
        Top = 4,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.Middle"]/*' />
        /// <devdoc>
        ///    <para>The middle of the image is aligned with the bottom of the first 
        ///       line of wrapping text.</para>
        /// </devdoc>
        Middle = 5,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.Bottom"]/*' />
        /// <devdoc>
        ///    <para>The bottom of the image is aligned with the bottom of the first line of wrapping text.</para>
        /// </devdoc>
        Bottom = 6,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.AbsBottom"]/*' />
        /// <devdoc>
        ///    <para>The bottom of the image is aligned with the bottom 
        ///       of the largest element on the same line.</para>
        /// </devdoc>
        AbsBottom = 7,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.AbsMiddle"]/*' />
        /// <devdoc>
        ///    <para> The middle of the image is aligned with the middle of the largest element on the 
        ///       same line.</para>
        /// </devdoc>
        AbsMiddle = 8,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.TextTop"]/*' />
        /// <devdoc>
        ///    <para>The image is aligned with the top of the the highest text on the same 
        ///       line.</para>
        /// </devdoc>
        TextTop = 9
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\label.cs ===
//------------------------------------------------------------------------------
// <copyright file="Label.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Web;
    using System.Web.UI;
    using System.ComponentModel;
    using System.Security.Permissions;

 
    /// <include file='doc\Label.uex' path='docs/doc[@for="LabelControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.Label'/> control.</para>
    /// </devdoc>
   [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
   [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
   public class LabelControlBuilder : ControlBuilder {
 
       /// <include file='doc\Label.uex' path='docs/doc[@for="LabelControlBuilder.AllowWhitespaceLiterals"]/*' />
       /// <internalonly/>
       /// <devdoc>
       ///    <para>Specifies whether white space literals are allowed.</para>
       /// </devdoc>
       public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }


    /// <include file='doc\Label.uex' path='docs/doc[@for="Label"]/*' />
    /// <devdoc>
    ///    <para>Constructs a label for displaying text programmatcially on a 
    ///       page.</para>
    /// </devdoc>
    [
    ControlBuilderAttribute(typeof(LabelControlBuilder)),
    DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultProperty("Text"),
    ParseChildren(false),
    Designer("System.Web.UI.Design.WebControls.LabelDesigner, " + AssemblyRef.SystemDesign),
    ToolboxData("<{0}:Label runat=server>Label</{0}:Label>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Label : WebControl {

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Label"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Label'/> class and renders 
        ///    it as a SPAN tag.</para>
        /// </devdoc>
        public Label() {
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Label1"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Label(HtmlTextWriterTag tag) : base(tag) {
        }


        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Text"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the text content of the <see cref='System.Web.UI.WebControls.Label'/> 
        /// control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.Label_Text),
        PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual string Text {
            get {
                object o = ViewState["Text"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                if (HasControls()) {
                    Controls.Clear();
                }
                ViewState["Text"] = value;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.AddParsedSubObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            if (HasControls()) {
                base.AddParsedSubObject(obj);
            }
            else {
                if (obj is LiteralControl) {
                    Text = ((LiteralControl)obj).Text;
                }
                else {
                    string currentText = Text;
                    if (currentText.Length != 0) {
                        Text = String.Empty;
                        base.AddParsedSubObject(new LiteralControl(currentText));
                    }
                    base.AddParsedSubObject(obj);
                }
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Load previously saved state.
        ///       Overridden to synchronize Text property with LiteralContent.</para>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                base.LoadViewState(savedState);
                string s = (string)ViewState["Text"];
                if (s != null)
                    Text = s;
            }
        }

        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Renders the contents of the <see cref='System.Web.UI.WebControls.Label'/> into the specified writer.</para>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            if (HasControls()) {
                base.RenderContents(writer);
            }
            else {
                writer.Write(Text);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\linkbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButtonControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.LinkButton'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LinkButtonControlBuilder : ControlBuilder {

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButtonControlBuilder.AllowWhitespaceLiterals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Specifies whether white space literals are allowed.</para>
        /// </devdoc>
        public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }


    /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton"]/*' />
    /// <devdoc>
    ///    <para>Constructs a link button and defines its properties.</para>
    /// </devdoc>
    [
    ControlBuilderAttribute(typeof(LinkButtonControlBuilder)),
    DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultEvent("Click"),
    DefaultProperty("Text"),
    ToolboxData("<{0}:LinkButton runat=server>LinkButton</{0}:LinkButton>"),
    Designer("System.Web.UI.Design.WebControls.LinkButtonDesigner, " + AssemblyRef.SystemDesign),
    ParseChildren(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LinkButton : WebControl, IPostBackEventHandler {

        private static readonly object EventClick = new object();
        private static readonly object EventCommand = new object();

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.LinkButton"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.LinkButton'/> class.</para>
        /// </devdoc>
        public LinkButton() : base(HtmlTextWriterTag.A) {
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.CommandName"]/*' />
        /// <devdoc>
        ///    <para>Specifies the command name that is propagated in the 
        ///    <see cref='System.Web.UI.WebControls.LinkButton.Command'/>event along with the associated <see cref='System.Web.UI.WebControls.LinkButton.CommandArgument'/> 
        ///    property.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.LinkButton_Command)
        ]
        public string CommandName {
            get {
                string s = (string)ViewState["CommandName"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["CommandName"] = value;
            }
        }


        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.CommandArgument"]/*' />
        /// <devdoc>
        ///    <para>Specifies the command argument that is propagated in the 
        ///    <see langword='Command '/>event along with the associated <see cref='System.Web.UI.WebControls.LinkButton.CommandName'/> 
        ///    property.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.LinkButton_CommandArgument)
        ]
        public string CommandArgument {
            get {
                string s = (string)ViewState["CommandArgument"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["CommandArgument"] = value;
            }
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets whether pressing the button causes page validation to fire. This defaults to True so that when
        ///          using validation controls, the validation state of all controls are updated when the button is clicked, both
        ///          on the client and the server. Setting this to False is useful when defining a cancel or reset button on a page
        ///          that has validators.</para>
        /// </devdoc>
        [
        Bindable(false),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.LinkButton_CausesValidation)
        ]
        public bool CausesValidation {
            get {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["CausesValidation"] = value;
            }
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.Text"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text display for the link button.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.LinkButton_Text),
        PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual string Text {
            get {
                object o = ViewState["Text"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                if (HasControls()) {
                    Controls.Clear();
                }
                ViewState["Text"] = value;
            }
        }


        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.Click"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the link button is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.LinkButton_OnClick)
        ]
        public event EventHandler Click {
            add {
                Events.AddHandler(EventClick, value);
            }
            remove {
                Events.RemoveHandler(EventClick, value);
            }
        }


        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.Command"]/*' />
        /// <devdoc>
        /// <para>Occurs when any item is clicked within the <see cref='System.Web.UI.WebControls.LinkButton'/> control tree.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.LinkButton_OnCommand)
        ]
        public event CommandEventHandler Command {
            add {
                Events.AddHandler(EventCommand, value);
            }
            remove {
                Events.RemoveHandler(EventCommand, value);
            }
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Render the attributes on the begin tag.
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            base.AddAttributesToRender(writer);

            if (Enabled && Page != null) {
                if (CausesValidation && Page.Validators.Count > 0) {
                    // LinkButton needs to explicitly call client validation functions to trigger validation.
                    writer.AddAttribute(HtmlTextWriterAttribute.Href, "javascript:" + Util.GetClientValidatedPostback(this));
                } else {
                    writer.AddAttribute(HtmlTextWriterAttribute.Href, Page.GetPostBackClientHyperlink(this, ""));
                }
            }
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.AddParsedSubObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            if (HasControls()) {
                base.AddParsedSubObject(obj);
            }
            else {
                if (obj is LiteralControl) {
                    Text = ((LiteralControl)obj).Text;
                }
                else {
                    string currentText = Text;
                    if (currentText.Length != 0) {
                        Text = String.Empty;
                        base.AddParsedSubObject(new LiteralControl(currentText));
                    }
                    base.AddParsedSubObject(obj);
                }
            }
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Load previously saved state.
        ///    Overridden to synchronize Text property with LiteralContent.
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                base.LoadViewState(savedState);
                string s = (string)ViewState["Text"];
                if (s != null)
                    Text = s;
            }
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.OnClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Click '/> event.</para>
        /// </devdoc>
        protected virtual void OnClick(EventArgs e) {
            EventHandler onClickHandler = (EventHandler)Events[EventClick];
            if (onClickHandler != null) onClickHandler(this,e);
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.OnCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Command'/> event.</para>
        /// </devdoc>
        protected virtual void OnCommand(CommandEventArgs e) {
            CommandEventHandler onCommandHandler = (CommandEventHandler)Events[EventCommand];
            if (onCommandHandler != null)
                onCommandHandler(this,e);

            // Command events are bubbled up the control heirarchy
            RaiseBubbleEvent(this, e);
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises a <see langword='Click '/>event upon postback 
        /// to the server, and a <see langword='Command'/> event if the <see cref='System.Web.UI.WebControls.LinkButton.CommandName'/>
        /// is defined.</para>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            if (CausesValidation) {
                Page.Validate();
            }
            OnClick(new EventArgs());
            OnCommand(new CommandEventArgs(CommandName, CommandArgument));
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null && Enabled)
                Page.RegisterPostBackScript();
        }

        /// <include file='doc\LinkButton.uex' path='docs/doc[@for="LinkButton.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            if (HasControls()) {
                base.RenderContents(writer);
            }
            else {
                writer.Write(Text);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\listitemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Security.Permissions;
 
    /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection"]/*' />
    /// <devdoc>
    /// <para>Encapsulates the items within a <see cref='System.Web.UI.WebControls.ListControl'/> . 
    ///    This class cannot be inherited.</para>
    /// </devdoc>
    [
    Editor("System.Web.UI.Design.WebControls.ListItemsCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ListItemCollection : ICollection, IList, IStateManager {

        private ArrayList listItems;
        private bool marked;
        private bool saveAll;
    
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.ListItemCollection"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Web.UI.WebControls.ListItemCollection'/> class.
        /// </devdoc>
        public ListItemCollection() {
            listItems = new ArrayList();
            marked = false;
            saveAll = false;
        }
        
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Web.UI.WebControls.ListItem'/> referenced by the specified ordinal 
        ///    index value.</para>
        /// </devdoc>
        public ListItem this[int index] {
            get {
                return (ListItem)listItems[index];
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return listItems[index];
            }
            set {
                listItems[index] = (ListItem)value;
            }
        }
    
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Capacity"]/*' />
        public int Capacity {
            get {
                return listItems.Capacity;
            }
            set {
                listItems.Capacity = value;
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the item count of the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                return listItems.Count;
            }
        }
        
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified item to the end of the collection.</para>
        /// </devdoc>
        public void Add(string item) {
            Add(new ListItem(item));
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Add1"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.Web.UI.WebControls.ListItem'/> to the end of the collection.</para>
        /// </devdoc>
        public void Add(ListItem item) {
            listItems.Add(item);
            if (marked) {
                item.Dirty = true;
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object item) {
            ListItem newItem = (ListItem) item;
            int returnValue = listItems.Add(newItem);
            if (marked) {
                newItem.Dirty = true;
            }
            return returnValue;
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.AddRange"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void AddRange(ListItem[] items) {
            if (items == null) {
                throw new ArgumentNullException("items");
            }
            foreach(ListItem item in items) {
                Add(item);
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Clear"]/*' />
        /// <devdoc>
        /// <para>Removes all <see cref='System.Web.UI.WebControls.ListItem'/> controls from the collection.</para>
        /// </devdoc>
        public void Clear() {
            listItems.Clear();
            if (marked)
                saveAll = true;
        }
            
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>Returns a value indicating whether the
        ///       collection contains the specified item.</para>
        /// </devdoc>
        public bool Contains(ListItem item) {
            return listItems.Contains(item);
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object item) {
            return Contains((ListItem) item);
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies contents from the collection to a specified <see cref='System.Array' qualify='true'/> with a 
        ///    specified starting index.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            listItems.CopyTo(array,index);
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.FindByText"]/*' />
        public ListItem FindByText(string text) {
            int index = FindByTextInternal(text);
            if (index != -1) {
                return (ListItem)listItems[index];
            }
            return null;
        }

        internal int FindByTextInternal(string text) {
            int i = 0;
            foreach (ListItem item in listItems) {
                if (item.Text.Equals(text)) {
                    return i;
                }
                i++;
            }
            return -1;
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.FindByValue"]/*' />
        public ListItem FindByValue(string value) {
            int index = FindByValueInternal(value);
            if (index != -1) {
                return (ListItem)listItems[index];
            }
            return null;
        }

        internal int FindByValueInternal(string value) {
            int i = 0;
            foreach (ListItem item in listItems) {
                if (item.Value.Equals(value)) {
                    return i;
                }
                i++;
            }
            return -1;
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Returns an enumerator of all <see cref='System.Web.UI.WebControls.ListItem'/> controls within the 
        ///    collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return listItems.GetEnumerator();
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns an ordinal index value that represents the 
        ///       position of the specified <see cref='System.Web.UI.WebControls.ListItem'/> within the collection.</para>
        /// </devdoc>
        public int IndexOf(ListItem item) {
            return listItems.IndexOf(item);
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object item) {
            return IndexOf((ListItem) item);
        }
        
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified item to the collection at the specified index 
        ///       location.</para>
        /// </devdoc>
        public void Insert(int index,string item) {
            Insert(index,new ListItem(item));
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Insert1"]/*' />
        /// <devdoc>
        /// <para>Inserts the specified <see cref='System.Web.UI.WebControls.ListItem'/> to the collection at the specified 
        ///    index location.</para>
        /// </devdoc>
        public void Insert(int index,ListItem item) {
            listItems.Insert(index,item);
            if (marked)
                saveAll = true;
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object item) {
            Insert(index, (ListItem) item);
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return listItems.IsReadOnly; }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether access to the collection is synchronized 
        ///       (thread-safe).</para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return listItems.IsSynchronized; }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// <para>Removes the <see cref='System.Web.UI.WebControls.ListItem'/> from the collection at the specified 
        ///    index location.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            listItems.RemoveAt(index);
            if (marked)
                saveAll = true;
        }
    
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified item from the collection.</para>
        /// </devdoc>
        public void Remove(string item) {
            int index = IndexOf(new ListItem(item));
            if (index >= 0) {
                RemoveAt(index);
            }
        }
    
        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.Remove1"]/*' />
        /// <devdoc>
        /// <para>Removes the specified <see cref='System.Web.UI.WebControls.ListItem'/> from the collection.</para>
        /// </devdoc>
        public void Remove(ListItem item) {
            int index = IndexOf(item);
            if (index >= 0) {
                RemoveAt(index);
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object item) {
            Remove((ListItem) item);
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object that can be used to synchronize access to the collection. In 
        ///       this case, it is the collection itself.</para>
        /// </devdoc>
        public object SyncRoot {
            get { return this; }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IStateManager.IsTrackingViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return true if tracking state changes.
        /// Method of private interface, IStateManager.
        /// </devdoc>
        bool IStateManager.IsTrackingViewState {
            get {
                return marked;
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IStateManager.LoadViewState"]/*' />
        /// <internalonly/>
        void IStateManager.LoadViewState(object state) {
            LoadViewState(state);
        }

        internal void LoadViewState(object state) {
            if (state != null) {
                if (state is Pair) {
                    // only changed items were saved
                    Pair p = (Pair) state;
                    ArrayList indices = (ArrayList) p.First;
                    ArrayList items = (ArrayList) p.Second;

                    for (int i=0; i<indices.Count; i++) {
                        int index = (int) indices[i];

                        if (index < Count)
                            this[index].LoadViewState(items[i]);
                        else {
                            ListItem li = new ListItem();
                            li.LoadViewState(items[i]);
                            Add(li);
                        }
                    }
                }
                else {
                    // all items were saved
                    Triplet t = (Triplet) state;

                    listItems = new ArrayList((int) t.First);
                    saveAll = true;

                    string[] texts  = (string[]) t.Second;
                    string[] values = (string[]) t.Third;

                    for (int i=0; i < texts.Length; i++) {
                        Add(new ListItem(texts[i], values[i]));
                    }
                }
            }
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IStateManager.TrackViewState"]/*' />
        /// <internalonly/>
        void IStateManager.TrackViewState() {
            TrackViewState();
        }

        internal void TrackViewState() {
            marked = true;
            for (int i=0; i < Count; i++)
                this[i].TrackViewState();
        }

        /// <include file='doc\ListItemCollection.uex' path='docs/doc[@for="ListItemCollection.IStateManager.SaveViewState"]/*' />
        /// <internalonly/>
        object IStateManager.SaveViewState() {
            return SaveViewState();
        }

        internal object SaveViewState() {
            if (saveAll == true) { 
                // save all items
                int count = Count;
                object[] texts = new string[count];
                object[] values = new string[count];
                for (int i=0; i < count; i++) {
                    texts[i] = this[i].Text;
                    values[i] =   this[i].Value;
                }
                return new Triplet(count, texts, values);
            }
            else { 
                // save only the changed items
                ArrayList indices = new ArrayList(4);
                ArrayList items = new ArrayList(4);

                for (int i=0; i < Count; i++) {
                    object item = this[i].SaveViewState();
                    if (item != null) { 
                        indices.Add(i);
                        items.Add(item);
                    }
                }
                if (indices.Count > 0)
                    return new Pair(indices, items);

                return null;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\listitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="listitem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using AttributeCollection = System.Web.UI.AttributeCollection;
    using System.Security.Permissions;

    /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItemControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.ListItem'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ListItemControlBuilder : ControlBuilder {
 
        /// <include file='doc\ListItem.uex' path='docs/doc[@for="ListItemControlBuilder.AllowWhitespaceLiterals"]/*' />
        public override bool AllowWhitespaceLiterals() {
            return false;
        }
 
        /// <include file='doc\ListItem.uex' path='docs/doc[@for="ListItemControlBuilder.HtmlDecodeLiterals"]/*' />
        public override bool HtmlDecodeLiterals() {
            // ListItem text gets rendered as an encoded attribute value.

            // At parse time text specified as an attribute gets decoded, and so text specified as a
            // literal needs to go through the same process.

            return true;
        }
    }

    /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem"]/*' />
    /// <devdoc>
    ///    <para>Constructs a list item control and defines
    ///       its properties. This class cannot be inherited.</para>
    /// </devdoc>
    [
    ControlBuilderAttribute(typeof(ListItemControlBuilder)),   
    TypeConverterAttribute(typeof(ExpandableObjectConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ListItem : IStateManager, IParserAccessor, IAttributeAccessor {

        private const int SELECTED = 0;
        private const int MARKED = 1;
        private const int TEXTISDIRTY = 2;
        private const int VALUEISDIRTY = 3;

        private string text;
        private string value;
        private BitArray misc;
        private AttributeCollection _attributes;

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.ListItem"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ListItem'/> class.</para>
        /// </devdoc>
        public ListItem() : this(null, null) {
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.ListItem1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ListItem'/> class with the specified text data.</para>
        /// </devdoc>
        public ListItem(string text) : this(text, null) {
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.ListItem2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ListItem'/> class with the 
        ///    specified text and value data.</para>
        /// </devdoc>
        public ListItem(string text, string value) {
            this.text = text;
            this.value = value;
            misc = new BitArray(4);
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Attributes"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of attribute name/value pairs expressed on the list item 
        ///       control but not supported by the control's strongly typed properties.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public AttributeCollection Attributes {
            get {
                if (_attributes == null)
                    _attributes = new AttributeCollection(new StateBag(true));

                return _attributes;
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Dirty"]/*' />
        /// <devdoc>
        ///  Internal property used to manage dirty state of ListItem.
        /// </devdoc>
        internal bool Dirty {
            get { 
                return (misc.Get(TEXTISDIRTY) || misc.Get(VALUEISDIRTY)); 
            }
            set { 
                misc.Set(TEXTISDIRTY,value); 
                misc.Set(VALUEISDIRTY,value); 
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Selected"]/*' />
        /// <devdoc>
        ///    <para>Specifies a value indicating whether the
        ///       item is selected.</para>
        /// </devdoc>
        [
        DefaultValue(false)
        ]
        public bool Selected {
            get { 
                return misc.Get(SELECTED); 
            }
            set { 
                misc.Set(SELECTED,value); 
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Text"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the display text of the list
        ///       item control.</para>
        /// </devdoc>
        [
        DefaultValue(""),
        PersistenceMode(PersistenceMode.EncodedInnerDefaultProperty)
        ]
        public string Text {
            get {
                if (text != null)
                    return text;
                if (value != null)
                    return value;
                return String.Empty;
            }
            set {
                text = value;
                if (((IStateManager)this).IsTrackingViewState)
                    misc.Set(TEXTISDIRTY,true);
            }
        }
        
        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Value"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value content of the list item control.</para>
        /// </devdoc>
        [
        DefaultValue("")
        ]
        public string Value {
            get {
                if (value != null)
                    return value;
                if (text != null)
                    return text;
                return String.Empty;
            }
            set {
                this.value = value;
                if (((IStateManager)this).IsTrackingViewState)
                    misc.Set(VALUEISDIRTY,true);
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.GetHashCode"]/*' />
        /// <internalonly/>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object o) {
            ListItem other = o as ListItem;

            if (other != null) {
                return Value.Equals(other.Value) && Text.Equals(other.Text);
            }
            return false;
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.FromString"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Web.UI.WebControls.ListItem'/> from the specified string.</para>
        /// </devdoc>
        public static ListItem FromString(string s) {
            return new ListItem(s);
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override string ToString() {
            return this.Text;
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IStateManager.IsTrackingViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return true if tracking state changes.
        /// Method of private interface, IStateManager.
        /// </devdoc>
        bool IStateManager.IsTrackingViewState {
            get {
                return misc.Get(MARKED);
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IStateManager.LoadViewState"]/*' />
        /// <internalonly/>
        void IStateManager.LoadViewState(object state) {
            LoadViewState(state);
        }

        internal void LoadViewState(object state) {
            if (state != null) {
                if (state is Pair) {
                    Pair p = (Pair) state;
                    if (p.First != null)
                        Text = (string) p.First;
                    Value = (string) p.Second;
                }
                else
                    Text = (string) state;
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IStateManager.TrackViewState"]/*' />
        /// <internalonly/>
        void IStateManager.TrackViewState() {
            TrackViewState();
        }

        internal void TrackViewState() {
            misc.Set(MARKED,true);
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IStateManager.SaveViewState"]/*' />
        /// <internalonly/>
        object IStateManager.SaveViewState() {
            return SaveViewState();
        }

        internal object SaveViewState() {
            if (misc.Get(TEXTISDIRTY) && misc.Get(VALUEISDIRTY))
                return new Pair(Text, Value);
            if (misc.Get(TEXTISDIRTY))
                return Text;
            if (misc.Get(VALUEISDIRTY))
                return new Pair(null, Value);
            return null;
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IAttributeAccessor.GetAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Returns the attribute value of the list item control
        /// having the specified attribute name.
        /// </devdoc>
        string IAttributeAccessor.GetAttribute(string name) {
            return Attributes[name];
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IAttributeAccessor.SetAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Sets an attribute of the list
        /// item control with the specified name and value.</para>
        /// </devdoc>
        void IAttributeAccessor.SetAttribute(string name, string value) {
            Attributes[name] = value;
        }


        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.IParserAccessor.AddParsedSubObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows the <see cref='System.Web.UI.WebControls.ListItem.Text'/> 
        /// property to be persisted as inner content.</para>
        /// </devdoc>
        void IParserAccessor.AddParsedSubObject(object obj) {
            if (obj is LiteralControl) {
                Text = ((LiteralControl)obj).Text;
            }
            else {
                if (obj is DataBoundLiteralControl)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Control_Cannot_Databind, "ListItem"));
                else 
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "ListItem", obj.GetType().Name.ToString()));
            }
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\listbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="Listbox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Drawing;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;


    /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox"]/*' />
    /// <devdoc>
    ///    <para>Constructs a list box and defines its
    ///       properties.</para>
    /// </devdoc>
    [
    ValidationProperty("SelectedItem")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ListBox : ListControl, IPostBackDataHandler {


        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.ListBox"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ListBox'/> class.</para>
        /// </devdoc>
        public ListBox() {
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public override Color BorderColor {
            get {
                return base.BorderColor;
            }
            set {
                base.BorderColor = value;
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public override BorderStyle BorderStyle {
            get {
                return base.BorderStyle;
            }
            set {
                base.BorderStyle = value;
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.BorderWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public override Unit BorderWidth {
            get {
                return base.BorderWidth;
            }
            set {
                base.BorderWidth = value;
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.Rows"]/*' />
        /// <devdoc>
        ///    <para> Gets or
        ///       sets the display height (in rows) of the list box.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(4),
        WebSysDescription(SR.ListBox_Rows)
        ]
        public virtual int Rows {
            get {
                object n = ViewState["Rows"];
                return((n == null) ? 4 : (int)n);
            }
            set {
                if (value < 1 || value > 2000) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Rows"] = value;
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.SelectionMode"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the selection behavior of the list box.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(ListSelectionMode.Single),
        WebSysDescription(SR.ListBox_SelectionMode)
        ]
        public virtual ListSelectionMode SelectionMode {
            get {
                object sm = ViewState["SelectionMode"];
                return((sm == null) ? ListSelectionMode.Single : (ListSelectionMode)sm);
            }
            set {
                if (value < ListSelectionMode.Single || value > ListSelectionMode.Multiple) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["SelectionMode"] = value;
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="Listbox.ToolTip"]/*' />
        [
        Bindable(false),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        EditorBrowsableAttribute(EditorBrowsableState.Never)
        ]
        public override string ToolTip {
            get {
                return String.Empty;
            }
            set {
                // NOTE: do not throw a NotSupportedException here.
                //       In WebControl::CopyBaseAttributes we copy over attributes to a target control,
                //       including ToolTip. We should not throw in that case, but just ignore the setting.
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Adds name, size, multiple, and onchange to list of attributes to render.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            writer.AddAttribute(HtmlTextWriterAttribute.Name,UniqueID);

            writer.AddAttribute(HtmlTextWriterAttribute.Size, (Rows).ToString(NumberFormatInfo.InvariantInfo));
            if (SelectionMode == ListSelectionMode.Multiple)
                writer.AddAttribute(HtmlTextWriterAttribute.Multiple,"multiple");

            if (AutoPostBack && Page != null) {
                // ASURT 98368
                // Need to merge the autopostback script with the user script
                string onChange = Page.GetPostBackClientEvent(this, "");
                if (HasAttributes) {
                    string userOnChange = Attributes["onchange"];
                    if (userOnChange != null) {
                        onChange = userOnChange + onChange;
                        Attributes.Remove("onchange");
                    }
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onchange, onChange);
                writer.AddAttribute("language", "javascript");
            }

            base.AddAttributesToRender(writer);
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Loads the posted content of the list control if it is different from the last
        /// posting.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(String postDataKey, NameValueCollection postCollection) {
            string[] selectedItems = postCollection.GetValues(postDataKey);
            bool selectionChanged = false;

            if (selectedItems != null) {
                if (SelectionMode == ListSelectionMode.Single) {
                    int n = Items.FindByValueInternal(selectedItems[0]);
                    if (SelectedIndex != n) {
                        SelectedIndex = n;
                        selectionChanged = true;
                    }
                }
                else { // multiple selection
                    int count = selectedItems.Length;
                    ArrayList oldSelectedIndices = SelectedIndicesInternal;
                    ArrayList newSelectedIndices = new ArrayList(count);
                    for (int i=0; i < count; i++) {
                        // create array of new indices from posted values
                        newSelectedIndices.Add(Items.FindByValueInternal(selectedItems[i]));
                    }

                    int oldcount = 0;
                    if (oldSelectedIndices != null)
                        oldcount = oldSelectedIndices.Count;

                    if (oldcount == count) {
                        // check new indices against old indices
                        // assumes selected values are posted in order
                        for (int i=0; i < count; i++) {
                            if (((int)newSelectedIndices[i]) != ((int)oldSelectedIndices[i])) {
                                selectionChanged = true;
                                break;
                            }
                        }
                    }
                    else {
                        // indices must have changed if count is different
                        selectionChanged = true;
                    }

                    if (selectionChanged) {
                        // select new indices
                        SelectInternal(newSelectedIndices);
                    }
                }
            }
            else { // no items selected
                if (SelectedIndex != -1) {
                    SelectedIndex = -1;
                    selectionChanged = true;
                }
            }
            return selectionChanged;
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null && SelectionMode == ListSelectionMode.Multiple && Enabled) {
                // ensure postback when no item is selected
                Page.RegisterRequiresPostBack(this);
            }
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Invokes the OnSelectedIndexChanged method whenever posted data
        /// for the <see cref='System.Web.UI.WebControls.ListBox'/> control has changed.</para>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnSelectedIndexChanged(EventArgs.Empty);
        }

        /// <include file='doc\Listbox.uex' path='docs/doc[@for="ListBox.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            bool selected = false;
            bool isSingle = (SelectionMode == ListSelectionMode.Single);

            ListItemCollection liCollection = Items;
            int n = liCollection.Count;
            if (n > 0) {
                for (int i=0; i < n; i++) {
                    ListItem li = liCollection[i];
                    writer.WriteBeginTag("option");
                    if (li.Selected) {
                        if (isSingle)
                        {
                            if (selected)
                                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cant_Multiselect_In_Single_Mode));
                            selected=true;
                        }
                        writer.WriteAttribute("selected", "selected");
                    }

                    writer.WriteAttribute("value", li.Value, true /*fEncode*/);

                    writer.Write(HtmlTextWriter.TagRightChar);
                    HttpUtility.HtmlEncode(li.Text, writer);
                    writer.WriteEndTag("option");
                    writer.WriteLine();
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\listitemtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListItemType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    
    /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType"]/*' />
    /// <devdoc>
    ///    <para>Specifies the type of the item in a list.</para>
    /// </devdoc>
    public enum ListItemType {
        
        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.Header"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       A header. It is not databound.</para>
        /// </devdoc>
        Header = 0,

        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.Footer"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       A footer. It is not databound.</para>
        /// </devdoc>
        Footer = 1,
        
        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.Item"]/*' />
        /// <devdoc>
        ///    An item. It is databound.
        /// </devdoc>
        Item = 2,

        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.AlternatingItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       An alternating (even-indexed) item. It is databound.</para>
        /// </devdoc>
        AlternatingItem = 3,

        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.SelectedItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       The selected item. It is databound.</para>
        /// </devdoc>
        SelectedItem = 4,

        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.EditItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       The item in edit mode. It is databound.</para>
        /// </devdoc>
        EditItem = 5,
        
        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.Separator"]/*' />
        /// <devdoc>
        ///    <para> A separator. It is not databound.</para>
        /// </devdoc>
        Separator = 6,

        /// <include file='doc\ListItemType.uex' path='docs/doc[@for="ListItemType.Pager"]/*' />
        /// <devdoc>
        ///    <para> A pager. It is used for rendering paging (page accessing) UI associated 
        ///       with the <see cref='System.Web.UI.WebControls.DataGrid'/> control and is not
        ///       databound.</para>
        /// </devdoc>
        Pager = 7
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\listselectionmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListSelectionMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\ListSelectionMode.uex' path='docs/doc[@for="ListSelectionMode"]/*' />
    /// <devdoc>
    ///    <para>Specifies the selection behavior of list controls.</para>
    /// </devdoc>
    public enum ListSelectionMode {
    
        /// <include file='doc\ListSelectionMode.uex' path='docs/doc[@for="ListSelectionMode.Single"]/*' />
        /// <devdoc>
        ///    <para>The list control allows only one item to be selected at one time.</para>
        /// </devdoc>
        Single = 0,
    
        /// <include file='doc\ListSelectionMode.uex' path='docs/doc[@for="ListSelectionMode.Multiple"]/*' />
        /// <devdoc>
        ///    <para> The list control allows multiple items to be selected at one time.</para>
        /// </devdoc>
        Multiple = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\listcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl"]/*' />
    /// <devdoc>
    ///    <para>An abstract base class. Defines the common
    ///       properties, methods, and events for all list-type controls.</para>
    /// </devdoc>
    [
    DataBindingHandler("System.Web.UI.Design.WebControls.ListControlDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultEvent("SelectedIndexChanged"),
    DefaultProperty("DataSource"),
    ParseChildren(true, "Items"),
    Designer("System.Web.UI.Design.WebControls.ListControlDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class ListControl : WebControl {

        private static readonly object EventSelectedIndexChanged = new object();

        private static readonly char [] SPLIT_CHARS = new char[] { ','};

        private ListItemCollection items;
        private object dataSource;
        private int cachedSelectedIndex;
        private string cachedSelectedValue;

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.ListControl"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ListControl'/> class.</para>
        /// </devdoc>
        public ListControl() : base(HtmlTextWriterTag.Select) {
            cachedSelectedIndex = -1;
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.AutoPostBack"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value
        ///       indicating whether an automatic postback to the server will occur whenever the
        ///       user changes the selection of the list.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(false),
        WebSysDescription(SR.ListControl_AutoPostBack)
        ]
        public virtual bool AutoPostBack {
            get {
                object b = ViewState["AutoPostBack"];
                return((b == null) ? false : (bool)b);
            }
            set {
                ViewState["AutoPostBack"] = value;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        WebCategory("Data"),
        WebSysDescription(SR.ListControl_DataMember)
        ]
        public virtual string DataMember {
            get {
                object o = ViewState["DataMember"];
                if (o != null)
                    return (string)o;
                return String.Empty;
            }
            set {
                ViewState["DataMember"] = value;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataSource"]/*' />
        /// <devdoc>
        ///    <para> Gets
        ///       or sets the data source that provides data
        ///       for populating the items of the list control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Data"),
        DefaultValue(null),
        WebSysDescription(SR.ListControl_DataSource),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual object DataSource {
            get {
                return dataSource;
            }
            set {
                if ((value == null) || (value is IListSource) || (value is IEnumerable)) {
                    dataSource = value;
                }
                else {
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_DataSource_Type, ID));
                }
            }
        }
        
        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataTextField"]/*' />
        /// <devdoc>
        ///    <para> Indicates the field of the
        ///       data source that provides the text content of the list items.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.ListControl_DataTextField)
        ]
        public virtual string DataTextField {
            get {
                object s = ViewState["DataTextField"];
                return((s == null) ? String.Empty : (string)s);
            }
            set {
                ViewState["DataTextField"] = value;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataTextFormatString"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.ListControl_DataTextFormatString)
        ]
        public virtual string DataTextFormatString {
            get {
                object s = ViewState["DataTextFormatString"];
                return ((s == null) ? String.Empty : (string)s);
            }
            set {
                ViewState["DataTextFormatString"] = value;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.DataValueField"]/*' />
        /// <devdoc>
        ///    <para>Indicates the field of the data source that provides the value content of the 
        ///       list items.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.ListControl_DataValueField)
        ]
        public virtual string DataValueField {
            get {
                object s = ViewState["DataValueField"];
                return((s == null) ? String.Empty : (string)s);
            }
            set {
                ViewState["DataValueField"] = value;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.Items"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the collection of items within the list.
        ///       This property
        ///       is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Default"),
        DefaultValue(null),
        MergableProperty(false),
        WebSysDescription(SR.ListControl_Items),
        PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual ListItemCollection Items {
            get {
                if (items == null) {
                    items = new ListItemCollection();
                    if (IsTrackingViewState)
                        items.TrackViewState();
                }
                return items;
            }
        }

        /// <devdoc>
        ///    Determines whether the SelectedIndices must be stored in view state, to
        ///    optimize the size of the saved state.
        /// </devdoc>
        private bool SaveSelectedIndicesViewState {
            get {
                // Must be saved when
                // 1. There is a registered event handler for SelectedIndexChanged
                // 2. Control is not enabled or visible, because the browser's post data will not include this control
                // 3. The instance is a derived instance, which might be overriding the OnSelectedIndexChanged method
                //    This is a bit hacky, since we have to cover all the four derived classes we have...

                if ((Events[EventSelectedIndexChanged] != null) ||
                    (Enabled == false) ||
                    (Visible == false)) {
                    return true;
                }

                Type t = this.GetType();
                if ((t == typeof(DropDownList)) ||
                    (t == typeof(ListBox)) ||
                    (t == typeof(CheckBoxList)) ||
                    (t == typeof(RadioButtonList))) {
                    return false;
                }

                return true;
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para>Indicates the ordinal index of the first selected item within the 
        ///       list.</para>
        /// </devdoc>
        [
        Bindable(true),
        Browsable(false),
        WebCategory("Behavior"),
        DefaultValue(0),
        WebSysDescription(SR.ListControl_SelectedIndex),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual int SelectedIndex {
            get {
                for (int i=0; i < Items.Count; i++) {
                    if (Items[i].Selected)
                        return i;
                }
                return -1;
            }
            set {
                // if we have no items, save the selectedindex
                // for later databinding
                if (Items.Count == 0) {
                    cachedSelectedIndex = value;
                }
                else {
                    if (value < -1 || value >= Items.Count) {
                        throw new ArgumentOutOfRangeException("value");
                    }
                    ClearSelection();
                    if (value >= 0)
                        Items[value].Selected = true;
                }
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedIndicesInternal"]/*' />
        /// <devdoc>
        ///    <para>A protected property. Gets an array of selected
        ///       indexes within the list. This property is read-only.</para>
        /// </devdoc>
        internal virtual ArrayList SelectedIndicesInternal {
            get {
                ArrayList selectedIndices = null; 
                for (int i=0; i < Items.Count; i++) {
                    if (Items[i].Selected)  {
                        if (selectedIndices == null)
                            selectedIndices = new ArrayList(3);
                        selectedIndices.Add(i);
                    }
                }
                return selectedIndices;
            }
        }


        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedItem"]/*' />
        /// <devdoc>
        ///    <para>Indicates the first selected item within the list.
        ///       This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        Browsable(false),
        DefaultValue(null),
        WebSysDescription(SR.ListControl_SelectedItem),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual ListItem SelectedItem{
            get {
                int i = SelectedIndex;
                return(i < 0) ? null : Items[i];
			}
        }


        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedValue"]/*' />
        /// <devdoc>
        ///    <para>Indicates the value of the first selected item within the 
        ///       list.</para>
        /// </devdoc>
        [
        Bindable(true),
        Browsable(false),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.ListControl_SelectedValue),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual string SelectedValue {
            get	{
                int i =	SelectedIndex;
                return (i < 0) ? String.Empty : Items[i].Value;
            }
            set	{
                // if we have no items,	save the selectedvalue
                // for later databinding
                if (Items.Count	== 0) {
                    cachedSelectedValue	= value;
                }
                else {
                    if (value == null) {
                        ClearSelection();
                        return;
                    }

                    ListItem selectItem	= Items.FindByValue(value);
                
                    if (selectItem == null) {
                        throw new ArgumentOutOfRangeException(value);
                    }

                    ClearSelection();
                    selectItem.Selected = true;
                }
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    Occurs when the list selection is changed upon server
        ///    postback.
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.ListControl_OnSelectedIndexChanged)
        ]
        public event EventHandler SelectedIndexChanged {
            add {
                Events.AddHandler(EventSelectedIndexChanged, value);
            }
            remove {
                Events.RemoveHandler(EventSelectedIndexChanged, value);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.ClearSelection"]/*' />
        /// <devdoc>
        ///    <para> Clears out the list selection and sets the 
        ///    <see cref='System.Web.UI.WebControls.ListItem.Selected'/> property
        ///       of all items to false.</para>
        /// </devdoc>
        public virtual void ClearSelection() {
            for (int i=0; i < Items.Count; i++)
                Items[i].Selected = false;
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Load previously saved state.
        ///    Overridden to restore selection.
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                Triplet statetriplet = (Triplet)savedState;
                base.LoadViewState(statetriplet.First);

                // restore state of items
                Items.LoadViewState(statetriplet.Second);

                // restore selected indices
                object selectedIndices = statetriplet.Third;
                if (selectedIndices != null)
                    SelectInternal((ArrayList)selectedIndices);
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void TrackViewState() {
            base.TrackViewState();
            Items.TrackViewState();
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnDataBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnDataBinding(EventArgs e) {
            base.OnDataBinding(e);

            // create items using the datasource
            IEnumerable dataSource = DataSourceHelper.GetResolvedDataSource(this.DataSource, this.DataMember);

            if (dataSource != null) {
                bool fieldsSpecified = false;
                bool formatSpecified = false;

                string textField = DataTextField;
                string valueField = DataValueField;
                string textFormat = DataTextFormatString;

                Items.Clear();
                ICollection collection = dataSource as ICollection;
                if (collection != null) {
                    Items.Capacity = collection.Count;
                }

                if ((textField.Length != 0) || (valueField.Length != 0)) {
                    fieldsSpecified = true;
                }
                if (textFormat.Length != 0) {
                    formatSpecified = true;
                }

                foreach (object dataItem in dataSource) {
                    ListItem item = new ListItem();

                    if (fieldsSpecified) {
                        if (textField.Length > 0) {
                            item.Text = DataBinder.GetPropertyValue(dataItem, textField, textFormat);
                        }
                        if (valueField.Length > 0) {
                            item.Value = DataBinder.GetPropertyValue(dataItem, valueField, null);
                        }
                    }
                    else {
                        if (formatSpecified) {
                            item.Text = String.Format(textFormat, dataItem);
                        }
                        else {
                            item.Text = dataItem.ToString();
                        }
                        item.Value = dataItem.ToString();
                    }

                    Items.Add(item);
                }
            }

            // try to apply the cached SelectedIndex and SelectedValue now
            if (cachedSelectedValue != null) {
                int cachedSelectedValueIndex = -1;

                cachedSelectedValueIndex = Items.FindByValueInternal(cachedSelectedValue);
                if (-1 == cachedSelectedValueIndex) {
                    throw new ArgumentOutOfRangeException("value");
                }

                if ((cachedSelectedIndex != -1) && (cachedSelectedIndex != cachedSelectedValueIndex))
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Attributes_mutually_exclusive, "SelectedIndex", "SelectedValue"));  
   
                SelectedIndex = cachedSelectedValueIndex;
                cachedSelectedValue = null;
                cachedSelectedIndex = -1;
            }
            else {
                if (cachedSelectedIndex != -1) {
                    SelectedIndex = cachedSelectedIndex;
                    cachedSelectedIndex = -1;
                }
            }
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    <para> A protected method. Raises the 
        ///    <see langword='SelectedIndexChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnSelectedIndexChanged(EventArgs e) {
            EventHandler onChangeHandler = (EventHandler)Events[EventSelectedIndexChanged];
            if (onChangeHandler != null) onChangeHandler(this, e);
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null && Enabled && AutoPostBack)
                Page.RegisterPostBackScript();
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override object SaveViewState() {
            object baseState = base.SaveViewState();
            object items = Items.SaveViewState();
            object selectedIndicesState = null;

            if (SaveSelectedIndicesViewState) {
                selectedIndicesState = SelectedIndicesInternal;
            }

            if (selectedIndicesState  != null || items != null || baseState != null)
                return new Triplet(baseState, items, selectedIndicesState);
            
            return null;
        }

        /// <include file='doc\ListControl.uex' path='docs/doc[@for="ListControl.SelectInternal"]/*' />
        /// <devdoc>
        ///    Sets items within the
        ///    list to be selected according to the specified array of indexes.
        /// </devdoc>
        internal void SelectInternal(ArrayList selectedIndices) {
            ClearSelection();
            for (int i=0; i < selectedIndices.Count; i++) {
                int n = (int) selectedIndices[i];
                if (n >= 0 && n < Items.Count)
                    Items[n].Selected = true;
            }
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\monthchangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="MonthChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.Security.Permissions;

    /// <include file='doc\MonthChangedEventArgs.uex' path='docs/doc[@for="MonthChangedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>Provides data for the 
    ///    <see langword='VisibleMonthChanged'/> event.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class MonthChangedEventArgs {
        DateTime newDate, previousDate;

        /// <include file='doc\MonthChangedEventArgs.uex' path='docs/doc[@for="MonthChangedEventArgs.MonthChangedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.MonthChangedEventArgs'/> class.</para>
        /// </devdoc>
        public MonthChangedEventArgs(DateTime newDate, DateTime previousDate) {
            this.newDate = newDate;
            this.previousDate = previousDate;
        }

        /// <include file='doc\MonthChangedEventArgs.uex' path='docs/doc[@for="MonthChangedEventArgs.NewDate"]/*' />
        /// <devdoc>
        ///    <para> Gets the date that determines the month currently 
        ///       displayed by the <see cref='System.Web.UI.WebControls.Calendar'/> .</para>
        /// </devdoc>
        public DateTime NewDate {
            get {
                return newDate;
            }
        } 

        /// <include file='doc\MonthChangedEventArgs.uex' path='docs/doc[@for="MonthChangedEventArgs.PreviousDate"]/*' />
        /// <devdoc>
        ///    <para> Gets the date that determines the month previously displayed 
        ///       by the <see cref='System.Web.UI.WebControls.Calendar'/>.</para>
        /// </devdoc>
        public DateTime PreviousDate {
            get {
                return previousDate;
            }
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\monthchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="MonthChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.UI.WebControls {

    /// <include file='doc\MonthChangedEventHandler.uex' path='docs/doc[@for="MonthChangedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see langword='VIsibleMonthChanged '/>event of a <see cref='System.Web.UI.WebControls.Calendar'/> .</para>
    /// </devdoc>
    public delegate void MonthChangedEventHandler(object sender, MonthChangedEventArgs e);    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\literal.cs ===
//------------------------------------------------------------------------------
// <copyright file="Literal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\Literal.uex' path='docs/doc[@for="LiteralControlBuilder"]/*' />
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LiteralControlBuilder : ControlBuilder {

        /// <include file='doc\Literal.uex' path='docs/doc[@for="LiteralControlBuilder.AppendSubBuilder"]/*' />
        public override void AppendSubBuilder(ControlBuilder subBuilder) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Control_does_not_allow_children,
                typeof(Literal).ToString()));
        }

        /// <include file='doc\Literal.uex' path='docs/doc[@for="LiteralControlBuilder.AllowWhitespaceLiterals"]/*' />
        public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }

    // The reason we define this empty override in the WebControls namespace is
    // to expose it as a control that can be used on a page (ASURT 54683)
    // E.g. <asp:literal runat=server id=lit1/>
    /// <include file='doc\Literal.uex' path='docs/doc[@for="Literal"]/*' />
    [
    DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultProperty("Text"),
    ControlBuilderAttribute(typeof(LiteralControlBuilder)),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Literal : Control {

        /// <include file='doc\Literal.uex' path='docs/doc[@for="Literal.Text"]/*' />
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.Literal_Text),
        ]
        public string Text {
            get {
                string s = (string)ViewState["Text"];
                return (s != null) ? s : String.Empty;
            }
            set {
                ViewState["Text"] = value;
            }
        }

        /// <include file='doc\Literal.uex' path='docs/doc[@for="Literal.Render"]/*' />
        protected override void Render(HtmlTextWriter output) {
            string text = Text;
            if (text.Length != 0) {
                output.Write(text);
            }
        }

        /// <include file='doc\Literal.uex' path='docs/doc[@for="Literal.CreateControlCollection"]/*' />
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }
    
        /// <include file='doc\Literal.uex' path='docs/doc[@for="Literal.AddParsedSubObject"]/*' />
        /// <internalonly/>
        protected override void AddParsedSubObject(object obj) {
            if (obj is LiteralControl) {
                Text = ((LiteralControl)obj).Text;
            }
            else {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "Literal", obj.GetType().Name.ToString()));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\nextprevformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="NextPrevFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\NextPrevFormat.uex' path='docs/doc[@for="NextPrevFormat"]/*' />
    /// <devdoc>
    ///    <para> Specifies the display format of the month on the Previous Month
    ///       and Next Month buttons within the <see cref='System.Web.UI.WebControls.Calendar'/> control.</para>
    /// </devdoc>
    public enum NextPrevFormat {
        /// <include file='doc\NextPrevFormat.uex' path='docs/doc[@for="NextPrevFormat.CustomText"]/*' />
        /// <devdoc>
        ///    <para> Custom text is used.</para>
        /// </devdoc>
        CustomText = 0,
        /// <include file='doc\NextPrevFormat.uex' path='docs/doc[@for="NextPrevFormat.ShortMonth"]/*' />
        /// <devdoc>
        ///    A short month format is used. For example,
        ///    Jan.
        /// </devdoc>
        ShortMonth = 1,
        /// <include file='doc\NextPrevFormat.uex' path='docs/doc[@for="NextPrevFormat.FullMonth"]/*' />
        /// <devdoc>
        ///    A full month format is used. For
        ///    example, January.
        /// </devdoc>
        FullMonth = 2
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\pagerposition.cs ===
//------------------------------------------------------------------------------
// <copyright file="PagerPosition.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\PagerPosition.uex' path='docs/doc[@for="PagerPosition"]/*' />
    /// <devdoc>
    ///    <para>Specifies the position of the Pager item
    ///       (for accessing various pages) within the <see cref='System.Web.UI.WebControls.DataGrid'/> control.</para>
    /// </devdoc>
    public enum PagerPosition {

        /// <include file='doc\PagerPosition.uex' path='docs/doc[@for="PagerPosition.Bottom"]/*' />
        /// <devdoc>
        /// <para>Positioned at the bottom of the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        Bottom = 0,

        /// <include file='doc\PagerPosition.uex' path='docs/doc[@for="PagerPosition.Top"]/*' />
        /// <devdoc>
        /// <para>Positioned at the top of the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        Top = 1,

        /// <include file='doc\PagerPosition.uex' path='docs/doc[@for="PagerPosition.TopAndBottom"]/*' />
        /// <devdoc>
        /// <para>Positioned at the top and the bottom of the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        TopAndBottom = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\pageddatasource.cs ===
//------------------------------------------------------------------------------
// <copyright file="PagedDataSource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource"]/*' />
    /// <devdoc>
    ///    <para>Provides a wrapper over an ICollection datasource to implement paging 
    ///       semantics or 'paged views' on top of the underlying datasource.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PagedDataSource : ICollection, ITypedList {

        private IEnumerable dataSource;
        private int currentPageIndex;
        private int pageSize;
        private bool allowPaging;
        private bool allowCustomPaging;
        private int virtualCount;

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.PagedDataSource"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.PagedDataSource'/> class.</para>
        /// </devdoc>
        public PagedDataSource() {
            this.pageSize = 10;
            this.allowPaging = false;
            this.currentPageIndex = 0;
            this.allowCustomPaging = false;
            this.virtualCount = 0;
        }


        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.AllowCustomPaging"]/*' />
        /// <devdoc>
        ///    Indicates whether to assume the underlying datasource
        ///    contains data for just the current page.
        /// </devdoc>
        public bool AllowCustomPaging {
            get {
                return allowCustomPaging;
            }
            set {
                allowCustomPaging = value;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.AllowPaging"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether to implement page semantics on top of the underlying datasource.</para>
        /// </devdoc>
        public bool AllowPaging {
            get {
                return allowPaging;
            }
            set {
                allowPaging = value;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.Count"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Specifies the number of items
        ///       to be used from the datasource.</para>
        /// </devdoc>
        public int Count {
            get {
                if (dataSource == null)
                    return 0;

                if (IsPagingEnabled) {
                    if (IsCustomPagingEnabled || (IsLastPage == false)) {
                        // In custom paging the datasource can contain at most
                        // a single page's worth of data.
                        // In non-custom paging, all pages except last one have
                        // a full page worth of data.
                        return pageSize;
                    }
                    else {
                        // last page might have fewer items in datasource
                        return DataSourceCount - FirstIndexInPage;
                    }
                }
                else {
                    return DataSourceCount;
                }
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.CurrentPageIndex"]/*' />
        /// <devdoc>
        ///    <para>Indicates the index of the current page.</para>
        /// </devdoc>
        public int CurrentPageIndex {
            get {
                return currentPageIndex;
            }
            set {
                currentPageIndex = value;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.DataSource"]/*' />
        /// <devdoc>
        ///    <para> Indicates the data source.</para>
        /// </devdoc>
        public IEnumerable DataSource {
            get {
                return dataSource;
            }
            set {
                dataSource = value;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.DataSourceCount"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int DataSourceCount {
            get {
                if (dataSource == null)
                    return 0;
                if (IsCustomPagingEnabled) {
                    return virtualCount;
                }
                else {
                    if (dataSource is ICollection) {
                        return ((ICollection)dataSource).Count;
                    }
                    else {
                        // The caller should not call this in the case of an IEnumerator datasource
                        // This is required for paging, but the assumption is that the user will set
                        // up custom paging.
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.PagedDataSource_Cannot_Get_Count));
                    }
                }
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.FirstIndexInPage"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int FirstIndexInPage {
            get {
                if ((dataSource == null) || (IsPagingEnabled == false)) {
                    return 0;
                }
                else {
                    if (IsCustomPagingEnabled) {
                        // In this mode, all the data belongs to the current page.
                        return 0;
                    }
                    else {
                        return currentPageIndex * pageSize;
                    }
                }
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.IsCustomPagingEnabled"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsCustomPagingEnabled {
            get {   
                return IsPagingEnabled && allowCustomPaging;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.IsFirstPage"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsFirstPage {
            get {
                if (IsPagingEnabled)
                    return(CurrentPageIndex == 0);
                else
                    return true;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.IsLastPage"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsLastPage {
            get {
                if (IsPagingEnabled)
                    return(CurrentPageIndex == (PageCount - 1));
                else
                    return true;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.IsPagingEnabled"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsPagingEnabled {
            get {
                return allowPaging && (pageSize != 0);
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.IsReadOnly"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.IsSynchronized"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.PageCount"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int PageCount {
            get {
                if (dataSource == null)
                    return 0;

                int dataSourceItemCount = DataSourceCount;
                if (IsPagingEnabled && (dataSourceItemCount != 0)) {
                    return (int)((dataSourceItemCount + pageSize - 1) / pageSize);
                }
                else {
                    return 1;
                }
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.PageSize"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int PageSize {
            get {
                return pageSize;
            }
            set {
                pageSize = value;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.SyncRoot"]/*' />
        /// <devdoc>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.VirtualCount"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int VirtualCount {
            get {
                return virtualCount;
            }
            set {
                virtualCount = value;
            }
        }


        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.CopyTo"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.GetEnumerator"]/*' />
        /// <devdoc>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            int startIndex = FirstIndexInPage;
            int count = -1;
            
            if (dataSource is ICollection) {
                count = Count;
            }

            if (dataSource is IList) {
                return new EnumeratorOnIList((IList)dataSource, startIndex, count);
            }
            else if (dataSource is Array) {
                return new EnumeratorOnArray((object[])dataSource, startIndex, count);
            }
            else if (dataSource is ICollection) {
                return new EnumeratorOnICollection((ICollection)dataSource, startIndex, count);
            }
            else {
                if (allowCustomPaging) {
                    // startIndex does not matter
                    // however count does... even if the data source contains more than 1 page of data in
                    // it, we only want to enumerate over a single page of data
                    // note: we can call Count here, even though we're dealing with an IEnumerator
                    //       because by now we have ensured that we're in custom paging mode
                    return new EnumeratorOnIEnumerator(dataSource.GetEnumerator(), Count);
                }
                else {
                    // startIndex and count don't matter since we're going to enumerate over all the
                    // data (either non-paged or custom paging scenario)
                    return dataSource.GetEnumerator();
                }
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.GetItemProperties"]/*' />
        /// <devdoc>
        /// </devdoc>
        public PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors) {
            if (dataSource == null)
                return null;

            if (dataSource is ITypedList) {
                return((ITypedList)dataSource).GetItemProperties(listAccessors);
            }
            return null;
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.GetListName"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string GetListName(PropertyDescriptor[] listAccessors) {
            return String.Empty;
        }


        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.EnumeratorOnIEnumerator"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class EnumeratorOnIEnumerator : IEnumerator {
            private IEnumerator realEnum;
            private int index;
            private int indexBounds;

            public EnumeratorOnIEnumerator(IEnumerator realEnum, int count) {
                this.realEnum = realEnum;
                this.index = -1;
                this.indexBounds = count;
            }

            public object Current {
                get {
                    return realEnum.Current;
                }
            }

            public bool MoveNext() {
                bool result = realEnum.MoveNext();
                index++;
                return result && (index < indexBounds);
            }

            public void Reset() {
                realEnum.Reset();
                index = -1;
            }
        }

        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.EnumeratorOnICollection"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class EnumeratorOnICollection : IEnumerator {
            private ICollection collection;
            private IEnumerator collectionEnum;
            private int startIndex;
            private int index;
            private int indexBounds;

            public EnumeratorOnICollection(ICollection collection, int startIndex, int count) {
                this.collection = collection;
                this.startIndex = startIndex;
                this.index = -1;

                this.indexBounds = startIndex + count;
                if (indexBounds > collection.Count) {
                    indexBounds = collection.Count;
                }
            }

            public object Current {
                get {
                    return collectionEnum.Current;
                }
            }

            public bool MoveNext() {
                if (collectionEnum == null) {
                    collectionEnum = collection.GetEnumerator();
                    for (int i = 0; i < startIndex; i++)
                        collectionEnum.MoveNext();
                }
                collectionEnum.MoveNext();
                index++;
                return (startIndex + index) < indexBounds;
            }

            public void Reset() {
                collectionEnum = null;
                index = -1;
            }
        }


        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.EnumeratorOnIList"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class EnumeratorOnIList : IEnumerator {
            private IList collection;
            private int startIndex;
            private int index;
            private int indexBounds;

            public EnumeratorOnIList(IList collection, int startIndex, int count) {
                this.collection = collection;
                this.startIndex = startIndex;
                this.index = -1;

                this.indexBounds = startIndex + count;
                if (indexBounds > collection.Count) {
                    indexBounds = collection.Count;
                }
            }

            public object Current {
                get {
                    if (index < 0) {
                        throw new InvalidOperationException(SR.Enumerator_MoveNext_Not_Called);
                    }
                    return collection[startIndex + index];
                }
            }

            public bool MoveNext() {
                index++;
                return (startIndex + index) < indexBounds;
            }

            public void Reset() {
                index = -1;
            }
        }


        /// <include file='doc\PagedDataSource.uex' path='docs/doc[@for="PagedDataSource.EnumeratorOnArray"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class EnumeratorOnArray : IEnumerator {
            private object[] array;
            private int startIndex;
            private int index;
            private int indexBounds;

            public EnumeratorOnArray(object[] array, int startIndex, int count) {
                this.array = array;
                this.startIndex = startIndex;
                this.index = -1;

                this.indexBounds = startIndex + count;
                if (indexBounds > array.Length) {
                    indexBounds = array.Length;
                }
            }

            public object Current {
                get {
                    if (index < 0) {
                        throw new InvalidOperationException(SR.Enumerator_MoveNext_Not_Called);
                    }
                    return array[startIndex + index];
                }
            }

            public bool MoveNext() {
                index++;
                return (startIndex + index) < indexBounds;
            }

            public void Reset() {
                index = -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\pagermode.cs ===
//------------------------------------------------------------------------------
// <copyright file="PagerMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\PagerMode.uex' path='docs/doc[@for="PagerMode"]/*' />
    /// <devdoc>
    ///    <para> Specifies the behavior mode of the Pager item (for accessing various
    ///       pages) within the <see cref='System.Web.UI.WebControls.DataGrid'/> control.</para>
    /// </devdoc>
    public enum PagerMode {

        /// <include file='doc\PagerMode.uex' path='docs/doc[@for="PagerMode.NextPrev"]/*' />
        /// <devdoc>
        ///    <para> Uses the Previous and Next buttons for
        ///       accessing the previous and next pages.</para>
        /// </devdoc>
        NextPrev = 0,

        /// <include file='doc\PagerMode.uex' path='docs/doc[@for="PagerMode.NumericPages"]/*' />
        /// <devdoc>
        ///    <para> Uses numbered buttons for accessing pages directly.</para>
        /// </devdoc>
        NumericPages = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\radiobutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="RadioButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Web;
    using System.Web.UI;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton"]/*' />
    /// <devdoc>
    ///    <para>Constructs a radio button and defines its
    ///       properties.</para>
    /// </devdoc>
    [
    Designer("System.Web.UI.Design.WebControls.CheckBoxDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RadioButton : CheckBox, IPostBackDataHandler {

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.RadioButton"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.RadioButton'/> class.</para>
        /// </devdoc>
        public RadioButton() {
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.GroupName"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the name of the group that the radio button belongs to.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.RadioButton_GroupName)
        ]
        public virtual string GroupName {
            get {
                string s = (string)ViewState["GroupName"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["GroupName"] = value;
            }
        }

        // Fully qualified GroupName for rendering purposes, to take care of conflicts
        // between different naming containers
        private string UniqueGroupName {
            get {
                // For radio buttons, we must make the groupname unique, but can't just use the
                // UniqueID because all buttons in a group must have the same name.  So
                // we replace the last part of the UniqueID with the group Name.
                string name = GroupName;
                string uid = UniqueID;
                int lastColon = uid.LastIndexOf(Control.ID_SEPARATOR);
                if (lastColon >= 0)
                    name = uid.Substring(0, lastColon+1) + name;
                return name;
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.ValueAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string ValueAttribute {
            get {
                string valueAttr = Attributes["value"];
                if (valueAttr == null) {
                    if (ID != null)
                        valueAttr = ID;
                    else
                        valueAttr = UniqueID;
                }
                return valueAttr;
            }
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Method of IPostBackDataHandler interface to process posted data.
        ///       RadioButton determines the posted radio group state.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(String postDataKey, NameValueCollection postCollection) {
            string post = postCollection[UniqueGroupName];
            bool valueChanged = false;
            if ((post != null) && post.Equals(ValueAttribute)) {
                if (Checked == false) {
                    Checked = true;
                    // only fire change event for RadioButton that is being checked
                    valueChanged = true;
                }
            }
            else {
                if (Checked == true) {
                    Checked = false;
                }
            }

            return valueChanged;
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Raises when posted data for a control has changed.
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnCheckedChanged(EventArgs.Empty);
        }

        /// <include file='doc\RadioButton.uex' path='docs/doc[@for="RadioButton.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    This method is invoked just prior to rendering.
        ///    Register client script for handling postback if onChangeHandler is set.
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            // must call CheckBox PreRender
            base.OnPreRender(e);

            if (Page != null && !Checked && Enabled) {
                Page.RegisterRequiresPostBack(this);
            }

            if (GroupName.Length == 0)
                GroupName = UniqueID;
        }

        internal override void RenderInputTag(HtmlTextWriter writer, string clientID, string onClick) {
            writer.AddAttribute(HtmlTextWriterAttribute.Id, clientID);
            writer.AddAttribute(HtmlTextWriterAttribute.Type, "radio");
            writer.AddAttribute(HtmlTextWriterAttribute.Name, UniqueGroupName);
            writer.AddAttribute(HtmlTextWriterAttribute.Value, ValueAttribute);

            if (Checked)
                writer.AddAttribute(HtmlTextWriterAttribute.Checked, "checked");

            // ASURT 119141: Render the disabled attribute on the INPUT tag (instead of the SPAN) so the checkbox actually gets disabled when Enabled=false
            if (!Enabled) {
                writer.AddAttribute(HtmlTextWriterAttribute.Disabled, "disabled");
            }

            if (AutoPostBack) {
                // ASURT 98368
                // Need to merge the autopostback script with the user script
                if (onClick != null) {
                    onClick += Page.GetPostBackClientEvent(this, "");
                }
                else {
                    onClick = Page.GetPostBackClientEvent(this, "");
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onclick, onClick);
                writer.AddAttribute("language", "javascript");
            }
            else {
                if (onClick != null) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Onclick, onClick);
                }
            }

            string s = AccessKey;
            if (s.Length > 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Accesskey, s);

            int i = TabIndex;
            if (i != 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Tabindex, i.ToString(NumberFormatInfo.InvariantInfo));

            writer.RenderBeginTag(HtmlTextWriterTag.Input);
            writer.RenderEndTag();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\placeholder.cs ===
//------------------------------------------------------------------------------
// <copyright file="PlaceHolder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

using System;
using System.Web.UI;
using System.Security.Permissions;

    /// <include file='doc\PlaceHolder.uex' path='docs/doc[@for="PlaceHolderControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.PlaceHolder'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class PlaceHolderControlBuilder : ControlBuilder {
 
       /// <include file='doc\PlaceHolder.uex' path='docs/doc[@for="PlaceHolderControlBuilder.AllowWhitespaceLiterals"]/*' />
       /// <internalonly/>
       /// <devdoc>
       ///    <para>Specifies whether white space literals are allowed.</para>
       /// </devdoc>
       public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }

// The reason we define this empty override in the WebControls namespace is
// to expose it as a control that can be used on a page (ASURT 51116)
// E.g. <asp:placeholder runat=server id=ph1/>
/// <include file='doc\PlaceHolder.uex' path='docs/doc[@for="PlaceHolder"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
    [
    ControlBuilderAttribute(typeof(PlaceHolderControlBuilder))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class PlaceHolder : Control {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\radiobuttonlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="RadioButtonList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList"]/*' />
    /// <devdoc>
    ///    <para>Generates a single-selection radio button group and 
    ///       defines its properties.</para>
    /// </devdoc>
    [
    ValidationProperty("SelectedItem")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RadioButtonList : ListControl, IRepeatInfoUser, INamingContainer, IPostBackDataHandler {

        private bool selIndexChanged;
        private short radioButtonTabIndex;

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.RadioButtonList"]/*' />
        /// <devdoc>
        ///   Creates a new RadioButtonList
        /// </devdoc>
        public RadioButtonList() {
            selIndexChanged = false;
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.CellPadding"]/*' />
        /// <devdoc>
        ///  CellPadding property.
        ///  The padding between each item.
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(-1),
        WebSysDescription(SR.RadioButtonList_CellPadding)
        ]
        public virtual int CellPadding {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellPadding;
            }
            set {
                ((TableStyle)ControlStyle).CellPadding = value;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.CellSpacing"]/*' />
        /// <devdoc>
        ///  CellSpacing property.
        ///  The spacing between each item.
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(-1),
        WebSysDescription(SR.RadioButtonList_CellSpacing)
        ]
        public virtual int CellSpacing {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellSpacing;
            }
            set {
                ((TableStyle)ControlStyle).CellSpacing = value;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.RepeatColumns"]/*' />
        /// <devdoc>
        ///    Indicates the column count of radio buttons
        ///    within the group.
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(0),
        WebSysDescription(SR.RadioButtonList_RepeatColumns)
        ]
        public virtual int RepeatColumns {
            get {
                object o = ViewState["RepeatColumns"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatColumns"] = value;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.RepeatDirection"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the direction of flow of
        ///       the radio buttons within the group.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(RepeatDirection.Vertical),
        WebSysDescription(SR.RadioButtonList_RepeatDirection)
        ]
        public virtual RepeatDirection RepeatDirection {
            get {
                object o = ViewState["RepeatDirection"];
                return((o == null) ? RepeatDirection.Vertical : (RepeatDirection)o);
            }
            set {
                if (value < RepeatDirection.Horizontal || value > RepeatDirection.Vertical) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatDirection"] = value;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.RepeatLayout"]/*' />
        /// <devdoc>
        ///    <para>Indicates the layout of radio buttons within the 
        ///       group.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(RepeatLayout.Table),
        WebSysDescription(SR.RadioButtonList_RepeatLayout)
        ]
        public virtual RepeatLayout RepeatLayout {
            get {
                object o = ViewState["RepeatLayout"];
                return((o == null) ? RepeatLayout.Table : (RepeatLayout)o);
            }
            set {
                if (value < RepeatLayout.Table || value > RepeatLayout.Flow) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatLayout"] = value;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.TextAlign"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the label text alignment for the radio buttons within the group.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(TextAlign.Right),
        WebSysDescription(SR.RadioButtonList_TextAlign)
        ]
        public virtual TextAlign TextAlign {
            get {
                object align = ViewState["TextAlign"];
                return((align == null) ? TextAlign.Right : (TextAlign)align);
            }
            set {
                if (value < TextAlign.Left || value > TextAlign.Right) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["TextAlign"] = value;
            }
        }


        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            return new TableStyle(ViewState);
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Loads the posted content of the list control if it is different from the last 
        /// posting.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(String postDataKey, NameValueCollection postCollection) {
            string post = postCollection[postDataKey];
            int currentSelectedIndex = SelectedIndex;
            int n = Items.Count;
            for (int i=0; i < n; i++) {
                if (post == Items[i].Value) {
                    if (i != currentSelectedIndex) {
                        selIndexChanged = true;
                        SelectedIndex = i;
                    }
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Invokes the OnSelectedIndexChanged 
        /// method whenever posted data for the <see cref='System.Web.UI.WebControls.RadioButtonList'/>
        /// control has changed.</para>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            if (selIndexChanged) {
                OnSelectedIndexChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            RepeatInfo repeatInfo = new RepeatInfo();
            Style style = (ControlStyleCreated ? ControlStyle : null);
            bool undirtyTabIndex = false;

            // TabIndex here is special... it needs to be applied to the individual
            // radiobuttons and not the outer control itself

            // cache away the TabIndex property state
            radioButtonTabIndex = TabIndex;
            if (radioButtonTabIndex != 0) {
                if (ViewState.IsItemDirty("TabIndex") == false) {
                    undirtyTabIndex = true;
                }
                TabIndex = 0;
            }

            repeatInfo.RepeatColumns = RepeatColumns;
            repeatInfo.RepeatDirection = RepeatDirection;
            repeatInfo.RepeatLayout = RepeatLayout;
            repeatInfo.RenderRepeater(writer, (IRepeatInfoUser)this, style, this);

            // restore the state of the TabIndex property
            if (radioButtonTabIndex != 0) {
                TabIndex = radioButtonTabIndex;
            }
            if (undirtyTabIndex) {
                ViewState.SetItemDirty("TabIndex", false);
            }

        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IRepeatInfoUser.HasFooter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasFooter {
            get {
                return false;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IRepeatInfoUser.HasHeader"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasHeader {
            get {
                return false;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IRepeatInfoUser.HasSeparators"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasSeparators {
            get {
                return false;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IRepeatInfoUser.RepeatedItemCount"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        int IRepeatInfoUser.RepeatedItemCount {
            get {
                return Items.Count;
            }
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IRepeatInfoUser.GetItemStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        Style IRepeatInfoUser.GetItemStyle(ListItemType itemType, int repeatIndex) {
            return null;
        }

        /// <include file='doc\RadioButtonList.uex' path='docs/doc[@for="RadioButtonList.IRepeatInfoUser.RenderItem"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called by the RepeatInfo helper to render each item
        /// </devdoc>
        void IRepeatInfoUser.RenderItem(ListItemType itemType, int repeatIndex, RepeatInfo repeatInfo, HtmlTextWriter writer) {

            RadioButton controlToRepeat;
            controlToRepeat = new RadioButton();
            controlToRepeat._page = Page;

            // This will cause the postback to go back to this control
            controlToRepeat.GroupName = UniqueID;
            controlToRepeat.ID = ClientID + "_" + repeatIndex.ToString(NumberFormatInfo.InvariantInfo);

            // Apply properties of the list items
            controlToRepeat.Text = Items[repeatIndex].Text;
            controlToRepeat.Attributes["value"] = Items[repeatIndex].Value;
            controlToRepeat.Checked = Items[repeatIndex].Selected;

            // Apply other properties
            // CONSIDER: apply RadioButtonList style to RadioButtons?
            controlToRepeat.TextAlign = TextAlign;
            controlToRepeat.AutoPostBack = this.AutoPostBack;
            controlToRepeat.TabIndex = radioButtonTabIndex;
            controlToRepeat.Enabled = this.Enabled;

            controlToRepeat.RenderControl(writer);
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\panel.cs ===
//------------------------------------------------------------------------------
// <copyright file="Panel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Web;
    using System.Web.UI;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Security.Permissions;

    /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel"]/*' />
    /// <devdoc>
    ///    <para>Constructs a panel for specifies layout regions
    ///       on a page and defines its properties.</para>
    /// </devdoc>
    [
    Designer("System.Web.UI.Design.WebControls.PanelDesigner, " + AssemblyRef.SystemDesign),
    ToolboxData("<{0}:Panel runat=server>Panel</{0}:Panel>"),
    ParseChildren(false),
    PersistChildren(true)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Panel : WebControl {

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.Panel"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Web.UI.WebControls.Panel'/> class.
        /// </devdoc>
        public Panel() : base(HtmlTextWriterTag.Div) {
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.BackImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL of the background image for the panel control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.ImageUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.Panel_BackImageUrl)
        ]
        public virtual string BackImageUrl {
            get {
                string s = (string)ViewState["BackImageUrl"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["BackImageUrl"] = value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the horizontal alignment of the contents within the panel.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.Panel_HorizontalAlign)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                object o = ViewState["HorizontalAlign"];
                return((o == null) ? HorizontalAlign.NotSet : (HorizontalAlign)o);
            }
            set {
                if (value < HorizontalAlign.NotSet || value > HorizontalAlign.Justify) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["HorizontalAlign"] = value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.Wrap"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value
        ///       indicating whether the content wraps within the panel.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(true),
        WebSysDescription(SR.Panel_Wrap)
        ]
        public virtual bool Wrap {
            get {
                object b = ViewState["Wrap"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["Wrap"] = value;
            }
        }

        /// <include file='doc\Panel.uex' path='docs/doc[@for="Panel.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Add background-image to list of style attributes to render.
        ///    Add align and nowrap to list of attributes to render.
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);

            string s = BackImageUrl;
            if (s.Length > 0)
                writer.AddStyleAttribute(HtmlTextWriterStyle.BackgroundImage,"url(" + ResolveClientUrl(s) + ")");

            HorizontalAlign hAlign = HorizontalAlign;
            if (hAlign != HorizontalAlign.NotSet) {
                TypeConverter hac = TypeDescriptor.GetConverter(typeof(HorizontalAlign));
                writer.AddAttribute(HtmlTextWriterAttribute.Align, hac.ConvertToString(hAlign));
            }
            
            if (!Wrap)
                writer.AddAttribute(HtmlTextWriterAttribute.Nowrap,"nowrap");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeatdirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeatDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\RepeatDirection.uex' path='docs/doc[@for="RepeatDirection"]/*' />
    /// <devdoc>
    ///    Defines the direction of flow within a list.
    /// </devdoc>
    public enum RepeatDirection {

        /// <include file='doc\RepeatDirection.uex' path='docs/doc[@for="RepeatDirection.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>The list items are rendered horizontally in rows (from left to right, then top to botton).</para>
        /// </devdoc>
        Horizontal = 0,

        /// <include file='doc\RepeatDirection.uex' path='docs/doc[@for="RepeatDirection.Vertical"]/*' />
        /// <devdoc>
        ///    <para>The list items are rendered vertically in columns (from top to bottom, then left to right).</para>
        /// </devdoc>
        Vertical = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\rangevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RangeValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.Diagnostics;
    using System.ComponentModel;
    using System.Web;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\RangeValidator.uex' path='docs/doc[@for="RangeValidator"]/*' />
    /// <devdoc>
    ///    <para> Checks if the value of the associated input control 
    ///       is within some minimum and maximum values, which
    ///       can be constant values or values of other controls.</para>
    /// </devdoc>
    [
    ToolboxData("<{0}:RangeValidator runat=server ErrorMessage=\"RangeValidator\"></{0}:RangeValidator>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RangeValidator : BaseCompareValidator {

        /// <include file='doc\RangeValidator.uex' path='docs/doc[@for="RangeValidator.MaximumValue"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the maximum value of the validation range.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.RangeValidator_MaximumValue)
        ]                                         
        public string MaximumValue {
            get { 
                object o = ViewState["MaximumValue"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["MaximumValue"] = value;
            }
        }

        /// <include file='doc\RangeValidator.uex' path='docs/doc[@for="RangeValidator.MinimumValue"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the minimum value of the validation range.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.RangeValidator_MinmumValue)
        ]                                         
        public string MinimumValue {
            get { 
                object o = ViewState["MinimumValue"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["MinimumValue"] = value;
            }
        }


        /// <include file='doc\RangeValidator.uex' path='docs/doc[@for="RangeValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    AddAttributesToRender method
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);
            if (RenderUplevel) {
                writer.AddAttribute("evaluationfunction", "RangeValidatorEvaluateIsValid");
                writer.AddAttribute("maximumvalue", MaximumValue);
                writer.AddAttribute("minimumvalue", MinimumValue);
            }
        }        

        /// <include file='doc\RangeValidator.uex' path='docs/doc[@for="RangeValidator.ControlPropertiesValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    This is a check of properties to determine any errors made by the developer
        /// </devdoc>
        protected override bool ControlPropertiesValid() {

            // Check the control values can be converted to data type
            string maximumValue = MaximumValue;
            if (!CanConvert(maximumValue, Type)) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(
                                                                       SR.Validator_value_bad_type, 
                                                                       new string [] {
                                                                           maximumValue,
                                                                           "MaximumValue",
                                                                           ID, 
                                                                           PropertyConverter.EnumToString(typeof(ValidationDataType), Type)
                                                                       }));
            }
            string minumumValue = MinimumValue;
            if (!CanConvert(minumumValue, Type)) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(
                                                                       SR.Validator_value_bad_type,
                                                                       new string [] {
                                                                           minumumValue,
                                                                           "MinimumValue",
                                                                           ID, 
                                                                           PropertyConverter.EnumToString(typeof(ValidationDataType), Type)
                                                                       }));
            }
            // Check for overlap.
            if (Compare(minumumValue, maximumValue, ValidationCompareOperator.GreaterThan, Type))  {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(
                                                                       SR.Validator_range_overalap,
                                                                       new string [] {
                                                                           maximumValue,
                                                                           minumumValue,
                                                                           ID,
                                                                       }));                    
            }
            return base.ControlPropertiesValid();            
        }

        /// <include file='doc\RangeValidator.uex' path='docs/doc[@for="RangeValidator.EvaluateIsValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    EvaluateIsValid method
        /// </devdoc>
        protected override bool EvaluateIsValid() {

            Debug.Assert(PropertiesValid, "Should have already been checked");

            // Get the peices of text from the control(s).
            string text = GetControlValidationValue(ControlToValidate);
            Debug.Assert(text != null, "Should have already caught this!");

            // Special case: if the string is blank, we don't try to validate it. The input should be
            // trimmed for coordination with the RequiredFieldValidator.
            if (text.Trim().Length == 0) {
                return true;
            }

            return(Compare(text, MinimumValue, ValidationCompareOperator.GreaterThanEqual, Type)
                   && Compare(text, MaximumValue, ValidationCompareOperator.LessThanEqual, Type));
        }            

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeatercommandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\RepeaterCommandEventHandler.uex' path='docs/doc[@for="RepeaterCommandEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the
    ///    <see langword='ItemCommand'/> event of a <see cref='System.Web.UI.WebControls.Repeater'/>.</para>
    /// </devdoc>
    public delegate void RepeaterCommandEventHandler(object source, RepeaterCommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeatercommandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterCommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\RepeaterCommandEventArgs.uex' path='docs/doc[@for="RepeaterCommandEventArgs"]/*' />
    /// <devdoc>
    ///    <para>Provides data for the
    ///    <see langword='ItemCommand'/> event of the <see cref='System.Web.UI.WebControls.Repeater'/> .</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class RepeaterCommandEventArgs : CommandEventArgs {

        private RepeaterItem item;
        private object commandSource;

        /// <include file='doc\RepeaterCommandEventArgs.uex' path='docs/doc[@for="RepeaterCommandEventArgs.RepeaterCommandEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.RepeaterCommandEventArgs'/> 
        /// class.</para>
        /// </devdoc>
        public RepeaterCommandEventArgs(RepeaterItem item, object commandSource, CommandEventArgs originalArgs) : base(originalArgs) {
            this.item = item;
            this.commandSource = commandSource;
        }


        /// <include file='doc\RepeaterCommandEventArgs.uex' path='docs/doc[@for="RepeaterCommandEventArgs.Item"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Web.UI.WebControls.RepeaterItem'/>associated with the event.</para>
        /// </devdoc>
        public RepeaterItem Item {
            get {
                return item;
            }
        }

        /// <include file='doc\RepeaterCommandEventArgs.uex' path='docs/doc[@for="RepeaterCommandEventArgs.CommandSource"]/*' />
        /// <devdoc>
        ///    Gets the command source.
        /// </devdoc>
        public object CommandSource {
            get {
                return commandSource;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\regularexpressionvalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegularExpressionValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Text.RegularExpressions;
    using System.Drawing.Design;
    using System.Web;
    using System.Security.Permissions;

    /// <include file='doc\RegularExpressionValidator.uex' path='docs/doc[@for="RegularExpressionValidator"]/*' />
    /// <devdoc>
    ///    <para>Checks if the value of the associated input control matches the pattern 
    ///       of a regular expression.</para>
    /// </devdoc>
    [
    ToolboxData("<{0}:RegularExpressionValidator runat=server ErrorMessage=\"RegularExpressionValidator\"></{0}:RegularExpressionValidator>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RegularExpressionValidator : BaseValidator {

        /// <include file='doc\RegularExpressionValidator.uex' path='docs/doc[@for="RegularExpressionValidator.ValidationExpression"]/*' />
        /// <devdoc>
        ///    <para>Indicates the regular expression assigned to be the validation criteria.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.WebControls.RegexTypeEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.RegularExpressionValidator_ValidationExpression)
        ]                                         
        public string ValidationExpression {
            get { 
                object o = ViewState["ValidationExpression"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                try {
                    Regex.IsMatch("", value);
                }
                catch (Exception e) {
                    throw new HttpException(
                                           HttpRuntime.FormatResourceString(SR.Validator_bad_regex, value), e);                    
                }
                ViewState["ValidationExpression"] = value;
            }
        }

        /// <include file='doc\RegularExpressionValidator.uex' path='docs/doc[@for="RegularExpressionValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    AddAttributesToRender method
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);
            if (RenderUplevel) {
                writer.AddAttribute("evaluationfunction", "RegularExpressionValidatorEvaluateIsValid");
                if (ValidationExpression.Length > 0) {
                    writer.AddAttribute("validationexpression", ValidationExpression);
                }
            }
        }            

        /// <include file='doc\RegularExpressionValidator.uex' path='docs/doc[@for="RegularExpressionValidator.EvaluateIsValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    EvaluateIsValid method
        /// </devdoc>
        protected override bool EvaluateIsValid() {

            // Always succeeds if input is empty or value was not found
            string controlValue = GetControlValidationValue(ControlToValidate);
            Debug.Assert(controlValue != null, "Should have already been checked");
            if (controlValue == null || controlValue.Trim().Length == 0) {
                return true;
            }

            try {
                // we are looking for an exact match, not just a search hit
                Match m = Regex.Match(controlValue, ValidationExpression);
                return(m.Success && m.Index == 0 && m.Length == controlValue.Length);
            }
            catch {
                Debug.Fail("Regex error should have been caught in property setter.");
                return true;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeateritem.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\RepeaterItem.uex' path='docs/doc[@for="RepeaterItem"]/*' />
    /// <devdoc>
    /// <para>Encapsulates an item within the <see cref='System.Web.UI.WebControls.Repeater'/> control.</para>
    /// </devdoc>
    [
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RepeaterItem : Control, INamingContainer {

        private int itemIndex;
        private ListItemType itemType;
        private object dataItem;

        /// <include file='doc\RepeaterItem.uex' path='docs/doc[@for="RepeaterItem.RepeaterItem"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.RepeaterItem'/> with the specified item type and
        ///    location.</para>
        /// </devdoc>
        public RepeaterItem(int itemIndex, ListItemType itemType) {
            this.itemIndex = itemIndex;
            this.itemType = itemType;
        }


        /// <include file='doc\RepeaterItem.uex' path='docs/doc[@for="RepeaterItem.DataItem"]/*' />
        /// <devdoc>
        ///    Specifies the data item.
        /// </devdoc>
        public virtual object DataItem {
            get {
                return dataItem;
            }
            set {
                dataItem = value;
            }
        }

        /// <include file='doc\RepeaterItem.uex' path='docs/doc[@for="RepeaterItem.ItemIndex"]/*' />
        /// <devdoc>
        ///    <para>Indicates the ordinal index that specifies the item 
        ///       location within the <see cref='System.Web.UI.WebControls.Repeater'/>
        ///       .</para>
        /// </devdoc>
        public virtual int ItemIndex {
            get {
                return itemIndex;
            }
        }

        /// <include file='doc\RepeaterItem.uex' path='docs/doc[@for="RepeaterItem.ItemType"]/*' />
        /// <devdoc>
        ///    Indicates the <see cref='System.Web.UI.WebControls.Repeater'/> item type. This property is
        ///    read-only.
        /// </devdoc>
        public virtual ListItemType ItemType {
            get {
                return itemType;
            }
        }


        /// <include file='doc\RepeaterItem.uex' path='docs/doc[@for="RepeaterItem.OnBubbleEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override bool OnBubbleEvent(object source, EventArgs e) {
            if (e is CommandEventArgs) {
                RepeaterCommandEventArgs args = new RepeaterCommandEventArgs(this, source, (CommandEventArgs)e);

                RaiseBubbleEvent(this, args);
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeateritemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection"]/*' />
    /// <devdoc>
    /// <para>Encapsulates the collection of <see cref='System.Web.UI.WebControls.RepeaterItem'/> objects within a <see cref='System.Web.UI.WebControls.Repeater'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class RepeaterItemCollection : ICollection {

        private ArrayList items;

        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.RepeaterItemCollection"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of
        ///    the <see cref='System.Web.UI.WebControls.RepeaterItemCollection'/> class with the specified items.
        /// </devdoc>
        public RepeaterItemCollection(ArrayList items) {
            this.items = items;
        }
        
        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the item count of the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                return items.Count;
            }
        }

        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether access to the collection is synchronized 
        ///       (thread-safe).</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object that can be used to synchronize access to the collection. In 
        ///       this case, it is the collection itself.</para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Web.UI.WebControls.RepeaterItem'/> referenced by the specified ordinal index value in 
        ///    the collection.</para>
        /// </devdoc>
        public RepeaterItem this[int index] {
            get {
                return(RepeaterItem)items[index];
            }
        }


        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies contents from the collection to a specified <see cref='System.Array' qualify='true'/> with a 
        ///    specified starting index.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\RepeaterItemCollection.uex' path='docs/doc[@for="RepeaterItemCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Returns an enumerator of all <see cref='System.Web.UI.WebControls.RepeaterItem'/> controls within the 
        ///    collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return items.GetEnumerator(); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeater.cs ===
//------------------------------------------------------------------------------
// <copyright file="Repeater.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater"]/*' />
    /// <devdoc>
    /// <para>Defines the properties, methods, and events of a <see cref='System.Web.UI.WebControls.Repeater'/> class.</para>
    /// </devdoc>
    [
    DefaultEvent("ItemCommand"),
    DefaultProperty("DataSource"),
    Designer("System.Web.UI.Design.WebControls.RepeaterDesigner, " + AssemblyRef.SystemDesign),
    ParseChildren(true),
    PersistChildren(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Repeater : Control, INamingContainer {

        private static readonly object EventItemCreated = new object();
        private static readonly object EventItemDataBound = new object();
        private static readonly object EventItemCommand = new object();

        internal const string ItemCountViewStateKey = "_!ItemCount";

        private object dataSource;
        private ITemplate headerTemplate;
        private ITemplate footerTemplate;
        private ITemplate itemTemplate;
        private ITemplate alternatingItemTemplate;
        private ITemplate separatorTemplate;

        private ArrayList itemsArray;
        private RepeaterItemCollection itemsCollection;

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.Repeater"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Repeater'/> class.</para>
        /// </devdoc>
        public Repeater() {
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.AlternatingItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how alternating (even-indexed) items 
        ///    are rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(RepeaterItem)),
            WebSysDescription(SR.Repeater_AlternatingItemTemplate)
        ]
        public virtual ITemplate AlternatingItemTemplate {
            get {
                return alternatingItemTemplate;
            }
            set {
                alternatingItemTemplate = value;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.Controls"]/*' />
        public override ControlCollection Controls {
            get {
                EnsureChildControls();
                return base.Controls;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        WebCategory("Data"),
        WebSysDescription(SR.Repeater_DataMember)
        ]
        public virtual string DataMember {
            get {
                object o = ViewState["DataMember"];
                if (o != null)
                    return (string)o;
                return String.Empty;
            }
            set {
                ViewState["DataMember"] = value;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.DataSource"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the data source that provides data for
        ///       populating the list.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Data"),
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            WebSysDescription(SR.Repeater_DataSource)
        ]
        public virtual object DataSource {
            get {
                return dataSource;
            }
            set {
                if ((value == null) || (value is IListSource) || (value is IEnumerable)) {
                    dataSource = value;
                }
                else {
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_DataSource_Type, ID));
                }
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.FooterTemplate"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how the control footer is 
        ///    rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(RepeaterItem)),
            WebSysDescription(SR.Repeater_FooterTemplate)
        ]
        public virtual ITemplate FooterTemplate {
            get {
                return footerTemplate;
            }
            set {
                footerTemplate = value;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.HeaderTemplate"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how the control header is rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(RepeaterItem)),
            WebSysDescription(SR.Repeater_HeaderTemplate)
        ]
        public virtual ITemplate HeaderTemplate {
            get {
                return headerTemplate;
            }
            set {
                headerTemplate = value;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.Items"]/*' />
        /// <devdoc>
        ///    Gets the <see cref='System.Web.UI.WebControls.RepeaterItem'/> collection.
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            WebSysDescription(SR.Repeater_Items)
        ]
        public virtual RepeaterItemCollection Items {
            get {
                if (itemsCollection == null) {
                    if (itemsArray == null) {
                        EnsureChildControls();
                    }
                    itemsCollection = new RepeaterItemCollection(itemsArray);
                }
                return itemsCollection;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.ItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how items are rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(RepeaterItem)),
            WebSysDescription(SR.Repeater_ItemTemplate)
        ]
        public virtual ITemplate ItemTemplate {
            get {
                return itemTemplate;
            }
            set {
                itemTemplate = value;
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.SeparatorTemplate"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how separators
        ///    in between items are rendered.</para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(RepeaterItem)),
            WebSysDescription(SR.Repeater_SeparatorTemplate)
        ]
        public virtual ITemplate SeparatorTemplate {
            get {
                return separatorTemplate;
            }
            set {
                separatorTemplate = value;
            }
        }


        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.ItemCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a button is clicked within the <see cref='System.Web.UI.WebControls.Repeater'/> control tree.</para>
        /// </devdoc>
       [
        WebCategory("Action"),
        WebSysDescription(SR.Repeater_OnItemCommand)
        ]
        public event RepeaterCommandEventHandler ItemCommand {
            add {
                Events.AddHandler(EventItemCommand, value);
            }
            remove {
                Events.RemoveHandler(EventItemCommand, value);
            }
        }


        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.ItemCreated"]/*' />
        /// <devdoc>
        /// <para> Occurs when an item is created within the <see cref='System.Web.UI.WebControls.Repeater'/> control tree.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        WebSysDescription(SR.Repeater_OnItemCreated)
        ]
        public event RepeaterItemEventHandler ItemCreated {
            add {
                Events.AddHandler(EventItemCreated, value);
            }
            remove {
                Events.RemoveHandler(EventItemCreated, value);
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.ItemDataBound"]/*' />
        /// <devdoc>
        /// <para>Occurs when an item is databound within a <see cref='System.Web.UI.WebControls.Repeater'/> control tree.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        WebSysDescription(SR.Repeater_OnItemDataBound)
        ]
        public event RepeaterItemEventHandler ItemDataBound {
            add {
                Events.AddHandler(EventItemDataBound, value);
            }
            remove {
                Events.RemoveHandler(EventItemDataBound, value);
            }
        }



        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.CreateChildControls"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void CreateChildControls() {
            Controls.Clear();
            
            if (ViewState[ItemCountViewStateKey] != null) {
                // create the control hierarchy using the view state (and
                // not the datasource)
                CreateControlHierarchy(false);
            }
            else {
                itemsArray = new ArrayList();
            }
            ClearChildViewState();
        }
        

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.CreateControlHierarchy"]/*' />
        /// <devdoc>
        ///    A protected method. Creates a control
        ///    hierarchy, with or without the data source as specified.
        /// </devdoc>
        protected virtual void CreateControlHierarchy(bool useDataSource) {
            IEnumerable dataSource = null;
            int count = -1;

            if (itemsArray != null) {
                itemsArray.Clear();
            }
            else {
                itemsArray = new ArrayList();
            }

            if (useDataSource == false) {
                // ViewState must have a non-null value for ItemCount because we check for
                // this in CreateChildControls
                count = (int)ViewState[ItemCountViewStateKey];
                if (count != -1) {
                    dataSource = new DummyDataSource(count);
                    itemsArray.Capacity = count;
                }
            }
            else {
                dataSource = DataSourceHelper.GetResolvedDataSource(this.DataSource, this.DataMember);

                ICollection collection = dataSource as ICollection;
                if (collection != null) {
                    itemsArray.Capacity = collection.Count;
                }
            }

            if (dataSource != null) {
                ControlCollection controls = Controls;
                RepeaterItem item;
                ListItemType itemType;
                int index = 0;

                bool hasSeparators = (separatorTemplate != null);
                count = 0;

                if (headerTemplate != null) {
                    CreateItem(-1, ListItemType.Header, useDataSource, null);
                }

                foreach (object dataItem in dataSource) {
                    // rather than creating separators after the item, we create the separator
                    // for the previous item in all iterations of this loop.
                    // this is so that we don't create a separator for the last item
                    if (hasSeparators && (count > 0)) {
                        CreateItem(index - 1, ListItemType.Separator, useDataSource, null);
                    }

                    itemType = (index % 2 == 0) ? ListItemType.Item : ListItemType.AlternatingItem;
                    item = CreateItem(index, itemType, useDataSource, dataItem);
                    itemsArray.Add(item);

                    count++;
                    index++;
                }

                if (footerTemplate != null) {
                    CreateItem(-1, ListItemType.Footer, useDataSource, null);
                }
            }

            if (useDataSource) {
                // save the number of items contained in the repeater for use in round-trips
                ViewState[ItemCountViewStateKey] = ((dataSource != null) ? count : -1);
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.CreateItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        private RepeaterItem CreateItem(int itemIndex, ListItemType itemType, bool dataBind, object dataItem) {
            RepeaterItem item = CreateItem(itemIndex, itemType);
            RepeaterItemEventArgs e = new RepeaterItemEventArgs(item);

            InitializeItem(item);
            if (dataBind) {
                item.DataItem = dataItem;
            }
            OnItemCreated(e);
            Controls.Add(item);

            if (dataBind) {
                item.DataBind();
                OnItemDataBound(e);

                item.DataItem = null;
            }

            return item;
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.CreateItem1"]/*' />
        /// <devdoc>
        /// <para>A protected method. Creates a <see cref='System.Web.UI.WebControls.RepeaterItem'/> with the specified item type and
        ///    location within the <see cref='System.Web.UI.WebControls.Repeater'/>.</para>
        /// </devdoc>
        protected virtual RepeaterItem CreateItem(int itemIndex, ListItemType itemType) {
            return new RepeaterItem(itemIndex, itemType);
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.DataBind"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override void DataBind() {
            // do our own databinding
            OnDataBinding(EventArgs.Empty);

            // contained items will be databound after they have been created,
            // so we don't want to walk the hierarchy here.
        }
        
        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.InitializeItem"]/*' />
        /// <devdoc>
        /// <para>A protected method. Populates iteratively the specified <see cref='System.Web.UI.WebControls.RepeaterItem'/> with a 
        ///    sub-hierarchy of child controls.</para>
        /// </devdoc>
        protected virtual void InitializeItem(RepeaterItem item) {
            ITemplate contentTemplate = null;

            switch (item.ItemType) {
                case ListItemType.Header:
                    contentTemplate = headerTemplate;
                    break;

                case ListItemType.Footer:
                    contentTemplate = footerTemplate;
                    break;

                case ListItemType.Item:
                    contentTemplate = itemTemplate;
                    break;

                case ListItemType.AlternatingItem:
                    contentTemplate = alternatingItemTemplate;
                    if (contentTemplate == null)
                        goto case ListItemType.Item;
                    break;

                case ListItemType.Separator:
                    contentTemplate = separatorTemplate;
                    break;
            }

            if (contentTemplate != null) {
                contentTemplate.InstantiateIn(item);
            }
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.OnBubbleEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override bool OnBubbleEvent(object sender, EventArgs e) {
            bool handled = false;

            if (e is RepeaterCommandEventArgs) {
                OnItemCommand((RepeaterCommandEventArgs)e);
                handled = true;
            }

            return handled;
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.OnDataBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>A protected method. Raises the <see langword='DataBinding'/> event.</para>
        /// </devdoc>
        protected override void OnDataBinding(EventArgs e) {
            base.OnDataBinding(e);

            // reset the control state
            Controls.Clear();
            ClearChildViewState();

            // and then create the control hierarchy using the datasource
            CreateControlHierarchy(true);
            ChildControlsCreated = true;
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.OnItemCommand"]/*' />
        /// <devdoc>
        /// <para>A protected method. Raises the <see langword='ItemCommand'/> event.</para>
        /// </devdoc>
        protected virtual void OnItemCommand(RepeaterCommandEventArgs e) {
            RepeaterCommandEventHandler onItemCommandHandler = (RepeaterCommandEventHandler)Events[EventItemCommand];
            if (onItemCommandHandler != null) onItemCommandHandler(this, e);
        }
        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.OnItemCreated"]/*' />
        /// <devdoc>
        /// <para>A protected method. Raises the <see langword='ItemCreated'/> event.</para>
        /// </devdoc>
        protected virtual void OnItemCreated(RepeaterItemEventArgs e) {
            RepeaterItemEventHandler onItemCreatedHandler = (RepeaterItemEventHandler)Events[EventItemCreated];
            if (onItemCreatedHandler != null) onItemCreatedHandler(this, e);
        }

        /// <include file='doc\Repeater.uex' path='docs/doc[@for="Repeater.OnItemDataBound"]/*' />
        /// <devdoc>
        /// <para>A protected method. Raises the <see langword='ItemDataBound'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnItemDataBound(RepeaterItemEventArgs e) {
            RepeaterItemEventHandler onItemDataBoundHandler = (RepeaterItemEventHandler)Events[EventItemDataBound];
            if (onItemDataBoundHandler != null) onItemDataBoundHandler(this, e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeateritemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterItemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\RepeaterItemEventHandler.uex' path='docs/doc[@for="RepeaterItemEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle 
    ///       the <see langword='ItemCreated'/> and <see langword='ItemDataBound'/> events of a <see cref='System.Web.UI.WebControls.Repeater'/> .</para>
    /// </devdoc>
    public delegate void RepeaterItemEventHandler(object sender, RepeaterItemEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeateritemeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterItemEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\RepeaterItemEventArgs.uex' path='docs/doc[@for="RepeaterItemEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='ItemCreated'/> and 
    /// <see langword='ItemDataBound '/>events.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class RepeaterItemEventArgs : EventArgs {

        private RepeaterItem item;

        /// <include file='doc\RepeaterItemEventArgs.uex' path='docs/doc[@for="RepeaterItemEventArgs.RepeaterItemEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.RepeaterItemEventArgs'/> class.</para>
        /// </devdoc>
        public RepeaterItemEventArgs(RepeaterItem item) {
            this.item = item;
        }


        /// <include file='doc\RepeaterItemEventArgs.uex' path='docs/doc[@for="RepeaterItemEventArgs.Item"]/*' />
        /// <devdoc>
        /// <para> Gets the <see cref='System.Web.UI.WebControls.RepeaterItem'/> associated with the event.</para>
        /// </devdoc>
        public RepeaterItem Item {
            get {
                return item;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeatinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeatInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo"]/*' />
    /// <devdoc>
    ///    <para>Defines the information used to render a list of items using
    ///       a <see cref='System.Web.UI.WebControls.Repeater'/>.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class RepeatInfo {

        private RepeatDirection repeatDirection;
        private RepeatLayout repeatLayout;
        private int repeatColumns;
        private bool outerTableImplied;

        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RepeatInfo"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.RepeatInfo'/> class. This class is not 
        ///    inheritable.</para>
        /// </devdoc>
        public RepeatInfo() {
            repeatDirection = RepeatDirection.Vertical;
            repeatLayout = RepeatLayout.Table;
            repeatColumns = 0;
            outerTableImplied = false;
        }


        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.OuterTableImplied"]/*' />
        /// <devdoc>
        ///    Indicates whether an outer table is implied
        ///    for the items.
        /// </devdoc>
        public bool OuterTableImplied {
            get {
                return outerTableImplied;
            }
            set {
                outerTableImplied = value;
            }
        }

        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RepeatColumns"]/*' />
        /// <devdoc>
        ///    <para> Indicates the column count of items.</para>
        /// </devdoc>
        public int RepeatColumns {
            get {
                return repeatColumns;
            }
            set {
                repeatColumns = value;
            }
        }

        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RepeatDirection"]/*' />
        /// <devdoc>
        ///    <para>Indicates the direction of flow of items.</para>
        /// </devdoc>
        public RepeatDirection RepeatDirection {
            get {
                return repeatDirection;
            }
            set {
                if (value < RepeatDirection.Horizontal || value > RepeatDirection.Vertical) {
                    throw new ArgumentOutOfRangeException("value");
                }
                repeatDirection = value;
            }
        }

        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RepeatLayout"]/*' />
        /// <devdoc>
        ///    Indicates the layout of items.
        /// </devdoc>
        public RepeatLayout RepeatLayout {
            get {
                return repeatLayout;
            }
            set {
                if (value < RepeatLayout.Table || value > RepeatLayout.Flow) {
                    throw new ArgumentOutOfRangeException("value");
                }
                repeatLayout = value;
            }
        }


        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RenderHorizontalRepeater"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void RenderHorizontalRepeater(HtmlTextWriter writer, IRepeatInfoUser user, Style controlStyle, WebControl baseControl) {
            Debug.Assert(outerTableImplied == false, "Cannot use outer implied table with Horizontal layout");

            int itemCount = user.RepeatedItemCount;

            int totalColumns = repeatColumns;
            int currentColumn = 0;

            if (totalColumns == 0) {
                // 0 implies a complete horizontal repetition without any
                // column count constraints
                totalColumns = itemCount;
            }

            WebControl outerControl = null;
            bool tableLayout = false;

            switch (repeatLayout) {
                case RepeatLayout.Table:
                    outerControl = new Table();
                    tableLayout = true;
                    break;
                case RepeatLayout.Flow:
                    outerControl = new WebControl(HtmlTextWriterTag.Span);
                    break;
            }

            bool separators = user.HasSeparators;

            // use ClientID (and not ID) since we want to render out the fully qualified client id
            // even though this outer control will not be parented to the control hierarchy
            outerControl.ID = baseControl.ClientID;

            outerControl.CopyBaseAttributes(baseControl);
            outerControl.ApplyStyle(controlStyle);
            outerControl.RenderBeginTag(writer);

            if (user.HasHeader) {
                if (tableLayout) {
                    writer.RenderBeginTag(HtmlTextWriterTag.Tr);

                    // add attributes to render for TD
                    if ((totalColumns != 1) || separators) {
                        int columnSpan = totalColumns;
                        if (separators)
                            columnSpan += totalColumns;
                        writer.AddAttribute(HtmlTextWriterAttribute.Colspan, columnSpan.ToString(NumberFormatInfo.InvariantInfo));
                    }
                    // add style attributes to render for TD
                    Style style = user.GetItemStyle(ListItemType.Header, -1);
                    if (style != null)
                        style.AddAttributesToRender(writer);
                    // render begin tag for TD
                    writer.RenderBeginTag(HtmlTextWriterTag.Td);
                }
                user.RenderItem(ListItemType.Header, -1, this, writer);
                if (tableLayout) {
                    // render end tag for TD
                    writer.RenderEndTag();

                    // render end tag for TR
                    writer.RenderEndTag();
                }
                else {
                    if (totalColumns < itemCount) {
                        // we have multiple rows, so have a break between the header and first row.
                        writer.WriteFullBeginTag("br");
                    }
                }
            }

            for (int i = 0; i < itemCount; i++) {
                if (tableLayout && (currentColumn == 0)) {
                    writer.RenderBeginTag(HtmlTextWriterTag.Tr);
                }

                if (tableLayout) {
                    // add style attributes to render for TD
                    Style style = user.GetItemStyle(ListItemType.Item, i);
                    if (style != null)
                        style.AddAttributesToRender(writer);
                    // render begin tag for TD
                    writer.RenderBeginTag(HtmlTextWriterTag.Td);
                }
                user.RenderItem(ListItemType.Item, i, this, writer);
                if (tableLayout) {
                    // render end tag for TD
                    writer.RenderEndTag();
                }
                if (separators && (i != (itemCount - 1))) {
                    if (tableLayout) {
                        Style style = user.GetItemStyle(ListItemType.Separator, i);
                        if (style != null)
                            style.AddAttributesToRender(writer);
                        writer.RenderBeginTag(HtmlTextWriterTag.Td);
                    }
                    user.RenderItem(ListItemType.Separator, i, this, writer);
                    if (tableLayout)
                        writer.RenderEndTag();
                }

                currentColumn++;
                if ((currentColumn == totalColumns) || (i == itemCount - 1)) {
                    if (tableLayout) {
                        // End tag for TR
                        writer.RenderEndTag();
                    }
                    else {
                        // write out the <br> after rows when there are multiple rows
                        if (totalColumns < itemCount) {
                            writer.WriteFullBeginTag("br");
                        }
                    }

                    currentColumn = 0;
                }
            }

            if (user.HasFooter) {
                if (tableLayout) {
                    writer.RenderBeginTag(HtmlTextWriterTag.Tr);

                    if ((totalColumns != 1) || separators) {
                        // add attributes to render for TD
                        int columnSpan = totalColumns;
                        if (separators)
                            columnSpan += totalColumns;
                        writer.AddAttribute(HtmlTextWriterAttribute.Colspan, columnSpan.ToString(NumberFormatInfo.InvariantInfo));
                    }
                    // add style attributes to render for TD
                    Style style = user.GetItemStyle(ListItemType.Footer, -1);
                    if (style != null)
                        style.AddAttributesToRender(writer);
                    // render begin tag for TD
                    writer.RenderBeginTag(HtmlTextWriterTag.Td);
                }
                user.RenderItem(ListItemType.Footer, -1, this, writer);
                if (tableLayout) {
                    // render end tag for TR and TD
                    writer.RenderEndTag();
                    writer.RenderEndTag();
                }
            }

            outerControl.RenderEndTag(writer);
        }

        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RenderRepeater"]/*' />
        /// <devdoc>
        ///    <para>Renders the Repeater with the specified
        ///       information.</para>
        /// </devdoc>
        public void RenderRepeater(HtmlTextWriter writer, IRepeatInfoUser user, Style controlStyle, WebControl baseControl) {
            if (repeatDirection == RepeatDirection.Vertical) {
                RenderVerticalRepeater(writer, user, controlStyle, baseControl);
            }
            else {
                RenderHorizontalRepeater(writer, user, controlStyle, baseControl);
            }
        }

        /// <include file='doc\RepeatInfo.uex' path='docs/doc[@for="RepeatInfo.RenderVerticalRepeater"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void RenderVerticalRepeater(HtmlTextWriter writer, IRepeatInfoUser user, Style controlStyle, WebControl baseControl) {
            int itemCount = user.RepeatedItemCount;
            int totalColumns;
            int totalRows;
            int filledColumns;

            if ((repeatColumns == 0) || (repeatColumns == 1)) {
                // A RepeatColumns of 0 implies a completely vertical repetition in
                // a single column. This is same as repeatColumns of 1.
                totalColumns = 1;
                filledColumns = 1;
                totalRows = itemCount;
            }
            else {
                totalColumns = repeatColumns;
                totalRows = (int)((itemCount + repeatColumns - 1) / repeatColumns);

                if ((totalRows == 0) && (itemCount != 0)) {
                    // if repeatColumns is a huge number like Int32.MaxValue, then the
                    // calculation above essentially reduces down to 0
                    totalRows = 1;
                    totalColumns = itemCount;
                }

                filledColumns = itemCount % totalColumns;
                    if (filledColumns == 0) {
                        filledColumns = totalColumns;
                    }

            }


            WebControl outerControl = null;
            bool tableLayout = false;

            if (outerTableImplied == false) {
                switch (repeatLayout) {
                    case RepeatLayout.Table:
                        outerControl = new Table();
                        tableLayout = true;
                        break;
                    case RepeatLayout.Flow:
                        outerControl = new WebControl(HtmlTextWriterTag.Span);
                        break;
                }
            }

            bool separators = user.HasSeparators;

            if (outerControl != null) {
                // use ClientID (and not ID) since we want to render out the fully qualified client id
                // even though this outer control will not be parented to the control hierarchy
                outerControl.ID = baseControl.ClientID;

                outerControl.CopyBaseAttributes(baseControl);
                outerControl.ApplyStyle(controlStyle);
                outerControl.RenderBeginTag(writer);
            }

            if (user.HasHeader) {
                if (tableLayout) {
                    writer.RenderBeginTag(HtmlTextWriterTag.Tr);

                    // add attributes to render for TD
                    if (totalColumns != 1) {
                        int columnSpan = totalColumns;
                        if (separators)
                            columnSpan += totalColumns;
                        writer.AddAttribute(HtmlTextWriterAttribute.Colspan, columnSpan.ToString(NumberFormatInfo.InvariantInfo));
                    }
                    // add style attributes to render for TD
                    Style style = user.GetItemStyle(ListItemType.Header, -1);
                    if (style != null)
                        style.AddAttributesToRender(writer);
                    // render begin tag for TD
                    writer.RenderBeginTag(HtmlTextWriterTag.Td);
                }
                user.RenderItem(ListItemType.Header, -1, this, writer);
                if (tableLayout) {
                    // render end tag for TR and TD
                    writer.RenderEndTag();
                    writer.RenderEndTag();
                }
                else if (outerTableImplied == false) {
                    writer.WriteFullBeginTag("br");
                }
            }

            int itemCounter = 0;

            for (int currentRow = 0; currentRow < totalRows; currentRow++) {
                if (tableLayout) {
                    writer.RenderBeginTag(HtmlTextWriterTag.Tr);
                }

                int itemIndex = currentRow;

                for (int currentCol = 0; currentCol < totalColumns; currentCol++) {
                    if (itemCounter >= itemCount) {
                        // done rendering all items, so break out of the loop now...
                        // we might end up here, in unfilled columns attempting to re-render items that
                        // have already been rendered on the next column in a prior row.
                        break;
                    }
                     
                    if (currentCol != 0) {
                        itemIndex += totalRows;
 
                        // if the previous column (currentColumn - 1) was not a filled column, i.e.,
                        // it had one less item (the maximum possible), then subtract 1 from the item index.
                        if ((currentCol - 1) >= filledColumns) {
                            itemIndex--;
                        }
                    }


                    if (itemIndex >= itemCount)
                        continue;

                    itemCounter++;

                    if (tableLayout) {
                        // add style attributes to render for TD
                        Style style = user.GetItemStyle(ListItemType.Item, itemIndex);
                        if (style != null)
                            style.AddAttributesToRender(writer);
                        // render begin tag for TD
                        writer.RenderBeginTag(HtmlTextWriterTag.Td);
                    }
                    user.RenderItem(ListItemType.Item, itemIndex, this, writer);
                    if (tableLayout) {
                        // render end tag for TD
                        writer.RenderEndTag();
                    }
                    if (separators && (itemIndex != (itemCount - 1))) {
                        if (totalColumns == 1) {
                            if (tableLayout) {
                                writer.RenderEndTag();
                                writer.RenderBeginTag(HtmlTextWriterTag.Tr);
                            }
                            else {
                                writer.WriteFullBeginTag("br");
                            }
                        }

                        if (tableLayout) {
                            Style style = user.GetItemStyle(ListItemType.Separator, itemIndex);
                            if (style != null)
                                style.AddAttributesToRender(writer);
                            writer.RenderBeginTag(HtmlTextWriterTag.Td);
                        }
                        if (itemIndex < itemCount)
                            user.RenderItem(ListItemType.Separator, itemIndex, this, writer);
                        if (tableLayout)
                            writer.RenderEndTag();
                    }
                }

                if (tableLayout) {
                    writer.RenderEndTag();
                }
                else {
                    if (((currentRow != totalRows - 1) || user.HasFooter) &&
                        (outerTableImplied == false)) {
                        writer.WriteFullBeginTag("br");
                    }
                }
            }

            if (user.HasFooter) {
                if (tableLayout) {
                    writer.RenderBeginTag(HtmlTextWriterTag.Tr);
                    // add attributes to render for TD
                    if (totalColumns != 1) {
                        int columnSpan = totalColumns;
                        if (separators)
                            columnSpan += totalColumns;
                        writer.AddAttribute(HtmlTextWriterAttribute.Colspan, columnSpan.ToString(NumberFormatInfo.InvariantInfo));
                    }
                    // add style attributes to render for TD
                    Style style = user.GetItemStyle(ListItemType.Footer, -1);
                    if (style != null)
                        style.AddAttributesToRender(writer);
                    // render begin tag for TD
                    writer.RenderBeginTag(HtmlTextWriterTag.Td);
                }
                user.RenderItem(ListItemType.Footer, -1, this, writer);
                if (tableLayout) {
                    // render end tag for TR and TD
                    writer.RenderEndTag();
                    writer.RenderEndTag();
                }
            }

            if (outerControl != null)
                outerControl.RenderEndTag(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\servervalidateeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServerValidateEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\ServerValidateEventArgs.uex' path='docs/doc[@for="ServerValidateEventArgs"]/*' />
    /// <devdoc>
    ///    <para>Provides data for the
    ///    <see langword='ServerValidate'/> event of the <see cref='System.Web.UI.WebControls.CustomValidator'/> .</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ServerValidateEventArgs : EventArgs {

        private bool isValid;
        private string value;

        /// <include file='doc\ServerValidateEventArgs.uex' path='docs/doc[@for="ServerValidateEventArgs.ServerValidateEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ServerValidateEventArgs'/> 
        /// class.</para>
        /// </devdoc>
        public ServerValidateEventArgs(string value, bool isValid) : base() {
            this.isValid = isValid;
            this.value = value;
        }

        /// <include file='doc\ServerValidateEventArgs.uex' path='docs/doc[@for="ServerValidateEventArgs.Value"]/*' />
        /// <devdoc>
        /// <para>Gets the string value to validate.</para>
        /// </devdoc>
        public string Value {
            get {
                return value;
            }
        }

        /// <include file='doc\ServerValidateEventArgs.uex' path='docs/doc[@for="ServerValidateEventArgs.IsValid"]/*' />
        /// <devdoc>
        ///    Gets or sets whether the input is valid.
        /// </devdoc>
        public bool IsValid {
            get {
                return isValid;
            }
            set {
                this.isValid = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\selecteddatescollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectedDatesCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection"]/*' />
    /// <devdoc>
    /// <para>Encapsulates the collection of <see cref='System.Web.UI.WebControls.Calendar.SelectedDates'/> within a <see cref='System.Web.UI.WebControls.Calendar'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class SelectedDatesCollection : ICollection {

        private ArrayList dateList;

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.SelectedDatesCollection"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.SelectedDatesCollection'/> class 
        ///    with the specified date list.</para>
        /// </devdoc>
        public SelectedDatesCollection(ArrayList dateList) {
            this.dateList = dateList;
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the item count of the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                return dateList.Count;
            }
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.DateTime' qualify='true'/> referenced by the specified ordinal index value in the collection.</para>
        /// </devdoc>
        public DateTime this[int index] {
            get { 
                return(DateTime) dateList[index];
            }
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.DateTime'/> to the end of the collection.</para>
        /// </devdoc>
        public void Add(DateTime date) {
            int index;            
            if (!FindIndex(date.Date, out index)) {
                dateList.Insert(index, date.Date);
            }
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.Clear"]/*' />
        /// <devdoc>
        /// <para>Removes all <see cref='System.DateTime'/> controls from the collection.</para>
        /// </devdoc>
        public void Clear() {
            dateList.Clear();
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>Returns a value indicating whether the collection contains the specified 
        ///       date.</para>
        /// </devdoc>
        public bool Contains(DateTime date) {
            int index;            
            return FindIndex(date.Date, out index);
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.FindIndex"]/*' />
        /// <devdoc>
        /// </devdoc>
        private bool FindIndex(DateTime date, out int index) {
            int n = Count;            
            int Min = 0;
            int Max = n;
            while (Min < Max) {
                index = (Min + Max ) / 2;
                if (date == this[index]) {
                    return true;
                }
                if (date < this[index]) {
                    Max = index;
                }
                else {
                    Min = index + 1;
                }
            }
            index = Min;
            return false;

        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Returns an enumerator of all <see cref='System.DateTime' qualify='true'/> controls within the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return dateList.GetEnumerator();
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies contents from the collection to a specified <see cref='System.Array' qualify='true'/> with a 
        ///    specified starting index.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object that can be used to synchronize access to the collection. In 
        ///       this case, it is the collection itself.</para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return false;}
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether access to the collection is synchronized 
        ///       (thread-safe).</para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }


        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified date from the collection.</para>
        /// </devdoc>
        public void Remove(DateTime date) {
            int index;            
            if (FindIndex(date.Date, out index)) {
                dateList.RemoveAt(index);
            }
        }

        /// <include file='doc\SelectedDatesCollection.uex' path='docs/doc[@for="SelectedDatesCollection.SelectRange"]/*' />
        /// <devdoc>
        /// <para>Sets the contents of the <see cref='System.Web.UI.WebControls.SelectedDatesCollection'/> to span
        ///    across the specified date range.</para>
        /// </devdoc>
        public void SelectRange(DateTime fromDate, DateTime toDate) {
            dateList.Clear();
            if (fromDate <= toDate) {
                for (DateTime date = fromDate.Date; date <= toDate.Date; date = date.AddDays(1)) {
                    dateList.Add(date);
                }
            }
        }        

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\repeatlayout.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeatLayout.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\RepeatLayout.uex' path='docs/doc[@for="RepeatLayout"]/*' />
    /// <devdoc>
    ///    <para>Specifies the layout of items of a list-bound control.</para>
    /// </devdoc>
    public enum RepeatLayout {

        /// <include file='doc\RepeatLayout.uex' path='docs/doc[@for="RepeatLayout.Table"]/*' />
        /// <devdoc>
        ///    <para>The items are displayed using a tabular layout.</para>
        /// </devdoc>
        Table = 0,

        /// <include file='doc\RepeatLayout.uex' path='docs/doc[@for="RepeatLayout.Flow"]/*' />
        /// <devdoc>
        ///    <para>The items are displayed using a flow layout.</para>
        /// </devdoc>
        Flow = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\requiredfieldvalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequiredFieldValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Security.Permissions;

    /// <include file='doc\RequiredFieldValidator.uex' path='docs/doc[@for="RequiredFieldValidator"]/*' />
    /// <devdoc>
    ///    <para> Checks if the value of
    ///       the associated input control is different from its initial value.</para>
    /// </devdoc>
    [
    ToolboxData("<{0}:RequiredFieldValidator runat=server ErrorMessage=\"RequiredFieldValidator\"></{0}:RequiredFieldValidator>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RequiredFieldValidator : BaseValidator {

        /// <include file='doc\RequiredFieldValidator.uex' path='docs/doc[@for="RequiredFieldValidator.InitialValue"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the initial value of the associated input control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.RequiredFieldValidator_InitialValue)
        ]                                         
        public string InitialValue {
            get { 
                object o = ViewState["InitialValue"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["InitialValue"] = value;
            }
        }

        /// <include file='doc\RequiredFieldValidator.uex' path='docs/doc[@for="RequiredFieldValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    AddAttributesToRender method
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);
            if (RenderUplevel) {
                writer.AddAttribute("evaluationfunction", "RequiredFieldValidatorEvaluateIsValid");
                writer.AddAttribute("initialvalue", InitialValue);
            }
        }    

        /// <include file='doc\RequiredFieldValidator.uex' path='docs/doc[@for="RequiredFieldValidator.EvaluateIsValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    EvaluateIsValid method
        /// </devdoc>
        protected override bool EvaluateIsValid() {

            // Get the control value, return true if it is not found
            string controlValue = GetControlValidationValue(ControlToValidate);
            if (controlValue == null) {
                Debug.Fail("Should have been caught by PropertiesValid check");
                return true;
            }

            // See if the control has changed
            return(!controlValue.Trim().Equals(InitialValue.Trim()));
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tablecellcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableCellCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection"]/*' />
    /// <devdoc>
    /// <para>Encapsulates the collection of <see cref='System.Web.UI.WebControls.TableHeaderCell'/> and <see cref='System.Web.UI.WebControls.TableCell'/> objects within a 
    /// <see cref='System.Web.UI.WebControls.Table'/> 
    /// control.</para>
    /// </devdoc>
    [
    Editor("System.Web.UI.Design.WebControls.TableCellsCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class TableCellCollection : IList {
        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.owner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A protected field of type <see cref='System.Web.UI.WebControls.TableRow'/>. Represents the
        ///    <see cref='System.Web.UI.WebControls.TableCell'/>
        ///    collection internally.
        /// </para>
        /// </devdoc>
        private TableRow owner;

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.TableCellCollection"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal TableCellCollection(TableRow owner) {
            this.owner = owner;
        }
        
        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.Count"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Web.UI.WebControls.TableCell'/>
        /// count in the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                if (owner.HasControls()) {
                    return owner.Controls.Count;
                }
                return 0;
            }
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a <see cref='System.Web.UI.WebControls.TableCell'/>
        ///       referenced by the specified
        ///       ordinal index value.
        ///    </para>
        /// </devdoc>
        public TableCell this[int index] {
            get {
                return(TableCell)owner.Controls[index];
            }
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified <see cref='System.Web.UI.WebControls.TableCell'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public int Add(TableCell cell) {
            AddAt(-1, cell);
            return owner.Controls.Count - 1;
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.AddAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified <see cref='System.Web.UI.WebControls.TableCell'/> to the collection at the specified
        ///       index location.
        ///    </para>
        /// </devdoc>
        public void AddAt(int index, TableCell cell) {
            owner.Controls.AddAt(index, cell);
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.AddRange"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void AddRange(TableCell[] cells) {
            if (cells == null) {
                throw new ArgumentNullException("cells");
            }
            foreach(TableCell cell in cells) {
                Add(cell);
            }
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.Clear"]/*' />
        /// <devdoc>
        /// <para>Removes all <see cref='System.Web.UI.WebControls.TableCell'/> controls 
        ///    from the collection.</para>
        /// </devdoc>
        public void Clear() {
            if (owner.HasControls()) {
                owner.Controls.Clear();
            }
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.GetCellIndex"]/*' />
        /// <devdoc>
        ///    <para>Returns an ordinal index value that represents the position of the
        ///       specified <see cref='System.Web.UI.WebControls.TableCell'/> within the collection.</para>
        /// </devdoc>
        public int GetCellIndex(TableCell cell) {
            if (owner.HasControls()) {
                return owner.Controls.IndexOf(cell);
            }
            return -1;
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an enumerator of all <see cref='System.Web.UI.WebControls.TableCell'/> controls within the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return owner.Controls.GetEnumerator();
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies contents from the collection to the specified <see cref='System.Array' qualify='true'/> with the
        ///    specified starting index.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the object that can be used to synchronize access to the
        ///       collection. In this case, it is the collection itself.
        ///    </para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection is read-only.
        ///    </para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return false;}
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether access to the collection is synchronized
        ///       (thread-safe).
        ///    </para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified <see cref='System.Web.UI.WebControls.TableCell'/> from the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public void Remove(TableCell cell) {
            owner.Controls.Remove(cell);
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the <see cref='System.Web.UI.WebControls.TableCell'/> from the collection at the
        ///       specified index location.
        ///    </para>
        /// </devdoc>
        public void RemoveAt(int index) {
            owner.Controls.RemoveAt(index);
        }

        // IList implementation, required by collection editor
        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return owner.Controls[index];
            }
            set {
                RemoveAt(index);
                AddAt(index, (TableCell)value);
            }
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object o) {
            return Add((TableCell) o);            
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object o) {
            return owner.Controls.Contains((TableCell)o);
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object o) {
            return owner.Controls.IndexOf((TableCell)o);
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object o) {
            owner.Controls.AddAt(index, (TableCell)o);
        }

        /// <include file='doc\TableCellCollection.uex' path='docs/doc[@for="TableCellCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object o) {
            owner.Controls.Remove((TableCell)o);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tablecell.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableCell.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCellControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.TableCell'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TableCellControlBuilder : ControlBuilder {

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCellControlBuilder.AllowWhitespaceLiterals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Specifies whether white space literals are allowed.
        /// </devdoc>
        public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }


    /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell"]/*' />
    /// <devdoc>
    ///    <para>Encapsulates a cell within a table.</para>
    /// </devdoc>
    [
    ControlBuilderAttribute(typeof(TableCellControlBuilder)),
    DefaultProperty("Text"),
    ParseChildren(false),
    PersistChildren(true),
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TableCell : WebControl {

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.TableCell"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.TableCell'/> class.
        ///    </para>
        /// </devdoc>
        public TableCell() : base(HtmlTextWriterTag.Td) {
            PreventAutoID();
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.TableCell1"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal TableCell(HtmlTextWriterTag tagKey) : base(tagKey) {
            PreventAutoID();
        }


        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.ColumnSpan"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number
        ///       of columns this table cell stretches horizontally.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(0),
        WebSysDescription(SR.TableCell_ColumnSpan)
        ]
        public virtual int ColumnSpan {
            get {
                object o = ViewState["ColumnSpan"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["ColumnSpan"] = value;
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the horizontal alignment of the content within the cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.TableCell_HorizontalAlign)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                if (ControlStyleCreated == false) {
                    return HorizontalAlign.NotSet;
                }
                return ((TableItemStyle)ControlStyle).HorizontalAlign;
            }
            set {
                ((TableItemStyle)ControlStyle).HorizontalAlign = value;
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.RowSpan"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the
        ///       number of rows this table cell stretches vertically.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(0),
        WebSysDescription(SR.TableCell_RowSpan)
        ]
        public virtual int RowSpan {
            get {
                object o = ViewState["RowSpan"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RowSpan"] = value;
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.Text"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the text contained in the cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.TableCell_Text)
        ]
        public virtual string Text {
            get {
                object o = ViewState["Text"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                if (HasControls()) {
                    Controls.Clear();
                }
                ViewState["Text"] = value;
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.VerticalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the vertical alignment of the content within the cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(VerticalAlign.NotSet),
        WebSysDescription(SR.TableCell_VerticalAlign)
        ]
        public virtual VerticalAlign VerticalAlign {
            get {
                if (ControlStyleCreated == false) {
                    return VerticalAlign.NotSet;
                }
                return ((TableItemStyle)ControlStyle).VerticalAlign;
            }
            set {
                ((TableItemStyle)ControlStyle).VerticalAlign = value;
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.Wrap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       whether the cell content wraps within the cell.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(true),
        WebSysDescription(SR.TableCell_Wrap)
        ]
        public virtual bool Wrap {
            get {
                if (ControlStyleCreated == false) {
                    return true;
                }
                return ((TableItemStyle)ControlStyle).Wrap;
            }
            set {
                ((TableItemStyle)ControlStyle).Wrap = value;
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected method. Adds information about the column
        ///       span and row span to the list of attributes to render.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);

            int span = ColumnSpan;
            if (span > 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Colspan, span.ToString(NumberFormatInfo.InvariantInfo));

            span = RowSpan;
            if (span > 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Rowspan, span.ToString(NumberFormatInfo.InvariantInfo));
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.AddParsedSubObject"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            if (HasControls()) {
                base.AddParsedSubObject(obj);
            }
            else {
                if (obj is LiteralControl) {
                    Text = ((LiteralControl)obj).Text;
                }
                else {
                    string currentText = Text;
                    if (currentText.Length != 0) {
                        Text = String.Empty;
                        base.AddParsedSubObject(new LiteralControl(currentText));
                    }
                    base.AddParsedSubObject(obj);
                }
            }
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected 
        ///       method. Creates a table item control
        ///       style.</para>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            return new TableItemStyle(ViewState);
        }

        /// <include file='doc\TableCell.uex' path='docs/doc[@for="TableCell.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected method.</para>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            // We can't use HasControls() here, because we may have a compiled render method (ASURT 94127)
            if (HasRenderingData()) {
                base.RenderContents(writer);
            }
            else {
                writer.Write(Text);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\style.cs ===
//------------------------------------------------------------------------------
// <copyright file="Style.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Text;
    using System.Web;
    using System.Web.UI;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\Style.uex' path='docs/doc[@for="Style"]/*' />
    /// <devdoc>
    /// <para> Defines the properties and methods of the <see cref='System.Web.UI.WebControls.Style'/> class.</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    TypeConverterAttribute(typeof(ExpandableObjectConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Style : Component, IStateManager {

        internal const int UNUSED = 0x0001;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_CSSCLASS"]/*' />
        /// <devdoc>
        ///    <para>Specifies the CSS class property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_CSSCLASS = 0x0002;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FORECOLOR"]/*' />
        /// <devdoc>
        ///    <para>Specifies the foreground color property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FORECOLOR = 0x0004;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_BACKCOLOR"]/*' />
        /// <devdoc>
        ///    <para>Specifies the background color property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_BACKCOLOR = 0x0008;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_BORDERCOLOR"]/*' />
        /// <devdoc>
        ///    <para>Specifies the border color property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_BORDERCOLOR = 0x0010;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_BORDERWIDTH"]/*' />
        /// <devdoc>
        ///    <para>Specifies the border width property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_BORDERWIDTH = 0x0020;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_BORDERSTYLE"]/*' />
        /// <devdoc>
        ///    <para>Specifies the border style property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_BORDERSTYLE = 0x0040;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_HEIGHT"]/*' />
        /// <devdoc>
        ///    <para>Specifies the height property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_HEIGHT = 0x0080;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_WIDTH"]/*' />
        /// <devdoc>
        ///    <para>Specifies the width property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_WIDTH = 0x0100;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_NAMES"]/*' />
        /// <devdoc>
        ///    <para>Specifies the names
        ///       sub-property of the font property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_NAMES = 0x0200;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_SIZE"]/*' />
        /// <devdoc>
        ///    <para>Specifies the size sub-property of the font
        ///       property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_SIZE = 0x0400;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_BOLD"]/*' />
        /// <devdoc>
        ///    <para> Specifies
        ///       the bold sub-property of the font property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_BOLD = 0x0800;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_ITALIC"]/*' />
        /// <devdoc>
        ///    <para> Specifies the italic
        ///       sub-property of the font property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_ITALIC = 0x1000;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_UNDERLINE"]/*' />
        /// <devdoc>
        ///    <para> Specifies
        ///       the underline sub-property of the font property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_UNDERLINE = 0x2000;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_OVERLINE"]/*' />
        /// <devdoc>
        ///    <para>Specifies the overline
        ///       sub-property of the font property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_OVERLINE = 0x4000;
        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.PROP_FONT_STRIKEOUT"]/*' />
        /// <devdoc>
        ///    <para>Specifies the strikeout sub-property of the font property. This field is constant.</para>
        /// </devdoc>
        internal const int PROP_FONT_STRIKEOUT = 0x8000;

        internal const string SetBitsKey = "_!SB";

        private StateBag statebag;
        private FontInfo fontInfo;
        private bool ownStateBag;
        private bool marked;
        private int setBits;
        private int markedBits;

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.Style"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.Style'/> class.
        ///    </para>
        /// </devdoc>
        public Style() : this(null) {
            this.ownStateBag = true;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.Style1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.Style'/> class with the
        ///       specified state bag information.
        ///    </para>
        /// </devdoc>
        public Style(StateBag bag) : base() {
            this.statebag = bag;
            this.marked = false;
            this.setBits = 0;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.BackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color property of the <see cref='System.Web.UI.WebControls.Style'/> class.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Color), ""),
        WebSysDescription(SR.Style_BackColor),
        NotifyParentProperty(true),
        TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public Color BackColor {
            get {
                if (IsSet(PROP_BACKCOLOR)) {
                    return(Color)(ViewState["BackColor"]);
                }
                return Color.Empty;
            }
            set {
                ViewState["BackColor"] = value;
                SetBit(PROP_BACKCOLOR);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border color property of the <see cref='System.Web.UI.WebControls.Style'/> class.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Color), ""),
        WebSysDescription(SR.Style_BorderColor),
        NotifyParentProperty(true),
        TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public Color BorderColor {
            get {
                if (IsSet(PROP_BORDERCOLOR)) {
                    return(Color)(ViewState["BorderColor"]);
                }
                return Color.Empty;
            }
            set {
                ViewState["BorderColor"] = value;
                SetBit(PROP_BORDERCOLOR);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.BorderWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border width property of the <see cref='System.Web.UI.WebControls.Style'/> class.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Unit), ""),
        WebSysDescription(SR.Style_BorderWidth),
        NotifyParentProperty(true)
        ]
        public Unit BorderWidth {
            get {
                if (IsSet(PROP_BORDERWIDTH)) {
                    return(Unit)(ViewState["BorderWidth"]);
                }
                return Unit.Empty;
            }
            set {
                if ((value.Type == UnitType.Percentage) || (value.Value < 0)) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["BorderWidth"] = value;
                SetBit(PROP_BORDERWIDTH);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.BorderStyle"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the border style property of the <see cref='System.Web.UI.WebControls.Style'/>
        /// class.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(BorderStyle.NotSet),
        WebSysDescription(SR.Style_BorderStyle),
        NotifyParentProperty(true)
        ]
        public BorderStyle BorderStyle {
            get {
                if (IsSet(PROP_BORDERSTYLE)) {
                    return(BorderStyle)(ViewState["BorderStyle"]);
                }
                return BorderStyle.NotSet;
            }
            set {
                if (value < BorderStyle.NotSet || value > BorderStyle.Outset) {
                    throw new ArgumentOutOfRangeException("value");                    
                }
                ViewState["BorderStyle"] = value;
                SetBit(PROP_BORDERSTYLE);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.CssClass"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the CSS class property of the <see cref='System.Web.UI.WebControls.Style'/> class.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.Style_CSSClass),
        NotifyParentProperty(true)
        ]
        public string CssClass {
            get {
                if (IsSet(PROP_CSSCLASS)) {
                    return(string)(ViewState["CssClass"]);
                }
                return String.Empty;
            }
            set {
                if (value == null)
                    throw new ArgumentOutOfRangeException("value");
                ViewState["CssClass"] = value;
                SetBit(PROP_CSSCLASS);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.Font"]/*' />
        /// <devdoc>
        /// <para>Gets font information of the <see cref='System.Web.UI.WebControls.Style'/> class.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        WebSysDescription(SR.Style_Font),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true)
        ]
        public FontInfo Font {
            get {
                if (fontInfo == null)
                    fontInfo = new FontInfo(this);
                return fontInfo;
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color (typically the color
        ///       of the text) property of the <see cref='System.Web.UI.WebControls.Style'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Color), ""),
        WebSysDescription(SR.Style_ForeColor),
        NotifyParentProperty(true),
        TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public Color ForeColor {
            get {
                if (IsSet(PROP_FORECOLOR)) {
                    return(Color)(ViewState["ForeColor"]);
                }
                return Color.Empty;
            }
            set {
                ViewState["ForeColor"] = value;
                SetBit(PROP_FORECOLOR);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the height property of the <see cref='System.Web.UI.WebControls.Style'/> class.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(typeof(Unit), ""),
        WebSysDescription(SR.Style_Height),
        NotifyParentProperty(true)
        ]
        public Unit Height {
            get {
                if (IsSet(PROP_HEIGHT)) {
                    return(Unit)(ViewState["Height"]);
                }
                return Unit.Empty;
            }
            set {
                if (value.Value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Height"] = value;
                SetBit(PROP_HEIGHT);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IsEmpty"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected property. Gets a value indicating whether any style elements have
        ///       been defined in the state bag.</para>
        /// </devdoc>
        protected virtual internal bool IsEmpty {
            get {
                return(setBits == 0);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.ViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Gets the state bag that holds the style elements.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected internal StateBag ViewState {
            get {
                if (statebag == null) {
                    statebag = new StateBag(false);
                    if (IsTrackingViewState)
                        statebag.TrackViewState();
                }
                return statebag;
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width property of the <see cref='System.Web.UI.WebControls.Style'/> class.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(typeof(Unit), ""),
        WebSysDescription(SR.Style_Width),
        NotifyParentProperty(true)
        ]
        public Unit Width {
            get {
                if (IsSet(PROP_WIDTH)) {
                    return(Unit)(ViewState["Width"]);
                }
                return Unit.Empty;
            }
            set {
                if (value.Value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Width"] = value;
                SetBit(PROP_WIDTH);
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.AddAttributesToRender"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void AddAttributesToRender(HtmlTextWriter writer) {
            AddAttributesToRender(writer, null);
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.AddAttributesToRender1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds all non-blank style attributes to the HTML output stream to be rendered
        ///       to the client.
        ///    </para>
        /// </devdoc>
        public virtual void AddAttributesToRender(HtmlTextWriter writer, WebControl owner) {
            StateBag viewState = ViewState;
            
            // CssClass
            if (IsSet(PROP_CSSCLASS)) {
                string css = (string)(viewState["CssClass"]);
                if (css.Length > 0)
                   writer.AddAttribute(HtmlTextWriterAttribute.Class, css);
            }

            Color c;
            Unit u;
            // ForeColor
            if (IsSet(PROP_FORECOLOR)) {
                c = (Color)(viewState["ForeColor"]);;
                if (!c.IsEmpty)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.Color, ColorTranslator.ToHtml(c));
            }

            // BackColor
            if (IsSet(PROP_BACKCOLOR)) {
                c = (Color)(viewState["BackColor"]);
                if (!c.IsEmpty)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.BackgroundColor, ColorTranslator.ToHtml(c));
            }

            // BorderColor
            if (IsSet(PROP_BORDERCOLOR)) {
                c = (Color)(viewState["BorderColor"]);
                if (!c.IsEmpty)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.BorderColor, ColorTranslator.ToHtml(c));
            }

            BorderStyle bs = this.BorderStyle;
            Unit bu = this.BorderWidth;

            if (!bu.IsEmpty) {
                writer.AddStyleAttribute(HtmlTextWriterStyle.BorderWidth, bu.ToString(CultureInfo.InvariantCulture));
                if (bs == BorderStyle.NotSet) {
                    if (bu.Value != 0.0)
                        writer.AddStyleAttribute(HtmlTextWriterStyle.BorderStyle, "solid");
                }
                else {
                    writer.AddStyleAttribute(HtmlTextWriterStyle.BorderStyle, Enum.Format(typeof(BorderStyle),bs, "G"));
                }
            }
            else {
                if (bs != BorderStyle.NotSet)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.BorderStyle, Enum.Format(typeof(BorderStyle),bs, "G"));
            }

            // need to call the property get in case we have font properties from view state and have not
            // created the font object
            FontInfo font = Font;

            // Font.Names
            string[] names = font.Names;
            if (names.Length > 0)
                writer.AddStyleAttribute(HtmlTextWriterStyle.FontFamily, Style.FormatStringArray(names, ','));

            // Font.Size
            FontUnit fu = font.Size;
            if (fu.IsEmpty == false)
                writer.AddStyleAttribute(HtmlTextWriterStyle.FontSize, fu.ToString(CultureInfo.InvariantCulture));

            // CONSIDER: How do we determine whether to render "normal" for font-weight or font-style?
            //           How do we determine whether to render "none" for text-decoration?

            // Font.Bold
            bool fw = font.Bold;
            if (fw == true)
                writer.AddStyleAttribute(HtmlTextWriterStyle.FontWeight, "bold");
            // Font.Italic
            bool fi = font.Italic;
            if (fi == true)
                writer.AddStyleAttribute(HtmlTextWriterStyle.FontStyle, "italic");

            bool underline = font.Underline;
            bool overline = font.Overline;
            bool strikeout = font.Strikeout;
            string td = String.Empty;

            // CONSIDER, nikhilko: we need to detect not-set state and write out "none"
            if (underline)
                td = "underline";
            if (overline)
                td += " overline";
            if (strikeout)
                td += " line-through";
            if (td.Length > 0)
                writer.AddStyleAttribute(HtmlTextWriterStyle.TextDecoration, td);


            // Height
            if (IsSet(PROP_HEIGHT)) {
                u = (Unit)(viewState["Height"]);
                if (u.IsEmpty == false)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.Height, u.ToString(CultureInfo.InvariantCulture));
            }

            // Width
            if (IsSet(PROP_WIDTH)) {
                u = (Unit)(viewState["Width"]);
                if (u.IsEmpty == false)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.Width, u.ToString(CultureInfo.InvariantCulture));
            }
        }


        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.CopyFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies non-blank elements from the specified style,
        ///       overwriting existing style elements if necessary.
        ///    </para>
        /// </devdoc>
        public virtual void CopyFrom(Style s) {
            if (s != null && !s.IsEmpty) {

                this.Font.CopyFrom(s.Font);

                if (s.IsSet(PROP_CSSCLASS))
                    this.CssClass = s.CssClass;
                if (s.IsSet(PROP_BACKCOLOR) && (s.BackColor != Color.Empty))
                    this.BackColor = s.BackColor;
                if (s.IsSet(PROP_FORECOLOR) && (s.ForeColor != Color.Empty))
                    this.ForeColor = s.ForeColor;
                if (s.IsSet(PROP_BORDERCOLOR) && (s.BorderColor != Color.Empty))
                    this.BorderColor = s.BorderColor;
                if (s.IsSet(PROP_BORDERWIDTH) && (s.BorderWidth != Unit.Empty))
                    this.BorderWidth = s.BorderWidth;
                if (s.IsSet(PROP_BORDERSTYLE))
                    this.BorderStyle = s.BorderStyle;
                if (s.IsSet(PROP_HEIGHT) && (s.Height != Unit.Empty))
                    this.Height = s.Height;
                if (s.IsSet(PROP_WIDTH) && (s.Width != Unit.Empty))
                    this.Width = s.Width;

            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.FormatStringArray"]/*' />
        /// <devdoc>
        /// </devdoc>
        private static string FormatStringArray(string[] array, char delimiter) {
            int n = array.Length;
            string retValue = String.Empty;

            if (n == 1) {
                return array[0];
            }
            else if (n != 0) {
                StringBuilder sb = new StringBuilder(n * array[0].Length);
                string s;

                for (int i = 0; i < n; i++) {
                    s = array[i].ToString();

                    if (i > 0) {
                        // stick in the delimiter between values
                        sb.Append(delimiter);
                    }
                    sb.Append(s);
                }

                retValue = sb.ToString();
            }
            return retValue;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IsTrackingViewState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A protected method. Returns a value indicating whether
        ///       any style elements have been defined in the state bag.
        ///    </para>
        /// </devdoc>
        protected bool IsTrackingViewState {
            get {
                return marked;
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IsSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a value indicating whether the specified style
        ///       property has been defined in
        ///       the state bag.
        ///    </para>
        /// </devdoc>
        internal bool IsSet(int propKey) {
            return (setBits & propKey) != 0;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.LoadViewState"]/*' />
        /// <devdoc>
        ///    <para>A protected method. Load the previously saved state.</para>
        /// </devdoc>
        protected internal void LoadViewState(object state) {
            if (state != null && ownStateBag)
                ViewState.LoadViewState(state);

            if (statebag != null) {
                object o = ViewState[SetBitsKey];
                if (o != null) {
                    markedBits = (int)o;

                    // markedBits indicates properties that got reloaded into
                    // view state, so update setBits, to indicate these
                    // properties are set as well.
                    setBits |= markedBits;
                }
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.TrackViewState"]/*' />
        /// <devdoc>
        ///    A protected method. Marks the beginning for tracking
        ///    state changes on the control. Any changes made after "mark" will be tracked and
        ///    saved as part of the control viewstate.
        /// </devdoc>
        protected internal virtual void TrackViewState() {
            if (ownStateBag) {
                ViewState.TrackViewState();
            }

            marked = true;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.MergeWith"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies non-blank elements from the specified style,
        ///       but will not overwrite any existing style elements.
        ///    </para>
        /// </devdoc>
        public virtual void MergeWith(Style s) {
            if (s == null || s.IsEmpty)
                return;

            if (IsEmpty) {
                // merge into an empty style is equivalent to a copy, which
                // is more efficient
                CopyFrom(s);
                return;
            }

            this.Font.MergeWith(s.Font);

            if (s.IsSet(PROP_CSSCLASS) && !this.IsSet(PROP_CSSCLASS))
                this.CssClass = s.CssClass;
            if (s.IsSet(PROP_BACKCOLOR) && (!this.IsSet(PROP_BACKCOLOR) || (BackColor == Color.Empty)))
                this.BackColor = s.BackColor;
            if (s.IsSet(PROP_FORECOLOR) && (!this.IsSet(PROP_FORECOLOR) || (ForeColor == Color.Empty)))
                this.ForeColor = s.ForeColor;
            if (s.IsSet(PROP_BORDERCOLOR) && (!this.IsSet(PROP_BORDERCOLOR) || (BorderColor == Color.Empty)))
                this.BorderColor = s.BorderColor;
            if (s.IsSet(PROP_BORDERWIDTH) && (!this.IsSet(PROP_BORDERWIDTH) || (BorderWidth == Unit.Empty)))
                this.BorderWidth = s.BorderWidth;
            if (s.IsSet(PROP_BORDERSTYLE) && !this.IsSet(PROP_BORDERSTYLE))
                this.BorderStyle = s.BorderStyle;
            if (s.IsSet(PROP_HEIGHT) && (!this.IsSet(PROP_HEIGHT) || (Height == Unit.Empty)))
                this.Height = s.Height;
            if (s.IsSet(PROP_WIDTH) && (!this.IsSet(PROP_WIDTH) || (Width == Unit.Empty)))
                this.Width = s.Width;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears out any defined style elements from the state bag.
        ///    </para>
        /// </devdoc>
        public virtual void Reset() {
            if (statebag != null) {
                if (IsSet(PROP_CSSCLASS))
                    ViewState.Remove("CssClass");
                if (IsSet(PROP_BACKCOLOR))
                    ViewState.Remove("BackColor");
                if (IsSet(PROP_FORECOLOR))
                    ViewState.Remove("ForeColor");
                if (IsSet(PROP_BORDERCOLOR))
                    ViewState.Remove("BorderColor");
                if (IsSet(PROP_BORDERWIDTH))
                    ViewState.Remove("BorderWidth");
                if (IsSet(PROP_BORDERSTYLE))
                    ViewState.Remove("BorderStyle");
                if (IsSet(PROP_HEIGHT))
                    ViewState.Remove("Height");
                if (IsSet(PROP_WIDTH))
                    ViewState.Remove("Width");

                Font.Reset();

                ViewState.Remove(SetBitsKey);
                markedBits = 0;
            }

            setBits = 0;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.SaveViewState"]/*' />
        /// <devdoc>
        ///    <para>A protected method. Saves any state that has been modified 
        ///       after the TrackViewState method was invoked.</para>
        /// </devdoc>
        protected internal virtual object SaveViewState() {
            if (statebag != null) {
                if (markedBits != 0) {
                    // new bits or properties were changed
                    // updating the state bag at this point will automatically mark
                    // SetBitsKey as dirty, and it will be added to the resulting viewstate
                    ViewState[SetBitsKey] = markedBits;
                }

                if (ownStateBag)
                    return ViewState.SaveViewState();
            }
            return null;
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.SetBit"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    A protected internal method.
        /// </devdoc>
        protected internal virtual void SetBit(int bit) {
            setBits |= bit;
            if (IsTrackingViewState) {
                // since we're tracking changes, include this property change or
                // bit into the markedBits flag set.
                markedBits |= bit;
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Overrides the <see langword='ToString'/>
        /// method to return <see cref='System.String.Empty' qualify='true'/>.</para>
        /// </devdoc>
        public override string ToString() {
            return String.Empty;
        }


        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IStateManager.IsTrackingViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return true if tracking state changes.
        /// </devdoc>
        bool IStateManager.IsTrackingViewState {
            get {
                return IsTrackingViewState;
            }
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IStateManager.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Load previously saved state.
        /// </devdoc>
        void IStateManager.LoadViewState(object state) {
            LoadViewState(state);
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IStateManager.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Start tracking state changes.
        /// </devdoc>
        void IStateManager.TrackViewState() {
            TrackViewState();
        }

        /// <include file='doc\Style.uex' path='docs/doc[@for="Style.IStateManager.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return object containing state changes.
        /// </devdoc>
        object IStateManager.SaveViewState() {
            return SaveViewState();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\servervalidateeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServerValidateEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\ServerValidateEventHandler.uex' path='docs/doc[@for="ServerValidateEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see langword='ServerValidate'/> event of a 
    /// <see cref='System.Web.UI.WebControls.CustomValidator'/>.</para>
    /// </devdoc>
    public delegate void ServerValidateEventHandler(object source, ServerValidateEventArgs args);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tableheadercell.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableHeaderCell.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// TableHeaderCell.cs
//

namespace System.Web.UI.WebControls {

    using System;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableHeaderCell.uex' path='docs/doc[@for="TableHeaderCell"]/*' />
    /// <devdoc>
    ///    <para> Encapsulates
    ///       a header cell within a table.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TableHeaderCell : TableCell {

        /// <include file='doc\TableHeaderCell.uex' path='docs/doc[@for="TableHeaderCell.TableHeaderCell"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.TableHeaderCell'/> class.
        ///    </para>
        /// </devdoc>
        public TableHeaderCell() : base(HtmlTextWriterTag.Th) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\table.cs ===
//------------------------------------------------------------------------------
// <copyright file="Table.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.IO;
    using System.Web;
    using System.Security.Permissions;

    /// <include file='doc\Table.uex' path='docs/doc[@for="Table"]/*' />
    /// <devdoc>
    ///    <para>Constructs a table and defines its properties.</para>
    /// </devdoc>
    [
    DefaultProperty("Rows"),
    ParseChildren(true, "Rows"),
    Designer("System.Web.UI.Design.WebControls.TableDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Table : WebControl {

        TableRowCollection rows;

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.Table"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.Table'/> class.
        ///    </para>
        /// </devdoc>
        public Table() : base(HtmlTextWriterTag.Table) {
        }


        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.BackImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Indicates the URL of the background image to display 
        ///       behind the table. The image will be tiled if it is smaller than the table.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.ImageUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.Table_BackImageUrl)
        ]
        public virtual string BackImageUrl {
            get {
                if (ControlStyleCreated == false) {
                    return String.Empty;
                }
                return ((TableStyle)ControlStyle).BackImageUrl;
            }
            set {
                ((TableStyle)ControlStyle).BackImageUrl = value;
            }
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.CellSpacing"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets
        ///       the distance (in pixels) between table cells.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(-1),
        WebSysDescription(SR.Table_CellSpacing)
        ]
        public virtual int CellSpacing {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellSpacing;
            }
            set {
                ((TableStyle)ControlStyle).CellSpacing = value;
            }
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.CellPadding"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the distance (in pixels) between the border and
        ///       the contents of the table cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(-1),
        WebSysDescription(SR.Table_CellPadding)
        ]
        public virtual int CellPadding {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellPadding;
            }
            set {
                ((TableStyle)ControlStyle).CellPadding = value;
            }
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.GridLines"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the gridlines property of the <see cref='System.Web.UI.WebControls.Table'/>
        /// class.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(GridLines.None),
        WebSysDescription(SR.Table_GridLines)
        ]
        public virtual GridLines GridLines {
            get {
                if (ControlStyleCreated == false) {
                    return GridLines.None;
                }
                return ((TableStyle)ControlStyle).GridLines;
            }
            set {
                ((TableStyle)ControlStyle).GridLines = value;
            }
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the horizontal alignment of the table within the page.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.Table_HorizontalAlign)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                if (ControlStyleCreated == false) {
                    return HorizontalAlign.NotSet;
                }
                return ((TableStyle)ControlStyle).HorizontalAlign;
            }
            set {
                ((TableStyle)ControlStyle).HorizontalAlign = value;
            }
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.Rows"]/*' />
        /// <devdoc>
        ///    <para> Gets the collection of rows within
        ///       the table.</para>
        /// </devdoc>
        [
        MergableProperty(false),
        WebSysDescription(SR.Table_Rows),
        PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual TableRowCollection Rows {
            get {
                if (rows == null)
                    rows = new TableRowCollection(this);
                return rows;
            }
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected method. Adds information about the border
        ///       color and border width HTML attributes to the list of attributes to render.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            base.AddAttributesToRender(writer);

            // Must render bordercolor attribute to affect cell borders.
            Color borderColor = BorderColor;
            if (!borderColor.IsEmpty) {
                writer.AddAttribute(HtmlTextWriterAttribute.Bordercolor, ColorTranslator.ToHtml(borderColor));
            }

            // GridLines property controls whether we render the "border" attribute, as "border" controls
            // whether gridlines appear in HTML 3.2. Always render a value for the border attribute.
            Unit borderWidth = BorderWidth;
            GridLines gridLines= GridLines;
            if (gridLines == GridLines.None) 
                borderWidth = Unit.Pixel(0);
            else {
                if (borderWidth.IsEmpty || borderWidth.Type != UnitType.Pixel) {
                    borderWidth = Unit.Pixel(1);
                }
            }
            writer.AddAttribute(HtmlTextWriterAttribute.Border, ((int)borderWidth.Value).ToString(NumberFormatInfo.InvariantInfo));
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected method. Creates a table control style.</para>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            return new TableStyle(ViewState);
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    A protected method.
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            IEnumerator rowEnum = Rows.GetEnumerator();
            TableRow row;
            while (rowEnum.MoveNext()) {
                row = (TableRow)rowEnum.Current;
                row.RenderControl(writer);
            }
        }
    
        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new RowControlCollection(this);
        }

        /// <include file='doc\Table.uex' path='docs/doc[@for="Table.RowControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected class RowControlCollection : ControlCollection {

            internal RowControlCollection (Control owner) : base(owner) {
            }

            /// <include file='doc\Table.uex' path='docs/doc[@for="Table.RowControlCollection.Add"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the end of the array.</para>
            /// </devdoc>
            public override void Add(Control child) {
                if (child is TableRow)
                    base.Add(child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "Table", child.GetType().Name.ToString())); // throw an exception here
            }

            /// <include file='doc\Table.uex' path='docs/doc[@for="Table.RowControlCollection.AddAt"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the array at the specified index location.</para>
            /// </devdoc>
            public override void AddAt(int index, Control child) {
                if (child is TableRow)
                    base.AddAt(index, child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "Table", child.GetType().Name.ToString())); // throw an exception here
            }
        } // class RowControlCollection 
    } // class Table
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tablerowcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableRowCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection"]/*' />
    /// <devdoc>
    /// <para>Encapsulates the collection of <see cref='System.Web.UI.WebControls.TableRow'/> objects within a <see cref='System.Web.UI.WebControls.Table'/> control.</para>
    /// </devdoc>
    [
    Editor("System.Web.UI.Design.WebControls.TableRowsCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class TableRowCollection : IList {

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.owner"]/*' />
        /// <devdoc>
        ///    A protected field of type <see cref='System.Web.UI.WebControls.Table'/>. Represents the <see cref='System.Web.UI.WebControls.TableRow'/> collection internally.
        /// </devdoc>
        private Table owner;

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.TableRowCollection"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal TableRowCollection(Table owner) {
            this.owner = owner;
        }
        
        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.Count"]/*' />
        /// <devdoc>
        ///    Gets the
        ///    count of <see cref='System.Web.UI.WebControls.TableRow'/> in the collection.
        /// </devdoc>
        public int Count {
            get {
                if (owner.HasControls()) {
                    return owner.Controls.Count;
                }
                return 0;
            }
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a <see cref='System.Web.UI.WebControls.TableRow'/> referenced by the
        ///       specified ordinal index value.
        ///    </para>
        /// </devdoc>
        public TableRow this[int index] {
            get {
                return(TableRow)owner.Controls[index];
            }
        }


        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified <see cref='System.Web.UI.WebControls.TableRow'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public int Add(TableRow row) {
            AddAt(-1, row);
            return owner.Controls.Count - 1;
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.AddAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified <see cref='System.Web.UI.WebControls.TableRow'/> to the collection at the specified
        ///       index location.
        ///    </para>
        /// </devdoc>
        public void AddAt(int index, TableRow row) {
            owner.Controls.AddAt(index, row);
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.AddRange"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void AddRange(TableRow[] rows) {
            if (rows == null) {
                throw new ArgumentNullException("rows");
            }
            foreach(TableRow row in rows) {
                Add(row);
            }
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.Clear"]/*' />
        /// <devdoc>
        /// <para>Removes all <see cref='System.Web.UI.WebControls.TableRow'/> controls from the collection.</para>
        /// </devdoc>
        public void Clear() {
            if (owner.HasControls())
                owner.Controls.Clear();
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.GetRowIndex"]/*' />
        /// <devdoc>
        ///    <para> Returns an ordinal index value that denotes the position of the specified
        ///    <see cref='System.Web.UI.WebControls.TableRow'/> within the collection. </para>
        /// </devdoc>
        public int GetRowIndex(TableRow row) {
            if (owner.HasControls()) {
                return owner.Controls.IndexOf(row);
            }
            return -1;
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an enumerator of all <see cref='System.Web.UI.WebControls.TableRow'/> controls within the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return owner.Controls.GetEnumerator();
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies contents from the collection to the specified <see cref='System.Array' qualify='true'/> with the
        ///    specified starting index.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the object that can be used to synchronize access to the collection. In
        ///       this case, it is the collection itself.
        ///    </para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection is read-only.
        ///    </para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return false;}
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether access to the collection is synchronized
        ///       (thread-safe).
        ///    </para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the specified <see cref='System.Web.UI.WebControls.TableRow'/> from the collection.</para>
        /// </devdoc>
        public void Remove(TableRow row) {
            owner.Controls.Remove(row);
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// <para>Removes the <see cref='System.Web.UI.WebControls.TableRow'/> from the collection at the specified
        ///    index location.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            owner.Controls.RemoveAt(index);
        }

        // IList implementation, required by collection editor
        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return owner.Controls[index];
            }
            set {
                RemoveAt(index);
                AddAt(index, (TableRow)value);
            }
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object o) {
            return Add((TableRow) o);            
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object o) {
            return owner.Controls.Contains((TableRow)o);
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object o) {
            return owner.Controls.IndexOf((TableRow)o);
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object o) {
            owner.Controls.AddAt(index, (TableRow)o);
        }

        /// <include file='doc\TableRowCollection.uex' path='docs/doc[@for="TableRowCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object o) {
            owner.Controls.Remove((TableRow)o);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tablerow.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow"]/*' />
    /// <devdoc>
    ///    <para> Encapsulates a row
    ///       within a table.</para>
    /// </devdoc>
    [
    DefaultProperty("Cells"),
    ParseChildren(true, "Cells"),
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TableRow : WebControl {

        TableCellCollection cells;

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.TableRow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.TableRow'/> class.
        ///    </para>
        /// </devdoc>
        public TableRow() : base(HtmlTextWriterTag.Tr) {
            PreventAutoID();
        }

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.Cells"]/*' />
        /// <devdoc>
        ///    <para> Indicates the table cell collection of the table 
        ///       row. This property is read-only.</para>
        /// </devdoc>
        [
        MergableProperty(false),
        WebSysDescription(SR.TableRow_Cells),
        PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual TableCellCollection Cells {
            get {
                if (cells == null)
                    cells = new TableCellCollection(this);
                return cells;
            }
        }

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para> Indicates the horizontal alignment of the content within the table cells.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.TableRow_HorizonalAlign)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                if (ControlStyleCreated == false) {
                    return HorizontalAlign.NotSet;
                }
                return ((TableItemStyle)ControlStyle).HorizontalAlign;
            }
            set {
                ((TableItemStyle)ControlStyle).HorizontalAlign = value;
            }
        }

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.VerticalAlign"]/*' />
        /// <devdoc>
        ///    <para>Indicates the vertical alignment of the content within the cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(VerticalAlign.NotSet),
        WebSysDescription(SR.TableRow_VerticalAlign)
        ]
        public virtual VerticalAlign VerticalAlign {
            get {
                if (ControlStyleCreated == false) {
                    return VerticalAlign.NotSet;
                }
                return ((TableItemStyle)ControlStyle).VerticalAlign;
            }
            set {
                ((TableItemStyle)ControlStyle).VerticalAlign = value;
            }
        }

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected method. Creates a table item control style.</para>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            return new TableItemStyle(ViewState);
        }

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new CellControlCollection(this);
        }

        /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.CellControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected class CellControlCollection : ControlCollection {

            internal CellControlCollection (Control owner) : base(owner) {
            }

            /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.CellControlCollection.Add"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the end of the array.</para>
            /// </devdoc>
            public override void Add(Control child) {
                if (child is TableCell)
                    base.Add(child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "TableRow", child.GetType().Name.ToString())); // throw an exception here
            }

            /// <include file='doc\TableRow.uex' path='docs/doc[@for="TableRow.CellControlCollection.AddAt"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the array at the specified index location.</para>
            /// </devdoc>
            public override void AddAt(int index, Control child) {
                if (child is TableCell)
                    base.AddAt(index, child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "TableRow", child.GetType().Name.ToString())); // throw an exception here
            }
        } // class CellControlCollection 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tableitemstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableItemStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle"]/*' />
    /// <devdoc>
    ///    <para>Specifies the style of the table item.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TableItemStyle : Style {

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.PROP_HORZALIGN"]/*' />
        /// <devdoc>
        ///    <para>Specifies the horizontal alignment property. This field is
        ///       constant.</para>
        /// </devdoc>
        const int PROP_HORZALIGN = 0x00010000;
        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.PROP_VERTALIGN"]/*' />
        /// <devdoc>
        ///    <para>Specifies the vertical alignment property. This field is
        ///       constant.</para>
        /// </devdoc>
        const int PROP_VERTALIGN = 0x00020000;
        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.PROP_WRAP"]/*' />
        /// <devdoc>
        ///    <para>Specifies the
        ///       wrap property. This field is constant.</para>
        /// </devdoc>
        const int PROP_WRAP = 0x00040000;

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.TableItemStyle"]/*' />
        /// <devdoc>
        /// <para>Creates a new instance of the <see cref='System.Web.UI.WebControls.TableItemStyle'/> class.</para>
        /// </devdoc>
        public TableItemStyle() : base() {
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.TableItemStyle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Web.UI.WebControls.TableItemStyle'/> class with the
        ///       specified state bag.
        ///    </para>
        /// </devdoc>
        public TableItemStyle(StateBag bag) : base(bag) {
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the horizontal alignment of the table item.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.TableItemStyle_HorizontalAlign),
        NotifyParentProperty(true)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                if (IsSet(PROP_HORZALIGN)) {
                    return(HorizontalAlign)(ViewState["HorizontalAlign"]);
                }
                return HorizontalAlign.NotSet;
            }
            set {
                if (value < HorizontalAlign.NotSet || value > HorizontalAlign.Justify) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["HorizontalAlign"] = value;
                SetBit(PROP_HORZALIGN);
            }
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.VerticalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the vertical alignment of the table item.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(VerticalAlign.NotSet),
        WebSysDescription(SR.TableItemStyle_VerticalAlign),
        NotifyParentProperty(true)
        ]
        public virtual VerticalAlign VerticalAlign {
            get {
                if (IsSet(PROP_VERTALIGN)) {
                    return(VerticalAlign)(ViewState["VerticalAlign"]);
                }
                return VerticalAlign.NotSet;
            }
            set {
                if (value < VerticalAlign.NotSet || value > VerticalAlign.Bottom) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["VerticalAlign"] = value;
                SetBit(PROP_VERTALIGN);
            }
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.Wrap"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the cell content wraps within the cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(true),
        WebSysDescription(SR.TableItemStyle_Wrap),
        NotifyParentProperty(true)
        ]
        public virtual bool Wrap {
            get {
                if (IsSet(PROP_WRAP)) {
                    return(bool)(ViewState["Wrap"]);
                }
                return true;
            }
            set {
                ViewState["Wrap"] = value;
                SetBit(PROP_WRAP);
            }
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.AddAttributesToRender"]/*' />
        /// <devdoc>
        ///    <para>Adds information about horizontal alignment, vertical alignment, and wrap to the list of attributes to render.</para>
        /// </devdoc>
        public override void AddAttributesToRender(HtmlTextWriter writer, WebControl owner) {
            base.AddAttributesToRender(writer, owner);

            if (!Wrap)
                writer.AddAttribute(HtmlTextWriterAttribute.Nowrap, "nowrap");

            HorizontalAlign hAlign = HorizontalAlign;
            if (hAlign != HorizontalAlign.NotSet) {
                TypeConverter hac = TypeDescriptor.GetConverter(typeof(HorizontalAlign));
                writer.AddAttribute(HtmlTextWriterAttribute.Align, hac.ConvertToString(hAlign));
            }
            
            VerticalAlign vAlign = VerticalAlign;
            if (vAlign != VerticalAlign.NotSet) {
                TypeConverter hac = TypeDescriptor.GetConverter(typeof(VerticalAlign));
                writer.AddAttribute(HtmlTextWriterAttribute.Valign, hac.ConvertToString(vAlign));
            }
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.CopyFrom"]/*' />
        /// <devdoc>
        ///    <para>Copies non-blank elements from the specified style, overwriting existing
        ///       style elements if necessary.</para>
        /// </devdoc>
        public override void CopyFrom(Style s) {
            if (s != null && !s.IsEmpty) {

                base.CopyFrom(s);

                if (s is TableItemStyle) {
                    TableItemStyle ts = (TableItemStyle)s;

                    if (ts.IsSet(PROP_HORZALIGN))
                        this.HorizontalAlign = ts.HorizontalAlign;
                    if (ts.IsSet(PROP_VERTALIGN))
                        this.VerticalAlign = ts.VerticalAlign;
                    if (ts.IsSet(PROP_WRAP))
                        this.Wrap = ts.Wrap;

                }
            }
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.MergeWith"]/*' />
        /// <devdoc>
        ///    <para>Copies non-blank elements from the specified style, but will not overwrite
        ///       any existing style elements.</para>
        /// </devdoc>
        public override void MergeWith(Style s) {
            if (s != null && !s.IsEmpty) {

                if (IsEmpty) {
                    // merge into an empty style is equivalent to a copy, which
                    // is more efficient
                    CopyFrom(s);
                    return;
                }

                base.MergeWith(s);

                if (s is TableItemStyle) {
                    TableItemStyle ts = (TableItemStyle)s;

                    if (ts.IsSet(PROP_HORZALIGN) && !this.IsSet(PROP_HORZALIGN))
                        this.HorizontalAlign = ts.HorizontalAlign;
                    if (ts.IsSet(PROP_VERTALIGN) && !this.IsSet(PROP_VERTALIGN))
                        this.VerticalAlign = ts.VerticalAlign;
                    if (ts.IsSet(PROP_WRAP) && !this.IsSet(PROP_WRAP))
                        this.Wrap = ts.Wrap;

                }
            }
        }

        /// <include file='doc\TableItemStyle.uex' path='docs/doc[@for="TableItemStyle.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears out any defined style elements from the state bag.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            if (IsSet(PROP_HORZALIGN))
                ViewState.Remove("HorizontalAlign");
            if (IsSet(PROP_VERTALIGN))
                ViewState.Remove("VerticalAlign");
            if (IsSet(PROP_WRAP))
                ViewState.Remove("Wrap");

            base.Reset();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\tablestyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Reflection;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle"]/*' />
    /// <devdoc>
    ///    <para>Specifies the style of the table.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TableStyle : Style {

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.PROP_BACKIMAGEURL"]/*' />
        /// <devdoc>
        ///    <para>Specifies the background image URL property. This field is constant.</para>
        /// </devdoc>
        const int PROP_BACKIMAGEURL = 0x00010000;
        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.PROP_CELLPADDING"]/*' />
        /// <devdoc>
        ///    <para>Specifies the cell-padding property. This field is constant.</para>
        /// </devdoc>
        const int PROP_CELLPADDING = 0x00020000;
        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.PROP_CELLSPACING"]/*' />
        /// <devdoc>
        ///    <para> Specifies the cell-spacing property. This field is constant.</para>
        /// </devdoc>
        const int PROP_CELLSPACING = 0x00040000;
        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.PROP_GRIDLINES"]/*' />
        /// <devdoc>
        ///    Specifies the gridlines property. This field is
        ///    constant.
        /// </devdoc>
        const int PROP_GRIDLINES = 0x00080000;
        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.PROP_HORZALIGN"]/*' />
        /// <devdoc>
        ///    Specifies the horizontal alignment property. This field
        ///    is constant.
        /// </devdoc>
        const int PROP_HORZALIGN = 0x00100000;

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.TableStyle"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.TableStyle'/> class.</para>
        /// </devdoc>
        public TableStyle() : base() {
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.TableStyle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.TableStyle'/> class with the
        ///       specified state bag information.
        ///    </para>
        /// </devdoc>
        public TableStyle(StateBag bag) : base(bag) {
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.BackImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL of the background image for the 
        ///       table. The image will be tiled if it is smaller than the table.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.TableStyle_BackImageUrl)
        ]
        public virtual string BackImageUrl {
            get {
                if (IsSet(PROP_BACKIMAGEURL)) {
                    return(string)(ViewState["BackImageUrl"]);
                }
                return String.Empty;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                ViewState["BackImageUrl"] = value;
                SetBit(PROP_BACKIMAGEURL);
            }
        }
        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.CellPadding"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the distance between the border and the
        ///       contents of the table cell.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(-1),
        WebSysDescription(SR.TableStyle_CellPadding)
        ]
        public virtual int CellPadding {
            get {
                if (IsSet(PROP_CELLPADDING)) {
                    return(int)(ViewState["CellPadding"]);
                }
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["CellPadding"] = value;
                SetBit(PROP_CELLPADDING);
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.CellSpacing"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the distance between table cells.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(-1),
        WebSysDescription(SR.TableStyle_CellSpacing)
        ]
        public virtual int CellSpacing {
            get {
                if (IsSet(PROP_CELLSPACING)) {
                    return(int)(ViewState["CellSpacing"]);
                }
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["CellSpacing"] = value;
                SetBit(PROP_CELLSPACING);
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.GridLines"]/*' />
        /// <devdoc>
        ///    Gets or sets the gridlines property of the table.
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(GridLines.None),
        WebSysDescription(SR.TableStyle_GridLines)
        ]
        public virtual GridLines GridLines {
            get {
                if (IsSet(PROP_GRIDLINES)) {
                    return(GridLines)(ViewState["GridLines"]);
                }
                return GridLines.None;
            }
            set {
                if (value < GridLines.None || value > GridLines.Both) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["GridLines"] = value;
                SetBit(PROP_GRIDLINES);
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the horizontal alignment of the table within the page.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.TableStyle_HorizontalAlign)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                if (IsSet(PROP_HORZALIGN)) {
                    return(HorizontalAlign)(ViewState["HorizontalAlign"]);
                }
                return HorizontalAlign.NotSet;
            }
            set {
                if (value < HorizontalAlign.NotSet || value > HorizontalAlign.Justify) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["HorizontalAlign"] = value;
                SetBit(PROP_HORZALIGN);
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> Adds information about the background
        ///       image, callspacing, cellpadding, gridlines, and alignment to the list of attributes
        ///       to render.</para>
        /// </devdoc>
        public override void AddAttributesToRender(HtmlTextWriter writer, WebControl owner) {
            base.AddAttributesToRender(writer, owner);

            string s = BackImageUrl;
            if (s.Length != 0) {
                if (owner != null) {
                    s = owner.ResolveClientUrl(s);
                }
                writer.AddStyleAttribute(HtmlTextWriterStyle.BackgroundImage, "url(" + s + ")");
            }

            int n = CellSpacing;
            if (n >= 0) {
                writer.AddAttribute(HtmlTextWriterAttribute.Cellspacing, n.ToString(NumberFormatInfo.InvariantInfo));
                if (n == 0)
                    writer.AddStyleAttribute(HtmlTextWriterStyle.BorderCollapse,"collapse");
            }

            n = CellPadding;
            if (n >= 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Cellpadding, n.ToString(NumberFormatInfo.InvariantInfo));

            HorizontalAlign align = HorizontalAlign;
            if (align != HorizontalAlign.NotSet)
                writer.AddAttribute(HtmlTextWriterAttribute.Align, Enum.Format(typeof(HorizontalAlign),align, "G"));

            GridLines gridLines = GridLines;
            if (gridLines != GridLines.None) {
                string rules = String.Empty;
                switch (GridLines) {
                    case GridLines.Both:
                        rules = "all";
                        break;
                    case GridLines.Horizontal:
                        rules = "rows";
                        break;
                    case GridLines.Vertical:
                        rules = "cols";
                        break;
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Rules, rules);
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.CopyFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Copies non-blank elements from the specified style, overwriting existing
        ///       style elements if necessary.</para>
        /// </devdoc>
        public override void CopyFrom(Style s) {
            if (s != null && !s.IsEmpty) {

                base.CopyFrom(s);

                if (s is TableStyle) {
                    TableStyle ts = (TableStyle)s;

                    if (ts.IsSet(PROP_BACKIMAGEURL))
                        this.BackImageUrl = ts.BackImageUrl;
                    if (ts.IsSet(PROP_CELLPADDING))
                        this.CellPadding = ts.CellPadding;
                    if (ts.IsSet(PROP_CELLSPACING))
                        this.CellSpacing = ts.CellSpacing;
                    if (ts.IsSet(PROP_GRIDLINES))
                        this.GridLines = ts.GridLines;
                    if (ts.IsSet(PROP_HORZALIGN))
                        this.HorizontalAlign = ts.HorizontalAlign;

                }
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.MergeWith"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Copies non-blank elements from the specified style, but will not overwrite
        ///       any existing style elements.</para>
        /// </devdoc>
        public override void MergeWith(Style s) {
            if (s != null && !s.IsEmpty) {

                if (IsEmpty) {
                    // merge into an empty style is equivalent to a copy,
                    // which is more efficient
                    CopyFrom(s);
                    return;
                }

                base.MergeWith(s);

                if (s is TableStyle) {
                    TableStyle ts = (TableStyle)s;

                    if (ts.IsSet(PROP_BACKIMAGEURL) && !this.IsSet(PROP_BACKIMAGEURL))
                        this.BackImageUrl = ts.BackImageUrl;
                    if (ts.IsSet(PROP_CELLPADDING) && !this.IsSet(PROP_CELLPADDING))
                        this.CellPadding = ts.CellPadding;
                    if (ts.IsSet(PROP_CELLSPACING) && !this.IsSet(PROP_CELLSPACING))
                        this.CellSpacing = ts.CellSpacing;
                    if (ts.IsSet(PROP_GRIDLINES) && !this.IsSet(PROP_GRIDLINES))
                        this.GridLines = ts.GridLines;
                    if (ts.IsSet(PROP_HORZALIGN) && !this.IsSet(PROP_HORZALIGN))
                        this.HorizontalAlign = ts.HorizontalAlign;

                }
            }
        }

        /// <include file='doc\TableStyle.uex' path='docs/doc[@for="TableStyle.Reset"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Clears out any defined style elements from the state bag.</para>
        /// </devdoc>
        public override void Reset() {
            if (IsSet(PROP_BACKIMAGEURL))
                ViewState.Remove("BackImageUrl");
            if (IsSet(PROP_CELLPADDING))
                ViewState.Remove("CellPadding");
            if (IsSet(PROP_CELLSPACING))
                ViewState.Remove("CellSpacing");
            if (IsSet(PROP_GRIDLINES))
                ViewState.Remove("GridLines");
            if (IsSet(PROP_HORZALIGN))
                ViewState.Remove("HorizontalAlign");

            base.Reset();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\textalign.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextAlign.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    using System;

    /// <include file='doc\TextAlign.uex' path='docs/doc[@for="TextAlign"]/*' />
    /// <devdoc>
    ///    <para>Specifies the text alignment within a control.</para>
    /// </devdoc>
    public enum TextAlign {

        /// <include file='doc\TextAlign.uex' path='docs/doc[@for="TextAlign.Left"]/*' />
        /// <devdoc>
        ///    <para>The text is aligned to the left within the enclosing control.</para>
        /// </devdoc>
        Left = 1,

        /// <include file='doc\TextAlign.uex' path='docs/doc[@for="TextAlign.Right"]/*' />
        /// <devdoc>
        ///    <para>The text is aligned to the right within the
        ///       enclosing control.</para>
        /// </devdoc>
        Right = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\targetconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TargetConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.Diagnostics;  
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Reflection;   
    using System.Security.Permissions;

    /// <include file='doc\TargetConverter.uex' path='docs/doc[@for="TargetConverter"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TargetConverter: StringConverter {

        private static string []  targetValues = {
            "_blank", 
            "_parent", 
            "_search", 
            "_self", 
            "_top"
        };

        private StandardValuesCollection values;

        /// <include file='doc\TargetConverter.uex' path='docs/doc[@for="TargetConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                values = new StandardValuesCollection(targetValues);
            }
            return values;            
        }

        /// <include file='doc\TargetConverter.uex' path='docs/doc[@for="TargetConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\TargetConverter.uex' path='docs/doc[@for="TargetConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }        

    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\templatecolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn"]/*' />
    /// <devdoc>
    ///    <para>Defines the template for controls layout within a 
    ///    <see cref='System.Web.UI.WebControls.DataGrid'/> 
    ///    column.</para>
    /// </devdoc>
    // CONSIDER: Does it make sense to return null from the the Template getters?
    // CONSIDER: Should we allow overriding the creation of templates?
    //
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TemplateColumn : DataGridColumn {

        private ITemplate headerTemplate;
        private ITemplate footerTemplate;
        private ITemplate itemTemplate;
        private ITemplate editItemTemplate;

        
        /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn.TemplateColumn"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Web.UI.WebControls.TemplateColumn'/> class.
        /// </devdoc>
        public TemplateColumn() {
        }

        
        /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn.EditItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how items in edit mode are rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            WebSysDescription(SR.TemplateColumn_EditItemTemplate),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(DataGridItem))
        ]
        public virtual ITemplate EditItemTemplate {
            get {
                return editItemTemplate;
            }
            set {
                editItemTemplate = value;
                OnColumnChanged();
            }
        }
        
        /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn.FooterTemplate"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how the control footer is rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            WebSysDescription(SR.TemplateColumn_FooterTemplate),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(DataGridItem))
        ]
        public virtual ITemplate FooterTemplate {
            get {
                return footerTemplate;
            }
            set {
                footerTemplate = value;
                OnColumnChanged();
            }
        }
        
        /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn.HeaderTemplate"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see cref='System.Web.UI.ITemplate' qualify='true'/>
        /// that defines how the control header is rendered.</para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            WebSysDescription(SR.TemplateColumn_HeaderTemplate),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(DataGridItem))
        ]
        public virtual ITemplate HeaderTemplate {
            get {
                return headerTemplate;
            }
            set {
                headerTemplate = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn.ItemTemplate"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see cref='System.Web.UI.ITemplate' qualify='true'/> that defines how items are rendered. </para>
        /// </devdoc>
        [
            Browsable(false),
            DefaultValue(null),
            WebSysDescription(SR.TemplateColumn_ItemTemplate),
            PersistenceMode(PersistenceMode.InnerProperty),
            TemplateContainer(typeof(DataGridItem))
        ]
        public virtual ITemplate ItemTemplate {
            get {
                return itemTemplate;
            }
            set {
                itemTemplate = value;
                OnColumnChanged();
            }
        }
        
        /// <include file='doc\TemplateColumn.uex' path='docs/doc[@for="TemplateColumn.InitializeCell"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override void InitializeCell(TableCell cell, int columnIndex, ListItemType itemType) {
            base.InitializeCell(cell, columnIndex, itemType);

            ITemplate contentTemplate = null;
            switch (itemType) {
                case ListItemType.Header:
                    contentTemplate = headerTemplate;
                    break;
                    
                case ListItemType.Footer:
                    contentTemplate = footerTemplate;
                    break;
                    
                case ListItemType.Item:
                case ListItemType.AlternatingItem:
                case ListItemType.SelectedItem:
                    contentTemplate = itemTemplate;
                    break;
                    
                case ListItemType.EditItem:
                    if (editItemTemplate != null)
                        contentTemplate = editItemTemplate;
                    else
                        goto case ListItemType.Item;
                    break;
            }
            
            if (contentTemplate != null) {
                // The base class might have added a control or some text for some cases
                // such as header text which need to be removed before
                // the corresponding template is used.
                // Note that setting text also has the effect of clearing out any controls.
                cell.Text = String.Empty;
                
                contentTemplate.InstantiateIn(cell);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\titleformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="TitleFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\TitleFormat.uex' path='docs/doc[@for="TitleFormat"]/*' />
    /// <devdoc>
    ///    <para> Specifies the name format of the visible 
    ///       month for the <see cref='System.Web.UI.WebControls.Calendar'/>
    ///       control.</para>
    /// </devdoc>
    public enum TitleFormat {
        /// <include file='doc\TitleFormat.uex' path='docs/doc[@for="TitleFormat.Month"]/*' />
        /// <devdoc>
        ///    <para>The name format of the visible month contains the
        ///       month but not the year. For example, January.</para>
        /// </devdoc>
        Month = 0,
        /// <include file='doc\TitleFormat.uex' path='docs/doc[@for="TitleFormat.MonthYear"]/*' />
        /// <devdoc>
        ///    <para> The name format of the visible month contains both the
        ///       month and the year. For example, January 2000.</para>
        /// </devdoc>
        MonthYear = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\textbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    using System.Text;
    using System.ComponentModel;
    using System;
    using System.Web;
    using System.Web.UI;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBoxControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.TextBox'/> control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TextBoxControlBuilder : ControlBuilder {

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBoxControlBuilder.AllowWhitespaceLiterals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Specifies whether white space literals are allowed.
        /// </devdoc>
        public override bool AllowWhitespaceLiterals() {
            return false;
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextControlBuilder.HtmlDecodeLiterals"]/*' />
        public override bool HtmlDecodeLiterals() {
            // TextBox text gets rendered as an encoded attribute value or encoded content.

            // At parse time text specified as an attribute gets decoded, and so text specified as a
            // literal needs to go through the same process.

            return true;
        }
    }


    /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox"]/*' />
    /// <devdoc>
    ///    <para>Constructs a text box and defines its properties.</para>
    /// </devdoc>
    [
    ControlBuilderAttribute(typeof(TextBoxControlBuilder)),
    DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultProperty("Text"),
    ValidationProperty("Text"),
    DefaultEvent("TextChanged"),
    ParseChildren(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TextBox : WebControl, IPostBackDataHandler {

        private static readonly object EventTextChanged = new Object();

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TextBox"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.TextBox'/> class.</para>
        /// </devdoc>
        public TextBox() : base(HtmlTextWriterTag.Input) {
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.AutoPostBack"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether an automatic
        ///       postback to the server will occur whenever the user changes the
        ///       content of the text box.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(false),
        WebSysDescription(SR.TextBox_AutoPostBack)
        ]
        public virtual bool AutoPostBack {
            get {
                object b = ViewState["AutoPostBack"];
                return((b == null) ? false : (bool)b);
            }
            set {
                ViewState["AutoPostBack"] = value;
            }
        }


        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.Columns"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the display
        ///       width of the text box in characters.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(0),
        WebSysDescription(SR.TextBox_Columns)
        ]
        public virtual int Columns {
            get {
                object o = ViewState["Columns"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Columns"] = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.MaxLength"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the maximum number of characters allowed in the text box.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(0),
        WebSysDescription(SR.TextBox_MaxLength)
        ]
        public virtual int MaxLength {
            get {
                object o = ViewState["MaxLength"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["MaxLength"] = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TextMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the behavior mode of the text box.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(TextBoxMode.SingleLine),
        WebSysDescription(SR.TextBox_TextMode)
        ]
        public virtual TextBoxMode TextMode {
            get {
                object mode = ViewState["Mode"];
                return((mode == null) ? TextBoxMode.SingleLine : (TextBoxMode)mode);
            }
            set {
                if (value < TextBoxMode.SingleLine || value > TextBoxMode.Password) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Mode"] = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Whether the textbox is in read-only mode.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(false),
        WebSysDescription(SR.TextBox_ReadOnly)
        ]
        public virtual bool ReadOnly {
            get {
                object o = ViewState["ReadOnly"];
                return((o == null) ? false : (bool)o);
            }
            set {
                ViewState["ReadOnly"] = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.Rows"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the display height of a multiline text box.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(0),
        WebSysDescription(SR.TextBox_Rows)
        ]
        public virtual int Rows {
            get {
                object o = ViewState["Rows"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Rows"] = value;
            }
        }

        /// <devdoc>
        ///    Determines whether the Text must be stored in view state, to
        ///    optimize the size of the saved state.
        /// </devdoc>
        private bool SaveTextViewState {
            get {
                // Must be saved when
                // 1. There is a registered event handler for SelectedIndexChanged
                // 2. Control is not enabled or visible, because the browser's post data will not include this control
                // 3. The instance is a derived instance, which might be overriding the OnTextChanged method

                if (TextMode == TextBoxMode.Password) {
                    return false;
                }

                if ((Events[EventTextChanged] != null) ||
                    (Enabled == false) ||
                    (Visible == false) ||
                    (this.GetType() != typeof(TextBox))) {
                    return true;
                }

                return false;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TagKey"]/*' />
        /// <devdoc>
        ///    <para>A protected property. Gets the HTML tag
        ///       for the text box control.</para>
        /// </devdoc>
        protected override HtmlTextWriterTag TagKey {
            get {
                if (TextMode == TextBoxMode.MultiLine)
                    return HtmlTextWriterTag.Textarea;
                else
                    return HtmlTextWriterTag.Input;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.Text"]/*' />
        /// <devdoc>
        ///    <para> Gets
        ///       or sets the text content of the text box.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.TextBox_Text),
        PersistenceMode(PersistenceMode.EncodedInnerDefaultProperty)
        ]
        public virtual string Text {
            get {
                string s = (string)ViewState["Text"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["Text"] = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.Wrap"]/*' />
        /// <devdoc>
        ///    Gets or sets a value indicating whether the
        ///    text content wraps within the text box.
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(true),
        WebSysDescription(SR.TextBox_Wrap)
        ]
        public virtual bool Wrap {
            get {
                object b = ViewState["Wrap"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["Wrap"] = value;
            }
        }


        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TextChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the content of the text box is
        ///       changed upon server postback.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.TextBox_OnTextChanged)
        ]
        public event EventHandler TextChanged {
            add {
                Events.AddHandler(EventTextChanged, value);
            }
            remove {
                Events.RemoveHandler(EventTextChanged, value);
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            writer.AddAttribute(HtmlTextWriterAttribute.Name,UniqueID);
            TextBoxMode mode = TextMode;

            int n;
            if (mode == TextBoxMode.MultiLine) {
                // MultiLine renders as textarea
                n = Rows;
                if (n > 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Rows, n.ToString(NumberFormatInfo.InvariantInfo));
                }
                n = Columns;
                if (n > 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Cols, n.ToString(NumberFormatInfo.InvariantInfo));
                }
                if (!Wrap) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Wrap,"off");
                }
            }
            else {
                // SingleLine renders as input
                if (mode == TextBoxMode.SingleLine) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Type,"text");

                    // only render value if we're not a password
                    string s = Text;
                    if (s.Length > 0)
                        writer.AddAttribute(HtmlTextWriterAttribute.Value,s);
                }
                else if (mode == TextBoxMode.Password) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Type,"password");
                }

                n = MaxLength;
                if (n > 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Maxlength, n.ToString(NumberFormatInfo.InvariantInfo));
                }
                n = Columns;
                if (n > 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Size, n.ToString(NumberFormatInfo.InvariantInfo));
                }
            }

            if (ReadOnly) {
                writer.AddAttribute(HtmlTextWriterAttribute.ReadOnly, "readonly");
            }

            if (AutoPostBack && Page != null) {
                // ASURT 98368
                // Need to merge the autopostback script with the user script
                string onChange = Page.GetPostBackClientEvent(this, "");
                if (HasAttributes) {
                    string userOnChange = Attributes["onchange"];
                    if (userOnChange != null) {
                        onChange = userOnChange + onChange;
                        Attributes.Remove("onchange");
                    }
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onchange, onChange);
                writer.AddAttribute("language", "javascript");
            }

            base.AddAttributesToRender(writer);
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.AddParsedSubObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overridden to only allow literal controls to be added as Text property.
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            if (obj is LiteralControl) {
                Text = ((LiteralControl)obj).Text;
            }
            else {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "TextBox", obj.GetType().Name.ToString()));
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (SaveTextViewState == false) {
                ViewState.SetItemDirty("Text", false);
            }

            if (Page != null && AutoPostBack && Enabled)
                Page.RegisterPostBackScript();
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Loads the posted text box content if it is different
        /// from the last posting.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string current = Text;
            string postData = postCollection[postDataKey];
            if (!current.Equals(postData)) {
                Text = postData;
                return true;
            }
            return false;
        }


        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.OnTextChanged"]/*' />
        /// <devdoc>
        /// <para> Raises the <see langword='TextChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnTextChanged(EventArgs e) {
            EventHandler onChangeHandler = (EventHandler)Events[EventTextChanged];
            if (onChangeHandler != null) onChangeHandler(this,e);
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Invokes the <see cref='System.Web.UI.WebControls.TextBox.OnTextChanged'/> method
        /// whenever posted data for the text box has changed.</para>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnTextChanged(EventArgs.Empty);
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            RenderBeginTag(writer);
            if (TextMode == TextBoxMode.MultiLine)
                HttpUtility.HtmlEncode(Text, writer);
            RenderEndTag(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\unit.cs ===
//------------------------------------------------------------------------------
// <copyright file="Unit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Globalization;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Security.Permissions;

    /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit"]/*' />
    /// <devdoc>
    ///    <para>Defines the fields, properties, and methods of the 
    ///    <see cref='System.Web.UI.WebControls.Unit'/> 
    ///    structure.</para>
    /// </devdoc>
    [
        TypeConverterAttribute(typeof(UnitConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public struct Unit {

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Empty"]/*' />
        /// <devdoc>
        ///    Specifies an empty unit. This field is
        ///    read-only.
        /// </devdoc>
        public static readonly Unit Empty = new Unit();

        private const int MaxValue = 32767;
        private const int MinValue = -32768;

        private UnitType type;
        private double value;

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Unit"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Unit'/> structure with the specified 32-bit signed integer as 
        ///    the unit value and <see langword='Pixel'/> as the (default) unit type.</para>
        /// </devdoc>
        public Unit(int value) {
            if ((value < MinValue) || (value > MaxValue)) {
                throw new ArgumentOutOfRangeException("value");
            }

            this.value = value;
            this.type = UnitType.Pixel;
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Unit1"]/*' />
        /// <devdoc>
        /// <para> Initializes a new instance of the <see cref='System.Web.UI.WebControls.Unit'/> structure with the 
        ///    specified double-precision
        ///    floating point number as the unit value and <see langword='Pixel'/>
        ///    as the (default) unit type.</para>
        /// </devdoc>
        public Unit(double value) {
            if ((value < MinValue) || (value > MaxValue)) {
                throw new ArgumentOutOfRangeException("value");
            }
            this.value = (int)value;
            this.type = UnitType.Pixel;
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Unit2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Unit'/> structure with the specified 
        ///    double-precision floating point number as the unit value and the specified
        /// <see cref='System.Web.UI.WebControls.UnitType'/> as the unit type.</para>
        /// </devdoc>
        public Unit(double value, UnitType type) {
            if ((value < MinValue) || (value > MaxValue)) {
                throw new ArgumentOutOfRangeException("value");
            }
            if (type == UnitType.Pixel) {
                this.value = (int)value;
            }
            else {
                this.value = value;
            }
            this.type = type;
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Unit3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Unit'/> structure with the specified text 
        ///    string that contains the unit value and unit type. If the unit type is not
        ///    specified, the default is <see langword='Pixel'/>
        ///    . </para>
        /// </devdoc>
        public Unit(string value) : this(value, CultureInfo.CurrentCulture, UnitType.Pixel) {
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Unit4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Unit(string value, CultureInfo culture) : this(value, culture, UnitType.Pixel) {
        }

        internal Unit(string value, CultureInfo culture, UnitType defaultType) {
            if ((value == null) || (value.Length == 0)) {
                this.value = 0;
                this.type = (UnitType)0;
            }
            else {
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }
                
                // This is invariant because it acts like an enum with a number together. 
                // The enum part is invariant, but the number uses current culture. 
                string trimLcase = value.Trim().ToLower(CultureInfo.InvariantCulture);
                int len = trimLcase.Length;

                int lastDigit = -1;
                for (int i = 0; i < len; i++) {
                    char ch = trimLcase[i];
                    if (((ch < '0') || (ch > '9')) && (ch != '-') && (ch != '.') && (ch != ','))
                        break;
                    lastDigit = i;
                }
                if (lastDigit == -1) {
                    throw new FormatException(SR.GetString(SR.UnitParseNoDigits, value));
                }
                if (lastDigit < len - 1) {
                    type = (UnitType)GetTypeFromString(trimLcase.Substring(lastDigit+1).Trim());
                }
                else {
                    type = defaultType;
                }

                string numericPart = trimLcase.Substring(0, lastDigit+1);
                // Cannot use Double.FromString, because we don't use it in the ToString implementation
                try {
                    if (type == UnitType.Pixel) {
                        TypeConverter converter = new Int32Converter();
                        this.value = (int)converter.ConvertFromString(null, culture, numericPart);
                    }
                    else {
                        TypeConverter converter = new SingleConverter();
                        this.value = (Single)converter.ConvertFromString(null, culture, numericPart);
                    }
                }
                catch {
                    throw new FormatException(SR.GetString(SR.UnitParseNumericPart, value, numericPart, type.ToString("G")));
                }
                if ((this.value < MinValue) || (this.value > MaxValue)) {
                    throw new ArgumentOutOfRangeException("value");
                }
            }
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.IsEmpty"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.Web.UI.WebControls.Unit'/> is empty.</para>
        /// </devdoc>
        public bool IsEmpty {
            get {
                return type == (UnitType)0;
            }
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Type"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the type of the <see cref='System.Web.UI.WebControls.Unit'/> .</para>
        /// </devdoc>
        public UnitType Type {
            get {
                if (!IsEmpty) {
                    return this.type;
                }
                else {
                    return UnitType.Pixel;
                }
            }
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Value"]/*' />
        /// <devdoc>
        /// <para>Gets the value of the <see cref='System.Web.UI.WebControls.Unit'/> .</para>
        /// </devdoc>
        public double Value {
            get {
                return this.value;
            }
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return type.GetHashCode() << 2 ^ value.GetHashCode();
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Equals"]/*' />
        /// <devdoc>
        /// <para>Compares this <see cref='System.Web.UI.WebControls.Unit'/> with the specified object.</para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == null || !(obj is Unit)) {
                return false;
            }
            Unit u = (Unit)obj;

            // compare internal values to avoid "defaulting" in the case of "Empty"
            //
            if (u.type == type && u.value == value) {
                return true;
            }

            return false;
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.operator=="]/*' />
        /// <devdoc>
        ///    <para>Compares two units to find out if they have the same value and type.</para>
        /// </devdoc>
        public static bool operator ==(Unit left, Unit right) {

            // compare internal values to avoid "defaulting" in the case of "Empty"
            //
            return (left.type == right.type && left.value == right.value);            
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.operator!="]/*' />
        /// <devdoc>
        ///    <para>Compares two units to find out if they have different
        ///       values and/or types.</para>
        /// </devdoc>
        public static bool operator !=(Unit left, Unit right) {

            // compare internal values to avoid "defaulting" in the case of "Empty"
            //
            return (left.type != right.type || left.value != right.value);            
        }


        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.GetStringFromType"]/*' />
        /// <devdoc>
        ///  Converts UnitType to persistence string.
        /// </devdoc>
        private static string GetStringFromType(UnitType type) {
            switch (type) {
                case UnitType.Pixel:
                    return "px";
                case UnitType.Point:
                    return "pt";
                case UnitType.Pica:
                    return "pc";
                case UnitType.Inch:
                    return "in";
                case UnitType.Mm:
                    return "mm";
                case UnitType.Cm:
                    return "cm";
                case UnitType.Percentage:
                    return "%";
                case UnitType.Em:
                    return "em";
                case UnitType.Ex:
                    return "ex";
            }
            return String.Empty;
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.GetTypeFromString"]/*' />
        /// <devdoc>
        ///  Converts persistence string to UnitType.
        /// </devdoc>
        private static UnitType GetTypeFromString(string value) {
            if (value != null && value.Length > 0) {
                if (value.Equals("px")) {
                    return UnitType.Pixel;
                }
                else if (value.Equals("pt")) {
                    return UnitType.Point;
                }
                else if (value.Equals("%")) {
                    return UnitType.Percentage;
                }
                else if (value.Equals("pc")) {
                    return UnitType.Pica;
                }
                else if (value.Equals("in")) {
                    return UnitType.Inch;
                }
                else if (value.Equals("mm")) {
                    return UnitType.Mm;
                }
                else if (value.Equals("cm")) {
                    return UnitType.Cm;
                }
                else if (value.Equals("em")) {
                    return UnitType.Em;
                }
                else if (value.Equals("ex")) {
                    return UnitType.Ex;
                }
                else {
                    throw new ArgumentOutOfRangeException("value");
                }
            }
            return UnitType.Pixel;
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Unit Parse(string s) {
            return new Unit(s);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Parse1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Unit Parse(string s, CultureInfo culture) {
            return new Unit(s, culture);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Percentage"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Web.UI.WebControls.Unit'/> of type <see langword='Percentage'/> from the specified 32-bit signed integer.</para>
        /// </devdoc>
        public static Unit Percentage(double n) {
            return new Unit(n,UnitType.Percentage);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Pixel"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Web.UI.WebControls.Unit'/> of type <see langword='Pixel'/> from the specified 32-bit signed integer.</para>
        /// </devdoc>
        public static Unit Pixel(int n) {
            return new Unit(n);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.Point"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Web.UI.WebControls.Unit'/> of type <see langword='Point'/> from the 
        ///    specified 32-bit signed integer.</para>
        /// </devdoc>
        public static Unit Point(int n) {
            return new Unit(n,UnitType.Point);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Converts a <see cref='System.Web.UI.WebControls.Unit'/> to a <see cref='System.String' qualify='true'/> .</para>
        /// </devdoc>
        public override string ToString() {
            if (IsEmpty)
                return String.Empty;

            // Double.ToString does not do the right thing, we get extra bits at the end
            string valuePart;
            if (type == UnitType.Pixel) {
                valuePart = ((int)value).ToString();
            }
            else {
                valuePart = ((float)value).ToString();
            }
            
            return valuePart + Unit.GetStringFromType(type);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.ToString1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ToString(CultureInfo culture) {
            if (IsEmpty)
                return String.Empty;

            // Double.ToString does not do the right thing, we get extra bits at the end
            string valuePart;
            if (type == UnitType.Pixel) {
                valuePart = ((int)value).ToString(culture);
            }
            else {
                valuePart = ((float)value).ToString(culture);
            }
            
            return valuePart + Unit.GetStringFromType(type);
        }

        /// <include file='doc\Unit.uex' path='docs/doc[@for="Unit.operatorUnit"]/*' />
        /// <devdoc>
        /// <para>Implicitly creates a <see cref='System.Web.UI.WebControls.Unit'/> of type <see langword='Pixel'/> from the specified 32-bit unsigned integer.</para>
        /// </devdoc>
        public static implicit operator Unit(int n) {
            return Unit.Pixel(n);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\textboxmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBoxMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// TextBoxMode.cs
//

namespace System.Web.UI.WebControls {
    
    using System;

    /// <include file='doc\TextBoxMode.uex' path='docs/doc[@for="TextBoxMode"]/*' />
    /// <devdoc>
    ///    <para> Specifies the behavior mode of
    ///       the text box.</para>
    /// </devdoc>
    public enum TextBoxMode {

        /// <include file='doc\TextBoxMode.uex' path='docs/doc[@for="TextBoxMode.SingleLine"]/*' />
        /// <devdoc>
        ///    <para>The text box is in single-line mode. It allows only one 
        ///       line of text within the text box.</para>
        /// </devdoc>
        SingleLine = 0,

        /// <include file='doc\TextBoxMode.uex' path='docs/doc[@for="TextBoxMode.MultiLine"]/*' />
        /// <devdoc>
        ///    <para>The text box is in multi-line mode. It allows multiple lines of text within 
        ///       the text box.</para>
        /// </devdoc>
        MultiLine = 1,

        /// <include file='doc\TextBoxMode.uex' path='docs/doc[@for="TextBoxMode.Password"]/*' />
        /// <devdoc>
        ///    <para>The text box is in password mode. It displays asterisks instead of the actual 
        ///       characters entered inside the text box to provide a measure of security.</para>
        /// </devdoc>
        Password = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\unittype.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnitType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    using System;

    /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType"]/*' />
    /// <devdoc>
    ///    <para> Specifies the unit types.</para>
    /// </devdoc>
    public enum UnitType {

        // NOTE: There is no enumeration value with '0' for a reason.
        //    Unit is a value class, and so when a Unit is created it
        //    is all zero'd out. We don't want that to imply 0px and
        //    we also use a 0 for type to imply its equal to Unit.Empty.
        // NotSet = 0,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Pixel"]/*' />
        /// <devdoc>
        ///    A pixel.
        /// </devdoc>
        Pixel = 1,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Point"]/*' />
        /// <devdoc>
        ///    A point.
        /// </devdoc>
        Point = 2,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Pica"]/*' />
        /// <devdoc>
        ///    A pica.
        /// </devdoc>
        Pica = 3,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Inch"]/*' />
        /// <devdoc>
        ///    An inch.
        /// </devdoc>
        Inch = 4,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Mm"]/*' />
        /// <devdoc>
        ///    A millimeter.
        /// </devdoc>
        Mm = 5,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Cm"]/*' />
        /// <devdoc>
        ///    <para>A centimeter.</para>
        /// </devdoc>
        Cm = 6,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Percentage"]/*' />
        /// <devdoc>
        ///    A percentage.
        /// </devdoc>
        Percentage = 7,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Em"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       A unit of font width relative to its parent element's font.</para>
        ///    <para>For example, if the font size of a phrase is 2em and it is within a paragraph 
        ///       whose font size is 10px, then the font size of the phrase is 20px.</para>
        ///    <para>Refer to the World Wide Web Consortium Website for more information. </para>
        /// </devdoc>
        Em = 8,

        /// <include file='doc\UnitType.uex' path='docs/doc[@for="UnitType.Ex"]/*' />
        /// <devdoc>
        ///    <para>A unit of font height relative to its parent 
        ///       element's font.</para>
        ///    <para>Refer to the World Wide Web Consortium Website for more 
        ///       information. </para>
        /// </devdoc>
        Ex = 9
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\unitconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="unitconverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\unitconverter.uex' path='docs/doc[@for="UnitConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies an interface to be overridden to provide
    ///       unit conversion
    ///       services. The base unit converter class.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class UnitConverter : TypeConverter {

        /// <include file='doc\unitconverter.uex' path='docs/doc[@for="UnitConverter.CanConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Returns a value indicating
        ///       whether the unit converter can convert from the specified source type.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            else {
                return base.CanConvertFrom(context, sourceType);
            }
        }

        /// <include file='doc\unitconverter.uex' path='docs/doc[@for="UnitConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Performs type conversion from the
        ///       specified context, object and argument list.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null)
                return null;

            if (value is string) {
                string textValue = ((string)value).Trim();
                if (textValue.Length == 0)
                    return Unit.Empty;
                if (culture != null)  {
                    return Unit.Parse(textValue, culture);
                }
                else {
                    return Unit.Parse(textValue);
                }
            }
            else {
                return base.ConvertFrom(context, culture, value);
            }
        }

        /// <include file='doc\unitconverter.uex' path='docs/doc[@for="UnitConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Performs type conversion to the specified destination type given the
        ///       specified context, object and argument list.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)) {
                if ((value == null) || ((Unit)value).IsEmpty)
                    return String.Empty;
                else
                    return ((Unit)value).ToString(culture);
            }
            else {
                return base.ConvertTo(context, culture, value, destinationType);
            }
#if FIX_BUG_73027
            // NOTE: This piece of code is required for serialization of a Unit into code.
            //       To enable it you must also override ConvertTo and return true for
            //       converstion to InstanceDescriptor.
            else if ((destinationType == typeof(InstanceDescriptor)) && (value != null)) {
                Unit u = (Unit)value;
                MemberInfo member = null;
                object[] args = null;

                if (u.IsEmpty) {
                    member = typeof(Unit).GetField("Empty");
                }
                else {
                    member = typeof(Unit).GetConstructor(new Type[] { typeof(double), typeof(UnitType) });
                    args = new object[] { u.Value, u.Type };
                }

                Debug.Assert(member != null, "Looks like we're missing Unit.Empty or Unit::ctor(double, UnitType)");
                if (member != null) {
                    return new InstanceDescriptor(member, args);
                }
                else {
                    return null;
                }
            }
#endif // FIX_BUG_73027            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\validatedcontrolconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidatedControlConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\ValidatedControlConverter.uex' path='docs/doc[@for="ValidatedControlConverter"]/*' />
    /// <devdoc>
    ///    <para> Filters and retrieves several types of values from validated controls.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ValidatedControlConverter: StringConverter {

        /// <include file='doc\ValidatedControlConverter.uex' path='docs/doc[@for="ValidatedControlConverter.ValidatedControlConverter"]/*' />
        /// <devdoc>
        /// </devdoc>
        public ValidatedControlConverter() {
        }                

        private object [] GetControls(IContainer container) {

            ComponentCollection allComponents = container.Components;
            ArrayList array = new ArrayList();
            // for each control in the container
            foreach (IComponent comp in (IEnumerable)allComponents) {
                if (comp is Control) {
                    Control control = (Control)comp;

                    // Must have an ID
                    if (control.ID == null || control.ID.Length == 0) {
                        continue;
                    }

                    // Must have a validation property
                    ValidationPropertyAttribute valProp = (ValidationPropertyAttribute)TypeDescriptor.GetAttributes(control)[typeof(ValidationPropertyAttribute)];
                    if (valProp != null && valProp.Name != null) {
                        array.Add(string.Copy(control.ID));                    
                    }
                }
            }
            array.Sort(Comparer.Default);
            return array.ToArray();
        }

        /// <include file='doc\ValidatedControlConverter.uex' path='docs/doc[@for="ValidatedControlConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Returns a collection of standard values retrieved from the context specified
        ///       by the specified type descriptor.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (context == null || context.Container == null) {
                return null;
            }
            object [] objValues = GetControls(context.Container);
            if (objValues != null) {
                return new StandardValuesCollection(objValues);
            }
            else {
                return null;
            }            
        }

        /// <include file='doc\ValidatedControlConverter.uex' path='docs/doc[@for="ValidatedControlConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets whether
        ///       or not the context specified contains exclusive standard values.</para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\ValidatedControlConverter.uex' path='docs/doc[@for="ValidatedControlConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets whether or not the specified context contains supported standard
        ///       values.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }        

    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\validationcompareoperator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationCompareOperator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator"]/*' />
    /// <devdoc>
    ///    <para>Specifies the validation comparison operators to be used by 
    ///       the <see cref='System.Web.UI.WebControls.CompareValidator'/>
    ///       control.</para>
    /// </devdoc>
    public enum ValidationCompareOperator {
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.Equal"]/*' />
        /// <devdoc>
        ///    <para>The Equal comparison operator.</para>
        /// </devdoc>
        Equal = 0,
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.NotEqual"]/*' />
        /// <devdoc>
        ///    <para>The NotEqual comparison operator.</para>
        /// </devdoc>
        NotEqual = 1,
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.GreaterThan"]/*' />
        /// <devdoc>
        ///    <para>The GreaterThan comparison operator.</para>
        /// </devdoc>
        GreaterThan = 2,
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.GreaterThanEqual"]/*' />
        /// <devdoc>
        ///    <para>The GreaterThanEqual comparison operator.</para>
        /// </devdoc>
        GreaterThanEqual = 3,
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.LessThan"]/*' />
        /// <devdoc>
        ///    <para>The LessThan comparison operator.</para>
        /// </devdoc>
        LessThan = 4,
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.LessThanEqual"]/*' />
        /// <devdoc>
        ///    <para>The LessThanEqual comparison operator.</para>
        /// </devdoc>
        LessThanEqual = 5,
        /// <include file='doc\ValidationCompareOperator.uex' path='docs/doc[@for="ValidationCompareOperator.DataTypeCheck"]/*' />
        /// <devdoc>
        ///    <para>The DataTypeCheck comparison operator. Specifies that only data 
        ///       type validity is to be performed.</para>
        /// </devdoc>
        DataTypeCheck = 6,
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\validationdatatype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationDataType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
        
    /// <include file='doc\ValidationDataType.uex' path='docs/doc[@for="ValidationDataType"]/*' />
    /// <devdoc>
    ///    <para>Specifies the validation data types to be used by the 
    ///    <see cref='System.Web.UI.WebControls.CompareValidator'/> and <see cref='System.Web.UI.WebControls.RangeValidator'/> 
    ///    controls.</para>
    /// </devdoc>
    public enum ValidationDataType {
        /// <include file='doc\ValidationDataType.uex' path='docs/doc[@for="ValidationDataType.String"]/*' />
        /// <devdoc>
        ///    <para>The data type is String.</para>
        /// </devdoc>
        String = 0,
        /// <include file='doc\ValidationDataType.uex' path='docs/doc[@for="ValidationDataType.Integer"]/*' />
        /// <devdoc>
        ///    <para>The data type is Integer.</para>
        /// </devdoc>
        Integer = 1,
        /// <include file='doc\ValidationDataType.uex' path='docs/doc[@for="ValidationDataType.Double"]/*' />
        /// <devdoc>
        ///    <para>The data type is Double.</para>
        /// </devdoc>
        Double = 2,
        /// <include file='doc\ValidationDataType.uex' path='docs/doc[@for="ValidationDataType.Date"]/*' />
        /// <devdoc>
        ///    <para>The data type is DataTime.</para>
        /// </devdoc>
        Date = 3,
        /// <include file='doc\ValidationDataType.uex' path='docs/doc[@for="ValidationDataType.Currency"]/*' />
        /// <devdoc>
        ///    <para>The data type is Currency.</para>
        /// </devdoc>
        Currency = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\validatordisplay.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidatorDisplay.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\ValidatorDisplay.uex' path='docs/doc[@for="ValidatorDisplay"]/*' />
    /// <devdoc>
    ///    <para>Specifies the display behavior of a validation control.</para>
    /// </devdoc>
    public enum ValidatorDisplay {
        /// <include file='doc\ValidatorDisplay.uex' path='docs/doc[@for="ValidatorDisplay.None"]/*' />
        /// <devdoc>
        ///    <para> The validation contents are never displayed
        ///       inline.</para>
        ///    <para> This is 
        ///       used so that the error message is only displayed in a <see cref='System.Web.UI.WebControls.ValidationSummary'/>
        ///       control.</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\ValidatorDisplay.uex' path='docs/doc[@for="ValidatorDisplay.Static"]/*' />
        /// <devdoc>
        ///    <para>The validator contents are displayed inline if validation fails. In addition, the 
        ///       validator is part of a page layout even when it is hidden.</para>
        ///    <para>The layout of the page does not change when the validator becomes visible. 
        ///       However, multiple validators for the same input control must occupy different
        ///       physical locations on the page.</para>
        /// </devdoc>
        Static = 1,
        /// <include file='doc\ValidatorDisplay.uex' path='docs/doc[@for="ValidatorDisplay.Dynamic"]/*' />
        /// <devdoc>
        ///    <para>The validator contents are displayed inline if validation fails. In 
        ///       addition, the validator only takes up space on the page when it is
        ///       visible.</para>
        ///    <para>This allows multiple validators to occupy the same physical location on the 
        ///       page when they become visible. In order to avoid the page layout changing when a
        ///       validator becomes visible, the HTML element containing the validator must be
        ///       sized large enough to accommodate the maximum size of the validator.</para>
        /// </devdoc>
        Dynamic = 2
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\validationsummary.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationSummary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web;
    using System.Web.UI.HtmlControls;
    using System.Security.Permissions;

    /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary"]/*' />
    /// <devdoc>
    ///    <para>Displays a summary of all validation errors of 
    ///       a page in a list, bulletted list, or single paragraph format. The errors can be displayed inline
    ///       and/or in a popup message box.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ValidationSummary : WebControl {

        private bool renderUplevel;

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.ValidationSummary"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ValidationSummary'/> class.</para>
        /// </devdoc>
        public ValidationSummary() : base(HtmlTextWriterTag.Div) {
            renderUplevel = false;
            // Red by default
            ForeColor = Color.Red;
        }

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.DisplayMode"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the display mode of the validation summary.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(ValidationSummaryDisplayMode.BulletList),
        WebSysDescription(SR.ValidationSummary_DisplayMode)
        ]
        public ValidationSummaryDisplayMode DisplayMode {
            get { 
                object o = ViewState["DisplayMode"];
                return((o == null) ? ValidationSummaryDisplayMode.BulletList : (ValidationSummaryDisplayMode)o);
            }
            set {
                if (value < ValidationSummaryDisplayMode.List || value > ValidationSummaryDisplayMode.SingleParagraph) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["DisplayMode"] = value;
            }
        }

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.EnableClientScript"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.ValidationSummary_EnableClientScript)
        ]
        public bool EnableClientScript {
            get {
                object o = ViewState["EnableClientScript"];
                return((o == null) ? true : (bool)o);
            }
            set {
                ViewState["EnableClientScript"] = value;
            }
        }


        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the foreground color
        ///       (typically the color of the text) of the control.</para>
        /// </devdoc>
        [
        DefaultValue(typeof(Color), "Red")
        ]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }                

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.HeaderText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the header text to be displayed at the top
        ///       of the summary.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.ValidationSummary_HeaderText)
        ]                                         
        public string HeaderText {
            get { 
                object o = ViewState["HeaderText"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["HeaderText"] = value;
            }
        }

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.ShowMessageBox"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the validation 
        ///       summary is to be displayed in a pop-up message box.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(false),
        WebSysDescription(SR.ValidationSummary_ShowMessageBox)
        ]
        public bool ShowMessageBox {
            get {
                object o = ViewState["ShowMessageBox"];
                return((o == null) ? false : (bool)o);
            }
            set {
                ViewState["ShowMessageBox"] = value;
            }
        }

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.ShowSummary"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the validation
        ///       summary is to be displayed inline.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.ValidationSummary_ShowSummary)
        ]
        public bool ShowSummary {
            get {
                object o = ViewState["ShowSummary"];
                return((o == null) ? true : (bool)o);
            }
            set {
                ViewState["ShowSummary"] = value;
            }
        }

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    AddAttributesToRender method.
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);

            if (renderUplevel) {
                // We always want validation cotnrols to have an id on the client, so if it's null, write it here.
                // Otherwise, base.RenderAttributes takes care of it.
                // REVIEW: this is a bit hacky.
                if (ID == null) {
                    writer.AddAttribute("id", ClientID);
                }

                if (HeaderText.Length > 0 ) {
                    writer.AddAttribute("headertext", HeaderText, true);
                }
                if (ShowMessageBox) {
                    writer.AddAttribute("showmessagebox", "True");
                }
                if (!ShowSummary) {
                    writer.AddAttribute("showsummary", "False");
                }
                if (DisplayMode != ValidationSummaryDisplayMode.BulletList) {
                    writer.AddAttribute("displaymode", PropertyConverter.EnumToString(typeof(ValidationSummaryDisplayMode), DisplayMode));
                }
            }
        }    

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    PreRender method.
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {

            // Act like invisible if disabled
            if (!Enabled) {
                return;
            }

            // work out uplevelness now
            Page page = Page;
            if (page != null && page.Request != null) {
                renderUplevel = (EnableClientScript 
                                 && page.Request.Browser.MSDomVersion.Major >= 4
                                 && page.Request.Browser.EcmaScriptVersion.CompareTo(new Version(1, 2)) >= 0);
            }
            if (renderUplevel) {
                string element = "document.all[\"" + ClientID + "\"]";
                Page.RegisterArrayDeclaration("Page_ValidationSummaries", element);
            }
        }

        /// <include file='doc\ValidationSummary.uex' path='docs/doc[@for="ValidationSummary.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Render method.
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {

            // Act like invisible if disabled
            if (!Enabled) {
                return;
            }

            string [] errorDescriptions;
            bool displayContents;
            bool inError;

            if (Site != null && Site.DesignMode) {
                // Dummy Error state
                inError = true;
                errorDescriptions = new string [] { 
                    HttpRuntime.FormatResourceString(SR.ValSummary_error_message_1),  
                    HttpRuntime.FormatResourceString(SR.ValSummary_error_message_2),  
                };
                displayContents = true;
                renderUplevel = false;                

            }
            else {

                // Fetch errors from the Page
                inError = false;
                errorDescriptions = null;

                // see if we are in error and how many messages there are
                int messages = 0;
                for (int i = 0; i < Page.Validators.Count; i++) {
                    IValidator val = Page.Validators[i];
                    if (!val.IsValid) {
                        inError = true;
                        if (val.ErrorMessage.Length != 0) {
                            messages++;
                        }
                    }
                }

                if (messages != 0) {
                    // get the messages;
                    errorDescriptions = new string [messages];
                    int iMessage = 0;
                    for (int i = 0; i < Page.Validators.Count; i++) {
                        IValidator val = Page.Validators[i];
                        if (!val.IsValid && val.ErrorMessage != null && val.ErrorMessage.Length != 0) {
                            errorDescriptions[iMessage] = string.Copy(val.ErrorMessage);
                            iMessage++;
                        }
                    }
                    Debug.Assert(messages == iMessage, "Not all messages were found!");                    
                }

                displayContents = (ShowSummary && inError);            

                // Make sure tags are hidden if there are no contents
                if (!displayContents && renderUplevel) {
                    Style["display"] = "none";
                }
            }

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            bool displayTags = renderUplevel ? true : displayContents;

            if (displayTags) {
                RenderBeginTag(writer);
            }

            if (displayContents) {

                string headerSep;
                string first;
                string pre;
                string post;
                string final;

                switch (DisplayMode) {
                    case ValidationSummaryDisplayMode.List:
                        headerSep = "<br>";
                        first = "";
                        pre = "";
                        post = "<br>";
                        final = "";
                        break;

                    case ValidationSummaryDisplayMode.BulletList:
                        headerSep = "";
                        first = "<ul>";
                        pre = "<li>";
                        post = "</li>";
                        final = "</ul>";
                        break;

                    case ValidationSummaryDisplayMode.SingleParagraph:                    
                        headerSep = " ";
                        first = "";
                        pre = "";
                        post = " ";
                        final = "<br>";
                        break;

                    default:
                        Debug.Fail("Invalid DisplayMode!");
                        goto
                    case ValidationSummaryDisplayMode.BulletList;                        
                }
                if (HeaderText.Length > 0) {
                    writer.Write(HeaderText);
                    writer.Write(headerSep);
                }
                writer.Write(first);
                if (errorDescriptions != null) {
                    for (int i = 0; i < errorDescriptions.Length; i++) {
                        Debug.Assert(errorDescriptions[i] != null && errorDescriptions[i].Length > 0, "Bad Error Messages");
                        writer.Write(pre);
                        writer.Write(errorDescriptions[i]);
                        writer.Write(post);
                    }
                }
                writer.Write(final);


            }
            if (displayTags) {
                RenderEndTag(writer);
            }
        }                
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\verticalalign.cs ===
//------------------------------------------------------------------------------
// <copyright file="VerticalAlign.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    using System;
    using System.ComponentModel;
    
    /// <include file='doc\VerticalAlign.uex' path='docs/doc[@for="VerticalAlign"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the vertical alignment of an object or text within a control.
    ///    </para>
    /// </devdoc>
    [ TypeConverterAttribute(typeof(VerticalAlignConverter)) ]
    public enum VerticalAlign {

        /// <include file='doc\VerticalAlign.uex' path='docs/doc[@for="VerticalAlign.NotSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Vertical
        ///       alignment property is not set.
        ///    </para>
        /// </devdoc>
        NotSet = 0,
        
        /// <include file='doc\VerticalAlign.uex' path='docs/doc[@for="VerticalAlign.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is aligned with the top of the
        ///       enclosing control.
        ///    </para>
        /// </devdoc>
        Top = 1,

        /// <include file='doc\VerticalAlign.uex' path='docs/doc[@for="VerticalAlign.Middle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is placed
        ///       across the vertical center of the enclosing control.
        ///    </para>
        /// </devdoc>
        Middle = 2,

        /// <include file='doc\VerticalAlign.uex' path='docs/doc[@for="VerticalAlign.Bottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or text is aligned with the bottom of the enclosing
        ///       control.
        ///    </para>
        /// </devdoc>
        Bottom = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\validationsummarydisplaymode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationSummaryDisplayMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\ValidationSummaryDisplayMode.uex' path='docs/doc[@for="ValidationSummaryDisplayMode"]/*' />
    /// <devdoc>
    ///    <para>Specifies the validation summary display mode to be 
    ///       used by the <see cref='System.Web.UI.WebControls.ValidationSummary'/> control.</para>
    /// </devdoc>
    public enum ValidationSummaryDisplayMode {
        /// <include file='doc\ValidationSummaryDisplayMode.uex' path='docs/doc[@for="ValidationSummaryDisplayMode.List"]/*' />
        /// <devdoc>
        ///    Specifies that each error message is
        ///    displayed on its own line.
        /// </devdoc>
        List = 0,
        /// <include file='doc\ValidationSummaryDisplayMode.uex' path='docs/doc[@for="ValidationSummaryDisplayMode.BulletList"]/*' />
        /// <devdoc>
        ///    <para>Specifies that each error message is
        ///       displayed on its own bulleted line.</para>
        /// </devdoc>
        BulletList = 1,
        /// <include file='doc\ValidationSummaryDisplayMode.uex' path='docs/doc[@for="ValidationSummaryDisplayMode.SingleParagraph"]/*' />
        /// <devdoc>
        ///    Specifies that all error messages are
        ///    displayed together in a single paragraph, separated from each other by two
        ///    spaces.
        /// </devdoc>
        SingleParagraph = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\verticalalignconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="VerticalAlignConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    internal class VerticalAlignConverter : EnumConverter {

        static string[] stringValues = new String[(int) VerticalAlign.Bottom + 1];

        static VerticalAlignConverter () { 
            stringValues[(int) VerticalAlign.NotSet] = "NotSet";
            stringValues[(int) VerticalAlign.Top] = "Top";
            stringValues[(int) VerticalAlign.Middle] = "Middle";
            stringValues[(int) VerticalAlign.Bottom] = "Bottom";
        }

        // this constructor needs to be public despite the fact that it's in an internal
        // class so it can be created by Activator.CreateInstance.
        public VerticalAlignConverter () : base(typeof(VerticalAlign)) {}

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            else {
                return base.CanConvertFrom(context, sourceType);
            }
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null)
                return null;

            if (value is string) {
                string textValue = ((string)value).Trim();
                if (textValue.Length == 0)
                    return VerticalAlign.NotSet;

                switch (textValue) {
                    case "NotSet":
                        return VerticalAlign.NotSet;
                    case "Top":
                        return VerticalAlign.Top;
                    case "Middle":
                        return VerticalAlign.Middle;
                    case "Bottom":
                        return VerticalAlign.Bottom;
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }
        
        public override bool CanConvertTo(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }

            return base.CanConvertTo(context, sourceType);
        }
        
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string) && ((int) value <= (int)VerticalAlign.Bottom)) {
                return stringValues[(int) value];
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\webcolorconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebColorConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Text;
    using System.Web.UI;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\WebColorConverter.uex' path='docs/doc[@for="WebColorConverter"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WebColorConverter : ColorConverter {

        private static Hashtable htmlSysColorTable;

        /// <include file='doc\WebColorConverter.uex' path='docs/doc[@for="WebColorConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string colorText = ((string)value).Trim();
                Color c = Color.Empty;

                // empty color
                if ((colorText == null) || (colorText.Length == 0))
                    return c;

                // #RRGGBB notation is handled by ColorConverter
                if (colorText[0] == '#') {
                    return base.ConvertFrom(context, culture, value);
                }

                // special case. HTML requires LightGrey, but System.Drawing.KnownColor has LightGray
                if (String.Compare(colorText, "LightGrey", true, CultureInfo.InvariantCulture) == 0) {
                    return Color.LightGray;
                }

                // System color
                if (htmlSysColorTable == null) {
                    InitializeHTMLSysColorTable();
                }
                object o = htmlSysColorTable[colorText.ToLower(CultureInfo.InvariantCulture)];
                if (o != null) {
                    return (Color)o;
                }
            }

            // ColorConverter handles all named and KnownColors
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\WebColorConverter.uex' path='docs/doc[@for="WebColorConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    Color c = (Color)value;

                    if (c == Color.Empty) {
                        return String.Empty;
                    }

                    /*
                    if (c.IsKnownColor) {
                        // Handle Web system colors and any 'special' named colors

                        string colorString = null;
                        switch (c.ToKnownColor()) {
                            case KnownColor.ActiveBorder: colorString = "ActiveBorder"; break;
                            case KnownColor.ActiveCaption: colorString = "ActiveCaption"; break;
                            case KnownColor.AppWorkspace: colorString = "AppWorkspace"; break;
                            case KnownColor.Desktop: colorString = "Background"; break;
                            case KnownColor.Control: colorString = "ButtonFace"; break;
                            case KnownColor.ControlLight: colorString = "ButtonHighlight"; break;
                            case KnownColor.ControlDark: colorString = "ButtonShadow"; break;
                            case KnownColor.ControlText: colorString = "ButtonText"; break;
                            case KnownColor.ActiveCaptionText: colorString = "CaptionText"; break;
                            case KnownColor.GrayText: colorString = "GrayText"; break;
                            case KnownColor.HotTrack:
                            case KnownColor.Highlight: colorString = "Highlight"; break;
                            case KnownColor.HighlightText: colorString = "HighlightText"; break;
                            case KnownColor.InactiveBorder: colorString = "InactiveBorder"; break;
                            case KnownColor.InactiveCaption: colorString = "InactiveCaption"; break;
                            case KnownColor.InactiveCaptionText: colorString = "InactiveCaptionText"; break;
                            case KnownColor.Info: colorString = "InfoBackground"; break;
                            case KnownColor.InfoText: colorString = "InfoText"; break;
                            case KnownColor.Menu: colorString = "Menu"; break;
                            case KnownColor.MenuText: colorString = "MenuText"; break;
                            case KnownColor.ScrollBar: colorString = "Scrollbar"; break;
                            case KnownColor.ControlDarkDark: colorString = "ThreeDDarkShadow"; break;
                            case KnownColor.ControlLightLight: colorString = "ButtonHighlight"; break;
                            case KnownColor.Window: colorString = "Window"; break;
                            case KnownColor.WindowFrame: colorString = "WindowFrame"; break;
                            case KnownColor.WindowText: colorString = "WindowText"; break;
                            
                            case KnownColor.LightGray: colorString = "LightGrey"; break;
                        }

                        if (colorString != null) {
                            return colorString;
                        }
                    }
                    */

                    if (c.IsKnownColor == false) {
                        // in the Web scenario, colors should be formatted in #RRGGBB notation
                        return "#" + (c.R).ToString("X2") + 
                            (c.G).ToString("X2") + 
                            (c.B).ToString("X2");
                    }
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        private static void InitializeHTMLSysColorTable() {
            Hashtable t = new Hashtable();
            t["activeborder"] = Color.FromKnownColor(KnownColor.ActiveBorder);
            t["activecaption"] = Color.FromKnownColor(KnownColor.ActiveCaption);
            t["appworkspace"] = Color.FromKnownColor(KnownColor.AppWorkspace);
            t["background"] = Color.FromKnownColor(KnownColor.Desktop);
            t["buttonface"] = Color.FromKnownColor(KnownColor.Control);
            t["buttonhighlight"] = Color.FromKnownColor(KnownColor.ControlLightLight);
            t["buttonshadow"] = Color.FromKnownColor(KnownColor.ControlDark);
            t["buttontext"] = Color.FromKnownColor(KnownColor.ControlText);
            t["captiontext"] = Color.FromKnownColor(KnownColor.ActiveCaptionText);
            t["graytext"] = Color.FromKnownColor(KnownColor.GrayText);
            t["highlight"] = Color.FromKnownColor(KnownColor.Highlight);
            t["highlighttext"] = Color.FromKnownColor(KnownColor.HighlightText);
            t["inactiveborder"] = Color.FromKnownColor(KnownColor.InactiveBorder);
            t["inactivecaption"] = Color.FromKnownColor(KnownColor.InactiveCaption);
            t["inactivecaptiontext"] = Color.FromKnownColor(KnownColor.InactiveCaptionText);
            t["infobackground"] = Color.FromKnownColor(KnownColor.Info);
            t["infotext"] = Color.FromKnownColor(KnownColor.InfoText);
            t["menu"] = Color.FromKnownColor(KnownColor.Menu);
            t["menutext"] = Color.FromKnownColor(KnownColor.MenuText);
            t["scrollbar"] = Color.FromKnownColor(KnownColor.ScrollBar);
            t["threeddarkshadow"] = Color.FromKnownColor(KnownColor.ControlDarkDark);
            t["threedface"] = Color.FromKnownColor(KnownColor.Control);
            t["threedhighlight"] = Color.FromKnownColor(KnownColor.ControlLight);
            t["threedlightshadow"] = Color.FromKnownColor(KnownColor.ControlLightLight);
            t["window"] = Color.FromKnownColor(KnownColor.Window);
            t["windowframe"] = Color.FromKnownColor(KnownColor.WindowFrame);
            t["windowtext"] = Color.FromKnownColor(KnownColor.WindowText);
            htmlSysColorTable = t;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\arglesseventhandlerproxy.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArglessEventHandlerProxy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
using System.Reflection;

/*
 * Proxy that provides EventHandler and redirects it to arg-less method on the given object
 */
internal class ArglessEventHandlerProxy {
    private Object _target;
    private MethodInfo _arglessMethod;

    internal ArglessEventHandlerProxy(Object target, MethodInfo arglessMethod) {
        Debug.Assert(arglessMethod.GetParameters().Length == 0);

        _target = target;
        _arglessMethod = arglessMethod;
    }

    internal void Callback(Object sender, EventArgs e) {
        _arglessMethod.Invoke(_target, new Object[0]);
    }

    internal EventHandler Handler {
        get {
            return new EventHandler(Callback);
        }
    }
}

internal delegate void VoidMethod();

internal class ArglessEventHandlerDelegateProxy {
    private VoidMethod _vm;

    internal ArglessEventHandlerDelegateProxy(VoidMethod vm) {
        _vm = vm;
    }

    internal void Callback(Object sender, EventArgs e) {
        _vm();
    }

    internal EventHandler Handler {
        get {
            return new EventHandler(Callback);
        }
    }
}




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\webcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Security;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Globalization;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.Web;
    using System.Web.UI;
    using System.Web.Util;
    using AttributeCollection = System.Web.UI.AttributeCollection;
    using System.Security.Permissions;

    /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl"]/*' />
    /// <devdoc>
    ///    <para> The base class for all Web controls. Defines the
    ///       methods, properties and events common to all controls within the
    ///       System.Web.UI.WebControls namespace.</para>
    /// </devdoc>
    [
    ParseChildren(true),
    PersistChildren(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WebControl : Control, IAttributeAccessor {

        private string tagName;
        private HtmlTextWriterTag tagKey;
        private AttributeCollection attrColl;
        private StateBag attrState;
        private Style controlStyle;
        private SimpleBitVector32 flags;

        // const mask into the BitVector32
        // do not change without verifying other uses
        private const int deferStyleLoadViewState = 0x00000001;
        private const int disabled                = 0x00000002;
        private const int disabledDirty           = 0x00000004;
        private const int accessKeySet            = 0x00000008;
        private const int toolTipSet              = 0x00000010;
        private const int tabIndexSet             = 0x00000020;

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.WebControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.WebControl'/> class and renders
        ///       it as a SPAN tag.
        ///    </para>
        /// </devdoc>
        protected WebControl() : this(HtmlTextWriterTag.Span) {
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.WebControl1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebControl(HtmlTextWriterTag tag) {
            tagKey = tag;
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.WebControl2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.WebControl'/> class and renders
        ///       it as the specified tag.
        ///    </para>
        /// </devdoc>
        protected WebControl(string tag) {
            tagKey = HtmlTextWriterTag.Unknown;
            tagName = tag;
        }


        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.AccessKey"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the keyboard shortcut key (AccessKey) for setting focus to the
        ///       Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.WebControl_AccessKey)
        ]
        public virtual string AccessKey {
            get {
                if (flags[accessKeySet]) {
                    string s = (string)ViewState["AccessKey"];
                    if (s != null) return s;
                }
                return String.Empty;
            }
            set {
                // Valid values are null, String.Empty, and single character strings
                if ((value != null) && (value.Length > 1)) {
                    throw new ArgumentOutOfRangeException("value");
                }

                ViewState["AccessKey"] = value;
                flags[accessKeySet] = true;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Attributes"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of attribute name/value pairs expressed on a Web control but
        ///       not supported by the control's strongly typed properties.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.WebControl_Attributes)
        ]
        public AttributeCollection Attributes {
            get {
                if (attrColl == null) {

                    if (attrState == null) {
                        attrState = new StateBag(true);
                        if (IsTrackingViewState)
                            attrState.TrackViewState();
                    }

                    attrColl = new AttributeCollection(attrState);
                }
                return attrColl;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.BackColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the background color of the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Color), ""),
        WebSysDescription(SR.WebControl_BackColor),
        TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public virtual Color BackColor {
            get {
                if (ControlStyleCreated == false) {
                    return Color.Empty;
                }
                return ControlStyle.BackColor;
            }
            set {
                ControlStyle.BackColor = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the border color of the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Color), ""),
        WebSysDescription(SR.WebControl_BorderColor),
        TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public virtual Color BorderColor {
            get {
                if (ControlStyleCreated == false) {
                    return Color.Empty;
                }
                return ControlStyle.BorderColor;
            }
            set {
                ControlStyle.BorderColor = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.BorderWidth"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the border width of the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Unit), ""),
        WebSysDescription(SR.WebControl_BorderWidth)
        ]
        public virtual Unit BorderWidth {
            get {
                if (ControlStyleCreated == false) {
                    return Unit.Empty;
                }
                return ControlStyle.BorderWidth;
            }
            set {
                if (value.Value < 0)
                    throw new ArgumentOutOfRangeException("value");
                ControlStyle.BorderWidth = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the border style of the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(BorderStyle.NotSet),
        WebSysDescription(SR.WebControl_BorderStyle)
        ]
        public virtual BorderStyle BorderStyle {
            get {
                if (ControlStyleCreated == false) {
                    return BorderStyle.NotSet;
                }
                return ControlStyle.BorderStyle;
            }
            set {
                ControlStyle.BorderStyle = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.ControlStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style of the Web control.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.WebControl_ControlStyle)
        ]
        public Style ControlStyle {
            get {
                if (controlStyle == null) {
                    controlStyle = CreateControlStyle();
                    if (IsTrackingViewState) {
                        controlStyle.TrackViewState();
                    }
                    if (flags[deferStyleLoadViewState]) {
                        flags[deferStyleLoadViewState] = false;
                        controlStyle.LoadViewState(null);
                    }
                }
                return controlStyle;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.ControlStyleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.WebControl_ControlStyleCreated)
        ]
        public bool ControlStyleCreated {
            get {
                return (controlStyle != null);
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.CssClass"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the CSS class rendered by the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.WebControl_CSSClassName)
        ]
        public virtual string CssClass {
            get {
                if (ControlStyleCreated == false) {
                    return String.Empty;
                }
                return ControlStyle.CssClass;
            }
            set {
                ControlStyle.CssClass = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Style"]/*' />
        /// <devdoc>
        ///    <para> Gets a collection of text attributes that will be rendered as a style
        ///       attribute on the outer tag of the Web control.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.WebControl_Style)
        ]
        public CssStyleCollection Style {
            get {
                return Attributes.CssStyle;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Enabled"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the Web control is enabled.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.WebControl_Enabled)
        ]
        public virtual bool Enabled {
            get {
                return !flags[disabled];
            }
            set {
                bool enabled = !flags[disabled];
                if (enabled != value) {
                    flags[disabled] = !value;
                    if (IsTrackingViewState) {
                        flags[disabledDirty] = true;
                    }
                }
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Font"]/*' />
        /// <devdoc>
        ///    <para>Gets font information of the Web control.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(null),
        WebSysDescription(SR.WebControl_Font),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true)
        ]
        public virtual FontInfo Font {
            get {
                return ControlStyle.Font;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the foreground color (typically the color of the text) of the
        ///       Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(typeof(Color), ""),
        WebSysDescription(SR.WebControl_ForeColor),
        TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public virtual Color ForeColor {
            get {
                if (ControlStyleCreated == false) {
                    return Color.Empty;
                }
                return ControlStyle.ForeColor;
            }
            set {
                ControlStyle.ForeColor = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.HasAttributes"]/*' />
        /// <devdoc>
        /// </devdoc>
        // REVIEW: This should become public at some point.  When it becomes public is should have the Browsable(false) and DesignerSerializationVisibility(false) attributes
        internal bool HasAttributes {
            get {
                return (((attrColl != null) && (attrColl.Count > 0)) || ((attrState != null) && (attrState.Count > 0)));
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Height"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the height of the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(typeof(Unit), ""),
        WebSysDescription(SR.WebControl_Height)
        ]
        public virtual Unit Height {
            get {
                if (ControlStyleCreated == false) {
                    return Unit.Empty;
                }
                return ControlStyle.Height;
            }
            set {
                if (value.Value < 0)
                    throw new ArgumentOutOfRangeException("value");
                ControlStyle.Height = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.TabIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the tab index of the Web control.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue((short)0),
        WebSysDescription(SR.WebControl_TabIndex)
        ]
        public virtual short TabIndex {
            get {
                if (flags[tabIndexSet]) {
                    object o = ViewState["TabIndex"];
                    if (o != null) return (short) o;
                }
                return (short)0;
            }
            set {
                ViewState["TabIndex"] = value;
                flags[tabIndexSet] = true;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.TagKey"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected virtual HtmlTextWriterTag TagKey {
            get {
                return tagKey;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.TagName"]/*' />
        /// <devdoc>
        ///    <para> A protected property. Gets the name of the control tag.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected virtual string TagName {
            get {
                if (tagName == null && tagKey != HtmlTextWriterTag.Unknown) {
                    tagName = Enum.Format(typeof(HtmlTextWriterTag), tagKey, "G").ToLower(CultureInfo.InvariantCulture);
                }
                return tagName;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.ToolTip"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the tool tip for the Web control to be displayed when the mouse
        ///       cursor is over the control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.WebControl_Tooltip)
        ]
        public virtual string ToolTip {
            get {
                if (flags[toolTipSet]) {
                    string s = (string)ViewState["ToolTip"];
                    if (s != null) return s;
                }
                return String.Empty;
            }
            set {
                ViewState["ToolTip"] = value;
                flags[toolTipSet] = true;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Width"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the width of the Web control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(typeof(Unit), ""),
        WebSysDescription(SR.WebControl_Width)
        ]
        public virtual Unit Width {
            get {
                if (ControlStyleCreated == false) {
                    return Unit.Empty;
                }
                return ControlStyle.Width;
            }
            set {
                if (value.Value < 0)
                    throw new ArgumentOutOfRangeException("value");
                ControlStyle.Width = value;
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.AddAttributesToRender"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds to the specified writer those HTML attributes and styles that need to be
        ///       rendered.
        ///    </para>
        /// </devdoc>
        protected virtual void AddAttributesToRender(HtmlTextWriter writer) {

            if (this.ID != null) {
                writer.AddAttribute(HtmlTextWriterAttribute.Id, ClientID);
            }
            string s;
            if (flags[accessKeySet]) {
                s = AccessKey;
                if (s.Length > 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Accesskey, s);
                }
            }
            if (!Enabled) {
                writer.AddAttribute(HtmlTextWriterAttribute.Disabled, "disabled");
            }
            if (flags[tabIndexSet]) {
                int n = TabIndex;
                if (n != 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Tabindex, n.ToString(NumberFormatInfo.InvariantInfo));
                }
            }
            if (flags[toolTipSet]) {
                s = ToolTip;
                if (s.Length > 0) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Title, s);
                }
            }

            if (ControlStyleCreated && !ControlStyle.IsEmpty) {
                // let the style add attributes
                ControlStyle.AddAttributesToRender(writer, this);
            }

            // add unknown attributes
            if (attrState != null) {
                AttributeCollection atrColl = Attributes;
                IEnumerator keys = atrColl.Keys.GetEnumerator();
                while (keys.MoveNext()) {
                    string attrName = (string)(keys.Current);
                    writer.AddAttribute(attrName, atrColl[attrName]);
                }
            }

        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.ApplyStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies any non-blank elements of the specified style to the Web control,
        ///       overwriting any existing style elements of the control.
        ///    </para>
        /// </devdoc>
        public void ApplyStyle(Style s) {
            if ((s != null) && (s.IsEmpty == false)) {
                ControlStyle.CopyFrom(s);
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.CopyBaseAttributes"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.Web.UI.WebControls.WebControl.AccessKey'/>, <see cref='System.Web.UI.WebControls.WebControl.Enabled'/>, ToolTip, <see cref='System.Web.UI.WebControls.WebControl.TabIndex'/>, and <see cref='System.Web.UI.WebControls.WebControl.Attributes'/> properties onto the
        ///    Web control from the specified source control.</para>
        /// </devdoc>
        public void CopyBaseAttributes(WebControl controlSrc) {

            if (controlSrc.flags[accessKeySet]) {
                this.AccessKey = controlSrc.AccessKey;
            }
            if (!controlSrc.Enabled) {
                this.Enabled = false;
            }
            if (controlSrc.flags[toolTipSet]) {
                this.ToolTip = controlSrc.ToolTip;
            }
            if (controlSrc.flags[tabIndexSet]) {
                this.TabIndex = controlSrc.TabIndex;
            }

            foreach(string key in controlSrc.Attributes.Keys) {
                this.Attributes[key] = controlSrc.Attributes[key];
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.CreateControlStyle"]/*' />
        /// <devdoc>
        ///    <para> A protected method. Creates the style object that is used internally
        ///       to implement all style-related properties. Controls may override to create an
        ///       appropriately typed style.</para>
        /// </devdoc>
        protected virtual Style CreateControlStyle() {
            return new Style(ViewState);
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Loads previously saved state.
        ///       Overridden to handle ViewState, Style, and Attributes.</para>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                Pair myState = (Pair)savedState;
                base.LoadViewState(myState.First);

                if (ControlStyleCreated || (ViewState[System.Web.UI.WebControls.Style.SetBitsKey] != null)) {
                    // the style shares the StateBag of its owner WebControl
                    // call LoadViewState to let style participate in state management
                    ControlStyle.LoadViewState(null);
                }
                else {
                    flags[deferStyleLoadViewState] = true;
                }

                if (myState.Second != null) {
                    if (attrState == null) {
                        attrState = new StateBag(true);
                        attrState.TrackViewState();
                    }
                    attrState.LoadViewState(myState.Second);
                }
            }

            // Load values cached out of view state
            object enabled = ViewState["Enabled"];
            if (enabled != null) {
                flags[disabled] = !((bool)enabled);
                flags[disabledDirty] = true;
            }

            if (((IDictionary)ViewState).Contains("AccessKey")) {
                flags[accessKeySet] = true;
            }

            if (((IDictionary)ViewState).Contains("TabIndex")) {
                flags[tabIndexSet] = true;
            }

            if (((IDictionary)ViewState).Contains("ToolTip")) {
                flags[toolTipSet] = true;
            }

        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marks the beginning for tracking state changes on the control.
        ///       Any changes made after "mark" will be tracked and
        ///       saved as part of the control viewstate.</para>
        /// </devdoc>
        protected override void TrackViewState() {
            base.TrackViewState();

            if (ControlStyleCreated) {
                // the style shares the StateBag of its owner WebControl
                // call TrackState to let style participate in state management
                ControlStyle.TrackViewState();
            }

            if (attrState != null) {
                attrState.TrackViewState();
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.MergeStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies any non-blank elements of the specified style to the Web control, but
        ///       will not overwrite any existing style elements of the control.
        ///    </para>
        /// </devdoc>
        public void MergeStyle(Style s) {
            if ((s != null) && (s.IsEmpty == false)) {
                ControlStyle.MergeWith(s);
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Renders the control into the specified writer.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            RenderBeginTag(writer);
            RenderContents(writer);
            RenderEndTag(writer);
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.RenderBeginTag"]/*' />
        /// <devdoc>
        ///    <para>Renders the HTML begin tag of the control into the specified writer.</para>
        /// </devdoc>
        public virtual void RenderBeginTag(HtmlTextWriter writer) {

            AddAttributesToRender(writer);

            HtmlTextWriterTag tagKey = TagKey;
            if (tagKey != HtmlTextWriterTag.Unknown) {
                writer.RenderBeginTag(tagKey);
            }
            else {
                writer.RenderBeginTag(this.TagName);
            }
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.RenderEndTag"]/*' />
        /// <devdoc>
        ///    <para>Renders the HTML end tag of the control into the specified writer.</para>
        /// </devdoc>
        public virtual void RenderEndTag(HtmlTextWriter writer) {
            writer.RenderEndTag();
        }


        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.RenderContents"]/*' />
        /// <devdoc>
        ///    <para>Renders the contents of the control into the specified writer.</para>
        /// </devdoc>
        protected virtual void RenderContents(HtmlTextWriter writer) {
            base.Render(writer);
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>A protected method. Saves any
        ///       state that was modified after the TrackViewState method was invoked.</para>
        /// </devdoc>
        protected override object SaveViewState() {
            Pair myState = null;

            // Save values cached out of view state
            if (flags[disabledDirty]) {
                ViewState["Enabled"] = !flags[disabled];
            }

            if (ControlStyleCreated) {
                // the style shares the StateBag of its owner WebControl
                // call SaveViewState to let style participate in state management
                ControlStyle.SaveViewState();
            }

            object baseState = base.SaveViewState();
            object aState = null;
            if (attrState != null) {
                aState = attrState.SaveViewState();
            }

            if (baseState != null || aState != null) {
                myState = new Pair(baseState, aState);
            }
            return myState;
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.IAttributeAccessor.GetAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Returns the attribute value of the Web control having
        /// the specified attribute name.
        /// </devdoc>
        string IAttributeAccessor.GetAttribute(string name) {
            return((attrState != null) ? (string)attrState[name] : null);
        }

        /// <include file='doc\WebControl.uex' path='docs/doc[@for="WebControl.IAttributeAccessor.SetAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Sets an attribute of the Web control with the specified
        /// name and value.</para>
        /// </devdoc>
        void IAttributeAccessor.SetAttribute(string name, string value) {
            Attributes[name] = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\counter.cs ===
//------------------------------------------------------------------------------
// <copyright file="counter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    using System;
    using System.Web;
    using System.Runtime.InteropServices;

    /// <include file='doc\counter.uex' path='docs/doc[@for="Counter"]/*' />
    /// <devdoc>
    ///    <para>Provides access to system timers.</para>
    /// </devdoc>
    internal sealed class Counter {           

        /// <devdoc>
        ///     not creatable
        /// </devdoc>
        private Counter() {
        }

        internal /*public*/ static float Time(long start) {
            long time = Value - start;
            return time / (float)Frequency;
        }

        /// <include file='doc\counter.uex' path='docs/doc[@for="Counter.Value"]/*' />
        /// <devdoc>
        ///    Gets the current system counter value.
        /// </devdoc>
        internal /*public*/ static long Value {
            get {
                long count = 0;
                SafeNativeMethods.QueryPerformanceCounter(ref count);
                return count;
            }
        }

        /// <include file='doc\counter.uex' path='docs/doc[@for="Counter.Frequency"]/*' />
        /// <devdoc>
        ///    Gets the frequency of the system counter in counts per second.
        /// </devdoc>
        internal /*public*/ static long Frequency {
            get {
                long freq = 0;
                SafeNativeMethods.QueryPerformanceFrequency(ref freq);
                return freq;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\datetimeutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileChangesMonitor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {

    using System;

    internal sealed class DateTimeUtil {
        internal DateTimeUtil() {}

        const long FileTimeOffset = 504911232000000000;
        static readonly DateTime    MinValuePlusOneDay = DateTime.MinValue.AddDays(1);
        static readonly DateTime    MaxValueMinusOneDay = DateTime.MaxValue.AddDays(-1);

        static internal DateTime FromFileTimeToUtc(long filetime) {
            long universalTicks = filetime + FileTimeOffset;

            return new DateTime(universalTicks);
        }

        static internal DateTime ConvertToUniversalTime(DateTime localTime) {
            if (localTime < MinValuePlusOneDay) {
                return DateTime.MinValue;
            }

            if (localTime > MaxValueMinusOneDay) {
                return DateTime.MaxValue;
            }

            return localTime.ToUniversalTime();
        }

        static internal DateTime ConvertToLocalTime(DateTime utcTime) {
            if (utcTime < MinValuePlusOneDay) {
                return DateTime.MinValue;
            }

            if (utcTime > MaxValueMinusOneDay) {
                return DateTime.MaxValue;
            }

            return utcTime.ToLocalTime();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\xml.cs ===
//------------------------------------------------------------------------------
// <copyright file="xml.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

using System;
using System.IO;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing.Design;
using System.Web;
using System.Web.Util;
using System.Web.UI;
using System.Web.Caching;
using System.Security.Policy;
using System.Xml;
using System.Xml.Xsl;
using System.Xml.XPath;
using System.Security.Permissions;

internal class XmlBuilder : ControlBuilder {

    internal XmlBuilder() {
    }

    public override Type GetChildControlType(string tagName, IDictionary attribs) {
        return null;
    }

    public override void AppendLiteralString(string s) {}

    public override bool NeedsTagInnerText() { return true; }

    public override void SetTagInnerText(string text) {
        if (!Util.IsWhiteSpaceString(text)) {

            // Trim the initial whitespaces since XML is very picky (ASURT 58100)
            int iFirstNonWhiteSpace = Util.FirstNonWhiteSpaceIndex(text);
            string textNoWS = text.Substring(iFirstNonWhiteSpace);

            // Parse the XML here just to cause a parse error in case it is
            // malformed.  It will be parsed again at runtime.
            XmlDocument document = new XmlDocument();
            XmlTextReader dataReader = new XmlTextReader(new StringReader(textNoWS));
            try {
                document.Load(dataReader);
            }
            catch (XmlException e) {
                // Update the line number to point to the correct line in the xml
                // block (ASURT 58233).  Note that sometimes, the Xml exception returns
                // -1 for the line, in which case we ignore it.
                _line += Util.LineCount(text, 0, iFirstNonWhiteSpace);
                if (e.LineNumber >= 0)
                    _line += e.LineNumber-1;

                throw;
            }

            base.AppendLiteralString(textNoWS);
        }
    }
}

/// <include file='doc\xml.uex' path='docs/doc[@for="Xml"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[
DefaultProperty("DocumentSource"),
PersistChildren(false),
ControlBuilderAttribute(typeof(XmlBuilder)),
Designer("System.Web.UI.Design.WebControls.XmlDesigner, " + AssemblyRef.SystemDesign)
]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class Xml : Control {

    private XmlDocument _document;
    private XPathDocument _xpathDocument;
    private XslTransform _transform;
    private XsltArgumentList _transformArgumentList;
    private string _documentContent;
    private string _documentSource;
    private string _transformSource;


    const string identityXslStr = 
        "<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>" +
        "<xsl:template match=\"/\"> <xsl:copy-of select=\".\"/> </xsl:template> </xsl:stylesheet>";

    static XslTransform _identityTransform;

    static Xml() {

        // Instantiate an identity transform, to be used whenever we need to output XML
        XmlTextReader reader = new XmlTextReader(new StringReader(identityXslStr));
        _identityTransform = new XslTransform();

        _identityTransform.Load(reader, null /*resolver*/, null /*evidence*/);
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.DocumentContent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
    WebSysDescription(SR.Xml_DocumentContent)
    ]
    public String DocumentContent {
        // This really should be a writeonly prop, but the designer doesn't support it
        get { return string.Empty; }
        set {
            _document = null;
            _xpathDocument = null;
            _documentContent = value;
        }
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.AddParsedSubObject"]/*' />
    protected override void AddParsedSubObject(object obj) {
        if (obj is LiteralControl) {
            DocumentContent = ((LiteralControl)obj).Text;
        }
        else {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "Xml", obj.GetType().Name.ToString()));
        }
    }

    private void LoadXPathDocument() {

        Debug.Assert(_xpathDocument == null && _document == null);

        if (_documentContent != null && _documentContent.Length > 0) {
            StringReader reader = new StringReader(_documentContent);
            _xpathDocument = new XPathDocument(reader);
            return;
        }

        if (_documentSource == null || _documentSource.Length == 0)
            return;

        // Make it absolute and check security
        string physicalPath = MapPathSecure(_documentSource);

        CacheInternal   cacheInternal = HttpRuntime.CacheInternal;
        string key = "System.Web.UI.WebControls.LoadXPathDocument:" + physicalPath;
        _xpathDocument = (XPathDocument) cacheInternal.Get(key);
        if (_xpathDocument == null) {
            Debug.Trace("XmlControl", "XPathDocument not found in cache (" + _documentSource + ")");

            using (CacheDependency dependency = new CacheDependency(false, physicalPath)) {
                _xpathDocument = new XPathDocument(physicalPath);
                cacheInternal.UtcInsert(key, _xpathDocument, dependency);
            }
        }
        else {
            Debug.Trace("XmlControl", "XPathDocument found in cache (" + _documentSource + ")");
        }
    }

    private void LoadXmlDocument() {

        Debug.Assert(_xpathDocument == null && _document == null);

        if (_documentContent != null && _documentContent.Length > 0) {
            _document = new XmlDocument();
            _document.LoadXml(_documentContent);
            return;
        }

        if (_documentSource == null || _documentSource.Length == 0)
            return;

        // Make it absolute and check security
        string physicalPath = MapPathSecure(_documentSource);

        CacheInternal cacheInternal = System.Web.HttpRuntime.CacheInternal;
        string key = "System.Web.UI.WebControls.LoadXmlDocument:" + physicalPath;

        _document = (XmlDocument) cacheInternal.Get(key);

        if (_document == null) {
            Debug.Trace("XmlControl", "XmlDocument not found in cache (" + _documentSource + ")");

            using (CacheDependency dependency = new CacheDependency(false, physicalPath)) {
                _document = new XmlDocument();
                _document.Load(physicalPath);
                cacheInternal.UtcInsert(key, _document, dependency);
            }
        }
        else {
            Debug.Trace("XmlControl", "XmlDocument found in cache (" + _documentSource + ")");
        }

        // REVIEW: is this lock needed?  Maybe CloneNode is thread safe?
        lock (_document) {
            // Always return a clone of the cached copy
            _document = (XmlDocument)_document.CloneNode(true/*deep*/);
        }
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.DocumentSource"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Bindable(true),
    WebCategory("Behavior"),
    DefaultValue(""),
    Editor("System.Web.UI.Design.XmlUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
    WebSysDescription(SR.Xml_DocumentSource)
    ]
    public String DocumentSource {
        get {
            return (_documentSource == null) ? string.Empty : _documentSource;
        }
        set {
            _document = null;
            _xpathDocument = null;
            _documentContent = null;
            _documentSource = value;
        }
    }

    private void LoadTransformFromSource() {

        // We're done if we already have a transform
        if (_transform != null)
            return;

        if (_transformSource == null || _transformSource.Length == 0)
            return;

        // Make it absolute and check security
        string physicalPath = MapPathSecure(_transformSource);

        CacheInternal cacheInternal = System.Web.HttpRuntime.CacheInternal;
        string key = "System.Web.UI.WebControls:" + physicalPath;

        _transform = (XslTransform) cacheInternal.Get(key);

        if (_transform == null) {
            Debug.Trace("XmlControl", "XslTransform not found in cache (" + _transformSource + ")");

            using (CacheDependency dependency = new CacheDependency(false, physicalPath)) {
                _transform = new XslTransform();
                _transform.Load(physicalPath);

                cacheInternal.UtcInsert(key, _transform, dependency);
            }
        }
        else {
            Debug.Trace("XmlControl", "XslTransform found in cache (" + _transformSource + ")");
        }
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.TransformSource"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Bindable(true),
    WebCategory("Behavior"),
    DefaultValue(""),
    Editor("System.Web.UI.Design.XslUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
    WebSysDescription(SR.Xml_TransformSource),
    ]
    public String TransformSource {
        get {
            return (_transformSource == null) ? string.Empty : _transformSource;
        }
        set {
            _transform = null;
            _transformSource = value;
        }
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.Document"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Browsable(false),
    WebSysDescription(SR.Xml_Document),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public XmlDocument Document {
        get {
            if (_document == null)
                LoadXmlDocument();
            return _document;
        }
        set {
            DocumentSource = null;
            _xpathDocument = null;
            _documentContent = null;
            _document = value;
        }
    }    

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.Transform"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Browsable(false),
    WebSysDescription(SR.Xml_Transform),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public XslTransform Transform {
        get { return _transform; }
        set {
            TransformSource = null;
            _transform = value;
        }
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.TransformArgumentList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Browsable(false),
    WebSysDescription(SR.Xml_TransformArgumentList),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public XsltArgumentList TransformArgumentList {
        get { return _transformArgumentList; }
        set {
            _transformArgumentList = value;
        }
    }

    /// <include file='doc\xml.uex' path='docs/doc[@for="Xml.Render"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override void Render(HtmlTextWriter output) {

        // If we don't already have an XmlDocument, load am XPathDocument (which is faster)
        if (_document == null)
            LoadXPathDocument();

        LoadTransformFromSource();

        if (_document == null && _xpathDocument == null)
            return;

        // If we don't have a transform, use the identity transform, which
        // simply renders the XML.
        if (_transform == null)
            _transform = _identityTransform;

        // Pass a resolver in full trust, to support certain XSL scenarios (ASURT 141427)
        XmlUrlResolver xr = null;
        if (HttpRuntime.HasUnmanagedPermission()) {
            xr = new XmlUrlResolver();
        }

        if (_document != null) {
            Transform.Transform(_document, _transformArgumentList, output, xr);
        }
        else {
            Transform.Transform(_xpathDocument, _transformArgumentList, output, xr);
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\aspcompat.cs ===
//------------------------------------------------------------------------------
// <copyright file="AspCompat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Support for ASP compatible execution mode of ASP.NET pages
 * 
 *  ASP compatible executions involves:
 *      1) Running on COM+1.0 STA thread pool
 *      2) Attachment of unmanaged intrinsics to unmanaged COM+1.0 context
 *      3) Support for OnStartPage/OnEndPage
 * 
 * Copyright (c) 2000, Microsoft Corporation
 */
namespace System.Web.Util {
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Text;
    using System.Web;
    using System.Security.Permissions;
    using System.Runtime.Remoting.Messaging;
    using Microsoft.Win32;
    using System.Globalization;
    using System.Web.Caching;

//
// Interface for unmanaged call to call back into managed code for
// intrinsics implementation
//

internal enum RequestString {
    QueryString = 1,
    Form = 2,
    Cookies = 3,
    ServerVars = 4
}

[ComImport, Guid("a1cca730-0e36-4870-aa7d-ca39c211f99d"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
internal interface IManagedContext {

                                            void    Application_Lock();
                                            void    Application_UnLock();
    [return: MarshalAs(UnmanagedType.BStr)] String  Application_GetContentsNames();
    [return: MarshalAs(UnmanagedType.BStr)] String  Application_GetStaticNames();
                                            Object  Application_GetContentsObject([In, MarshalAs(UnmanagedType.LPWStr)] String name);
                                            void    Application_SetContentsObject([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In] Object obj);
                                            void    Application_RemoveContentsObject([In, MarshalAs(UnmanagedType.LPWStr)] String name);
                                            void    Application_RemoveAllContentsObjects();
                                            Object  Application_GetStaticObject([In, MarshalAs(UnmanagedType.LPWStr)] String name);

    [return: MarshalAs(UnmanagedType.BStr)] String  Request_GetAsString([In, MarshalAs(UnmanagedType.I4)] int what);
    [return: MarshalAs(UnmanagedType.BStr)] String  Request_GetCookiesAsString();
    [return: MarshalAs(UnmanagedType.I4)]   int     Request_GetTotalBytes();
    [return: MarshalAs(UnmanagedType.I4)]   int     Request_BinaryRead([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1), Out] byte[] bytes, int size);

    [return: MarshalAs(UnmanagedType.BStr)] String  Response_GetCookiesAsString();
                                            void    Response_AddCookie([In, MarshalAs(UnmanagedType.LPWStr)] String name);
                                            void    Response_SetCookieText([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.LPWStr)] String text);
                                            void    Response_SetCookieSubValue([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.LPWStr)] String key, [In, MarshalAs(UnmanagedType.LPWStr)] String value);
                                            void    Response_SetCookieExpires([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.R8)] double dtExpires);
                                            void    Response_SetCookieDomain([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.LPWStr)] String domain);
                                            void    Response_SetCookiePath([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.LPWStr)] String path);
                                            void    Response_SetCookieSecure([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.I4)] int secure);
                                            void    Response_Write([In, MarshalAs(UnmanagedType.LPWStr)] String text);
                                            void    Response_BinaryWrite([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1), In] byte[] bytes, int size);
                                            void    Response_Redirect([In, MarshalAs(UnmanagedType.LPWStr)] String url);
                                            void    Response_AddHeader([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In, MarshalAs(UnmanagedType.LPWStr)] String value);
                                            void    Response_Pics([In, MarshalAs(UnmanagedType.LPWStr)] String value);
                                            void    Response_Clear();
                                            void    Response_Flush();
                                            void    Response_End();
                                            void    Response_AppendToLog([In, MarshalAs(UnmanagedType.LPWStr)] String entry);
    [return: MarshalAs(UnmanagedType.BStr)] String  Response_GetContentType();
                                            void    Response_SetContentType([In, MarshalAs(UnmanagedType.LPWStr)] String contentType);
    [return: MarshalAs(UnmanagedType.BStr)] String  Response_GetCharSet();
                                            void    Response_SetCharSet([In, MarshalAs(UnmanagedType.LPWStr)] String charSet);
    [return: MarshalAs(UnmanagedType.BStr)] String  Response_GetCacheControl();
                                            void    Response_SetCacheControl([In, MarshalAs(UnmanagedType.LPWStr)] String cacheControl);
    [return: MarshalAs(UnmanagedType.BStr)]         String  Response_GetStatus();
                                            void    Response_SetStatus([In, MarshalAs(UnmanagedType.LPWStr)] String status);
    [return: MarshalAs(UnmanagedType.I4)]   int     Response_GetExpiresMinutes();
                                            void    Response_SetExpiresMinutes([In, MarshalAs(UnmanagedType.I4)] int expiresMinutes);
    [return: MarshalAs(UnmanagedType.R8)]   double  Response_GetExpiresAbsolute();
                                            void    Response_SetExpiresAbsolute([In, MarshalAs(UnmanagedType.R8)] double dtExpires);
    [return: MarshalAs(UnmanagedType.I4)]   int     Response_GetIsBuffering();
                                            void    Response_SetIsBuffering([In, MarshalAs(UnmanagedType.I4)] int isBuffering);
    [return: MarshalAs(UnmanagedType.I4)]   int     Response_IsClientConnected();

    [return: MarshalAs(UnmanagedType.Interface)] Object Server_CreateObject([In, MarshalAs(UnmanagedType.LPWStr)] String progId);
    [return: MarshalAs(UnmanagedType.BStr)] String  Server_MapPath([In, MarshalAs(UnmanagedType.LPWStr)] String logicalPath);
    [return: MarshalAs(UnmanagedType.BStr)] String  Server_HTMLEncode([In, MarshalAs(UnmanagedType.LPWStr)] String str);
    [return: MarshalAs(UnmanagedType.BStr)] String  Server_URLEncode([In, MarshalAs(UnmanagedType.LPWStr)] String str);
    [return: MarshalAs(UnmanagedType.BStr)] String  Server_URLPathEncode([In, MarshalAs(UnmanagedType.LPWStr)] String str);
    [return: MarshalAs(UnmanagedType.I4)]   int     Server_GetScriptTimeout();
                                            void    Server_SetScriptTimeout([In, MarshalAs(UnmanagedType.I4)] int timeoutSeconds);
                                            void    Server_Execute([In, MarshalAs(UnmanagedType.LPWStr)] String url);
                                            void    Server_Transfer([In, MarshalAs(UnmanagedType.LPWStr)] String url);

    [return: MarshalAs(UnmanagedType.I4)]   int     Session_IsPresent();
    [return: MarshalAs(UnmanagedType.BStr)] String  Session_GetID();
    [return: MarshalAs(UnmanagedType.I4)]   int     Session_GetTimeout();
                                            void    Session_SetTimeout([In, MarshalAs(UnmanagedType.I4)] int value);
    [return: MarshalAs(UnmanagedType.I4)]   int     Session_GetCodePage();
                                            void    Session_SetCodePage([In, MarshalAs(UnmanagedType.I4)] int value);
    [return: MarshalAs(UnmanagedType.I4)]   int     Session_GetLCID();
                                            void    Session_SetLCID([In, MarshalAs(UnmanagedType.I4)] int value);
                                            void    Session_Abandon();
    [return: MarshalAs(UnmanagedType.BStr)] String  Session_GetContentsNames();
    [return: MarshalAs(UnmanagedType.BStr)] String  Session_GetStaticNames();
                                            Object  Session_GetContentsObject([In, MarshalAs(UnmanagedType.LPWStr)] String name);
                                            void    Session_SetContentsObject([In, MarshalAs(UnmanagedType.LPWStr)] String name, [In]Object obj);
                                            void    Session_RemoveContentsObject([In, MarshalAs(UnmanagedType.LPWStr)] String name);
                                            void    Session_RemoveAllContentsObjects();
                                            Object  Session_GetStaticObject([In, MarshalAs(UnmanagedType.LPWStr)] String name);
}
/// <include file='doc\AspCompat.uex' path='docs/doc[@for="AspCompatCallback"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>

//
//  Delegate to the code executing on within ASP compat context
//  (provided by the caller and used internally to wrap it)
//

internal delegate void AspCompatCallback();

//
//  Utility class for AspCompat work
//

internal class AspCompatApplicationStep : HttpApplication.IExecutionStep, IManagedContext {

    private GCHandle          _rootedThis;      // for the duration of async
    private HttpContext       _context;         // context for callback
    private HttpApplication   _app;             // app instance to run the code under
    private AspCompatCallback _code;            // the code to run in asp compat mode
    private Exception         _error;           // error during the execution
    private HttpAsyncResult   _ar;              // async result returned to the caller
    private bool              _syncCaller;      // called synchronously?
    private AspCompatCallback _execCallback;    // keep delegate as a member (not gc it)
    private WorkItemCallback  _compCallback;    // keep delegate as a member (not gc it)
    private ArrayList         _staComponents;   // list of STA components to be released

    internal AspCompatApplicationStep(HttpContext context, AspCompatCallback code) {
        _context = context;
        _app = context.ApplicationInstance;
        _code = code;
        _execCallback = new AspCompatCallback(this.OnAspCompatExecution);
        _compCallback = new WorkItemCallback(this.OnAspCompatCompletion);
    }

    private void MarkCallContext(AspCompatApplicationStep mark) {
         CallContext.SetData("AspCompat", mark);
    }

    private static AspCompatApplicationStep Current {
        get { return (AspCompatApplicationStep)CallContext.GetData("AspCompat"); }
    }

    internal static bool IsInAspCompatMode {
        get { return (Current != null); }
    }

    // IExecutionStep implementation

    void HttpApplication.IExecutionStep.Execute() {
        _code();
    }

    bool HttpApplication.IExecutionStep.CompletedSynchronously {
        get { return true; }
    }

    bool HttpApplication.IExecutionStep.IsCancellable {
        get { return true; }
    }

    // OnPageStart / OnPageEnd support

    private void RememberStaComponent(Object component) {
        if (_staComponents == null)
            _staComponents = new ArrayList();
        _staComponents.Add(component);
    }

    internal static void OnPageStart(Object component) {
        // has to be in asp compat mode
        if (!IsInAspCompatMode)
            return;

        int rc = UnsafeNativeMethods.AspCompatOnPageStart(component);
        if (rc != 1)
            new HttpException(HttpRuntime.FormatResourceString(SR.Error_onpagestart));

        if (UnsafeNativeMethods.AspCompatIsApartmentComponent(component) != 0)
            Current.RememberStaComponent(component);
    }

    // Disallow Apartment components in when ASPCOMPAT is off

    internal static void CheckThreadingModel(String progidDisplayName, Guid clsid) {
        if (IsInAspCompatMode)
            return;

        // try cache first
        CacheInternal cacheInternal = HttpRuntime.CacheInternal;
        String key = "AspCompat.ThreadingModel:" + progidDisplayName;
        String threadingModel = (String)cacheInternal.Get(key);

        if (threadingModel == null) {
            try {
                RegistryKey regKey = Registry.ClassesRoot.OpenSubKey("CLSID\\{" + clsid + "}\\InprocServer32" );
                if (regKey != null) {
                    threadingModel = (String)regKey.GetValue("ThreadingModel");
                    regKey.Close();
                }
            }
            catch {
            }

            if (threadingModel == null)
                threadingModel = String.Empty;

            cacheInternal.UtcInsert(key, threadingModel);
        }

        if (String.Compare(threadingModel, "Apartment", true, CultureInfo.InvariantCulture) == 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Apartment_component_not_allowed, progidDisplayName));
        }
    }

    // Async patern

    internal /*public*/ IAsyncResult BeginAspCompatExecution(AsyncCallback cb, object extraData) {
        InternalSecurityPermissions.UnmanagedCode.Demand();

        if (IsInAspCompatMode) {
            // already in AspCompatMode -- execute synchronously
            bool sync = true;
            Exception error = _app.ExecuteStep(this, ref sync);
            _ar = new HttpAsyncResult(cb, extraData, true, null, error);
            _syncCaller = true;
        }
        else {
            _ar = new HttpAsyncResult(cb, extraData);
            _syncCaller = (cb == null);
            _rootedThis = GCHandle.Alloc(this);

            if (UnsafeNativeMethods.AspCompatProcessRequest(_execCallback, this) != 1) {
                // failed to queue up the execution in ASP compat mode
                _rootedThis.Free();
                _ar.Complete(true, null, new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_access_AspCompat)));
            }
        }

        return _ar;
    }

    internal /*public*/ void EndAspCompatExecution(IAsyncResult ar) {
        Debug.Assert(_ar == ar);
        _ar.End();
    }

    private void ExecuteAspCompatCode() {
        MarkCallContext(this);
        _app.OnThreadEnter();

        try {
            bool sync = true;
            _error = _app.ExecuteStep(this, ref sync);
        }
        finally {
            _app.OnThreadLeave();
            MarkCallContext(null);
        }
    }

    private void OnAspCompatExecution() {
        try {
            if (_syncCaller) {
                // for synchronous caller don't take the app lock (could dead lock because we switched threads)
                ExecuteAspCompatCode();
            }
            else {
                lock (_app) {
                    ExecuteAspCompatCode();
                }
            }
        }
        finally {
            // release all STA components
            if (_staComponents != null) {
                foreach (Object component in _staComponents)
                    Marshal.ReleaseComObject(component);
            }

            // reschedule execution back to the regular thread pool
            WorkItem.PostInternal(_compCallback);
        }
    }

    private void OnAspCompatCompletion() {
        _rootedThis.Free();
        _ar.Complete(false, null, _error); // resume the application execution
    }

    //
    // Implemenation of IManagedContext
    //

    private static String CollectionToString(NameValueCollection c) {
        // 'easy' marshalling format key, # of strings, strings, ... (all '\t' separated)
        int n = c.Count;
        if (n == 0)
           return String.Empty;

        StringBuilder sb = new StringBuilder(256);

        for (int i = 0; i < n; i++) {
            String key = c.GetKey(i);
            String[] vv = c.GetValues(i);
            int len = (vv != null) ? vv.Length : 0;
            sb.Append(key + "\t" + len + "\t");
            for (int j = 0; j < len; j++) {
                sb.Append(vv[j]);
                if (j < vv.Length-1)
                    sb.Append("\t");
            }
            if (i < n-1)
                sb.Append("\t");
        }

        return sb.ToString();
    }

    private static String CookiesToString(HttpCookieCollection cc) {
        // marshalling of cookies as string (all '\t' separated):
        // all cookies as one ';' separated string
        // # of cookies
        // [for each cookie] name, text, # of keys, key, value, ...
        StringBuilder sb = new StringBuilder(256);  // resulting string (per above)
        StringBuilder st = new StringBuilder(128);  // all cookies string

        int numCookies = cc.Count;
        sb.Append(numCookies.ToString() + "\t");

        for (int i = 0; i < numCookies; i++) {
            HttpCookie c = cc[i];
            sb.Append(c.Name + "\t" + c.Value + "\t");

            if (i > 0)
                st.Append(";" + c.Name + "=" + c.Value);
            else
                st.Append(c.Name + "=" + c.Value);

            NameValueCollection cv = c.Values;
            int ncv = cv.Count;
            bool hasNotEmptyKeys = false;

            if (cv.HasKeys()) {
                for (int j = 0; j < ncv; j++) {
                    String key = cv.GetKey(j);
                    if (key != null && key.Length > 0) {
                        hasNotEmptyKeys = true;
                        break;
                    }
                }
            }

            if (hasNotEmptyKeys) {
                sb.Append(ncv + "\t");
                for (int j = 0; j < ncv; j++)
                    sb.Append(cv.GetKey(j) + "\t" + cv.Get(j) + "\t");
            }
            else {
                sb.Append("0\t");
            }
        }

        // append the contructed text to the all cookies string
        st.Append("\t");
        st.Append(sb.ToString()); 
        return st.ToString();
    }

    private static String StringArrayToString(String[] ss) {
        // construct tab separeted string for marshalling
        StringBuilder sb = new StringBuilder(256);

        if (ss != null) {
            for (int i = 0; i < ss.Length; i++) {
                if (i > 0)
                    sb.Append("\t");
                sb.Append(ss[i]);
            }
        }

        return sb.ToString();
    }

    private static String EnumKeysToString(IEnumerator e) {
        StringBuilder sb = new StringBuilder(256);

        if (e.MoveNext()) {
            sb.Append(e.Current);
            while (e.MoveNext()) {
                sb.Append("\t");
                sb.Append(e.Current);
            }
        }

        return sb.ToString();
    }

    private static String DictEnumKeysToString(IDictionaryEnumerator e) {
        StringBuilder sb = new StringBuilder(256);

        if (e.MoveNext()) {
            sb.Append(e.Key);
            while (e.MoveNext()) {
                sb.Append("\t");
                sb.Append(e.Key);
            }
        }

        return sb.ToString();
    }

    void IManagedContext.Application_Lock() {
        _context.Application.Lock();
    }

    void IManagedContext.Application_UnLock() {
        _context.Application.UnLock();
    }

    String IManagedContext.Application_GetContentsNames() {
        return StringArrayToString(_context.Application.AllKeys);
    }

    String IManagedContext.Application_GetStaticNames() {
        return DictEnumKeysToString((IDictionaryEnumerator)_context.Application.StaticObjects.GetEnumerator());
    }

    Object IManagedContext.Application_GetContentsObject(String name) {
        return _context.Application[name];
    }

    void IManagedContext.Application_SetContentsObject(String name, Object obj) {
        _context.Application[name] = obj;
    }

    void IManagedContext.Application_RemoveContentsObject(String name) {
        _context.Application.Remove(name);
    }

    void IManagedContext.Application_RemoveAllContentsObjects() {
        _context.Application.RemoveAll();
    }

    Object IManagedContext.Application_GetStaticObject(String name) {
        return _context.Application.StaticObjects[name];
    }

    String IManagedContext.Request_GetAsString(int what) {
        String s = String.Empty;

        switch ((RequestString)what) {
            case RequestString.QueryString:
                return CollectionToString(_context.Request.QueryString);
            case RequestString.Form:
                return CollectionToString(_context.Request.Form);
            case RequestString.Cookies:
                return String.Empty;
            case RequestString.ServerVars:
                return CollectionToString(_context.Request.ServerVariables);
        }

        return s;
    }

    String IManagedContext.Request_GetCookiesAsString() {
        return CookiesToString(_context.Request.Cookies);
    }

    int IManagedContext.Request_GetTotalBytes() {
        return _context.Request.TotalBytes;
    }

    int IManagedContext.Request_BinaryRead(byte[] bytes, int size) {
        return _context.Request.InputStream.Read(bytes, 0, size);
    }

    String IManagedContext.Response_GetCookiesAsString() {
        return CookiesToString(_context.Response.Cookies);
    }

    void IManagedContext.Response_AddCookie(String name) {
        _context.Response.Cookies.Add(new HttpCookie(name));
    }

    void IManagedContext.Response_SetCookieText(String name, String text) {
        _context.Response.Cookies[name].Value = text;
    }

    void IManagedContext.Response_SetCookieSubValue(String name, String key, String value) {
        _context.Response.Cookies[name].Values[key] = value;
    }

    void IManagedContext.Response_SetCookieExpires(String name, double dtExpires) {
        _context.Response.Cookies[name].Expires = DateTime.FromOADate(dtExpires);
    }

    void IManagedContext.Response_SetCookieDomain(String name, String domain) {
        _context.Response.Cookies[name].Domain = domain;
    }

    void IManagedContext.Response_SetCookiePath(String name, String path) {
        _context.Response.Cookies[name].Path = path;
    }

    void IManagedContext.Response_SetCookieSecure(String name, int secure) {
        _context.Response.Cookies[name].Secure = (secure != 0);
    }

    void IManagedContext.Response_Write(String text) {
        _context.Response.Write(text);
    }

    void IManagedContext.Response_BinaryWrite(byte[] bytes, int size) {
        _context.Response.OutputStream.Write(bytes, 0, size);
    }

    void IManagedContext.Response_Redirect(String url) {
        _context.Response.Redirect(url);
    }

    void IManagedContext.Response_AddHeader(String name, String value) {
        _context.Response.AppendHeader(name, value);
    }

    void IManagedContext.Response_Pics(String value) {
        _context.Response.Pics(value);
    }

    void IManagedContext.Response_Clear() {
        _context.Response.Clear();
    }

    void IManagedContext.Response_Flush() {
        _context.Response.Flush();
    }

    void IManagedContext.Response_End() {
        _context.Response.End();
    }

    void IManagedContext.Response_AppendToLog(String entry) {
        _context.Response.AppendToLog(entry);
    }

    String IManagedContext.Response_GetContentType() {
        return _context.Response.ContentType;
    }

    void IManagedContext.Response_SetContentType(String contentType) {
        _context.Response.ContentType = contentType;
    }

    String IManagedContext.Response_GetCharSet() {
        return _context.Response.Charset;
    }

    void IManagedContext.Response_SetCharSet(String charSet) {
        _context.Response.Charset = charSet;
    }

    String IManagedContext.Response_GetCacheControl() {
        return _context.Response.CacheControl;
    }

    void IManagedContext.Response_SetCacheControl(String cacheControl) {
        _context.Response.CacheControl = cacheControl;
    }

    String IManagedContext.Response_GetStatus() {
        return _context.Response.Status;
    }

    void IManagedContext.Response_SetStatus(String status) {
        _context.Response.Status = status;
    }

    int IManagedContext.Response_GetExpiresMinutes() {
        return _context.Response.Expires;
    }

    void IManagedContext.Response_SetExpiresMinutes(int expiresMinutes) {
        _context.Response.Expires = expiresMinutes;
    }

    double IManagedContext.Response_GetExpiresAbsolute() {
        return _context.Response.ExpiresAbsolute.ToOADate();
    }

    void IManagedContext.Response_SetExpiresAbsolute(double dtExpires) {
        _context.Response.ExpiresAbsolute = DateTime.FromOADate(dtExpires);
    }

    int IManagedContext.Response_GetIsBuffering() {
        return _context.Response.BufferOutput ? 1 : 0;
    }

    void IManagedContext.Response_SetIsBuffering(int isBuffering) {
        _context.Response.BufferOutput = (isBuffering != 0);
    }

    int IManagedContext.Response_IsClientConnected() {
        return _context.Response.IsClientConnected ? 1 : 0;
    }

    Object IManagedContext.Server_CreateObject(String progId) {
        return _context.Server.CreateObject(progId);
    }

    String IManagedContext.Server_MapPath(String logicalPath) {
        return _context.Server.MapPath(logicalPath);
    }

    String IManagedContext.Server_HTMLEncode(String str) {
        return _context.Server.HtmlEncode(str);
    }

    String IManagedContext.Server_URLEncode(String str) {
        return _context.Server.UrlEncode(str);
    }

    String IManagedContext.Server_URLPathEncode(String str) {
        return _context.Server.UrlPathEncode(str);
    }

    int IManagedContext.Server_GetScriptTimeout() {
        return _context.Server.ScriptTimeout;
    }

    void IManagedContext.Server_SetScriptTimeout(int timeoutSeconds) {
        _context.Server.ScriptTimeout = timeoutSeconds;
    }

    void IManagedContext.Server_Execute(String url) {
        _context.Server.Execute(url);
    }

    void IManagedContext.Server_Transfer(String url) {
        _context.Server.Transfer(url);
    }

    int IManagedContext.Session_IsPresent() {
        return (_context.Session != null) ? 1 : 0;
    }

    String IManagedContext.Session_GetID() {
        return _context.Session.SessionID;
    }

    int IManagedContext.Session_GetTimeout() {
        return _context.Session.Timeout;
    }

    void IManagedContext.Session_SetTimeout(int value) {
        _context.Session.Timeout = value;
    }

    int IManagedContext.Session_GetCodePage() {
        return _context.Session.CodePage;
    }

    void IManagedContext.Session_SetCodePage(int value) {
        _context.Session.CodePage = value;
    }

    int IManagedContext.Session_GetLCID() {
        return _context.Session.LCID;
    }

    void IManagedContext.Session_SetLCID(int value) {
        _context.Session.LCID = value;
    }

    void IManagedContext.Session_Abandon() {
        _context.Session.Abandon();
    }

    String IManagedContext.Session_GetContentsNames() {
        return EnumKeysToString(_context.Session.GetEnumerator());
    }

    String IManagedContext.Session_GetStaticNames() {
        return DictEnumKeysToString((IDictionaryEnumerator)_context.Session.StaticObjects.GetEnumerator());
    }

    Object IManagedContext.Session_GetContentsObject(String name) {
        return _context.Session[name];
    }

    void IManagedContext.Session_SetContentsObject(String name, Object obj) {
        _context.Session[name] = obj;
    }

    void IManagedContext.Session_RemoveContentsObject(String name) {
        _context.Session.Remove(name);
    }

    void IManagedContext.Session_RemoveAllContentsObjects() {
        _context.Session.RemoveAll();
    }

    Object IManagedContext.Session_GetStaticObject(String name) {
        return _context.Session.StaticObjects[name];
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\codepageutils.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodePageUtils.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    using System.Collections;
    
    //
    // Utility class to help with determining if a given code page
    // is ASCII compatible (preserves 0-127 Unicode characters as is)
    //

    internal class CodePageUtils {

        /*      The following array of ASCII compatible code pages
                is generated by running this code on a machine that
                has _many_ codepages installed:

                using System;
                using System.Collections;
                using System.Text;
                public class qq {
                    public static void Main(string[] args) {
                        ArrayList list = new ArrayList();
                        byte[] bb = new byte[128]; for (int i = 0; i < 128; i++) bb[i] = (byte)i;
                        String asciiString = Encoding.ASCII.GetString(bb);
                        for (int i = 1; i < 100000; i++) {
                            try {
                                Encoding e = Encoding.GetEncoding(i);
                                byte[] xx = e.GetBytes(asciiString);
                                if (xx.Length == 128) {
                                    bool good = true;
                                    for (int j = 0; j < 128; j++) { if (bb[j] != xx[j]) { good = false; break; } }
                                    if (good) list.Add(i);
                                }
                            }
                            catch {}
                        }
                        int n = list.Count;
                        Console.Write("private const int[] _asciiCompatCodePages = new int[" + n + "] {\r\n    ");
                        for (int i = 0; i < n; i++) {
                            Console.Write("{0,5}", list[i]);
                            if (i < n-1) Console.Write(", ");
                            if (((i+1) % 10) == 0) Console.Write("\r\n    ");
                        }
                        Console.Write("\r\n};\r\n");
                    }
                }

        */

        private static int[] _asciiCompatCodePages = new int[79] {
              437,   708,   720,   737,   775,   850,   852,   855,   857,   858,
              860,   861,   862,   863,   864,   865,   866,   869,   874,   932,
              936,   949,   950,  1250,  1251,  1252,  1253,  1254,  1255,  1256,
             1257,  1258,  1361, 10000, 10001, 10002, 10003, 10004, 10005, 10006,
            10007, 10008, 10010, 10017, 10029, 10079, 10081, 10082, 20000, 20001,
            20002, 20003, 20004, 20005, 20127, 20866, 20932, 20936, 20949, 21866,
            28591, 28592, 28593, 28594, 28595, 28596, 28597, 28598, 28599, 28605,
            38598, 50220, 50221, 50222, 50225, 50227, 51932, 51949, 65001
        };

        private CodePageUtils() {
        }

        internal /*public*/ static bool IsAsciiCompatibleCodePage(int codepage) {
            return (Array.BinarySearch(_asciiCompatCodePages, codepage) >= 0);
        }

        internal const int CodePageUT8 = 65001;
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\altserialization.cs ===
//------------------------------------------------------------------------------
// <copyright file="altserialization.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * AltSerialization.cs
 * 
 * Copyright (c) 1998-2000, Microsoft Corporation
 * 
 */

namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Serialization;
    using System.IO;
    
    internal class AltSerialization {
        enum TypeID : byte {
            String = 1,
            Int32,
            Boolean,
            DateTime,
            Decimal,
            Byte,
            Char,
            Single,
            Double,
            SByte,
            Int16,
            Int64,
            UInt16,
            UInt32,
            UInt64,
            TimeSpan,
            Guid,
            IntPtr,
            UIntPtr,
            Object,
            Null,
        }

        static Type[] s_serializedTypes = 
        {
            null,   // id of String is 1
            typeof(String),
            typeof(Int32),
            typeof(Boolean),
            typeof(DateTime),
            typeof(Decimal),
            typeof(Byte),
            typeof(Char),
            typeof(Single),
            typeof(Double),
            typeof(SByte),
            typeof(Int16),
            typeof(Int64),
            typeof(UInt16),
            typeof(UInt32),
            typeof(UInt64),
            typeof(TimeSpan),
            typeof(Guid),
            typeof(IntPtr),
            typeof(UIntPtr),
            null,
        };

        private AltSerialization() {
        }

        internal static void WriteValueToStream(Object value, BinaryWriter writer) {
            if (value == null) {
                writer.Write((byte)TypeID.Null);
            } else {
                Type    t = value.GetType();
    
                if (t == s_serializedTypes[(int)TypeID.String]) {
                    writer.Write((byte)TypeID.String);
                    writer.Write((String) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Int32]) {
                    writer.Write((byte)TypeID.Int32);
                    writer.Write((Int32) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Boolean]) {
                    writer.Write((byte)TypeID.Boolean);
                    writer.Write((Boolean) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.DateTime]) {
                    writer.Write((byte)TypeID.DateTime);
                    writer.Write(((DateTime) value).Ticks);
                }
                else if (t == s_serializedTypes[(int)TypeID.Decimal]) {
                    writer.Write((byte)TypeID.Decimal);
                    int[] bits = Decimal.GetBits((Decimal)value);
                    for (int i = 0; i < 4; i++) {
                        writer.Write((int)bits[i]);
                    }
                }
                else if (t == s_serializedTypes[(int)TypeID.Byte]) {
                    writer.Write((byte)TypeID.Byte);
                    writer.Write((byte) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Char]) {
                    writer.Write((byte)TypeID.Char);
                    writer.Write((char) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Single]) {
                    writer.Write((byte)TypeID.Single);
                    writer.Write((float) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Double]) {
                    writer.Write((byte)TypeID.Double);
                    writer.Write((double) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.SByte]) {
                    writer.Write((byte)TypeID.SByte);
                    writer.Write((SByte) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Int16]) {
                    writer.Write((byte)TypeID.Int16);
                    writer.Write((short) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.Int64]) {
                    writer.Write((byte)TypeID.Int64);
                    writer.Write((long) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.UInt16]) {
                    writer.Write((byte)TypeID.UInt16);
                    writer.Write((UInt16) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.UInt32]) {
                    writer.Write((byte)TypeID.UInt32);
                    writer.Write((UInt32) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.UInt64]) {
                    writer.Write((byte)TypeID.UInt64);
                    writer.Write((UInt64) value);
                }
                else if (t == s_serializedTypes[(int)TypeID.TimeSpan]) {
                    writer.Write((byte)TypeID.TimeSpan);
                    writer.Write(((TimeSpan) value).Ticks);
                }
                else if (t == s_serializedTypes[(int)TypeID.Guid]) {
                    writer.Write((byte)TypeID.Guid);
                    Guid guid = (Guid) value;
                    byte[] bits = guid.ToByteArray();
                    writer.Write(bits);
                }
                else if (t == s_serializedTypes[(int)TypeID.IntPtr]) {
                    writer.Write((byte)TypeID.IntPtr);
                    IntPtr  v = (IntPtr) value;
                    if (IntPtr.Size == 4) {
                        writer.Write((Int32)v.ToInt32());
                    }
                    else {
                        Debug.Assert(IntPtr.Size == 8);
                        writer.Write((Int64)v.ToInt64());
                    }
                }
                else if (t == s_serializedTypes[(int)TypeID.UIntPtr]) {
                    writer.Write((byte)TypeID.UIntPtr);
                    UIntPtr  v = (UIntPtr) value;
                    if (UIntPtr.Size == 4) {
                        writer.Write((UInt32)v.ToUInt32());
                    }
                    else {
                        Debug.Assert(UIntPtr.Size == 8);
                        writer.Write((UInt64)v.ToUInt64());
                    }
                }
                else {
                    writer.Write((byte)TypeID.Object);
                    BinaryFormatter formatter = new BinaryFormatter();
                    try {
                        formatter.Serialize(writer.BaseStream, value);
                    } catch (Exception innerException) {
                        HttpException outerException = new HttpException(HttpRuntime.FormatResourceString(SR.Cant_serialize_session_state), innerException);
                        outerException.SetFormatter(new UseLastUnhandledErrorFormatter(outerException));
                        throw outerException;
                    }
                }
            }
        }

        internal static Object ReadValueFromStream(BinaryReader reader) {
            TypeID  id;
            Object  value = null;

            id = (TypeID) reader.ReadByte();
            switch (id) {
                case TypeID.String:            
                    value = reader.ReadString();
                    break;

                case TypeID.Int32:
                    value = reader.ReadInt32();
                    break;

                case TypeID.Boolean:
                    value = reader.ReadBoolean();
                    break;

                case TypeID.DateTime:
                    value = new DateTime(reader.ReadInt64());
                    break;

                case TypeID.Decimal:
                    {
                        int[] bits = new int[4];
                        for (int i = 0; i < 4; i++) {
                            bits[i] = reader.ReadInt32();
                        }

                        value = new Decimal(bits);
                    }
                    break;

                case TypeID.Byte:
                    value = reader.ReadByte();
                    break;

                case TypeID.Char:
                    value = reader.ReadChar();
                    break;

                case TypeID.Single:
                    value = reader.ReadSingle();
                    break;

                case TypeID.Double:
                    value = reader.ReadDouble();
                    break;

                case TypeID.SByte:
                    value = reader.ReadSByte();
                    break;

                case TypeID.Int16:
                    value = reader.ReadInt16();
                    break;

                case TypeID.Int64:
                    value = reader.ReadInt64();
                    break;

                case TypeID.UInt16:
                    value = reader.ReadUInt16();
                    break;

                case TypeID.UInt32:
                    value = reader.ReadUInt32();
                    break;

                case TypeID.UInt64:
                    value = reader.ReadUInt64();
                    break;

                case TypeID.TimeSpan:
                    value = new TimeSpan(reader.ReadInt64());
                    break;

                case TypeID.Guid:
                    {
                        byte[] bits = reader.ReadBytes(16);
                        value = new Guid(bits);
                    }
                    break;

                case TypeID.IntPtr:
                    if (IntPtr.Size == 4) {
                        value = new IntPtr(reader.ReadInt32());
                    }
                    else {
                        Debug.Assert(IntPtr.Size == 8);
                        value = new IntPtr(reader.ReadInt64());
                    }
                    break;

                case TypeID.UIntPtr:
                    if (UIntPtr.Size == 4) {
                        value = new UIntPtr(reader.ReadUInt32());
                    }
                    else {
                        Debug.Assert(UIntPtr.Size == 8);
                        value = new UIntPtr(reader.ReadUInt64());
                    }
                    break;

                case TypeID.Object:
                    BinaryFormatter formatter = new BinaryFormatter();
                    value = formatter.Deserialize(reader.BaseStream);
                    break;

                case TypeID.Null:            
                    value = null;
                    break;
            }

            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\doublelinklist.cs ===
//------------------------------------------------------------------------------
// <copyright file="DoubleLinkList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * DoubleLinkList
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {
    using System.Text;
    using System.Runtime.Serialization.Formatters;

    internal class DoubleLinkList : DoubleLink {
        internal /*public*/ DoubleLinkList() {
        }
        internal /*public*/ void Clear() {
            _next = _prev = this;
        }
        internal /*public*/ bool IsEmpty() {
            return _next == this;
        }
        internal /*public*/ DoubleLink GetHead() {
            return _next;
        }
        internal /*public*/ DoubleLink GetTail() {
            return _prev;
        }
        internal /*public*/ Object RemoveHead() {
            _next.Remove(); return _next.Item;
        }
        internal /*public*/ Object RemoveTail() {
            _prev.Remove(); return _prev.Item;
        }
        internal /*public*/ virtual void InsertHead(DoubleLink entry) {
            entry.InsertAfter(this);
        }
        internal /*public*/ virtual void InsertTail(DoubleLink entry) {
            entry.InsertBefore(this);
        }

        internal /*public*/ DoubleLinkList RemoveSublist(DoubleLink head, DoubleLink tail) {
            DoubleLinkList  list = new DoubleLinkList();

            head._prev._next = tail._next;
            tail._next._prev = head._prev;
            list._next = head;
            list._prev = tail;
            head._prev = list;
            tail._next = list;

            return list;
        }

        internal /*public*/ DoubleLinkListEnumerator GetEnumerator() {
            return new DoubleLinkListEnumerator(this);
        }

#if DBG
        internal /*public*/ override void DebugValidate() {
            DoubleLink  l1, l2;

            base.DebugValidate();

            /*
             * Detect loops by moving one pointer forward 2 for every 1
             * of the other.
             */

            l1 = l2 = this;
            for (;;) {
                /* move l2 forward */
                l2 = l2._next;
                if (l2 == this)
                    break;

                Debug.CheckValid(l2 != l1, "Invalid loop in list, first move.");
                l2.DebugValidate();

                /* move l2 forward again */
                l2 = l2._next;
                if (l2 == this)
                    break;

                Debug.CheckValid(l2 != l1, "Invalid loop in list, second move.");
                l2.DebugValidate();

                /* move l1 forward */
                l1 = l1._next;
            }
        }

        internal /*public*/ override string DebugDescription(String indent) {
            string                      desc;
            DoubleLinkListEnumerator    lenum;
            int                         c;
            StringBuilder               sb;
            string                      i2 = indent + "    ";

            if (IsEmpty()) {
                desc = indent + "DoubleLinkList is empty\n";
            }
            else {
                c = Length;

                sb = new StringBuilder(indent + "DoubleLinkList has " + c + " entries.\n");
                lenum = GetEnumerator();
                while (lenum.MoveNext()) {
                    sb.Append(Debug.GetDescription(lenum.GetDoubleLink(), i2));
                }

                desc = sb.ToString();
            }

            return desc;
        }
#endif    

        internal /*public*/ int Length {
            get {
                DoubleLinkListEnumerator    lenum;
                int                         c;

                Debug.Validate(this);

                c = 0;
                lenum = GetEnumerator();
                while (lenum.MoveNext()) {
                    c++;
                }

                return c;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\doublelink.cs ===
//------------------------------------------------------------------------------
// <copyright file="DoubleLink.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * DoubleLink
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;

    internal class DoubleLink {
        internal DoubleLink    _next, _prev;
        internal Object           Item;

        internal /*public*/ DoubleLink() {
            _next = _prev = this;
        }
        internal /*public*/ DoubleLink(Object item)  : this() {
            this.Item = item;
        }
        internal /*public*/ DoubleLink Next {get {return _next;}}
        internal /*public*/ DoubleLink Prev {get {return _prev;}}

        internal /*public*/ void InsertAfter(DoubleLink after) {
            this._prev = after;
            this._next = after._next;
            after._next = this;
            this._next._prev = this;
        }

        internal /*public*/ void InsertBefore(DoubleLink before) {
            this._prev = before._prev;
            this._next = before;
            before._prev = this;
            this._prev._next = this;
        }

        internal /*public*/ void Remove() {
            this._prev._next = this._next;
            this._next._prev = this._prev;
            _next = _prev = this;
        }

#if DBG
        internal /*public*/ virtual void DebugValidate() {
            Debug.CheckValid(this._next != this || this._prev == this, "Invalid link");
        }

        internal /*public*/ virtual string DebugDescription(string indent) {
            string desc;

            desc = indent + "_next=" + _next + ", _prev=" + _prev + "\nItem=";
            desc += Debug.GetDescription(Item, indent + "    ");

            return desc;
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\doublelinklistenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="DoubleLinkListEnumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * DoubleLinkList
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;
    using System.Collections;

    internal class DoubleLinkListEnumerator : IEnumerator {
        private DoubleLinkList  _list;
        private DoubleLink      _current;

        internal DoubleLinkListEnumerator(DoubleLinkList list) {
            _list = list;
            _current = list;
        }

        public void Reset() {
            _current = _list;
        }

        public bool MoveNext() {
            if (_current.Next == _list) {
                _current = null;
                return false;
            }

            _current = _current.Next;
            return true;
        }

        public Object Current {
            get { 
                if (_current == null || _current == _list)
                    throw new InvalidOperationException();
                return _current.Item;
            }
        }

        internal /*public*/ DoubleLink GetDoubleLink() {
            return _current;
        }

        internal /*public*/ void Remove() {
            if (_current == null || _current == _list)
                throw new InvalidOperationException();

            DoubleLink  t = _current;
            _current = _current.Prev;
            t.Remove();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\parsehttpdate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ParseHttpDate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ParseHttpDate.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Globalization;


namespace System.Web.Util
{
    class HttpDate
    {
        static readonly int[] s_tensDigit = new int[10] { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 };
        
        private HttpDate() {
        }

        /*++
        
            Converts a 2 character string to integer
        
            Arguments:
                s   String to convert
        
            Returns:
                numeric equivalent, 0 on failure.
        --*/
        static int atoi2(string s, int startIndex)
        {
            try {
                int tens = s[0 + startIndex] - '0';
                int ones = s[1 + startIndex] - '0';
            
                return s_tensDigit[tens] + ones;
            } 
            catch {
                throw new FormatException(SR.GetString(SR.Atio2BadString, s, startIndex));
            }
        }
        
        static readonly string[] s_days = new string [7] {
            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
        };
        
        static readonly string[] s_months = new string[12] {
            "Jan", "Feb", "Mar", "Apr",
            "May", "Jun", "Jul", "Aug",
            "Sep", "Oct", "Nov", "Dec"
        };
        
        // Custom table for make_month() for mapping "Apr" to 4
        static readonly sbyte[] s_monthIndexTable = new sbyte[64] {
           -1, (sbyte)'A',          2, 12, -1, -1,         -1,  8, // A to G
           -1,         -1,         -1, -1,  7, -1, (sbyte)'N', -1, // H to O
            9,         -1, (sbyte)'R', -1, 10, -1,         11, -1, // P to W
           -1,          5,         -1, -1, -1, -1,         -1, -1, // X to Z
           -1, (sbyte)'A',          2, 12, -1, -1,         -1,  8, // a to g
           -1,         -1,         -1, -1,  7, -1, (sbyte)'N', -1, // h to o
            9,         -1, (sbyte)'R', -1, 10, -1,         11, -1, // p to w
           -1,          5,         -1, -1, -1, -1,         -1, -1  // x to z
        };
        
        static int make_month(string s, int startIndex)
        {
            int i;
            sbyte monthIndex;
            string monthString;
        
            //
            // use the third character as the index
            //
        
            i = ((int) s[2 + startIndex] - 0x40) & 0x3F;
            monthIndex = s_monthIndexTable[i];
        
            if ( monthIndex >= 13 ) {
            
                //
                // ok, we need to look at the second character
                //
            
                if ( monthIndex == (sbyte) 'N' ) {
            
                    //
                    // we got an N which we need to resolve further
                    //
            
                    //
                    // if s[1] is 'u' then Jun, if 'a' then Jan
                    //


                    if ( s_monthIndexTable[(s[1 + startIndex]-0x40) & 0x3f] == (sbyte) 'A' ) {
                        monthIndex = 1;
                    } else {
                        monthIndex = 6;
                    }
            
                } else if ( monthIndex == (sbyte) 'R' ) {
            
                    //
                    // if s[1] is 'a' then March, if 'p' then April
                    //
            
                    if ( s_monthIndexTable[(s[1 + startIndex]-0x40) & 0x3f] == (sbyte) 'A' ) {
                        monthIndex = 3;
                    } else {
                        monthIndex = 4;
                    }
                } else {
                    throw new FormatException(SR.GetString(SR.MakeMonthBadString, s, startIndex));
                }
            }

        
            monthString = s_months[monthIndex-1];
        
            if ( (s[0 + startIndex] == monthString[0]) &&
                 (s[1 + startIndex] == monthString[1]) &&
                 (s[2 + startIndex] == monthString[2]) ) {
        
                return(monthIndex);
        
            } else if ( ((Char.ToUpper(s[0 + startIndex], CultureInfo.InvariantCulture)) == monthString[0]) &&
                        ((Char.ToLower(s[1 + startIndex], CultureInfo.InvariantCulture)) == monthString[1]) &&
                        ((Char.ToLower(s[2 + startIndex], CultureInfo.InvariantCulture)) == monthString[2]) ) {
        
                return monthIndex;
            }

            throw new FormatException(SR.GetString(SR.MakeMonthBadString, s, startIndex));

        } // make_month
        
        /*++
        
          Converts a string representation of a GMT time (three different
          varieties) to an NT representation of a file time.
        
          We handle the following variations:
        
            Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
            Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
            Sun Nov 06 08:49:37 1994        (ANSI C's asctime() format
        
          Arguments:
            time                String representation of time field
        
          Returns:
            TRUE on success and FALSE on failure.
        
          History:
        
            Johnl       24-Jan-1995     Modified from WWW library
        
        --*/
        static internal DateTime UtcParse(string time)
        {
            int         i;
            int         year, month, day, hour, minute, second;
        
            if (time == null) {
                throw new ArgumentNullException("time");
            }
        
            if ((i = time.IndexOf(',')) != -1) {
        
                //
                // Thursday, 10-Jun-93 01:29:59 GMT
                // or: Thu, 10 Jan 1993 01:29:59 GMT */
                //
        
                int length = time.Length - i;
                while (--length > 0 && time[++i] == ' ') ;

                if (time[i+2] == '-' ) {      /* First format */
        
                    if (length < 18) {
                        throw new FormatException(SR.GetString(SR.UtilParseDateTimeBad, time));
                    }
        
                    day = atoi2(time, i);
                    month = make_month(time, i + 3);
                    year = atoi2(time, i + 7);
                    if ( year < 50 ) {
                        year += 2000;
                    } else {
                        year += 1900;
                    }

                    hour = atoi2(time, i + 10);
                    minute = atoi2(time, i + 13);
                    second = atoi2(time, i +16);
        
                } else {                         /* Second format */
        
                    if (length < 20) {
                        throw new FormatException(SR.GetString(SR.UtilParseDateTimeBad, time));
                    }
        
                    day = atoi2(time, i);
                    month = make_month(time, i + 3);
                    year = atoi2(time, i + 7) * 100 + atoi2(time, i + 9);
                    hour = atoi2(time, i + 12);
                    minute = atoi2(time, i + 15);
                    second = atoi2(time, i + 18);
                }
            } else {    /* Try the other format:  Wed Jun 09 01:29:59 1993 GMT */
        
                i = -1;
                int length = time.Length + 1;
                while (--length > 0 && time[++i] == ' ');
        
                if (length < 24) {
                    throw new FormatException(SR.GetString(SR.UtilParseDateTimeBad, time));
                }

                day = atoi2(time, i + 8);
                month = make_month(time, i + 4);
                year = atoi2(time, i + 20) * 100 + atoi2(time, i + 22);
                hour = atoi2(time, i + 11);
                minute = atoi2(time, i + 14);
                second = atoi2(time, i + 17);
            }
        
            return new DateTime(year, month, day, hour, minute, second);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\msec.cs ===
//------------------------------------------------------------------------------
// <copyright file="Msec.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Msec
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {

    internal class Msec {
        internal const int ONE_SECOND     = 1000;            
        internal const int ONE_MINUTE     = ONE_SECOND * 60; 
        internal const int ONE_HOUR       = ONE_MINUTE * 60; 
        internal const int ONE_DAY        = ONE_HOUR * 24;   
        internal const int ONE_WEEK       = ONE_DAY * 7;     
        internal const long ONE_YEAR      = ONE_DAY * 365L;
        internal const long ONE_LEAP_YEAR = ONE_DAY * 366L;

        private Msec() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\hresults.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    // Note: FACILITY_URT is defined as 0x13 (0x8013xxxx).  Within that
    // range, 0x1yyy is for Runtime errors (used for Security, Metadata, etc).
    // In that subrange, 0x15zz and 0x16zz have been allocated for classlib-type 
    // HResults. Also note that some of our HResults have to map to certain 
    // COM HR's, etc.
    
    internal sealed class HResults {
        internal const int S_OK                   = 0;
        internal const int E_NOTIMPL              = unchecked((int)0x80004001); 
        internal const int E_POINTER              = unchecked((int)0x80004003); 
        internal const int E_FAIL                 = unchecked((int)0x80004005);     
        internal const int E_FILENOTFOUND         = unchecked((int)0x80070002);     
        internal const int E_PATHNOTFOUND         = unchecked((int)0x80070003);     
        internal const int E_ACCESSDENIED         = unchecked((int)0x80070005);
        internal const int E_OUTOFMEMORY          = unchecked((int)0x8007000E);
        internal const int E_INVALIDARG           = unchecked((int)0x80070057);
        internal const int E_INSUFFICIENT_BUFFER  = unchecked((int)0x8007007A);

        private HResults() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\resourcepool.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourcePool.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    using System.Collections;
    using System.Threading;

    /*
     * ResourcePool provides a place to store expensive resources,
     * such as network connections, that you want to dispose of when
     * they are underused. A resource pool can be configured to timeout
     * resources at a given interval, and to have a max limit of resources.
     */
    class ResourcePool : IDisposable {
        ArrayList       _resources;     // the resources
        int             _iDisposable;   // resources below this index are candidates for disposal
        int             _max;           // max number of resources
        Timer           _timer;         // periodic timer
        TimerCallback   _callback;      // callback delegate
        TimeSpan        _interval;      // callback interval
        bool            _disposed;

        internal ResourcePool(TimeSpan interval, int max) {
            _interval = interval;
            _resources = new ArrayList(4);
            _max = max;
            _callback = new TimerCallback(this.TimerProc);

            Debug.Validate("ResourcePool", this);
        }

        public void Dispose() {
            lock (this) {
                if (!_disposed) {
                    if (_resources != null) {
                        foreach (IDisposable resource in _resources) {
                            resource.Dispose();
                        }

                        _resources.Clear();
                    }

                    if (_timer != null) {
                        _timer.Dispose();
                    }

                    _disposed = true;
                }
            }
        }

        internal object RetrieveResource() {
            object result = null;

            // avoid lock in common case
            if (_resources.Count != 0) {
                lock (this) {
                    Debug.Validate("ResourcePool", this);

                    if (!_disposed) {
                        if (_resources.Count == 0) {
                            result = null;
                            Debug.Trace("ResourcePool", "RetrieveResource returned null");
                        } else {
                            result = _resources[_resources.Count-1];
                            _resources.RemoveAt(_resources.Count-1);
                            if (_resources.Count < _iDisposable) {
                                _iDisposable = _resources.Count;
                            }
                        }

                        Debug.Validate("ResourcePool", this);
                    }
                }
            }
    
            return result;
        }

        internal void StoreResource(IDisposable o) {

            lock (this) {
                Debug.Validate("ResourcePool", this);

                if (!_disposed) {
                    if (_resources.Count < _max) {
                        _resources.Add(o);
                        o = null;
                        if (_timer == null) {

#if DBG
                            if (!Debug.IsTagPresent("Timer") || Debug.IsTagEnabled("Timer"))
#endif
                            {
                                _timer = new Timer(_callback, null, _interval, _interval);
                            }
                        }
                    }

                    Debug.Validate("ResourcePool", this);
                }
            }

            if (o != null) {
                Debug.Trace("ResourcePool", "StoreResource reached max=" + _max);
                o.Dispose();
            }
        }

        void TimerProc(Object userData) {
            IDisposable[] a = null;

            lock (this) {
                Debug.Validate("ResourcePool", this);

                if (!_disposed) {
                    if (_resources.Count == 0) {
                        if (_timer != null) {
                            _timer.Dispose();
                            _timer = null;
                        }

                        Debug.Validate("ResourcePool", this);
                        return;
                    }

                    a = new IDisposable[_iDisposable];
                    _resources.CopyTo(0, a, 0, _iDisposable);
                    _resources.RemoveRange(0, _iDisposable);
                    _iDisposable = _resources.Count;

                    Debug.Trace("ResourcePool", "Timer disposing " + a.Length + "; remaining=" + _resources.Count);
                    Debug.Validate("ResourcePool", this);
                }
            }

            if (a != null) {
                for (int i = 0; i < a.Length; i++) {
                    a[i].Dispose();
                }
            }
        }

#if DBG
        internal void DebugValidate() {
            Debug.CheckValid(_resources != null, "_resources != null");

            Debug.CheckValid(0 <= _iDisposable && _iDisposable <= _resources.Count,
                             "0 <= _iDisposable && _iDisposable <= _resources.Count" +
                             ";_iDisposable=" + _iDisposable +
                             ";_resources.Count=" + _resources.Count);

            Debug.CheckValid(_interval > TimeSpan.Zero, "_interval > TimeSpan.Zero" +
                             ";_interval=" + _interval);
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\debug.cs ===
//------------------------------------------------------------------------------
// <copyright file="Debug.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Debug class implementation
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Diagnostics;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using HttpException = System.Web.HttpException;


    /*
     * Debugging class. Please see inc\util.h for a description
     * of debugging functionality.
     */
    class Debug {
        internal const String TAG_INTERNAL = "Internal";
        internal const String TAG_EXTERNAL = "External";
        internal const String TAG_ALL      = "*";

        const int           MB_SERVICE_NOTIFICATION = 0x00200000,
        MB_TOPMOST = 0x00040000,
        MB_OK = 0x00000000,
        MB_ICONEXCLAMATION = 0x00000030;


#if DBG
        static Hashtable        s_tableAlwaysValidate = new Hashtable();
        static Type             s_stringType = typeof(String);
        static Type[]           s_DumpArgs = new Type[1] {s_stringType};
        static Type[]           s_ValidateArgs = new Type[0];
        const string            s_newline = "\n";

        private static String GetCurrentStackTrace() {
            String          stacktrace;
            int             iLastDebug; 
            int             iStart;        

            stacktrace = System.Environment.StackTrace;

            /*
             * Remove debug functions from stack trace. A stack trace 
             * has a format such as:
             * 
             *     at System.Environment.CaptureStackTrace(int)
             *     at System.Environment.GetStackTrace()
             *     at System.Web.Util.Debug.Assert(bool, System.String)
             *     at System.Web.HttpRuntime.ProcessRequest(System.Web.HttpWorkerRequest)
             *     at System.Web.Hosting.ISAPIRuntime.ProcessRequest(int, int)
             * 
             */

            iLastDebug = stacktrace.LastIndexOf("System.Web.Util.Debug");
            iStart = stacktrace.IndexOf("\r\n", iLastDebug) + 2;
            return stacktrace.Substring(iStart);
        }
#endif

        private Debug() {
        }


        /*
         * Sends the message to the debugger if the tag is enabled.
         * 
         * @param tag      The tag to identify the message.
         * @param message  The message.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Trace(String tag, String message) {
#if DBG
            if (HttpRuntime.IsIsapiLoaded) {
                if (UnsafeNativeMethods.DBGNDTrace(tag, message)) {
                    Break();
                }
            }
#endif
        }

        [System.Diagnostics.Conditional("DBG")]
        public static void TraceException(String tag, Exception e) {
#if DBG
            String httpCode;

            if (e is HttpException) {
                httpCode = " _httpCode=" + ((HttpException)e).GetHttpCode().ToString();
            }
            else {
                httpCode = String.Empty;
            }

            String strHr   = ((e is ExternalException) ? "_hr =" + ((ExternalException)e).ErrorCode : "");
            String message = "\\p\\" + 
                             e.ToString() + 
                             "\n" + 
                             strHr +
                             httpCode +
                             "\n" + 
                             e.StackTrace;

            Trace(tag, message);
#endif
        }


#if DBG
        static bool DoAssert(bool assertion, String message) {
            StringBuilder   sb = new StringBuilder();

            /*
             * Skip 2 frames - one for this function, one for
             * the public Assert function that called this function.
             */
            StackFrame      frame = new StackFrame(2, true);
            sb.Append("File: ");
            sb.Append(frame.GetFileName());
            sb.Append(":");
            sb.Append(frame.GetFileLineNumber());

            StackTrace      trace = new StackTrace(2, true);
            sb.Append("\nStack trace:");
            sb.Append(trace.ToString());

            if (HttpRuntime.IsIsapiLoaded) {
                return UnsafeNativeMethods.DBGNDAssert(message, sb.ToString());
            }
            else {
                return false;
            }
        }
#endif

        /*
         * Raises an assertion dialog if the assertion is false.
         * 
         * @param assertion    The condition to assert.
         * @param message      A message to include in the debug display.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Assert(bool assertion, String message) {
#if DBG
            if (assertion == false) {
                if (DoAssert(assertion, message)) {
                    Break();
                }
            }
#endif
        }


        /*
         * Raises an assertion dialog if the assertion is false.
         * 
         * @param assertion    The condition to assert.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Assert(bool assertion) {
#if DBG
            if (assertion == false) {
                if (DoAssert(assertion, null)) {
                    Break();
                }
            }
#endif
        }

        /*
         * Is the debugging tag enabled?
         * 
         * @param tag   The tag name.
         */
        public static bool IsTagEnabled(String tag) {
#if DBG
            if (HttpRuntime.IsIsapiLoaded)
                return UnsafeNativeMethods.DBGNDIsTagEnabled(tag);
#endif
            return false;
        }

        /*
         * Is the debugging tag present?
         * 
         * @param tag   The tag name.
         */
        public static bool IsTagPresent(String tag) {
#if DBG
            if (HttpRuntime.IsIsapiLoaded)
                return UnsafeNativeMethods.DBGNDIsTagPresent(tag);
#endif
            return false;
        }

        /*
         * Breaks into cordbg.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Break() {
#if DBG
            if (!System.Diagnostics.Debugger.IsAttached) {
                System.Diagnostics.Debugger.Launch();
            }
            else {
                System.Diagnostics.Debugger.Break();            
            }
#endif
        }


        /*
         * Tells the debug system to always validate calls for a
         * particular tag. This is useful for temporarily enabling
         * validation in stress tests or other situations where you
         * may not have control over the debug tags that are enabled
         * on a particular machine.
         * 
         * @param tag   The tag name.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void AlwaysValidate(String tag) {
#if DBG
            s_tableAlwaysValidate[tag] = tag;
#endif
        }


        /*
         * Throws an exception if the assertion is not valid.
         * Use this function from a DebugValidate method where
         * you would otherwise use Assert.
         * 
         * @param assertion    The assertion.
         * @param message      Message to include if the assertion fails.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void CheckValid(bool assertion, string message) {
#if DBG
            if (!assertion) {
                throw new HttpException(message);
            }
#endif
        }


        /*
         * Cals DebugValidate on an object if such a method exists.
         * 
         * This method should be used from implementations of DebugValidate
         * where it is unknown whether an object has a DebugValidate method.
         * For example, the DoubleLink class uses it to validate the
         * item of type Object which it points to.
         * 
         * This method should NOT be used when code wants to conditionally
         * validate an object and have a failed validation caught in an assert.
         * Use Debug.Validate(tag, obj) for that purpose.
         * 
         * @param obj The object to validate. May be null.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Validate(Object obj) {
#if DBG
            Type        type;
            MethodInfo  mi;

            if (obj != null) {
                type = obj.GetType();

                mi = type.GetMethod(
                        "DebugValidate", 
                        BindingFlags.NonPublic | BindingFlags.Instance,
                        null,
                        s_ValidateArgs,
                        null);

                if (mi != null) {
                    object[] tempIndex = null;
                    mi.Invoke(obj, tempIndex);
                }
            }
#endif
        }

        /*
         * Validates an object is the "Validate" tag is enabled, or when
         * the "Validate" tag is not disabled and the given 'tag' is enabled.
         * An Assertion is made if the validation fails.
         * 
         * @param tag The tag to validate under.
         * @param obj The object to validate. May be null.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Validate(string tag, Object obj) {
#if DBG
            if (    obj != null 
                    && (    IsTagEnabled("Validate")
                            ||  (   !IsTagPresent("Validate") 
                                    && (   s_tableAlwaysValidate[tag] != null 
                                           ||  IsTagEnabled(tag))))) {
                try {
                    Debug.Validate(obj);
                }
                catch (Exception e) {
                    Debug.Assert(false, "Validate failed: " + e.InnerException.Message);
                }
            }
#endif
        }

#if DBG

        /*
         * Calls DebugDescription on an object to get its description. 
         * 
         * This method should only be used in implementations of DebugDescription
         * where it is not known whether a nested objects has an implementation
         * of DebugDescription. For example, the double linked list class uses
         * GetDescription to get the description of the item it points to.
         * 
         * This method should NOT be used when you want to conditionally 
         * dump an object. Use Debug.Dump instead.
         * 
         * @param obj      The object to call DebugDescription on. May be null.
         * @param indent   A prefix for each line in the description. This is used
         *                 to allow the nested display of objects within other objects.
         *                 The indent is usually a multiple of four spaces.
         * 
         * @return         The description.
         */
        public static string GetDescription(Object obj, string indent) {
            string      description;
            Type        type;
            MethodInfo  mi;
            Object[]   parameters;

            if (obj == null) {
                description = s_newline;
            }
            else {
                InternalSecurityPermissions.Reflection.Assert();
                try {
                    type = obj.GetType();
                    mi = type.GetMethod(
                            "DebugDescription", 
                            BindingFlags.NonPublic | BindingFlags.Instance,
                            null,
                            s_DumpArgs,
                            null);
                            
                    if (mi == null || mi.ReturnType != s_stringType) {
                        description = indent + obj.ToString();
                    }
                    else {
                        parameters = new Object[1] {(Object) indent};
                        description = (string) mi.Invoke(obj, parameters);
                    }
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }

            return description;
        }
#endif


        /*
         * Dumps an object to the debugger if the "Dump" tag is enabled,
         * or if the "Dump" tag is not present and the 'tag' is enabled.
         * 
         * @param tag  The tag to Dump with.
         * @param obj  The object to dump.
         */
        [System.Diagnostics.Conditional("DBG")]
        public static void Dump(string tag, Object obj) {
#if DBG
            string  description;
            string  traceTag = null;
            bool    dumpEnabled, dumpPresent;

            if (obj != null) {
                dumpEnabled = IsTagEnabled("Dump");
                dumpPresent = IsTagPresent("Dump");
                if (dumpEnabled || !dumpPresent) {
                    if (IsTagEnabled(tag)) {
                        traceTag = tag;
                    }
                    else if (dumpEnabled) {
                        traceTag = "Dump";
                    }

                    if (traceTag != null) {
                        description = GetDescription(obj, string.Empty);
                        Debug.Trace(traceTag, "Dump\n" + description);
                    }
                }
            }
#endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\profiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="Profiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Profiler.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.Util {

    using System;
    using System.Web;
    using System.Web.SessionState;
    using System.Web.UI;
    using System.Threading;
    using System.Collections;

    internal class Profiler {
        private int             _requestNum;
        private int             _requestsToProfile;
        private ArrayList      _requests;
        private bool            _pageOutput;
        private bool            _isEnabled; 
        private bool            _oldEnabled;   
        private bool            _localOnly;
        private TraceMode       _outputMode;


        internal Profiler() {
            _requestsToProfile = 10;
            _outputMode = TraceMode.SortByTime;
            _requestNum = 0;
            _localOnly = true;
        }

        internal /*public*/ bool IsEnabled {
            get { return _isEnabled;}
            set { 
               _isEnabled = value;
               _oldEnabled = value;
            }
        }

        internal /*public*/ bool PageOutput {
            get {  
                // calling HttpContext.Current is slow, but we'll only get there if _pageOutput is true.
                return (_pageOutput && !(_localOnly && !HttpContext.Current.Request.IsLocal));  
            }
            set { 
                _pageOutput = value;
            }
        }

        internal /*public*/ TraceMode OutputMode {
            get { return _outputMode;}
            set { _outputMode = value;}
        }

        internal /*public*/ bool LocalOnly {
            get { return _localOnly;}
            set { _localOnly = value; }
        }

        internal bool IsConfigEnabled { 
            get { return _oldEnabled; }
        }

        internal int RequestsToProfile {
            get { return _requestsToProfile;}
            set { _requestsToProfile = value;}
        }

        internal int RequestsRemaining {
            get { return _requestsToProfile - _requests.Count;}
        }

        internal void Reset() {
            // start profiling and clear the current log of requests
            _requests = new ArrayList();
            _requestNum = 0;

            if (_requestsToProfile != 0)
                _isEnabled = _oldEnabled;
            else 
                _isEnabled = false;
        }

        internal void StartRequest(HttpContext context) {
            context.Trace.VerifyStart();
        }

        internal void EndRequest(HttpContext context) {
            context.Trace.EndRequest();

            // grab trace data and add it to the list
            if (Interlocked.Increment(ref _requestNum) <= _requestsToProfile) {
                if (_requests == null)
                    _requests = new ArrayList();

                _requests.Add(context.Trace.GetData());
            }

            if (_requestNum >= _requestsToProfile)
                EndProfiling();
        }

        internal void EndProfiling() {
            _isEnabled = false;
        }

        internal ArrayList GetData() {
            return  _requests;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\readwritespinlock.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReadWriteSpinLock.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Web.Util {

using System.Threading;
using System.Collections;
using Microsoft.Win32;

struct ReadWriteSpinLock {
    // 
    // Fields
    // 

    //  _bits is layed out as follows:
    //
    //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    //  +-+-+---------------------------+--------------------------------+
    //  |S|W|          WriteLockCount   |           ReadLockCount        |
    //  +-+-+---------------------------+--------------------------------+
    //  where
    //
    //      S - sign bit (always zero) - By having a sign bit, operations 
    //      on the ReadLockCount can use InterlockedIncrement/Decrement
    //
    //      W - writer waiting bit - set by threads attempting write lock, preventing
    //          any further threads from acquiring read locks.  This attempts to hint
    //          that updates have priority, but doesn't guarantee priority.
    //
    //      WriteLockCount - Write lock recursion count
    //
    //      ReadLockCount - Read lock recursion count
    //
    int     _bits;
    int     _id;

    //
    // Statics
    //

    static bool s_disableBusyWaiting;

    // 
    // Constants
    // 

    const int BACK_OFF_FACTORS_LENGTH = 13;
    static readonly double [] s_backOffFactors = new double [BACK_OFF_FACTORS_LENGTH] {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010
    };

    const int WRITER_WAITING_MASK   = (int) 0x40000000;
    const int WRITE_COUNT_MASK      = (int) 0x3FFF0000;
    const int READ_COUNT_MASK       = (int) 0x0000FFFF;
    const int WRITER_WAITING_SHIFT  = 30;           
    const int WRITE_COUNT_SHIFT     = 16;           

    static bool WriterWaiting(int bits)             {return ((bits & WRITER_WAITING_MASK) != 0);}
    static int  WriteLockCount(int bits)            {return ((bits & WRITE_COUNT_MASK) >> WRITE_COUNT_SHIFT);}
    static int  ReadLockCount(int bits)             {return (bits & READ_COUNT_MASK);}
    static bool NoWriters(int bits)                 {return ((bits & WRITE_COUNT_MASK) == 0);}
    static bool NoWritersOrWaitingWriters(int bits) {return ((bits & (WRITE_COUNT_MASK | WRITER_WAITING_MASK)) == 0);}
    static bool NoLocks(int bits)                   {return ((bits & ~WRITER_WAITING_MASK) == 0);}

    bool        WriterWaiting()                     {return WriterWaiting(_bits);}             
    int         WriteLockCount()                    {return WriteLockCount(_bits);}            
    int         ReadLockCount()                     {return ReadLockCount(_bits);}             
    bool        NoWriters()                         {return NoWriters(_bits);}                 
    bool        NoWritersOrWaitingWriters()         {return NoWritersOrWaitingWriters(_bits);} 
    bool        NoLocks()                           {return NoLocks(_bits);}                   

    int CreateNewBits(bool writerWaiting, int writeCount, int readCount) {
        int bits = ((writeCount << WRITE_COUNT_SHIFT) | readCount);
        if (writerWaiting) {
            bits |= WRITER_WAITING_MASK;
        }

        return bits;
    }


    static ReadWriteSpinLock() {
        s_disableBusyWaiting = (SystemInfo.GetNumProcessCPUs() == 1);
    }


    internal ReadWriteSpinLock(string name) {
        _bits = 0;
        _id = 0;

    }

    internal void Dispose() {
    }

    internal /*public*/ void AcquireReaderLock() {

        // This lock supports Writelock then Readlock 
        // from the same thread (possibly from different functions).
        int threadId = Thread.CurrentThread.GetHashCode();

        // Optimize for the common case by 
        if (_TryAcquireReaderLock(threadId))
            return;

        _Spin(true, threadId);
        Debug.Trace("Spinlock", "AcquireReaderLock: _bits=" + _bits.ToString("x8") + " _id= " + _id.ToString("x8"));
    }


    internal /*public*/ void AcquireWriterLock() {

        int threadId = Thread.CurrentThread.GetHashCode();

        // Optimize for the common case by 
        if (_TryAcquireWriterLock(threadId))
            return;

        _Spin(false, threadId);

        Debug.Trace("Spinlock", "AcquireWriterLock: _bits=" + _bits.ToString("x8") + " _id= " + _id.ToString("x8"));
    }


    internal /*public*/ void ReleaseReaderLock() {
#if DBG 
        int id = _id;
        Debug.Assert(id == 0 || id == Thread.CurrentThread.GetHashCode(), "id == 0 || id == Thread.CurrentThread.GetHashCode()");
#endif

        int n = Interlocked.Decrement(ref _bits);

        Debug.Assert(n >= 0, "n >= 0");
        Debug.Trace("Spinlock", "ReleaseReaderLock: _bits=" + _bits.ToString("x8") + " _id= " + _id.ToString("x8"));
    }


    void AlterWriteCountHoldingWriterLock(int oldBits, int delta) {
        int readLockCount = ReadLockCount(oldBits);
        int oldWriteLockCount = WriteLockCount(oldBits);
        int newWriteLockCount = oldWriteLockCount + delta;
        Debug.Assert(newWriteLockCount >= 0, "newWriteLockCount >= 0");
        int newBits;
        int test;
    
        for (;;) {
            //
            // Since we own the lock, the only change that can be 
            // made by another thread to _bits is to add the writer-waiting bit.
            //
            Debug.Assert(WriteLockCount(oldBits) == oldWriteLockCount, "WriteLockCount(oldBits) == oldWriteLockCount");
            Debug.Assert(ReadLockCount(oldBits) == readLockCount, "ReadLockCount(oldBits) == readLockCount");
            newBits = CreateNewBits(WriterWaiting(oldBits), newWriteLockCount, readLockCount);
            test = Interlocked.CompareExchange(ref _bits, newBits, oldBits);
            if (test == oldBits) {
                break;
            }
    
            oldBits = test;
        }
    }
    
    internal /*public*/ void ReleaseWriterLock() {
#if DBG
        int id = _id;
        Debug.Assert(id == Thread.CurrentThread.GetHashCode(), "id == Thread.CurrentThread.GetHashCode()");
#endif
    
        int oldBits = _bits;
        int writeLockCount = WriteLockCount(oldBits);
        Debug.Assert(writeLockCount > 0, "writeLockCount > 0");
        if (writeLockCount == 1) {
            // Reset the id before releasing count so that
            // AcquireRead works correctly.
            _id = 0;
        }
    
        AlterWriteCountHoldingWriterLock(oldBits, -1);
        Debug.Trace("Spinlock", "ReleaseWriterLock: _bits=" + _bits.ToString("x8") + " _id= " + _id.ToString("x8"));
    }


    bool _TryAcquireWriterLock(int threadId) {
        int id = _id;
        int oldBits = _bits;
        int newBits;
        int test;

        if (id == threadId) {
            // we can just pound in the correct value
            AlterWriteCountHoldingWriterLock(oldBits, +1);
            return true;
        }

        if (id == 0 && NoLocks(oldBits)) {
            newBits = CreateNewBits(false, 1, 0);
            test = Interlocked.CompareExchange(ref _bits, newBits, oldBits);
            if (test == oldBits) {
                id = _id;
                Debug.Assert(id == 0);
                _id = threadId;

                return true;
            }

            oldBits = test;
        }

        // If there is contention, make sure the WRITER_WAITING bit is set.
        // Note: this blocks readers from using a value that is about to be changed
        if (!WriterWaiting(oldBits)) {
            // hammer on _bits until the bit is set
            for (;;) {
                newBits = (oldBits | WRITER_WAITING_MASK);
                test = Interlocked.CompareExchange(ref _bits, newBits, oldBits);
                if (test == oldBits)
                    break;

                oldBits = test;
            }
        }

        return false;
    }

    bool _TryAcquireReaderLock(int threadId) {
        int oldBits = _bits;
        int id = _id;

        if (id == 0) {
            if (!NoWriters(oldBits)) {
                return false;
            }
        }
        else if (id != threadId) {
            return false;
        }

        if (Interlocked.CompareExchange(ref _bits, oldBits + 1, oldBits) == oldBits) {
            return true;
        }

        return false;
    }


    /// <include file='doc\ReadWriteSpinLock.uex' path='docs/doc[@for="ReadWriteSpinLock._Spin"]/*' />
    /// <internalonly/>
    void _Spin(bool isReaderLock, int threadId) {

        const int LOCK_MAXIMUM_SPINS =      10000;    // maximum allowable spin count
        const int LOCK_DEFAULT_SPINS =       4000;    // default spin count
        const int LOCK_MINIMUM_SPINS =        100;    // minimum allowable spin count

        int sleepTime = 0;
        int baseSpins;

        {   // limit scope of temp. stack vars to calculation of baseSpin2

            // Alternatives for threadId include a static counter
            // or the low DWORD of QueryPerformanceCounter().
            double randomBackoffFactor = s_backOffFactors[threadId % BACK_OFF_FACTORS_LENGTH];
            baseSpins = (int)(LOCK_DEFAULT_SPINS * randomBackoffFactor);
            baseSpins = Math.Min(LOCK_MAXIMUM_SPINS, baseSpins);
            baseSpins = Math.Max(baseSpins, LOCK_MINIMUM_SPINS);
        }

        DateTime utcSpinStartTime = DateTime.UtcNow; // error if struct not initialized

        // hand-optimize loop: Increase locality by copying static variables 
        // onto the stack (this will reduce cache misses after a contact 
        // switch induced by Sleep()).
        bool disableBusyWaiting = s_disableBusyWaiting;

        for (;;) {
            if (isReaderLock) {
                if (_TryAcquireReaderLock(threadId)) {
                    break;
                }
            }
            else {
                if (_TryAcquireWriterLock(threadId)) {
                    break;
                }
            }

            // if 1 cpu, or cpu affinity is set to 1, spinning is a waste of time
            if (disableBusyWaiting) {

                Thread.Sleep(sleepTime);

                // Avoid priority inversion: 0, 1, 0, 1,...
                sleepTime ^= 1;
            }
            else {
                int spinCount = baseSpins;

                // Check no more than baseSpins times then yield.
                // It is important not to use the InterlockedExchange in the
                // inner loop in order to minimize system memory bus traffic.
                for(;;) {
                    //
                    // If the lock is available break spinning and 
                    // try to obtain it.
                    //
                    if (isReaderLock) {
                        if (NoWritersOrWaitingWriters()) {
                            break;
                        }
                    }
                    else {
                        if (NoLocks()) {
                            break;
                        }
                    }

                    if (--spinCount < 0) {

                        Thread.Sleep(sleepTime);

                        // Backoff algorithm: reduce (or increase) busy wait time
                        baseSpins /= 2;
                        // LOCK_MINIMUM_SPINS <= baseSpins <= LOCK_MAXIMUM_SPINS
                        //baseSpins = Math.Min(LOCK_MAXIMUM_SPINS, baseSpins); //= min(LOCK_MAXIMUM_SPINS, baseSpins)
                        baseSpins = Math.Max(baseSpins, LOCK_MINIMUM_SPINS); //= max(baseSpins, LOCK_MINIMUM_SPINS);
                        spinCount = baseSpins;

                        // Using Sleep(0) leads to the possibility of priority
                        // inversion.  Sleep(0) only yields the processor if
                        // there's another thread of the same priority that's
                        // ready to run.  If a high-priority thread is trying to
                        // acquire the lock, which is held by a low-priority
                        // thread, then the low-priority thread may never get
                        // scheduled and hence never free the lock.  NT attempts
                        // to avoid priority inversions by temporarily boosting
                        // the priority of low-priority runnable threads, but the
                        // problem can still occur if there's a medium-priority
                        // thread that's always runnable.  If Sleep(1) is used,
                        // then the thread unconditionally yields the CPU.  We
                        // only do this for the second and subsequent even
                        // iterations, since a millisecond is a long time to wait
                        // if the thread can be scheduled in again sooner
                        // (~100,000 instructions).
                        // Avoid priority inversion: 0, 1, 0, 1,...
                        sleepTime ^= 1;
                    }
                    else {
                        // kill about 20 clock cycles on this proc
                        Thread.SpinWait(10);
                    }
                }

            }
        }// while

    }// _Spin

} // ReadWriteSpinLock

} // namespace System.Web.Util

// NOTES:
//
// This ReaderWriterSpinlock is a combination of the 
// original lightweight (4 byte) System.Web.Util.ReadWriteSpinLock
// and the lightweight (4 byte) exclusive lock (SmallSpinLock) used 
// in the George Reilly's LKRHash (see http://georgere/work/lkrhash).
//
// In an effort to support reentrancy during writes we are squirreling 
// away the thread id of the thread holding the write lock into the upper 
// 16 bits of the lock count.  This is possible as long as thread ids stay
// smaller than 7FFF.  Anything higher than that would flip the sign bit
// and we'd no longer be able to do signed comparisons to check 
// for read vs. write.  
//
//          read            write
// lower    #read locks     #write locks (from same thread)
// higher   0x0000          thread id of thread holding lock
//
// Adapted from LKRHash's lock.cpp, from GeorgeRe
// The original implementation is due to PALarson.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\readwriteobjectlock.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReadWriteObjectLock.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * ReadWriteObjectLock
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {

    using System.Runtime.Serialization.Formatters;
    using System.Threading;

    class ReadWriteObjectLock {
        private int _lock;

        internal ReadWriteObjectLock() {
        }

        internal virtual void AcquireRead() {
            lock(this) {
                while (_lock == -1) {
                    try {
                        Monitor.Wait(this);
                    }
                    catch (ThreadInterruptedException) {
                        // Just keep looping
                    }
                }

                _lock++;
            }                   
        }

        internal virtual void ReleaseRead() {
            lock(this) {
                Debug.Assert(_lock > 0);

                _lock--;
                if (_lock == 0) {
                    Monitor.PulseAll(this);
                }
            }
        }

        internal virtual void AcquireWrite() {
            lock(this) {
                while (_lock != 0) {
                    try {
                        Monitor.Wait(this);
                    }
                    catch (ThreadInterruptedException) {
                        // Just keep looping
                    }
                }

                _lock = -1;
            }                   
        }

        internal virtual void ReleaseWrite() {
            lock(this) {
                Debug.Assert(_lock == -1);

                _lock = 0;
                Monitor.PulseAll(this);
            }
        }
/*
        internal virtual void AssertReadLock() {
#if DBG
            Debug.Assert(_lock > 0);
#endif
        }


        internal virtual void AssertWriteLock() {
#if DBG
            Debug.Assert(_lock == -1);
#endif
        }
*/
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\simplebitvector32.cs ===
//------------------------------------------------------------------------------
// <copyright file="SimpleBitVector32.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    using System;

    //
    // This is a cut down copy of System.Collections.Specialized.BitVector32. The
    // reason this is here is because it is used rather intensively by Control and
    // WebControl. As a result, being able to inline this operations results in a
    // measurable performance gain, at the expense of some maintainability.
    //
    internal struct SimpleBitVector32 {
        private int data;

        internal SimpleBitVector32(int data) {
            this.data = data;
        }

        internal /*public*/ bool this[int bit] {
            get {
                return (data & bit) == bit;
            }
            set {
                if (value) {
                    data |= bit;
                }
                else {
                    data &= ~bit;
                }
            }
        }

        internal /*public*/ int Data { get { return data; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\sec.cs ===
//------------------------------------------------------------------------------
// <copyright file="Sec.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Sec
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;


    internal class Sec {
        internal const int ONE_SECOND     = 1;            
        internal const int ONE_MINUTE     = ONE_SECOND * 60; 
        internal const int ONE_HOUR       = ONE_MINUTE * 60; 
        internal const int ONE_DAY        = ONE_HOUR * 24;   
        internal const int ONE_WEEK       = ONE_DAY * 7;     
        internal const int ONE_YEAR       = ONE_DAY * 365;
        internal const int ONE_LEAP_YEAR  = ONE_DAY * 366;

        private Sec() {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\symbolhashcodeprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="SymbolHashCodeProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    using System.Collections;
    using System.Globalization;  

    /// <include file='doc\SymbolHashCodeProvider.uex' path='docs/doc[@for="SymbolHashCodeProvider"]/*' />
    /// <devdoc>
    ///  <para> 
    ///    For internal use only. This provides case-insensitive hash code
    ///    for symbols and is not affected by the ambient culture.
    ///  </para>
    /// </devdoc>
    internal class SymbolHashCodeProvider: IHashCodeProvider {
        
        /// <include file='doc\SymbolHashCodeProvider.uex' path='docs/doc[@for="SymbolHashCodeProvider.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal static readonly IHashCodeProvider Default = new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture);

        internal SymbolHashCodeProvider() {
        }

        int IHashCodeProvider.GetHashCode(object key) {
            return Default.GetHashCode(key);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\systeminfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {

    class SystemInfo {
        static int  _trueNumberOfProcessors;

        private SystemInfo() {
        }

        static internal int GetNumProcessCPUs() {
            if (_trueNumberOfProcessors == 0) {
                UnsafeNativeMethods.SYSTEM_INFO si;
                UnsafeNativeMethods.GetSystemInfo(out si);

                if (si.dwNumberOfProcessors == 1) {
                    _trueNumberOfProcessors = 1;
                }
                else {
                    // KERNEL32.DLL:GetCurrentProcess() always returns -1 under NT
                    // Note: not really a handle (no need to CloseHandle())
                    IntPtr processHandle = UnsafeNativeMethods.INVALID_HANDLE_VALUE;
                    IntPtr processAffinityMask;
                    IntPtr systemAffinityMask;
                    int returnCode = UnsafeNativeMethods.GetProcessAffinityMask(
                            processHandle, out processAffinityMask, out systemAffinityMask);

                    if (returnCode == 0) {
                        _trueNumberOfProcessors = 1;
                    }
                    else {
                        // if cpu affinity is set to a single processor busy waiting is a waste of time
                        int numProcessors = 0;
                        if (IntPtr.Size == 4) {
                            uint mask = (uint) processAffinityMask;
                            for (; mask != 0; mask >>= 1) {
                                if ((mask & 1) == 1) {
                                    ++numProcessors;
                                }
                            }
                        }
                        else {
                            ulong mask = (ulong) processAffinityMask;
                            for (; mask != 0; mask >>= 1) {
                                if ((mask & 1) == 1) {
                                    ++numProcessors;
                                }
                            }
                        }

                        _trueNumberOfProcessors = numProcessors;
                    }
                }
            }

            Debug.Assert(_trueNumberOfProcessors > 0);
            return _trueNumberOfProcessors;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\sorteddoublelinklist.cs ===
//------------------------------------------------------------------------------
// <copyright file="SortedDoubleLinkList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * SortedDoubleLinkList
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;

    using System.Collections;

    /*
     * A sorted doubly linked list.
     */
    internal class SortedDoubleLinkList : DoubleLinkList {
        private IComparer   _comparer = Comparer.Default;

        internal /*public*/ SortedDoubleLinkList(IComparer comparer) {
            if (comparer != null) {
                _comparer = comparer;
            }
        }

        /*
         * Inserts an entry and keeps the list sorted.
         * 
         * @param entry
         */
        internal /*public*/ virtual void Insert(DoubleLink entry) {
            DoubleLink  l;

            for (l = _next; l != this; l = l._next) {
                if (_comparer.Compare(entry.Item, l.Item) <= 0)
                    break;
            }

            entry.InsertBefore(l);
        }

        internal /*public*/ override void InsertHead(DoubleLink entry) {
            throw new NotSupportedException();
        }
        internal /*public*/ override void InsertTail(DoubleLink entry) {
            throw new NotSupportedException();
        }

#if DBG
        internal /*public*/ override void DebugValidate() {
            DoubleLink  l1, l2;

            base.DebugValidate();
            l1 = Next;
            l2 = l1.Next;
            while (l2 != this) {
                Debug.CheckValid(_comparer.Compare(l1, l2) <= 0, "SortedDoubleLinkList is not sorted");

                l1 = l2;
                l2 = l2.Next;
            }
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\transactions.cs ===
//------------------------------------------------------------------------------
// <copyright file="Transactions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Transactions support for ASP.NET pages
 * 
 * Copyright (c) 2000, Microsoft Corporation
 */
namespace System.Web.Util {

using System.Collections;
using System.EnterpriseServices;
using System.Security.Permissions;

//
//  Delegate to the transacted managed code
//

/// <include file='doc\Transactions.uex' path='docs/doc[@for="TransactedCallback"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public delegate void TransactedCallback();

//
//  Delegate for the internal transacted execution
//

internal enum TransactedExecState {
    CommitPending = 0,
    AbortPending = 1,
    Error = 2
}

internal delegate int TransactedExecCallback();  // return value 'int' for interop

//
//  Utility class with to be called to do transactions
//

/// <include file='doc\Transactions.uex' path='docs/doc[@for="Transactions"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class Transactions {
    /// <include file='doc\Transactions.uex' path='docs/doc[@for="Transactions.InvokeTransacted"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static void InvokeTransacted(TransactedCallback callback, TransactionOption mode) {
        bool aborted = false;
        InvokeTransacted(callback, mode, ref aborted);
    }

    /// <include file='doc\Transactions.uex' path='docs/doc[@for="Transactions.InvokeTransacted1"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static void InvokeTransacted(TransactedCallback callback, TransactionOption mode, ref bool transactionAborted) {
        // check for hosting permission even if no user code on the stack
        HttpRuntime.CheckAspNetHostingPermission(AspNetHostingPermissionLevel.Medium, SR.Transaction_not_supported_in_low_trust);

        bool executeWithoutTransaction = false;

        if (Environment.OSVersion.Platform != PlatformID.Win32NT || Environment.OSVersion.Version.Major <= 4)
            throw new PlatformNotSupportedException(SR.GetString(SR.RequiresNT));

        if (mode == TransactionOption.Disabled)
            executeWithoutTransaction = true;

        if (executeWithoutTransaction) {
            // bypass the transaction logic
            callback();
            transactionAborted = false;
            return;
        }

        TransactedInvocation call = new TransactedInvocation(callback);
        TransactedExecCallback execCallback = new TransactedExecCallback(call.ExecuteTransactedCode);

        PerfCounters.IncrementCounter(AppPerfCounter.TRANSACTIONS_PENDING);

        int rc;
        try {
            rc = UnsafeNativeMethods.TransactManagedCallback(execCallback, (int)mode);
        }
        finally {
            PerfCounters.DecrementCounter(AppPerfCounter.TRANSACTIONS_PENDING);
        }

        // rethrow the expection originally caught in managed code
        if (call.Error != null)
            throw new HttpException(null, call.Error); 

        PerfCounters.IncrementCounter(AppPerfCounter.TRANSACTIONS_TOTAL);

        if (rc == 1) {
            PerfCounters.IncrementCounter(AppPerfCounter.TRANSACTIONS_COMMITTED);
            transactionAborted = false;
        }
        else if (rc == 0) {
            PerfCounters.IncrementCounter(AppPerfCounter.TRANSACTIONS_ABORTED);
            transactionAborted = true;
        }
        else {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_execute_transacted_code));
        }
    }

    // Class with wrappers to ContextUtil that don't throw

    internal class Utils {
        private Utils() {
        }

        /*
        internal static String TransactionId {
            get {
                String id = null;

                try {
                    id = ContextUtil.TransactionId.ToString();
                }
                catch {
                }

                return id;
            }
        }
        */

        internal static bool IsInTransaction {
            get {
                bool inTransaction = false;

                try {
                    inTransaction = ContextUtil.IsInTransaction;
                }
                catch {
                }

                return inTransaction;
            }
        }

        internal static bool AbortPending {
            get {
                bool aborted = false;

                try {
                    if (ContextUtil.MyTransactionVote == TransactionVote.Abort)
                        aborted = true;
                }
                catch {
                }

                return aborted;
            }
        }
    }

    // Managed class encapsulating the transacted call

    internal class TransactedInvocation {
        private TransactedCallback _callback;
        private Exception _error;

        internal TransactedInvocation(TransactedCallback callback) {
            _callback = callback;
        }

        internal int ExecuteTransactedCode() {
            TransactedExecState state = TransactedExecState.CommitPending;

            try {
                _callback();

                if (Transactions.Utils.AbortPending)
                    state = TransactedExecState.AbortPending;
            }
            catch (Exception e) {
                _error = e;  // remember exception to be rethrown back in managed code
                state = TransactedExecState.Error;
            }

            return (int)state;
        }

        internal Exception Error {
            get { return _error; }
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\symbolequalcomparer.cs ===
//------------------------------------------------------------------------------
// <copyright file="SymbolEqualComparer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {
    using System.Collections;
    using System.Globalization;  

    /// <include file='doc\SymbolEqualComparer.uex' path='docs/doc[@for="SymbolEqualComparer"]/*' />
    /// <devdoc>
    ///  <para> 
    ///    For internal use only. This implements a comparison that only 
    ///    checks for equalilty, so this should only be used in un-sorted data
    ///    structures like Hastable and ListDictionary. This is a little faster
    ///    than using CaseInsensitiveComparer because it does a strict character by 
    ///    character equality chech rather than a sorted comparison.
    ///  </para>
    /// </devdoc>
    internal class SymbolEqualComparer: IComparer {

        /// <include file='doc\SymbolEqualComparer.uex' path='docs/doc[@for="SymbolEqualComparer.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal static readonly IComparer Default = new SymbolEqualComparer();

        internal SymbolEqualComparer() {
        }

        int IComparer.Compare(object keyLeft, object keyRight) {

            string sLeft = keyLeft as string;
            string sRight = keyRight as string;
            if (sLeft == null) {
                throw new ArgumentNullException("keyLeft");
            }
            if (sRight == null) {
                throw new ArgumentNullException("keyRight");
            }
            int lLeft = sLeft.Length;
            int lRight = sRight.Length;
            if (lLeft != lRight) {
                return 1;
            }
            for (int i = 0; i < lLeft; i++) {
                char charLeft = sLeft[i];
                char charRight = sRight[i];
                if (charLeft == charRight) {
                    continue;
                }
                UnicodeCategory catLeft = Char.GetUnicodeCategory(charLeft);
                UnicodeCategory catRight = Char.GetUnicodeCategory(charRight);
                if (catLeft == UnicodeCategory.UppercaseLetter 
                    && catRight == UnicodeCategory.LowercaseLetter) {
                    if (Char.ToLower(charLeft, CultureInfo.InvariantCulture) == charRight) {
                        continue;
                    }
                } else if (catRight == UnicodeCategory.UppercaseLetter 
                    && catLeft == UnicodeCategory.LowercaseLetter){
                    if (Char.ToLower(charRight, CultureInfo.InvariantCulture) == charLeft) {
                        continue;
                    }
                }
                return 1;
            }
            return 0;        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\smtpmail.cs ===
//------------------------------------------------------------------------------
// <copyright file="SmtpMail.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Simple SMTP send mail utility
 * 
 * Copyright (c) 2000, Microsoft Corporation
 */
namespace System.Web.Mail {
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Security.Permissions;

/*
 * Class that sends MailMessage using CDONTS/CDOSYS
 */
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class SmtpMail {

    private SmtpMail() {
    }

    //
    // Late bound helper
    //

    internal class LateBoundAccessHelper {
        private String _progId;
        private Type _type;

        internal LateBoundAccessHelper(String progId) {
            _progId = progId;
        }

        private Type LateBoundType {
            get {
                if (_type == null) {
                    try {
                        _type = Type.GetTypeFromProgID(_progId); 
                    }
                    catch {
                    }

                    if (_type == null)
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Could_not_create_object, _progId));
                }

                return _type;
            }
        }

        internal Object CreateInstance() {
            return Activator.CreateInstance(LateBoundType);
        }

        internal Object CallMethod(Object obj, String methodName, Object[] args) {
            try {
                return CallMethod(LateBoundType, obj, methodName, args);
            }
            catch (Exception e) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Could_not_access_object, _progId), e);
            }
        }

        internal static Object CallMethodStatic(Object obj, String methodName, Object[] args) {
            return CallMethod(obj.GetType(), obj, methodName, args);
        }

        private static Object CallMethod(Type type, Object obj, String methodName, Object[] args) {
            return type.InvokeMember(methodName, BindingFlags.InvokeMethod, null, obj, args);
        }

        internal Object GetProp(Object obj, String propName) {
            try {
                return GetProp(LateBoundType, obj, propName);
            }
            catch (Exception e) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Could_not_access_object, _progId), e);
            }
        }

        internal static Object GetPropStatic(Object obj, String propName) {
            return GetProp(obj.GetType(), obj, propName);
        }

        private static Object GetProp(Type type, Object obj, String propName) {
            return type.InvokeMember(propName, BindingFlags.GetProperty, null, obj,new Object[0]);
        }

        internal void SetProp(Object obj, String propName, Object propValue) {
            try {
                SetProp(LateBoundType, obj, propName, propValue);
            }
            catch (Exception e) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Could_not_access_object, _progId), e);
            }
        }

        internal static void SetPropStatic(Object obj, String propName, Object propValue) {
            SetProp(obj.GetType(), obj, propName, propValue);
        }

        private static void SetProp(Type type, Object obj, String propName, Object propValue) {
            type.InvokeMember(propName, BindingFlags.SetProperty, null, obj, new Object[1] { propValue });
        }

        internal void SetProp(Object obj, String propName, Object propKey, Object propValue) {
            try {
                SetProp(LateBoundType, obj, propName, propKey, propValue);
            }
            catch (Exception e) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Could_not_access_object, _progId), e);
            }
        }

        internal static void SetPropStatic(Object obj, String propName, Object propKey, Object propValue) {
            SetProp(obj.GetType(), obj, propName, propKey, propValue);
        }

        private static void SetProp(Type type, Object obj, String propName, Object propKey, Object propValue) {
            type.InvokeMember(propName, BindingFlags.SetProperty, null, obj,new Object[2] { propKey, propValue });
        }
    }

    //
    // Late bound access to CDONTS
    //

    internal class CdoNtsHelper {

        private static LateBoundAccessHelper _helper = new LateBoundAccessHelper("CDONTS.NewMail");

        private CdoNtsHelper() {
        }

        internal static void Send(MailMessage message) {
            // create mail object
            Object newMail = _helper.CreateInstance();

            // set properties

            if (message.From != null)
                _helper.SetProp(newMail, "From", message.From);

            if (message.To != null)
                _helper.SetProp(newMail, "To", message.To);

            if (message.Cc != null)
                _helper.SetProp(newMail, "Cc", message.Cc);

            if (message.Bcc != null)
                _helper.SetProp(newMail, "Bcc", message.Bcc);

            if (message.Subject != null)
                _helper.SetProp(newMail, "Subject", message.Subject);

            if (message.Priority != MailPriority.Normal) {
                int p = 0;
                switch (message.Priority) {
                case MailPriority.Low:      p = 0;  break;
                case MailPriority.Normal:   p = 1;  break;
                case MailPriority.High:     p = 2;  break;
                }
                _helper.SetProp(newMail, "Importance", p);
            }

            if (message.BodyEncoding != null)
                _helper.CallMethod(newMail, "SetLocaleIDs", new Object[1] { message.BodyEncoding.CodePage });

            if (message.UrlContentBase != null)
                _helper.SetProp(newMail, "ContentBase", message.UrlContentBase);

            if (message.UrlContentLocation != null)
                _helper.SetProp(newMail, "ContentLocation", message.UrlContentLocation);

            int numHeaders = message.Headers.Count;
            if (numHeaders > 0) {
                IDictionaryEnumerator e = message.Headers.GetEnumerator();
                while (e.MoveNext()) {
                    String k = (String)e.Key;
                    String v = (String)e.Value;
                    _helper.SetProp(newMail, "Value", k, v);
                }
            }

            if (message.BodyFormat == MailFormat.Html) {
                _helper.SetProp(newMail, "BodyFormat", 0);
                _helper.SetProp(newMail, "MailFormat", 0);
            }

            if (message.Body != null)
                _helper.SetProp(newMail, "Body", message.Body);

            for (IEnumerator e = message.Attachments.GetEnumerator(); e.MoveNext(); ) {
                MailAttachment a = (MailAttachment)e.Current;

                int c = 0;
                switch (a.Encoding) {
                case MailEncoding.UUEncode: c = 0;  break;
                case MailEncoding.Base64:   c = 1;  break;
                }

                _helper.CallMethod(newMail, "AttachFile", new Object[3] { a.Filename, null, (Object)c });
            }

            // send mail
            _helper.CallMethod(newMail, "Send", new Object[5] { null, null, null, null, null });

            // close unmanaged COM classic component
            Marshal.ReleaseComObject(newMail);
        }

        internal static void Send(String from, String to, String subject, String messageText) {
            Object newMail = _helper.CreateInstance();
            _helper.CallMethod(newMail, "Send", new Object[5] { from, to, subject, messageText, (Object)1 });
            Marshal.ReleaseComObject(newMail);
        }
    }

    //
    // Late bound access to CDOSYS
    //

    internal class CdoSysHelper {

        private static LateBoundAccessHelper _helper = new LateBoundAccessHelper("CDO.Message");

        private CdoSysHelper() {
        }

        private static void SetField(Object m, String name, String value) {
            _helper.SetProp(m, "Fields", "urn:schemas:mailheader:" + name, value);
            Object fields = _helper.GetProp(m, "Fields");
            LateBoundAccessHelper.CallMethodStatic(fields, "Update", new Object[0]);
            Marshal.ReleaseComObject(fields);
        }

        internal static void Send(MailMessage message) {
            // create message object
            Object m = _helper.CreateInstance();

            // set properties

            if (message.From != null)
                _helper.SetProp(m, "From", message.From);

            if (message.To != null)
                _helper.SetProp(m, "To", message.To);

            if (message.Cc != null)
                _helper.SetProp(m, "Cc", message.Cc);

            if (message.Bcc != null)
                _helper.SetProp(m, "Bcc", message.Bcc);

            if (message.Subject != null)
                _helper.SetProp(m, "Subject", message.Subject);


            if (message.Priority != MailPriority.Normal) {
                String importance = null;
                switch (message.Priority) {
                case MailPriority.Low:      importance = "low";     break;
                case MailPriority.Normal:   importance = "normal";  break;
                case MailPriority.High:     importance = "high";    break;
                }

                if (importance != null)
                    SetField(m, "importance", importance);
            }

            if (message.BodyEncoding != null) {
                Object body = _helper.GetProp(m, "BodyPart");
                LateBoundAccessHelper.SetPropStatic(body, "Charset", message.BodyEncoding.BodyName);
                Marshal.ReleaseComObject(body);
            }

            if (message.UrlContentBase != null)
                SetField(m, "content-base", message.UrlContentBase);

            if (message.UrlContentLocation != null)
                SetField(m, "content-location", message.UrlContentLocation);

            int numHeaders = message.Headers.Count;
            if (numHeaders > 0) {
                IDictionaryEnumerator e = message.Headers.GetEnumerator();
                while (e.MoveNext()) {
                    SetField(m, (String)e.Key, (String)e.Value);
                }
            }

            if (message.Body != null) {
                if (message.BodyFormat == MailFormat.Html) {
                    _helper.SetProp(m, "HtmlBody", message.Body);
                }
                else {
                    _helper.SetProp(m, "TextBody", message.Body);
                }
            }

            for (IEnumerator e = message.Attachments.GetEnumerator(); e.MoveNext(); ) {
                MailAttachment a = (MailAttachment)e.Current;
                Object bodyPart = _helper.CallMethod(m, "AddAttachment", new Object[3] { a.Filename, null, null });

                if (a.Encoding == MailEncoding.UUEncode)
                    _helper.SetProp(m, "MimeFormatted", false);

                if (bodyPart != null)
                    Marshal.ReleaseComObject(bodyPart);
            }

            // optional SMTP server
            String server = SmtpMail.SmtpServer;
            if (server.Length == 0)
                server = null;

            if (server != null || message.Fields.Count > 0) {
                Object config = LateBoundAccessHelper.GetPropStatic(m, "Configuration");

                if (config != null) {
                    if (server != null) {
                        LateBoundAccessHelper.SetPropStatic(config, "Fields", "http://schemas.microsoft.com/cdo/configuration/sendusing", (Object)2);
                        LateBoundAccessHelper.SetPropStatic(config, "Fields", "http://schemas.microsoft.com/cdo/configuration/smtpserver", server);
                        LateBoundAccessHelper.SetPropStatic(config, "Fields", "http://schemas.microsoft.com/cdo/configuration/smtpserverport", (Object)25);
                    }

                    foreach (DictionaryEntry e in message.Fields) {
                        LateBoundAccessHelper.SetPropStatic(config, "Fields", (String)e.Key, e.Value);
                    }
                   
                    Object fields = LateBoundAccessHelper.GetPropStatic(config, "Fields");
                    LateBoundAccessHelper.CallMethodStatic(fields, "Update", new Object[0]);
                    Marshal.ReleaseComObject(fields);

                    Marshal.ReleaseComObject(config);
                }
            }

            // send mail
            _helper.CallMethod(m, "Send", new Object[0]);

            // close unmanaged COM classic component
            Marshal.ReleaseComObject(m);
        }

        internal static void Send(String from, String to, String subject, String messageText) {
            MailMessage m = new MailMessage();
            m.From = from;
            m.To = to;
            m.Subject = subject;
            m.Body = messageText;
            Send(m);
        }
    }

    private static String _server;

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.SmtpServer"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static String SmtpServer {
        get {
            String s = _server;
            return (s != null) ? s : String.Empty; 
        }

        set {
            _server = value; 
        }
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.Send"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static void Send(String from, String to, String subject, String messageText) {
        InternalSecurityPermissions.AspNetHostingPermissionLevelMedium.Demand();
        InternalSecurityPermissions.UnmanagedCode.Assert();

        lock (typeof(SmtpMail)) {
            if (Environment.OSVersion.Platform != PlatformID.Win32NT) {
                throw new PlatformNotSupportedException(SR.GetString(SR.RequiresNT));
            }
            else if (Environment.OSVersion.Version.Major <= 4) {
                CdoNtsHelper.Send(from, to, subject, messageText);
            }
            else {
                CdoSysHelper.Send(from, to, subject, messageText);
            }
        }
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.Send1"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static void Send(MailMessage message) {
        InternalSecurityPermissions.AspNetHostingPermissionLevelMedium.Demand();
        InternalSecurityPermissions.UnmanagedCode.Assert();

        lock (typeof(SmtpMail)) {
            if (Environment.OSVersion.Platform != PlatformID.Win32NT) {
                throw new PlatformNotSupportedException(SR.GetString(SR.RequiresNT));
            }
            else if (Environment.OSVersion.Version.Major <= 4) {
                CdoNtsHelper.Send(message);
            }
            else {
                CdoSysHelper.Send(message);
            }
        }
    }
}

//
// Enums for message elements
//

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public enum MailFormat {
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat.Text"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Text = 0,       // note - different from CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat.Html"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Html = 1
}

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public enum MailPriority {
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.Normal"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Normal = 0,     // note - different from CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.Low"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Low = 1,
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.High"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    High = 2
}

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public enum MailEncoding {
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding.UUEncode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    UUEncode = 0,   // note - same as CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding.Base64"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Base64 = 1
}

/*
 * Immutable struct that holds a single attachment
 */
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class MailAttachment {
    private String _filename;
    private MailEncoding _encoding;

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.Filename"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public String Filename { get { return _filename; } }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.Encoding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MailEncoding Encoding { get { return _encoding; } }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.MailAttachment"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MailAttachment(String filename)
    {
        _filename = filename;
        _encoding = MailEncoding.Base64;
        VerifyFile();
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.MailAttachment1"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MailAttachment(String filename, MailEncoding encoding)
    {
        _filename = filename;
        _encoding = encoding;
        VerifyFile();
    }

    private void VerifyFile() {
        try {
            File.Open(_filename, FileMode.Open, FileAccess.Read,  FileShare.Read).Close();
        }
        catch {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Bad_attachment, _filename));
        }
    }
}

/*
 * Struct that holds a single message
 */
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class MailMessage {
    Hashtable _headers = new Hashtable();
    Hashtable _fields = new Hashtable();
    ArrayList _attachments = new ArrayList();

    string from;
    string to;
    string cc;
    string bcc;
    string subject;
    MailPriority priority = MailPriority.Normal;
    string urlContentBase;
    string urlContentLocation;
    string body;
    MailFormat bodyFormat = MailFormat.Text;
    Encoding bodyEncoding = Encoding.Default;
    

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.From"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string From {
        get {
            return from;
        }
        set {
            from = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.To"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string To {
        get {
            return to;
        }
        set {
            to = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Cc"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string Cc {
        get {
            return cc;
        }
        set {
            cc = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Bcc"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string Bcc {
        get {
            return bcc;
        }
        set {
            bcc = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Subject"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string Subject {
        get {
            return subject;
        }
        set {
            subject = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Priority"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MailPriority Priority {
        get {
            return priority;
        }
        set {
            priority = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.UrlContentBase"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string UrlContentBase {
        get {
            return urlContentBase;
        }
        set {
            urlContentBase = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.UrlContentLocation"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string UrlContentLocation {
        get {
            return urlContentLocation;
        }
        set {
            urlContentLocation = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Body"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string Body {
        get {
            return body;
        }
        set {
            body = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.BodyFormat"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public MailFormat BodyFormat {
        get {
            return bodyFormat;
        }
        set {
            bodyFormat = value;
        }
    }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.BodyEncoding"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public Encoding BodyEncoding {
        get {
            return bodyEncoding;
        }
        set {
            bodyEncoding = value;
        }
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Headers"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public IDictionary  Headers { get { return _headers; } }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Fields"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public IDictionary  Fields { get { return _fields; } }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Attachments"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public IList        Attachments { get { return _attachments; } }
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\versioninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="versioninfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Support for getting file versions
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Util {
    using System.Diagnostics;
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Configuration.Assemblies;

    //
    // Support for getting file version of relevant files
    //

    internal class VersionInfo {
        static private string _systemWebVersion;
        static private string _isapiVersion;
        static private string _mscoreeVersion;
        static private string _lock = "lock";

        private VersionInfo() {
        }

        internal static string GetFileVersion(String filename) {
            try {
                return FileVersionInfo.GetVersionInfo(filename).FileVersion;
            }
            catch {
                return String.Empty;
            }
        }

        internal static string GetLoadedModuleFileName(string module) {
            IntPtr h = UnsafeNativeMethods.GetModuleHandle(module);
            if (h == (IntPtr)0)
                return null;

            StringBuilder buf = new StringBuilder(256);
            if (UnsafeNativeMethods.GetModuleFileName(h, buf, 256) == 0)
                return null;

            String fileName = buf.ToString();
            if (fileName.StartsWith("\\\\?\\")) // on Whistler GetModuleFileName migth return this
                fileName = fileName.Substring(4);
            return fileName;
        }

        internal static string GetLoadedModuleVersion(string module) {
            String filename = GetLoadedModuleFileName(module);
            if (filename == null)
                return null;
            return GetFileVersion(filename);
        }

        internal static string SystemWebVersion {
            get {
                if (_systemWebVersion == null) {
                    lock(_lock) {
                        if (_systemWebVersion == null)
                            _systemWebVersion = GetFileVersion(typeof(HttpRuntime).Module.FullyQualifiedName);
                    }
                }

                return _systemWebVersion;
            }
        }

        internal static string IsapiVersion {
            get {
                if (_isapiVersion == null) {
                    lock(_lock) {
                        if (_isapiVersion == null)
                            _isapiVersion = GetLoadedModuleVersion(ModName.ISAPI_FULL_NAME);
                    }
                }

                return _isapiVersion;
            }
        }

        internal static string ClrVersion {
            get {
                if (_mscoreeVersion == null) {
                    lock(_lock) {
                        if (_mscoreeVersion == null)
                            _mscoreeVersion = GetLoadedModuleVersion("MSCORLIB.DLL");
                    }
                }

                return _mscoreeVersion;
            }
        }
    }

    //
    // Support for getting OS Flavor
    //

    internal enum OsFlavor {
        Undetermined,
        Other,
        WebBlade,
        StdServer,
        AdvServer,
        DataCenter,
    }

    internal class OsVersionInfo {
        private const UInt32 VER_NT_WORKSTATION         = 0x0000001;
        private const UInt32 VER_NT_DOMAIN_CONTROLLER   = 0x0000002;
        private const UInt32 VER_NT_SERVER              = 0x0000003;
        private const UInt32 VER_SUITE_ENTERPRISE       = 0x00000002;
        private const UInt32 VER_SUITE_DATACENTER       = 0x00000080;
        private const UInt32 VER_SUITE_PERSONAL         = 0x00000200;
        private const UInt32 VER_SUITE_BLADE            = 0x00000400;

        internal static OsFlavor s_osFlavor = OsFlavor.Undetermined;

        private OsVersionInfo() {
        }

        internal static OsFlavor CurrentOsFlavor {
            get {
                if (s_osFlavor == OsFlavor.Undetermined) {
                    UnsafeNativeMethods.OSVERSIONINFOEX x = new UnsafeNativeMethods.OSVERSIONINFOEX();
                    if (UnsafeNativeMethods.GetVersionEx(x)) {
                        UInt32 product = (UInt32)x.wProductType;
                        UInt32 suite = (UInt32)x.wSuiteMask;

                        if (product == VER_NT_SERVER || product == VER_NT_DOMAIN_CONTROLLER) {
                            if ((suite&VER_SUITE_BLADE) != 0)
                                s_osFlavor = OsFlavor.WebBlade;
                            else if ((suite&VER_SUITE_ENTERPRISE) != 0)
                                s_osFlavor = OsFlavor.AdvServer;
                            else if ((suite&VER_SUITE_DATACENTER) != 0)
                                s_osFlavor = OsFlavor.DataCenter;
                            else
                                s_osFlavor = OsFlavor.StdServer;
                        }
                        else {
                           s_osFlavor = OsFlavor.Other;
                        }
                    }
                }

                return s_osFlavor;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\urlpath.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlPath.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * UrlPath class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Util {
using System.Text;
using System.Runtime.Serialization.Formatters;
using System.Runtime.InteropServices;
using System.Collections;
using System.IO;

/*
 * Code to perform Url path combining
 */
internal class UrlPath {

    private const char appRelativeCharacter = '~';

    private UrlPath() {
    }

    internal static bool IsRooted(String basepath) {
        return(basepath == null || basepath.Length == 0 || basepath[0] == '/' || basepath[0] == '\\');
    }

    internal static bool IsRelativeUrl(string url) {
        // If it has a protocol, it's not relative
        if (url.IndexOf(":") != -1)
            return false;

        return !IsRooted(url);
    }

    internal static bool IsAppRelativePath(string path) {
        return (path.Length >= 1 && path[0] == appRelativeCharacter);
    }

    internal static bool IsValidVirtualPathWithoutProtocol(string path) {
        if (path == null)
            return false;
        if (path.IndexOf(":") != -1)
            return false;
        return true;
    }

    internal static String GetDirectory(String path) {
        if (path == null || path.Length == 0)
            throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Empty_path_has_no_directory));

        if (path[0] != '/')
            throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Path_must_be_rooted));

        // Make sure there is a filename after the last '/'
        Debug.Assert(path[path.Length-1] != '/', "Path should not end with a /");

        string dir = path.Substring(0, path.LastIndexOf('/'));

        // If it's the root dir, we would end up with "".  Return "/" instead
        if (dir.Length == 0)
            return "/";

        return dir;
    }

    private static void FailIfPhysicalPath(string path) {
        if (path == null || path.Length < 4)
            return;

        if (path[1] == ':' || (path[0] == '\\' && path[1] == '\\')) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Physical_path_not_allowed, path));
        }
    }

    internal static String Combine(String basepath, String relative) {
        String path;

        // Make sure the relative path is not a physical path (ASURT 73641)
        FailIfPhysicalPath(relative);

        if (IsRooted(relative)) {
            path = relative;
            if (path == null || path.Length == 0)
                return String.Empty;
        }
        else {

            string appPath = HttpRuntime.AppDomainAppVirtualPath;

            // If the path is exactly "~", just return the app root path
            if (relative.Length == 1 && relative[0] == appRelativeCharacter)
                return appPath;

            // If the relative path starts with "~/" or "~\", treat it as app root
            // relative (ASURT 68628)
            if (relative.Length >=2 && relative[0] == appRelativeCharacter && (relative[1] == '/' || relative[1] == '\\')) {
                if (appPath.Length > 1)
                    path = appPath + "/" + relative.Substring(2);
                else
                    path = "/" + relative.Substring(2);
            }
            else {

                if (basepath == null || (basepath.Length == 1 && basepath[0] == '/'))
                    basepath = String.Empty;

                path = basepath + "/" + relative;
            }
        }

        return Reduce(path);
    }

    internal static String Reduce(String path) {
        // ignore query string
        String queryString = null;
        if (path != null) {
            int iqs = path.IndexOf('?');
            if (iqs >= 0) {
                queryString = path.Substring(iqs);
                path = path.Substring(0, iqs);
            }
        }

        int length = path.Length;
        int examine;

        // Make sure we don't have any back slashes
        path = path.Replace('\\', '/');

        // quickly rule out situations in which there are no . or ..

        for (examine = 0; ; examine++) {
            examine = path.IndexOf('.', examine);
            if (examine < 0)
                return (queryString != null) ? (path + queryString) : path;

            if ((examine == 0 || path[examine - 1] == '/')
                && (examine + 1 == length || path[examine + 1] == '/' ||
                    (path[examine + 1] == '.' && (examine + 2 == length || path[examine + 2] == '/'))))
                break;
        }

        // OK, we found a . or .. so process it:

        ArrayList list = new ArrayList();
        StringBuilder sb = new StringBuilder();
        int start;
        examine = 0;

        for (;;) {
            start = examine;
            examine = path.IndexOf('/', start + 1);

            if (examine < 0)
                examine = length;

            if (examine - start <= 3 &&
                (examine < 1 || path[examine - 1] == '.') &&
                (start + 1 >= length || path[start + 1] == '.')) {
                if (examine - start == 3) {
                    if (list.Count == 0)
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_exit_up_top_directory));

                    sb.Length = (int)list[list.Count - 1];
                    list.RemoveRange(list.Count - 1, 1);
                }
            }
            else {
                list.Add(sb.Length);

                sb.Append(path, start, examine - start);
            }

            if (examine == length)
                break;
        }

        return sb.ToString() + queryString;
    }

    private const string dummyProtocolAndServer = "http://foo";

    // Return the relative vpath path from one rooted vpath to another
    internal static string MakeRelative(string from, string to) {
        
        // Make sure both virtual paths are rooted
        Debug.Assert(IsRooted(from));
        Debug.Assert(IsRooted(to));

        // Uri's need full url's so, we use a dummy root
        Uri fromUri = new Uri(dummyProtocolAndServer + from, true /*dontEscape*/);
        Uri toUri = new Uri(dummyProtocolAndServer + to, true /*dontEscape*/);

        string relativePath = fromUri.MakeRelative(toUri);

        // Note that we need to re-append the query string and fragment (e.g. #anchor)
        return relativePath + toUri.Query + toUri.Fragment;
    }

    internal static bool IsAbsolutePhysicalPath(string path) {
        if (path == null || path.Length < 3)
            return false;

        if (path.StartsWith("\\\\"))
            return true;

        return (Char.IsLetter(path[0]) && path[1] == ':' && path[2] == '\\');
    }

    internal static string GetDirectoryOrRootName(string path) {
        string dir;

        dir = Path.GetDirectoryName(path);
        if (dir == null) {
            dir = Path.GetPathRoot(path);
        }

        return dir;
    }

    internal static string GetFileName(string path) {
        // The physical file implementation works fine for virtual
        return Path.GetFileName(path);
    }
    
    internal static string AppendSlashToPathIfNeeded(string path) {

        if (path == null) return null;

        int l = path.Length;
        if (l == 0) return path;
        
        if (path[l-1] != '/')
            path += '/';
        
        return path;
    }
}


/*
 * Wrappers around IO functions that consume bogus exceptions
 */
internal class FileUtil {

    private FileUtil() {
    }

    internal static bool FileExists(String filename) {
        bool exists = false;

        try {
            exists = File.Exists(filename);
        }
        catch {
        }

        return exists;
    }

    private static String GetNormalizedDirectoryName(String dirname) {
        if (dirname != null && dirname.Length > 3 && dirname[dirname.Length-1] == '\\')
            dirname = dirname.Substring(0, dirname.Length-1);
        return dirname;
    }

    internal static bool DirectoryExists(String dirname) {
        bool exists = false;
        dirname = GetNormalizedDirectoryName(dirname);

        try {
            exists = Directory.Exists(dirname);
        }
        catch {
        }

        return exists;
    }

    internal static bool DirectoryAccessible(String dirname) {
        bool accessible = false;
        dirname = GetNormalizedDirectoryName(dirname);

        try {
            accessible = (new DirectoryInfo(dirname)).Exists;
        }
        catch {
        }

        return accessible;
    }
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\busy.cpp ===
/*
 * BUSY.CPP
 *
 * Implements the OleUIBusy function which invokes the "Server Busy"
 * dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"

OLEDBGDATA

// Internally used structure
typedef struct tagBUSY
{
        // Keep these items first as the Standard* functions depend on it here.
        LPOLEUIBUSY     lpOBZ;  // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog or that we don't want to change in the original structure
         * until the user presses OK.
         */
        DWORD   dwFlags;        // Flags passed in
        HWND    hWndBlocked;    // HWND of app which is blocking

} BUSY, *PBUSY, FAR *LPBUSY;

// Internal function prototypes
// BUSY.CPP

INT_PTR CALLBACK BusyDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL GetTaskInfo(HWND hWnd, HTASK htask, LPTSTR* lplpszWindowName, HWND* lphWnd);
void BuildBusyDialogString(HWND, DWORD, int, LPTSTR);
BOOL FBusyInit(HWND hDlg, WPARAM wParam, LPARAM lParam);
void MakeWindowActive(HWND hWndSwitchTo);

/*
 * OleUIBusy
 *
 * Purpose:
 *  Invokes the standard OLE "Server Busy" dialog box which
 *  notifies the user that the server application is not receiving
 *  messages.  The dialog then asks the user to either cancel
 *  the operation, switch to the task which is blocked, or continue
 *  waiting.
 *
 * Parameters:
 *  lpBZ            LPOLEUIBUSY pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *              OLEUI_BZERR_HTASKINVALID  : Error
 *              OLEUI_BZ_SWITCHTOSELECTED : Success, user selected "switch to"
 *              OLEUI_BZ_RETRYSELECTED    : Success, user selected "retry"
 *              OLEUI_CANCEL              : Success, user selected "cancel"
 */
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY lpOBZ)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpOBZ, sizeof(OLEUIBUSY),
                &hMemDlg);

        // Error out if the standard validation failed
        if (OLEUI_SUCCESS != uRet)
                return uRet;

        // Error out if our secondary validation failed
        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }

        // Invoke the dialog.
        uRet = UStandardInvocation(BusyDialogProc, (LPOLEUISTANDARD)lpOBZ,
                hMemDlg, MAKEINTRESOURCE(IDD_BUSY));
        return uRet;
}

/*
 * BusyDialogProc
 *
 * Purpose:
 *  Implements the OLE Busy dialog as invoked through the OleUIBusy function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 *
 */
INT_PTR CALLBACK BusyDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPBUSY lpBZ = (LPBUSY)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (INT_PTR)uRet;

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // Process our special "close" message.  If we get this message,
        // this means that the call got unblocked, so we need to
        // return OLEUI_BZ_CALLUNBLOCKED to our calling app.
        if (iMsg == uMsgCloseBusyDlg)
        {
                SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_CALLUNBLOCKED, 0L);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpBZ)
            {
                StandardCleanup(lpBZ, hDlg);
            }
            break;
        case WM_INITDIALOG:
                FBusyInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_ACTIVATEAPP:
                {
                        /* try to bring down our Busy/NotResponding dialog as if
                        **    the user entered RETRY.
                        */
                        BOOL fActive = (BOOL)wParam;
                        if (fActive)
                        {
                                // If this is the app BUSY case, then bring down our
                                // dialog when switching BACK to our app
                                if (lpBZ && !(lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
                                        SendMessage(hDlg,uMsgEndDialog,OLEUI_BZ_RETRYSELECTED,0L);
                        }
                        else
                        {
                                // If this is the app NOT RESPONDING case, then bring down
                                // our dialog when switching AWAY to another app
                                if (lpBZ && (lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
                                        SendMessage(hDlg,uMsgEndDialog,OLEUI_BZ_RETRYSELECTED,0L);
                        }
                }
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_BZ_SWITCHTO:
                        {
                                BOOL fNotRespondingDlg =
                                                (BOOL)(lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG);
                                HWND hwndTaskList = hDlg;

                                // If this is the app not responding case, then we want
                                // to bring down the dialog when "SwitchTo" is selected.
                                // If the app is busy (RetryRejectedCall situation) then
                                // we do NOT want to bring down the dialog. this is
                                // the OLE2.0 user model design.
                                if (fNotRespondingDlg)
                                {
                                        hwndTaskList = GetParent(hDlg);
                                        if (hwndTaskList == NULL)
                                                hwndTaskList = GetDesktopWindow();
                                        PostMessage(hDlg, uMsgEndDialog,
                                                OLEUI_BZ_SWITCHTOSELECTED, 0L);
                                }

                                // If user selects "Switch To...", switch activation
                                // directly to the window which is causing the problem.
                                if (IsWindow(lpBZ->hWndBlocked))
                                        MakeWindowActive(lpBZ->hWndBlocked);
                                else
                                        PostMessage(hwndTaskList, WM_SYSCOMMAND, SC_TASKLIST, 0);
                        }
                        break;

                case IDC_BZ_RETRY:
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_RETRYSELECTED, 0L);
                        break;

                case IDCANCEL:
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;
                }
                break;
        }

        return FALSE;
}

/*
 * FBusyInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Busy dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FBusyInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        HFONT hFont;
        LPBUSY lpBZ = (LPBUSY)LpvStandardInit(hDlg, sizeof(BUSY), &hFont);

        // PvStandardInit sent a termination to us already.
        if (NULL == lpBZ)
                return FALSE;

        // Our original structure is in lParam
        LPOLEUIBUSY lpOBZ = (LPOLEUIBUSY)lParam;

        // Copy it to our instance of the structure (in lpBZ)
        lpBZ->lpOBZ = lpOBZ;
        lpBZ->nIDD = IDD_BUSY;

        //Copy other information from lpOBZ that we might modify.
        lpBZ->dwFlags = lpOBZ->dwFlags;

        // Set default information
        lpBZ->hWndBlocked = NULL;

        // Insert HWND of our dialog into the address pointed to by
        // lphWndDialog.  This can be used by the app who called
        // OleUIBusy to bring down the dialog with uMsgCloseBusyDialog
        if (lpOBZ->lphWndDialog &&
                !IsBadWritePtr(lpOBZ->lphWndDialog, sizeof(HWND)))
        {
                *lpOBZ->lphWndDialog = hDlg;
        }

        // Update text in text box --
        // GetTaskInfo will return two pointers, one to the task name
        // (file name) and one to the window name.  We need to call
        // OleStdFree on these when we're done with them.  We also
        // get the HWND which is blocked in this call
        //
        // In the case where this call fails, a default message should already
        // be present in the dialog template, so no action is needed

        LPTSTR lpWindowName;
        if (GetTaskInfo(hDlg, lpOBZ->hTask, &lpWindowName, &lpBZ->hWndBlocked))
        {
                // Build string to present to user, place in IDC_BZ_MESSAGE1 control
                BuildBusyDialogString(hDlg, lpBZ->dwFlags, IDC_BZ_MESSAGE1, lpWindowName);
                OleStdFree(lpWindowName);
        }

        // Update icon with the system "exclamation" icon
        HICON hIcon = LoadIcon(NULL, IDI_EXCLAMATION);
        SendDlgItemMessage(hDlg, IDC_BZ_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

        // Disable/Enable controls
        if ((lpBZ->dwFlags & BZ_DISABLECANCELBUTTON) ||
                (lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
        {
                // Disable cancel for "not responding" dialog
                StandardEnableDlgItem(hDlg, IDCANCEL, FALSE);
        }

        if (lpBZ->dwFlags & BZ_DISABLESWITCHTOBUTTON)
                StandardEnableDlgItem(hDlg, IDC_BZ_SWITCHTO, FALSE);

        if (lpBZ->dwFlags & BZ_DISABLERETRYBUTTON)
                StandardEnableDlgItem(hDlg, IDC_BZ_RETRY, FALSE);

        // Call the hook with lCustData in lParam
        UStandardHook((LPVOID)lpBZ, hDlg, WM_INITDIALOG, wParam, lpOBZ->lCustData);

        // Update caption if lpszCaption was specified
        if (lpBZ->lpOBZ->lpszCaption && !IsBadReadPtr(lpBZ->lpOBZ->lpszCaption, 1))
        {
                SetWindowText(hDlg, lpBZ->lpOBZ->lpszCaption);
        }
        return TRUE;
}

/*
 * BuildBusyDialogString
 *
 * Purpose:
 *  Builds the string that will be displayed in the dialog from the
 *  task name and window name parameters.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  dwFlags         DWORD containing flags passed into dialog
 *  iControl        Control ID to place the text string
 *  lpTaskName      LPSTR pointing to name of task (e.g. C:\TEST\TEST.EXE)
 *  lpWindowName    LPSTR for name of window
 *
 * Caveats:
 *  The caller of this function MUST de-allocate the lpTaskName and
 *  lpWindowName pointers itself with OleStdFree
 *
 * Return Value:
 *  void
 */
void BuildBusyDialogString(
        HWND hDlg, DWORD dwFlags, int iControl, LPTSTR lpWindowName)
{
        // Load the format string out of stringtable, choose a different
        // string depending on what flags are passed in to the dialog
        UINT uiStringNum;
        if (dwFlags & BZ_NOTRESPONDINGDIALOG)
                uiStringNum = IDS_BZRESULTTEXTNOTRESPONDING;
        else
                uiStringNum = IDS_BZRESULTTEXTBUSY;

        TCHAR szFormat[256];
        if (LoadString(_g_hOleStdResInst, uiStringNum, szFormat, 256) == 0)
                return;

        // Build the string. The format string looks like this:
        // "This action cannot be completed because the "%1" application
        // is [busy | not responding]. Choose \"Switch To\" to correct the
        // problem."

        TCHAR szMessage[512];
        FormatString1(szMessage, szFormat, lpWindowName, 512);
        SetDlgItemText(hDlg, iControl, szMessage);
}

/*
 * GetTaskInfo()
 *
 * Purpose:  Gets information about the specified task and places the
 * module name, window name and top-level HWND for the task in the specified
 * pointers
 *
 * NOTE: The two string pointers allocated in this routine are
 * the responsibility of the CALLER to de-allocate.
 *
 * Parameters:
 *    hWnd             HWND who called this function
 *    htask            HTASK which we want to find out more info about
 *    lplpszTaskName   Location that the module name is returned
 *    lplpszWindowName Location where the window name is returned
 *
 */
BOOL GetTaskInfo(
        HWND hWnd, HTASK htask, LPTSTR* lplpszWindowName, HWND* lphWnd)
{
        if (htask == NULL)
                return FALSE;

        // initialize 'out' parameters
        *lplpszWindowName = NULL;

        // Now, enumerate top-level windows in system
        HWND hwndNext = GetWindow(hWnd, GW_HWNDFIRST);
        while (hwndNext)
        {
                // See if we can find a non-owned top level window whose
                // hInstance matches the one we just got passed.  If we find one,
                // we can be fairly certain that this is the top-level window for
                // the task which is blocked.
                DWORD dwProcessID;
                DWORD dwThreadID = GetWindowThreadProcessId(hwndNext, &dwProcessID);
                if ((hwndNext != hWnd) &&
                        (dwThreadID == HandleToUlong(htask)) &&
                        (IsWindowVisible(hwndNext)) && !GetWindow(hwndNext, GW_OWNER))
                {
                        // We found our window!  Alloc space for new strings
                        LPTSTR lpszWN;
                        if ((lpszWN = (LPTSTR)OleStdMalloc(MAX_PATH_SIZE)) == NULL)
                                break;

                        // We found the window we were looking for, copy info to
                        // local vars
                        GetWindowText(hwndNext, lpszWN, MAX_PATH);

                        // Note: the task name cannot be retrieved with the Win32 API.

                        // everything was successful. Set string pointers to point to our data.
                        *lplpszWindowName = lpszWN;
                        *lphWnd = hwndNext;
                        return TRUE;
                }
                hwndNext = GetWindow(hwndNext, GW_HWNDNEXT);
        }

        return FALSE;
}

/*
 * MakeWindowActive()
 *
 * Purpose: Makes specified window the active window.
 *
 */
void MakeWindowActive(HWND hWndSwitchTo)
{
        // If it's iconic, we need to restore it.
        if (IsIconic(hWndSwitchTo))
                ShowWindow(hWndSwitchTo, SW_RESTORE);

        // Move the new window to the top of the Z-order
        SetForegroundWindow(GetLastActivePopup(hWndSwitchTo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\chngsrc.cpp ===
/*
 * CHNGSRC.CPP
 *
 * Implements the OleUIChangeSource function which invokes the complete
 * Change Source dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "strsafe.h"

OLEDBGDATA

// Internally used structure
typedef struct tagCHANGESOURCE
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUICHANGESOURCE     lpOCS;       //Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */

} CHANGESOURCE, *PCHANGESOURCE, FAR* LPCHANGESOURCE;

// Internal function prototypes
// CHNGSRC.CPP

UINT_PTR CALLBACK ChangeSourceHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL FChangeSourceInit(HWND hDlg, WPARAM, LPARAM);
STDAPI_(BOOL) IsValidInterface(void FAR* ppv);

/*
 * OleUIChangeSource
 *
 * Purpose:
 *  Invokes the standard OLE Change Source dialog box allowing the user
 *  to change the source of a link.  The link source is not actually
 *  changed by this dialog.  It is up to the caller to actually change
 *  the link source itself.
 *
 * Parameters:
 *  lpCS            LPOLEUIChangeSource pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */
STDAPI_(UINT) OleUIChangeSource(LPOLEUICHANGESOURCE lpCS)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpCS,
                sizeof(OLEUICHANGESOURCE), &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;


        HCURSOR hCurSave = NULL;

        // validate contents of lpCS
        if (lpCS->lpOleUILinkContainer == NULL)
        {
                uRet = OLEUI_CSERR_LINKCNTRNULL;
                goto Error;
        }
        if (!IsValidInterface(lpCS->lpOleUILinkContainer))
        {
                uRet = OLEUI_CSERR_LINKCNTRINVALID;
                goto Error;
        }

        // lpszFrom and lpszTo must be NULL (they are out only)
        if (lpCS->lpszFrom != NULL)
        {
                uRet = OLEUI_CSERR_FROMNOTNULL;
                goto Error;
        }
        if (lpCS->lpszTo != NULL)
        {
                uRet = OLEUI_CSERR_TONOTNULL;
                goto Error;
        }

        // lpszDisplayName must be valid or NULL
        if (lpCS->lpszDisplayName != NULL &&
                IsBadStringPtr(lpCS->lpszDisplayName, (UINT)-1))
        {
                uRet = OLEUI_CSERR_SOURCEINVALID;
                goto Error;
        }

        hCurSave = HourGlassOn();

        // attempt to retrieve link source if not provided
        if (lpCS->lpszDisplayName == NULL)
        {
                if (NOERROR != lpCS->lpOleUILinkContainer->GetLinkSource(
                        lpCS->dwLink, &lpCS->lpszDisplayName, &lpCS->nFileLength,
                        NULL, NULL, NULL, NULL))
                {
                        uRet = OLEUI_CSERR_SOURCEINVALID;
                        goto Error;
                }
        }

        // verify that nFileLength is valid
        UINT cchDisplayName = lstrlen(lpCS->lpszDisplayName);
        if (cchDisplayName < lpCS->nFileLength)
        {
            uRet = OLEUI_CSERR_SOURCEINVALID;
            goto Error;
        }

        // allocate file buffer and split directory and file name
        UINT nFileLength; nFileLength = lpCS->nFileLength;
        UINT nFileBuf; nFileBuf = max(nFileLength+1, MAX_PATH);
        LPTSTR lpszFileBuf;
        
        if (cchDisplayName > nFileBuf -1)
        {
            uRet = OLEUI_CSERR_SOURCEINVALID;
            goto Error;
        }
        
        LPTSTR lpszDirBuf; lpszDirBuf = (LPTSTR)OleStdMalloc(nFileBuf * sizeof(TCHAR));
        if (lpszDirBuf == NULL)
        {
                uRet = OLEUI_ERR_OLEMEMALLOC;
                goto Error;
        }
        lstrcpyn(lpszDirBuf, lpCS->lpszDisplayName, nFileLength+1);

        UINT nFileLen; nFileLen = GetFileName(lpszDirBuf, NULL, 0);

        lpszFileBuf = (LPTSTR)OleStdMalloc(nFileBuf * sizeof(TCHAR));
        if (lpszFileBuf == NULL)
        {
                uRet = OLEUI_ERR_OLEMEMALLOC;
                goto ErrorFreeDirBuf;
        }
        memmove(lpszFileBuf, lpszDirBuf+nFileLength-nFileLen+1,
                (nFileLen+1)*sizeof(TCHAR));
        lpszDirBuf[nFileLength-(nFileLen - 1)] = 0;

        // start filling the OPENFILENAME struct
        OPENFILENAME ofn; memset(&ofn, 0, sizeof(ofn));
        ofn.lpstrFile = lpszFileBuf;
        ofn.nMaxFile = nFileBuf;
        ofn.lpstrInitialDir = lpszDirBuf;

        // load filter strings
        TCHAR szFilters[MAX_PATH];
        if (!LoadString(_g_hOleStdResInst, IDS_FILTERS, szFilters, MAX_PATH))
                szFilters[0] = 0;
        else
                ReplaceCharWithNull(szFilters, szFilters[lstrlen(szFilters)-1]);
        ofn.lpstrFilter = szFilters;
        ofn.nFilterIndex = 1;

        TCHAR szTitle[MAX_PATH];

        // set the caption
        if (NULL!=lpCS->lpszCaption)
            ofn.lpstrTitle = lpCS->lpszCaption;
        else
        {
            LoadString(_g_hOleStdResInst, IDS_CHANGESOURCE, szTitle, MAX_PATH);
            ofn.lpstrTitle = szTitle;
        }

        // fill in rest of OPENFILENAME struct
        ofn.hwndOwner = lpCS->hWndOwner;
        ofn.lStructSize = sizeof(ofn);
        ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK;
        if (bWin4 && ((NULL == lpCS->hInstance && NULL == lpCS->hResource)
                || 0 != (lpCS->dwFlags & CSF_EXPLORER)))
            ofn.Flags |= OFN_EXPLORER;
        if (lpCS->dwFlags & CSF_SHOWHELP)
                ofn.Flags |= OFN_SHOWHELP;
        ofn.lCustData = (LPARAM)lpCS;
        ofn.lpfnHook = ChangeSourceHookProc;
        ofn.lCustData = (LPARAM)lpCS;
        lpCS->lpOFN = &ofn;             // needed sometimes in hook proc

        // allow hooking of the dialog resource
        if (lpCS->hResource != NULL)
        {
                ofn.hInstance = (HINSTANCE)lpCS->hResource;
                ofn.lpTemplateName = (LPCTSTR)lpCS->hResource;
                ofn.Flags |= OFN_ENABLETEMPLATEHANDLE;
        }
        else
        {
                if (lpCS->hInstance == NULL)
                {
                        ofn.hInstance = _g_hOleStdResInst;
                        ofn.lpTemplateName = bWin4 ?
                                MAKEINTRESOURCE(IDD_CHANGESOURCE4) : MAKEINTRESOURCE(IDD_CHANGESOURCE);
                        ofn.Flags |= OFN_ENABLETEMPLATE;
                }
                else
                {
                        ofn.hInstance = lpCS->hInstance;
                        ofn.lpTemplateName = lpCS->lpszTemplate;
                        ofn.Flags |= OFN_ENABLETEMPLATE;
                }
        }

        if (lpCS->hWndOwner != NULL)
        {
                // allow hooking of the OFN struct
                SendMessage(lpCS->hWndOwner, uMsgBrowseOFN, ID_BROWSE_CHANGESOURCE, (LPARAM)&ofn);
        }

        // call up the dialog
        BOOL bResult;

        bResult = StandardGetOpenFileName(&ofn);

        // cleanup
        OleStdFree(lpszDirBuf);
        OleStdFree(lpszFileBuf);

        HourGlassOff(hCurSave);

        // map return value to OLEUI_ standard returns
        return bResult ? OLEUI_OK : OLEUI_CANCEL;

// handle most error returns here
ErrorFreeDirBuf:
        OleStdFree(lpszDirBuf);

Error:
        if (hCurSave != NULL)
                HourGlassOff(hCurSave);
        return uRet;
}

/*
 * ChangeSourceHookProc
 *
 * Purpose:
 *  Implements the OLE Change Source dialog as invoked through the
 *  OleUIChangeSource function.  This is a standard COMMDLG hook function
 *  as opposed to a dialog proc.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */
UINT_PTR CALLBACK ChangeSourceHookProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPCHANGESOURCE lpCS = (LPCHANGESOURCE)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        LPOLEUICHANGESOURCE lpOCS = NULL;
        if (lpCS != NULL)
                lpOCS = lpCS->lpOCS;

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return uHook;

        // Process help message
        if ((iMsg == uMsgHelp) && NULL != lpOCS)
        {
            PostMessage(lpOCS->hWndOwner, uMsgHelp,
                (WPARAM)hDlg, MAKELPARAM(IDD_CHANGESOURCE, 0));
        }

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                // Free any specific allocations before calling StandardCleanup
                StandardCleanup((PVOID)lpCS, hDlg);
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // handle validation of the file name (when user hits OK)
        if ((iMsg == uMsgFileOKString) && (lpOCS != NULL))
        {
                // always use fully qualified name
                LPOPENFILENAME lpOFN = lpOCS->lpOFN;
                LPCTSTR lpsz = lpOFN->lpstrFile;
                LPTSTR lpszFile;
                TCHAR szPath[MAX_PATH];
                if (!GetFullPathName(lpsz, MAX_PATH, szPath, &lpszFile))
                        lstrcpyn(szPath, lpsz, MAX_PATH);
                UINT nLenFile = lstrlen(szPath);
                TCHAR szItemName[MAX_PATH];
                GetDlgItemText(hDlg, edt2, szItemName, MAX_PATH);

                // combine them into szDisplayName (which is now large enough)
                TCHAR szDisplayName[MAX_PATH+MAX_PATH];
                StringCchCopy(szDisplayName, sizeof(szDisplayName)/sizeof(szDisplayName[0]), szPath);
                if (szItemName[0] != '\0')
                {
                        StringCchCat(szDisplayName, sizeof(szDisplayName)/sizeof(szDisplayName[0]), TEXT("\\"));
                        StringCchCat(szDisplayName, sizeof(szDisplayName)/sizeof(szDisplayName[0]), szItemName);
                }

                if (!(lpOCS->dwFlags & CSF_ONLYGETSOURCE))
                {
                        // verify the source by calling into the link container
                        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpOCS->lpOleUILinkContainer;
                        ULONG chEaten;
                        if (lpOleUILinkCntr->SetLinkSource(lpOCS->dwLink, szDisplayName, nLenFile,
                                &chEaten, TRUE) != NOERROR)
                        {
                                // link not verified ok
                                lpOCS->dwFlags &= ~CSF_VALIDSOURCE;
                                UINT uRet = PopupMessage(hDlg, IDS_CHANGESOURCE, IDS_INVALIDSOURCE,
                                                MB_ICONQUESTION | MB_YESNO);
                                if (uRet == IDYES)
                                {
                                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                                        return 1;       // do not close dialog
                                }

                                // user doesn't care if the link is valid or not
                                lpOleUILinkCntr->SetLinkSource(lpOCS->dwLink, szDisplayName, nLenFile,
                                        &chEaten, FALSE);
                        }
                        else
                        {
                                // link was verified ok
                                lpOCS->dwFlags |= CSF_VALIDSOURCE;
                        }
                }

                // calculate lpszFrom and lpszTo for batch changes to links
                DiffPrefix(lpOCS->lpszDisplayName, szDisplayName, &lpOCS->lpszFrom, &lpOCS->lpszTo);

                // only keep them if the file name portion is the only part that changed
                if (lstrcmpi(lpOCS->lpszTo, lpOCS->lpszFrom) == 0 ||
                        (UINT)lstrlen(lpOCS->lpszFrom) > lpOCS->nFileLength)
                {
                        OleStdFree(lpOCS->lpszFrom);
                        lpOCS->lpszFrom = NULL;

                        OleStdFree(lpOCS->lpszTo);
                        lpOCS->lpszTo = NULL;
                }

                // store new source in lpOCS->lpszDisplayName
                OleStdFree(lpOCS->lpszDisplayName);
                lpOCS->lpszDisplayName = OleStdCopyString(szDisplayName);
                lpOCS->nFileLength = nLenFile;

                return 0;
        }

        switch (iMsg)
        {
        case WM_NOTIFY:
            if (((NMHDR*)lParam)->code == CDN_HELP)
            {
                goto POSTHELP;
            }
            break;
        case WM_COMMAND:
            if (wID == pshHelp)
            {
POSTHELP:
                PostMessage(lpCS->lpOCS->hWndOwner, uMsgHelp,
                        (WPARAM)hDlg, MAKELPARAM(IDD_CHANGESOURCE, 0));
            }
            break;
        case WM_INITDIALOG:
            return FChangeSourceInit(hDlg, wParam, lParam);
        }

        return 0;
}

/*
 * FChangeSourceInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Change Source dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FChangeSourceInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        LPCHANGESOURCE lpCS = (LPCHANGESOURCE)LpvStandardInit(hDlg, sizeof(CHANGESOURCE), NULL);

        // PvStandardInit send a termination to us already.
        if (NULL == lpCS)
                return FALSE;

        LPOLEUICHANGESOURCE lpOCS=
                (LPOLEUICHANGESOURCE)((LPOPENFILENAME)lParam)->lCustData;
        lpCS->lpOCS = lpOCS;
        lpCS->nIDD = IDD_CHANGESOURCE;

        // Setup Item text box with item part of lpszDisplayName
        LPTSTR lpszItemName = lpOCS->lpszDisplayName + lpOCS->nFileLength;
        if (*lpszItemName != '\0')
                SetDlgItemText(hDlg, edt2, lpszItemName+1);
        SendDlgItemMessage(hDlg, edt2, EM_LIMITTEXT, MAX_PATH, 0L);

        // Change the caption
        if (NULL!=lpOCS->lpszCaption)
                SetWindowText(hDlg, lpOCS->lpszCaption);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpCS, hDlg, WM_INITDIALOG, wParam, lpOCS->lCustData);
#ifdef CHICO
        TCHAR szTemp[MAX_PATH];
        LoadString(_g_hOleStdResInst, IDS_CHNGSRCOKBUTTON , szTemp, MAX_PATH);
        CommDlg_OpenSave_SetControlText(GetParent(hDlg), IDOK, szTemp);
#endif
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\common.cpp ===
/*
 * COMMON.CPP
 *
 * Standardized (and centralized) pieces of each OLEDLG dialog function:
 *
 *  UStandardValidation     Validates standard fields in each dialog structure
 *  UStandardInvocation     Invokes a dialog through DialogBoxIndirectParam
 *  LpvStandardInit         Common WM_INITDIALOG processing
 *  LpvStandardEntry        Common code to execute on dialog proc entry.
 *  UStandardHook           Centralized hook calling function.
 *  StandardCleanup         Common exit/cleanup code.
 *  StandardShowDlgItem     Show-Enable/Hide-Disable dialog item
 *      StandardEnableDlgItem   Enable/Disable dialog item
 *  StandardResizeDlgY          Resize dialog to fit controls
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"

OLEDBGDATA

/*
 * UStandardValidation
 *
 * Purpose:
 *  Performs validation on the standard pieces of any dialog structure,
 *  that is, the fields defined in the OLEUISTANDARD structure.
 *
 * Parameters:
 *  lpUI            const LPOLEUISTANDARD pointing to the shared data of
 *                  all structs.
 *  cbExpect        const UINT structure size desired by the caller.
 *  phDlgMem        const HGLOBAL FAR * in which to store a loaded customized
 *                  template, if one exists.
 *                  (This may be NULL in which case the template pointer isn't
 *                  needed by the calling function and should be released.)
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS if all validation succeeded.  Otherwise
 *                  it will be one of the standard error codes.
 */
UINT WINAPI UStandardValidation(LPOLEUISTANDARD lpUI, const UINT cbExpect,
        HGLOBAL* phMemDlg)
{
        /*
         * 1.  Validate non-NULL pointer parameter.  Note:  We don't validate
         *     phDlg since it's not passed from an external source.
         */
        if (NULL == lpUI)
                return OLEUI_ERR_STRUCTURENULL;

        // 2.  Validate that the structure is readable and writable.
        if (IsBadWritePtr(lpUI, cbExpect))
                return OLEUI_ERR_STRUCTUREINVALID;

        // 3.  Validate the structure size
        if (cbExpect != lpUI->cbStruct)
                return OLEUI_ERR_CBSTRUCTINCORRECT;

        // 4.  Validate owner-window handle.  NULL is considered valid.
        if (NULL != lpUI->hWndOwner && !IsWindow(lpUI->hWndOwner))
                return OLEUI_ERR_HWNDOWNERINVALID;

        // 5.  Validate the dialog caption.  NULL is considered valid.
        if (NULL != lpUI->lpszCaption && IsBadReadPtr(lpUI->lpszCaption, 1))
                return OLEUI_ERR_LPSZCAPTIONINVALID;

        // 6.  Validate the hook pointer.  NULL is considered valid.
        if (NULL != lpUI->lpfnHook && IsBadCodePtr((FARPROC)lpUI->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        /*
         * 7.  If hInstance is non-NULL, we have to also check lpszTemplate.
         *     Otherwise, lpszTemplate is not used and requires no validation.
         *     lpszTemplate cannot be NULL if used.
         */
        HGLOBAL hMem = NULL;
        if (NULL != lpUI->hInstance)
        {
                //Best we can try is one character
                if (NULL == lpUI->lpszTemplate || (HIWORD(PtrToUlong(lpUI->lpszTemplate)) != 0 &&
                        IsBadReadPtr(lpUI->lpszTemplate, 1)))
                        return OLEUI_ERR_LPSZTEMPLATEINVALID;
                HRSRC hRes = FindResource(lpUI->hInstance, lpUI->lpszTemplate, RT_DIALOG);
                if (NULL == hRes)
                    return OLEUI_ERR_FINDTEMPLATEFAILURE;

                hMem = LoadResource(lpUI->hInstance, hRes);
                if (NULL == hMem)
                    return OLEUI_ERR_LOADTEMPLATEFAILURE;
        }

        // 8. If hResource is non-NULL, be sure we can lock it.
        if (NULL != lpUI->hResource)
        {
                if ((LPSTR)NULL == LockResource(lpUI->hResource))
                        return OLEUI_ERR_HRESOURCEINVALID;
        }

        /*
         * Here we have hMem==NULL if we should use the standard template
         * or the one in lpUI->hResource.  If hMem is non-NULL, then we
         * loaded one from the calling application's resources which the
         * caller of this function has to free if it sees any other error.
         */
        if (NULL != phMemDlg)
        {
            *phMemDlg = hMem;
        }
        return OLEUI_SUCCESS;
}

/*
 * UStandardInvocation
 *
 * Purpose:
 *  Provides standard template loading and calling on DialogBoxIndirectParam
 *  for all the OLE UI dialogs.
 *
 * Parameters:
 *  lpDlgProc       DLGPROC of the dialog function.
 *  lpUI            LPOLEUISTANDARD containing the dialog structure.
 *  hMemDlg         HGLOBAL containing the dialog template.  If this
 *                  is NULL and lpUI->hResource is NULL, then we load
 *                  the standard template given the name in lpszStdTemplate
 *  lpszStdTemplate LPCSTR standard template to load if hMemDlg is NULL
 *                  and lpUI->hResource is NULL.
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS if all is well, otherwise and error
 *                  code.
 */
UINT WINAPI UStandardInvocation(
        DLGPROC lpDlgProc, LPOLEUISTANDARD lpUI, HGLOBAL hMemDlg, LPTSTR lpszStdTemplate)
{
        // Make sure we have a template, then lock it down
        HGLOBAL hTemplate = hMemDlg;
        if (NULL == hTemplate)
                hTemplate = lpUI->hResource;

        if (NULL == hTemplate)
        {
                HRSRC hRes = FindResource(_g_hOleStdResInst, (LPCTSTR) lpszStdTemplate, RT_DIALOG);
                if (NULL == hRes)
                        return OLEUI_ERR_FINDTEMPLATEFAILURE;

                hTemplate = LoadResource(_g_hOleStdResInst, hRes);
                if (NULL == hTemplate)
                        return OLEUI_ERR_LOADTEMPLATEFAILURE;
        }

        /*
         * hTemplate has the template to use, so now we can invoke the dialog.
         * Since we have exported all of our dialog procedures using the
         * _keyword, we do not need to call MakeProcInstance,
         * we can ue the dialog procedure address directly.
         */

        INT_PTR iRet = DialogBoxIndirectParam(_g_hOleStdResInst, (LPCDLGTEMPLATE)hTemplate,
                lpUI->hWndOwner, lpDlgProc, (LPARAM)lpUI);

        if (-1 == iRet)
                return OLEUI_ERR_DIALOGFAILURE;

        // Return the code from EndDialog, generally OLEUI_OK or OLEUI_CANCEL
        return (UINT)iRet;
}

/*
 * LpvStandardInit
 *
 * Purpose:
 *  Default actions for WM_INITDIALOG handling in the dialog, allocating
 *  a dialog-specific structure, setting that memory as a dialog property,
 *  and creating a small font if necessary setting that font as a property.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  cbStruct        UINT size of dialog-specific structure to allocate.
 *  fCreateFont     BOOL indicating if we need to create a small Helv
 *                  font for this dialog.
 *  phFont          HFONT FAR * in which to place a created font.  Can be
 *                  NULL if fCreateFont is FALSE.
 *
 * Return Value:
 *  LPVOID          Pointer to global memory allocated for the dialog.
 *                  The memory will have been set as a dialog property
 *                  using the STRUCTUREPROP label.
 */
LPVOID WINAPI LpvStandardInit(HWND hDlg, UINT cbStruct, HFONT* phFont)
{
        // Must have at least sizeof(void*) bytes in cbStruct
        if (sizeof(void*) > cbStruct)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
                return NULL;
        }

        HGLOBAL gh = GlobalAlloc(GHND, cbStruct);
        if (NULL == gh)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
                return NULL;
        }
        LPVOID lpv = GlobalLock(gh);
        SetProp(hDlg, STRUCTUREPROP, gh);

        if (phFont != NULL)
            *phFont = NULL;
        if (!bWin4 && phFont != NULL)
        {
                // Create the non-bold font for result and file texts.  We call
                HFONT hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
                LOGFONT lf;
                GetObject(hFont, sizeof(LOGFONT), &lf);
                lf.lfWeight = FW_NORMAL;

                // Attempt to create the font.  If this fails, then we return no font.
                *phFont = CreateFontIndirect(&lf);

                // If we couldn't create the font, we'll do with the default.
                if (NULL != *phFont)
                        SetProp(hDlg, FONTPROP, (HANDLE)*phFont);
        }

        // Setup the context help mode (WS_EX_CONTEXTHELP)
        if (bWin4)
        {
                DWORD dwExStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
                dwExStyle |= WS_EX_CONTEXTHELP;
                SetWindowLong(hDlg, GWL_EXSTYLE, dwExStyle);
        }

        return lpv;
}

typedef struct COMMON
{
        OLEUISTANDARD*  pStandard;
        UINT                    nIDD;

} COMMON, *PCOMMON, FAR* LPCOMMON;


/*
 * LpvStandardEntry
 *
 * Purpose:
 *  Retrieves the dialog's structure property and calls the hook
 *  as necessary.  This should be called on entry into all dialog
 *  procedures.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  iMsg            UINT message to the dialog
 *  wParam, lParam  WPARAM, LPARAM message parameters
 *  puHookResult    UINT FAR * in which this function stores the return value
 *                  from the hook if it is called.  If no hook is available,
 *                  this will be FALSE.
 *
 * Return Value:
 *  LPVOID          Pointer to the dialog's extra structure held in the
 *                  STRUCTUREPROP property.
 */
// char szDebug[100];
 
LPVOID WINAPI LpvStandardEntry(HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam, UINT FAR * puHookResult)
{
    // This will fail under WM_INITDIALOG, where we allocate using StandardInit
    LPVOID  lpv = NULL;
    HGLOBAL gh = GetProp(hDlg, STRUCTUREPROP);


    if (NULL != puHookResult && NULL != gh)
    {
        *puHookResult = 0;

        // gh was locked previously, lock and unlock to get lpv
        lpv = GlobalLock(gh);
        GlobalUnlock(gh);

        // Call the hook for all messages except WM_INITDIALOG
        if (NULL != lpv && WM_INITDIALOG != iMsg)
        *puHookResult = UStandardHook(lpv, hDlg, iMsg, wParam, lParam);

        // Default processing for various messages
        LPCOMMON lpCommon = (LPCOMMON)lpv;
        if (*puHookResult == 0 && NULL != lpv)
        {
            switch (iMsg)
            {
                // handle standard Win4 help messages
            case WM_HELP:
                {
                HWND hWndChild = (HWND)((LPHELPINFO)lParam)->hItemHandle;
                //skip read-only controls (requested by Help folks)
                //basically the help strings for items like ObjectName on GnrlProps
                //give useless information. 
                //If we do not make this check now the other option is to turn ON
                //the #if 0 inside the switch. That is ugly.

                    if (hWndChild!=hDlg	) 
                    {
                        int iCtrlId = ((LPHELPINFO)lParam)->iCtrlId;
                        // wsprintfA(szDebug,"\n @@@ hWnd= %lx, hChld = %lx,  ctrlId = %d ", hDlg, hWndChild, iCtrlId);
                        // OutputDebugStringA(szDebug);
                        switch (iCtrlId)
                        {
                            // list of control IDs that should not have help
                        case -1:		//IDC_STATIC
                        case 0xffff:    //IDC_STATIC
                        case IDC_CI_GROUP:
                        case IDC_GP_OBJECTICON:
                            break;
                        default:
                            StandardHelp(hWndChild, lpCommon->nIDD);                        

                        }
                    }
                *puHookResult = TRUE;  //We handled the message.
                break;
            } //case WM_HELP

            case WM_CONTEXTMENU:
                {
                    POINT pt;
                    int iCtrlId;
                    HWND hwndChild = NULL;
                    if( hDlg == (HWND) wParam )
                    {
                        GetCursorPos(&pt);
                        ScreenToClient(hDlg, &pt);
                        hwndChild = ChildWindowFromPointEx(hDlg, pt, 
                        CWP_SKIPINVISIBLE); 
                        //hWndChild will now be either hDlg or hWnd of the ctrl   
                    }

                    if ( hwndChild != hDlg ) 
                    {
                        if (hwndChild) 
                        {
                            iCtrlId = GetDlgCtrlID(hwndChild);
                        }
                        else
                        {
                            iCtrlId = GetDlgCtrlID((HWND)wParam);
                        }
                        // wsprintfA(szDebug, "\n ### hWnd= %lx, hChld = %lx,  ctrlId = %d ", hDlg, hwndChild, iCtrlId);
                        // OutputDebugStringA(szDebug);
                        switch (iCtrlId)
                        {
                            // list of control IDs that should not have help
                        case -1:        //  IDC_STATIC
                        case 0xffff:    //  IDC_STATIC
                        case IDC_CI_GROUP:
                        case IDC_GP_OBJECTICON:
                        break;
                        default:
                            StandardContextMenu(wParam, lParam, lpCommon->nIDD);
                        }
                    }

                    *puHookResult = TRUE;  //We handled the message.
                    break;
                }   // case WM_CONTEXTMENU

            case WM_CTLCOLOREDIT:
                {
                    // make readonly edits have gray background
                    if (bWin4 && (GetWindowLong((HWND)lParam, GWL_STYLE)
                        & ES_READONLY))
                    {
                        *puHookResult = (UINT)SendMessage(hDlg, WM_CTLCOLORSTATIC, wParam, lParam);
                    }
                    break;
                }   
            }   //switch (iMsg)
        }   //*puHookResult == 0
    } //NULL != puHookResult 
    return lpv;
}

/*
 * UStandardHook
 *
 * Purpose:
 *  Provides a generic hook calling function assuming that all private
 *  dialog structures have a far pointer to their assocated public
 *  structure as the first field, and that the first part of the public
 *  structure matches an OLEUISTANDARD.
 *
 * Parameters:
 *  pv              PVOID to the dialog structure.
 *  hDlg            HWND to send with the call to the hook.
 *  iMsg            UINT message to send to the hook.
 *  wParam, lParam  WPARAM, LPARAM message parameters
 *
 * Return Value:
 *  UINT            Return value from the hook, zero to indicate that
 *                  default action should occur,  nonzero to specify
 *                  that the hook did process the message.  In some
 *                  circumstances it will be important for the hook to
 *                  return a non-trivial non-zero value here, such as
 *                  a brush from WM_CTLCOLOR, in which case the caller
 *                  should return that value from the dialog procedure.
 */
UINT WINAPI UStandardHook(LPVOID lpv, HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{
        UINT uRet = 0;
        LPOLEUISTANDARD lpUI = *((LPOLEUISTANDARD FAR *)lpv);
        if (NULL != lpUI && NULL != lpUI->lpfnHook)
        {
                /*
                 * In order for the hook to have the proper DS, they should be
                 * compiling with -GA -GEs so and usin __to get everything
                 * set up properly.
                 */
                uRet = (*lpUI->lpfnHook)(hDlg, iMsg, wParam, lParam);
        }
        return uRet;
}

/*
 * StandardCleanup
 *
 * Purpose:
 *  Removes properties and reverses any other standard initiazation
 *  done through StandardSetup.
 *
 * Parameters:
 *  lpv             LPVOID containing the private dialog structure.
 *  hDlg            HWND of the dialog closing.
 *
 * Return Value:
 *  None
 */
void WINAPI StandardCleanup(LPVOID lpv, HWND hDlg)
{
        HFONT hFont=(HFONT)RemoveProp(hDlg, FONTPROP);
        if (NULL != hFont)
        {
            DeleteObject(hFont);
        }

        HGLOBAL gh = RemoveProp(hDlg, STRUCTUREPROP);
        if (gh != NULL)
        {
                GlobalUnlock(gh);
                GlobalFree(gh);
        }
}

/* StandardShowDlgItem
 * -------------------
 *    Show & Enable or Hide & Disable a dialog item as appropriate.
 *    it is NOT sufficient to simply hide the item; it must be disabled
 *    too or the keyboard accelerator still functions.
 */
void WINAPI StandardShowDlgItem(HWND hDlg, int idControl, int nCmdShow)
{
        HWND hItem = GetDlgItem(hDlg, idControl);
        if (hItem != NULL)
        {
                ShowWindow(hItem, nCmdShow);
                EnableWindow(hItem, nCmdShow != SW_HIDE);
        }
}

/* StandardEnableDlgItem
 * -------------------
 *    Enable/Disable a dialog item. If the item does not exist
 *        this call is a noop.
 */
void WINAPI StandardEnableDlgItem(HWND hDlg, int idControl, BOOL bEnable)
{
        HWND hItem = GetDlgItem(hDlg, idControl);
        if (hItem != NULL)
                EnableWindow(hItem, bEnable);
}

/* StandardResizeDlgY
 * ------------------
 *    Resize a dialog to fit around the visible controls.  This is used
 *        for dialogs which remove controls from the bottom of the dialogs.
 *    A good example of this is the convert dialog, which when CF_HIDERESULTS
 *    is selected, removes the "results box" at the bottom of the dialog.
 *        This implementation currently
 */
BOOL WINAPI StandardResizeDlgY(HWND hDlg)
{
        RECT rect;

        // determine maxY by looking at all child windows on the dialog
        int maxY = 0;
        HWND hChild = GetWindow(hDlg, GW_CHILD);
        while (hChild != NULL)
        {
                if (GetWindowLong(hChild, GWL_STYLE) & WS_VISIBLE)
                {
                        GetWindowRect(hChild, &rect);
                        if (rect.bottom > maxY)
                                maxY = rect.bottom;
                }
                hChild = GetWindow(hChild, GW_HWNDNEXT);
        }

        if (maxY > 0)
        {
                // get current font that the dialog is using
                HFONT hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0);
                if (hFont == NULL)
                        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
                OleDbgAssert(hFont != NULL);

                // calculate height of the font in pixels
                HDC hDC = GetDC(NULL);
                hFont = (HFONT)SelectObject(hDC, hFont);
                TEXTMETRIC tm;
                GetTextMetrics(hDC, &tm);
                SelectObject(hDC, hFont);
                ReleaseDC(NULL, hDC);

                // determine if window is too large and resize if necessary
                GetWindowRect(hDlg, &rect);
                if (rect.bottom > maxY + tm.tmHeight)
                {
                        // window is too large -- resize it
                        rect.bottom = maxY + tm.tmHeight;
                        SetWindowPos(hDlg, NULL,
                                0, 0, rect.right-rect.left, rect.bottom-rect.top,
                                SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
                        return TRUE;
                }
        }

        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Support for Windows 95 help
#define HELPFILE        TEXT("mfcuix.hlp")

LPDWORD LoadHelpInfo(UINT nIDD)
{
        HRSRC hrsrc = FindResource(_g_hOleStdResInst, MAKEINTRESOURCE(nIDD),
                MAKEINTRESOURCE(RT_HELPINFO));
        if (hrsrc == NULL)
                return NULL;

        HGLOBAL hHelpInfo = LoadResource(_g_hOleStdResInst, hrsrc);
        if (hHelpInfo == NULL)
                return NULL;

        LPDWORD lpdwHelpInfo = (LPDWORD)LockResource(hHelpInfo);
        return lpdwHelpInfo;
}

void WINAPI StandardHelp(HWND hWnd, UINT nIDD)
{
        LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
        if (lpdwHelpInfo == NULL)
        {
                OleDbgOut1(TEXT("Warning: unable to load help information (RT_HELPINFO)\n"));
                return;
        }
/*
        int id=GetDlgCtrlID( hWnd);
        wsprintfA(szDebug,"\n HH @@@### hWnd= %lx, ctrlId = %d %lx", hWnd,id,id);
        OutputDebugStringA(szDebug);
*/
        
        WinHelp(hWnd, HELPFILE, HELP_WM_HELP, (ULONG_PTR)lpdwHelpInfo);
}

void WINAPI StandardContextMenu(WPARAM wParam, LPARAM, UINT nIDD)
{
        LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
        if (lpdwHelpInfo == NULL)
        {
                OleDbgOut1(TEXT("Warning: unable to load help information (RT_HELPINFO)\n"));
                return;
        }
/*
        int id=GetDlgCtrlID((HWND)wParam);
        wsprintfA(szDebug,"\n CC $$$*** hWnd= %lx, ctrlId = %d %lx ",(HWND)wParam,id,id);
        OutputDebugStringA(szDebug);
*/
        
        WinHelp((HWND)wParam, HELPFILE, HELP_CONTEXTMENU, (ULONG_PTR)lpdwHelpInfo);
}

/////////////////////////////////////////////////////////////////////////////
// StandardPropertySheet (stub for Windows 95 API PropertySheet)

typedef void (WINAPI* LPFNINITCOMMONCONTROLS)(VOID);

int WINAPI StandardInitCommonControls()
{
        TASKDATA* pTaskData = GetTaskData();
        OleDbgAssert(pTaskData != NULL);

        if (pTaskData->hInstCommCtrl == NULL)
        {
                pTaskData->hInstCommCtrl = LoadLibrary(TEXT("comctl32.dll"));
                if (pTaskData->hInstCommCtrl == NULL)
                        goto Error;

                LPFNINITCOMMONCONTROLS lpfnInitCommonControls = (LPFNINITCOMMONCONTROLS)
                        GetProcAddress(pTaskData->hInstCommCtrl, "InitCommonControls");
                if (lpfnInitCommonControls == NULL)
                        goto ErrorFreeLibrary;
                (*lpfnInitCommonControls)();
        }
        return 0;

ErrorFreeLibrary:
        if (pTaskData->hInstCommCtrl != NULL)
        {
                FreeLibrary(pTaskData->hInstCommCtrl);
                pTaskData->hInstCommCtrl = NULL;
        }

Error:
        return -1;
}

typedef int (WINAPI* LPFNPROPERTYSHEET)(LPCPROPSHEETHEADER);

int WINAPI StandardPropertySheet(LPPROPSHEETHEADER lpPS, BOOL fWide)
{
        int nResult = StandardInitCommonControls();
        if (nResult < 0)
                return nResult;

        TASKDATA* pTaskData = GetTaskData();
        OleDbgAssert(pTaskData != NULL);

        LPFNPROPERTYSHEET lpfnPropertySheet;
        if (fWide)
        {
            lpfnPropertySheet = (LPFNPROPERTYSHEET)GetProcAddress(pTaskData->hInstCommCtrl, "PropertySheetW");
        }
        else
        {
            lpfnPropertySheet = (LPFNPROPERTYSHEET)GetProcAddress(pTaskData->hInstCommCtrl, "PropertySheetA");
        }
        if (lpfnPropertySheet == NULL)
                return -1;

        nResult = (*lpfnPropertySheet)(lpPS);
        return nResult;
}

typedef HICON (WINAPI* LPFNEXTRACTICON)(HINSTANCE, LPCTSTR, UINT);

HICON StandardExtractIcon(HINSTANCE hInst, LPCTSTR lpszExeFileName, UINT nIconIndex)
{
    TASKDATA* pTaskData = GetTaskData();
    OleDbgAssert(pTaskData != NULL);
    LPFNEXTRACTICON lpfnExtractIcon;

    if (pTaskData->hInstShell == NULL)
    {
        pTaskData->hInstShell = LoadLibrary(TEXT("shell32.dll"));
        if (pTaskData->hInstShell == NULL)
            goto Error;
    }
    lpfnExtractIcon = (LPFNEXTRACTICON)
#ifdef UNICODE
    GetProcAddress(pTaskData->hInstShell, "ExtractIconW");
#else
    GetProcAddress(pTaskData->hInstShell, "ExtractIconA");
#endif
    if (lpfnExtractIcon == NULL)
            goto ErrorFreeLibrary;
    return (*lpfnExtractIcon)(hInst, lpszExeFileName, nIconIndex);

ErrorFreeLibrary:
    if (pTaskData->hInstShell != NULL)
    {
            FreeLibrary(pTaskData->hInstShell);
            pTaskData->hInstShell = NULL;
    }

Error:
    return NULL;
}


typedef BOOL (WINAPI* LPFNGETOPENFILENAME)(LPOPENFILENAME);

BOOL StandardGetOpenFileName(LPOPENFILENAME lpofn)
{
    TASKDATA* pTaskData = GetTaskData();
    OleDbgAssert(pTaskData != NULL);
    LPFNGETOPENFILENAME lpfnGetOpenFileName;

    if (pTaskData->hInstComDlg == NULL)
    {
        pTaskData->hInstComDlg = LoadLibrary(TEXT("comdlg32.dll"));
        if (pTaskData->hInstComDlg == NULL)
            goto Error;
    }
    lpfnGetOpenFileName = (LPFNGETOPENFILENAME)
#ifdef UNICODE
    GetProcAddress(pTaskData->hInstComDlg, "GetOpenFileNameW");
#else
    GetProcAddress(pTaskData->hInstComDlg, "GetOpenFileNameA");
#endif
    if (lpfnGetOpenFileName == NULL)
            goto ErrorFreeLibrary;
    return (*lpfnGetOpenFileName)(lpofn);

ErrorFreeLibrary:
    if (pTaskData->hInstComDlg != NULL)
    {
            FreeLibrary(pTaskData->hInstComDlg);
            pTaskData->hInstComDlg = NULL;
    }

Error:
    return FALSE;
}

typedef short (WINAPI* LPFNGETFILETITLE)(LPCTSTR, LPTSTR, WORD);

short StandardGetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf)
{
    TASKDATA* pTaskData = GetTaskData();
    OleDbgAssert(pTaskData != NULL);
    LPFNGETFILETITLE lpfnGetFileTitle;

    if (pTaskData->hInstComDlg == NULL)
    {
        pTaskData->hInstComDlg = LoadLibrary(TEXT("comdlg32.dll"));
        if (pTaskData->hInstComDlg == NULL)
            goto Error;
    }
    lpfnGetFileTitle = (LPFNGETFILETITLE)
#ifdef UNICODE
    GetProcAddress(pTaskData->hInstComDlg, "GetFileTitleW");
#else
    GetProcAddress(pTaskData->hInstComDlg, "GetFileTitleA");
#endif
    if (lpfnGetFileTitle == NULL)
            goto ErrorFreeLibrary;
    return (*lpfnGetFileTitle)(lpszFile, lpszTitle, cbBuf);

ErrorFreeLibrary:
    if (pTaskData->hInstComDlg != NULL)
    {
            FreeLibrary(pTaskData->hInstComDlg);
            pTaskData->hInstComDlg = NULL;
    }

Error:
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\workitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="WorkItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Util {

    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Threading;

//
// Support for positing of work items to a different thread
//

/// <include file='doc\WorkItem.uex' path='docs/doc[@for="WorkItemCallback"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public delegate void WorkItemCallback();

/// <include file='doc\WorkItem.uex' path='docs/doc[@for="WorkItem"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class WorkItem {

    private static bool _useQueueUserWorkItem = true;
    private static WaitCallback _onQueueUserWorkItemCompletion = new WaitCallback(OnQueueUserWorkItemCompletion);

    /// <include file='doc\WorkItem.uex' path='docs/doc[@for="WorkItem.Post"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static void Post(WorkItemCallback callback) {
        InternalSecurityPermissions.UnmanagedCode.Demand();

        if (Environment.OSVersion.Platform != PlatformID.Win32NT)
            throw new PlatformNotSupportedException(SR.GetString(SR.RequiresNT));

        PostInternal(callback);
    }

    private static void OnQueueUserWorkItemCompletion(Object state) {
        WorkItemCallback callback = state as WorkItemCallback;

        if (callback != null) {
            // assert to disregard the user code up the compressed stack
            InternalSecurityPermissions.Unrestricted.Assert();
            // call the callback
            callback();
        }
    }

    internal static void PostInternal(WorkItemCallback callback) {
        if (_useQueueUserWorkItem) {
            ThreadPool.QueueUserWorkItem(_onQueueUserWorkItemCompletion, callback);
        }
        else {
            WrappedWorkItemCallback w = new WrappedWorkItemCallback(callback);
            w.Post();
        }
    }
}

internal class WrappedWorkItemCallback {
    private GCHandle         _rootedThis;
    private WorkItemCallback _originalCallback;
    private WorkItemCallback _wrapperCallback;

    internal WrappedWorkItemCallback(WorkItemCallback callback) {
        _originalCallback = callback;
        _wrapperCallback = new WorkItemCallback(this.OnCallback);
    }

    internal void Post() {
        _rootedThis = GCHandle.Alloc(this);

        if (UnsafeNativeMethods.PostThreadPoolWorkItem(_wrapperCallback) != 1) {
            _rootedThis.Free();
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_post_workitem));
        }
    }

    private void OnCallback() {
        _rootedThis.Free();
        _originalCallback();
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\convert.cpp ===
/*
 * CONVERT.CPP
 *
 * Implements the OleUIConvert function which invokes the complete
 * Convert dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include <stdlib.h>
#include "utility.h"
#include "iconbox.h"
#include "strsafe.h"
#include <reghelp.hxx>

OLEDBGDATA

// Internally used structure
typedef struct tagCONVERT
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUICONVERT  lpOCV;   // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */

        DWORD   dwFlags;            // Flags passed in
        HWND    hListVisible;       // listbox that is currently visible
        HWND    hListInvisible;     // listbox that is currently hidden
        CLSID   clsid;              // Class ID sent in to dialog: IN only
        DWORD   dvAspect;
        BOOL    fCustomIcon;
        UINT    IconIndex;          // index (in exe) of current icon
        LPTSTR  lpszIconSource;     // path to current icon source
        LPTSTR  lpszCurrentObject;
        LPTSTR  lpszConvertDefault;
        LPTSTR  lpszActivateDefault;

} CONVERT, *PCONVERT, FAR *LPCONVERT;

// Internal function prototypes
// CONVERT.CPP

INT_PTR CALLBACK ConvertDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FConvertInit(HWND hDlg, WPARAM, LPARAM);
void SetConvertResults(HWND, LPCONVERT);
UINT FillClassList(CLSID clsid, HWND hList, HWND hListInvisible,
        LPTSTR FAR *lplpszCurrentClass, BOOL fIsLinkedObject, WORD wFormat,
        UINT cClsidExclude, LPCLSID lpClsidExclude, BOOL bAddSameClass);
BOOL FormatIncluded(LPTSTR szStringToSearch, WORD wFormat);
void SwapWindows(HWND, HWND, HWND);
void ConvertCleanup(HWND hDlg, LPCONVERT lpCV);
static void UpdateClassIcon(HWND hDlg, LPCONVERT lpCV, HWND hList);

/*
 * OleUIConvert
 *
 * Purpose:
 *  Invokes the standard OLE Change Type dialog box allowing the user
 *  to change the type of the single specified object, or change the
 *  type of all OLE objects of a specified type.
 *
 * Parameters:
 *  lpCV            LPOLEUICONVERT pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT lpCV)
{
        HGLOBAL  hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpCV, sizeof(OLEUICONVERT),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        if (lpCV->hMetaPict != NULL && !IsValidMetaPict(lpCV->hMetaPict))
        {
            return(OLEUI_CTERR_HMETAPICTINVALID);
        }

        if ((lpCV->dwFlags & CF_SETCONVERTDEFAULT)
                 && (!IsValidClassID(lpCV->clsidConvertDefault)))
           uRet = OLEUI_CTERR_CLASSIDINVALID;

        if ((lpCV->dwFlags & CF_SETACTIVATEDEFAULT)
                 && (!IsValidClassID(lpCV->clsidActivateDefault)))
           uRet = OLEUI_CTERR_CLASSIDINVALID;

        if ((lpCV->dvAspect != DVASPECT_ICON) && (lpCV->dvAspect != DVASPECT_CONTENT))
           uRet = OLEUI_CTERR_DVASPECTINVALID;

        if ((lpCV->wFormat >= CF_CLIPBOARDMIN) && (lpCV->wFormat <= CF_CLIPBOARDMAX))
        {
                TCHAR szTemp[8];
                if (0 == GetClipboardFormatName(lpCV->wFormat, szTemp, 8))
                        uRet = OLEUI_CTERR_CBFORMATINVALID;
        }

        if ((NULL != lpCV->lpszUserType)
                && (IsBadReadPtr(lpCV->lpszUserType, 1)))
                uRet = OLEUI_CTERR_STRINGINVALID;

        if ( (NULL != lpCV->lpszDefLabel)
                && (IsBadReadPtr(lpCV->lpszDefLabel, 1)) )
                uRet = OLEUI_CTERR_STRINGINVALID;

        if (0 != lpCV->cClsidExclude &&
                IsBadReadPtr(lpCV->lpClsidExclude, lpCV->cClsidExclude * sizeof(CLSID)))
        {
                uRet = OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }

        UINT nIDD;
        if (!bWin4)
                nIDD = lpCV->dwFlags & CF_CONVERTONLY ? IDD_CONVERTONLY : IDD_CONVERT;
        else
                nIDD = lpCV->dwFlags & CF_CONVERTONLY ? IDD_CONVERTONLY4 : IDD_CONVERT4;

        // Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(ConvertDialogProc, (LPOLEUISTANDARD)lpCV,
                hMemDlg, MAKEINTRESOURCE(nIDD));
        return uRet;
}

/*
 * ConvertDialogProc
 *
 * Purpose:
 *  Implements the OLE Convert dialog as invoked through the
 *  OleUIConvert function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 *
 */
INT_PTR CALLBACK ConvertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPCONVERT lpCV = (LPCONVERT)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        //If the hook processed the message, we're done.
        if (0 != uRet)
                return (INT_PTR)uRet;

        //Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // Process help message from Change Icon
        if (iMsg == uMsgHelp)
        {
                PostMessage(lpCV->lpOCV->hWndOwner, uMsgHelp, wParam, lParam);
                return FALSE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpCV)
            {
                ConvertCleanup(hDlg, lpCV);
                StandardCleanup(lpCV, hDlg);
            }
            break;
        case WM_INITDIALOG:
                FConvertInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_CV_ACTIVATELIST:
                case IDC_CV_CONVERTLIST:
                        switch (wCode)
                        {
                        case LBN_SELCHANGE:
                                // Change "Results" window to reflect current selection
                                SetConvertResults(hDlg, lpCV);

                                // Update the icon we display, if in display as icon mode
                                if ((lpCV->dwFlags & CF_SELECTCONVERTTO) &&
                                         lpCV->dvAspect == DVASPECT_ICON && !lpCV->fCustomIcon)
                                {
                                        UpdateClassIcon(hDlg, lpCV, hWndMsg);
                                }
                                break;

                        case LBN_DBLCLK:
                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                                break;
                        }
                        break;

                case IDC_CV_CONVERTTO:
                case IDC_CV_ACTIVATEAS:
                        {
                                HWND hList = lpCV->hListVisible;
                                HWND hListInvisible = lpCV->hListInvisible;

                                if (IDC_CV_CONVERTTO == wParam)
                                {
                                        // User just click on the button again - it was
                                        // already selected.
                                        if (lpCV->dwFlags & CF_SELECTCONVERTTO)
                                                break;

                                        // If we're working with a linked object, don't
                                        // add the activate list - just the object's
                                        // class should appear in the listbox.
                                        SwapWindows(hDlg,  hList, hListInvisible);

                                        lpCV->hListVisible = hListInvisible;
                                        lpCV->hListInvisible = hList;

                                        EnableWindow(lpCV->hListInvisible, FALSE);
                                        EnableWindow(lpCV->hListVisible, TRUE);

                                        // Update our flags.
                                        lpCV->dwFlags &= ~CF_SELECTACTIVATEAS;
                                        lpCV->dwFlags |= CF_SELECTCONVERTTO;
                                }
                                else
                                {
                                        if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
                                                break;

                                        SwapWindows(hDlg, hList, hListInvisible);

                                        lpCV->hListVisible = hListInvisible;
                                        lpCV->hListInvisible = hList;

                                        EnableWindow(lpCV->hListInvisible, FALSE);
                                        EnableWindow(lpCV->hListVisible, TRUE);

                                        // Update our flags.
                                        lpCV->dwFlags |= CF_SELECTACTIVATEAS;
                                        lpCV->dwFlags &= ~CF_SELECTCONVERTTO;
                                }

                                LRESULT lRetVal;
                                if (lpCV->dwFlags & CF_SELECTCONVERTTO)
                                        lRetVal = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszConvertDefault);
                                else
                                        lRetVal = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszActivateDefault);

                                if (LB_ERR == lRetVal)
                                {
                                        TCHAR szCurrentObject[40];
                                        GetDlgItemText(hDlg, IDC_CV_OBJECTTYPE, szCurrentObject, 40);
                                        SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)szCurrentObject);
                                }

                                // Turn updates back on.
                                SendMessage(hDlg, WM_SETREDRAW, TRUE, 0L);

                                InvalidateRect(lpCV->hListVisible, NULL, TRUE);
                                UpdateWindow(lpCV->hListVisible);

                                if ((lpCV->dvAspect & DVASPECT_ICON) && (lpCV->dwFlags & CF_SELECTCONVERTTO))
                                        UpdateClassIcon(hDlg, lpCV, lpCV->hListVisible);

                                // Hide the icon stuff when Activate is selected...show
                                // it again when Convert is selected.
                                BOOL fState = ((lpCV->dwFlags & CF_SELECTACTIVATEAS) ||
                                                  (lpCV->dwFlags & CF_DISABLEDISPLAYASICON)) ?
                                                  SW_HIDE : SW_SHOW;

                                StandardShowDlgItem(hDlg, IDC_CV_DISPLAYASICON, fState);

                                // Only display the icon if convert is selected AND
                                // display as icon is checked.
                                if ((SW_SHOW==fState) && (DVASPECT_ICON!=lpCV->dvAspect))
                                   fState = SW_HIDE;

                                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, fState);
                                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, fState);

                                SetConvertResults(hDlg, lpCV);
                        }
                        break;

                case IDOK:
                        {
                                // Set output flags to current ones
                                lpCV->lpOCV->dwFlags = lpCV->dwFlags;

                                // Update the dvAspect and fObjectsIconChanged members
                                // as appropriate.
                                if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
                                {
                                        // DON'T update aspect if activate as was selected.
                                        lpCV->lpOCV->fObjectsIconChanged = FALSE;
                                }
                                else
                                        lpCV->lpOCV->dvAspect = lpCV->dvAspect;

                                // Get the new clsid
                                TCHAR szBuffer[256];
                                LRESULT iCurSel = SendMessage(lpCV->hListVisible, LB_GETCURSEL, 0, 0);
                                SendMessage(lpCV->hListVisible, LB_GETTEXT, iCurSel, (LPARAM)szBuffer);

                                LPTSTR lpszCLSID = PointerToNthField(szBuffer, 2, '\t');
                                CLSIDFromString(lpszCLSID, (&(lpCV->lpOCV->clsidNew)));

                                // Free the hMetaPict we got in.
                                OleUIMetafilePictIconFree(lpCV->lpOCV->hMetaPict);

                                // Get the hMetaPict (if display as icon is checked)
                                if (DVASPECT_ICON == lpCV->dvAspect)
                                        lpCV->lpOCV->hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                                IDC_CV_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                else
                                        lpCV->lpOCV->hMetaPict = (HGLOBAL)NULL;

                                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                        }
                        break;

                case IDCANCEL:
                        {
                            HGLOBAL hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                IDC_CV_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                            OleUIMetafilePictIconFree(hMetaPict);
                            SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        }
                        break;

                case IDC_OLEUIHELP:
                        PostMessage(lpCV->lpOCV->hWndOwner,
                                uMsgHelp, (WPARAM)hDlg, MAKELPARAM(IDD_CONVERT, 0));
                        break;

                case IDC_CV_DISPLAYASICON:
                        {
                                BOOL fCheck = IsDlgButtonChecked(hDlg, wID);
                                if (fCheck)
                                        lpCV->dvAspect = DVASPECT_ICON;
                                else
                                        lpCV->dvAspect = DVASPECT_CONTENT;

                                if (fCheck && !lpCV->fCustomIcon)
                                        UpdateClassIcon(hDlg, lpCV, lpCV->hListVisible);

                                // Show or hide the icon depending on the check state.
                                int i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
                                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, i);
                                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, i);
                                SetConvertResults(hDlg, lpCV);
                        }
                        break;

                case IDC_CV_CHANGEICON:
                        {
                                // Initialize the structure for the hook.
                                OLEUICHANGEICON ci; memset(&ci, 0, sizeof(ci));

                                ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                        IDC_CV_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                ci.cbStruct = sizeof(ci);
                                ci.hWndOwner= hDlg;
                                ci.dwFlags  = CIF_SELECTCURRENT;

                                // Only show help if we're showing it for this dialog.
                                if (lpCV->dwFlags & CF_SHOWHELPBUTTON)
                                        ci.dwFlags |= CIF_SHOWHELP;

                                int iSel = (INT)SendMessage(lpCV->hListVisible, LB_GETCURSEL, 0, 0);

                                // Get whole string
                                LPTSTR pszString = (LPTSTR)OleStdMalloc(
                                        OLEUI_CCHLABELMAX_SIZE + OLEUI_CCHCLSIDSTRING_SIZE);

                                SendMessage(lpCV->hListVisible, LB_GETTEXT, iSel, (LPARAM)pszString);

                                // Set pointer to CLSID (string)
                                LPTSTR pszCLSID = PointerToNthField(pszString, 2, '\t');

                                // Get the clsid to pass to change icon.
                                CLSIDFromString(pszCLSID, &(ci.clsid));
                                OleStdFree(pszString);

                                // Let the hook in to customize Change Icon if desired.
                                uRet = UStandardHook(lpCV, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);

                                if (0 == uRet)
                                        uRet= (OLEUI_OK == OleUIChangeIcon(&ci));

                                // Update the display if necessary.
                                if (0 != uRet)
                                {
                                        SendDlgItemMessage(hDlg, IDC_CV_ICONDISPLAY, IBXM_IMAGESET, 0,
                                                (LPARAM)ci.hMetaPict);

                                        // Update our custom/default flag
                                        if (ci.dwFlags & CIF_SELECTDEFAULT)
                                                lpCV->fCustomIcon = FALSE;   // we're in default mode (icon changes on each LB selchange)
                                        else if (ci.dwFlags & CIF_SELECTFROMFILE)
                                                lpCV->fCustomIcon = TRUE;    // we're in custom mode (icon doesn't change)

                                        // no change in fCustomIcon if user selected current
                                        lpCV->lpOCV->fObjectsIconChanged = TRUE;
                                }
                        }
                        break;
                }
                break;
        }

        return FALSE;
}

/*
 * FConvertInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Convert dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FConvertInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;  // non-bold version of dialog's font
        LPCONVERT lpCV = (LPCONVERT)LpvStandardInit(hDlg, sizeof(CONVERT), &hFont);

        // PvStandardInit send a termination to us already.
        if (NULL == lpCV)
                return FALSE;

        LPOLEUICONVERT lpOCV = (LPOLEUICONVERT)lParam;
        lpCV->lpOCV = lpOCV;
        lpCV->nIDD = IDD_CONVERT;
        lpCV->fCustomIcon = FALSE;

        // Copy other information from lpOCV that we might modify.
        lpCV->dwFlags = lpOCV->dwFlags;
        lpCV->clsid = lpOCV->clsid;
        lpCV->dvAspect = lpOCV->dvAspect;
        lpCV->hListVisible = GetDlgItem(hDlg, IDC_CV_ACTIVATELIST);
        lpCV->hListInvisible = GetDlgItem(hDlg, IDC_CV_CONVERTLIST);
        OleDbgAssert(lpCV->hListInvisible != NULL);
        lpCV->lpszCurrentObject = lpOCV->lpszUserType;
        lpOCV->clsidNew = CLSID_NULL;
        lpOCV->fObjectsIconChanged = FALSE;

        lpCV->lpszConvertDefault = (LPTSTR)OleStdMalloc(OLEUI_CCHLABELMAX_SIZE);
        lpCV->lpszActivateDefault = (LPTSTR)OleStdMalloc(OLEUI_CCHLABELMAX_SIZE);
        lpCV->lpszIconSource = (LPTSTR)OleStdMalloc(MAX_PATH_SIZE);

		if ((lpCV->lpszConvertDefault == NULL)  ||
			(lpCV->lpszActivateDefault == NULL) ||
		    (lpCV->lpszIconSource == NULL))
		{
			if (lpCV->lpszConvertDefault != NULL)
				OleStdFree (lpCV->lpszConvertDefault);
			if (lpCV->lpszActivateDefault != NULL)
				OleStdFree (lpCV->lpszActivateDefault);
			if (lpCV->lpszIconSource != NULL)
				OleStdFree (lpCV->lpszIconSource);
			
			// Gonna kill the window...
			PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
			return FALSE;
		}

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                SendDlgItemMessage(hDlg, IDC_CV_OBJECTTYPE, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_CV_RESULTTEXT, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Hide the help button if necessary
        if (!(lpCV->dwFlags & CF_SHOWHELPBUTTON))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Show or hide the Change icon button
        if (lpCV->dwFlags & CF_HIDECHANGEICON)
                DestroyWindow(GetDlgItem(hDlg, IDC_CV_CHANGEICON));

        // Fill the Object Type listbox with entries from the reg DB.
        UINT nRet = FillClassList(lpOCV->clsid, lpCV->hListVisible,
                lpCV->hListInvisible, &(lpCV->lpszCurrentObject),
                lpOCV->fIsLinkedObject, lpOCV->wFormat,
                lpOCV->cClsidExclude, lpOCV->lpClsidExclude,
                !(lpCV->dwFlags & CF_CONVERTONLY));

        if (nRet == -1)
        {
                // bring down dialog if error when filling list box
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
        }

        // Set the name of the current object.
        SetDlgItemText(hDlg, IDC_CV_OBJECTTYPE, lpCV->lpszCurrentObject);

        // Disable the "Activate As" button if the Activate list doesn't
        // have any objects in it.
        int cItemsActivate = (INT)SendMessage(lpCV->hListVisible, LB_GETCOUNT, 0, 0L);
        if (1 >= cItemsActivate || (lpCV->dwFlags & CF_DISABLEACTIVATEAS))
                StandardEnableDlgItem(hDlg, IDC_CV_ACTIVATEAS, FALSE);

        // Set the tab width in the list to push all the tabs off the side.
        RECT rect;
        if (lpCV->hListVisible != NULL)
                GetClientRect(lpCV->hListVisible, &rect);
        else
                GetClientRect(lpCV->hListInvisible, &rect);
        DWORD dw = GetDialogBaseUnits();
        rect.right = (8*rect.right)/LOWORD(dw);  //Convert pixels to 2x dlg units.
        if (lpCV->hListVisible != NULL)
                SendMessage(lpCV->hListVisible, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)(&rect.right));
        SendMessage(lpCV->hListInvisible, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)(&rect.right));

        // Make sure that either "Convert To" or "Activate As" is selected
        // and initialize listbox contents and selection accordingly
        if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
        {
                // Don't need to adjust listbox here because FillClassList
                // initializes to the "Activate As" state.
                CheckRadioButton(hDlg, IDC_CV_CONVERTTO, IDC_CV_ACTIVATEAS, IDC_CV_ACTIVATEAS);

                // Hide the icon stuff when Activate is selected...it gets shown
                // again when Convert is selected.
                StandardShowDlgItem(hDlg, IDC_CV_DISPLAYASICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, SW_HIDE);
        }
        else
        {
                // Default case.  If user hasn't selected either flag, we will
                // come here anyway.
                // swap listboxes.

                HWND hWndTemp = lpCV->hListVisible;

                if (lpCV->dwFlags & CF_DISABLEDISPLAYASICON)
                {
                        StandardShowDlgItem(hDlg, IDC_CV_DISPLAYASICON, SW_HIDE);
                        StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, SW_HIDE);
                        StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, SW_HIDE);
                }

                lpCV->dwFlags |= CF_SELECTCONVERTTO; // Make sure flag is set
                if (!(lpCV->dwFlags & CF_CONVERTONLY))
                        CheckRadioButton(hDlg, IDC_CV_CONVERTTO, IDC_CV_ACTIVATEAS, IDC_CV_CONVERTTO);

                SwapWindows(hDlg, lpCV->hListVisible, lpCV->hListInvisible);

                lpCV->hListVisible = lpCV->hListInvisible;
                lpCV->hListInvisible = hWndTemp;

                if (lpCV->hListInvisible)
                        EnableWindow(lpCV->hListInvisible, FALSE);
                EnableWindow(lpCV->hListVisible, TRUE);
        }

        // Initialize Default strings.

        // Default convert string is easy...just user the user type name from
        // the clsid we got, or the current object
        if ((lpCV->dwFlags & CF_SETCONVERTDEFAULT)
                 && (IsValidClassID(lpCV->lpOCV->clsidConvertDefault)))
        {
                LPOLESTR lpszTemp = NULL;
                if (OleRegGetUserType(lpCV->lpOCV->clsidConvertDefault, USERCLASSTYPE_FULL,
                        &lpszTemp) == NOERROR)
                {
                        StringCchCopy(lpCV->lpszConvertDefault, OLEUI_CCHLABELMAX, lpszTemp);
                        OleStdFree(lpszTemp);
                }
                else
                {
                   StringCchCopy(lpCV->lpszConvertDefault, OLEUI_CCHLABELMAX, lpCV->lpszCurrentObject);
                }
        }
        else
                StringCchCopy(lpCV->lpszConvertDefault, OLEUI_CCHLABELMAX,
						(lpCV->lpszCurrentObject ? lpCV->lpszCurrentObject : TEXT("")));


        // Default activate is a bit trickier.  We want to use the user type
        // name if from the clsid we got (assuming we got one), or the current
        // object if it fails or we didn't get a clsid.  But...if there's a
        // Treat As entry in the reg db, then we use that instead.  So... the
        // logic boils down to this:
        //
        // if ("Treat As" in reg db)
        //    use it;
        // else
        //    if (CF_SETACTIVATEDEFAULT)
        //      use it;
        //    else
        //      use current object;

        HKEY hKey;
		
		LONG lRet = OpenClassesRootKey(TEXT("CLSID"), &hKey);
        LPARAM lpRet;

        if (lRet != ERROR_SUCCESS)
                goto CheckInputFlag;

        LPOLESTR lpszCLSID;
        StringFromCLSID(lpCV->lpOCV->clsid, &lpszCLSID);
        TCHAR szKey[OLEUI_CCHKEYMAX];
        StringCchCopy(szKey, OLEUI_CCHCLSIDSTRING+1, lpszCLSID);
        StringCchCat(szKey, OLEUI_CCHKEYMAX, TEXT("\\TreatAs"));
        OleStdFree(lpszCLSID);

        TCHAR szValue[OLEUI_CCHKEYMAX];
        dw = OLEUI_CCHKEYMAX_SIZE;
        lRet = RegQueryValue(hKey, szKey, szValue, (LONG*)&dw);

        CLSID clsid;
        if (lRet != ERROR_SUCCESS)
        {
                RegCloseKey(hKey);
                goto CheckInputFlag;
        }
        else
        {
                CLSIDFromString(szValue, &clsid);
                LPOLESTR lpszTemp = NULL;
                if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &lpszTemp) == NOERROR)
                {
			if (lpCV->lpszActivateDefault)
			{
                            lstrcpyn(lpCV->lpszActivateDefault, lpszTemp, OLEUI_CCHLABELMAX);
			}
                     OleStdFree(lpszTemp);
                }
                else
                {
                        RegCloseKey(hKey);
                        goto CheckInputFlag;
                }
        }
        RegCloseKey(hKey);
        goto SelectStringInListbox;

CheckInputFlag:
        if ((lpCV->dwFlags & CF_SETACTIVATEDEFAULT)
                 && (IsValidClassID(lpCV->lpOCV->clsidActivateDefault)))
        {
                LPOLESTR lpszTemp = NULL;
                if (OleRegGetUserType(lpCV->lpOCV->clsidActivateDefault, USERCLASSTYPE_FULL,
                        &lpszTemp) == NOERROR)
                {
                        lstrcpyn(lpCV->lpszActivateDefault, lpszTemp, OLEUI_CCHLABELMAX);
                        OleStdFree(lpszTemp);
                }
                else
                {
                   StringCchCopy(lpCV->lpszActivateDefault, OLEUI_CCHLABELMAX, lpCV->lpszCurrentObject);
                }
        }
        else
			if ((lpCV->lpszActivateDefault) && (lpCV->lpszCurrentObject))
                StringCchCopy((lpCV->lpszActivateDefault), OLEUI_CCHLABELMAX, lpCV->lpszCurrentObject);



SelectStringInListbox:
        if (lpCV->dwFlags & CF_SELECTCONVERTTO)
           lpRet = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszConvertDefault);
        else
           lpRet = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszActivateDefault);

        if (LB_ERR == lpRet)
           SendMessage(lpCV->hListVisible, LB_SETCURSEL, (WPARAM)0, 0L);

        if ((HGLOBAL)NULL != lpOCV->hMetaPict)
        {
                HGLOBAL hMetaPict = OleDuplicateData(lpOCV->hMetaPict, CF_METAFILEPICT, NULL);
                SendDlgItemMessage(hDlg, IDC_CV_ICONDISPLAY, IBXM_IMAGESET,
                        0, (LPARAM)hMetaPict);
                lpCV->fCustomIcon = TRUE;
        }
        else
        {
                UpdateClassIcon(hDlg, lpCV, lpCV->hListVisible);
        }

        // Initialize icon stuff
        if (DVASPECT_ICON == lpCV->dvAspect )
        {
                SendDlgItemMessage(hDlg, IDC_CV_DISPLAYASICON, BM_SETCHECK, TRUE, 0L);
        }
        else
        {
                // Hide & disable icon stuff
                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, SW_HIDE);
        }

        // Call the hook with lCustData in lParam
        UStandardHook((LPVOID)lpCV, hDlg, WM_INITDIALOG, wParam, lpOCV->lCustData);

        // Update results window
        SetConvertResults(hDlg, lpCV);

        // Update caption if lpszCaption was specified
        if (lpCV->lpOCV->lpszCaption && !IsBadReadPtr(lpCV->lpOCV->lpszCaption, 1))
        {
                SetWindowText(hDlg, lpCV->lpOCV->lpszCaption);
        }

        return TRUE;
}

/*
 * FillClassList
 *
 * Purpose:
 *  Enumerates available OLE object classes from the registration
 *  database that we can convert or activate the specified clsid from.
 *
 *  Note that this function removes any prior contents of the listbox.
 *
 * Parameters:
 *  clsid           Class ID for class to find convert classes for
 *  hList           HWND to the listbox to fill.
 *  hListActivate   HWND to invisible listbox that stores "activate as" list.
 *  lpszClassName   LPSTR to put the (hr) class name of the clsid; we
 *                  do it here since we've already got the reg db open.
 *  fIsLinkedObject BOOL is the original object a linked object
 *  wFormat         WORD specifying the format of the original class.
 *  cClsidExclude   UINT number of entries in exclude list
 *  lpClsidExclude  LPCLSID array classes to exclude for list
 *
 * Return Value:
 *  UINT            Number of strings added to the listbox, -1 on failure.
 */
UINT FillClassList(CLSID clsid, HWND hListActivate, HWND hListConvert,
        LPTSTR FAR *lplpszCurrentClass, BOOL fIsLinkedObject,
        WORD wFormat, UINT cClsidExclude, LPCLSID lpClsidExclude, BOOL bAddSameClass)
{
        // Clean out the existing strings.
        if (hListActivate)
                SendMessage(hListActivate, LB_RESETCONTENT, 0, 0L);

        OleDbgAssert(hListConvert != NULL);
        SendMessage(hListConvert, LB_RESETCONTENT, 0, 0L);

        // Open up the root key.
        HKEY hKey;
        LONG lRet = OpenClassesRootKey(TEXT("CLSID"), &hKey);
        LPARAM lpRet;

        if (ERROR_SUCCESS != lRet)
                return (UINT)-1;

        if (NULL == *lplpszCurrentClass)
        {
                if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, lplpszCurrentClass) != NOERROR)
                {
                        *lplpszCurrentClass = OleStdLoadString(_g_hOleStdResInst, IDS_PSUNKNOWNTYPE);
                        if (*lplpszCurrentClass == NULL)
                        {
                                RegCloseKey(hKey);
                                return (UINT)-1;
                        }
                }
        }

        // Get the class name of the original class.
        LPTSTR lpszCLSID;
        StringFromCLSID(clsid, &lpszCLSID);
        // Here, we step through the entire registration db looking for
        // class that can read or write the original class' format.  We
        // maintain two lists - an activate list and a convert list.  The
        // activate list is a subset of the convert list - activate == read/write
        // and convert == read. We swap the listboxes as needed with
        // SwapWindows, and keep track of which is which in the lpCV structure.

        // Every item has the following format:
        //
        //     Class Name\tclsid\0

        UINT cStrings = 0;
        TCHAR szClass[OLEUI_CCHKEYMAX];
        lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));

        TCHAR szFormatKey[OLEUI_CCHKEYMAX];
        TCHAR szFormat[OLEUI_CCHKEYMAX];
        TCHAR szHRClassName[OLEUI_CCHKEYMAX];
        CLSID clsidForList;

        while (ERROR_SUCCESS == lRet)
        {
                UINT j;
                BOOL fExclude = FALSE;                

                //Check if this CLSID is in the exclusion list.
                HRESULT hr = CLSIDFromString(szClass, &clsidForList);
                if (SUCCEEDED(hr))
                {
                    for (j = 0; j < cClsidExclude; j++)
                    {
                        if (IsEqualCLSID(clsidForList, lpClsidExclude[j]))
                        {
                            fExclude=TRUE;
                            break;
                        }
                    }
                    if (fExclude)
                        goto Next;   // don't add this class to list
                }

                // Check for a \Conversion\Readwritable\Main - if its
                // readwriteable, then the class can be added to the ActivateAs
                // list.
                // NOTE: the presence of this key should NOT automatically be
                //       used to add the class to the CONVERT list.
                StringCchCopy(szFormatKey, OLEUI_CCHCLSIDSTRING+1, szClass);
                StringCchCat(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), TEXT("\\Conversion\\Readwritable\\Main"));

                DWORD dw; dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                {
                        // Here, we've got a list of formats that this class can read
                        // and write. We need to see if the original class' format is
                        // in this list.  We do that by looking for wFormat in
                        // szFormat - if it in there, then we add this class to the
                        // ACTIVATEAS list only. we do NOT automatically add it to the
                        // CONVERT list. Readable and Readwritable format lists should
                        // be handled separately.

                        dw=OLEUI_CCHKEYMAX_SIZE;
                        lRet=RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);

                        if (ERROR_SUCCESS == lRet && hListActivate != NULL)
                        {
                                // only add if not already in list
                                StringCchCat(szHRClassName, sizeof(szHRClassName)/sizeof(szHRClassName[0]), TEXT("\t"));
                                if (LB_ERR == SendMessage(hListActivate, LB_FINDSTRING, 0, (LPARAM)szHRClassName))
                                {
                                        StringCchCat(szHRClassName, sizeof(szHRClassName)/sizeof(szHRClassName[0]), szClass);
                                        SendMessage(hListActivate, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
                                }
                        }
                }

                // Here we'll check to see if the original class' format is in the
                // readable list. if so, we will add the class to the CONVERTLIST

                // We've got a special case for a linked object here.
                // If an object is linked, then the only class that
                // should appear in the convert list is the object's
                // class.  So, here we check to see if the object is
                // linked.  If it is, then we compare the classes.  If
                // they aren't the same, then we just go to the next key.

                if (!fIsLinkedObject || lstrcmp(lpszCLSID, szClass) == 0)
                {
                        //Check for a \Conversion\Readable\Main entry
                        StringCchCopy(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), szClass);
                        StringCchCat(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), TEXT("\\Conversion\\Readable\\Main"));

                        // Check to see if this class can read the original class
                        // format.  If it can, add the string to the listbox as
                        // CONVERT_LIST.

                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                        if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                        {
                                dw = OLEUI_CCHKEYMAX_SIZE;
                                lRet = RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);

                                if (ERROR_SUCCESS == lRet)
                                {
                                        // only add if not already in list
                                        StringCchCat(szHRClassName, sizeof(szHRClassName)/sizeof(szHRClassName[0]), TEXT("\t"));
                                        if (LB_ERR == SendMessage(hListConvert, LB_FINDSTRING, 0, (LPARAM)szHRClassName))
                                        {
                                                StringCchCat(szHRClassName, sizeof(szHRClassName)/sizeof(szHRClassName[0]), szClass);
                                                SendMessage(hListConvert, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
                                        }
                                }
                        }
                }
Next:
                //Continue with the next key.
                lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));

        }  // end while

        // If the original class isn't already in the list, add it.
        if (bAddSameClass)
        {
                StringCchCopy(szHRClassName,  sizeof(szHRClassName)/sizeof(szHRClassName[0]), *lplpszCurrentClass); // -1 so we know we have enough room for "\t"
                StringCchCat(szHRClassName,  sizeof(szHRClassName)/sizeof(szHRClassName[0]), TEXT("\t"));
                StringCchCat(szHRClassName,  sizeof(szHRClassName)/sizeof(szHRClassName[0]), lpszCLSID);

                if (hListActivate != NULL)
                {
                        // only add it if it's not there already.
                        lpRet = SendMessage(hListActivate, LB_FINDSTRING, (WPARAM)-1, (LPARAM)szHRClassName);
                        if (LB_ERR == lpRet)
                                SendMessage(hListActivate, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
                }

                // only add it if it's not there already.
                lpRet = SendMessage(hListConvert, LB_FINDSTRING, (WPARAM)-1, (LPARAM)szHRClassName);
                if (LB_ERR == lpRet)
                        SendMessage(hListConvert, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
        }

        // Free the string we got from StringFromCLSID.
        OleStdFree(lpszCLSID);
        RegCloseKey(hKey);

        return cStrings;        // return # of strings added
}

/*
 * OleUICanConvertOrActivateAs
 *
 * Purpose:
 *  Determine if there is any OLE object class from the registration
 *  database that we can convert or activate the specified clsid from.
 *
 * Parameters:
 *  rClsid          REFCLSID Class ID for class to find convert classes for
 *  fIsLinkedObject BOOL is the original object a linked object
 *  wFormat         WORD specifying the format of the original class.
 *
 * Return Value:
 *  BOOL            TRUE if Convert command should be enabled, else FALSE
 */
STDAPI_(BOOL) OleUICanConvertOrActivateAs(
        REFCLSID rClsid, BOOL fIsLinkedObject, WORD wFormat)
{
        // Open up the root key.
        HKEY hKey;
        HRESULT hr;
        LONG lRet = OpenClassesRootKey(TEXT("CLSID"), &hKey);

        if (ERROR_SUCCESS != lRet)
                return FALSE;

        // Get the class name of the original class.
        LPTSTR lpszCLSID = NULL;
        hr = StringFromCLSID(rClsid, &lpszCLSID);
	if (FAILED(hr) || lpszCLSID == NULL) //out of memory, most likely
	    return FALSE;

        // Here, we step through the entire registration db looking for
        // class that can read or write the original class' format.
        // This loop stops if a single class is found.

        UINT cStrings = 0;
        TCHAR szClass[OLEUI_CCHKEYMAX];
        lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));

        TCHAR szFormatKey[OLEUI_CCHKEYMAX];
        TCHAR szFormat[OLEUI_CCHKEYMAX];
        TCHAR szHRClassName[OLEUI_CCHKEYMAX];
        BOOL fEnableConvert = FALSE;

        while (ERROR_SUCCESS == lRet)
        {
                if (lstrcmp(lpszCLSID, szClass) == 0)
                        goto next;   // we don't want to consider the source class

                // Check for a \Conversion\ReadWriteable\Main entry first - if its
                // readwriteable, then we don't need to bother checking to see if
                // its readable.

                StringCchCopy(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), szClass);
                StringCchCat(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), TEXT("\\Conversion\\Readwritable\\Main"));
                DWORD dw; dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                if (ERROR_SUCCESS != lRet)
                {
                        // Try \\DataFormats\DefaultFile too
                        StringCchCopy(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), szClass);
                        StringCchCat(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), TEXT("\\DataFormats\\DefaultFile"));
                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);
                }

                if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                {
                        // Here, we've got a list of formats that this class can read
                        // and write. We need to see if the original class' format is
                        // in this list.  We do that by looking for wFormat in
                        // szFormat - if it in there, then we add this class to the
                        // both lists and continue.  If not, then we look at the
                        // class' readable formats.

                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);
                        if (ERROR_SUCCESS == lRet)
                        {
                                fEnableConvert = TRUE;
                                break;  // STOP -- found one!
                        }
                }

                // We either didn't find the readwritable key, or the
                // list of readwritable formats didn't include the
                // original class format.  So, here we'll check to
                // see if its in the readable list.

                // We've got a special case for a linked object here.
                // If an object is linked, then the only class that
                // should appear in the convert list is the object's
                // class.  So, here we check to see if the object is
                // linked.  If it is, then we compare the classes.  If
                // they aren't the same, then we just go to the next key.

                else if (!fIsLinkedObject || lstrcmp(lpszCLSID, szClass) == 0)
                {
                        // Check for a \Conversion\Readable\Main entry
                        StringCchCopy(szFormatKey,  sizeof(szFormatKey)/sizeof(szFormatKey[0]), szClass);
                        StringCchCat(szFormatKey, sizeof(szFormatKey)/sizeof(szFormatKey[0]), TEXT("\\Conversion\\Readable\\Main"));

                        // Check to see if this class can read the original class format.
                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                        if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                        {
                                dw = OLEUI_CCHKEYMAX_SIZE;
                                lRet = RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);
                                if (ERROR_SUCCESS == lRet)
                                {
                                        fEnableConvert = TRUE;
                                        break;  // STOP -- found one!
                                }
                        }
                }
next:
                // Continue with the next key.
                lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));
        }

        // Free the string we got from StringFromCLSID.
        OleStdFree(lpszCLSID);
        RegCloseKey(hKey);

        return fEnableConvert;
}

/*
 * FormatIncluded
 *
 * Purpose:
 *  Parses the string for format from the word.
 *
 * Parameters:
 *  szStringToSearch  String to parse
 *  wFormat           format to find
 *
 * Return Value:
 *  BOOL        TRUE if format is found in string,
 *              FALSE otherwise.
 */
BOOL FormatIncluded(LPTSTR szStringToSearch, WORD wFormat)
{
        TCHAR szFormat[255];
        if (wFormat < 0xC000)
                StringCchPrintf(szFormat, sizeof(szFormat)/sizeof(szFormat[0]), TEXT("%d"), wFormat);
        else
                GetClipboardFormatName(wFormat, szFormat, 255);

        LPTSTR lpToken = szStringToSearch;
        while (lpToken != NULL)
        {
                LPTSTR lpTokenNext = FindChar(lpToken, TEXT(','));
                if (lpTokenNext != NULL)
                {
                        *lpTokenNext = 0;
                        ++lpTokenNext;
                }
                if (0 == lstrcmpi(lpToken, szFormat))
                        return TRUE;

                lpToken = lpTokenNext;
        }
        return FALSE;
}

/*
 * UpdateClassIcon
 *
 * Purpose:
 *  Handles LBN_SELCHANGE for the Object Type listbox.  On a selection
 *  change, we extract an icon from the server handling the currently
 *  selected object type using the utility function HIconFromClass.
 *  Note that we depend on the behavior of FillClassList to stuff the
 *  object class after a tab in the listbox string that we hide from
 *  view (see WM_INITDIALOG).
 *
 * Parameters
 *  hDlg            HWND of the dialog box.
 *  lpCV            LPCONVERT pointing to the dialog structure
 *  hList           HWND of the Object Type listbox.
 *
 * Return Value:
 *  None
 */
static void UpdateClassIcon(HWND hDlg, LPCONVERT lpCV, HWND hList)
{
        if (GetDlgItem(hDlg, IDC_CV_ICONDISPLAY) == NULL)
                return;

        // Get current selection in the list box
        int iSel= (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        if (LB_ERR == iSel)
                return;

        // Allocate a string to hold the entire listbox string
        DWORD cb = (DWORD)SendMessage(hList, LB_GETTEXTLEN, iSel, 0L);
        LPTSTR pszName = (LPTSTR)OleStdMalloc((cb+1) * sizeof(TCHAR));
        if (pszName == NULL)
                return;

        // Get whole string
        SendMessage(hList, LB_GETTEXT, iSel, (LPARAM)pszName);

        // Set pointer to CLSID (string)
        LPTSTR pszCLSID = PointerToNthField(pszName, 2, '\t');

        // Create the class ID with this string.
        CLSID clsid;
        HRESULT hr = CLSIDFromString(pszCLSID, &clsid);
        if (SUCCEEDED(hr))
        {
            // Get Icon for that CLSID
            HGLOBAL hMetaPict = OleGetIconOfClass(clsid, NULL, TRUE);

            // Replace current icon with the new one.
            SendDlgItemMessage(hDlg, IDC_CV_ICONDISPLAY, IBXM_IMAGESET, 1,
                               (LPARAM)hMetaPict);
        }

        OleStdFree(pszName);
}

/*
 * SetConvertResults
 *
 * Purpose:
 *  Centralizes setting of the Result display in the Convert
 *  dialog.  Handles loading the appropriate string from the module's
 *  resources and setting the text, displaying the proper result picture,
 *  and showing the proper icon.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *  lpCV            LPCONVERT in which we assume that the dwFlags is
 *                  set to the appropriate radio button selection, and
 *                  the list box has the appropriate class selected.
 *
 * Return Value:
 *  None
 */
void SetConvertResults(HWND hDlg, LPCONVERT lpCV)
{
        HWND hList = lpCV->hListVisible;

        /*
         * We need scratch memory for loading the stringtable string, loading
         * the object type from the listbox, loading the source object
         * type, and constructing the final string.  We therefore allocate
         * four buffers as large as the maximum message length (512) plus
         * the object type, guaranteeing that we have enough
         * in all cases.
         */
        UINT i = (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        UINT cch = 512+(UINT)SendMessage(hList, LB_GETTEXTLEN, i, 0L);
        HGLOBAL hMem = GlobalAlloc(GHND, (DWORD)(4*cch)*sizeof(TCHAR));
        if (NULL == hMem)
                return;

        LPTSTR lpszOutput = (LPTSTR)GlobalLock(hMem);
        LPTSTR lpszSelObj = lpszOutput + cch;
        LPTSTR lpszDefObj = lpszSelObj + cch;
        LPTSTR lpszString = lpszDefObj + cch;

        // Get selected object and null terminate human-readable name (1st field).
        SendMessage(hList, LB_GETTEXT, i, (LPARAM)lpszSelObj);

        LPTSTR pszT = PointerToNthField(lpszSelObj, 2, '\t');
        pszT = CharPrev(lpszSelObj, pszT);
        *pszT = '\0';

        // Get default object
        GetDlgItemText(hDlg, IDC_CV_OBJECTTYPE, lpszDefObj, 512);

        //Default is an empty string.
        *lpszOutput=0;

        if (lpCV->dwFlags & CF_SELECTCONVERTTO)
        {
                if (lpCV->lpOCV->fIsLinkedObject)  // working with linked object
                        LoadString(_g_hOleStdResInst, IDS_CVRESULTCONVERTLINK, lpszOutput, cch);
                else
                {
                        if (0 !=lstrcmp(lpszDefObj, lpszSelObj))
                        {
                                // converting to a new class
                                if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTCONVERTTO, lpszString, cch))
                                        FormatString2(lpszOutput, lpszString, lpszDefObj, lpszSelObj, cch);
                        }
                        else
                        {
                                // converting to the same class (no conversion)
                                if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTNOCHANGE, lpszString, cch))
                                        StringCchPrintf(lpszOutput, cch, lpszString, lpszDefObj);
                        }
                }

                if (lpCV->dvAspect == DVASPECT_ICON)  // Display as icon is checked
                {
                   if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTDISPLAYASICON, lpszString, cch))
                                StringCchCat(lpszOutput, cch, lpszString);
                }
        }

        if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
        {
           if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTACTIVATEAS, lpszString, cch))
                        FormatString2(lpszOutput, lpszString, lpszDefObj, lpszSelObj, cch);

           // activating as a new class
           if (0 != lstrcmp(lpszDefObj, lpszSelObj))
           {
                        if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTACTIVATEDIFF, lpszString, cch))
                                StringCchCat(lpszOutput, cch, lpszString);
           }
           else // activating as itself.
           {
                        StringCchCat(lpszOutput, cch, TEXT("."));
           }
        }

        // If LoadString failed, we simply clear out the results (*lpszOutput=0 above)
        SetDlgItemText(hDlg, IDC_CV_RESULTTEXT, lpszOutput);

        GlobalUnlock(hMem);
        GlobalFree(hMem);
}

/*
 * ConvertCleanup
 *
 * Purpose:
 *  Performs convert-specific cleanup before Convert termination.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *
 * Return Value:
 *  None
 */
void ConvertCleanup(HWND hDlg, LPCONVERT lpCV)
{
        // Free our strings. Zero out the user type name string
        // the the calling app doesn't free to it.

        OleStdFree((LPVOID)lpCV->lpszConvertDefault);
        OleStdFree((LPVOID)lpCV->lpszActivateDefault);
        OleStdFree((LPVOID)lpCV->lpszIconSource);
        if (lpCV->lpOCV->lpszUserType)
        {
                OleStdFree((LPVOID)lpCV->lpOCV->lpszUserType);
                lpCV->lpOCV->lpszUserType = NULL;
        }

        if (lpCV->lpOCV->lpszDefLabel)
        {
                OleStdFree((LPVOID)lpCV->lpOCV->lpszDefLabel);
                lpCV->lpOCV->lpszDefLabel = NULL;
        }
}

/*
 * SwapWindows
 *
 * Purpose:
 *  Moves hWnd1 to hWnd2's position and hWnd2 to hWnd1's position.
 *  Does NOT change sizes.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can turn redraw off
 *
 * Return Value:
 *  None
 */
void SwapWindows(HWND hDlg, HWND hWnd1, HWND hWnd2)
{
        if (hWnd1 != NULL && hWnd2 != NULL)
        {
                RECT rect1; GetWindowRect(hWnd1, &rect1);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rect1, 2);

                RECT rect2; GetWindowRect(hWnd2, &rect2);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rect2, 2);

                SetWindowPos(hWnd1, NULL,
                        rect2.left, rect2.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
                SetWindowPos(hWnd2, NULL,
                        rect1.left, rect1.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\util\wildcard.cs ===
//------------------------------------------------------------------------------
// <copyright file="Wildcard.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Wildcard
 * 
 * wildcard wrappers for Regex
 *
 * (1) Wildcard does straight string wildcarding with no path separator awareness
 * (2) WildcardUrl recognizes that forward / slashes are special and can't match * or ?
 * (3) WildcardDos recognizes that backward \ and : are special and can't match * or ?
 * 
 * Copyright (c) 1999, Microsoft Corporation
 */
namespace System.Web.Util {
    using System.Runtime.Serialization.Formatters;
    using System.Text.RegularExpressions;

    /*
     * Wildcard
     *
     * Wildcard patterns have three metacharacters:
     *
     * A ? is equivalent to .
     * A * is equivalent to .*
     * A , is equivalent to |
     *
     * Note that by each alternative is surrounded by \A...\z to anchor
     * at the edges of the string.
     */
    internal class Wildcard {
        internal /*public*/ Wildcard(String pattern) : this (pattern, false) {
        }

        internal /*public*/ Wildcard(String pattern, bool caseInsensitive) {
            _pattern = pattern;
            _caseInsensitive = caseInsensitive;
        }

        internal String _pattern;
        internal bool _caseInsensitive;
        internal Regex _regex;

        protected static Regex metaRegex = new Regex("[\\+\\{\\\\\\[\\|\\(\\)\\.\\^\\$]");
        protected static Regex questRegex = new Regex("\\?");
        protected static Regex starRegex = new Regex("\\*");
        protected static Regex commaRegex = new Regex(",");
        protected static Regex slashRegex = new Regex("(?=/)");
        protected static Regex backslashRegex = new Regex("(?=[\\\\:])");

        /*
         * IsMatch returns true if the input is an exact match for the
         * wildcard pattern.
         */
        internal /*public*/ bool IsMatch(String input) {
            EnsureRegex();

            bool result =  _regex.IsMatch(input);

            return result;
        }

        internal /*public*/ String Pattern {
            get {
                return _pattern;
            }
        }

        /*
         * Builds the matching regex when needed
         */
        protected void EnsureRegex() {
            // threadsafe without protection because of gc

            if (_regex != null)
                return;

            _regex = RegexFromWildcard(_pattern, _caseInsensitive);
        }

        /*
         * Basic wildcard -> Regex conversion, no slashes
         */
        protected virtual Regex RegexFromWildcard(String pattern, bool caseInsensitive) {
            RegexOptions options = RegexOptions.None;

            // match right-to-left (for speed) if the pattern starts with a *

            if (pattern.Length > 0 && pattern[0] == '*')
                options = RegexOptions.RightToLeft | RegexOptions.Singleline;
            else
                options = RegexOptions.Singleline;

            // case insensitivity

            if (caseInsensitive)
                options |= RegexOptions.IgnoreCase | RegexOptions.CultureInvariant;

            // Remove regex metacharacters

            pattern = metaRegex.Replace(pattern, "\\$0");

            // Replace wildcard metacharacters with regex codes

            pattern = questRegex.Replace(pattern, ".");
            pattern = starRegex.Replace(pattern, ".*");
            pattern = commaRegex.Replace(pattern, "\\z|\\A");

            // anchor the pattern at beginning and end, and return the regex

            return new Regex("\\A" + pattern + "\\z", options);
        }
    }

    abstract internal class WildcardPath : Wildcard {
        internal /*public*/ WildcardPath(String pattern) : base(pattern) {
        }

        internal /*public*/ WildcardPath(String pattern, bool caseInsensitive) : base(pattern, caseInsensitive) {
        }

        private Regex _suffix;
        private Regex[][] _dirs;

        /*
         * IsSuffix returns true if a suffix of the input is an exact
         * match for the wildcard pattern.
         */
        internal /*public*/ bool IsSuffix(String input) {
            EnsureSuffix();
            return _suffix.IsMatch(input);
        }

        /*
         * AllowPrefix returns true if the input is an exact match for
         * a prefix-directory of the wildcard pattern (i.e., if it
         * is possible to match the wildcard pattern by adding
         * more subdirectories or a filename at the end of the path).
         */
        internal /*public*/ bool AllowPrefix(String prefix) {
            String[] dirs = SplitDirs(prefix);

            EnsureDirs();

            for (int i = 0; i < _dirs.Length; i++) {
                // pattern is shorter than prefix: reject
                if (_dirs[i].Length < dirs.Length)
                    goto NextAlt;

                for (int j = 0; j < dirs.Length; j++) {
                    // the jth directory doesn't match; path is not a prefix
                    if (!_dirs[i][j].IsMatch(dirs[j]))
                        goto NextAlt;
                }

                // one alternative passed: we pass.

                return true;

                NextAlt: 
                ;
            }

            return false;
        }

        /*
         * Builds the matching regex when needed
         */
        protected void EnsureSuffix() {
            // threadsafe without protection because of gc

            if (_suffix != null)
                return;

            _suffix = SuffixFromWildcard(_pattern, _caseInsensitive);
        }

        /*
         * Builds the matching regex array when needed
         */
        protected void EnsureDirs() {
            // threadsafe without protection because of gc

            if (_dirs != null)
                return;

            _dirs = DirsFromWildcard(_pattern);
        }

        /*
         * Specialize for forward-slash and backward-slash cases
         */
        protected abstract Regex SuffixFromWildcard(String pattern, bool caseInsensitive);
        protected abstract Regex[][] DirsFromWildcard(String pattern);
        protected abstract String[] SplitDirs(String input);
    }

    /*
     * WildcardUrl
     *
     * The twist is that * and ? cannot match forward slashes,
     * and we can do an exact suffix match that starts after
     * any /, and we can also do a prefix prune.
     */
    internal class WildcardUrl : WildcardPath {
        internal /*public*/ WildcardUrl(String pattern) : base(pattern) {
        }

        internal /*public*/ WildcardUrl(String pattern, bool caseInsensitive) : base(pattern, caseInsensitive) {
        }

        protected override String[] SplitDirs(String input) {
            return slashRegex.Split(input);
        }

        protected override Regex RegexFromWildcard(String pattern, bool caseInsensitive) {
            RegexOptions options;

            // match right-to-left (for speed) if the pattern starts with a *

            if (pattern.Length > 0 && pattern[0] == '*')
                options = RegexOptions.RightToLeft;
            else
                options = RegexOptions.None;

            // case insensitivity

            if (caseInsensitive)
                options |= RegexOptions.IgnoreCase | RegexOptions.CultureInvariant;

            // Remove regex metacharacters

            pattern = metaRegex.Replace(pattern, "\\$0");

            // Replace wildcard metacharacters with regex codes

            pattern = questRegex.Replace(pattern, "[^/]");
            pattern = starRegex.Replace(pattern, "[^/]*");
            pattern = commaRegex.Replace(pattern, "\\z|\\A");

            // anchor the pattern at beginning and end, and return the regex

            return new Regex("\\A" + pattern + "\\z", options);
        }

        protected override Regex SuffixFromWildcard(String pattern, bool caseInsensitive) {
            RegexOptions options;

            // match right-to-left (for speed)

            options = RegexOptions.RightToLeft;

            // case insensitivity

            if (caseInsensitive)
                options |= RegexOptions.IgnoreCase | RegexOptions.CultureInvariant;

            // Remove regex metacharacters

            pattern = metaRegex.Replace(pattern, "\\$0");

            // Replace wildcard metacharacters with regex codes

            pattern = questRegex.Replace(pattern, "[^/]");
            pattern = starRegex.Replace(pattern, "[^/]*");
            pattern = commaRegex.Replace(pattern, "\\z|(?:\\A|(?<=/))");

            // anchor the pattern at beginning and end, and return the regex

            return new Regex("(?:\\A|(?<=/))" + pattern + "\\z", options);
        }

        protected override Regex[][] DirsFromWildcard(String pattern) {
            String[] alts = commaRegex.Split(pattern);
            Regex[][] dirs = new Regex[alts.Length][];

            for (int i = 0; i < alts.Length; i++) {
                String[] dirpats = slashRegex.Split(alts[i]);

                Regex[] dirregex = new Regex[dirpats.Length];

                if (alts.Length == 1 && dirpats.Length == 1) {
                    // common case: no commas, no slashes: dir regex is same as top regex.

                    EnsureRegex();
                    dirregex[0] = _regex;
                }
                else {
                    for (int j = 0; j < dirpats.Length; j++) {
                        dirregex[j] = RegexFromWildcard(dirpats[j], _caseInsensitive);
                    }
                }

                dirs[i] = dirregex;
            }

            return dirs;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\common.h ===
/*
 * COMMON.H
 *
 * Structures and definitions applicable to all OLE 2.0 UI dialogs.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _COMMON_H_
#define _COMMON_H_

// Macros to handle control message packing between Win16 and Win32
#ifndef COMMANDPARAMS
#define COMMANDPARAMS(wID, wCode, hWndMsg)                          \
        WORD        wID     = LOWORD(wParam);                       \
        WORD        wCode   = HIWORD(wParam);                       \
        HWND        hWndMsg = (HWND)lParam;
#endif

#ifndef SendCommand
#define SendCommand(hWnd, wID, wCode, hControl)                     \
                        SendMessage(hWnd, WM_COMMAND, MAKELONG(wID, wCode)      \
                                                , (LPARAM)hControl)
#endif

// Property labels used to store dialog structures and fonts
#define STRUCTUREPROP       TEXT("Structure")
#define FONTPROP            TEXT("Font")

#ifndef WM_HELP

// WM_HELP is new Windows 95 help message
#define WM_HELP         0x0053
// WM_CONTEXTMENU is new Windows 95 right button menus
#define WM_CONTEXTMENU  0x007B

typedef struct tagHELPINFO      /* Structure pointed to by lParam of WM_HELP */
{
    UINT    cbSize;             /* Size in bytes of this struct  */
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int     iCtrlId;            /* Control Id or a Menu item Id. */
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
    DWORD   dwContextId;        /* Context Id associated with this item */
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
}  HELPINFO, FAR *LPHELPINFO;

#define HELP_CONTEXTMENU        0x000a
#define HELP_WM_HELP            0x000c

#endif //!WM_HELP


#ifndef WS_EX_CONTEXTHELP
#define WS_EX_CONTEXTHELP       0x0400L
#endif

#ifndef OFN_EXPLORER
#define OFN_EXPLORER            0x00080000
#endif

#ifndef WS_EX_CLIENTEDGE
#define WS_EX_CLIENTEDGE        0x200
#endif


/*
 * Standard structure for all dialogs.  This commonality lets us make
 * a single piece of code that will validate this entire structure and
 * perform any necessary initialization.
 */

typedef struct tagOLEUISTANDARD
{
        // These IN fields are standard across all OLEUI dialog functions.
        DWORD           cbStruct;       // Structure Size
        DWORD           dwFlags;        // IN-OUT:  Flags
        HWND            hWndOwner;      // Owning window
        LPCTSTR         lpszCaption;    // Dialog caption bar contents
        LPFNOLEUIHOOK   lpfnHook;       // Hook callback
        LPARAM          lCustData;      // Custom data to pass to hook
        HINSTANCE       hInstance;      // Instance for customized template name
        LPCTSTR         lpszTemplate;   // Customized template name
        HRSRC           hResource;      // Customized template handle

} OLEUISTANDARD, *POLEUISTANDARD, FAR *LPOLEUISTANDARD;

// Function prototypes
// COMMON.CPP

UINT WINAPI UStandardValidation(LPOLEUISTANDARD, const UINT, HGLOBAL*);
UINT WINAPI UStandardInvocation(DLGPROC, LPOLEUISTANDARD, HGLOBAL, LPTSTR);
LPVOID WINAPI LpvStandardInit(HWND, UINT, HFONT* = NULL);
LPVOID WINAPI LpvStandardEntry(HWND, UINT, WPARAM, LPARAM, UINT FAR *);
UINT WINAPI UStandardHook(LPVOID, HWND, UINT, WPARAM, LPARAM);
void WINAPI StandardCleanup(LPVOID, HWND);
void WINAPI StandardShowDlgItem(HWND hDlg, int idControl, int nCmdShow);
void WINAPI StandardEnableDlgItem(HWND hDlg, int idControl, BOOL bEnable);
BOOL WINAPI StandardResizeDlgY(HWND hDlg);
void WINAPI StandardHelp(HWND, UINT);
void WINAPI StandardContextMenu(WPARAM, LPARAM, UINT nIDD);
UINT InternalObjectProperties(LPOLEUIOBJECTPROPS lpOP, BOOL fWide);
int WINAPI StandardPropertySheet(LPPROPSHEETHEADER lpPS, BOOL fWide);
int WINAPI StandardInitCommonControls();
HICON StandardExtractIcon(HINSTANCE hInst, LPCTSTR lpszExeFileName, UINT nIconIndex);
BOOL StandardGetOpenFileName(LPOPENFILENAME lpofn);
short StandardGetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf);

// shared globals: registered messages
extern UINT uMsgHelp;
extern UINT uMsgEndDialog;
extern UINT uMsgBrowse;
extern UINT uMsgChangeIcon;
extern UINT uMsgFileOKString;
extern UINT uMsgCloseBusyDlg;
extern UINT uMsgConvert;
extern UINT uMsgChangeSource;
extern UINT uMsgAddControl;
extern UINT uMsgBrowseOFN;

typedef struct tagTASKDATA
{
        HINSTANCE hInstCommCtrl;
        HINSTANCE hInstShell;
        HINSTANCE hInstComDlg;
} TASKDATA;

STDAPI_(TASKDATA*) GetTaskData();       // returns TASKDATA for current process

extern BOOL bWin4;                      // TRUE if running Win4 or greater
extern BOOL bSharedData;        // TRUE if runing Win32s

/////////////////////////////////////////////////////////////////////////////
// Maximum buffer sizes

// Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX             256  // same in geticon.c too
#define OLEUI_CCHKEYMAX_SIZE        OLEUI_CCHKEYMAX*sizeof(TCHAR)

// Maximum length of Object menu
#define OLEUI_OBJECTMENUMAX         256

// Maximim length of a path in BYTEs
#define MAX_PATH_SIZE               (MAX_PATH*sizeof(TCHAR))

// Icon label length
#define OLEUI_CCHLABELMAX           80  // same in geticon.c too (doubled)
#define OLEUI_CCHLABELMAX_SIZE      OLEUI_CCHLABELMAX*sizeof(TCHAR)

// Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING        39
#define OLEUI_CCHCLSIDSTRING_SIZE   OLEUI_CCHCLSIDSTRING*sizeof(TCHAR)

#endif //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\dbgutil.cpp ===
/*************************************************************************
**
**    OLE 2.0 Common Utilities
**
**    dbgutil.h
**
**    This file contains file contains functions to support debug output.
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#include "precomp.h"

#ifdef _DEBUG

static int s_nDbgIndent = 0;        // indent level for debug message
static int s_nDbgLevel = 0;   // default dbg level printed

STDAPI_(void) OleDbgPrint(
	int     nDbgLvl,
	LPTSTR   lpszPrefix,
	LPTSTR   lpszMsg,
	int     nIndent)
{
	if (nDbgLvl <= s_nDbgLevel)
		OleDbgPrintAlways(lpszPrefix, lpszMsg, nIndent);
}

STDAPI_(void) OleDbgPrintAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, int nIndent)
{
	if (nIndent < 0)
		OleDbgIndent(nIndent);

	if (lpszPrefix && *lpszPrefix != '\0')
	{
		OutputDebugString(TEXT("| "));
		for (int i = 0; i < s_nDbgIndent; i++)
			OutputDebugString(TEXT("----"));

		OutputDebugString(lpszPrefix);
		OutputDebugString(TEXT(": "));
	}

	OutputDebugString(lpszMsg);
	if (nIndent > 0)
		OleDbgIndent(nIndent);
}

STDAPI_(void) OleDbgSetDbgLevel(int nDbgLvl)
{
	s_nDbgLevel = nDbgLvl;
}

STDAPI_(int) OleDbgGetDbgLevel( void )
{
	return s_nDbgLevel;
}

STDAPI_(void) OleDbgIndent(int n)
{
	switch (n)
	{
	case -1:
		s_nDbgIndent--;
		break;
	case 1:
		s_nDbgIndent++;
		break;
	case -2:
		s_nDbgIndent = 0;
		break;
	}
}


STDAPI_(void) OleDbgPrintRefCnt(
		int         nDbgLvl,
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPVOID      lpObj,
		ULONG       refcnt)
{
	if (nDbgLvl <= s_nDbgLevel)
		OleDbgPrintRefCntAlways(lpszPrefix, lpszMsg, lpObj, refcnt);
}


STDAPI_(void) OleDbgPrintRefCntAlways(
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPVOID      lpObj,
		ULONG       refcnt)
{
	TCHAR szBuf[256];
	StringCchPrintf(szBuf, sizeof(szBuf)/sizeof(szBuf[0]), TEXT("[obj=(0x%lx) cnt=%ld] %s"), lpObj, refcnt, lpszMsg);
	OleDbgPrintAlways(lpszPrefix, szBuf, 0);
}

STDAPI_(void) OleDbgPrintRect(
		int         nDbgLvl,
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPRECT      lpRect)
{
	if (nDbgLvl <= s_nDbgLevel)
		OleDbgPrintRectAlways(lpszPrefix, lpszMsg, lpRect);
}


STDAPI_(void) OleDbgPrintRectAlways(
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPRECT      lpRect)
{
	TCHAR szBuf[256];
	StringCchPrintf(
		szBuf,
		sizeof(szBuf)/sizeof(szBuf[0]),
		TEXT("%s: (%d,%d)-(%d,%d) %dx%d\r\n"),
		lpszMsg,
		lpRect->left,
		lpRect->top,
		lpRect->right,
		lpRect->bottom,
		(lpRect->right-lpRect->left),
		(lpRect->bottom-lpRect->top)
	);
	OleDbgPrintAlways(lpszPrefix, szBuf, 0);
}


#define CASE_SCODE(sc)  \
	case sc: \
		pszErrName = TEXT(#sc); \
		break;

STDAPI_(void) OleDbgPrintScodeAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, SCODE sc)
{
	const TCHAR* pszErrName;

	switch (sc)
	{
	/* SCODE's defined in SCODE.H */

	CASE_SCODE(S_OK)
	CASE_SCODE(S_FALSE)
	CASE_SCODE(E_UNEXPECTED)
	CASE_SCODE(E_OUTOFMEMORY)
	CASE_SCODE(E_INVALIDARG)
	CASE_SCODE(E_NOINTERFACE)
	CASE_SCODE(E_POINTER)
	CASE_SCODE(E_HANDLE)
	CASE_SCODE(E_ABORT)
	CASE_SCODE(E_FAIL)
	CASE_SCODE(E_ACCESSDENIED)

	/* SCODE's defined in OLE2.H */

	CASE_SCODE(OLE_E_OLEVERB)
	CASE_SCODE(OLE_E_ADVF)
	CASE_SCODE(OLE_E_ENUM_NOMORE)
	CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
	CASE_SCODE(OLE_E_NOCONNECTION)
	CASE_SCODE(OLE_E_NOTRUNNING)
	CASE_SCODE(OLE_E_NOCACHE)
	CASE_SCODE(OLE_E_BLANK)
	CASE_SCODE(OLE_E_CLASSDIFF)
	CASE_SCODE(OLE_E_CANT_GETMONIKER)
	CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
	CASE_SCODE(OLE_E_STATIC)
	CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
	CASE_SCODE(OLE_E_INVALIDRECT)
	CASE_SCODE(OLE_E_WRONGCOMPOBJ)
	CASE_SCODE(OLE_E_INVALIDHWND)
	CASE_SCODE(OLE_E_NOT_INPLACEACTIVE)
	CASE_SCODE(OLE_E_CANTCONVERT)
	CASE_SCODE(OLE_E_NOSTORAGE)

	CASE_SCODE(DV_E_FORMATETC)
	CASE_SCODE(DV_E_DVTARGETDEVICE)
	CASE_SCODE(DV_E_STGMEDIUM)
	CASE_SCODE(DV_E_STATDATA)
	CASE_SCODE(DV_E_LINDEX)
	CASE_SCODE(DV_E_TYMED)
	CASE_SCODE(DV_E_CLIPFORMAT)
	CASE_SCODE(DV_E_DVASPECT)
	CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
	CASE_SCODE(DV_E_NOIVIEWOBJECT)

	CASE_SCODE(OLE_S_USEREG)
	CASE_SCODE(OLE_S_STATIC)
	CASE_SCODE(OLE_S_MAC_CLIPFORMAT)

	CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
	CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
	CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
	CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
	CASE_SCODE(CONVERT10_E_STG_FMT)
	CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
	CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
	CASE_SCODE(CONVERT10_S_NO_PRESENTATION)

	CASE_SCODE(CLIPBRD_E_CANT_OPEN)
	CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
	CASE_SCODE(CLIPBRD_E_CANT_SET)
	CASE_SCODE(CLIPBRD_E_BAD_DATA)
	CASE_SCODE(CLIPBRD_E_CANT_CLOSE)

	CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
	CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
	CASE_SCODE(DRAGDROP_E_INVALIDHWND)
	CASE_SCODE(DRAGDROP_S_DROP)
	CASE_SCODE(DRAGDROP_S_CANCEL)
	CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)

	CASE_SCODE(OLEOBJ_E_NOVERBS)
	CASE_SCODE(OLEOBJ_E_INVALIDVERB)
	CASE_SCODE(OLEOBJ_S_INVALIDVERB)
	CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
	CASE_SCODE(OLEOBJ_S_INVALIDHWND)
	CASE_SCODE(INPLACE_E_NOTUNDOABLE)
	CASE_SCODE(INPLACE_E_NOTOOLSPACE)
	CASE_SCODE(INPLACE_S_TRUNCATED)

	/* SCODE's defined in COMPOBJ.H */

	CASE_SCODE(CO_E_NOTINITIALIZED)
	CASE_SCODE(CO_E_ALREADYINITIALIZED)
	CASE_SCODE(CO_E_CANTDETERMINECLASS)
	CASE_SCODE(CO_E_CLASSSTRING)
	CASE_SCODE(CO_E_IIDSTRING)
	CASE_SCODE(CO_E_APPNOTFOUND)
	CASE_SCODE(CO_E_APPSINGLEUSE)
	CASE_SCODE(CO_E_ERRORINAPP)
	CASE_SCODE(CO_E_DLLNOTFOUND)
	CASE_SCODE(CO_E_ERRORINDLL)
	CASE_SCODE(CO_E_WRONGOSFORAPP)
	CASE_SCODE(CO_E_OBJNOTREG)
	CASE_SCODE(CO_E_OBJISREG)
	CASE_SCODE(CO_E_OBJNOTCONNECTED)
	CASE_SCODE(CO_E_APPDIDNTREG)
	CASE_SCODE(CLASS_E_NOAGGREGATION)
    CASE_SCODE(CLASS_E_CLASSNOTAVAILABLE)
	CASE_SCODE(REGDB_E_READREGDB)
	CASE_SCODE(REGDB_E_WRITEREGDB)
	CASE_SCODE(REGDB_E_KEYMISSING)
	CASE_SCODE(REGDB_E_INVALIDVALUE)
	CASE_SCODE(REGDB_E_CLASSNOTREG)
	CASE_SCODE(REGDB_E_IIDNOTREG)
	CASE_SCODE(RPC_E_CALL_REJECTED)
	CASE_SCODE(RPC_E_CALL_CANCELED)
	CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
	CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
	CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
	CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
	CASE_SCODE(RPC_E_SERVER_DIED)
	CASE_SCODE(RPC_E_CLIENT_DIED)
	CASE_SCODE(RPC_E_INVALID_DATAPACKET)
	CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
	CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
	CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
	CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
	CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
	CASE_SCODE(RPC_E_INVALID_DATA)
	CASE_SCODE(RPC_E_INVALID_PARAMETER)
	CASE_SCODE(RPC_E_UNEXPECTED)

	/* SCODE's defined in DVOBJ.H */

	CASE_SCODE(DATA_S_SAMEFORMATETC)
	CASE_SCODE(VIEW_E_DRAW)
	CASE_SCODE(VIEW_S_ALREADY_FROZEN)
	CASE_SCODE(CACHE_E_NOCACHE_UPDATED)
	CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
	CASE_SCODE(CACHE_S_SAMECACHE)
	CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)

	/* SCODE's defined in STORAGE.H */

	CASE_SCODE(STG_E_INVALIDFUNCTION)
	CASE_SCODE(STG_E_FILENOTFOUND)
	CASE_SCODE(STG_E_PATHNOTFOUND)
	CASE_SCODE(STG_E_TOOMANYOPENFILES)
	CASE_SCODE(STG_E_ACCESSDENIED)
	CASE_SCODE(STG_E_INVALIDHANDLE)
	CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
	CASE_SCODE(STG_E_INVALIDPOINTER)
	CASE_SCODE(STG_E_NOMOREFILES)
	CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
	CASE_SCODE(STG_E_SEEKERROR)
	CASE_SCODE(STG_E_WRITEFAULT)
	CASE_SCODE(STG_E_READFAULT)
	CASE_SCODE(STG_E_SHAREVIOLATION)
	CASE_SCODE(STG_E_LOCKVIOLATION)
	CASE_SCODE(STG_E_FILEALREADYEXISTS)
	CASE_SCODE(STG_E_INVALIDPARAMETER)
	CASE_SCODE(STG_E_MEDIUMFULL)
	CASE_SCODE(STG_E_ABNORMALAPIEXIT)
	CASE_SCODE(STG_E_INVALIDHEADER)
	CASE_SCODE(STG_E_INVALIDNAME)
	CASE_SCODE(STG_E_UNKNOWN)
	CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
	CASE_SCODE(STG_E_INVALIDFLAG)
	CASE_SCODE(STG_E_INUSE)
	CASE_SCODE(STG_E_NOTCURRENT)
	CASE_SCODE(STG_E_REVERTED)
	CASE_SCODE(STG_E_CANTSAVE)
	CASE_SCODE(STG_E_OLDFORMAT)
	CASE_SCODE(STG_E_OLDDLL)
	CASE_SCODE(STG_E_SHAREREQUIRED)
	CASE_SCODE(STG_E_NOTFILEBASEDSTORAGE)
	CASE_SCODE(STG_E_EXTANTMARSHALLINGS)
	CASE_SCODE(STG_S_CONVERTED)

	/* SCODE's defined in STORAGE.H */

	CASE_SCODE(MK_E_CONNECTMANUALLY)
	CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
	CASE_SCODE(MK_E_NEEDGENERIC)
	CASE_SCODE(MK_E_UNAVAILABLE)
	CASE_SCODE(MK_E_SYNTAX)
	CASE_SCODE(MK_E_NOOBJECT)
	CASE_SCODE(MK_E_INVALIDEXTENSION)
	CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
	CASE_SCODE(MK_E_NOTBINDABLE)
	CASE_SCODE(MK_E_NOTBOUND)
	CASE_SCODE(MK_E_CANTOPENFILE)
	CASE_SCODE(MK_E_MUSTBOTHERUSER)
	CASE_SCODE(MK_E_NOINVERSE)
	CASE_SCODE(MK_E_NOSTORAGE)
	CASE_SCODE(MK_E_NOPREFIX)
	CASE_SCODE(MK_S_REDUCED_TO_SELF)
	CASE_SCODE(MK_S_ME)
	CASE_SCODE(MK_S_HIM)
	CASE_SCODE(MK_S_US)
	CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)

	default:
		pszErrName = TEXT("UNKNOWN SCODE");
		break;
	}

	TCHAR szBuf[256];
	StringCchPrintf(szBuf, sizeof(szBuf)/sizeof(szBuf[0]), TEXT("%s %s (0x%lx)\n"), lpszMsg, pszErrName, sc);
	OleDbgPrintAlways(lpszPrefix, szBuf, 0);
}

STDAPI OleStdAssert(LPTSTR lpstrExpr, LPTSTR lpstrMsg, LPTSTR lpstrFileName, UINT iLine)
{
	TCHAR buf[4096];
	StringCchPrintf(buf, sizeof(buf)/sizeof(buf[0]), _T("Expr: %s Msg: (%s)\n")
		_T("File: %s, line: %ud"), lpstrExpr, lpstrMsg, lpstrFileName, iLine);
	int i = MessageBox(GetActiveWindow(), buf, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ABORTRETRYIGNORE);
	switch (i)
	{
	case IDABORT:
		ExitProcess((UINT)-3);
		break;

	case IDRETRY:
		#ifdef _X86_
			_asm int 3;
		#else
			DebugBreak();
		#endif
		break;
	}
	return NOERROR;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\dllfuncs.cpp ===
/*
 * DLLFUNCS.CPP
 *
 * Contains entry and exit points for the DLL implementation
 * of the OLE 2.0 User Interface Support Library.
 *
 * This file is not needed if we are linking the static library
 * version of this library.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "uiclass.h"

OLEDBGDATA_MAIN(TEXT("OLEDLG"))

/*
 * DllMain
 *
 * Purpose:
 *  DLL-specific entry point called from LibEntry.
 */

STDAPI_(BOOL) OleUIInitialize(HINSTANCE, HINSTANCE);
STDAPI_(BOOL) OleUIUnInitialize();

#pragma code_seg(".text$initseg")

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD Reason, LPVOID lpv)
{
        if (Reason == DLL_PROCESS_DETACH)
        {
                OleDbgOut2(TEXT("DllMain: OLEDLG.DLL unloaded\r\n"));

                OleUIUnInitialize();
        }
        else if (Reason == DLL_PROCESS_ATTACH)
        {
                OSVERSIONINFO sVersion;

                sVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                if (GetVersionEx(&sVersion))
                {
                    if (VER_PLATFORM_WIN32s == sVersion.dwPlatformId)
                    {
                        if ((1 == sVersion.dwMajorVersion) && (30 > sVersion.dwMinorVersion))
                        {
                            return(FALSE); // fail to load on older versions of Win32s
                        }
                    }
                }

                OleDbgOut2(TEXT("DllMain: OLEDLG.DLL loaded\r\n"));

                DisableThreadLibraryCalls(hInst);

                OleUIInitialize(hInst, (HINSTANCE)0);
        }
        return TRUE;
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\drawicon.cpp ===
/*
 * DRAWICON.CPP
 *
 * Functions to handle creation of metafiles with icons and labels
 * as well as functions to draw such metafiles with or without the label.
 *
 * The metafile is created with a comment that marks the records containing
 * the label code.  Drawing the metafile enumerates the records, draws
 * all records up to that point, then decides to either skip the label
 * or draw it.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "utility.h"
#include "malloc.h"

// Private implementation

//Structure for label and source extraction from a metafile
typedef struct tagLABELEXTRACT
{
        LPTSTR      lpsz;
        UINT        Index;      // index in lpsz (so we can retrieve 2+ lines)
        DWORD       PrevIndex;  // index of last line (so we can mimic word wrap)

        union
                {
                UINT    cch;        //Length of label for label extraction
                UINT    iIcon;      //Index of icon in source extraction.
                } u;

        //For internal use in enum procs
        BOOL        fFoundIconOnly;
        BOOL        fFoundSource;
        BOOL        fFoundIndex;
} LABELEXTRACT, FAR * LPLABELEXTRACT;


//Structure for extracting icons from a metafile (CreateIcon parameters)
typedef struct tagICONEXTRACT
{
        HICON       hIcon;          //Icon created in the enumeration proc.

        /*
         * Since we want to handle multitasking well we have the caller
         * of the enumeration proc instantiate these variables instead of
         * using statics in the enum proc (which would be bad).
         */
        BOOL        fAND;
        HGLOBAL     hMemAND;        //Enumeration proc allocates and copies
} ICONEXTRACT, FAR * LPICONEXTRACT;


//Structure to use to pass info to EnumMetafileDraw
typedef struct tagDRAWINFO
{
        RECT     Rect;
        BOOL     fIconOnly;
} DRAWINFO, FAR * LPDRAWINFO;


int CALLBACK EnumMetafileIconDraw(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPARAM);
int CALLBACK EnumMetafileExtractLabel(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPLABELEXTRACT);
int CALLBACK EnumMetafileExtractIcon(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPICONEXTRACT);
int CALLBACK EnumMetafileExtractIconSource(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPLABELEXTRACT);

/*
 * Strings for metafile comments.  KEEP THESE IN SYNC WITH THE
 * STRINGS IN GETICON.CPP
 */

static const char szIconOnly[] = "IconOnly"; // Where to stop to exclude label.

/*
 * OleUIMetafilePictIconFree
 *
 * Purpose:
 *  Deletes the metafile contained in a METAFILEPICT structure and
 *  frees the memory for the structure itself.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL metafilepict structure created in
 *                  OleMetafilePictFromIconAndLabel
 *
 * Return Value:
 *  None
 */

STDAPI_(void) OleUIMetafilePictIconFree(HGLOBAL hMetaPict)
{
        if (NULL != hMetaPict)
        {
                STGMEDIUM stgMedium;
                stgMedium.tymed = TYMED_MFPICT;
                stgMedium.hMetaFilePict = hMetaPict;
                stgMedium.pUnkForRelease = NULL;
                ReleaseStgMedium(&stgMedium);
        }
}

/*
 * OleUIMetafilePictIconDraw
 *
 * Purpose:
 *  Draws the metafile from OleMetafilePictFromIconAndLabel, either with
 *  the label or without.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  pRect           LPRECT in which to draw the metafile.
 *  hMetaPict       HGLOBAL to the METAFILEPICT from
 *                  OleMetafilePictFromIconAndLabel
 *  fIconOnly       BOOL specifying to draw the label or not.
 *
 * Return Value:
 *  BOOL            TRUE if the function is successful, FALSE if the
 *                  given metafilepict is invalid.
 */

STDAPI_(BOOL) OleUIMetafilePictIconDraw(HDC hDC, LPCRECT pRect,
        HGLOBAL hMetaPict, BOOL fIconOnly)
{
        if (NULL == hMetaPict)
                return FALSE;

        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);

        if (NULL == pMF)
                return FALSE;

        DRAWINFO di;
        di.Rect = *pRect;
        di.fIconOnly = fIconOnly;

        //Transform to back to pixels
        int cx = XformWidthInHimetricToPixels(hDC, pMF->xExt);
        int cy = XformHeightInHimetricToPixels(hDC, pMF->yExt);

        SaveDC(hDC);

        SetMapMode(hDC, pMF->mm);
        SetViewportOrgEx(hDC, (pRect->right - cx) / 2, 0, NULL);
        SetViewportExtEx(hDC, min ((pRect->right - cx) / 2 + cx, cx), cy, NULL);

        if (fIconOnly)
                EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileIconDraw, (LPARAM)&di);
        else
           PlayMetaFile(hDC, pMF->hMF);

        RestoreDC(hDC, -1);

        GlobalUnlock(hMetaPict);
        return TRUE;
}

/*
 * EnumMetafileIconDraw
 *
 * Purpose:
 *  EnumMetaFile callback function that draws either the icon only or
 *  the icon and label depending on given flags.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  lParam          LPARAM flags passed in EnumMetaFile.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */
int CALLBACK EnumMetafileIconDraw(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPARAM lParam)
{
        LPDRAWINFO lpdi = (LPDRAWINFO)lParam;

        /*
         * We play everything blindly except for DIBBITBLT (or DIBSTRETCHBLT)
         * and ESCAPE with MFCOMMENT.  For the BitBlts we change the x,y to
         * draw at (0,0) instead of wherever it was written to draw.  The
         * comment tells us there to stop if we don't want to draw the label.
         */

        //If we're playing icon only, stop enumeration at the comment.
        if (lpdi->fIconOnly)
        {
                if (META_ESCAPE==pMFR->rdFunction && MFCOMMENT==pMFR->rdParm[0])
                {
                        if (0 == lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
                                return 0;
                }

                /*
                 * Check for the records in which we want to munge the coordinates.
                 * destX is offset 6 for BitBlt, offset 9 for StretchBlt, either of
                 * which may appear in the metafile.
                 */
                if (META_DIBBITBLT == pMFR->rdFunction)
                        pMFR->rdParm[6]=0;

                if (META_DIBSTRETCHBLT == pMFR->rdFunction)
                          pMFR->rdParm[9] = 0;
        }

        PlayMetaFileRecord(hDC, phTable, pMFR, cObj);
        return 1;
}


/*
 * OleUIMetafilePictExtractLabel
 *
 * Purpose:
 *  Retrieves the label string from metafile representation of an icon.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile.
 *  lpszLabel       LPSTR in which to store the label.
 *  cchLabel        UINT length of lpszLabel.
 *  lpWrapIndex     DWORD index of first character in last line. Can be NULL
 *                  if calling function doesn't care about word wrap.
 *
 * Return Value:
 *  UINT            Number of characters copied.
 */
STDAPI_(UINT) OleUIMetafilePictExtractLabel(HGLOBAL hMetaPict, LPTSTR lpszLabel,
        UINT cchLabel, LPDWORD lpWrapIndex)
{
        if (NULL == hMetaPict || NULL == lpszLabel || 0 == cchLabel)
                return FALSE;

        /*
         * We extract the label by getting a screen DC and walking the metafile
         * records until we see the ExtTextOut record we put there.  That
         * record will have the string embedded in it which we then copy out.
         */
        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);

        if (NULL == pMF)
                return FALSE;

        LABELEXTRACT le;
        le.lpsz=lpszLabel;
        le.u.cch=cchLabel;
        le.Index=0;
        le.fFoundIconOnly=FALSE;
        le.fFoundSource=FALSE;  //Unused for this function.
        le.fFoundIndex=FALSE;   //Unused for this function.
        le.PrevIndex = 0;

        //Use a screen DC so we have something valid to pass in.
        HDC hDC = GetDC(NULL);
        if (hDC)
        {
            EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileExtractLabel, (LPARAM)(LPLABELEXTRACT)&le);
            ReleaseDC(NULL, hDC);
        } else {
            le.u.cch = 0;
			lpszLabel[0] = NULL;
        }

        GlobalUnlock(hMetaPict);

        //Tell where we wrapped (if calling function cares)
        if (NULL != lpWrapIndex)
           *lpWrapIndex = le.PrevIndex;

        //Return amount of text copied
        return le.u.cch;
}

/*
 * EnumMetafileExtractLabel
 *
 * Purpose:
 *  EnumMetaFile callback function that walks a metafile looking for
 *  ExtTextOut, then concatenates the text from each one into a buffer
 *  in lParam.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  pLE             LPLABELEXTRACT providing the destination buffer and length.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileExtractLabel(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPLABELEXTRACT pLE)
{
        /*
         * We don't allow anything to happen until we see "IconOnly"
         * in an MFCOMMENT that is used to enable everything else.
         */
        if (!pLE->fFoundIconOnly)
        {
                if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
                {
                        if (0 == lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
                                pLE->fFoundIconOnly=TRUE;
                }
                return 1;
        }

        //Enumerate all records looking for META_EXTTEXTOUT - there can be more
        //than one.
        if (META_EXTTEXTOUT == pMFR->rdFunction)
        {
                /*
                 * If ExtTextOut has NULL fuOptions, then the rectangle is omitted
                 * from the record, and the string starts at rdParm[4].  If
                 * fuOptions is non-NULL, then the string starts at rdParm[8]
                 * (since the rectange takes up four WORDs in the array).  In
                 * both cases, the string continues for (rdParm[2]+1) >> 1
                 * words.  We just cast a pointer to rdParm[8] to an LPSTR and
                 * lstrcpyn into the buffer we were given.
                 *
                 * Note that we use element 8 in rdParm instead of 4 because we
                 * passed ETO_CLIPPED in for the options on ExtTextOut--docs say
                 * [4] which is rect doesn't exist if we passed zero there.
                 *
                 */

                UINT cchMax = min(pLE->u.cch - pLE->Index, (UINT)pMFR->rdParm[2]);
                LPTSTR lpszTemp = pLE->lpsz + pLE->Index;
#ifdef _UNICODE
                MultiByteToWideChar(CP_ACP, 0, (LPSTR)&pMFR->rdParm[8], cchMax,
                        lpszTemp, cchMax+1);
#else
                lstrcpyn(lpszTemp, (LPSTR)&pMFR->rdParm[8], cchMax+1);
#endif
                lpszTemp[cchMax+1] = 0;

                pLE->PrevIndex = pLE->Index;
                pLE->Index += cchMax;
        }
        return 1;
}

/*
 * OleUIMetafilePictExtractIcon
 *
 * Purpose:
 *  Retrieves the icon from metafile into which DrawIcon was done before.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile.
 *
 * Return Value:
 *  HICON           Icon recreated from the data in the metafile.
 */
STDAPI_(HICON) OleUIMetafilePictExtractIcon(HGLOBAL hMetaPict)
{
        if (NULL == hMetaPict)
                return NULL;

        /*
         * We extract the label by getting a screen DC and walking the metafile
         * records until we see the ExtTextOut record we put there.  That
         * record will have the string embedded in it which we then copy out.
         */
        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);

        if (NULL == pMF)
                return FALSE;

        ICONEXTRACT ie;
        ie.fAND  = TRUE;
        ie.hIcon = NULL;

        //Use a screen DC so we have something valid to pass in.
        HDC hDC=GetDC(NULL);
        if (hDC != NULL)
        {
            EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileExtractIcon, (LPARAM)&ie);
            ReleaseDC(NULL, hDC);
        }

        GlobalUnlock(hMetaPict);

        return ie.hIcon;
}

/*
 * EnumMetafileExtractIcon
 *
 * Purpose:
 *  EnumMetaFile callback function that walks a metafile looking for
 *  StretchBlt (3.1) and BitBlt (3.0) records.  We expect to see two
 *  of them, the first being the AND mask and the second being the XOR
 *  data.  We
 *  ExtTextOut, then copies the text into a buffer in lParam.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  pIE             LPICONEXTRACT providing the destination buffer and length.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileExtractIcon(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPICONEXTRACT pIE)
{
        //Continue enumeration if we don't see the records we want.
        if (META_DIBBITBLT != pMFR->rdFunction && META_DIBSTRETCHBLT != pMFR->rdFunction)
                return 1;

        UNALIGNED BITMAPINFO* lpBI;
        UINT uWidth, uHeight;
        /*
         * Windows 3.0 DrawIcon uses META_DIBBITBLT in whereas 3.1 uses
         * META_DIBSTRETCHBLT so we have to handle each case separately.
         */
        if (META_DIBBITBLT==pMFR->rdFunction)       //Win3.0
        {
                //Get dimensions and the BITMAPINFO struct.
                uHeight = pMFR->rdParm[1];
                uWidth = pMFR->rdParm[2];
                lpBI = (LPBITMAPINFO)&(pMFR->rdParm[8]);
        }

        if (META_DIBSTRETCHBLT == pMFR->rdFunction)   //Win3.1
        {
                //Get dimensions and the BITMAPINFO struct.
                uHeight = pMFR->rdParm[2];
                uWidth = pMFR->rdParm[3];
                lpBI = (LPBITMAPINFO)&(pMFR->rdParm[10]);
        }

        UNALIGNED BITMAPINFOHEADER* lpBH=(LPBITMAPINFOHEADER)&(lpBI->bmiHeader);

        //Pointer to the bits which follows the BITMAPINFO structure.
        LPBYTE lpbSrc=(LPBYTE)lpBI+sizeof(BITMAPINFOHEADER);

        //Add the length of the color table (if one exists)
        if (0 != lpBH->biClrUsed)
        {
                // If we have an explicit count of colors used, we
                // can find the offset to the data directly
                lpbSrc += (lpBH->biClrUsed*sizeof(RGBQUAD));
        }
        else if (lpBH->biCompression == BI_BITFIELDS)
        {
                // 16 or 32 bpp, indicated by BI_BITFIELDS in the compression
                // field, have 3 DWORD masks for adjusting subsequent
                // direct-color values, and no palette
                lpbSrc += 3 * sizeof(DWORD);
        }
        else
        {
                // In other cases, there is an array of RGBQUAD entries
                // equal to 2^(biBitCount) where biBitCount is the number
                // of bits per pixel.  The exception is 24 bpp bitmaps,
                // which have no color table and just use direct RGB values.
                lpbSrc += (lpBH->biBitCount == 24) ? 0 :
                        (1 << (lpBH->biBitCount)) * sizeof(RGBQUAD);
        }

        // copy into aligned stack space (since SetDIBits needs aligned data)
        size_t nSize = (size_t)(lpbSrc - (LPBYTE)lpBI);
        LPBITMAPINFO lpTemp = (LPBITMAPINFO)_alloca(nSize);
        memcpy(lpTemp, lpBI, nSize);

        /*
         * All the bits we have in lpbSrc are device-independent, so we
         * need to change them over to be device-dependent using SetDIBits.
         * Once we have a bitmap with the device-dependent bits, we can
         * GetBitmapBits to have buffers with the real data.
         *
         * For each pass we have to allocate memory for the bits.  We save
         * the memory for the mask between passes.
         */

        HBITMAP hBmp;

        //Use CreateBitmap for ANY monochrome bitmaps
        if (pIE->fAND || 1==lpBH->biBitCount)
                hBmp=CreateBitmap((UINT)lpBH->biWidth, (UINT)lpBH->biHeight, 1, 1, NULL);
        else
                hBmp=CreateCompatibleBitmap(hDC, (UINT)lpBH->biWidth, (UINT)lpBH->biHeight);

        if (!hBmp || !SetDIBits(hDC, hBmp, 0, (UINT)lpBH->biHeight, (LPVOID)lpbSrc, lpTemp, DIB_RGB_COLORS))
        {
                if (!pIE->fAND)
                        GlobalFree(pIE->hMemAND);

                if (hBmp)
                    DeleteObject(hBmp);

                return 0;
        }

        //Allocate memory and get the DDBits into it.
        BITMAP bm;
        GetObject(hBmp, sizeof(bm), &bm);

        DWORD cb = bm.bmHeight*bm.bmWidthBytes * bm.bmPlanes;
        HGLOBAL hMem = GlobalAlloc(GHND, cb);

        if (NULL==hMem)
        {
                if (NULL != pIE->hMemAND)
                        GlobalFree(pIE->hMemAND);

                DeleteObject(hBmp);
                return 0;
        }

        LPBYTE lpbDst = (LPBYTE)GlobalLock(hMem);
        GetBitmapBits(hBmp, cb, (LPVOID)lpbDst);
        DeleteObject(hBmp);
        GlobalUnlock(hMem);

        /*
         * If this is the first pass (pIE->fAND==TRUE) then save the memory
         * of the AND bits for the next pass.
         */
        if (pIE->fAND)
        {
                pIE->fAND = FALSE;
                pIE->hMemAND = hMem;

                //Continue enumeration looking for the next blt record.
                return 1;
        }
        else
        {
                //Get the AND pointer again.
                lpbSrc=(LPBYTE)GlobalLock(pIE->hMemAND);

                /*
                 * Create the icon now that we have all the data.  lpbDst already
                 * points to the XOR bits.
                 */

                int cxIcon = GetSystemMetrics(SM_CXICON);
                int cyIcon = GetSystemMetrics(SM_CYICON);

                pIE->hIcon = CreateIcon(_g_hOleStdInst, uWidth, uHeight,
                        (BYTE)bm.bmPlanes, (BYTE)bm.bmBitsPixel, lpbSrc, lpbDst);

                GlobalUnlock(pIE->hMemAND);
                GlobalFree(pIE->hMemAND);
                GlobalFree(hMem);

                return 0;
        }
}


/*
 * OleUIMetafilePictExtractIconSource
 *
 * Purpose:
 *  Retrieves the filename and index of the icon source from a metafile
 *  created with OleMetafilePictFromIconAndLabel.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile.
 *  lpszSource      LPTSTR in which to store the source filename.  This
 *                  buffer should be MAX_PATH characters.
 *  piIcon          UINT FAR * in which to store the icon's index
 *                  within lpszSource
 *
 * Return Value:
 *  BOOL            TRUE if the records were found, FALSE otherwise.
 */
STDAPI_(BOOL) OleUIMetafilePictExtractIconSource(HGLOBAL hMetaPict,
        LPTSTR lpszSource, UINT FAR *piIcon)
{
        if (NULL == hMetaPict || NULL == lpszSource || NULL == piIcon)
                return FALSE;

        /*
         * We will walk the metafile looking for the two comment records
         * following the IconOnly comment.  The flags fFoundIconOnly and
         * fFoundSource indicate if we have found IconOnly and if we have
         * found the source comment already.
         */

        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);
        if (NULL == pMF)
                return FALSE;

        LABELEXTRACT    le;
        le.lpsz = lpszSource;
        le.fFoundIconOnly = FALSE;
        le.fFoundSource = FALSE;
        le.fFoundIndex = FALSE;
        le.u.iIcon = NULL;

        //Use a screen DC so we have something valid to pass in.
        HDC hDC = GetDC(NULL);
        if (hDC)
        {
            EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileExtractIconSource,
                         (LPARAM)(LPLABELEXTRACT)&le);
            ReleaseDC(NULL, hDC);
        }
        GlobalUnlock(hMetaPict);

        //Copy the icon index to the caller's variable.
        *piIcon=le.u.iIcon;

        //Check that we found everything.
        return (le.fFoundIconOnly && le.fFoundSource && le.fFoundIndex);
}


/*
 * EnumMetafileExtractIconSource
 *
 * Purpose:
 *  EnumMetaFile callback function that walks a metafile skipping the first
 *  comment record, extracting the source filename from the second, and
 *  the index of the icon in the third.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  pLE             LPLABELEXTRACT providing the destination buffer and
 *                  area to store the icon index.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileExtractIconSource(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPLABELEXTRACT pLE)
{
        /*
         * We don't allow anything to happen until we see "IconOnly"
         * in an MFCOMMENT that is used to enable everything else.
         */
        if (!pLE->fFoundIconOnly)
        {
                if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
                {
                        if (0 == lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
                                pLE->fFoundIconOnly=TRUE;
                }
                return 1;
        }

        //Now see if we find the source string.
        if (!pLE->fFoundSource)
        {
                if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
                {
#ifdef _UNICODE
                        MultiByteToWideChar(CP_ACP, 0, (LPSTR)&pMFR->rdParm[2], -1,
                                pLE->lpsz, MAX_PATH);
#else
                        lstrcpyn(pLE->lpsz, (LPSTR)&pMFR->rdParm[2], MAX_PATH);
#endif
                        pLE->lpsz[MAX_PATH-1] = '\0';
                        pLE->fFoundSource=TRUE;
                }
                return 1;
        }

        //Next comment will be the icon index.
        if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
        {
                /*
                 * This string contains the icon index in string form,
                 * so we need to convert back to a UINT.  After we see this
                 * we can stop the enumeration.  The comment will have
                 * a null terminator because we made sure to save it.
                 */
                LPSTR psz = (LPSTR)&pMFR->rdParm[2];
                pLE->u.iIcon = 0;

                //Do Ye Olde atoi
                while (*psz)
                        pLE->u.iIcon = (10*pLE->u.iIcon)+((*psz++)-'0');

                pLE->fFoundIndex=TRUE;
                return 0;
        }
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\iconbox.h ===
/*
 * ICONBOX.H
 *
 * Structures and definitions for the IconBox control.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _ICONBOX_H_
#define _ICONBOX_H_

// Function prototypes
BOOL FIconBoxInitialize(HINSTANCE, HINSTANCE);
void IconBoxUninitialize(void);
LRESULT CALLBACK IconBoxWndProc(HWND, UINT, WPARAM, LPARAM);

// Window extra bytes contain the bitmap index we deal with currently.
#define CBICONBOXWNDEXTRA              (sizeof(HGLOBAL)+sizeof(BOOL))
#define IBWW_HIMAGE                    0
#define IBWW_FLABEL                    (sizeof(HGLOBAL))

// Control messages
#define IBXM_IMAGESET                   (WM_USER+0)
#define IBXM_IMAGEGET                   (WM_USER+1)
#define IBXM_IMAGEFREE                  (WM_USER+2)
#define IBXM_LABELENABLE                (WM_USER+3)

#endif //_ICONBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\geticon.cpp ===
/*
 *  GETICON.CPP
 *
 *  Functions to create DVASPECT_ICON metafile from filename or classname.
 *
 *  OleMetafilePictFromIconAndLabel
 *
 *    (c) Copyright Microsoft Corp. 1992-1993 All Rights Reserved
 */


/*******
 *
 * ICON (DVASPECT_ICON) METAFILE FORMAT:
 *
 * The metafile generated with OleMetafilePictFromIconAndLabel contains
 * the following records which are used by the functions in DRAWICON.CPP
 * to draw the icon with and without the label and to extract the icon,
 * label, and icon source/index.
 *
 *  SetWindowOrg
 *  SetWindowExt
 *  DrawIcon:
 *      Inserts records of DIBBITBLT or DIBSTRETCHBLT, once for the
 *      AND mask, one for the image bits.
 *  Escape with the comment "IconOnly"
 *      This indicates where to stop record enumeration to draw only
 *      the icon.
 *  SetTextColor
 *  SetTextAlign
 *  SetBkColor
 *  CreateFont
 *  SelectObject on the font.
 *  ExtTextOut
 *      One or more ExtTextOuts occur if the label is wrapped.  The
 *      text in these records is used to extract the label.
 *  SelectObject on the old font.
 *  DeleteObject on the font.
 *  Escape with a comment that contains the path to the icon source.
 *  Escape with a comment that is the ASCII of the icon index.
 *
 *******/

#include "precomp.h"
#include "common.h"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include <reghelp.hxx>
#include "utility.h"
#include "strsafe.h"

OLEDBGDATA

static const TCHAR szSeparators[] = TEXT(" \t\\/!:");

#define IS_SEPARATOR(c)         ( (c) == ' ' || (c) == '\\' \
                                                                  || (c) == '/' || (c) == '\t' \
                                                                  || (c) == '!' || (c) == ':')
#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' )

#define IS_SPACE(c)                     ( (c) == ' ' || (c) == '\t' || (c) == '\n' )

/*
 * GetAssociatedExecutable
 *
 * Purpose:  Finds the executable associated with the provided extension
 *
 * Parameters:
 *   lpszExtension   LPSTR points to the extension we're trying to find
 *                   an exe for. Does **NO** validation.
 *
 *   lpszExecutable  LPSTR points to where the exe name will be returned.
 *                   No validation here either - pass in 128 char buffer.
 *
 * Return:
 *   BOOL            TRUE if we found an exe, FALSE if we didn't.
 *
 *   SECURITY BUG: DON'T TRUST THE RESULTS OF THIS FUNCTION! IF THE ASSOCIATED EXECUTABLE IS
 *   "D:\Program Files\Foo.exe", this routine will return "D:\program". Currently this function is not used to actually
 *   start an application, so it is not causing a security defect. It is a bug, however, and will be a security issue if
 *   you do use the results to start the executable.
 */
BOOL FAR PASCAL GetAssociatedExecutable(LPTSTR lpszExtension, LPTSTR lpszExecutable, UINT cchBuf)
{
        BOOL fRet = FALSE;
        HKEY hKey = NULL;
        LRESULT lRet = OpenClassesRootKey(NULL, &hKey);
        if (ERROR_SUCCESS != lRet)
        {
                goto end;
        }

        LONG dw = OLEUI_CCHKEYMAX_SIZE;
        TCHAR szValue[OLEUI_CCHKEYMAX];
        lRet = RegQueryValue(hKey, lpszExtension, szValue, &dw);  //ProgId
        if (ERROR_SUCCESS != lRet)
        {
                goto end;
        }

        // szValue now has ProgID
        TCHAR szKey[OLEUI_CCHKEYMAX];
        StringCchCopy(szKey, sizeof(szKey)/sizeof(szKey[0]), szValue);
        if (FAILED(StringCchCat(szKey, sizeof(szKey)/sizeof(szKey[0]), TEXT("\\Shell\\Open\\Command"))))
        {
                goto end;
        }    

        dw = OLEUI_CCHKEYMAX_SIZE;
        lRet = RegQueryValue(hKey, szKey, szValue, &dw);
        if (ERROR_SUCCESS != lRet)
        {
                goto end;
        }

        // szValue now has an executable name in it.  Let's null-terminate
        // at the first post-executable space (so we don't have cmd line
        // args.
        LPTSTR lpszTemp = szValue;
        while ('\0' != *lpszTemp && IS_SPACE(*lpszTemp))
                lpszTemp = CharNext(lpszTemp);      // Strip off leading spaces

        LPTSTR lpszExe = lpszTemp;
        while ('\0' != *lpszTemp && !IS_SPACE(*lpszTemp))
                lpszTemp = CharNext(lpszTemp);     // Step through exe name
        *lpszTemp = '\0';  // null terminate at first space (or at end).

        StringCchCopy(lpszExecutable, cchBuf, lpszExe);
        fRet = TRUE;
        
end:        

        if(hKey)
        { 
            RegCloseKey(hKey);
            hKey = NULL;
        }
        return fRet;
}


/*
 * PointerToNthField
 *
 * Purpose:
 *  Returns a pointer to the beginning of the nth field.
 *  Assumes null-terminated string.
 *
 * Parameters:
 *  lpszString        string to parse
 *  nField            field to return starting index of.
 *  chDelimiter       char that delimits fields
 *
 * Return Value:
 *  LPSTR             pointer to beginning of nField field.
 *                    NOTE: If the null terminator is found
 *                          Before we find the Nth field, then
 *                          we return a pointer to the null terminator -
 *                          calling app should be sure to check for
 *                          this case.
 *
 */
LPTSTR FAR PASCAL PointerToNthField(LPTSTR lpszString, int nField, TCHAR chDelimiter)
{
        if (1 == nField)
                return lpszString;

        int cFieldFound = 1;
        LPTSTR lpField = lpszString;
        while (*lpField != '\0')
        {
                if (*lpField++ == chDelimiter)
                {
                        cFieldFound++;
                        if (nField == cFieldFound)
                                return lpField;
                }
        }
        return lpField;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\iconbox.cpp ===
/*
 * ICONBOX.CPP
 *
 * Implemenatation of an IconBox control for OLE 2.0 UI dialogs that we'll
 * use wherever a dialog needs an icon/label display.  Through the control's
 * interface we can change the image or control label visibility.
 *
 * The IconBox discusses images in CF_METAFILEPICT format.  When drawing
 * such a metafile, the entire aspect is centered in the IconBox, so long
 * labels are chopped at either end.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "iconbox.h"
#include "utility.h"
#include "uiclass.h"

OLEDBGDATA

//Flag indicating if we've registered the class
static BOOL fRegistered;


/*
 * FIconBoxInitialize
 *
 * Purpose:
 *  Registers the IconBox control class.
 *
 * Parameters:
 *  hInst           HINSTANCE instance of the DLL.
 *
 *  hPrevInst       HINSTANCE of the previous instance.  Used to
 *                  determine whether to register window classes or not.
 *
 * Return Value:
 *  BOOL            TRUE if all initialization succeeded, FALSE otherwise.
 */

#pragma code_seg(".text$initseg")

BOOL FIconBoxInitialize(HINSTANCE hInst, HINSTANCE hPrevInst)
{
        // Only register class if we're the first instance
        if (hPrevInst)
                fRegistered = TRUE;
        else
        {
                // Static flag fRegistered guards against calling this function more
                // than once
                if (!fRegistered)
                {
                        WNDCLASS wc;
                        wc.lpfnWndProc   =IconBoxWndProc;
                        wc.cbClsExtra    =0;
                        wc.cbWndExtra    =CBICONBOXWNDEXTRA;
                        wc.hInstance     =hInst;
                        wc.hIcon         =NULL;
                        wc.hCursor       =LoadCursor(NULL, IDC_ARROW);
                        wc.hbrBackground =(HBRUSH)NULL;
                        wc.lpszMenuName  =NULL;
                        wc.style         =CS_GLOBALCLASS | CS_VREDRAW | CS_HREDRAW;

                        wc.lpszClassName = TEXT(SZCLASSICONBOX1);
                        fRegistered = RegisterClass(&wc);

                        wc.lpszClassName = TEXT(SZCLASSICONBOX2);
                        fRegistered = RegisterClass(&wc);

                        wc.lpszClassName = TEXT(SZCLASSICONBOX3);
                        fRegistered = RegisterClass(&wc);
                }
        }
        return fRegistered;
}

#pragma code_seg()


/*
 * IconBoxUninitialize
 *
 * Purpose:
 *  Cleans up anything done in FIconBoxInitialize.  Currently there is
 *  nothing, but we do this for symmetry.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void IconBoxUninitialize(void)
{
        return;
}

/*
 * IconBoxWndProc
 *
 * Purpose:
 *  Window Procedure for the IconBox custom control.  Only handles
 *  WM_CREATE, WM_PAINT, and private messages to manipulate the image.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

LRESULT CALLBACK IconBoxWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        //Handle standard Windows messages.
        switch (iMsg)
        {
        case WM_CREATE:
                SetWindowLongPtr(hWnd, IBWW_HIMAGE, 0);
                SetWindowWord(hWnd, IBWW_FLABEL, TRUE);
                return (LRESULT)0;

        case WM_ERASEBKGND:
                {

                        RECT rect;
                        GetClientRect(hWnd, &rect);
                        HBRUSH hBrush = (HBRUSH)SendMessage(GetParent(hWnd), WM_CTLCOLORDLG,
                                wParam, (LPARAM)GetParent(hWnd));

                        if (!hBrush)
                                return FALSE;

                        UnrealizeObject(hBrush);

                        SetBrushOrgEx((HDC)wParam, 0, 0, NULL);
                        FillRect((HDC)wParam, &rect, hBrush);
                        return TRUE;
                }

        case WM_PAINT:
                {
                        HGLOBAL hMF = (HGLOBAL)GetWindowLongPtr(hWnd, IBWW_HIMAGE);

                        //BeginPaint and EndPaint clear us even if hMF is NULL.
                        PAINTSTRUCT ps;
                        HDC hDC = BeginPaint(hWnd, &ps);

                        if (NULL != hMF)
                        {
                                //Now we get to paint the metafile, centered in our rect.
                                RECT rc;
                                GetClientRect(hWnd, &rc);

                                /*
                                 * If we're doing icon only, then place the metafile
                                 * at the center of our box minus half the icon width.
                                 * Top is top.
                                 */
                                BOOL fLabel = GetWindowWord(hWnd, IBWW_FLABEL);

                                //Go draw where we decided to place it.
                                OleUIMetafilePictIconDraw(hDC, &rc, hMF, !fLabel);
                        }
                        EndPaint(hWnd, &ps);
                }
                break;

        case IBXM_IMAGESET:
                {
                        /*
                         * wParam is a flag to delete the old or not.
                         * lParam contains the new handle.
                         */
                        HGLOBAL hMF = (HGLOBAL)SetWindowLongPtr(hWnd, IBWW_HIMAGE, lParam);
                        InvalidateRect(hWnd, NULL, TRUE);
                        UpdateWindow(hWnd);

                        //Delete the old handle if requested
                        if (0L!=wParam)
                        {
                                OleUIMetafilePictIconFree(hMF);
                                hMF=NULL;
                        }
                        return (LRESULT)hMF;
                }

        case IBXM_IMAGEGET:
                {
                        //Return the current index.
                        HGLOBAL hMF=(HGLOBAL)GetWindowLongPtr(hWnd, IBWW_HIMAGE);
                        return (LRESULT)hMF;
                }

        case IBXM_IMAGEFREE:
                {
                        //Free up whatever we're holding.
                        HGLOBAL hMF=(HGLOBAL)GetWindowLongPtr(hWnd, IBWW_HIMAGE);
                        OleUIMetafilePictIconFree(hMF);
                        SetWindowLongPtr(hWnd, IBWW_HIMAGE, 0);
                        return (LRESULT)1;
                }

        case IBXM_LABELENABLE:
                //wParam has the new flag, returns the previous flag.
                return (LRESULT)SetWindowWord(hWnd, IBWW_FLABEL, (WORD)wParam);

        default:
                return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }

        return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\icon.cpp ===
/*
 * ICON.CPP
 *
 * Implements the OleUIChangeIcon function which invokes the complete
 * Change Icon dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "iconbox.h"
#include "strsafe.h"

OLEDBGDATA

ULONG
MyGetLongPathName(LPCTSTR pcsPath,
                 LPTSTR  pcsLongPath,
                 ULONG   cchLongPath);

#define CXICONPAD       (12)
#define CYICONPAD       (4)

// Internally used structure
typedef struct tagCHANGEICON
{
        LPOLEUICHANGEICON   lpOCI;      //Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */
        DWORD               dwFlags;
        HICON               hCurIcon;
        TCHAR               szLabel[OLEUI_CCHLABELMAX+1];
        TCHAR               szFile[MAX_PATH];
        UINT                iIcon;
        HICON               hDefIcon;
        TCHAR               szDefIconFile[MAX_PATH];
        UINT                iDefIcon;
        UINT                nBrowseHelpID;      // Help ID callback for Browse dlg

} CHANGEICON, *PCHANGEICON, FAR *LPCHANGEICON;

// Internal function prototypes
// ICON.CPP

INT_PTR CALLBACK ChangeIconDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FChangeIconInit(HWND, WPARAM, LPARAM);
UINT UFillIconList(HWND, UINT, LPTSTR, BOOL);
BOOL FDrawListIcon(LPDRAWITEMSTRUCT);
void UpdateResultIcon(LPCHANGEICON, HWND, UINT);

/*
 * OleUIChangeIcon
 *
 * Purpose:
 *  Invokes the standard OLE Change Icon dialog box allowing the user
 *  to select an icon from an icon file, executable, or DLL.
 *
 * Parameters:
 *  lpCI            LPOLEUIChangeIcon pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS or OLEUI_OK if all is well, otherwise
 *                  an error value.
 */
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON lpCI)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpCI, sizeof(OLEUICHANGEICON),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        // Check for a valid hMetaPict.
        if (NULL == lpCI->hMetaPict && NULL == lpCI->szIconExe && CLSID_NULL == lpCI->clsid)
        {
            return(OLEUI_CIERR_MUSTHAVECURRENTMETAFILE);
        }
        if (lpCI->hMetaPict != NULL && !IsValidMetaPict(lpCI->hMetaPict))
        {
            return(OLEUI_CIERR_MUSTHAVECURRENTMETAFILE);
        }

        // Test to be sure that the class ID matches a registered class ID
        // so we can return OLEUI_CIERR_MUSTHAVECLSID if necessary.
        HGLOBAL hTemp = OleGetIconOfClass(lpCI->clsid, NULL, TRUE);
        if (hTemp == NULL)
        {
            return(OLEUI_CIERR_MUSTHAVECLSID);
        }
        OleUIMetafilePictIconFree(hTemp);

        if (lpCI->dwFlags & CIF_USEICONEXE &&
                (lpCI->cchIconExe < 1 || lpCI->cchIconExe > MAX_PATH))
        {
                uRet = OLEUI_CIERR_SZICONEXEINVALID;
        }

        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }

        // Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(ChangeIconDialogProc, (LPOLEUISTANDARD)lpCI,
                hMemDlg, MAKEINTRESOURCE(IDD_CHANGEICON));
        return uRet;
}

/*
 * ChangeIconDialogProc
 *
 * Purpose:
 *  Implements the OLE Change Icon dialog as invoked through the
 *  OleUIChangeIcon function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */
INT_PTR CALLBACK ChangeIconDialogProc(HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{

        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        UINT uRet = 0;
        LPCHANGEICON lpCI = (LPCHANGEICON)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (INT_PTR)uRet;

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        TCHAR szTemp[MAX_PATH];
        HICON hIcon;
        HGLOBAL hMetaPict;

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpCI)
            {
                SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_RESETCONTENT, 0, 0L);
                StandardCleanup(lpCI, hDlg);
            }
            break;
        case WM_INITDIALOG:
                FChangeIconInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_MEASUREITEM:
                {
                        LPMEASUREITEMSTRUCT lpMI = (LPMEASUREITEMSTRUCT)lParam;

                        // All icons are system metric+padding in width and height
                        lpMI->itemWidth = GetSystemMetrics(SM_CXICON)+CXICONPAD;
                        lpMI->itemHeight= GetSystemMetrics(SM_CYICON)+CYICONPAD;
                }
                break;

        case WM_DRAWITEM:
                return FDrawListIcon((LPDRAWITEMSTRUCT)lParam);

        case WM_DELETEITEM:
                DestroyIcon((HICON)(((LPDELETEITEMSTRUCT)lParam)->itemData));
                break;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_CI_CURRENT:
                case IDC_CI_DEFAULT:
                case IDC_CI_FROMFILE:
                        if (lpCI != NULL)
                                UpdateResultIcon(lpCI, hDlg, (UINT)-1);
                        break;

                case IDC_CI_LABELEDIT:
                        if (lpCI != NULL && EN_KILLFOCUS == wCode)
                                UpdateResultIcon(lpCI, hDlg, (UINT)-1);
                        break;

                case IDC_CI_FROMFILEEDIT:
                        GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, szTemp, sizeof(szTemp)/sizeof(TCHAR));
                        if (lpCI != NULL)
                        {
                                if (wCode == EN_KILLFOCUS)
                                {
                                        if (lstrcmpi(szTemp, lpCI->szFile))
                                        {
                                                StringCchCopy(lpCI->szFile, MAX_PATH, szTemp);
                                                UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, FALSE);
                                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                        }
                                }
                                else if (wCode == EN_SETFOCUS)
                                {
                                        UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                }
                        }
                        break;

                case IDC_CI_ICONLIST:
                        switch (wCode)
                        {
                        case LBN_SETFOCUS:
                                // If we got the focus, see about updating.
                                GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, szTemp, sizeof(szTemp)/sizeof(TCHAR));

                                // Check if file changed and update the list if so
                                if (lpCI && 0 != lstrcmpi(szTemp, lpCI->szFile))
                                {
                                        StringCchCopy(lpCI->szFile, MAX_PATH, szTemp);
                                        UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, FALSE);
                                }
                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                break;

                        case LBN_SELCHANGE:
                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                break;

                        case LBN_DBLCLK:
                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                                break;
                        }
                        break;

                case IDC_CI_BROWSE:
                        {
                                StringCchCopy(szTemp,  sizeof(szTemp)/sizeof(TCHAR), lpCI->szFile);
                                uRet = UStandardHook(lpCI, hDlg, uMsgBrowse, MAX_PATH_SIZE,
                                        (LPARAM)lpCI->szFile);

                                DWORD dwOfnFlags = OFN_FILEMUSTEXIST;
                                if (lpCI->lpOCI->dwFlags & CIF_SHOWHELP)
                                   dwOfnFlags |= OFN_SHOWHELP;

                                if (0 == uRet)
                                {
                                        uRet = (BOOL)Browse(hDlg, lpCI->szFile, NULL, MAX_PATH_SIZE,
                                                IDS_ICONFILTERS, dwOfnFlags, ID_BROWSE_CHANGEICON, NULL);
                                }

                                if (0 != uRet && 0 != lstrcmpi(szTemp, lpCI->szFile))
                                {
                                        SetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpCI->szFile);
                                        UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, TRUE);
                                        UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                }
                        }
                        break;

                case IDOK:
                        {
                            HWND hwndCtl = GetDlgItem(hDlg, IDOK);
                            if (hwndCtl == GetFocus())
                            {
                                GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, szTemp, sizeof(szTemp)/sizeof(TCHAR));

                                // Check if the file name is valid
                                // if SelectFromFile radio button selected
                                if (lpCI->dwFlags & CIF_SELECTFROMFILE)
                                {
                                        // Check if the file changed at all.
                                        if (0 != lstrcmpi(szTemp, lpCI->szFile))
                                        {
                                                StringCchCopy(lpCI->szFile, MAX_PATH, szTemp);
                                                // file changed.  May need to expand the name
                                                // calling DoesFileExist will do the trick
                                                DoesFileExist(lpCI->szFile, MAX_PATH);
                                                UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, TRUE);
                                                SetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpCI->szFile);
                                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                                return TRUE; // eat this message to prevent focus change.
                                        }
                                        if (!DoesFileExist(lpCI->szFile, MAX_PATH))
                                        {
                                                OpenFileError(hDlg, ERROR_FILE_NOT_FOUND, lpCI->szFile);
                                                HWND hWnd = GetDlgItem(hDlg, IDC_CI_FROMFILEEDIT);
                                                SetFocus(hWnd);
                                                SendMessage(hWnd, EM_SETSEL, 0, -1);
                                                return TRUE;  // eat this message
                                        }
                                }

                                // Get current metafile image
                                UpdateResultIcon(lpCI, hDlg, (UINT)-1);
                                hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, IDC_CI_ICONDISPLAY,
                                        IBXM_IMAGEGET, 0, 0);

                                // Clean up the current icon that we extracted.
                                hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_GETICON, 0, 0L);
                                DestroyIcon(hIcon);

                                // Clean up the default icon
                                DestroyIcon(lpCI->hDefIcon);

                                // Remove the prop set on our parent
                                RemoveProp(lpCI->lpOCI->hWndOwner, PROP_HWND_CHGICONDLG);

                                OleUIMetafilePictIconFree(lpCI->lpOCI->hMetaPict);
                                lpCI->lpOCI->hMetaPict = hMetaPict;
                                lpCI->lpOCI->dwFlags = lpCI->dwFlags;
                                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                            }
                            else
                            {
                                SetFocus(hwndCtl);
                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                            }
                            break;
                        }

                case IDCANCEL:
                        // Free current icon display image
                        SendDlgItemMessage(hDlg, IDC_CI_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0);

                        // Clean up the current icon that we extracted.
                        hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_GETICON, 0, 0L);
                        DestroyIcon(hIcon);

                        // Clean up the default icon
                        DestroyIcon(lpCI->hDefIcon);

                        // Remove the prop set on our parent
                        RemoveProp(lpCI->lpOCI->hWndOwner, PROP_HWND_CHGICONDLG);

                        // We leave hMetaPict intact on Cancel; caller's responsibility
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;

                case IDC_OLEUIHELP:
                        PostMessage(lpCI->lpOCI->hWndOwner, uMsgHelp,
                                                (WPARAM)hDlg, MAKELPARAM(IDD_CHANGEICON, 0));
                        break;
                }
                break;

        default:
                if (lpCI && iMsg == lpCI->nBrowseHelpID)
                {
                        PostMessage(lpCI->lpOCI->hWndOwner, uMsgHelp,
                                        (WPARAM)hDlg, MAKELPARAM(IDD_CHANGEICONBROWSE, 0));
                }
                if (iMsg == uMsgBrowseOFN &&
                        lpCI && lpCI->lpOCI && lpCI->lpOCI->hWndOwner)
                {
                        SendMessage(lpCI->lpOCI->hWndOwner, uMsgBrowseOFN, wParam, lParam);
                }
                break;
        }

        return FALSE;
}

/*
 * FChangeIconInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Change Icon dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FChangeIconInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        LPCHANGEICON lpCI = (LPCHANGEICON)LpvStandardInit(hDlg, sizeof(CHANGEICON));

        // LpvStandardInit send a termination to us already.
        if (NULL == lpCI)
                return FALSE;

        // Save the original pointer and copy necessary information.
        LPOLEUICHANGEICON lpOCI = (LPOLEUICHANGEICON)lParam;
        lpCI->lpOCI = lpOCI;
        lpCI->nIDD = IDD_CHANGEICON;
        lpCI->dwFlags = lpOCI->dwFlags;

        // Go extract the icon source from the metafile.
        TCHAR szTemp[MAX_PATH];
	szTemp[0] = 0;
        OleUIMetafilePictExtractIconSource(lpOCI->hMetaPict, szTemp, &lpCI->iIcon);
        MyGetLongPathName(szTemp, lpCI->szFile, MAX_PATH);

        // Go extract the icon and the label from the metafile
        OleUIMetafilePictExtractLabel(lpOCI->hMetaPict, lpCI->szLabel, OLEUI_CCHLABELMAX_SIZE, NULL);
        lpCI->hCurIcon = OleUIMetafilePictExtractIcon(lpOCI->hMetaPict);

        // Show or hide the help button
        if (!(lpCI->dwFlags & CIF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Set text limits and initial control contents
        SendDlgItemMessage(hDlg, IDC_CI_LABELEDIT, EM_LIMITTEXT, OLEUI_CCHLABELMAX, 0L);
        SendDlgItemMessage(hDlg, IDC_CI_FROMFILEEDIT, EM_LIMITTEXT, MAX_PATH,  0L);
        SetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpCI->szFile);

        // Copy the label text into the edit and static controls.
        SetDlgItemText(hDlg, IDC_CI_LABELEDIT,   lpCI->szLabel);

        lpCI->hDefIcon = NULL;
        if (lpCI->dwFlags & CIF_USEICONEXE)
        {
                lpCI->hDefIcon = StandardExtractIcon(_g_hOleStdInst, lpCI->lpOCI->szIconExe, 0);
                if (NULL != lpCI->hDefIcon)
                {
                        StringCchCopy(lpCI->szDefIconFile, MAX_PATH, lpCI->lpOCI->szIconExe);
                        lpCI->iDefIcon = 0;
                }
        }

        if (NULL == lpCI->hDefIcon)
        {
                HGLOBAL hMetaPict;
                hMetaPict = OleGetIconOfClass(lpCI->lpOCI->clsid, NULL, TRUE);
                lpCI->hDefIcon = OleUIMetafilePictExtractIcon(hMetaPict);
                TCHAR szTemp[MAX_PATH];
                OleUIMetafilePictExtractIconSource(hMetaPict,
                        szTemp, &lpCI->iDefIcon);
                MyGetLongPathName(szTemp, lpCI->szDefIconFile, MAX_PATH);
                OleUIMetafilePictIconFree(hMetaPict);
        }

        // Initialize all the icon displays.
        SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_SETICON,
           (WPARAM)lpCI->hCurIcon, 0L);
        SendDlgItemMessage(hDlg, IDC_CI_DEFAULTICON, STM_SETICON,
           (WPARAM)lpCI->hDefIcon, 0L);

        /*
         *  Since we cannot predict the size of icons on any display,
         *  we have to resize the icon listbox to the size of an icon
         *  (plus padding), a scrollbar, and two borders (top & bottom).
         */
        UINT cyList = GetSystemMetrics(SM_CYICON)+GetSystemMetrics(SM_CYHSCROLL)
                   +GetSystemMetrics(SM_CYBORDER)*2+CYICONPAD;
        HWND hList = GetDlgItem(hDlg, IDC_CI_ICONLIST);
        RECT rc;
        GetClientRect(hList, &rc);
        SetWindowPos(hList, NULL, 0, 0, rc.right, cyList, SWP_NOMOVE | SWP_NOZORDER);

        // Set the columns in this multi-column listbox to hold one icon
        SendMessage(hList, LB_SETCOLUMNWIDTH,
                GetSystemMetrics(SM_CXICON)+CXICONPAD,0L);

        /*
         *  If the listbox expanded below the group box, then size
         *  the groupbox down, move the label static and exit controls
         *  down, and expand the entire dialog appropriately.
         */
        GetWindowRect(hList, &rc);
        RECT rcG;
        GetWindowRect(GetDlgItem(hDlg, IDC_CI_GROUP), &rcG);
        if (rc.bottom > rcG.bottom)
        {
                // Calculate amount to move things down.
                cyList=(rcG.bottom-rcG.top)-(rc.bottom-rc.top-cyList);

                // Expand the group box.
                rcG.right -=rcG.left;
                rcG.bottom-=rcG.top;
                SetWindowPos(GetDlgItem(hDlg, IDC_CI_GROUP), NULL, 0, 0,
                        rcG.right, rcG.bottom+cyList, SWP_NOMOVE | SWP_NOZORDER);

                // Expand the dialog box.
                GetClientRect(hDlg, &rc);
                SetWindowPos(hDlg, NULL, 0, 0, rc.right, rc.bottom+cyList,
                        SWP_NOMOVE | SWP_NOZORDER);

                // Move the label and edit controls down.
                GetClientRect(GetDlgItem(hDlg, IDC_CI_LABEL), &rc);
                SetWindowPos(GetDlgItem(hDlg, IDC_CI_LABEL), NULL, 0, cyList,
                        rc.right, rc.bottom, SWP_NOSIZE | SWP_NOZORDER);

                GetClientRect(GetDlgItem(hDlg, IDC_CI_LABELEDIT), &rc);
                SetWindowPos(GetDlgItem(hDlg, IDC_CI_LABELEDIT), NULL, 0, cyList,
                        rc.right, rc.bottom, SWP_NOSIZE | SWP_NOZORDER);
        }

        /*
         *  Select Current, Default, or From File radiobuttons appropriately.
         *  The CheckRadioButton call sends WM_COMMANDs which handle
         *  other actions.  Note that if we check From File, which
         *  takes an icon from the list, we better fill the list.
         *  This will also fill the list even if default is selected.
         */
        if (0 != UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, FALSE))
        {
                // If szFile worked, then select the source icon in the listbox.
                SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_SETCURSEL, lpCI->iIcon, 0L);
        }

        if (lpCI->dwFlags & CIF_SELECTCURRENT)
        {
                CheckRadioButton(hDlg, IDC_CI_CURRENT, IDC_CI_FROMFILE, IDC_CI_CURRENT);
        }
        else
        {
                UINT uID = (lpCI->dwFlags & CIF_SELECTFROMFILE) ? IDC_CI_FROMFILE : IDC_CI_DEFAULT;
                CheckRadioButton(hDlg, IDC_CI_CURRENT, IDC_CI_FROMFILE, uID);
        }
        UpdateResultIcon(lpCI, hDlg, (UINT)-1);

        // Change the caption
        if (NULL!=lpOCI->lpszCaption)
                SetWindowText(hDlg, lpOCI->lpszCaption);

        /*  Give our parent window access to our hDlg (via a special SetProp).
         *  The PasteSpecial dialog may need to force our dialog down if the
         *  clipboard contents change underneath it. if so it will send
         *  us a IDCANCEL command.
         */
        SetProp(lpCI->lpOCI->hWndOwner, PROP_HWND_CHGICONDLG, hDlg);
        lpCI->nBrowseHelpID = RegisterWindowMessage(HELPMSGSTRING);

        // Call the hook with lCustData in lParam
        UStandardHook(lpCI, hDlg, WM_INITDIALOG, wParam, lpOCI->lCustData);
        return TRUE;
}

/*
 * UFillIconList
 *
 * Purpose:
 *  Given a listbox and a filename, attempts to open that file and
 *  read all the icons that exist therein, adding them to the listbox
 *  hList as owner-draw items.  If the file does not exist or has no
 *  icons, then you get no icons and an appropriate warning message.
 *
 * Parameters:
 *  hDlg            HWND of the dialog containing the listbox.
 *  idList          UINT identifier of the listbox to fill.
 *  pszFile         LPSTR of the file from which to extract icons.
 *
 * Return Value:
 *  UINT            Number of items added to the listbox.  0 on failure.
 */
UINT UFillIconList(HWND hDlg, UINT idList, LPTSTR pszFile, BOOL bError)
{
        HWND hList = GetDlgItem(hDlg, idList);
        if (NULL == hList)
                return 0;

        // Clean out the listbox.
        SendMessage(hList, LB_RESETCONTENT, 0, 0L);

        // If we have an empty string, just exit leaving the listbox empty as well
        if (0 == lstrlen(pszFile))
                return 0;

        // Turn on the hourglass
        HCURSOR hCur = HourGlassOn();
        UINT nFileError = 0;

        // Check if the file is valid.
        TCHAR szPathName[MAX_PATH];
        LPTSTR lpszFilePart = NULL;
        UINT cIcons = 0;
        if (SearchPath(NULL, pszFile, NULL, MAX_PATH, szPathName, &lpszFilePart) != 0)
        {
                // This hack is still necessary in Win32 because even under
                // Win32s this ExtractIcon bug appears.
           #ifdef EXTRACTICONWORKS
                // Get the icon count for this file.
                cIcons = (UINT)StandardExtractIcon(_g_hOleStdInst, szPathName, (UINT)-1);
           #else
                /*
                 * ExtractIcon in Windows 3.1 with -1 eats a selector, leaving an
                 * extra global memory object around for this applciation.  Since
                 * changing icons may happen very often with all OLE apps in
                 * the system, we have to work around it.  So we'll say we
                 * have lots of icons and just call ExtractIcon until it
                 * fails.  We check if there's any around by trying to get
                 * the first one.
                 */
                cIcons = 0xFFFF;
                HICON hIcon = StandardExtractIcon(_g_hOleStdInst, szPathName, 0);

                // Fake a failure with cIcons=0, or cleanup hIcon from this test.
                if (NULL == hIcon || 1 == HandleToUlong(hIcon))
                        cIcons = 0;
                else
                        DestroyIcon(hIcon);
           #endif

                if (0 != cIcons)
                {
                        SendMessage(hList, WM_SETREDRAW, FALSE, 0L);
                        for (UINT i = 0; i < cIcons; i++)
                        {
                                hIcon=StandardExtractIcon(_g_hOleStdInst, szPathName, i);
                                if (hIcon != NULL)
                                        SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)hIcon);
                                else
                                        break;
                        }

                        //Force complete repaint
                        SendMessage(hList, WM_SETREDRAW, TRUE, 0L);
                        InvalidateRect(hList, NULL, TRUE);

                        //Select an icon
                        SendMessage(hList, LB_SETCURSEL, 0, 0L);
                }
                else
                        nFileError = IDS_CINOICONSINFILE;
        }
        else
                nFileError = ERROR_FILE_NOT_FOUND;

        // show error if necessary and possible
        if (nFileError && bError)
        {
                ErrorWithFile(hDlg, _g_hOleStdResInst, nFileError, szPathName,
                        MB_OK | MB_ICONEXCLAMATION);
        }

        HourGlassOff(hCur);
        return cIcons;
}

/*
 * FDrawListIcon
 *
 * Purpose:
 *  Handles WM_DRAWITEM for the icon listbox.
 *
 * Parameters:
 *  lpDI            LPDRAWITEMSTRUCT from WM_DRAWITEM
 *
 * Return Value:
 *  BOOL            TRUE if we did anything, FALSE if there are no items
 *                  in the list.
 */
BOOL FDrawListIcon(LPDRAWITEMSTRUCT lpDI)
{
        /*
         * If there are no items in the list, then itemID is negative according
         * to the Win3.1 SDK.  Unfortunately DRAWITEMSTRUCT has an unsigned int
         * for this field, so we need the typecast to do a signed comparison.
         */
        if ((int)lpDI->itemID < 0)
                return FALSE;

        /*
         * For selection or draw entire case we just draw the entire item all
         * over again.  For focus cases, we only call DrawFocusRect.
         */
        if (lpDI->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))
        {
                COLORREF cr;

                // Clear background and draw the icon.
                if (lpDI->itemState & ODS_SELECTED)
                        cr = SetBkColor(lpDI->hDC, GetSysColor(COLOR_HIGHLIGHT));
                else
                        cr = SetBkColor(lpDI->hDC, GetSysColor(COLOR_WINDOW));

                // Draw a cheap rectangle.
                ExtTextOut(lpDI->hDC, 0, 0, ETO_OPAQUE, &lpDI->rcItem, NULL, 0, NULL);
                DrawIcon(lpDI->hDC, lpDI->rcItem.left+(CXICONPAD/2),
                        lpDI->rcItem.top+(CYICONPAD/2), (HICON)(lpDI->itemData));

                // Restore original background for DrawFocusRect
                SetBkColor(lpDI->hDC, cr);
        }

        // Always change focus on the focus action.
        if (lpDI->itemAction & ODA_FOCUS || lpDI->itemState & ODS_FOCUS)
                DrawFocusRect(lpDI->hDC, &lpDI->rcItem);

        return TRUE;
}

/*
 * UpdateResultIcon
 *
 * Purpose:
 *  Updates the result icon using the current icon in the default display
 *  or the icon listbox depending on fFromDefault.
 *
 * Parameters:
 *  lpCI            LPCHANGEICON containing dialog flags.
 *  hDlg            HWND of the dialog
 *  uID             UINT identifying the radiobutton selected.
 *
 * Return Value:
 *  None
 */
void UpdateResultIcon(LPCHANGEICON lpCI, HWND hDlg, UINT uID)
{
        if (uID == -1)
        {
                if (SendDlgItemMessage(hDlg, IDC_CI_CURRENT, BM_GETCHECK, 0, 0))
                        uID = IDC_CI_CURRENT;
                else if (SendDlgItemMessage(hDlg, IDC_CI_DEFAULT, BM_GETCHECK, 0, 0))
                        uID = IDC_CI_DEFAULT;
                else if (SendDlgItemMessage(hDlg, IDC_CI_FROMFILE, BM_GETCHECK, 0, 0))
                        uID = IDC_CI_FROMFILE;
        }

        lpCI->dwFlags &= ~(CIF_SELECTCURRENT | CIF_SELECTDEFAULT | CIF_SELECTFROMFILE);
        LRESULT lTemp = -1;

        switch (uID)
        {
        case IDC_CI_CURRENT:
                lTemp = SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_GETICON, 0, 0L);
                lpCI->dwFlags |= CIF_SELECTCURRENT;
                break;

        case IDC_CI_DEFAULT:
                lTemp = SendDlgItemMessage(hDlg, IDC_CI_DEFAULTICON, STM_GETICON, 0, 0L);
                lpCI->dwFlags |= CIF_SELECTDEFAULT;
                break;

        case IDC_CI_FROMFILE:
                {
                        // Get the selected icon from the list and place it in the result
                        lpCI->dwFlags |= CIF_SELECTFROMFILE;
                        UINT iSel = (UINT)SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_GETCURSEL, 0, 0L);
                        if (LB_ERR == (int)iSel)
                                lTemp = SendDlgItemMessage(hDlg, IDC_CI_DEFAULTICON, STM_GETICON, 0, 0L);
                        else
                                lTemp = SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_GETITEMDATA, iSel, 0);
                        break;
                }

        default:
                OleDbgAssert(FALSE);
                break;
        }
        CheckRadioButton(hDlg, IDC_CI_CURRENT, IDC_CI_FROMFILE, uID);

        // set current icon display as a result of the controls
        LPTSTR lpszSourceFile = lpCI->szFile;
        if (lpCI->dwFlags & CIF_SELECTDEFAULT)
        {
                // use defaults
                lpszSourceFile = lpCI->szDefIconFile;
                lpCI->iIcon = lpCI->iDefIcon;
        }
        else if (lpCI->dwFlags & CIF_SELECTCURRENT)
        {
                TCHAR szTemp[MAX_PATH];
                OleUIMetafilePictExtractIconSource(lpCI->lpOCI->hMetaPict,
                        szTemp, &lpCI->iIcon);
                MyGetLongPathName(szTemp, lpszSourceFile, MAX_PATH);
        }
        else if (lpCI->dwFlags & CIF_SELECTFROMFILE)
        {
                // get from file and index
                GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpszSourceFile, MAX_PATH);
                lpCI->iIcon = (UINT)SendDlgItemMessage(hDlg,
                        IDC_CI_ICONLIST, LB_GETCURSEL, 0, 0L);
        }

        // Get new hMetaPict and set result text
        TCHAR szTemp[MAX_PATH];
        GetDlgItemText(hDlg, IDC_CI_LABELEDIT, szTemp, MAX_PATH);
        TCHAR szShortFile[MAX_PATH];
        GetShortPathName(lpszSourceFile, szShortFile, MAX_PATH);
        HGLOBAL hMetaPict = OleMetafilePictFromIconAndLabel(
                (HICON)lTemp, szTemp, szShortFile, lpCI->iIcon);
        SendDlgItemMessage(hDlg, IDC_CI_ICONDISPLAY, IBXM_IMAGESET, 1,
                (LPARAM)hMetaPict);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsLongComponent, public
//
//  Synopsis:   Determines whether the current path component is a legal
//              8.3 name or not.  If not, it is considered to be a long
//              component.
//
//  Arguments:  [pwcsPath] - Path to check
//              [ppwcsEnd] - Return for end of component pointer
//
//  Returns:    BOOL
//
//  Modifies:   [ppwcsEnd]
//
//  History:    28-Aug-94       DrewB   Created
//              5-04-95         stevebl Modified for use by oledlg
//
//  Notes:      An empty path is considered to be long
//              The following characters are not valid in file name domain:
//              * + , : ; < = > ? [ ] |
//
//----------------------------------------------------------------------------

BOOL IsLongComponent(LPCTSTR pwcsPath,
                     PTSTR *ppwcsEnd)
{
    LPTSTR pwcEnd, pwcDot;
    BOOL fLongNameFound;
    TCHAR wc;

    pwcEnd = (LPTSTR)pwcsPath;
    fLongNameFound = FALSE;
    pwcDot = NULL;

    while (TRUE)
    {
        wc = *pwcEnd;

        if (wc == '\\' || wc == 0)
        {
            *ppwcsEnd = pwcEnd;

            // We're at a component terminator, so make the
            // determination of whether what we've seen is a long
            // name or short one

            // If we've aready seen illegal characters or invalid
            // structure for a short name, don't bother to check lengths
            if (pwcEnd-pwcsPath > 0 && !fLongNameFound)
            {
                // If this component fits in 8.3 then it is a short name
                if ((!pwcDot && (ULONG)(pwcEnd - pwcsPath) <= 8) ||
                    (pwcDot && ((ULONG)(pwcEnd - pwcDot) <= 3 + 1 &&
                                (ULONG)(pwcEnd - pwcsPath) <= 8 + 3 + 1)))
                {
                    return FALSE;
                }
            }

            return TRUE;
        }

        // Handle dots
        if (wc == '.')
        {
            // If two or more '.' or the base name is longer than
            // 8 characters or no base name at all, it is an illegal dos
            // file name
            if (pwcDot != NULL ||
                ((ULONG)(pwcEnd - pwcsPath)) > 8 ||
                (pwcEnd == pwcsPath && *(pwcEnd + 1) != '\\'))
            {
                fLongNameFound = TRUE;
            }

            pwcDot = pwcEnd;
        }

        // Check for characters which aren't valid in short names
        else if (wc <= ' ' ||
                 wc == '*' ||
                 wc == '+' ||
                 wc == ',' ||
                 wc == ':' ||
                 wc == ';' ||
                 wc == '<' ||
                 wc == '=' ||
                 wc == '>' ||
                 wc == '?' ||
                 wc == '[' ||
                 wc == ']' ||
                 wc == '|')
        {
            fLongNameFound = TRUE;
        }

        pwcEnd++;
    }
}

//
// The following code was stolen from NT's RTL in curdir.c
//

#define IS_PATH_SEPARATOR(wch) \
    ((wch) == '\\' || (wch) == '/')

typedef enum
{
    PATH_TYPE_UNKNOWN,
    PATH_TYPE_UNC_ABSOLUTE,
    PATH_TYPE_LOCAL_DEVICE,
    PATH_TYPE_ROOT_LOCAL_DEVICE,
    PATH_TYPE_DRIVE_ABSOLUTE,
    PATH_TYPE_DRIVE_RELATIVE,
    PATH_TYPE_ROOTED,
    PATH_TYPE_RELATIVE
} PATH_TYPE;

PATH_TYPE
DetermineDosPathNameType(
    IN LPCTSTR DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    PATH_TYPE_UNKNOWN - The path type can not be determined

    PATH_TYPE_UNC_ABSOLUTE - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    PATH_TYPE_LOCAL_DEVICE - The path specifies a local device in the format
        \\.\rest-of-path this can be used for any device where the nt and
        Win32 names are the same. For example mailslots.

    PATH_TYPE_ROOT_LOCAL_DEVICE - The path specifies the root of the local
        devices in the format \\.

    PATH_TYPE_DRIVE_ABSOLUTE - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    PATH_TYPE_DRIVE_RELATIVE - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    PATH_TYPE_ROOTED - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    PATH_TYPE_RELATIVE - The path is relative (i.e. not absolute or rooted).

--*/

{
    PATH_TYPE ReturnValue;

    if ( IS_PATH_SEPARATOR(*DosFileName) )
    {
        if ( IS_PATH_SEPARATOR(*(DosFileName+1)) )
        {
            if ( DosFileName[2] == '.' )
            {
                if ( IS_PATH_SEPARATOR(*(DosFileName+3)) )
                {
                    ReturnValue = PATH_TYPE_LOCAL_DEVICE;
                }
                else if ( (*(DosFileName+3)) == 0 )
                {
                    ReturnValue = PATH_TYPE_ROOT_LOCAL_DEVICE;
                }
                else
                {
                    ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
                }
            }
            else
            {
                ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
            }
        }
        else
        {
            ReturnValue = PATH_TYPE_ROOTED;
        }
    }
    else if (*(DosFileName+1) == ':')
    {
        if (IS_PATH_SEPARATOR(*(DosFileName+2)))
        {
            ReturnValue = PATH_TYPE_DRIVE_ABSOLUTE;
        }
        else
        {
            ReturnValue = PATH_TYPE_DRIVE_RELATIVE;
        }
    }
    else
    {
        ReturnValue = PATH_TYPE_RELATIVE;
    }

    return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   MyGetLongPathName, public
//
//  Synopsis:   Expand each component of the given path into its
//              long form
//
//  Arguments:  [pwcsPath] - Path
//              [pwcsLongPath] - Long path return buffer
//              [cchLongPath] - Size of return buffer in characters
//
//  Returns:    0 for errors
//              Number of characters needed for buffer if buffer is too small
//                includes NULL terminator
//              Length of long path, doesn't include NULL terminator
//
//  Modifies:   [pwcsLongPath]
//
//  History:    28-Aug-94       DrewB   Created
//              11-Nov-94       BruceMa Modifed to use for Chicago at
//                                      FindFirstFile
//              5-04-95         stevebl Modified for use by OLEDLG
//
//  Notes:      The source and destination buffers can be the same memory
//              Doesn't handle paths with internal . and .., although
//              they are handled at the beginning
//
//----------------------------------------------------------------------------

ULONG
MyGetLongPathName(LPCTSTR pcsPath,
                 LPTSTR  pwcsLongPath,
                 ULONG   cchLongPath)
{
    PATH_TYPE pt;
    HANDLE h;
    LPTSTR pwcsLocalLongPath;
    ULONG cchReturn, cb, cch, cchOutput;
    LPTSTR pwcStart = NULL;
    LPTSTR pwcEnd;
    LPTSTR pwcLong;
    TCHAR wcSave;
    BOOL fLong;
    WIN32_FIND_DATA wfd;
    cchReturn = 0;
    pwcsLocalLongPath = NULL;

    __try
    {
        //
        // First, run down the string checking for tilde's. Any path
        // that has a short name section to it will have a tilde. If
        // there are no tilde's, then we already have the long path,
        // so we can return the string.
        //
        fLong = TRUE;
        for (pwcLong = (LPTSTR)pcsPath; *pwcLong != 0; pwcLong++)
        {
            if (*pwcLong == L'~')
            {
                fLong = FALSE;
            }
        }
        //
        // This derives the number of characters, including the NULL
        //
        cch = ((ULONG)(pwcLong - pcsPath)) + 1;

        //
        // If it isn't a long path already, then we are going to have
        // to parse it.
        //
        if (!fLong)
        {
            // Decide the path type, we want find out the position of
            // the first character of the first name
            pt = DetermineDosPathNameType(pcsPath);
            switch(pt)
            {
                // Form: "\\server_name\share_name\rest_of_the_path"
            case PATH_TYPE_UNC_ABSOLUTE:
#if defined(UNICODE)
                if ((pwcStart = wcschr(pcsPath + 2, L'\\')) != NULL &&
                    (pwcStart = wcschr(pwcStart + 1, L'\\')) != NULL)
#else
                if ((pwcStart = strchr(pcsPath + 2, '\\')) != NULL &&
                    (pwcStart = strchr(pwcStart + 1, '\\')) != NULL)
#endif
                {
                    pwcStart++;
                }
                else
                {
                    pwcStart = NULL;
                }
                break;

                // Form: "\\.\rest_of_the_path"
            case PATH_TYPE_LOCAL_DEVICE:
                pwcStart = (LPTSTR)pcsPath + 4;
                break;

                // Form: "\\."
            case PATH_TYPE_ROOT_LOCAL_DEVICE:
                pwcStart = NULL;
                break;

                // Form: "D:\rest_of_the_path"
            case PATH_TYPE_DRIVE_ABSOLUTE:
                pwcStart = (LPTSTR)pcsPath + 3;
                break;

                // Form: "rest_of_the_path"
            case PATH_TYPE_RELATIVE:
                pwcStart = (LPTSTR) pcsPath;
                goto EatDots;

                // Form: "D:rest_of_the_path"
            case PATH_TYPE_DRIVE_RELATIVE:
                pwcStart = (LPTSTR)pcsPath+2;

            EatDots:
                // Handle .\ and ..\ cases
                while (*pwcStart != 0 && *pwcStart == L'.')
                {
                    if (pwcStart[1] == L'\\')
                    {
                        pwcStart += 2;
                    }
                    else if (pwcStart[1] == L'.' && pwcStart[2] == L'\\')
                    {
                        pwcStart += 3;
                    }
                    else
                    {
                        break;
                    }
                }
                break;

                // Form: "\rest_of_the_path"
            case PATH_TYPE_ROOTED:
                pwcStart = (LPTSTR)pcsPath + 1;
                break;

            default:
                pwcStart = NULL;
                break;
            }
        }

        // In the special case where we have no work to do, exit quickly
        // This saves a lot of instructions for trivial cases
        // In one case the path as given requires no processing
        // The middle case, we determine there were no tilde's in the path
        // In the other, the path only has one component and it is already
        // long
        ///
        if (pwcStart == NULL ||
            (fLong == TRUE) ||
            ((fLong = IsLongComponent(pwcStart, &pwcEnd)) &&
             *pwcEnd == 0))
        {
            // Nothing to convert, copy down the source string
            // to the buffer if necessary

            if (pwcStart != NULL)
            {
                cch = (ULONG)(pwcEnd - pcsPath + 1);
            }

            if (cchLongPath >= cch)
            {
                memcpy(pwcsLongPath, pcsPath, cch * sizeof(TCHAR));

                cchReturn = cch - 1;
                goto gsnTryExit;
            }
            else
            {
                cchReturn = cch;
                goto gsnTryExit;
            }
        }

        // Make a local buffer so that we won't overlap the
        // source pathname in case the long name is longer than the
        // source name.
        if (cchLongPath > 0)
        {
            pwcsLocalLongPath = (PTCHAR)malloc(cchLongPath * sizeof(TCHAR));
            if (pwcsLocalLongPath == NULL)
            {
                goto gsnTryExit;
            }
        }

        // Set up pointer to copy output to
        pwcLong = pwcsLocalLongPath;
        cchOutput = 0;

        // Copy the portions of the path that we skipped initially
        cch = (ULONG)(pwcStart-pcsPath);
        cchOutput += cch;
        if (cchOutput <= cchLongPath)
        {
            memcpy(pwcLong, pcsPath, cch*sizeof(TCHAR));
            pwcLong += cch;
        }

        for (;;)
        {
            // Determine whether the current component is long or short
            cch = ((ULONG)(pwcEnd-pwcStart))+1;
            cb = cch*sizeof(TCHAR);

            if (fLong)
            {
                // If the component is already long, just copy it into
                // the output.  Copy the terminating character along with it
                // so the output remains properly punctuated

                cchOutput += cch;
                if (cchOutput <= cchLongPath)
                {
                    memcpy(pwcLong, pwcStart, cb);
                    pwcLong += cch;
                }
            }
            else
            {
                TCHAR wcsTmp[MAX_PATH];

                // For a short component we need to determine the
                // long name, if there is one.  The only way to
                // do this reliably is to enumerate for the child

                wcSave = *pwcEnd;
                *pwcEnd = 0;

                h = FindFirstFile(pcsPath, &wfd);
                *pwcEnd = wcSave;

                if (h == INVALID_HANDLE_VALUE)
                {
                    goto gsnTryExit;
                }

                FindClose(h);

                lstrcpyn(wcsTmp, wfd.cFileName, MAX_PATH);

                // Copy the filename returned by the query into the output
                // Copy the terminator from the original component into
                // the output to maintain punctuation
                cch = lstrlen(wcsTmp)+1;
                cchOutput += cch;
                if (cchOutput <= cchLongPath)
                {
                    memcpy(pwcLong, wcsTmp, (cch-1)*sizeof(TCHAR));
                    pwcLong += cch;
                    *(pwcLong-1) = *pwcEnd;
                }
            }

            if (*pwcEnd == 0)
            {
                break;
            }

            // Update start pointer to next component
            pwcStart = pwcEnd+1;
            fLong = IsLongComponent(pwcStart, &pwcEnd);
        }

        // Copy local output buffer to given output buffer if necessary
        if (cchLongPath >= cchOutput)
        {
            memcpy(pwcsLongPath, pwcsLocalLongPath, cchOutput * sizeof(TCHAR));
            cchReturn = cchOutput-1;
        }
        else
        {
            cchReturn = cchOutput;
        }

gsnTryExit:;
    }
    __finally
    {
        if (pwcsLocalLongPath != NULL)
        {
            free(pwcsLocalLongPath);
            pwcsLocalLongPath = NULL;
        }
    }

    return cchReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\links.cpp ===
/*
 * links.c
 *
 * Implements the OleUIEditLinks function which invokes the complete
 * Edit Links dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include <commdlg.h>
#include <dlgs.h>
#include <stdlib.h>
#include <strsafe.h>

OLEDBGDATA

// INTERNAL INFORMATION STARTS HERE
#define OLEUI_SZMAX 255
#define LINKTYPELEN 30  // was 9, now I've more than tripled it
#define szNULL    TEXT("\0")

typedef UINT (CALLBACK* COMMDLGHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

// Internally used structure

typedef struct tagLINKINFO
{
        DWORD   dwLink;             // app specific identifier of a link
        LPTSTR  lpszDisplayName;    // file based part of name
        LPTSTR  lpszItemName;       // object part of name
        LPTSTR  lpszShortFileName;  // filename without path
        LPTSTR  lpszShortLinkType;  // Short link type - progID
        LPTSTR  lpszFullLinkType;   // Full link type - user friendly name
        LPTSTR  lpszAMX;            // Is the link auto (A) man (M) or dead (X)
        ULONG   clenFileName;       // count of file part of mon.
        BOOL    fSourceAvailable;   // bound or not - on boot assume yes??
        BOOL    fIsAuto;            // 1 =automatic, 0=manual update
        BOOL    fIsMarked;          // 1 = marked, 0 = not
        BOOL    fDontFree;          // Don't free this data since it's being reused
        BOOL    fIsSelected;        // item selected or to be selected
} LINKINFO, FAR* LPLINKINFO;

typedef struct tagEDITLINKS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIEDITLINKS    lpOEL;  // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        BOOL        fClose;         // Does the button read cancel (0) or
                                                                // close (1)?
        BOOL        fItemsExist;    // TRUE, items in lbox, FALSE, none
        UINT        nChgSrcHelpID;  // ID for Help callback from ChangeSrc dlg
        TCHAR       szClose[50];    // Text for Close button
                                                                //   (when Cancel button gets renamed)
        int         nColPos[3];     // tab positions for list box
        int         nHeightLine;    // height of each line in owner draw listbox
        int         nMaxCharWidth;  // maximim width of text in owner draw listbox

} EDITLINKS, *PEDITLINKS, FAR *LPEDITLINKS;

// Internal function prototypes
// LINKS.CPP

INT_PTR CALLBACK EditLinksDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FEditLinksInit(HWND, WPARAM, LPARAM);
BOOL Container_ChangeSource(HWND, LPEDITLINKS);
HRESULT Container_AutomaticManual(HWND, BOOL, LPEDITLINKS);
HRESULT CancelLink(HWND, LPEDITLINKS);
HRESULT Container_UpdateNow(HWND, LPEDITLINKS);
HRESULT Container_OpenSource(HWND, LPEDITLINKS);
int AddLinkLBItem(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPLINKINFO lpLI,
        BOOL fGetSelected);
VOID BreakString(LPLINKINFO);
int GetSelectedItems(HWND, int FAR* FAR*);
VOID InitControls(HWND hDlg, LPEDITLINKS lpEL);
VOID UpdateLinkLBItem(HWND hListBox, int nIndex, LPEDITLINKS lpEL, BOOL bSelect);
VOID ChangeAllLinks(HWND hLIstBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPTSTR lpszFrom, LPTSTR lpszTo);
int LoadLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr);
VOID RefreshLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr);


/*
* OleUIEditLinks
*
* Purpose:
*  Invokes the standard OLE Edit Links dialog box allowing the user
*  to manipulate ole links (delete, update, change source, etc).
*
* Parameters:
*  lpEL            LPOLEUIEditLinks pointing to the in-out structure
*                  for this dialog.
*
* Return Value:
*  UINT            One of the following codes, indicating success or error:
*                      OLEUI_SUCCESS           Success
*                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
*/
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS lpEL)
{
        HGLOBAL  hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpEL, sizeof(OLEUIEDITLINKS),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        // Validate interface.
        if (NULL == lpEL->lpOleUILinkContainer)
        {
            uRet = OLEUI_ELERR_LINKCNTRNULL;
        }
        else if(IsBadReadPtr(lpEL->lpOleUILinkContainer, sizeof(IOleUILinkContainer)))
        {
            uRet = OLEUI_ELERR_LINKCNTRINVALID;
        }

        if (OLEUI_SUCCESS != uRet)
        {
            return(uRet);
        }

        UINT nIDD = bWin4 ? IDD_EDITLINKS4 : IDD_EDITLINKS;

        // Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(EditLinksDialogProc, (LPOLEUISTANDARD)lpEL,
                hMemDlg, MAKEINTRESOURCE(nIDD));
        return uRet;
}

/*
* EditLinksDialogProc
*
* Purpose:
*  Implements the OLE Edit Links dialog as invoked through the
*  OleUIEditLinks function.
*
* Parameters:
*  Standard
*
* Return Value:
*  Standard
*/
INT_PTR CALLBACK EditLinksDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPEDITLINKS lpEL = (LPEDITLINKS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (BOOL)uRet;

        //Process help message from secondary dialog
        if ((iMsg == uMsgHelp) && (lpEL) && (lpEL->lpOEL))
        {
                PostMessage(lpEL->lpOEL->hWndOwner, uMsgHelp, wParam, lParam);
                return FALSE;
        }

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpEL)
            {
                StandardCleanup(lpEL, hDlg);
            }
            break;
        case WM_INITDIALOG:
                return FEditLinksInit(hDlg, wParam, lParam);

        case WM_MEASUREITEM:
                {
                        LPMEASUREITEMSTRUCT lpMIS = (LPMEASUREITEMSTRUCT)lParam;
                        int nHeightLine;

                        if (lpEL && lpEL->nHeightLine != -1)
                        {
                                // use cached height
                                nHeightLine = lpEL->nHeightLine;
                        }
                        else
                        {
                                HFONT hFont;
                                HDC   hDC;
                                TEXTMETRIC  tm;

                                hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);

                                if (hFont == NULL)
                                        hFont = (HFONT)GetStockObject(SYSTEM_FONT);

                                hDC = GetDC(hDlg);
                                hFont = (HFONT)SelectObject(hDC, hFont);

                                GetTextMetrics(hDC, &tm);
                                nHeightLine = tm.tmHeight;

                                if (lpEL)
                                {
                                        lpEL->nHeightLine = nHeightLine;
                                        lpEL->nMaxCharWidth = tm.tmMaxCharWidth;
                                }
                                ReleaseDC(hDlg, hDC);
                        }
                        lpMIS->itemHeight = nHeightLine;
                }
                break;

        case WM_DRAWITEM:
                {
                        LPDRAWITEMSTRUCT lpDIS = (LPDRAWITEMSTRUCT)lParam;
                        LPLINKINFO lpLI = (LPLINKINFO)lpDIS->itemData;

                        if ((int)lpDIS->itemID < 0)
                                break;

                        if ((ODA_DRAWENTIRE | ODA_SELECT) & lpDIS->itemAction)
                        {
                                HBRUSH hbr;
                                COLORREF crText;
                                if (ODS_SELECTED & lpDIS->itemState)
                                {
                                        /*Get proper txt colors */
                                        crText = SetTextColor(lpDIS->hDC,
                                                        GetSysColor(COLOR_HIGHLIGHTTEXT));
                                        hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
                                        lpLI->fIsSelected = TRUE;
                                }
                                else
                                {
                                        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                                        lpLI->fIsSelected = FALSE;
                                }

                                FillRect(lpDIS->hDC, &lpDIS->rcItem, hbr);
                                DeleteObject(hbr);

                                int nOldBkMode = SetBkMode(lpDIS->hDC, TRANSPARENT);

                                RECT rcClip;
                                if (lpLI->lpszDisplayName)
                                {
                                        TCHAR szTemp[MAX_PATH];
                                        StringCchCopy(szTemp, sizeof(szTemp)/sizeof(szTemp[0]), lpLI->lpszDisplayName);
                                        LPTSTR lpsz = ChopText(
                                                        lpDIS->hwndItem,
                                                        lpEL->nColPos[1] - lpEL->nColPos[0]
                                                                - (lpEL->nMaxCharWidth > 0 ?
                                                                lpEL->nMaxCharWidth : 5),
                                                        szTemp, 0
                                        );
                                        rcClip.left = lpDIS->rcItem.left + lpEL->nColPos[0];
                                        rcClip.top = lpDIS->rcItem.top;
                                        rcClip.right = lpDIS->rcItem.left + lpEL->nColPos[1]
                                                                        - (lpEL->nMaxCharWidth > 0 ?
                                                                        lpEL->nMaxCharWidth : 5);
                                        rcClip.bottom = lpDIS->rcItem.bottom;
                                        ExtTextOut(
                                                        lpDIS->hDC,
                                                        rcClip.left,
                                                        rcClip.top,
                                                        ETO_CLIPPED,
                                                        (LPRECT)&rcClip,
                                                        lpsz,
                                                        lstrlen(lpsz),
                                                        NULL
                                        );
                                }
                                if (lpLI->lpszShortLinkType)
                                {
                                        rcClip.left = lpDIS->rcItem.left + lpEL->nColPos[1];
                                        rcClip.top = lpDIS->rcItem.top;
                                        rcClip.right = lpDIS->rcItem.left + lpEL->nColPos[2]
                                                                        - (lpEL->nMaxCharWidth > 0 ?
                                                                        lpEL->nMaxCharWidth : 5);
                                        rcClip.bottom = lpDIS->rcItem.bottom;
                                        ExtTextOut(
                                                        lpDIS->hDC,
                                                        rcClip.left,
                                                        rcClip.top,
                                                        ETO_CLIPPED,
                                                        (LPRECT)&rcClip,
                                                        lpLI->lpszShortLinkType,
                                                        lstrlen(lpLI->lpszShortLinkType),
                                                        NULL
                                        );
                                }
                                if (lpLI->lpszAMX)
                                {
                                        rcClip.left = lpDIS->rcItem.left + lpEL->nColPos[2];
                                        rcClip.top = lpDIS->rcItem.top;
                                        rcClip.right = lpDIS->rcItem.right;
                                        rcClip.bottom = lpDIS->rcItem.bottom;
                                        ExtTextOut(
                                                        lpDIS->hDC,
                                                        rcClip.left,
                                                        rcClip.top,
                                                        ETO_CLIPPED,
                                                        (LPRECT)&rcClip,
                                                        lpLI->lpszAMX,
                                                        lstrlen(lpLI->lpszAMX),
                                                        NULL
                                        );
                                }

                                SetBkMode(lpDIS->hDC, nOldBkMode);

                                // restore orig colors if we changed them
                                if (ODS_SELECTED & lpDIS->itemState)
                                        SetTextColor(lpDIS->hDC, crText);

                        }
                        if (ODA_FOCUS & lpDIS->itemAction)
                                DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);
                }
                return TRUE;

        case WM_DELETEITEM:
                {
                        LPDELETEITEMSTRUCT lpDIS = (LPDELETEITEMSTRUCT)lParam;
                        UINT idCtl = (UINT)wParam;
                        LPLINKINFO lpLI = (LPLINKINFO)lpDIS->itemData;

                        if (lpLI->lpszDisplayName)
                                OleStdFree((LPVOID)lpLI->lpszDisplayName);
                        if (lpLI->lpszShortLinkType)
                                OleStdFree((LPVOID)lpLI->lpszShortLinkType);
                        if (lpLI->lpszFullLinkType)
                                OleStdFree((LPVOID)lpLI->lpszFullLinkType);

                        /* The ChangeSource processing reuses allocated space for
                        **    links that have been modified.
                        */
                        // Don't free the LINKINFO for the changed links
                        if (lpLI->fDontFree)
                                lpLI->fDontFree = FALSE;
                        else
                        {
                                if (lpLI->lpszAMX)
                                        OleStdFree((LPVOID)lpLI->lpszAMX);
                                OleStdFree((LPVOID)lpLI);
                        }
                }
                return TRUE;

        case WM_COMPAREITEM:
                {
                        LPCOMPAREITEMSTRUCT lpCIS = (LPCOMPAREITEMSTRUCT)lParam;
                        LPLINKINFO lpLI1 = (LPLINKINFO)lpCIS->itemData1;
                        LPLINKINFO lpLI2 = (LPLINKINFO)lpCIS->itemData2;

                        // Sort list entries by DisplayName
                        return lstrcmp(lpLI1->lpszDisplayName, lpLI2->lpszDisplayName);
                }

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_EL_CHANGESOURCE:
                        {
                                BOOL fRet = Container_ChangeSource(hDlg, lpEL);
                                if (!fRet)
                                        PopupMessage(hDlg, IDS_LINKS, IDS_FAILED,
                                                         MB_ICONEXCLAMATION | MB_OK);
                                InitControls(hDlg, lpEL);
                        }
                        break;

                case IDC_EL_AUTOMATIC:
                        {
                                CheckDlgButton(hDlg, IDC_EL_AUTOMATIC, 1);
                                CheckDlgButton(hDlg, IDC_EL_MANUAL, 0);

                                HRESULT hErr = Container_AutomaticManual(hDlg, TRUE, lpEL);
                                if (hErr != NOERROR)
                                        PopupMessage(hDlg, IDS_LINKS, IDS_FAILED,
                                                        MB_ICONEXCLAMATION | MB_OK);

                                InitControls(hDlg, lpEL);
                        }
                        break;

                case IDC_EL_MANUAL:
                        {
                                CheckDlgButton(hDlg, IDC_EL_MANUAL, 1);
                                CheckDlgButton(hDlg, IDC_EL_AUTOMATIC, 0);

                                HRESULT hErr = Container_AutomaticManual(hDlg, FALSE, lpEL);
                                if (hErr != NOERROR)
                                        PopupMessage(hDlg, IDS_LINKS, IDS_FAILED,
                                                        MB_ICONEXCLAMATION | MB_OK);

                                InitControls(hDlg, lpEL);
                        }
                        break;

                case IDC_EL_CANCELLINK:
                        CancelLink(hDlg,lpEL);
                        InitControls(hDlg, lpEL);
                        break;

                case IDC_EL_UPDATENOW:
                        Container_UpdateNow(hDlg, lpEL);
                        InitControls(hDlg, lpEL);
                        break;

                case IDC_EL_OPENSOURCE:
                        {
                            HRESULT hErr = Container_OpenSource(hDlg, lpEL);
                            if (hErr != NOERROR)
                            {
                                InitControls(hDlg, lpEL);
                                // Don't close dialog
                                break;
                            }
                            SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                        } // fall through

                case IDC_EL_LINKSLISTBOX:
                        if (wCode == LBN_SELCHANGE)
                                InitControls(hDlg, lpEL);
                        break;

                case IDCANCEL:
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;

                case IDC_OLEUIHELP:
                        PostMessage(lpEL->lpOEL->hWndOwner, uMsgHelp,
                                (WPARAM)hDlg, MAKELPARAM(IDD_EDITLINKS, 0));
                        break;
                }
                break;

        default:
                if (lpEL != NULL && iMsg == lpEL->nChgSrcHelpID)
                {
                        PostMessage(lpEL->lpOEL->hWndOwner, uMsgHelp,
                                (WPARAM)hDlg, MAKELPARAM(IDD_CHANGESOURCE, 0));
                }
                if (iMsg == uMsgBrowseOFN &&
                        lpEL != NULL && lpEL->lpOEL && lpEL->lpOEL->hWndOwner)
                {
                        SendMessage(lpEL->lpOEL->hWndOwner, uMsgBrowseOFN, wParam, lParam);
                }
                break;
        }

        return FALSE;
}

/*
 * FEditLinksInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Edit Links dialog box.
 *
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FEditLinksInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPEDITLINKS lpEL = (LPEDITLINKS)LpvStandardInit(hDlg, sizeof(EDITLINKS), &hFont);

        // PvStandardInit send a termination to us already.
        if (NULL == lpEL)
                return FALSE;

        LPOLEUIEDITLINKS lpOEL = (LPOLEUIEDITLINKS)lParam;
        lpEL->lpOEL = lpOEL;
        lpEL->nIDD = IDD_EDITLINKS;

        // metrics unknown so far
        lpEL->nHeightLine = -1;
        lpEL->nMaxCharWidth = -1;

        /* calculate the column positions relative to the listbox */
        HWND hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        RECT rc;
        GetWindowRect(hListBox, (LPRECT)&rc);
        int nStart = rc.left;
        GetWindowRect(GetDlgItem(hDlg, IDC_EL_COL1), (LPRECT)&rc);
        lpEL->nColPos[0] = rc.left - nStart;
        GetWindowRect(GetDlgItem(hDlg, IDC_EL_COL2), (LPRECT)&rc);
        lpEL->nColPos[1] = rc.left - nStart;
        GetWindowRect(GetDlgItem(hDlg, IDC_EL_COL3), (LPRECT)&rc);
        lpEL->nColPos[2] = rc.left - nStart;

        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;

        ULONG cLinks = LoadLinkLB(hListBox, lpOleUILinkCntr);
        if ((int)cLinks < 0)
                return FALSE;

        BOOL fDlgItem = (BOOL)cLinks;
        lpEL->fItemsExist = (BOOL)cLinks;

        InitControls(hDlg, lpEL);

        // Copy other information from lpOEL that we might modify.

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                // Do this for as many controls as you need it for.
                // SendDlgItemMessage(hDlg, ID_<UFILL>, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Show or hide the help button
        if (!(lpEL->lpOEL->dwFlags & ELF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        /*
         * PERFORM OTHER INITIALIZATION HERE.  ON ANY LoadString
         * FAILURE POST OLEUI_MSG_ENDDIALOG WITH OLEUI_ERR_LOADSTRING.
         */

        // If requested disable UpdateNow button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLEUPDATENOW))
                StandardShowDlgItem(hDlg, IDC_EL_UPDATENOW, SW_HIDE);

        // If requested disable OpenSource button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLEOPENSOURCE))
                StandardShowDlgItem(hDlg, IDC_EL_OPENSOURCE, SW_HIDE);

        // If requested disable UpdateNow button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLECHANGESOURCE))
                StandardShowDlgItem(hDlg, IDC_EL_CHANGESOURCE, SW_HIDE);

        // If requested disable CancelLink button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLECANCELLINK))
                StandardShowDlgItem(hDlg, IDC_EL_CANCELLINK, SW_HIDE);

        // Change the caption
        if (NULL!=lpOEL->lpszCaption)
                SetWindowText(hDlg, lpOEL->lpszCaption);

        // Load 'Close' string used to rename Cancel button
        int n = LoadString(_g_hOleStdResInst, IDS_CLOSE, lpEL->szClose, sizeof(lpEL->szClose)/sizeof(TCHAR));
        if (!n)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                return FALSE;
        }

        if (cLinks > 0)
                SetFocus(hListBox);
        else
                SetFocus(GetDlgItem(hDlg, IDCANCEL));

        lpEL->nChgSrcHelpID = RegisterWindowMessage(HELPMSGSTRING);

        // Call the hook with lCustData in lParam
        UStandardHook(lpEL, hDlg, WM_INITDIALOG, wParam, lpOEL->lCustData);

        return FALSE;
}

/*
* Container_ChangeSource
*
* Purpose:
*  Tunnel to File Open type dlg and allow user to select new file
*  for file based monikers, OR to change the whole moniker to what
*  the user types into the editable field.
*
* Parameters:
*  hDlg            HWND of the dialog
*  LPEDITLINKS     Pointer to EditLinks structure (contains all nec.
*              info)
*
* Return Value:
*  BOOL          for now, because we are not using any ole functions
*                to return an HRESULT.
*  HRESULT       HRESULT value indicating success or failure of
*              changing the moniker value
*/

BOOL Container_ChangeSource(HWND hDlg, LPEDITLINKS lpEL)
{
        HWND hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        int FAR* rgIndex;
        int cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return FALSE;

        if (!cSelItems)
                return TRUE;

        OLEUICHANGESOURCE cs; memset(&cs, 0, sizeof(cs));
        cs.cbStruct = sizeof(cs);
        cs.hWndOwner = hDlg;
        if (lpEL->lpOEL->dwFlags & ELF_SHOWHELP)
                cs.dwFlags |= CSF_SHOWHELP;

        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        cs.lpOleUILinkContainer = lpOleUILinkCntr;

        for (int i = cSelItems-1; i >= 0; i--)
        {
                // allow caller to customize the change source dialog
                LPLINKINFO lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);
                cs.lpszDisplayName = lpLI->lpszDisplayName;
                cs.dwLink = lpLI->dwLink;
                cs.nFileLength = lpLI->clenFileName;

                UINT uRet = UStandardHook(lpEL, hDlg, uMsgChangeSource, 0, (LPARAM)&cs);
                if (!uRet)
                        uRet = (OLEUI_OK == OleUIChangeSource(&cs));
                if (!uRet)
                        break;  // dialog canceled (cancel for all)

                if (!lpEL->fClose)
                {
                        SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                        lpEL->fClose = TRUE;
                }

                // update the list box item for the new name
                //      (note: original lpszDisplayName already freed)
                lpLI->fSourceAvailable = (cs.dwFlags & CSF_VALIDSOURCE);
                lpLI->lpszDisplayName = cs.lpszDisplayName;
                UpdateLinkLBItem(hListBox, rgIndex[i], lpEL, TRUE);

                // if differed only in file name, allow user to change all links
                if (cs.lpszFrom != NULL && cs.lpszTo != NULL)
                        ChangeAllLinks(hListBox, lpOleUILinkCntr, cs.lpszFrom, cs.lpszTo);

                // must free and NULL out the lpszFrom and lpszTo OUT fields
                OleStdFree(cs.lpszFrom);
                cs.lpszFrom = NULL;
                OleStdFree(cs.lpszTo);
                cs.lpszTo = NULL;
        }

        if (rgIndex != NULL)
                OleStdFree(rgIndex);

        return TRUE;
}

/*
* Container_AutomaticManual
*
* Purpose:
*   To change the selected moniker to manual or automatic update.
*
* Parameters:
*  hDlg            HWND of the dialog
*  FAutoMan        Flag indicating AUTO (TRUE/1) or MANUAL(FALSE/0)
*  LPEDITLINKS     Pointer to EditLinks structure (contains all nec.
*              info)
*            * this may change - don't know how the linked list
*            * of multi-selected items will work.
* Return Value:
*  HRESULT       HRESULT value indicating success or failure of
*              changing the moniker value
*/

HRESULT Container_AutomaticManual(HWND hDlg, BOOL fAutoMan, LPEDITLINKS lpEL)
{
        HRESULT hErr = NOERROR;
        int cSelItems;
        int FAR* rgIndex;
        int i = 0;
        LPLINKINFO  lpLI;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        BOOL        bUpdate = FALSE;

        OleDbgAssert(lpOleUILinkCntr);

        /* Change so looks at flag in structure.  Only update those that
        need to be updated.  Make sure to change flag if status changes.
        */

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (!cSelItems)
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        if (!lpEL->fClose)
        {
                SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                lpEL->fClose = TRUE;
        }

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);
                if (fAutoMan)
                {
                        // If switching to AUTOMATIC
                        if (!lpLI->fIsAuto)   // Only change MANUAL links
                        {
                                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::SetLinkUpdateOptions called\r\n"));
                                hErr=lpOleUILinkCntr->SetLinkUpdateOptions(
                                                lpLI->dwLink,
                                                OLEUPDATE_ALWAYS
                                );
                                OLEDBG_END2

                                lpLI->fIsAuto=TRUE;
                                lpLI->fIsMarked = TRUE;
                                bUpdate = TRUE;
                        }
                }
                else   // If switching to MANUAL
                {
                        if (lpLI->fIsAuto)  // Only do AUTOMATIC Links
                        {
                                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::SetLinkUpdateOptions called\r\n"));
                                hErr=lpOleUILinkCntr->SetLinkUpdateOptions(
                                                lpLI->dwLink,
                                                OLEUPDATE_ONCALL
                                );
                                OLEDBG_END2

                                lpLI->fIsAuto = FALSE;
                                lpLI->fIsMarked = TRUE;
                                bUpdate = TRUE;
                        }
                }

                if (hErr != NOERROR)
                {
                        OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::SetLinkUpdateOptions returned"),hErr);
                        break;
                }
        }

        if (bUpdate)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;
}

HRESULT CancelLink(HWND hDlg, LPEDITLINKS lpEL)
{
        HRESULT hErr;
        LPMONIKER lpmk;
        int cSelItems;
        int FAR* rgIndex;
        int i = 0;
        LPLINKINFO  lpLI;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        BOOL        bUpdate = FALSE;

        OleDbgAssert(lpOleUILinkCntr);

        lpmk = NULL;

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (!cSelItems)
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);

                UINT uRet = PopupMessage(hDlg, IDS_LINKS,
                        IDS_CONFIRMBREAKLINK, MB_YESNO|MB_ICONQUESTION);
                if (uRet == IDNO)
                        break;

                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::CancelLink called\r\n"));
                hErr = lpOleUILinkCntr->CancelLink(lpLI->dwLink);
                OLEDBG_END2

                if (!lpEL->fClose)
                {
                        SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                        lpEL->fClose = TRUE;
                }

                if (hErr != NOERROR)
                {
                        OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::CancelLink returned"),hErr);
                        lpLI->fIsMarked = TRUE;
                        bUpdate = TRUE;
                }
                else
                {
                        // Delete links that we make null from listbox
                        SendMessage(hListBox, LB_DELETESTRING, (WPARAM) rgIndex[i], 0L);
                        int i2;
                        for (i2 = i + 1; i2 < cSelItems; i2++)
                        {
                            if (rgIndex[i2] > rgIndex[i])
                                rgIndex[i2]--;
                        }
                }
        }

        if (bUpdate)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;
}

/*
 * Container_UpdateNow
 *
 * Purpose:
 *   Immediately force an update for all (manual) links
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  LPEDITLINKS     Pointer to EditLinks structure (contains all nec. info)
 *            * this may change - don't know how the linked list
 *            * of multi-selected items will work.
 * Return Value:
 *  HRESULT       HRESULT value indicating success or failure of
 *              changing the moniker value
 */
HRESULT Container_UpdateNow(HWND hDlg, LPEDITLINKS lpEL)
{
        HRESULT         hErr;
        LPLINKINFO      lpLI;
        int cSelItems;
        int FAR* rgIndex;
        int i = 0;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        BOOL        bUpdate = FALSE;

        OleDbgAssert(lpOleUILinkCntr);

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (!cSelItems)
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        if (!lpEL->fClose)
        {
                SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                lpEL->fClose = TRUE;
        }

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);

                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::UpdateLink called\r\n"));
                hErr = lpOleUILinkCntr->UpdateLink(
                                lpLI->dwLink,
                                TRUE,
                                FALSE
                );
                OLEDBG_END2
                bUpdate = TRUE;
                lpLI->fIsMarked = TRUE;

                if (hErr != NOERROR)
                {
                        OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::UpdateLink returned"),hErr);
                        break;
                }
        }

        if (bUpdate)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;

}

/*
 * Container_OpenSource
 *
 * Purpose:
 *   Immediately force an update for all (manual) links
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  LPEDITLINKS     Pointer to EditLinks structure (contains all nec.
 *              info)
 *
 * Return Value:
 *  HRESULT       HRESULT value indicating success or failure of
 *              changing the moniker value
 */

HRESULT Container_OpenSource(HWND hDlg, LPEDITLINKS lpEL)
{
        HRESULT         hErr;
        int             cSelItems;
        int FAR*        rgIndex;
        LPLINKINFO      lpLI;
        RECT            rcPosRect;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND            hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);

        OleDbgAssert(lpOleUILinkCntr);

        rcPosRect.top = 0;
        rcPosRect.left = 0;
        rcPosRect.right = 0;
        rcPosRect.bottom = 0;

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (cSelItems != 1)     // can't open source for multiple items
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        if (!lpEL->fClose)
        {
                SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                lpEL->fClose = TRUE;
        }

        lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[0], 0);

        OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::OpenLinkSource called\r\n"));
        hErr = lpOleUILinkCntr->OpenLinkSource(
                        lpLI->dwLink
        );
        OLEDBG_END2

        UpdateLinkLBItem(hListBox, rgIndex[0], lpEL, TRUE);
        if (hErr != NOERROR) {
                OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::OpenLinkSource returned"),hErr);
        }

        if (rgIndex) 
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;
}

/* AddLinkLBItem
** -------------
**
**    Add the item pointed to by lpLI to the Link ListBox and return
**    the index of it in the ListBox
*/
int AddLinkLBItem(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPLINKINFO lpLI, BOOL fGetSelected)
{
        HRESULT hErr;
        DWORD dwUpdateOpt;
        int nIndex;

        OleDbgAssert(lpOleUILinkCntr && hListBox && lpLI);

        lpLI->fDontFree = FALSE;

        OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::GetLinkSource called\r\n"));
        hErr = lpOleUILinkCntr->GetLinkSource(
                        lpLI->dwLink,
                        (LPTSTR FAR*)&lpLI->lpszDisplayName,
                        (ULONG FAR*)&lpLI->clenFileName,
                        (LPTSTR FAR*)&lpLI->lpszFullLinkType,
                        (LPTSTR FAR*)&lpLI->lpszShortLinkType,
                        (BOOL FAR*)&lpLI->fSourceAvailable,
                        fGetSelected ? (BOOL FAR*)&lpLI->fIsSelected : NULL
        );
        OLEDBG_END2

        if (hErr != NOERROR)
        {
                OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::GetLinkSource returned"),hErr);
                PopupMessage(hListBox, IDS_LINKS, IDS_ERR_GETLINKSOURCE,
                                MB_ICONEXCLAMATION | MB_OK);
                goto cleanup;
        }

        OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::GetLinkUpdateOptions called\r\n"));
        hErr=lpOleUILinkCntr->GetLinkUpdateOptions(
                        lpLI->dwLink,
                        (LPDWORD)&dwUpdateOpt
        );
        OLEDBG_END2

        if (hErr != NOERROR)
        {
                OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::GetLinkUpdateOptions returned"),hErr);
                PopupMessage(hListBox, IDS_LINKS, IDS_ERR_GETLINKUPDATEOPTIONS,
                                MB_ICONEXCLAMATION | MB_OK);

                goto cleanup;
        }

        if (lpLI->fSourceAvailable)
        {
                if (dwUpdateOpt == OLEUPDATE_ALWAYS)
                {
                        lpLI->fIsAuto = TRUE;
                        LoadString(_g_hOleStdResInst, IDS_LINK_AUTO, lpLI->lpszAMX,
                                        (int)OleStdGetSize((LPVOID)lpLI->lpszAMX) / sizeof (TCHAR));
                }
                else
                {
                        lpLI->fIsAuto = FALSE;
                        LoadString(_g_hOleStdResInst, IDS_LINK_MANUAL, lpLI->lpszAMX,
                                        (int)OleStdGetSize((LPVOID)lpLI->lpszAMX) / sizeof (TCHAR));
                }
        }
        else
                LoadString(_g_hOleStdResInst, IDS_LINK_UNKNOWN, lpLI->lpszAMX,
                                (int)OleStdGetSize((LPVOID)lpLI->lpszAMX) / sizeof (TCHAR));

        BreakString(lpLI);

        nIndex = (int)SendMessage(hListBox, LB_ADDSTRING, (WPARAM)0,
                        (LPARAM)lpLI);

        if (nIndex == LB_ERR)
        {
                PopupMessage(hListBox, IDS_LINKS, IDS_ERR_ADDSTRING,
                                MB_ICONEXCLAMATION | MB_OK);
                goto cleanup;
        }
        return nIndex;

cleanup:
        if (lpLI->lpszDisplayName)
                OleStdFree((LPVOID)lpLI->lpszDisplayName);

        if (lpLI->lpszShortLinkType)
                OleStdFree((LPVOID)lpLI->lpszShortLinkType);

        if (lpLI->lpszFullLinkType)
                OleStdFree((LPVOID)lpLI->lpszFullLinkType);

        return -1;
}

/* BreakString
 * -----------
 *
 *  Purpose:
 *      Break the lpszDisplayName into various parts
 *
 *  Parameters:
 *      lpLI            pointer to LINKINFO structure
 *
 *  Returns:
 *
 */
VOID BreakString(LPLINKINFO lpLI)
{
        LPTSTR lpsz;

        if (!lpLI->clenFileName ||
                (lstrlen(lpLI->lpszDisplayName)==(int)lpLI->clenFileName))
        {
                lpLI->lpszItemName = NULL;
        }
        else
        {
                lpLI->lpszItemName = lpLI->lpszDisplayName + lpLI->clenFileName;
        }

        // search from last character of filename
        lpsz = lpLI->lpszDisplayName + lstrlen(lpLI->lpszDisplayName);
        while (lpsz > lpLI->lpszDisplayName)
        {
                lpsz = CharPrev(lpLI->lpszDisplayName, lpsz);
                if ((*lpsz == '\\') || (*lpsz == '/') || (*lpsz == ':'))
                        break;
        }

        if (lpsz == lpLI->lpszDisplayName)
                lpLI->lpszShortFileName = lpsz;
        else
                lpLI->lpszShortFileName = CharNext(lpsz);
}

/* GetSelectedItems
 * ----------------
 *
 *  Purpose:
 *      Retrieve the indices of the selected items in the listbox
 *      Note that *lprgIndex needed to be free after using the function
 *
 *  Parameters:
 *      hListBox        window handle of listbox
 *      lprgIndex       pointer to an integer array to receive the indices
 *                      must be freed afterwards
 *
 *  Returns:
 *      number of indices retrieved, -1 if error
 */
int GetSelectedItems(HWND hListBox, int FAR* FAR* lprgIndex)
{
        DWORD cSelItems;
        DWORD cCheckItems;

        *lprgIndex = NULL;

        cSelItems = (DWORD)SendMessage(hListBox, LB_GETSELCOUNT, 0, 0L);
        if ((int)cSelItems < 0)      // error
                return (int)cSelItems;

        if (!cSelItems)
                return 0;

        *lprgIndex = (int FAR*)OleStdMalloc((int)cSelItems * sizeof(int));
        if (!(*lprgIndex))
                return -1; // outofmem

        cCheckItems = (DWORD)SendMessage(hListBox, LB_GETSELITEMS,
                        (WPARAM) cSelItems, (LPARAM) (int FAR *) *lprgIndex);

        if (cCheckItems == cSelItems)
                return (int)cSelItems;
        else
        {
                if (*lprgIndex)
                        OleStdFree((LPVOID)*lprgIndex);
                *lprgIndex = NULL;
                return 0;
        }
}

/* InitControls
 * ------------
 *
 *  Purpose:
 *      Initialize the state of the Auto/Manual button, Link source/type
 *      static field, etc in the dialogs according to the selection in the
 *      listbox
 *
 *  Parameters:
 *      hDlg        handle to the dialog window
 */
VOID InitControls(HWND hDlg, LPEDITLINKS lpEL)
{
        int         cSelItems;
        HWND        hListBox;
        int         i;
        int FAR*    rgIndex;
        LPLINKINFO  lpLI;
        LPTSTR      lpszType = NULL;
        LPTSTR      lpszSource = NULL;
        int         cAuto = 0;
        int         cManual = 0;
        BOOL        bSameType = TRUE;
        BOOL        bSameSource = TRUE;
        TCHAR       tsz[MAX_PATH];
        LPTSTR      lpsz;

        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);

        cSelItems = GetSelectedItems(hListBox, &rgIndex);
        if (cSelItems < 0) 
			return;

		if ((cSelItems > 0) && (rgIndex == NULL))
			return;

        StandardEnableDlgItem(hDlg, IDC_EL_AUTOMATIC, (BOOL)cSelItems);
        StandardEnableDlgItem(hDlg, IDC_EL_MANUAL, (BOOL)cSelItems);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLECANCELLINK))
                StandardEnableDlgItem(hDlg, IDC_EL_CANCELLINK, (BOOL)cSelItems);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLEOPENSOURCE))
                StandardEnableDlgItem(hDlg, IDC_EL_OPENSOURCE, cSelItems == 1);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLECHANGESOURCE))
                StandardEnableDlgItem(hDlg, IDC_EL_CHANGESOURCE, cSelItems == 1);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLEUPDATENOW))
                StandardEnableDlgItem(hDlg, IDC_EL_UPDATENOW, (BOOL)cSelItems);

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendDlgItemMessage(hDlg, IDC_EL_LINKSLISTBOX,
                        LB_GETITEMDATA, rgIndex[i], 0);

                if (lpszSource && lpLI->lpszDisplayName)
                {
                        if (bSameSource && lstrcmp(lpszSource, lpLI->lpszDisplayName))
                                bSameSource = FALSE;
                }
                else
                        lpszSource = lpLI->lpszDisplayName;

                if (lpszType && lpLI->lpszFullLinkType)
                {
                        if (bSameType && lstrcmp(lpszType, lpLI->lpszFullLinkType))
                                bSameType = FALSE;
                }
                else
                        lpszType = lpLI->lpszFullLinkType;

                if (lpLI->fIsAuto)
                        cAuto++;
                else
                        cManual++;
        }

        CheckDlgButton(hDlg, IDC_EL_AUTOMATIC, cAuto && !cManual);
        CheckDlgButton(hDlg, IDC_EL_MANUAL, !cAuto && cManual);

        /* fill full source in static text box
        **    below list
        */
        if (!bSameSource || !lpszSource)
                lpszSource = szNULL;
        StringCchCopy(tsz, sizeof(tsz)/sizeof(tsz[0]), lpszSource);
        lpsz = ChopText(GetDlgItem(hDlg, IDC_EL_LINKSOURCE), 0, tsz, 0);
        SetDlgItemText(hDlg, IDC_EL_LINKSOURCE, lpsz);

        /* fill full link type name in static
        **    "type" text box
        */
        if (!bSameType || !lpszType)
                lpszType = szNULL;
        SetDlgItemText(hDlg, IDC_EL_LINKTYPE, lpszType);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);
}


/* UpdateLinkLBItem
 * -----------------
 *
 *  Purpose:
 *      Update the linkinfo struct in the listbox to reflect the changes
 *      made by the last operation. It is done simply by removing the item
 *      from the listbox and add it back.
 *
 *  Parameters:
 *      hListBox        handle of listbox
 *      nIndex          index of listbox item
 *      lpEL            pointer to editlinks structure
 *      bSelect         select the item or not after update
 */
VOID UpdateLinkLBItem(HWND hListBox, int nIndex, LPEDITLINKS lpEL, BOOL bSelect)
{
        LPLINKINFO lpLI;
        LPOLEUILINKCONTAINER    lpOleUILinkCntr;

        if (!hListBox || (nIndex < 0) || !lpEL)
                return;

        lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;

        lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, nIndex, 0);

        if (lpLI == NULL)
                return;

        /* Don't free the data associated with this listbox item
        **    because we are going to reuse the allocated space for
        **    the modified link. WM_DELETEITEM processing in the
        **    dialog checks this flag before deleting data
        **    associcated with list item.
        */
        lpLI->fDontFree = TRUE;
        SendMessage(hListBox, LB_DELETESTRING, nIndex, 0L);

        nIndex = AddLinkLBItem(hListBox, lpOleUILinkCntr, lpLI, FALSE);
        if (bSelect)
        {
                SendMessage(hListBox, LB_SETSEL, TRUE, MAKELPARAM(nIndex, 0));
                SendMessage(hListBox, LB_SETCARETINDEX, nIndex, MAKELPARAM(TRUE, 0));
        }
}



/* ChangeAllLinks
 * --------------
 *
 *  Purpose:
 *      Enumerate all the links in the listbox and change those starting
 *      with lpszFrom to lpszTo.
 *
 *  Parameters:
 *      hListBox        window handle of
 *      lpOleUILinkCntr pointer to OleUI Link Container
 *      lpszFrom        prefix for matching
 *      lpszTo          prefix to substitution
 *
 *  Returns:
 */
VOID ChangeAllLinks(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPTSTR lpszFrom, LPTSTR lpszTo)
{
        int     cItems;
        int     nIndex;
        int     cFrom;
        LPLINKINFO  lpLI;
        TCHAR   szTmp[MAX_PATH];
        BOOL    bFound;

        cFrom = lstrlen(lpszFrom);

        cItems = (int)SendMessage(hListBox, LB_GETCOUNT, 0, 0L);
        OleDbgAssert(cItems >= 0);

        bFound = FALSE;

#ifdef _DEBUG
        OleDbgPrint(3, TEXT("From : "), lpszFrom, 0);
        OleDbgPrint(3, TEXT(""), TEXT("\r\n"), 0);
        OleDbgPrint(3, TEXT("To   : "), lpszTo, 0);
        OleDbgPrint(3, TEXT(""), TEXT("\r\n"), 0);
#endif

        for (nIndex = 0; nIndex < cItems; nIndex++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, nIndex, 0);

                // unmark the item
                lpLI->fIsMarked = FALSE;

                /* if the corresponding position for the end of lpszFrom in the
                **    display name is not a separator. We stop comparing this
                **    link.
                */
                if (!*(lpLI->lpszDisplayName + cFrom) ||
                        (*(lpLI->lpszDisplayName + cFrom) == '\\') ||
                        (*(lpLI->lpszDisplayName + cFrom) == '!'))
                {
                        lstrcpyn(szTmp, lpLI->lpszDisplayName, cFrom + 1);
                        if (!lstrcmp(szTmp, lpszFrom))
                        {
                                HRESULT hErr;
                                int nFileLength;
                                ULONG ulDummy;

                                if (!bFound)
                                {
                                        TCHAR szTitle[256];
                                        TCHAR szMsg[256];
                                        TCHAR szBuf[256];
                                        int uRet;

                                        LoadString(_g_hOleStdResInst, IDS_CHANGESOURCE, szTitle,
                                                        sizeof(szTitle)/sizeof(TCHAR));
                                        LoadString(_g_hOleStdResInst, IDS_CHANGEADDITIONALLINKS,
                                                        szMsg, sizeof(szMsg)/sizeof(TCHAR));
                                        StringCchPrintf(szBuf, sizeof(szBuf)/sizeof(szBuf[0]), szMsg, lpszFrom);
                                        uRet = MessageBox(hListBox, szBuf, szTitle,
                                                        MB_ICONQUESTION | MB_YESNO);
                                        if (uRet == IDYES)
                                                bFound = TRUE;
                                        else
                                                return;
                                }

                                StringCchCopy(szTmp, sizeof(szTmp)/sizeof(szTmp[0]), lpszTo);
                                StringCchCat(szTmp, sizeof(szTmp)/sizeof(szTmp[0]), lpLI->lpszDisplayName + cFrom);
                                nFileLength = lstrlen(szTmp) -
                                        (lpLI->lpszItemName ? lstrlen(lpLI->lpszItemName) : 0);

                                hErr = lpOleUILinkCntr->SetLinkSource(
                                                lpLI->dwLink,
                                                szTmp,
                                                (ULONG)nFileLength,
                                                (ULONG FAR*)&ulDummy,
                                                TRUE
                                );
                                if (hErr != NOERROR)
                                {
                                        lpOleUILinkCntr->SetLinkSource(
                                                        lpLI->dwLink,
                                                        szTmp,
                                                        (ULONG)nFileLength,
                                                        (ULONG FAR*)&ulDummy,
                                                        FALSE);
                                }
                                lpLI->fIsMarked = TRUE;
                        }
                }
        }

        /* have to do the refreshing after processing all links, otherwise
        **    the item positions will change during the process as the
        **    listbox stores items in order
        */
        if (bFound)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);
}



/* LoadLinkLB
 * ----------
 *
 *  Purpose:
 *      Enumerate all links from the Link Container and build up the Link
 *      ListBox
 *
 *  Parameters:
 *      hListBox        window handle of
 *      lpOleUILinkCntr pointer to OleUI Link Container
 *      lpszFrom        prefix for matching
 *      lpszTo          prefix to substitution
 *
 *  Returns:
 *      number of link items loaded, -1 if error
 */
int LoadLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr)
{
        DWORD       dwLink = 0;
        LPLINKINFO  lpLI;
        int         nIndex;
        int         cLinks;

        cLinks = 0;

        while ((dwLink = lpOleUILinkCntr->GetNextLink(dwLink)) != 0)
        {
                lpLI = (LPLINKINFO)OleStdMalloc(sizeof(LINKINFO));
                if (NULL == lpLI)
                        return -1;

                lpLI->fIsMarked = FALSE;
                lpLI->fIsSelected = FALSE;
                lpLI->fDontFree = FALSE;

                lpLI->lpszAMX = (LPTSTR)OleStdMalloc((LINKTYPELEN+1)*sizeof(TCHAR));

                lpLI->dwLink = dwLink;
                cLinks++;
                if ((nIndex = AddLinkLBItem(hListBox,lpOleUILinkCntr,lpLI,TRUE)) < 0)
                        // can't load list box
                        return -1;

                if (lpLI->fIsSelected)
                        SendMessage(hListBox, LB_SETSEL, TRUE, MAKELPARAM(nIndex, 0));
        }
        if (SendMessage(hListBox,LB_GETSELITEMS,(WPARAM)1,(LPARAM)(int FAR*)&nIndex))
                SendMessage(hListBox, LB_SETCARETINDEX, (WPARAM)nIndex, MAKELPARAM(TRUE, 0));

        return cLinks;
}

/* RefreshLinkLB
 * -------------
 *
 *  Purpose:
 *      Enumerate all items in the links listbox and update those with
 *      fIsMarked set.
 *      Note that this is a time consuming routine as it keeps iterating
 *      all items in the listbox until all of them are unmarked.
 *
 *  Parameters:
 *      hListBox        window handle of listbox
 *      lpOleUILinkCntr pointer to OleUI Link Container
 *
 *  Returns:
 *
 */
VOID RefreshLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr)
{
        int cItems;
        int nIndex;
        LPLINKINFO  lpLI;
        BOOL        bStop;

        OleDbgAssert(hListBox);

        cItems = (int)SendMessage(hListBox, LB_GETCOUNT, 0, 0L);
        OleDbgAssert(cItems >= 0);

        do
        {
                bStop = TRUE;
                for (nIndex = 0; nIndex < cItems; nIndex++)
                {
                        lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, nIndex, 0);
                        if (lpLI->fIsMarked)
                        {
                                lpLI->fIsMarked = FALSE;
                                lpLI->fDontFree = TRUE;

                                SendMessage(hListBox, LB_DELETESTRING, nIndex, 0L);
                                nIndex=AddLinkLBItem(hListBox, lpOleUILinkCntr, lpLI, FALSE);
                                if (lpLI->fIsSelected)
                                {
                                        SendMessage(hListBox, LB_SETSEL, (WPARAM)TRUE,
                                                        MAKELPARAM(nIndex, 0));
                                        SendMessage(hListBox, LB_SETCARETINDEX, (WPARAM)nIndex,
                                                        MAKELPARAM(TRUE, 0));
                                }
                                bStop = FALSE;
                                break;
                        }
                }
        } while (!bStop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\ole2ui.cpp ===
/*
 * OLE2UI.CPP
 *
 * Contains initialization routines and miscellaneous API implementations for
 * the OLE 2.0 User Interface Support Library.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"
#include <commdlg.h>
#include <stdarg.h>
#include "strcache.h"

OLEDBGDATA

// Registered messages for use with all the dialogs, registered in LibMain
UINT uMsgHelp;
UINT uMsgEndDialog;
UINT uMsgBrowse;
UINT uMsgChangeIcon;
UINT uMsgFileOKString;
UINT uMsgCloseBusyDlg;
UINT uMsgConvert;
UINT uMsgChangeSource;
UINT uMsgAddControl;
UINT uMsgBrowseOFN;

// local function prototypes
INT_PTR CALLBACK PromptUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UpdateLinksDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

// local definition
#define WM_U_UPDATELINK (WM_USER+0x2000)
#define WM_U_SHOWWINDOW (WM_USER+0x2001)

// local structure definition
typedef struct tagUPDATELINKS
{
        LPOLEUILINKCONTAINER    lpOleUILinkCntr;    // pointer to Link Container
        UINT                    cLinks;             // total number of links
        UINT                    cUpdated;           // number of links updated
        DWORD                   dwLink;             // pointer to link
        BOOL                    fError;             // error flag
        LPTSTR                  lpszTitle;          // caption for dialog box
} UPDATELINKS, *PUPDATELINKS, FAR *LPUPDATELINKS;


/*
 * OleUIInitialize
 *
 * NOTE: This function should only be called by your application IF it is
 * using the static-link version of this library.  If the DLL version is
 * being used, this function is automatically called from the OLEDLG DLL's
 * LibMain.
 *
 * Purpose:
 *   Initializes the OLE UI Library.  Registers the OLE clipboard formats
 *   used in the Paste Special dialog, registers private custom window
 *   messages, and registers window classes of the "Result Image"
 *   and "Icon Box" custom controls used in the UI dialogs.
 *
 * Parameters:
 *
 *  hInstance       HINSTANCE of the module where the UI library resources
 *                  and Dialog Procedures are contained.  If you are calling
 *                  this function yourself, this should be the instance handle
 *                  of your application.
 *
 *  hPrevInst       HINSTANCE of the previous application instance.
 *                  This is the parameter passed in to your WinMain.  For
 *                  the DLL version, this should always be set to zero (for
 *                  WIN16 DLLs).
 *
 * Return Value:
 *  BOOL            TRUE if initialization was successful.
 *                  FALSE otherwise.
 */

#pragma code_seg(".text$initseg")

BOOL bWin4;                             // TRUE if running Windows4 or greater
BOOL bSharedData;               // TRUE if running Win32s (it has shared data)

static DWORD tlsIndex= (DWORD)-1;
static TASKDATA taskData;

STDAPI_(TASKDATA*) GetTaskData()
{
        TASKDATA* pData;
        if (tlsIndex == (DWORD)-1)
                pData = &taskData;
        else
                pData = (TASKDATA*)TlsGetValue(tlsIndex);
        return pData;
}

DWORD WINAPI _AfxTlsAlloc()
{
        DWORD dwResult = TlsAlloc();
        DWORD dwVersion = GetVersion();
        if ((dwVersion & 0x80000000) && (BYTE)dwVersion <= 3)
        {
                while (dwResult <= 2)
                        dwResult = TlsAlloc();
        }
        return dwResult;
}

static int nInitCount;

STDAPI_(BOOL) OleUIUnInitialize();

STDAPI_(BOOL) OleUIInitialize(HINSTANCE hInstance,
        HINSTANCE hPrevInst)
{
        OleDbgOut1(TEXT("OleUIInitialize called.\r\n"));

        // Cache information about the windows version we are running
        DWORD dwVersion = GetVersion();
        bWin4 = LOBYTE(dwVersion) >= 4;
        bSharedData = !bWin4 && (dwVersion & 0x80000000);

        if (nInitCount == 0)
        {
                if (bSharedData)
                {
                        // allocate thread local storage on Win32s
                        tlsIndex = _AfxTlsAlloc();
                        if (tlsIndex == (DWORD)-1)
                                return FALSE;
                }
        }
        ++nInitCount;

        // Setup process local storage if necessary
        if (tlsIndex != (DWORD)-1)
        {
                void* pData = LocalAlloc(LPTR, sizeof(TASKDATA));
                if (pData == NULL)
                {
                        if (nInitCount == 0)
                        {
                                OleUIUnInitialize();
                                return FALSE;
                        }
                }
                TlsSetValue(tlsIndex, pData);
        }

        // Initialize OleStd functions
        OleStdInitialize(hInstance, hInstance);

        // Register messages we need for the dialogs.
        uMsgHelp = RegisterWindowMessage(SZOLEUI_MSG_HELP);
        uMsgEndDialog = RegisterWindowMessage(SZOLEUI_MSG_ENDDIALOG);
        uMsgBrowse = RegisterWindowMessage(SZOLEUI_MSG_BROWSE);
        uMsgChangeIcon = RegisterWindowMessage(SZOLEUI_MSG_CHANGEICON);
        uMsgFileOKString = RegisterWindowMessage(FILEOKSTRING);
        uMsgCloseBusyDlg = RegisterWindowMessage(SZOLEUI_MSG_CLOSEBUSYDIALOG);
        uMsgConvert = RegisterWindowMessage(SZOLEUI_MSG_CONVERT);
        uMsgChangeSource = RegisterWindowMessage(SZOLEUI_MSG_CHANGESOURCE);
        uMsgAddControl = RegisterWindowMessage(SZOLEUI_MSG_ADDCONTROL);
        uMsgBrowseOFN = RegisterWindowMessage(SZOLEUI_MSG_BROWSE_OFN);

        if (!FResultImageInitialize(hInstance, hPrevInst))
        {
                OleDbgOut1(TEXT("OleUIInitialize: FResultImageInitialize failed. Terminating.\r\n"));
                return 0;
        }
        if (!FIconBoxInitialize(hInstance, hPrevInst))
        {
                OleDbgOut1(TEXT("OleUIInitialize: FIconBoxInitialize failed. Terminating.\r\n"));
                return 0;
        }

#if USE_STRING_CACHE==1
        // It is ok if this fails. InsertObject dialog can do without the cache 
        // support. InsertObjCacheUninit will cleanup as appropriate.
        if (!InsertObjCacheInitialize())
        {
            OleDbgOut1(TEXT("OleUIInitiallize: InsertObjCacheInit failed."));
        }
#endif
        return TRUE;
}

#pragma code_seg()


/*
 * OleUIUnInitialize
 *
 * NOTE: This function should only be called by your application IF it is using
 * the static-link version of this library.  If the DLL version is being used,
 * this function is automatically called from the DLL's LibMain.
 *
 * Purpose:
 *   Uninitializes OLE UI libraries.  Deletes any resources allocated by the
 *   library.
 *
 * Return Value:
 *   BOOL       TRUE if successful, FALSE if not.  Current implementation always
 *              returns TRUE.
 */
STDAPI_(BOOL) OleUIUnInitialize()
{
#if USE_STRING_CACHE==1
        InsertObjCacheUninitialize();
#endif
        IconBoxUninitialize();
        ResultImageUninitialize();

        // Cleanup thread local storage
        if (tlsIndex != (DWORD)-1)
        {
                TASKDATA* pData = (TASKDATA*)TlsGetValue(tlsIndex);
                TlsSetValue(tlsIndex, NULL);
                if (pData != NULL)
                {
                        if (pData->hInstCommCtrl != NULL)
                                FreeLibrary(pData->hInstCommCtrl);
                        if (pData->hInstShell != NULL)
                                FreeLibrary(pData->hInstShell);
                        if (pData->hInstComDlg != NULL)
                                FreeLibrary(pData->hInstComDlg);
                        LocalFree(pData);
                }
        }

        // Last chance cleanup
        if (nInitCount == 1)
        {
                // cleanup thread local storage
                if (tlsIndex != (DWORD)-1)
                {
                        TlsFree(tlsIndex);
                        tlsIndex = (DWORD)-1;
                }
        }
        if (nInitCount != 0)
                --nInitCount;

        return TRUE;
}


/*
 * OleUIAddVerbMenu
 *
 * Purpose:
 *  Add the Verb menu for the specified object to the given menu.  If the
 *  object has one verb, we directly add the verb to the given menu.  If
 *  the object has multiple verbs we create a cascading sub-menu.
 *
 * Parameters:
 *  lpObj           LPOLEOBJECT pointing to the selected object.  If this
 *                  is NULL, then we create a default disabled menu item.
 *
 *  lpszShortType   LPTSTR with short type name (AuxName==2) corresponding
 *                  to the lpOleObj. if the string is NOT known, then NULL
 *                  may be passed. if NULL is passed, then
 *                  IOleObject::GetUserType will be called to retrieve it.
 *                  if the caller has the string handy, then it is faster
 *                  to pass it in.
 *
 *  hMenu           HMENU in which to make modifications.
 *
 *  uPos            Position of the menu item
 *
 *  uIDVerbMin      UINT_PTR ID value at which to start the verbs.
 *                      verb_0 = wIDMVerbMin + verb_0
 *                      verb_1 = wIDMVerbMin + verb_1
 *                      verb_2 = wIDMVerbMin + verb_2
 *                      etc.
 *  uIDVerbMax      UINT_PTR maximum ID value allowed for object verbs.
 *                     if uIDVerbMax==0 then any ID value is allowed
 *
 *  bAddConvert     BOOL specifying whether or not to add a "Convert" item
 *                  to the bottom of the menu (with a separator).
 *
 *  idConvert       UINT ID value to use for the Convert menu item, if
 *                  bAddConvert is TRUE.
 *
 *  lphMenu         HMENU FAR * of the cascading verb menu if it's created.
 *                  If there is only one verb, this will be filled with NULL.
 *
 *
 * Return Value:
 *  BOOL            TRUE if lpObj was valid and we added at least one verb
 *                  to the menu.  FALSE if lpObj was NULL and we created
 *                  a disabled default menu item
 */

STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
        LPCTSTR lpszShortType,
        HMENU hMenu, UINT uPos,
        UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert,
        HMENU FAR *lphMenu)
{
        LPPERSISTSTORAGE    lpPS=NULL;
        LPENUMOLEVERB       lpEnumOleVerb = NULL;
        OLEVERB             oleverb;
        LPCTSTR             lpszShortTypeName = lpszShortType;
        LPTSTR              lpszVerbName = NULL;
        HRESULT             hrErr;
        BOOL                fStatus;
        BOOL                fIsLink = FALSE;
        BOOL                fResult = TRUE;
        BOOL                fAddConvertItem = FALSE;
        int                 cVerbs = 0;
        UINT                uFlags = MF_BYPOSITION;
        static BOOL         fFirstTime = TRUE;
        static TCHAR        szBuffer[OLEUI_OBJECTMENUMAX];
        static TCHAR        szNoObjectCmd[OLEUI_OBJECTMENUMAX];
        static TCHAR        szObjectCmd1Verb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szLinkCmd1Verb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szObjectCmdNVerb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szLinkCmdNVerb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szUnknown[OLEUI_OBJECTMENUMAX];
        static TCHAR        szEdit[OLEUI_OBJECTMENUMAX];
        static TCHAR        szConvert[OLEUI_OBJECTMENUMAX];

        // Set fAddConvertItem flag
        if (bAddConvert & (idConvert != 0))
                fAddConvertItem = TRUE;

        // only need to load the strings the 1st time
        if (fFirstTime)
        {
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITNOOBJCMD,
                                 szNoObjectCmd, OLEUI_OBJECTMENUMAX))
                        return FALSE;
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITLINKCMD_1VERB,
                                 szLinkCmd1Verb, OLEUI_OBJECTMENUMAX))
                        return FALSE;
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITOBJECTCMD_1VERB,
                                 szObjectCmd1Verb, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITLINKCMD_NVERB,
                                 szLinkCmdNVerb, OLEUI_OBJECTMENUMAX))
                        return FALSE;
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITOBJECTCMD_NVERB,
                                 szObjectCmdNVerb, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIUNKNOWN,
                                 szUnknown, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDIT,
                                 szEdit, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UICONVERT,
                                   szConvert, OLEUI_OBJECTMENUMAX) && fAddConvertItem)
                        return FALSE;

                fFirstTime = FALSE;
        }

        // Delete whatever menu may happen to be here already.
        DeleteMenu(hMenu, uPos, uFlags);

        if (lphMenu == NULL || IsBadWritePtr(lphMenu, sizeof(HMENU)))
        {
            goto AVMError;
        }
        *lphMenu=NULL;

        if ((!lpOleObj) || IsBadReadPtr(lpOleObj, sizeof (IOleObject)))
                goto AVMError;

        if ((!lpszShortTypeName) || IsBadReadPtr(lpszShortTypeName, sizeof(TCHAR)))
        {
                // get the Short form of the user type name for the menu
                OLEDBG_BEGIN2(TEXT("IOleObject::GetUserType called\r\n"))
                hrErr = lpOleObj->GetUserType(
                                USERCLASSTYPE_SHORT,
                                (LPTSTR FAR*)&lpszShortTypeName);
                OLEDBG_END2

                if (NOERROR != hrErr) {
                        OleDbgOutHResult(TEXT("IOleObject::GetUserType returned"), hrErr);
                }
        }

        // check if the object is a link
        fIsLink = OleStdIsOleLink((LPUNKNOWN)lpOleObj);

        // Get the verb enumerator from the OLE object
        OLEDBG_BEGIN2(TEXT("IOleObject::EnumVerbs called\r\n"))
        hrErr = lpOleObj->EnumVerbs(
                        (LPENUMOLEVERB FAR*)&lpEnumOleVerb
        );
        OLEDBG_END2

        if (NOERROR != hrErr) {
                OleDbgOutHResult(TEXT("IOleObject::EnumVerbs returned"), hrErr);
        }

        if (!(*lphMenu = CreatePopupMenu()))
                goto AVMError;

        // loop through all verbs
        while (lpEnumOleVerb != NULL)
        {
                hrErr = lpEnumOleVerb->Next(
                                1,
                                (LPOLEVERB)&oleverb,
                                NULL
                );
                if (NOERROR != hrErr)
                        break;              // DONE! no more verbs

                /* OLE2NOTE: negative verb numbers and verbs that do not
                **    indicate ONCONTAINERMENU should NOT be put on the verb menu
                */
                if (oleverb.lVerb < 0 ||
                                ! (oleverb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU))
                {
                        /* OLE2NOTE: we must still free the verb name string */
                        if (oleverb.lpszVerbName)
                                OleStdFree(oleverb.lpszVerbName);
                        continue;
                }

                // we must free the previous verb name string
                if (lpszVerbName)
                        OleStdFree(lpszVerbName);

                lpszVerbName = oleverb.lpszVerbName;
                if ( 0 == uIDVerbMax || 
                        (uIDVerbMax >= uIDVerbMin+(UINT)oleverb.lVerb) )
                {
                        fStatus = InsertMenu(
                                        *lphMenu,
                                        (UINT)-1,
                                        MF_BYPOSITION | (UINT)oleverb.fuFlags,
                                        uIDVerbMin+(UINT)oleverb.lVerb,
                                        lpszVerbName
                        );
                        if (! fStatus)
                                goto AVMError;

                        cVerbs++;
                }
        }

        // Add the separator and "Convert" menu item.
        if (fAddConvertItem)
        {
                if (0 == cVerbs)
                {
                        LPTSTR lpsz;

                        // if object has no verbs, then use "Convert" as the obj's verb
                        lpsz = lpszVerbName = OleStdCopyString(szConvert);
                        uIDVerbMin = (UINT)idConvert;

                        // remove "..." from "Convert..." string; it will be added later
                        if (lpsz)
                        {
                                while(*lpsz && *lpsz != '.')
                                        lpsz = CharNext(lpsz);
                                *lpsz = '\0';
                        }
                }

                if (cVerbs > 0)
                {
                        fStatus = InsertMenu(*lphMenu,
                                                (UINT)-1,
                                                MF_BYPOSITION | MF_SEPARATOR,
                                                (UINT)0,
                                                (LPCTSTR)NULL);
                        if (! fStatus)
                                goto AVMError;
                }

                /* add convert menu */
                fStatus = InsertMenu(*lphMenu,
                                        (UINT)-1,
                                        MF_BYPOSITION,
                                        idConvert,
                                        (LPCTSTR)szConvert);
                if (! fStatus)
                        goto AVMError;

                cVerbs++;
        }


        /*
         * Build the appropriate menu based on the number of verbs found
         *
         */
        if (cVerbs == 0)
        {
                // there are NO verbs (not even Convert...). set the menu to be
                // "<short type> &Object/Link" and gray it out.
                wsprintf(
                        szBuffer,
                        (fIsLink ? szLinkCmdNVerb : szObjectCmdNVerb),
                        (lpszShortTypeName ? lpszShortTypeName : TEXT(""))
                );
                uFlags |= MF_GRAYED;

                fResult = FALSE;
                DestroyMenu(*lphMenu);
                *lphMenu = NULL;

        }
        else if (cVerbs == 1)
        {
                //One verb without Convert, one item.
                LPTSTR       lpsz = (fIsLink ? szLinkCmd1Verb : szObjectCmd1Verb);

                // strip ampersands from lpszVerbName to ensure that
                // the right character is used as the menu key
                LPTSTR pchIn;
                LPTSTR pchOut;
                pchIn = pchOut = lpszVerbName;
                while (*pchIn)
                {
                    while (*pchIn && '&' == *pchIn)
                    {
                        pchIn++;
                    }
                    *pchOut = *pchIn;
                    pchOut++;
                    pchIn++;
                }
                *pchOut = 0;

                FormatString2(szBuffer, lpsz, lpszVerbName, lpszShortTypeName, OLEUI_OBJECTMENUMAX);

                // if only "verb" is "Convert..." then append the ellipses
                if (fAddConvertItem)
                        lstrcat(szBuffer, TEXT("..."));

                DestroyMenu(*lphMenu);
                *lphMenu=NULL;
        }
        else
        {

                //Multiple verbs or one verb with Convert, add the cascading menu
                wsprintf(
                        szBuffer,
                        (fIsLink ? szLinkCmdNVerb: szObjectCmdNVerb),
                        (lpszShortTypeName ? lpszShortTypeName : TEXT(""))
                );
                uFlags |= MF_ENABLED | MF_POPUP;
#ifdef _WIN64
//
// Sundown: Checking with JerrySh for the validity of the HMENU truncation...........
//          If not valid, this'd require modifying the prototype of this function for
//          uIDVerbMin & uIDVerbMax and modifying sdk\inc\oledlg.h exposed interface.
//
                OleDbgAssert( !(((ULONG_PTR)*lphMenu) >> 32) )
#endif // _WIN64
                uIDVerbMin=(UINT)HandleToUlong(*lphMenu);
        }

        if (!InsertMenu(hMenu, uPos, uFlags, uIDVerbMin, szBuffer))
        {
AVMError:
                InsertMenu(hMenu, uPos, MF_GRAYED | uFlags,
                        uIDVerbMin, szNoObjectCmd);
                fResult = FALSE;
        }

	// Redraw the menu bar, if possible
	HWND hWndActive   = GetActiveWindow();
	HMENU hMenuActive = GetMenu(hWndActive);

	if(hMenuActive == hMenu)
	{
		DrawMenuBar(hWndActive);
	}

        if (lpszVerbName)
                OleStdFree(lpszVerbName);
        if (!lpszShortType && lpszShortTypeName)
                OleStdFree((LPVOID)lpszShortTypeName);
        if (lpEnumOleVerb)
                lpEnumOleVerb->Release();
        return fResult;
}

/////////////////////////////////////////////////////////////////////////////
// Support for special error prompts

typedef struct tagPROMPTUSER
{
        va_list argptr;
        UINT    nIDD;           // dialog/help ID
        LPTSTR  szTitle;
} PROMPTUSER, *PPROMPTUSER, FAR* LPPROMPTUSER;

/* PromptUserDlgProc
 * -----------------
 *
 *  Purpose:
 *      Dialog procedure used by OleUIPromptUser(). Returns when a button is
 *      clicked in the dialog box and the button id is return.
 *
 *  Parameters:
 *      hDlg
 *      iMsg
 *      wParam
 *      lParam
 *
 *  Returns:
 *
 */
INT_PTR CALLBACK PromptUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        switch (iMsg)
        {
        case WM_INITDIALOG:
                {
                        SendDlgItemMessage(hDlg, IDC_PU_ICON,
                                STM_SETICON, (WPARAM)LoadIcon(NULL, IDI_EXCLAMATION), 0L);

                        LPPROMPTUSER lpPU = (LPPROMPTUSER)lParam;
                        SetProp(hDlg, STRUCTUREPROP, lpPU);
                        SetWindowText(hDlg, lpPU->szTitle);

                        TCHAR szFormat[256];
                        GetDlgItemText(hDlg, IDC_PU_TEXT, szFormat,
                                sizeof(szFormat)/sizeof(TCHAR));
                        TCHAR szBuf[256];
                        wvsprintf(szBuf, szFormat, lpPU->argptr);
                        SetDlgItemText(hDlg, IDC_PU_TEXT, szBuf);
                }
                return TRUE;

        case WM_COMMAND:
                EndDialog(hDlg, wParam);
                return TRUE;

        default:
                return FALSE;
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIPromptUserInternal
//
//  Synopsis:   internal entry point to start the PromptUser dialog
//              Used to support both ANSI and Unicode entrypoints
//
//  Arguments:  [nTemplate]  - dialog template ID
//              [szTitle]    - the title string
//              [hwndParent] - the dialog's parent window
//              [arglist]    - variable argument list
//
//  History:    12-01-94   stevebl   Created
//
//----------------------------------------------------------------------------

int OleUIPromptUserInternal(int nTemplate, HWND hwndParent, LPTSTR szTitle, va_list arglist)
{
    PROMPTUSER pu;
    pu.szTitle = szTitle;
    pu.argptr = arglist;
    pu.nIDD = nTemplate;
    return ((int)DialogBoxParam(_g_hOleStdResInst, MAKEINTRESOURCE(nTemplate), hwndParent,
                    PromptUserDlgProc, (LPARAM)&pu));
}

/* OleUIPromptUser
 * ---------------
 *
 *  Purpose:
 *      Popup a dialog box with the specified template and returned the
 *      response (button id) from the user.
 *
 *  Parameters:
 *      nTemplate       resource number of the dialog
 *      hwndParent      parent of the dialog box
 *      ...             title of the dialog box followed by argument list
 *                      for the format string in the static control
 *                      (IDC_PU_TEXT) of the dialog box.
 *                      The caller has to make sure that the correct number
 *                      and type of argument are passed in.
 *
 *  Returns:
 *      button id selected by the user (template dependent)
 *
 *  Comments:
 *      the following message dialog boxes are supported:
 *
 *      IDD_LINKSOURCEUNAVAILABLE -- Link source is unavailable
 *          VARARG Parameters:
 *              None.
 *          Used for the following error codes:
 *              OLE_E_CANT_BINDTOSOURCE
 *              STG_E_PATHNOTFOUND
 *              (sc >= MK_E_FIRST) && (sc <= MK_E_LAST) -- any Moniker error
 *              any unknown error if object is a link
 *
 *      IDD_SERVERNOTFOUND -- server registered but NOT found
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of object
 *          Used for the following error codes:
 *              CO_E_APPNOTFOUND
 *              CO_E_APPDIDNTREG
 *              any unknown error if object is an embedded object
 *
 *      IDD_SERVERNOTREG -- server NOT registered
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of object
 *          Used for the following error codes:
 *              REGDB_E_CLASSNOTREG
 *              OLE_E_STATIC -- static object with no server registered
 *
 *      IDD_LINKTYPECHANGED -- class of link source changed since last binding
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of ole link source
 *          Used for the following error codes:
 *              OLE_E_CLASSDIFF
 *
 *      IDD_LINKTYPECHANGED -- class of link source changed since last binding
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of ole link source
 *          Used for the following error codes:
 *              OLE_E_CLASSDIFF
 *
 *      IDD_OUTOFMEMORY -- out of memory
 *          VARARG Parameters:
 *              None.
 *          Used for the following error codes:
 *              E_OUTOFMEMORY
 *
 */

int FAR CDECL OleUIPromptUser(int nTemplate, HWND hwndParent, ...)
{
        va_list arglist;
        va_start(arglist, hwndParent);
        LPTSTR szTitle = va_arg(arglist, LPTSTR);
        int nRet = OleUIPromptUserInternal(nTemplate, hwndParent, szTitle, arglist);
        va_end(arglist);

        return nRet;
}

/* UpdateLinksDlgProc
 * ------------------
 *
 *  Purpose:
 *      Dialog procedure used by OleUIUpdateLinks(). It will enumerate all
 *      all links in the container and updates all automatic links.
 *      Returns when the Stop Button is clicked in the dialog box or when all
 *      links are updated
 *
 *  Parameters:
 *      hDlg
 *      iMsg
 *      wParam
 *      lParam          pointer to the UPDATELINKS structure
 *
 *  Returns:
 *
 */

#define UPDATELINKS_STARTDELAY  2000    // delay before 1st link updates

INT_PTR CALLBACK UpdateLinksDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        LPUPDATELINKS FAR*      lplpUL = NULL;
        HANDLE                  gh;
        static BOOL             fAbort = FALSE;

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                gh = RemoveProp(hDlg, STRUCTUREPROP);
                if (NULL != gh)
                {
                        GlobalUnlock(gh);
                        GlobalFree(gh);
                }
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
        {
                gh = GlobalAlloc(GHND, sizeof(LPUPDATELINKS));
                SetProp(hDlg, STRUCTUREPROP, gh);

                if (NULL == gh)
                {
                        PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC,0L);
                        return FALSE;
                }

                fAbort = FALSE;
                lplpUL = (LPUPDATELINKS FAR*)GlobalLock(gh);

                if (!lplpUL)
                {
                        PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC,0L);
                        return FALSE;
                }

                if (bWin4)
                {
                        if (StandardInitCommonControls() >= 0)
                        {
                                // get rect of the existing "progress" control
                                RECT rect;
                                GetWindowRect(GetDlgItem(hDlg, IDC_UL_METER), &rect);
                                ScreenToClient(hDlg, ((POINT*)&rect)+0);
                                ScreenToClient(hDlg, ((POINT*)&rect)+1);

                                // create progress control in that rect
                                HWND hProgress = CreateWindowEx(
                                        0, PROGRESS_CLASS, NULL, WS_CHILD|WS_VISIBLE,
                                        rect.left, rect.top,
                                        rect.right-rect.left, rect.bottom-rect.top, hDlg,
                                        (HMENU)IDC_UL_PROGRESS, _g_hOleStdInst, NULL);
                                if (hProgress != NULL)
                                {
                                        // initialize the progress control
                                        SendMessage(hProgress, PBM_SETRANGE, 0, MAKELONG(0, 100));

                                        // hide the other "meter" control
                                        StandardShowDlgItem(hDlg, IDC_UL_METER, SW_HIDE);
                                }
                        }
                }

                *lplpUL = (LPUPDATELINKS)lParam;
                if ((*lplpUL)->lpszTitle)
                {
                    SetWindowText(hDlg, (*lplpUL)->lpszTitle);
                }
                SetTimer(hDlg, 1, UPDATELINKS_STARTDELAY, NULL);
                return TRUE;
        }

        case WM_TIMER:
                KillTimer(hDlg, 1);
                gh = GetProp(hDlg, STRUCTUREPROP);

                if (NULL!=gh)
                {
                        // gh was locked previously, lock and unlock to get lplpUL
                        lplpUL = (LPUPDATELINKS*)GlobalLock(gh);
                        GlobalUnlock(gh);
                }
                if (! fAbort && lplpUL)
                        PostMessage(hDlg, WM_U_UPDATELINK, 0, (LPARAM)(*lplpUL));
                else
                        PostMessage(hDlg,uMsgEndDialog,OLEUI_CANCEL,0L);

                return 0;

        case WM_COMMAND:    // Stop button
                fAbort = TRUE;
                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                return TRUE;

        case WM_U_UPDATELINK:
                {
                        HRESULT         hErr;
                        int             nPercent;
                        RECT            rc;
                        TCHAR           szPercent[5];       // 0% to 100%
                        HBRUSH          hbr;
                        HDC             hDC;
                        HWND            hwndMeter;
                        MSG             msg;
                        DWORD           dwUpdateOpt;
                        LPUPDATELINKS   lpUL = (LPUPDATELINKS)lParam;

                        lpUL->dwLink=lpUL->lpOleUILinkCntr->GetNextLink(lpUL->dwLink);

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                                if (! IsDialogMessage(hDlg, &msg))
                                {
                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                }
                        }

                        if (fAbort)
                                return FALSE;

                        if (!lpUL->dwLink)
                        {
                                // all links processed
                                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                                return TRUE;
                        }

                        hErr = lpUL->lpOleUILinkCntr->GetLinkUpdateOptions(
                                lpUL->dwLink, (LPDWORD)&dwUpdateOpt);

                        if ((hErr == NOERROR) && (dwUpdateOpt == OLEUPDATE_ALWAYS))
                        {
                                hErr = lpUL->lpOleUILinkCntr->UpdateLink(lpUL->dwLink, FALSE, FALSE);
                                lpUL->fError |= (hErr != NOERROR);
                                lpUL->cUpdated++;

                                nPercent = (lpUL->cLinks > 0) ? (lpUL->cUpdated * 100 / lpUL->cLinks) : 100;
                                if (nPercent <= 100)
                                {
                                        // update percentage
                                        wsprintf(szPercent, TEXT("%d%%"), nPercent);
                                        SetDlgItemText(hDlg, IDC_UL_PERCENT, szPercent);

                                        HWND hProgress = GetDlgItem(hDlg, IDC_UL_PROGRESS);
                                        if (hProgress == NULL)
                                        {
                                                // update indicator
                                                hwndMeter = GetDlgItem(hDlg, IDC_UL_METER);
                                                GetClientRect(hwndMeter, (LPRECT)&rc);
                                                InflateRect((LPRECT)&rc, -1, -1);
                                                rc.right = (rc.right - rc.left) * nPercent / 100 + rc.left;
                                                hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
                                                if (hbr)
                                                {
                                                        hDC = GetDC(hwndMeter);
                                                        if (hDC)
                                                        {
                                                                FillRect(hDC, (LPRECT)&rc, hbr);
                                                                ReleaseDC(hwndMeter, hDC);
                                                        }
                                                        DeleteObject(hbr);
                                                }
                                        }
                                        else
                                        {
                                                // update the progress indicator
                                                SendMessage(hProgress, PBM_SETPOS, nPercent, 0);
                                        }
                                }
                        }

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                                if (! IsDialogMessage(hDlg, &msg))
                                {
                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                }
                        }
                        PostMessage(hDlg, WM_U_UPDATELINK, 0, lParam);
                }
                return TRUE;

        case WM_U_SHOWWINDOW:
                ShowWindow(hDlg, SW_SHOW);
                return TRUE;
        }
        return FALSE;
}


/* OleUIUpdateLinkS
 * ----------------
 *
 *  Purpose:
 *      Update all links in the Link Container and popup a dialog box which
 *      shows the progress of the updating.
 *      The process is stopped when the user press Stop button or when all
 *      links are processed.
 *
 *  Parameters:
 *      lpOleUILinkCntr         pointer to Link Container
 *      hwndParent              parent window of the dialog
 *      lpszTitle               title of the dialog box
 *      cLinks                  total number of links
 *
 *  Returns:
 *      TRUE                    all links updated successfully or user aborted dialog
 *      FALSE                   oherwise
 */
STDAPI_(BOOL) OleUIUpdateLinks(
        LPOLEUILINKCONTAINER lpOleUILinkCntr, HWND hwndParent, LPTSTR lpszTitle, int cLinks)
{
        LPUPDATELINKS lpUL = (LPUPDATELINKS)OleStdMalloc(sizeof(UPDATELINKS));
        if (lpUL == NULL)
            return FALSE;

        BOOL          fError = TRUE;


        // Validate interface.
        if (NULL == lpOleUILinkCntr || IsBadReadPtr(lpOleUILinkCntr, sizeof(IOleUILinkContainer)))
                goto Error;


        // Validate parent-window handle.  NULL is considered valid.
        if (NULL != hwndParent && !IsWindow(hwndParent))
                goto Error;

        // Validate the dialog title.  NULL is considered valid.
        if (NULL != lpszTitle && IsBadReadPtr(lpszTitle, 1))
                goto Error;

        if (cLinks < 0)
                goto Error;

        OleDbgAssert(lpOleUILinkCntr && hwndParent && lpszTitle && (cLinks>0));
        OleDbgAssert(lpUL);

        lpUL->lpOleUILinkCntr = lpOleUILinkCntr;
        lpUL->cLinks           = cLinks;
        lpUL->cUpdated         = 0;
        lpUL->dwLink           = 0;
        lpUL->fError           = FALSE;
        lpUL->lpszTitle    = lpszTitle;

        DialogBoxParam(_g_hOleStdResInst, MAKEINTRESOURCE(IDD_UPDATELINKS),
                        hwndParent, UpdateLinksDlgProc, (LPARAM)lpUL);

        fError = lpUL->fError;
Error:
        OleStdFree((LPVOID)lpUL);

        return !fError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\insobj.cpp ===
/*
 * INSOBJ.CPP
 *
 * Implements the OleUIInsertObject function which invokes the complete
 * Insert Object dialog.  Makes use of the OleChangeIcon function in
 * ICON.CPP.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */

#include "precomp.h"
#include "common.h"
#include <commdlg.h>
#include <memory.h>
#include <dos.h>
#include <stdlib.h>
#include <reghelp.hxx>
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"

#include "strcache.h"

OLEDBGDATA

#if USE_STRING_CACHE==1
extern CStringCache gInsObjStringCache; //defined in strcache.cpp
DWORD g_dwOldListType = 0;
#endif

// Internally used structure
typedef struct tagINSERTOBJECT
{
        LPOLEUIINSERTOBJECT lpOIO;              // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */
        DWORD               dwFlags;
        CLSID               clsid;
        TCHAR               szFile[MAX_PATH];
        BOOL                fFileSelected;      // Enables Display As Icon for links
        BOOL                fAsIconNew;
        BOOL                fAsIconFile;
        BOOL                fFileDirty;
        BOOL                fFileValid;
        UINT                nErrCode;
        HGLOBAL             hMetaPictFile;
        UINT                nBrowseHelpID;      // Help ID callback for Browse dlg
        BOOL                            bObjectListFilled;
        BOOL                            bControlListFilled;
        BOOL                            bControlListActive;

} INSERTOBJECT, *PINSERTOBJECT, FAR *LPINSERTOBJECT;

// Internal function prototypes
// INSOBJ.CPP

void EnableChangeIconButton(HWND hDlg, BOOL fEnable);
INT_PTR CALLBACK InsertObjectDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FInsertObjectInit(HWND, WPARAM, LPARAM);
UINT UFillClassList(HWND, UINT, LPCLSID, BOOL, BOOL);
LRESULT URefillClassList(HWND, LPINSERTOBJECT);
BOOL FToggleObjectSource(HWND, LPINSERTOBJECT, DWORD);
void UpdateClassType(HWND, LPINSERTOBJECT, BOOL);
void SetInsertObjectResults(HWND, LPINSERTOBJECT);
BOOL FValidateInsertFile(HWND, BOOL, UINT FAR*);
void InsertObjectCleanup(HWND);
static void UpdateClassIcon(HWND hDlg, LPINSERTOBJECT lpIO, HWND hList);
BOOL CALLBACK HookDlgProc(HWND, UINT, WPARAM, LPARAM);

#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':')

BOOL CALLBACK HookDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#ifdef CHICO
    switch (uMsg)
    {
    case WM_INITDIALOG:
        TCHAR szTemp[MAX_PATH];
        LoadString(_g_hOleStdResInst, IDS_INSERT , szTemp, MAX_PATH);
        CommDlg_OpenSave_SetControlText(GetParent(hDlg), IDOK, szTemp);
        return(TRUE);
    default:
        break;
    }
#endif
    return(FALSE);
}

/*
 * OleUIInsertObject
 *
 * Purpose:
 *  Invokes the standard OLE Insert Object dialog box allowing the
 *  user to select an object source and classname as well as the option
 *  to display the object as itself or as an icon.
 *
 * Parameters:
 *  lpIO            LPOLEUIINSERTOBJECT pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS or OLEUI_OK if all is well, otherwise
 *                  an error value.
 */

STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT lpIO)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpIO, sizeof(OLEUIINSERTOBJECT),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        //Now we can do Insert Object specific validation.

        if (NULL != lpIO->lpszFile &&
                (lpIO->cchFile <= 0 || lpIO->cchFile > MAX_PATH))
        {
                uRet = OLEUI_IOERR_CCHFILEINVALID;
        }

        // NULL is NOT valid for lpszFile
        if (lpIO->lpszFile == NULL)
        {
            uRet = OLEUI_IOERR_LPSZFILEINVALID;
        }
        else
        {
            if (IsBadWritePtr(lpIO->lpszFile, lpIO->cchFile*sizeof(TCHAR)))
                    uRet = OLEUI_IOERR_LPSZFILEINVALID;
        }

        if (0 != lpIO->cClsidExclude &&
                IsBadReadPtr(lpIO->lpClsidExclude, lpIO->cClsidExclude * sizeof(CLSID)))
        {
                uRet = OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

        //If we have flags to create any object, validate necessary data.
        if (lpIO->dwFlags & (IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT | IOF_CREATELINKOBJECT))
        {
                if (NULL != lpIO->lpFormatEtc
                        && IsBadReadPtr(lpIO->lpFormatEtc, sizeof(FORMATETC)))
                        uRet = OLEUI_IOERR_LPFORMATETCINVALID;

                if (NULL != lpIO->ppvObj && IsBadWritePtr(lpIO->ppvObj, sizeof(LPVOID)))
                        uRet = OLEUI_IOERR_PPVOBJINVALID;

                if (NULL != lpIO->lpIOleClientSite
                        && IsBadReadPtr(*(VOID**)&lpIO->lpIOleClientSite, sizeof(DWORD)))
                        uRet = OLEUI_IOERR_LPIOLECLIENTSITEINVALID;

                if (NULL != lpIO->lpIStorage
                        && IsBadReadPtr(*(VOID**)&lpIO->lpIStorage, sizeof(DWORD)))
                        uRet = OLEUI_IOERR_LPISTORAGEINVALID;
        }

        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }
#if USE_STRING_CACHE==1
        // Inform the string cache about a fresh InsertObject invocation.
        gInsObjStringCache.NewCall(lpIO->dwFlags, lpIO->cClsidExclude);
#endif

        //Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(InsertObjectDialogProc, (LPOLEUISTANDARD)lpIO,
                hMemDlg, MAKEINTRESOURCE(IDD_INSERTOBJECT));

        //Stop here if we cancelled or had an error.
        if (OLEUI_SUCCESS !=uRet && OLEUI_OK!=uRet)
                return uRet;

        /*
         * If any of the flags specify that we're to create objects on return
         * from this dialog, then do so.  If we encounter an error in this
         * processing, we return OLEUI_IOERR_SCODEHASERROR.  Since the
         * three select flags are mutually exclusive, we don't have to
         * if...else here, just if each case (keeps things cleaner that way).
         */

        lpIO->sc = S_OK;

        // Check if Create New was selected and we have IOF_CREATENEWOBJECT
        if ((lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL)) &&
                (lpIO->dwFlags & IOF_CREATENEWOBJECT))
        {
                HRESULT hrErr = OleCreate(lpIO->clsid, lpIO->iid, lpIO->oleRender,
                        lpIO->lpFormatEtc, lpIO->lpIOleClientSite, lpIO->lpIStorage,
                        lpIO->ppvObj);
                lpIO->sc = GetScode(hrErr);
        }

        // Try Create From File
        if ((lpIO->dwFlags & IOF_SELECTCREATEFROMFILE))
        {
                if (!(lpIO->dwFlags & IOF_CHECKLINK) && (lpIO->dwFlags & IOF_CREATEFILEOBJECT))
                {
                        HRESULT hrErr=OleCreateFromFile(CLSID_NULL, lpIO->lpszFile, lpIO->iid,
                                lpIO->oleRender, lpIO->lpFormatEtc, lpIO->lpIOleClientSite,
                                lpIO->lpIStorage, lpIO->ppvObj);
                        lpIO->sc = GetScode(hrErr);
                }

                if ((lpIO->dwFlags & IOF_CHECKLINK) && (lpIO->dwFlags & IOF_CREATELINKOBJECT))
                {
                        HRESULT hrErr=OleCreateLinkToFile(lpIO->lpszFile, lpIO->iid,
                                lpIO->oleRender, lpIO->lpFormatEtc, lpIO->lpIOleClientSite,
                                lpIO->lpIStorage, lpIO->ppvObj);
                        lpIO->sc = GetScode(hrErr);
                }
        }

        //If we tried but failed a create option, then return the appropriate error
        if (S_OK != lpIO->sc)
                uRet = OLEUI_IOERR_SCODEHASERROR;

        return uRet;
}

/*
 * InsertObjectDialogProc
 *
 * Purpose:
 *  Implements the OLE Insert Object dialog as invoked through the
 *  OleUIInsertObject function.
 */

INT_PTR CALLBACK InsertObjectDialogProc(HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPINSERTOBJECT lpIO = (LPINSERTOBJECT)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (BOOL)uRet;

        // Process help message from Change Icon
        if (iMsg == uMsgHelp)
        {
                if (lpIO && (lpIO->lpOIO))
                    PostMessage(lpIO->lpOIO->hWndOwner, uMsgHelp, wParam, lParam);
                return FALSE;
        }

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // The following messages do not require lpio to be non-null.
        switch (iMsg)
        {
        case WM_INITDIALOG:
            return FInsertObjectInit(hDlg, wParam, lParam);
        }

        // The following messages DO require lpIO to be non-null, so don't
        // continue processing if lpIO is NULL.
        if (NULL == lpIO)
            return FALSE;

        switch (iMsg)
        {
        case WM_DESTROY:
            InsertObjectCleanup(hDlg);
            StandardCleanup(lpIO, hDlg);
            break;

        case WM_COMMAND:
            switch (wID)
            {
            case IDC_IO_CREATENEW:
                if (1 == IsDlgButtonChecked(hDlg, IDC_IO_CREATENEW))
                {
                    FToggleObjectSource(hDlg, lpIO, IOF_SELECTCREATENEW);
                    SetFocus(GetDlgItem(hDlg, IDC_IO_CREATENEW));
                }
                break;
                
            case IDC_IO_CREATEFROMFILE:
                if (1 == IsDlgButtonChecked(hDlg, IDC_IO_CREATEFROMFILE))
                {
                    FToggleObjectSource(hDlg, lpIO, IOF_SELECTCREATEFROMFILE);
                    SetFocus(GetDlgItem(hDlg, IDC_IO_CREATEFROMFILE));
                }
                break;
                
            case IDC_IO_INSERTCONTROL:
                if (1 == IsDlgButtonChecked(hDlg, IDC_IO_INSERTCONTROL))
                {
                    FToggleObjectSource(hDlg, lpIO, IOF_SELECTCREATECONTROL);
                    SetFocus(GetDlgItem(hDlg, IDC_IO_INSERTCONTROL));
                }
                break;
                
            case IDC_IO_LINKFILE:
                {
                    BOOL fCheck=IsDlgButtonChecked(hDlg, wID);
                    if (fCheck)
                        lpIO->dwFlags |=IOF_CHECKLINK;
                    else
                        lpIO->dwFlags &=~IOF_CHECKLINK;
                    
                    // Results change here, so be sure to update it.
                    SetInsertObjectResults(hDlg, lpIO);
                    UpdateClassIcon(hDlg, lpIO, NULL);
                }
                break;

            case IDC_IO_OBJECTTYPELIST:
                switch (wCode)
                {
                case LBN_SELCHANGE:
                    UpdateClassIcon(hDlg, lpIO, hWndMsg);
                    SetInsertObjectResults(hDlg, lpIO);
                    break;
                    
                case LBN_DBLCLK:
                    SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                    break;
                }
                break;

            case IDC_IO_FILEDISPLAY:
                // If there are characters, enable OK and Display As Icon
                if (EN_CHANGE == wCode)
                {
                    lpIO->fFileDirty = TRUE;
                    lpIO->fFileValid = FALSE;
                    lpIO->fFileSelected = (0L != SendMessage(hWndMsg, EM_LINELENGTH, 0, 0L));
                    StandardEnableDlgItem(hDlg, IDC_IO_LINKFILE, lpIO->fFileSelected);
                    StandardEnableDlgItem(hDlg, IDC_IO_DISPLAYASICON, lpIO->fFileSelected);
                    EnableChangeIconButton(hDlg, lpIO->fFileSelected);
                    StandardEnableDlgItem(hDlg, IDOK, lpIO->fFileSelected);
                }
                if (EN_KILLFOCUS == wCode && NULL != lpIO)
                {
                    if (FValidateInsertFile(hDlg, FALSE, &lpIO->nErrCode))
                    {
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = TRUE;
                        UpdateClassIcon(hDlg, lpIO, NULL);
                        UpdateClassType(hDlg, lpIO, TRUE);
                    }
                    else
                    {
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = FALSE;
                        UpdateClassType(hDlg, lpIO, FALSE);
                    }
                }
                break;

            case IDC_IO_DISPLAYASICON:
                {
                    BOOL fCheck = IsDlgButtonChecked(hDlg, wID);
                    if (fCheck)
                        lpIO->dwFlags |=IOF_CHECKDISPLAYASICON;
                    else
                        lpIO->dwFlags &=~IOF_CHECKDISPLAYASICON;
                    
                    // Update the internal flag based on this checking
                    if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                        lpIO->fAsIconNew = fCheck;
                    else
                        lpIO->fAsIconFile = fCheck;
                    
                    // Re-read the class icon on Display checked
                    if (fCheck)
                    {
                        if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
                        {
                            if (FValidateInsertFile(hDlg, TRUE,&lpIO->nErrCode))
                            {
                                lpIO->fFileDirty = FALSE;
                                lpIO->fFileValid = TRUE;
                                UpdateClassIcon(hDlg, lpIO,
                                                GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
                                UpdateClassType(hDlg, lpIO, TRUE);
                            }
                            else
                            {
                                lpIO->fAsIconFile= FALSE;
                                lpIO->fFileDirty = FALSE;
                                lpIO->fFileValid = FALSE;
                                SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY,
                                                   IBXM_IMAGESET, 0, 0L);
                                UpdateClassType(hDlg, lpIO, FALSE);
                                
                                lpIO->dwFlags &=~IOF_CHECKDISPLAYASICON;
                                CheckDlgButton(hDlg, IDC_IO_DISPLAYASICON, 0);
                                
                                HWND hWndEC = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                                SetFocus(hWndEC);
                                SendMessage(hWndEC, EM_SETSEL, 0, -1);
                                return TRUE;
                            }
                        }
                        else
                            UpdateClassIcon(hDlg, lpIO,
                                            GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
                    }
                    
                    // Results change here, so be sure to update it.
                    SetInsertObjectResults(hDlg, lpIO);

                    /*
                     * Show or hide controls as appropriate.  Do the icon
                     * display last because it will take some time to repaint.
                     * If we do it first then the dialog looks too sluggish.
                     */
                    UINT i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
                    StandardShowDlgItem(hDlg, IDC_IO_ICONDISPLAY, i);
                    StandardShowDlgItem(hDlg, IDC_IO_CHANGEICON, i);
                    EnableChangeIconButton(hDlg, fCheck);
                }
                break;

            case IDC_IO_CHANGEICON:
                {
                    // if we're in SELECTCREATEFROMFILE mode, then we need to Validate
                    // the contents of the edit control first.

                    if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
                    {
                        if (lpIO->fFileDirty &&
                            !FValidateInsertFile(hDlg, TRUE, &lpIO->nErrCode))
                        {
                            HWND hWndEC;
                            lpIO->fFileValid = FALSE;
                            hWndEC = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                            SetFocus(hWndEC);
                            SendMessage(hWndEC, EM_SETSEL, 0, -1);
                            return TRUE;
                        }
                        else
                        {
                            lpIO->fFileDirty = FALSE;
                        }
                    }
                    
                    // Initialize the structure for the hook.
                    OLEUICHANGEICON ci; memset(&ci, 0, sizeof(ci));
                    ci.cbStruct = sizeof(ci);
                    ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                        IDC_IO_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                    ci.hWndOwner= hDlg;
                    ci.dwFlags  = CIF_SELECTCURRENT;
                    if (lpIO->dwFlags & IOF_SHOWHELP)
                        ci.dwFlags |= CIF_SHOWHELP;
                    
                    HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                    int iCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);
                    if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                    {
                        LPTSTR pszString = (LPTSTR)OleStdMalloc(
                            OLEUI_CCHKEYMAX_SIZE + OLEUI_CCHCLSIDSTRING_SIZE);
                        
                        SendMessage(hList, LB_GETTEXT, iCurSel, (LPARAM)pszString);
                        
                        LPTSTR pszCLSID = PointerToNthField(pszString, 2, '\t');
                        CLSIDFromString(pszCLSID, &ci.clsid);
                        OleStdFree((LPVOID)pszString);
                    }
                    else  // IOF_SELECTCREATEFROMFILE
                    {
                        TCHAR  szFileName[MAX_PATH];
                        GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFileName, MAX_PATH);
                            if (S_OK != GetClassFile(szFileName, &ci.clsid))
                            {
                                int istrlen = lstrlen(szFileName);
                                LPTSTR lpszExtension = szFileName + istrlen -1;

                                while (lpszExtension > szFileName &&
                                       *lpszExtension != '.')
                                {
                                    lpszExtension = CharPrev(szFileName, lpszExtension);
                                }

                                GetAssociatedExecutable(lpszExtension, ci.szIconExe, sizeof(ci.szIconExe)/sizeof(ci.szIconExe[0]));
                                ci.cchIconExe = lstrlen(ci.szIconExe);
                                ci.dwFlags |= CIF_USEICONEXE;
                            }
                    }

                    // Let the hook in to customize Change Icon if desired.
                    uRet = UStandardHook(lpIO, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);

                    if (0 == uRet)
                        uRet = (UINT)(OLEUI_OK == OleUIChangeIcon(&ci));
                    
                    // Update the display and itemdata if necessary.
                    if (0 != uRet)
                    {
                        /*
                         * OleUIChangeIcon will have already freed our
                         * current hMetaPict that we passed in when OK is
                         * pressed in that dialog.  So we use 0L as lParam
                         * here so the IconBox doesn't try to free the
                         * metafilepict again.
                         */
                        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY,
                                           IBXM_IMAGESET, 0, (LPARAM)ci.hMetaPict);
                        
                        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                            SendMessage(hList, LB_SETITEMDATA, iCurSel, (LPARAM)ci.hMetaPict);
                    }
                }
                break;

            case IDC_IO_FILE:
                {
                    /*
                     * To allow the hook to customize the browse dialog, we
                     * send OLEUI_MSG_BROWSE.  If the hook returns FALSE
                     * we use the default, otherwise we trust that it retrieved
                     * a filename for us.  This mechanism prevents hooks from
                     * trapping IDC_IO_BROWSE to customize the dialog and from
                     * trying to figure out what we do after we have the name.
                     */
                    TCHAR szTemp[MAX_PATH];
                    int nChars = GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szTemp, MAX_PATH);
                    
                    TCHAR szInitialDir[MAX_PATH];
                    BOOL fUseInitialDir = FALSE;
                    if (FValidateInsertFile(hDlg, FALSE, &lpIO->nErrCode))
                    {
                        StandardGetFileTitle(szTemp, lpIO->szFile, MAX_PATH);
                        int istrlen = lstrlen(lpIO->szFile);
                        
                        lstrcpyn(szInitialDir, szTemp, nChars - istrlen);
                        fUseInitialDir = TRUE;
                    }
                    else  // file name isn't valid...lop off end of szTemp to get a
                          // valid directory
                    {
                        TCHAR szBuffer[MAX_PATH];
                        lstrcpyn(szBuffer, szTemp, sizeof(szBuffer)/sizeof(TCHAR));
                        
                        if ('\\' == szBuffer[nChars-1])
                            szBuffer[nChars-1] = '\0';
                        
                        DWORD Attribs = GetFileAttributes(szBuffer);
                        if (Attribs != 0xffffffff &&
                            (Attribs & FILE_ATTRIBUTE_DIRECTORY) )
                        {
                            lstrcpy(szInitialDir, szBuffer);
                            fUseInitialDir = TRUE;
                        }
                        *lpIO->szFile = '\0';
                    }
                    
                    uRet = UStandardHook(lpIO, hDlg, uMsgBrowse,
                                         MAX_PATH, (LPARAM)(LPSTR)lpIO->szFile);

                    if (0 == uRet)
                    {
                        DWORD dwOfnFlags = OFN_FILEMUSTEXIST | OFN_ENABLEHOOK;
                        if (lpIO->lpOIO->dwFlags & IOF_SHOWHELP)
                            dwOfnFlags |= OFN_SHOWHELP;
                        
                        uRet = (UINT)Browse(hDlg, lpIO->szFile,
                                            fUseInitialDir ? szInitialDir : NULL, MAX_PATH,
                                            IDS_FILTERS, dwOfnFlags, ID_BROWSE_INSERTFILE, (LPOFNHOOKPROC)HookDlgProc);
                    }
                    
                    // Only update if the file changed.
                    if (0 != uRet && 0 != lstrcmpi(szTemp, lpIO->szFile))
                    {
                        SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, lpIO->szFile);
                        lpIO->fFileSelected=TRUE;
                        
                        if (FValidateInsertFile(hDlg, TRUE, &lpIO->nErrCode))
                        {
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = TRUE;
                            UpdateClassIcon(hDlg, lpIO, NULL);
                            UpdateClassType(hDlg, lpIO, TRUE);
                            // auto set OK to be default button if valid file
                            SendMessage(hDlg, DM_SETDEFID,
                                        (WPARAM)GetDlgItem(hDlg, IDOK), 0L);
                            SetFocus(GetDlgItem(hDlg, IDOK));
                        }
                        else  // filename is invalid - set focus back to ec
                        {
                            HWND hWnd;
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = FALSE;
                            hWnd = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                            SetFocus(hWnd);
                            SendMessage(hWnd, EM_SETSEL, 0, -1);
                        }

                        // Once we have a file, Display As Icon is always enabled
                        StandardEnableDlgItem(hDlg, IDC_IO_DISPLAYASICON, TRUE);
                        
                        // As well as OK
                        StandardEnableDlgItem(hDlg, IDOK, TRUE);
                    }
                }
                break;

            case IDC_IO_ADDCONTROL:
                {
                    TCHAR szFileName[MAX_PATH];
                    szFileName[0] = 0;
                    
                    // allow hook to customize
                    uRet = UStandardHook(lpIO, hDlg, uMsgAddControl,
                                         MAX_PATH, (LPARAM)szFileName);
                    
                    if (0 == uRet)
                    {
                        DWORD dwOfnFlags = OFN_FILEMUSTEXIST | OFN_ENABLEHOOK;
                        if (lpIO->lpOIO->dwFlags & IOF_SHOWHELP)
                            dwOfnFlags |= OFN_SHOWHELP;
                        uRet = (UINT)Browse(hDlg, szFileName, NULL, MAX_PATH,
                                            IDS_OCX_FILTERS, dwOfnFlags, ID_BROWSE_ADDCONTROL , (LPOFNHOOKPROC)HookDlgProc);
                    }
                    
                    if (0 != uRet)
                    {
                        // try to register the control DLL
                        HINSTANCE hInst = LoadLibrary(szFileName);
                        if (hInst == NULL)
                        {
                            PopupMessage(hDlg, IDS_ADDCONTROL, IDS_CANNOTLOADOCX,
                                         MB_OK | MB_ICONEXCLAMATION);
                            break;
                        }
                        
                        HRESULT (FAR STDAPICALLTYPE* lpfn)(void);
                        (FARPROC&)lpfn = GetProcAddress(hInst, "DllRegisterServer");
                        if (lpfn == NULL)
                        {
                            PopupMessage(hDlg, IDS_ADDCONTROL, IDS_NODLLREGISTERSERVER,
                                         MB_OK | MB_ICONEXCLAMATION);
                            FreeLibrary(hInst);
                            break;
                        }
                        
                        if (FAILED((*lpfn)()))
                        {
                            PopupMessage(hDlg, IDS_ADDCONTROL, IDS_DLLREGISTERFAILED,
                                         MB_OK | MB_ICONEXCLAMATION);
                            FreeLibrary(hInst);
                            break;
                        }
                        
                        // cleanup the DLL from memory
                        FreeLibrary(hInst);
                        
                        // registered successfully -- refill the list box
                        lpIO->bControlListFilled = FALSE;
                        lpIO->bObjectListFilled = FALSE;
                        URefillClassList(hDlg, lpIO);
                    }
                }
                break;

            case IDOK:
                {
                    if ((HWND)lParam != GetFocus())
                        SetFocus((HWND)lParam);
                    
                    // If the file name is clean (already validated), or
                    // if Create New is selected, then we can skip this part.
                    
                    if ((lpIO->dwFlags & IOF_SELECTCREATEFROMFILE) &&
                        lpIO->fFileDirty)
                    {
                        if (FValidateInsertFile(hDlg, TRUE, &lpIO->nErrCode))
                        {
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = TRUE;
                            UpdateClassIcon(hDlg, lpIO, NULL);
                            UpdateClassType(hDlg, lpIO, TRUE);
                        }
                        else  // filename is invalid - set focus back to ec
                        {
                            HWND hWnd;
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = FALSE;
                            hWnd = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                            SetFocus(hWnd);
                            SendMessage(hWnd, EM_SETSEL, 0, -1);
                            UpdateClassType(hDlg, lpIO, FALSE);
                        }
                        return TRUE;  // eat this message
                    }
                    else if ((lpIO->dwFlags & IOF_SELECTCREATEFROMFILE) &&
                             !lpIO->fFileValid)
                    {
                        // filename is invalid - set focus back to ec
                        HWND hWnd;
                        TCHAR szFile[MAX_PATH];
                        
                        if (0 != GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY,
                                                szFile, MAX_PATH))
                        {
                            OpenFileError(hDlg, lpIO->nErrCode, szFile);
                        }
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = FALSE;
                        hWnd = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                        SetFocus(hWnd);
                        SendMessage(hWnd, EM_SETSEL, 0, -1);
                        UpdateClassType(hDlg, lpIO, FALSE);
                        return TRUE;  // eat this message
                    }
                    
                    // Copy the necessary information back to the original struct
                    LPOLEUIINSERTOBJECT lpOIO = lpIO->lpOIO;
                    lpOIO->dwFlags = lpIO->dwFlags;
                    
                    if (lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
                    {
                        HWND hListBox = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                        UINT iCurSel = (UINT)SendMessage(hListBox, LB_GETCURSEL, 0, 0);
                        
                        if (lpIO->dwFlags & IOF_CHECKDISPLAYASICON)
                        {
                            lpOIO->hMetaPict=(HGLOBAL)SendMessage(hListBox,
                                                                  LB_GETITEMDATA, iCurSel, 0L);
                            
                            /*
                             * Set the item data to 0 here so that the cleanup
                             * code doesn't delete the metafile.
                             */
                            SendMessage(hListBox, LB_SETITEMDATA, iCurSel, 0L);
                        }
                        else
                            lpOIO->hMetaPict = (HGLOBAL)NULL;
                        
                        TCHAR szBuffer[OLEUI_CCHKEYMAX+OLEUI_CCHCLSIDSTRING];
                        SendMessage(hListBox, LB_GETTEXT, iCurSel, (LPARAM)szBuffer);
                        
                        LPTSTR lpszCLSID = PointerToNthField(szBuffer, 2, '\t');
                        CLSIDFromString(lpszCLSID, &lpOIO->clsid);
                    }
                    else  // IOF_SELECTCREATEFROMFILE
                    {
                        if (lpIO->dwFlags & IOF_CHECKDISPLAYASICON)
                        {
                            // get metafile here
                            lpOIO->hMetaPict = (HGLOBAL)SendDlgItemMessage(
                                hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                        }
                        else
                            lpOIO->hMetaPict = (HGLOBAL)NULL;
                    }
                    
                    GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY,
                                   lpIO->szFile, lpOIO->cchFile);
                    lstrcpyn(lpOIO->lpszFile, lpIO->szFile, lpOIO->cchFile);
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                }
                break;
                
            case IDCANCEL:
                SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                break;
                
            case IDC_OLEUIHELP:
                PostMessage(lpIO->lpOIO->hWndOwner, uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_INSERTOBJECT, 0));
                break;
            }
            break;
            
        default:
            if (iMsg == lpIO->nBrowseHelpID)
            {
                PostMessage(lpIO->lpOIO->hWndOwner, uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_INSERTFILEBROWSE, 0));
            }
            if (iMsg == uMsgBrowseOFN &&
                lpIO->lpOIO && lpIO->lpOIO->hWndOwner)
            {
                SendMessage(lpIO->lpOIO->hWndOwner, uMsgBrowseOFN, wParam, lParam);
            }
            break;
        }

        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckButton
//
//  Synopsis:   Handles checking the radio buttons
//
//  Arguments:  [hDlg] - dialog handle
//              [iID]  - ID of the button to check
//
//  Returns:    nothing
//
//  History:    1-19-95   stevebl   Created
//
//  Notes:      Used in place of CheckRadioButtons to avoid a GP fault under
//              win32s that arises from IDC_IO_CREATENEW, IDC_IO_CREATEFROMFILE
//              and IDC_IO_INSERTCONTROL not being contiguous.
//
//----------------------------------------------------------------------------

void CheckButton(HWND hDlg, int iID)
{
    CheckDlgButton(hDlg, IDC_IO_CREATENEW, iID == IDC_IO_CREATENEW ? 1 : 0);
    CheckDlgButton(hDlg, IDC_IO_CREATEFROMFILE, iID == IDC_IO_CREATEFROMFILE ? 1 : 0);
    CheckDlgButton(hDlg, IDC_IO_INSERTCONTROL, iID == IDC_IO_INSERTCONTROL ? 1 : 0);
}


/*
 * FInsertObjectInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Insert Object dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FInsertObjectInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPINSERTOBJECT lpIO = (LPINSERTOBJECT)LpvStandardInit(hDlg, sizeof(INSERTOBJECT), &hFont);

        // PvStandardInit send a termination to us already.
        if (NULL == lpIO)
                return FALSE;

        LPOLEUIINSERTOBJECT lpOIO = (LPOLEUIINSERTOBJECT)lParam;

        // Save the original pointer and copy necessary information.
        lpIO->lpOIO = lpOIO;
        lpIO->nIDD = IDD_INSERTOBJECT;
        lpIO->dwFlags = lpOIO->dwFlags;
        lpIO->clsid = lpOIO->clsid;

        if ((lpOIO->lpszFile) && ('\0' != *lpOIO->lpszFile))
                lstrcpyn(lpIO->szFile, lpOIO->lpszFile, MAX_PATH);
        else
                *(lpIO->szFile) = '\0';

        lpIO->hMetaPictFile = (HGLOBAL)NULL;

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                SendDlgItemMessage(hDlg, IDC_IO_RESULTTEXT,  WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_IO_FILETYPE,  WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Initilize the file name display to cwd if we don't have any name.
        if ('\0' == *(lpIO->szFile))
        {
                TCHAR szCurDir[MAX_PATH];
                int nLen;
                GetCurrentDirectory(MAX_PATH, szCurDir);
                nLen = lstrlen(szCurDir);
                if (nLen != 0 && szCurDir[nLen-1] != '\\')
                        lstrcat(szCurDir, _T("\\"));
                SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szCurDir);
                lpIO->fFileDirty = TRUE;  // cwd is not a valid filename
        }
        else
        {
                SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, lpIO->szFile);
                if (FValidateInsertFile(hDlg, FALSE, &lpIO->nErrCode))
                {
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = TRUE;
                }
                else
                {
                        lpIO->fFileDirty = TRUE;
                        lpIO->fFileValid = FALSE;
                }
        }

        // Initialize radio button and related controls
        if (lpIO->dwFlags & IOF_CHECKDISPLAYASICON)
        {
            if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                    lpIO->fAsIconNew = TRUE;
            else
                    lpIO->fAsIconFile = TRUE;
        }
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                CheckButton(hDlg, IDC_IO_CREATENEW);
        if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
                CheckButton(hDlg, IDC_IO_CREATEFROMFILE);
        if (lpIO->dwFlags & IOF_SELECTCREATECONTROL)
                CheckButton(hDlg, IDC_IO_INSERTCONTROL);
        CheckDlgButton(hDlg, IDC_IO_LINKFILE, (BOOL)(0L != (lpIO->dwFlags & IOF_CHECKLINK)));

        lpIO->dwFlags &=
                ~(IOF_SELECTCREATENEW|IOF_SELECTCREATEFROMFILE|IOF_SELECTCREATECONTROL);
        FToggleObjectSource(hDlg, lpIO, lpOIO->dwFlags &
                (IOF_SELECTCREATENEW|IOF_SELECTCREATEFROMFILE|IOF_SELECTCREATECONTROL));

        // Show or hide the help button
        if (!(lpIO->dwFlags & IOF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Show or hide the Change icon button
        if (lpIO->dwFlags & IOF_HIDECHANGEICON)
                DestroyWindow(GetDlgItem(hDlg, IDC_IO_CHANGEICON));

        // Hide Insert Control button if necessary
        if (!(lpIO->dwFlags & IOF_SHOWINSERTCONTROL))
                StandardShowDlgItem(hDlg, IDC_IO_INSERTCONTROL, SW_HIDE);

        // Initialize the result display
        UpdateClassIcon(hDlg, lpIO, GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
        SetInsertObjectResults(hDlg, lpIO);

        // Change the caption
        if (NULL!=lpOIO->lpszCaption)
                SetWindowText(hDlg, lpOIO->lpszCaption);

        // Hide all DisplayAsIcon related controls if it should be disabled
        if (lpIO->dwFlags & IOF_DISABLEDISPLAYASICON)
        {
                StandardShowDlgItem(hDlg, IDC_IO_DISPLAYASICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_IO_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_IO_ICONDISPLAY, SW_HIDE);
        }

        lpIO->nBrowseHelpID = RegisterWindowMessage(HELPMSGSTRING);

        // All Done:  call the hook with lCustData
        UStandardHook(lpIO, hDlg, WM_INITDIALOG, wParam, lpOIO->lCustData);

        /*
         * We either set focus to the listbox or the edit control.  In either
         * case we don't want Windows to do any SetFocus, so we return FALSE.
         */
        return FALSE;
}

/*
 * URefillClassList
 *
 * Purpose:
 *  Fills the class list box with names as appropriate for the current
 *  flags.  This function is called when the user changes the flags
 *  via the "exclusion" radio buttons.
 *
 *  Note that this function removes any prior contents of the listbox.
 *
 * Parameters:
 *  hDlg                HWND to the dialog box.
 *  lpIO                        pointer to LPINSERTOBJECT structure
 *
 * Return Value:
 *  LRESULT            Number of strings added to the listbox, -1 on failure.
 */
LRESULT URefillClassList(HWND hDlg, LPINSERTOBJECT lpIO)
{
        OleDbgAssert(lpIO->dwFlags & (IOF_SELECTCREATECONTROL|IOF_SELECTCREATENEW));

        // always the same dialog ID because they are swapped
        HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);

        // determine if already filled
        BOOL bFilled;
        if (lpIO->dwFlags & IOF_SELECTCREATECONTROL)
                bFilled = lpIO->bControlListFilled;
        else
                bFilled = lpIO->bObjectListFilled;

        if (!bFilled)
        {
                // fill the list
                LPOLEUIINSERTOBJECT lpOIO = lpIO->lpOIO;
                UINT uResult = UFillClassList(hList, lpOIO->cClsidExclude, lpOIO->lpClsidExclude,
                        (BOOL)(lpIO->dwFlags & IOF_VERIFYSERVERSEXIST),
                        (lpIO->dwFlags & IOF_SELECTCREATECONTROL));

                // mark the list as filled
                if (lpIO->dwFlags & IOF_SELECTCREATECONTROL)
                        lpIO->bControlListFilled = TRUE;
                else
                        lpIO->bObjectListFilled = TRUE;
        }

        // return number of items now in the list
        return SendMessage(hList, LB_GETCOUNT, 0, 0);
}


/*
 * UFillClassList
 *
 * Purpose:
 *  Enumerates available OLE object classes from the registration
 *  database and fills a listbox with those names.
 *
 *  Note that this function removes any prior contents of the listbox.
 *
 * Parameters:
 *  hList           HWND to the listbox to fill.
 *  cIDEx           UINT number of CLSIDs to exclude in lpIDEx
 *  lpIDEx          LPCLSID to CLSIDs to leave out of the listbox.
 *  fVerify         BOOL indicating if we are to validate existence of
 *                  servers before putting them in the list.
 *
 * Return Value:
 *  UINT            Number of strings added to the listbox, -1 on failure.
 */

UINT UFillClassList(HWND hList, UINT cIDEx, LPCLSID lpIDEx, BOOL fVerify,
        BOOL fExcludeObjects)
{
    OleDbgAssert(hList != NULL);

    // Set the tab width in the list to push all the tabs off the side.
    RECT rc;
    GetClientRect(hList, &rc);
    DWORD dw = GetDialogBaseUnits();
    rc.right =(8*rc.right)/LOWORD(dw);  //Convert pixels to 2x dlg units.
    SendMessage(hList, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&rc.right);

    // Clean out the existing strings.
    SendMessage(hList, LB_RESETCONTENT, 0, 0L);
    UINT cStrings = 0;

#if USE_STRING_CACHE==1
    if (gInsObjStringCache.OKToUse() && gInsObjStringCache.IsUptodate())
    {
        // IsUptodate returns false if the cache is not yet populated
        // or if any CLSID key changed in the registry since the last
        // time the cache was populated.
        
        LPCTSTR lpStr;
        // Reset enumerator in the cache.
        gInsObjStringCache.ResetEnumerator();
        while ( (lpStr = gInsObjStringCache.NextString()) != NULL)
        {
            SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)lpStr);
            cStrings++;
        }

    }
    else
    {
        // Setup the cache if it was successfully initialized and 
        // there were no errors in a previous use.
        if (gInsObjStringCache.OKToUse())
        {
            // Clear the string counter and enumerator.
            // We will fill up the cache with strings in this round.
            gInsObjStringCache.FlushCache(); 
        }
#endif
        LPTSTR pszExec = (LPTSTR)OleStdMalloc(OLEUI_CCHKEYMAX_SIZE*4);
        if (NULL == pszExec)
            return (UINT)-1;

        LPTSTR pszClass = pszExec+OLEUI_CCHKEYMAX;
        LPTSTR pszKey = pszClass+OLEUI_CCHKEYMAX;

        // Open up the root key.
        HKEY hKey;
        LONG lRet = OpenClassesRootKey(NULL, &hKey);
        if ((LONG)ERROR_SUCCESS!=lRet)
        {
            OleStdFree((LPVOID)pszExec);
            return (UINT)-1;
        }

        // We will now loop over all ProgIDs and add candidates that
        // pass various insertable tests to the ListBox one by one.
        while (TRUE)
        {
            // assume not yet (for handling of OLE1.0 compat case)
            BOOL bHaveCLSID = FALSE;
            LPTSTR pszID = pszKey+OLEUI_CCHKEYMAX;

            lRet = RegEnumKey(hKey, cStrings++, pszClass, OLEUI_CCHKEYMAX_SIZE);
            if ((LONG)ERROR_SUCCESS != lRet)
                    break;
            if (!iswalpha(pszClass[0])) 
            {
                // avoids looking into ".ext" type entries under HKCR
                continue;
            }

            // Cheat on lstrcat by using lstrcpy after this string, saving time
            UINT cch = lstrlen(pszClass);

            // Check for \NotInsertable. If this is found then this overrides
            // all other keys; this class will NOT be added to the InsertObject
            // list.

            lstrcpy(pszClass+cch, TEXT("\\NotInsertable"));
            HKEY hKeyTemp = NULL;
            lRet = RegOpenKey(hKey, pszClass, &hKeyTemp);
            if (hKeyTemp != NULL)
                RegCloseKey(hKeyTemp);

            if ((LONG)ERROR_SUCCESS == lRet)
                continue;    // NotInsertable IS found--skip this class

            // check if ProgId says "Insertable"
            lstrcpy(pszClass+cch, TEXT("\\Insertable"));
            hKeyTemp = NULL;
            lRet = RegOpenKey(hKey, pszClass, &hKeyTemp);
            if (hKeyTemp != NULL)
                RegCloseKey(hKeyTemp);

            if (lRet == ERROR_SUCCESS || fExcludeObjects)
            {
                // ProgId says insertable (=> can't be OLE 1.0)
                // See if we are displaying Objects or Controls

                // Check for CLSID

                lstrcpy(pszClass+cch, TEXT("\\CLSID"));

                dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, pszClass, pszID, (LONG*)&dw);
                if ((LONG)ERROR_SUCCESS != lRet)
                    continue;   // CLSID subkey not found
                bHaveCLSID = TRUE;

                // CLSID\ is 6, dw contains pszID length.
                cch = 6 + ((UINT)dw/sizeof(TCHAR)) - 1;
                lstrcpy(pszExec, TEXT("CLSID\\"));
                lstrcpy(pszExec+6, pszID);


                //  fExcludeObjects is TRUE for the Insert Control box.
                //  It's FALSE for the Insert Object box.

                lstrcpy(pszExec+cch, TEXT("\\Control"));
                hKeyTemp = NULL;
                lRet = RegOpenKey(hKey, pszExec, &hKeyTemp);
                if (hKeyTemp != NULL)
                    RegCloseKey(hKeyTemp);

                if (!fExcludeObjects)
                {
                    // We are listing Objects.
                    if (lRet == ERROR_SUCCESS)
                    {   
                        // this is a control
                        continue;
                    }
                }
                else 
                {    
                    // We are listing controls
                    if (lRet != ERROR_SUCCESS)
                    {
                        // This is an Object
                        continue;
                    }
                    // Some generous soul at some point of time in the past
                    // decided that for controls it is OK to have the 
                    // Inertable key on the clsid too. So we have to perform 
                    // that additional check before we decide if the control
                    // entry should be listed or not.
                    
                    lstrcpy(pszExec+cch, TEXT("\\Insertable"));
                    hKeyTemp = NULL;
                    lRet = RegOpenKey(hKey, pszExec, &hKeyTemp);
                    if (hKeyTemp != NULL)
                        RegCloseKey(hKeyTemp);
                    if ((LONG)ERROR_SUCCESS != lRet)
                        continue;
                }

                
                // This is beginning to look like a probable list candidate

                // Check \LocalServer32, LocalServer, and \InprocServer
                // if we were requested to (IOF_VERIFYSERVERSEXIST)
                if (fVerify)
                {
                    // Try LocalServer32
                    lstrcpy(pszExec+cch, TEXT("\\LocalServer32"));
                    dw = OLEUI_CCHKEYMAX_SIZE;
                    lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                    if ((LONG)ERROR_SUCCESS != lRet)
                    {
                        // Try LocalServer
                        lstrcpy(pszExec+cch, TEXT("\\LocalServer"));
                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                        if ((LONG)ERROR_SUCCESS != lRet)
                        {
                            // Try InprocServer32
                            lstrcpy(pszExec+cch, TEXT("\\InProcServer32"));
                            dw = OLEUI_CCHKEYMAX_SIZE;
                            lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                            if ((LONG)ERROR_SUCCESS != lRet)
                            {
                                // Try InprocServer
                                lstrcpy(pszExec+cch, TEXT("\\InProcServer"));
                                dw = OLEUI_CCHKEYMAX_SIZE;
                                lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                                if ((LONG)ERROR_SUCCESS != lRet)
                                    continue;
                            }
                        }
                    }

                    if (!DoesFileExist(pszKey, OLEUI_CCHKEYMAX))
                        continue;

                } //fVerify

                // Get the readable name for the server.
                // We'll needed it for the listbox.

                *(pszExec+cch) = 0;   //Remove \\*Server

                dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                if ((LONG)ERROR_SUCCESS!=lRet)
                    continue;

            }
            else
            {
                // We did not see an "Insertable" under ProgId, can
                // this be an OLE 1.0 time server entry?

                // Check for a \protocol\StdFileEditing\server entry.
                lstrcpy(pszClass+cch, TEXT("\\protocol\\StdFileEditing\\server"));
                DWORD dwTemp = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, pszClass, pszKey, (LONG*)&dwTemp);
                if ((LONG)ERROR_SUCCESS == lRet)
                {
                    // This is not a control
                    // skip it if excluding non-controls
                    if (fExcludeObjects)
                        continue;

                    // Check if the EXE actually exists.  
                    // (By default we don't do this for speed.
                    // If an application wants to, it must provide 
                    // IOF_VERIFYSERVERSEXIST flag in the request)

                    if (fVerify && !DoesFileExist(pszKey, OLEUI_CCHKEYMAX))
                        continue;

                    // get readable class name
                    dwTemp = OLEUI_CCHKEYMAX_SIZE;
                    *(pszClass+cch) = 0;  // set back to rootkey
                    lRet=RegQueryValue(hKey, pszClass, pszKey, (LONG*)&dwTemp);

                    // attempt to get clsid directly from registry
                    lstrcpy(pszClass+cch, TEXT("\\CLSID"));
                    dwTemp = OLEUI_CCHKEYMAX_SIZE;
                    lRet = RegQueryValue(hKey, pszClass, pszID, (LONG*)&dwTemp);
                    if ((LONG)ERROR_SUCCESS == lRet)
                        bHaveCLSID = TRUE;
                    *(pszClass+cch) = 0;    // set back to rootkey
                }
                else 
                {   
                    // This is not OLE 1.0 either!
                    continue;
                }
            }

            // At this point we have an insertable candidate.
            // or OLE 1.0 time.

            // get CLSID to add to listbox.
            CLSID clsid;
            if (!bHaveCLSID)
            {
                if (FAILED(CLSIDFromProgID(pszClass, &clsid)))
                    continue;
                if (FAILED(StringFromCLSID(clsid, &pszID)))
                    continue;
            }
            else
            {
                if (FAILED(CLSIDFromString(pszID, &clsid)))
                    continue;
            }

            // ##### WARNING #####: using 'continue' after this point 
            // would leak memory so don't use it!

            // check if this CLSID is in the exclusion list.
            BOOL fExclude = FALSE;
            for (UINT i=0; i < cIDEx; i++)
            {
                if (IsEqualCLSID(clsid, lpIDEx[i]))
                {
                    fExclude=TRUE;
                    break;
                }
            }

            // don't add objects without names
            if (lstrlen(pszKey) > 0 && !fExclude)
            {
                // We got through all the conditions, add the string.
                if (LB_ERR == SendMessage(hList, LB_FINDSTRING, 0, (LPARAM)pszKey))
                {
                    pszKey[cch = lstrlen(pszKey)] = '\t';
                    lstrcpy(pszKey+cch+1, pszID);
                    SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)pszKey);
#if USE_STRING_CACHE==1
                    if (gInsObjStringCache.OKToUse())
                    {   
                        if (!gInsObjStringCache.AddString(pszKey))
                        {
                            // Adding the string failed due to some reason
                            OleDbgAssert(!"Failure adding string");
                            
                            // A failed Add() should mark the    
                            // Cache not OK to use any more.
                            OleDbgAssert(!gInsObjStringCache.OKToUse())
                        }
                    }
#endif
                }
            }

            if (!bHaveCLSID)
                OleStdFree((LPVOID)pszID);
        }   // While (TRUE)
        RegCloseKey(hKey);
        OleStdFree((LPVOID)pszExec);

#if USE_STRING_CACHE
    }
#endif

    // Select the first item by default
    SendMessage(hList, LB_SETCURSEL, 0, 0L);

    return cStrings;
}

/*
 * FToggleObjectSource
 *
 * Purpose:
 *  Handles enabling, disabling, showing, and flag manipulation when the
 *  user changes between Create New, Insert File, and Link File in the
 *  Insert Object dialog.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpIO            LPINSERTOBJECT pointing to the dialog structure
 *  dwOption        DWORD flag indicating the option just selected:
 *                  IOF_SELECTCREATENEW or IOF_SELECTCREATEFROMFILE
 *
 * Return Value:
 *  BOOL            TRUE if the option was already selected, FALSE otherwise.
 */

BOOL FToggleObjectSource(HWND hDlg, LPINSERTOBJECT lpIO, DWORD dwOption)
{
        // Skip all of this if we're already selected.
        if (lpIO->dwFlags & dwOption)
                return TRUE;

#ifdef USE_STRING_CACHE
        // if we're using string cache, we need to flush the cache if
        // the list previously displayed was of different type

        if(IOF_SELECTCREATECONTROL == dwOption)
        {
            if(g_dwOldListType == IOF_SELECTCREATENEW)
                gInsObjStringCache.FlushCache();
            g_dwOldListType = IOF_SELECTCREATECONTROL;
        }
        else if(IOF_SELECTCREATENEW == dwOption)
        {
            if(g_dwOldListType == IOF_SELECTCREATECONTROL)
                gInsObjStringCache.FlushCache(); 
            g_dwOldListType = IOF_SELECTCREATENEW;
        }
#endif


        // if we're switching from "from file" to "create new" and we've got
        // an icon for "from file", then we need to save it so that we can
        // show it if the user reselects "from file".

        if ((IOF_SELECTCREATENEW == dwOption) &&
                (lpIO->dwFlags & IOF_CHECKDISPLAYASICON))
        {
                lpIO->hMetaPictFile = (HGLOBAL)SendDlgItemMessage(hDlg,
                        IDC_IO_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
        }

        /*
         * 1.  Change the Display As Icon checked state to reflect the
         *     selection for this option, stored in the fAsIcon* flags.
         */
        BOOL fTemp;
        if (IOF_SELECTCREATENEW == dwOption)
                fTemp = lpIO->fAsIconNew;
        else if (IOF_SELECTCREATEFROMFILE == dwOption)
                fTemp = lpIO->fAsIconFile;
        else
                fTemp = FALSE;

        if (fTemp)
                lpIO->dwFlags |= IOF_CHECKDISPLAYASICON;
        else
                lpIO->dwFlags &= ~IOF_CHECKDISPLAYASICON;

        CheckDlgButton(hDlg, IDC_IO_DISPLAYASICON,
                 (BOOL)(0L!=(lpIO->dwFlags & IOF_CHECKDISPLAYASICON)));

        EnableChangeIconButton(hDlg, fTemp);

        /*
         *      Display Icon:  Enabled on Create New or on Create from File if
         *     there is a selected file.
         */
        if (IOF_SELECTCREATENEW == dwOption)
                fTemp = TRUE;
        else if (IOF_SELECTCREATEFROMFILE == dwOption)
                fTemp = lpIO->fFileSelected;
        else
                fTemp = FALSE;

        if (IOF_SELECTCREATECONTROL == dwOption)
                StandardShowDlgItem(hDlg, IDC_IO_DISPLAYASICON, SW_HIDE);
        else if (!(lpIO->dwFlags & IOF_DISABLEDISPLAYASICON))
                StandardShowDlgItem(hDlg, IDC_IO_DISPLAYASICON, SW_SHOW);

        StandardEnableDlgItem(hDlg, IDC_IO_DISPLAYASICON, fTemp);

        // OK and Link follow the same enabling as Display As Icon.
        StandardEnableDlgItem(hDlg, IDOK,
                fTemp || IOF_SELECTCREATECONTROL == dwOption);
        StandardEnableDlgItem(hDlg, IDC_IO_LINKFILE, fTemp);

        // Enable Browse... when Create from File is selected.
        fTemp = (IOF_SELECTCREATEFROMFILE != dwOption);
        StandardEnableDlgItem(hDlg, IDC_IO_FILE, !fTemp);
        StandardEnableDlgItem(hDlg, IDC_IO_FILEDISPLAY, !fTemp);

        // Switch Object Type & Control Type listboxes if necessary
        HWND hWnd1 = NULL, hWnd2 = NULL;
        if (lpIO->bControlListActive && IOF_SELECTCREATENEW == dwOption)
        {
                hWnd1 = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                hWnd2 = GetDlgItem(hDlg, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd1, GWL_ID, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd2, GWL_ID, IDC_IO_OBJECTTYPELIST);
                lpIO->bControlListActive = FALSE;
        }
        else if (!lpIO->bControlListActive && IOF_SELECTCREATECONTROL == dwOption)
        {
                hWnd1 = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                hWnd2 = GetDlgItem(hDlg, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd1, GWL_ID, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd2, GWL_ID, IDC_IO_OBJECTTYPELIST);
                lpIO->bControlListActive = TRUE;
        }

        // Clear out any existing selection flags and set the new one
        DWORD dwTemp = IOF_SELECTCREATENEW | IOF_SELECTCREATEFROMFILE |
                IOF_SELECTCREATECONTROL;
        lpIO->dwFlags = (lpIO->dwFlags & ~dwTemp) | dwOption;

        if (dwOption & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
        {
                // refill class list box if necessary
                if ((lpIO->bControlListActive && !lpIO->bControlListFilled) ||
                        (!lpIO->bControlListActive && !lpIO->bObjectListFilled))
                {
                        URefillClassList(hDlg, lpIO);
                }
        }

        if (hWnd1 != NULL && hWnd2 != NULL)
        {
                ShowWindow(hWnd1, SW_HIDE);
                ShowWindow(hWnd2, SW_SHOW);
        }

        /*
         * Switch between Object Type listbox on Create New and
         *              file buttons on others.
         */
        UINT uTemp = (fTemp) ? SW_SHOWNORMAL : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_IO_OBJECTTYPELIST, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_OBJECTTYPETEXT, uTemp);

        uTemp = (fTemp) ? SW_HIDE : SW_SHOWNORMAL;
        StandardShowDlgItem(hDlg, IDC_IO_FILETEXT, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_FILETYPE, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_FILEDISPLAY, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_FILE, uTemp);

        // Link is always hidden if IOF_DISABLELINK is set.
        if (IOF_DISABLELINK & lpIO->dwFlags)
                uTemp = SW_HIDE;

        StandardShowDlgItem(hDlg, IDC_IO_LINKFILE, uTemp);  //last use of uTemp

        // Remove add button when not in Insert control mode
        uTemp = (IOF_SELECTCREATECONTROL == dwOption) ? SW_SHOW : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_IO_ADDCONTROL, uTemp);

        /*
         * Show or hide controls as appropriate.  Do the icon
         * display last because it will take some time to repaint.
         * If we do it first then the dialog looks too sluggish.
         */

        int i = (lpIO->dwFlags & IOF_CHECKDISPLAYASICON) ? SW_SHOWNORMAL : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_IO_CHANGEICON, i);
        StandardShowDlgItem(hDlg, IDC_IO_ICONDISPLAY, i);
        EnableChangeIconButton(hDlg, SW_SHOWNORMAL == i);

        // Change result display
        SetInsertObjectResults(hDlg, lpIO);

        /*
         *      For Create New, twiddle the listbox to think we selected it
         *  so it updates the icon from the object type. set the focus
         *  to the list box.
         *
         *  For Insert or Link file, set the focus to the filename button
         *  and update the icon if necessary.
         */
        if (fTemp)
        {
                UpdateClassIcon(hDlg, lpIO, GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
                SetFocus(GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
        }
        else
        {
                if (lpIO->fAsIconFile && (NULL != lpIO->hMetaPictFile) )
                {
                        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGESET, 0,
                                (LPARAM)lpIO->hMetaPictFile);
                        lpIO->hMetaPictFile = 0;
                }
                else
                {
                        UpdateClassIcon(hDlg, lpIO, NULL);
                }
                SetFocus(GetDlgItem(hDlg, IDC_IO_FILE));
        }

        return FALSE;
}


/*
 * UpdateClassType
 *
 * Purpose:
 *  Updates static text control to reflect current file type.  Assumes
 *  a valid filename.
 *
 * Parameters
 *  hDlg            HWND of the dialog box.
 *  lpIO            LPINSERTOBJECT pointing to the dialog structure
 *  fSet            TRUE to set the text, FALSE to explicitly clear it
 *
 * Return Value:
 *  None
 */

void UpdateClassType(HWND hDlg, LPINSERTOBJECT lpIO, BOOL fSet)
{
        LPTSTR lpszFileType = NULL;
        if (fSet)
        {
                TCHAR szFileName[MAX_PATH];
                GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFileName, MAX_PATH);

                CLSID clsid;
                if (S_OK == GetClassFile(szFileName, &clsid))
                        OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &lpszFileType);
        }

		if (lpszFileType != NULL)
		{
			SetDlgItemText(hDlg, IDC_IO_FILETYPE, lpszFileType);
			OleStdFree(lpszFileType);
		}
}


/*
 * UpdateClassIcon
 *
 * Purpose:
 *  Handles LBN_SELCHANGE for the Object Type listbox.  On a selection
 *  change, we extract an icon from the server handling the currently
 *  selected object type using the utility function HIconFromClass.
 *  Note that we depend on the behavior of FillClassList to stuff the
 *  object class after a tab in the listbox string that we hide from
 *  view (see WM_INITDIALOG).
 *
 * Parameters
 *  hDlg            HWND of the dialog box.
 *  lpIO            LPINSERTOBJECT pointing to the dialog structure
 *  hList           HWND of the Object Type listbox.
 *
 * Return Value:
 *  None
 */

static void UpdateClassIcon(HWND hDlg, LPINSERTOBJECT lpIO, HWND hList)
{
        // If Display as Icon is not selected, exit
        if (!(lpIO->dwFlags & IOF_CHECKDISPLAYASICON))
                return;

        /*
         * When we change object type selection, get the new icon for that
         * type into our structure and update it in the display.  We use the
         * class in the listbox when Create New is selected or the association
         * with the extension in Create From File.
         */

        DWORD cb = MAX_PATH;
        UINT iSel;
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
        {
                iSel = (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);

                if (LB_ERR==(int)iSel)
                        return;

                // Check to see if we've already got the hMetaPict for this item
                LRESULT dwRet = SendMessage(hList, LB_GETITEMDATA, (WPARAM)iSel, 0L);

                HGLOBAL hMetaPict=(HGLOBAL)dwRet;
                if (hMetaPict)
                {
                        // Yep, we've already got it, so just display it and return.
                        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGESET,
                                0, (LPARAM)hMetaPict);
                        return;
                }
                iSel = (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
                if (LB_ERR==(int)iSel)
                        return;

                // Allocate a string to hold the entire listbox string
                cb = (DWORD)SendMessage(hList, LB_GETTEXTLEN, iSel, 0L);
        }

        LPTSTR pszName = (LPTSTR)OleStdMalloc((cb+1)*sizeof(TCHAR));
        if (NULL == pszName)
                return;
        *pszName = 0;

        // Get the clsid we want.
        HGLOBAL hMetaPict;
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
        {
                // Grab the classname string from the list
                SendMessage(hList, LB_GETTEXT, iSel, (LPARAM)pszName);

                // Set pointer to CLSID (string)
                LPTSTR pszCLSID = PointerToNthField(pszName, 2, '\t');

                // Get CLSID from the string and then accociated icon
                HRESULT hr = CLSIDFromString(pszCLSID, &lpIO->clsid);
                if (FAILED(hr))
                    lpIO->clsid = GUID_NULL;
                hMetaPict = OleGetIconOfClass(lpIO->clsid, NULL, TRUE);
        }

        else
        {
                // Get the class from the filename
                GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, pszName, MAX_PATH);
                hMetaPict = OleGetIconOfFile(pszName,
                        lpIO->dwFlags & IOF_CHECKLINK ? TRUE : FALSE);
        }

        // Replace the current display with this new one.
        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGESET,
                0, (LPARAM)hMetaPict);

        // Enable or disable "Change Icon" button depending on whether
        // we've got a valid filename or not.
        EnableChangeIconButton(hDlg, hMetaPict ? TRUE : FALSE);

        // Save the hMetaPict so that we won't have to re-create
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                SendMessage(hList, LB_SETITEMDATA, (WPARAM)iSel, (LPARAM)hMetaPict);

        OleStdFree(pszName);
}


/*
 * SetInsertObjectResults
 *
 * Purpose:
 *  Centralizes setting of the Result and icon displays in the Insert Object
 *  dialog.  Handles loading the appropriate string from the module's
 *  resources and setting the text, displaying the proper result picture,
 *  and showing the proper icon.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *  lpIO            LPINSERTOBJECT in which we assume that the
 *                  current radiobutton and Display as Icon selections
 *                  are set.  We use the state of those variables to
 *                  determine which string we use.
 *
 * Return Value:
 *  None
 */

void SetInsertObjectResults(HWND hDlg, LPINSERTOBJECT lpIO)
{
        /*
         * We need scratch memory for loading the stringtable string, loading
         * the object type from the listbox, and constructing the final string.
         * We therefore allocate three buffers as large as the maximum message
         * length (512) plus the object type, guaranteeing that we have enough
         * in all cases.
         */
        UINT i = (UINT)SendDlgItemMessage(hDlg, IDC_IO_OBJECTTYPELIST, LB_GETCURSEL, 0, 0L);

        UINT cch = 512;

        if (i != LB_ERR)
        {
            cch += (UINT)SendDlgItemMessage(hDlg, IDC_IO_OBJECTTYPELIST, LB_GETTEXTLEN, i, 0L);
        }

        LPTSTR pszTemp= (LPTSTR)OleStdMalloc((DWORD)(4*cch)*sizeof(TCHAR));
        if (NULL == pszTemp)
                return;

        LPTSTR psz1 = pszTemp;
        LPTSTR psz2 = psz1+cch;
        LPTSTR psz3 = psz2+cch;
        LPTSTR psz4 = psz3+cch;

        BOOL fAsIcon = (0L != (lpIO->dwFlags & IOF_CHECKDISPLAYASICON));
        UINT iImage=0, iString1=0, iString2=0;

        if (lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
        {
                iString1 = fAsIcon ? IDS_IORESULTNEWICON : IDS_IORESULTNEW;
                iString2 = 0;
                iImage   = fAsIcon ? RESULTIMAGE_EMBEDICON : RESULTIMAGE_EMBED;
        }

        if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
        {
                // Pay attention to Link checkbox
                if (lpIO->dwFlags & IOF_CHECKLINK)
                {
                        iString1 = fAsIcon ? IDS_IORESULTLINKFILEICON1 : IDS_IORESULTLINKFILE1;
                        iString2 = fAsIcon ? IDS_IORESULTLINKFILEICON2 : IDS_IORESULTLINKFILE2;
                        iImage =fAsIcon ? RESULTIMAGE_LINKICON : RESULTIMAGE_LINK;
                }
                else
                {
                        iString1 = IDS_IORESULTFROMFILE1;
                        iString2 = fAsIcon ? IDS_IORESULTFROMFILEICON2 : IDS_IORESULTFROMFILE2;
                        iImage =fAsIcon ? RESULTIMAGE_EMBEDICON : RESULTIMAGE_EMBED;
                }
        }

        // Default is an empty string.
        *psz1=0;

        if (0 != LoadString(_g_hOleStdResInst, iString1, psz1, cch))
        {
                // Load second string, if necessary
                if (0 != iString2 &&
                        0 != LoadString(_g_hOleStdResInst, iString2, psz4, cch))
                {
                        lstrcat(psz1, psz4);  // concatenate strings together.
                }

                // In Create New, do the extra step of inserting the object type string
                if (lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
                {
                        if (i == LB_ERR)
                        {
                                SetDlgItemText(hDlg, IDC_IO_RESULTTEXT, NULL);

                                // Change the image.
                                SendDlgItemMessage(hDlg, IDC_IO_RESULTIMAGE, RIM_IMAGESET, RESULTIMAGE_NONE, 0L);

                                OleStdFree((LPVOID)pszTemp);
                                return;
                        }

                        *psz2=NULL;
                        SendDlgItemMessage(hDlg, IDC_IO_OBJECTTYPELIST, LB_GETTEXT, i, (LPARAM)psz2);

                        // Null terminate at any tab (before the classname)
                        LPTSTR pszT = psz2;
                        while (_T('\t') != *pszT && 0 != *pszT)
                                pszT++;
                        OleDbgAssert(pszT < psz3);
                        *pszT=0;

                        // Build the string and point psz1 to it.
                        wsprintf(psz3, psz1, psz2);
                        psz1 = psz3;
                }
        }

        // If LoadString failed, we simply clear out the results (*psz1=0 above)
        SetDlgItemText(hDlg, IDC_IO_RESULTTEXT, psz1);

        // Go change the image and Presto!  There you have it.
        SendDlgItemMessage(hDlg, IDC_IO_RESULTIMAGE, RIM_IMAGESET, iImage, 0L);

        OleStdFree((LPVOID)pszTemp);
}

/*
 * FValidateInsertFile
 *
 * Purpose:
 *  Given a possibly partial pathname from the file edit control,
 *  attempt to locate the file and if found, store the full path
 *  in the edit control IDC_IO_FILEDISPLAY.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box.
 *  fTellUser       BOOL TRUE if function should tell user, FALSE if
 *                   function should validate silently.
 *
 * Return Value:
 *  BOOL            TRUE if the file is acceptable, FALSE otherwise.
 */

BOOL FValidateInsertFile(HWND hDlg, BOOL fTellUser, UINT FAR* lpnErrCode)
{
        *lpnErrCode = 0;

        /*
         * To validate we attempt OpenFile on the string.  If OpenFile
         * fails then we display an error.  If not, OpenFile will store
         * the complete path to that file in the OFSTRUCT which we can
         * then stuff in the edit control.
         */
        TCHAR szFile[MAX_PATH];
        if (0 == GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFile, MAX_PATH))
                return FALSE;   // #4569 : return FALSE when there is no text in ctl

        // if file is currently open (ie. sharing violation) OleCreateFromFile
        // and OleCreateLinkToFile can still succeed; do not consider it an
        // error.
        if (!DoesFileExist(szFile, MAX_PATH))
        {
           *lpnErrCode = ERROR_FILE_NOT_FOUND;
           if (fTellUser)
                   OpenFileError(hDlg, ERROR_FILE_NOT_FOUND, szFile);
           return FALSE;
        }

        // get full pathname, since the file exists
        TCHAR szPath[MAX_PATH];
        LPTSTR lpszDummy;
        GetFullPathName(szFile, sizeof(szPath)/sizeof(TCHAR), szPath, &lpszDummy);
        SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szPath);

        return TRUE;
}


/*
 * InsertObjectCleanup
 *
 * Purpose:
 *  Clears cached icon metafiles from those stored in the listbox.
 *
 * Parameters:
 *  hDlg            HWND of the dialog.
 *
 * Return Value:
 *  None
 */

void InsertObjectCleanup(HWND hDlg)
{
        HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
        UINT iItems= (UINT)SendMessage(hList, LB_GETCOUNT, 0, 0L);
        for (UINT i = 0; i < iItems; i++)
        {
                LRESULT dwRet = SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
                HGLOBAL hMetaPict=(HGLOBAL)dwRet;
                if (hMetaPict)
                        OleUIMetafilePictIconFree(hMetaPict);
        }
}

void EnableChangeIconButton(HWND hDlg, BOOL fEnable)
{

    HRESULT hr = S_OK;

    if(fEnable){

        HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
        int iCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);

        CLSID clsid = {0};

        if (1 == IsDlgButtonChecked(hDlg, IDC_IO_CREATENEW))
        {
            LPTSTR pszString = (LPTSTR)OleStdMalloc(
                OLEUI_CCHKEYMAX_SIZE + OLEUI_CCHCLSIDSTRING_SIZE);

            if(NULL == pszString)
            { 
                fEnable = FALSE;
                goto CLEANUP;
            }
            
            SendMessage(hList, LB_GETTEXT, iCurSel, (LPARAM)pszString);

            if(0 == *pszString)
            { 
                fEnable = FALSE;
                OleStdFree((LPVOID)pszString);
                goto CLEANUP;
            }

            
            LPTSTR pszCLSID = PointerToNthField(pszString, 2, '\t');

            if(NULL == pszCLSID || 0 == *pszCLSID)
            { 
                fEnable = FALSE;
                OleStdFree((LPVOID)pszString);
                goto CLEANUP;
            }

            
            hr = CLSIDFromString(pszCLSID, &clsid);
            OleStdFree((LPVOID)pszString);

            if(FAILED(hr))
            {
                fEnable = FALSE;
            }
        }
        else  // IOF_SELECTCREATEFROMFILE
        {
            TCHAR  szFileName[MAX_PATH] = {0};
            GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFileName, MAX_PATH);
            
                if (S_OK != GetClassFile(szFileName, &clsid))
                {
                    int istrlen = lstrlen(szFileName);
                    LPTSTR lpszExtension = szFileName + istrlen -1;

                    while (lpszExtension > szFileName &&
                           *lpszExtension != '.')
                    {
                        lpszExtension = CharPrev(szFileName, lpszExtension);
                    }

                    *szFileName = 0;

                    GetAssociatedExecutable(lpszExtension, szFileName, sizeof(szFileName)/sizeof(szFileName[0]));

                    if(0 == *szFileName){ 
                        fEnable = FALSE;
                    }
                }
        }
    }

CLEANUP:

    StandardEnableDlgItem(hDlg, IDC_IO_CHANGEICON, fEnable);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\objprop.cpp ===
/*
 * OBJPROP.CPP
 *
 * Implements the OleUIObjectProperties function which invokes the complete
 * Object Properties dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "iconbox.h"
#include "resimage.h"
#include <stddef.h>

OLEDBGDATA

// Internally used structure
typedef struct tagGNRLPROPS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIGNRLPROPS lpOGP;         // Original structure passed.
        UINT            nIDD;                   // IDD of dialog (used for help info)

        CLSID           clsidNew;               // new class ID (if conversion done)

} GNRLPROPS, *PGNRLPROPS, FAR* LPGNRLPROPS;

typedef struct tagVIEWPROPS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIVIEWPROPS lpOVP;         // Original structure passed.
        UINT                    nIDD;           // IDD of dialog (used for help info)

        BOOL                    bIconChanged;
        int                             nCurrentScale;
        BOOL                    bRelativeToOrig;
        DWORD                   dvAspect;

} VIEWPROPS, *PVIEWPROPS, FAR* LPVIEWPROPS;

typedef struct tagLINKPROPS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUILINKPROPS lpOLP;         // Original structure passed.
        UINT            nIDD;                   // IDD of dialog (used for help info)

        DWORD           dwUpdate;               // original update mode
        LPTSTR          lpszDisplayName;// new link source
        ULONG           nFileLength;    // file name part of source

} LINKPROPS, *PLINKPROPS, FAR* LPLINKPROPS;

// Internal function prototypes
// OBJPROP.CPP

/*
 * OleUIObjectProperties
 *
 * Purpose:
 *  Invokes the standard OLE Object Properties dialog box allowing the user
 *  to change General, View, and Link properties of an OLE object.  This
 *  dialog uses the new Windows 95 tabbed dialogs.
 *
 * Parameters:
 *  lpOP            LPOLEUIObjectProperties pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 *
 */

static UINT WINAPI ValidateObjectProperties(LPOLEUIOBJECTPROPS);
static UINT WINAPI PrepareObjectProperties(LPOLEUIOBJECTPROPS);

STDAPI_(UINT) OleUIObjectProperties(LPOLEUIOBJECTPROPS lpOP)
{
#ifdef UNICODE
    return (InternalObjectProperties(lpOP, TRUE));
#else
    return (InternalObjectProperties(lpOP, FALSE));
#endif
}

UINT InternalObjectProperties(LPOLEUIOBJECTPROPS lpOP, BOOL fWide)
{
        // Validate Parameters
        UINT uRet = ValidateObjectProperties(lpOP);
        if (OLEUI_SUCCESS != uRet)
                return uRet;

        if (NULL == lpOP->lpObjInfo)
        {
            return(OLEUI_OPERR_OBJINFOINVALID);
        }

        if (IsBadReadPtr(lpOP->lpObjInfo, sizeof(IOleUIObjInfo)))
        {
            return(OLEUI_OPERR_OBJINFOINVALID);
        }

        if (lpOP->dwFlags & OPF_OBJECTISLINK)
        {
            if (NULL == lpOP->lpLinkInfo)
            {
                return(OLEUI_OPERR_LINKINFOINVALID);
            }

            if (IsBadReadPtr(lpOP->lpLinkInfo, sizeof(IOleUILinkInfo)))
            {
                return(OLEUI_OPERR_LINKINFOINVALID);
            }
        }

        // Fill Missing values in lpPS
        LPPROPSHEETHEADER lpPS = (LPPROPSHEETHEADER)lpOP->lpPS;
        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lpPS->ppsp;
        uRet = PrepareObjectProperties(lpOP);
        if (OLEUI_SUCCESS != uRet)
                return uRet;

        LPTSTR lpszShortType = NULL;
        lpOP->lpObjInfo->GetObjectInfo(lpOP->dwObject, NULL, NULL,
                NULL, &lpszShortType, NULL);
        if (lpszShortType == NULL)
                return OLEUI_ERR_OLEMEMALLOC;

        TCHAR szCaption[256];
        if (lpPS->pszCaption == NULL)
        {
            TCHAR szTemp[256];
            LoadString(_g_hOleStdResInst,
                    (lpOP->dwFlags & OPF_OBJECTISLINK) ?
                            IDS_LINKOBJECTPROPERTIES : IDS_OBJECTPROPERTIES,
                    szTemp, sizeof(szTemp) / sizeof(TCHAR));
            wsprintf(szCaption, szTemp, lpszShortType);
#ifdef UNICODE
            if (!fWide)
            {
                  // We're going to actually call the ANSI version of PropertySheet,
                  // so we need to store the caption as an ANSI string.
                  lstrcpy(szTemp, szCaption);
                  WTOA((char *)szCaption, szTemp, 256);
            }
#endif
            lpPS->pszCaption = szCaption;
        }
        OleStdFree(lpszShortType);

        // Invoke the property sheet
        int nResult = StandardPropertySheet(lpOP->lpPS, fWide);

        // Cleanup any temporary memory allocated during the process
        if (lpPP == NULL)
        {
                OleStdFree((LPVOID)lpOP->lpPS->ppsp);
                lpOP->lpPS->ppsp = NULL;
        }

        // map PropertPage return value to OLEUI_ return code
        if (nResult < 0)
                uRet = OLEUI_OPERR_PROPERTYSHEET;
        else if (nResult == 0)
                uRet = OLEUI_CANCEL;
        else
                uRet = OLEUI_OK;

        return uRet;
}

/////////////////////////////////////////////////////////////////////////////
// Validation code

static UINT WINAPI ValidateGnrlProps(LPOLEUIGNRLPROPS lpGP)
{
        OleDbgAssert(lpGP != NULL);

        if (lpGP->cbStruct != sizeof(OLEUIGNRLPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;
        if (lpGP->lpfnHook && IsBadCodePtr((FARPROC)lpGP->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        return OLEUI_SUCCESS;
}

static UINT WINAPI ValidateViewProps(LPOLEUIVIEWPROPS lpVP)
{
        OleDbgAssert(lpVP != NULL);

        if (lpVP->cbStruct != sizeof(OLEUIVIEWPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;
        if (lpVP->lpfnHook && IsBadCodePtr((FARPROC)lpVP->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        return OLEUI_SUCCESS;
}

static UINT WINAPI ValidateLinkProps(LPOLEUILINKPROPS lpLP)
{
        OleDbgAssert(lpLP != NULL);

        if (lpLP->cbStruct != sizeof(OLEUILINKPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;
        if (lpLP->lpfnHook && IsBadCodePtr((FARPROC)lpLP->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        return OLEUI_SUCCESS;
}

static UINT WINAPI ValidateObjectProperties(LPOLEUIOBJECTPROPS lpOP)
{
        // Validate LPOLEUIOBJECTPROPS lpOP
        if (lpOP == NULL)
                return OLEUI_ERR_STRUCTURENULL;

        if (IsBadWritePtr(lpOP, sizeof(OLEUIOBJECTPROPS)))
                return OLEUI_ERR_STRUCTUREINVALID;

        // Validate cbStruct field of OLEUIOBJECTPROPS
        if (lpOP->cbStruct != sizeof(OLEUIOBJECTPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;

        // Validate "sub" property pointers
        if (lpOP->lpGP == NULL || lpOP->lpVP == NULL ||
                ((lpOP->dwFlags & OPF_OBJECTISLINK) && lpOP->lpLP == NULL))
                return OLEUI_OPERR_SUBPROPNULL;

        if (IsBadWritePtr(lpOP->lpGP, sizeof(OLEUIGNRLPROPS)) ||
                IsBadWritePtr(lpOP->lpVP, sizeof(OLEUIVIEWPROPS)) ||
                ((lpOP->dwFlags & OPF_OBJECTISLINK) &&
                        IsBadWritePtr(lpOP->lpLP, sizeof(OLEUILINKPROPS))))
                return OLEUI_OPERR_SUBPROPINVALID;

        // Validate property sheet data pointers
        LPPROPSHEETHEADER lpPS = lpOP->lpPS;
        if (lpPS == NULL)
                return OLEUI_OPERR_PROPSHEETNULL;

// Size of PROPSHEEDHEADER has changed, meaning that if we check for
// the size of PROPSHEETHEADER as we used to, we will break older code.
        if ( IsBadWritePtr(lpPS, sizeof(DWORD)) )
            return OLEUI_OPERR_PROPSHEETINVALID;

        if (IsBadWritePtr(lpPS, lpPS->dwSize))
            return OLEUI_OPERR_PROPSHEETINVALID;

//        DWORD dwSize = lpPS->dwSize;
//        if (dwSize < sizeof(PROPSHEETHEADER))
//                return OLEUI_ERR_CBSTRUCTINCORRECT;

        // If links specified, validate "sub" link property pointer
        if (lpOP->dwFlags & OPF_OBJECTISLINK)
        {
                if (lpPS->ppsp != NULL && lpPS->nPages < 3)
                        return OLEUI_OPERR_PAGESINCORRECT;
        }
        else
        {
                if (lpPS->ppsp != NULL && lpPS->nPages < 2)
                        return OLEUI_OPERR_PAGESINCORRECT;
        }
// Size of PROPSHEETPAGE has changed, meaning that if we check for
// the size of the new PROPSHEETPAGE we will break old code.
//        if (lpPS->ppsp != NULL &&
//                IsBadWritePtr((PROPSHEETPAGE*)lpPS->ppsp,
//                        lpPS->nPages * sizeof(PROPSHEETPAGE)))
//        {
//                return OLEUI_OPERR_INVALIDPAGES;
//        }

        // not setting PSH_PROPSHEETPAGE is not supported
        if (lpOP->dwFlags & OPF_NOFILLDEFAULT)
        {
                if (!(lpPS->dwFlags & PSH_PROPSHEETPAGE))
                        return OLEUI_OPERR_NOTSUPPORTED;
        }
        else if (lpPS->dwFlags != 0)
        {
                return OLEUI_OPERR_NOTSUPPORTED;
        }

        // Sanity check any pages provided
        LPCPROPSHEETPAGE lpPP = lpPS->ppsp;
        for (UINT nPage = 0; nPage < lpPS->nPages; nPage++)
        {
// Size of PROPSHEETPAGE has changed, meaning that if we check for
// the size of the new PROPSHEETPAGE we will break old code.
//                if (lpPP->dwSize != sizeof(PROPSHEETPAGE))
//                        return OLEUI_ERR_CBSTRUCTINCORRECT;
                if (lpPP->pfnDlgProc != NULL)
                        return OLEUI_OPERR_DLGPROCNOTNULL;
                if (lpPP->lParam != 0)
                        return OLEUI_OPERR_LPARAMNOTZERO;
                lpPP = (LPCPROPSHEETPAGE)((LPBYTE)lpPP+lpPP->dwSize);
        }

        // validate individual prop page structures
        UINT uRet = ValidateGnrlProps(lpOP->lpGP);
        if (uRet != OLEUI_SUCCESS)
                return uRet;
        uRet = ValidateViewProps(lpOP->lpVP);
        if (uRet != OLEUI_SUCCESS)
                return uRet;
        if ((lpOP->dwFlags & OPF_OBJECTISLINK) && lpOP->lpLP != NULL)
        {
                uRet = ValidateLinkProps(lpOP->lpLP);
                if (uRet != OLEUI_SUCCESS)
                        return uRet;
        }

        return OLEUI_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// GnrlPropsDialogProc and helpers

// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, UINT nMax)
{
    NUMBERFMT numberFmt;
    numberFmt.NumDigits = 0;
    numberFmt.LeadingZero = 0;

    TCHAR szSep[5];
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, sizeof(szSep) / sizeof(TCHAR));
    numberFmt.Grouping = Atol(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, sizeof(szSep) / sizeof(TCHAR));
    numberFmt.lpDecimalSep = numberFmt.lpThousandSep = szSep;
    numberFmt.NegativeOrder= 0;

    TCHAR szTemp[64];
    wsprintf(szTemp, TEXT("%lu"), dw);

    GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &numberFmt, pszResult, nMax);
    return pszResult;
}

const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

/* converts numbers into short formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */
LPTSTR ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000)
    {
        wsprintf(szTemp, TEXT("%d"), DWORD(dw64));
        i = 0;
    }
    else
    {
        for (i = 1; i < (sizeof(pwOrders) - 1)
            && dw64 >= 1000L * 1024L; dw64 >>= 10, i++)
            ; /* do nothing */

        wInt = DWORD(dw64 >> 10);
        AddCommas(wInt, szTemp, sizeof(szTemp)/sizeof(TCHAR));
        wLen = lstrlen(szTemp);
        if (wLen < 3)
        {
            wDec = DWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
            // At this point, wDec should be between 0 and 1000
            // we want get the top one (or two) digits.
            wDec /= 10;
            if (wLen == 2)
                wDec /= 10;

            // Note that we need to set the format before getting the
            // intl char.
            lstrcpy(szFormat, TEXT("%02d"));

            szFormat[2] = '0' + 3 - wLen;
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                    szTemp+wLen, sizeof(szTemp)/sizeof(*szTemp)-wLen);
            szTemp[sizeof(szTemp)/sizeof(*szTemp)-1] = 0;

            wLen = lstrlen(szTemp);

            wLen += _snwprintf(szTemp+wLen, sizeof(szTemp)/sizeof(*szTemp)-wLen, szFormat, wDec);
            szTemp[sizeof(szTemp)/sizeof(*szTemp)-1] = 0;
        }
    }

    LoadString(_g_hOleStdResInst, pwOrders[i], szOrder,
               sizeof(szOrder)/sizeof(szOrder[0]));
    wsprintf(szBuf, szOrder, (LPSTR)szTemp);

    return szBuf;
}

LPTSTR WINAPI ShortSizeFormat(DWORD dw, LPTSTR szBuf)
{
        return ShortSizeFormat64((__int64)dw, szBuf);
}

BOOL FGnrlPropsRefresh(HWND hDlg, LPGNRLPROPS lpGP)
{
        // get object information and fill in default fields
        LPOLEUIOBJECTPROPS lpOP = lpGP->lpOGP->lpOP;
        LPOLEUIOBJINFO lpObjInfo = lpOP->lpObjInfo;

        // get object's icon
        HGLOBAL hMetaPict;
        lpObjInfo->GetViewInfo(lpOP->dwObject, &hMetaPict, NULL, NULL);
        if (hMetaPict != NULL)
        {
                HICON hIcon = OleUIMetafilePictExtractIcon(hMetaPict);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTICON, STM_SETICON,
                        (WPARAM)hIcon, 0);
        }
        OleUIMetafilePictIconFree(hMetaPict);

        // get type, short type, location, and size of object
        DWORD dwObjSize;
        LPTSTR lpszLabel = NULL;
        LPTSTR lpszType = NULL;
        LPTSTR lpszShortType = NULL;
        LPTSTR lpszLocation = NULL;
        lpObjInfo->GetObjectInfo(lpOP->dwObject, &dwObjSize, &lpszLabel,
                &lpszType, &lpszShortType, &lpszLocation);

        // set name, type, and size of object
        SetDlgItemText(hDlg, IDC_GP_OBJECTNAME, lpszLabel);
        SetDlgItemText(hDlg, IDC_GP_OBJECTTYPE, lpszType);
        SetDlgItemText(hDlg, IDC_GP_OBJECTLOCATION, lpszLocation);
        TCHAR szTemp[128];
        if (dwObjSize == (DWORD)-1)
        {
                LoadString(_g_hOleStdResInst, IDS_OLE2UIUNKNOWN, szTemp, 64);
                SetDlgItemText(hDlg, IDC_GP_OBJECTSIZE, szTemp);
        }
        else
        {
                // get the master formatting string
                TCHAR szFormat[64];
                LoadString(_g_hOleStdResInst, IDS_OBJECTSIZE, szFormat, 64);

                // format the size in two ways (short, and with commas)
                TCHAR szNum1[20], szNum2[32];
                ShortSizeFormat(dwObjSize, szNum1);
                AddCommas(dwObjSize, szNum2, 32);
                FormatString2(szTemp, szFormat, szNum1, szNum2, sizeof(szTemp)/sizeof(TCHAR));

                // set the control's text
                SetDlgItemText(hDlg, IDC_GP_OBJECTSIZE, szTemp);
        }

        // enable/disable convert button as necessary
        BOOL bEnable = TRUE;
        if (lpOP->dwFlags & (OPF_OBJECTISLINK|OPF_DISABLECONVERT))
                bEnable = FALSE;
        else
        {
                CLSID clsid; WORD wFormat;
                lpObjInfo->GetConvertInfo(lpOP->dwObject, &clsid, &wFormat, NULL, NULL, NULL);
                bEnable = OleUICanConvertOrActivateAs(clsid, FALSE, wFormat);
        }
        StandardEnableDlgItem(hDlg, IDC_GP_CONVERT, bEnable);

        // cleanup temporary info strings
        OleStdFree(lpszLabel);
        OleStdFree(lpszType);
        OleStdFree(lpszShortType);
        OleStdFree(lpszLocation);

        return TRUE;
}

BOOL FGnrlPropsInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPGNRLPROPS lpGP = (LPGNRLPROPS)LpvStandardInit(hDlg, sizeof(GNRLPROPS), &hFont);

        // LpvStandardInit send a termination to us already.
        if (NULL == lpGP)
                return FALSE;

        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lParam;
        LPOLEUIGNRLPROPS lpOGP = (LPOLEUIGNRLPROPS)lpPP->lParam;
        lpGP->lpOGP = lpOGP;
        lpGP->nIDD = IDD_GNRLPROPS;

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTNAME, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTTYPE, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTLOCATION, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTSIZE, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Show or hide the help button
        if (!(lpOGP->lpOP->dwFlags & OPF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Initialize the controls
        FGnrlPropsRefresh(hDlg, lpGP);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpGP, hDlg, WM_INITDIALOG, wParam, lpOGP->lCustData);
        return TRUE;
}

INT_PTR CALLBACK GnrlPropsDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPGNRLPROPS lpGP = (LPGNRLPROPS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return (INT_PTR)uHook;

        // Get pointers to important info
        LPOLEUIGNRLPROPS lpOGP = NULL;
        LPOLEUIOBJECTPROPS lpOP = NULL;
        LPOLEUIOBJINFO lpObjInfo = NULL;
        if (lpGP != NULL)
        {
                lpOGP = lpGP->lpOGP;
                if (lpOGP != NULL)
                {
                        lpObjInfo = lpOGP->lpOP->lpObjInfo;
                        lpOP = lpOGP->lpOP;
                }
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
                FGnrlPropsInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_GP_CONVERT:
                        {
                                if(!lpGP)
                                    return TRUE;

                                // Call up convert dialog to obtain new CLSID
                                OLEUICONVERT cv; memset(&cv, 0, sizeof(cv));
                                cv.cbStruct = sizeof(cv);
                                cv.dwFlags |= CF_CONVERTONLY;
                                if (lpOP->dwFlags & OPF_SHOWHELP)
                                    cv.dwFlags |= CF_SHOWHELPBUTTON;
                                cv.clsidConvertDefault = lpGP->clsidNew;
                                cv.dvAspect = DVASPECT_CONTENT;
                                lpObjInfo->GetObjectInfo(lpOP->dwObject,
                                        NULL, NULL, &cv.lpszUserType, NULL, NULL);
                                lpObjInfo->GetConvertInfo(lpOP->dwObject,
                                        &cv.clsid, &cv.wFormat, &cv.clsidConvertDefault,
                                        &cv.lpClsidExclude, &cv.cClsidExclude);
                                cv.fIsLinkedObject =
                                        (lpOGP->lpOP->dwFlags & OPF_OBJECTISLINK);
                                if (cv.clsidConvertDefault != CLSID_NULL)
                                        cv.dwFlags |= CF_SETCONVERTDEFAULT;
                                cv.hWndOwner = GetParent(GetParent(hDlg));

                                // allow caller to hook the convert structure
                                uHook = UStandardHook(lpGP, hDlg, uMsgConvert, 0, (LPARAM)&cv);
                                if (0 == uHook)
                                {
                                        uHook = (OLEUI_OK == OleUIConvert(&cv));
                                        SetFocus(hDlg);
                                }

                                // check to see dialog results
                                if (uHook != 0 && (cv.dwFlags & CF_SELECTCONVERTTO))
                                {
                                        lpGP->clsidNew = cv.clsidNew;
                                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                                }
                        }
                        return TRUE;
                case IDC_OLEUIHELP:
                        PostMessage(GetParent(GetParent(hDlg)),
                                uMsgHelp,
                                (WPARAM)hDlg,
                                MAKELPARAM(IDD_GNRLPROPS, 0));
                        return TRUE;


                }
                break;

        case PSM_QUERYSIBLINGS:
                if(!lpGP)
                    break;

                SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                switch (wParam)
                {
                case OLEUI_QUERY_GETCLASSID:
                        *(CLSID*)lParam = lpGP->clsidNew;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                        return TRUE;

                case OLEUI_QUERY_LINKBROKEN:
                        FGnrlPropsRefresh(hDlg, lpGP);
                        return TRUE;
                }
                break;

        case WM_NOTIFY:
                switch (((NMHDR*)lParam)->code)
                {
                case PSN_HELP:
                    PostMessage(GetParent(GetParent(hDlg)), uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_GNRLPROPS, 0));
                    break;
                case PSN_APPLY:
                        if(!lpGP)
                            return TRUE;

                        // apply changes if changes made
                        if (lpGP->clsidNew != CLSID_NULL)
                        {
                                // convert the object -- fail the apply if convert fails
                                if (NOERROR != lpObjInfo->ConvertObject(lpOP->dwObject,
                                        lpGP->clsidNew))
                                {
                                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                                        return TRUE;
                                }
                                lpGP->clsidNew = CLSID_NULL;
                        }
                        SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                        PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        return TRUE;
                }
                break;

        case WM_DESTROY:
                {
                        HICON hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_GP_OBJECTICON,
                                STM_GETICON, 0, 0);
                        if (hIcon != NULL)
                                DestroyIcon(hIcon);
                        StandardCleanup((PVOID)lpGP, hDlg);
                }
                return TRUE;
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// ViewPropsDialogProc and helpers

void EnableDisableScaleControls(LPVIEWPROPS lpVP, HWND hDlg)
{
        LPOLEUIVIEWPROPS lpOVP = lpVP->lpOVP;
        BOOL bEnable = !(lpOVP->dwFlags & VPF_DISABLESCALE) &&
                SendDlgItemMessage(hDlg, IDC_VP_ASICON, BM_GETCHECK, 0, 0) == 0;
        StandardEnableDlgItem(hDlg, IDC_VP_SPIN, bEnable);
        StandardEnableDlgItem(hDlg, IDC_VP_PERCENT, bEnable);
        StandardEnableDlgItem(hDlg, IDC_VP_SCALETXT, bEnable);
        bEnable = bEnable && !(lpOVP->dwFlags & VPF_DISABLERELATIVE);
        StandardEnableDlgItem(hDlg, IDC_VP_RELATIVE, bEnable);
}

BOOL FViewPropsInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        LPVIEWPROPS lpVP = (LPVIEWPROPS)LpvStandardInit(hDlg, sizeof(VIEWPROPS));

        // LpvStandardInit send a termination to us already.
        if (NULL == lpVP)
                return FALSE;

        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lParam;
        LPOLEUIVIEWPROPS lpOVP = (LPOLEUIVIEWPROPS)lpPP->lParam;
        lpVP->lpOVP = lpOVP;
        lpVP->nIDD = IDD_VIEWPROPS;

        // get object information and fill in default fields
        LPOLEUIOBJECTPROPS lpOP = lpOVP->lpOP;
        LPOLEUIOBJINFO lpObjInfo = lpOP->lpObjInfo;

        // initialize icon and scale variables
        HGLOBAL hMetaPict;
        DWORD dvAspect;
        int nCurrentScale;
        lpObjInfo->GetViewInfo(lpOP->dwObject, &hMetaPict,
                &dvAspect, &nCurrentScale);
        SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGESET,
                0, (LPARAM)hMetaPict);
        lpVP->nCurrentScale = nCurrentScale;
        lpVP->dvAspect = dvAspect;

        // Initialize the result image
        SendDlgItemMessage(hDlg, IDC_VP_RESULTIMAGE,
                RIM_IMAGESET, RESULTIMAGE_EDITABLE, 0L);

        // Initialize controls
        CheckRadioButton(hDlg, IDC_VP_EDITABLE, IDC_VP_ASICON,
                dvAspect == DVASPECT_CONTENT ?  IDC_VP_EDITABLE : IDC_VP_ASICON);
        SendDlgItemMessage(hDlg, IDC_VP_RELATIVE, BM_SETCHECK,
                (lpOVP->dwFlags & VPF_SELECTRELATIVE) != 0, 0L);
        if (!(lpOVP->dwFlags & VPF_DISABLESCALE))
                SetDlgItemInt(hDlg, IDC_VP_PERCENT, nCurrentScale, FALSE);
        lpVP->bRelativeToOrig = SendDlgItemMessage(hDlg, IDC_VP_RELATIVE,
                BM_GETCHECK, 0, 0) != 0;

        // Setup up-down control as buddy to IDC_VP_PERCENT
        HWND hWndSpin = CreateWindowEx(0, UPDOWN_CLASS, NULL,
                WS_CHILD|UDS_SETBUDDYINT|UDS_ARROWKEYS|UDS_ALIGNRIGHT, 0, 0, 0, 0,
                hDlg, (HMENU)IDC_VP_SPIN, _g_hOleStdInst, NULL);
        if (hWndSpin != NULL)
        {
                SendMessage(hWndSpin, UDM_SETRANGE, 0,
                        MAKELPARAM(lpOVP->nScaleMax, lpOVP->nScaleMin));
                SendMessage(hWndSpin, UDM_SETPOS, 0, nCurrentScale);
                SendMessage(hWndSpin, UDM_SETBUDDY,
                        (WPARAM)GetDlgItem(hDlg, IDC_VP_PERCENT), 0);
                ShowWindow(hWndSpin, SW_SHOW);
        }
        EnableDisableScaleControls(lpVP, hDlg);
        if (!(lpOP->dwFlags & OPF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpVP, hDlg, WM_INITDIALOG, wParam, lpOVP->lCustData);
        return TRUE;
}

INT_PTR CALLBACK ViewPropsDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPVIEWPROPS lpVP = (LPVIEWPROPS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return (INT_PTR)uHook;

        // Get pointers to important info
        LPOLEUIVIEWPROPS lpOVP = NULL;
        LPOLEUIOBJECTPROPS lpOP = NULL;
        LPOLEUIOBJINFO lpObjInfo = NULL;
        if (lpVP != NULL)
        {
                lpOVP = lpVP->lpOVP;
                if (lpOVP != NULL)
                {
                        lpObjInfo = lpOVP->lpOP->lpObjInfo;
                        lpOP = lpOVP->lpOP;
                }
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
                FViewPropsInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_VP_ASICON:
                case IDC_VP_EDITABLE:
                        EnableDisableScaleControls(lpVP, hDlg);
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        return TRUE;

                case IDC_VP_CHANGEICON:
                        {
                                // Call up Change Icon dialog to obtain new icon
                                OLEUICHANGEICON ci; memset(&ci, 0, sizeof(ci));
                                ci.cbStruct = sizeof(ci);
                                ci.dwFlags = CIF_SELECTCURRENT;
                                ci.hWndOwner = GetParent(GetParent(hDlg));
                                ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY,
                                        IBXM_IMAGEGET, 0, 0L);

                                // get classid to look for (may be new class if conversion applied)
                                SendMessage(GetParent(hDlg), PSM_QUERYSIBLINGS,
                                        OLEUI_QUERY_GETCLASSID, (LPARAM)&ci.clsid);
                                lpObjInfo->GetConvertInfo(lpOP->dwObject,
                                        &ci.clsid, NULL, NULL, NULL, NULL);
                                if (lpOP->dwFlags & OPF_SHOWHELP)
                                        ci.dwFlags |= CIF_SHOWHELP;

                                // allow the caller to hook the change icon
                                uHook = UStandardHook(lpVP, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);
                                if (0 == uHook)
                                {
                                        uHook = (OLEUI_OK == OleUIChangeIcon(&ci));
                                        SetFocus(hDlg);
                                }
                                if (0 != uHook)
                                {
                                        // apply the changes
                                        SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGESET, 1,
                                                (LPARAM)ci.hMetaPict);
                                        lpVP->bIconChanged = TRUE;
                                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                                }
                        }
                        return TRUE;

                case IDC_VP_PERCENT:
                case IDC_VP_RELATIVE:
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        return TRUE;
                case IDC_OLEUIHELP:
                        PostMessage(GetParent(GetParent(hDlg)),
                                uMsgHelp,
                                (WPARAM)hDlg,
                                MAKELPARAM(IDD_VIEWPROPS, 0));
                        return TRUE;
                }
                break;

        case WM_VSCROLL:
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                break;

        case PSM_QUERYSIBLINGS:
                SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                switch (wParam)
                {
                case OLEUI_QUERY_LINKBROKEN:
					    // lpVP could be NULL in low memory situations-- in this case don't handle
					    // the message.
					    if (lpVP != NULL)
						{
							if (!lpVP->bIconChanged)
							{
                                // re-init icon, since user hasn't changed it
                                HGLOBAL hMetaPict;
                                lpObjInfo->GetViewInfo(lpOP->dwObject, &hMetaPict, NULL, NULL);
                                SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGESET,
												   1, (LPARAM)hMetaPict);
							}
							return TRUE;
						}
                }
                break;

        case WM_NOTIFY:
                switch (((NMHDR*)lParam)->code)
                {
                case PSN_HELP:
                    PostMessage(GetParent(GetParent(hDlg)), uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_VIEWPROPS, 0));
                    break;
                case PSN_APPLY:
                        {
                                HGLOBAL hMetaPict = NULL;
                                int nCurrentScale = -1;
                                DWORD dvAspect = (DWORD)-1;
                                BOOL bRelativeToOrig = FALSE;

                                // handle icon change
                                if (lpVP->bIconChanged)
                                {
                                        hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                                IDC_VP_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                        lpVP->bIconChanged = FALSE;
                                }

                                // handle scale changes
                                if (IsWindowEnabled(GetDlgItem(hDlg, IDC_VP_PERCENT)))
                                {
                                        // parse the percentage entered
                                        BOOL bValid;
                                        nCurrentScale = GetDlgItemInt(hDlg, IDC_VP_PERCENT, &bValid, FALSE);
                                        if (!bValid)
                                        {
                                                PopupMessage(GetParent(hDlg), IDS_VIEWPROPS,
                                                        IDS_INVALIDPERCENTAGE, MB_OK|MB_ICONEXCLAMATION);

                                                // cancel the call
                                                SetWindowLong(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                                return TRUE;
                                        }
                                        // normalize range
                                        int nScaleMin, nScaleMax;
                                        if (lpOVP->nScaleMin > lpOVP->nScaleMax)
                                        {
                                                nScaleMin = lpOVP->nScaleMax;
                                                nScaleMax = lpOVP->nScaleMin;
                                        }
                                        else
                                        {
                                                nScaleMin = lpOVP->nScaleMin;
                                                nScaleMax = lpOVP->nScaleMax;
                                        }
                                        // check range for validity
                                        if (nCurrentScale < nScaleMin || nCurrentScale > nScaleMax)
                                        {
                                                // format appropriate message
                                                TCHAR szCaption[128];
                                                LoadString(_g_hOleStdResInst, IDS_VIEWPROPS, szCaption, 128);
                                                TCHAR szFormat[128];
                                                LoadString(_g_hOleStdResInst, IDS_RANGEERROR, szFormat, 128);
                                                TCHAR szTemp[256], szNum1[32], szNum2[32];
                                                wsprintf(szNum1, _T("%d"), lpOVP->nScaleMin);
                                                wsprintf(szNum2, _T("%d"), lpOVP->nScaleMax);
                                                FormatString2(szTemp, szFormat, szNum1, szNum2, sizeof(szTemp)/sizeof(TCHAR));
                                                MessageBox(GetParent(hDlg), szTemp, szCaption, MB_OK|MB_ICONEXCLAMATION);

                                                // and cancel the call
                                                SetWindowLong(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                                return TRUE;
                                        }

                                        // otherwise scale is in correct range
                                        bRelativeToOrig =
                                                SendDlgItemMessage(hDlg, IDC_VP_RELATIVE, BM_GETCHECK, 0, 0) != 0;
                                        if (nCurrentScale != lpVP->nCurrentScale ||
                                                bRelativeToOrig != lpVP->bRelativeToOrig)
                                        {
                                                lpVP->nCurrentScale = nCurrentScale;
                                                lpVP->bRelativeToOrig = bRelativeToOrig;
                                        }
                                }

                                // handle aspect changes
                                if (SendDlgItemMessage(hDlg, IDC_VP_ASICON, BM_GETCHECK, 0, 0L))
                                        dvAspect = DVASPECT_ICON;
                                else
                                        dvAspect = DVASPECT_CONTENT;
                                if (dvAspect == lpVP->dvAspect)
                                        dvAspect = (DWORD)-1;
                                else
                                {
                                        lpVP->dvAspect = dvAspect;
                                        bRelativeToOrig = 1;
                                }

                                lpObjInfo->SetViewInfo(lpOP->dwObject, hMetaPict, dvAspect,
                                        nCurrentScale, bRelativeToOrig);
                        }
                        SetWindowLong(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                        PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        return TRUE;
                }
                break;

        case WM_DESTROY:
                SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0);
                StandardCleanup((PVOID)lpVP, hDlg);
                return TRUE;
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// LinkPropsDialogProc and helpers

static BOOL IsNullTime(const FILETIME* lpFileTime)
{
    FILETIME fileTimeNull = { 0, 0 };
    return CompareFileTime(&fileTimeNull, lpFileTime) == 0;
}

static BOOL SetDlgItemDate(HWND hDlg, int nID, const FILETIME* lpFileTime)
{
    if (IsNullTime(lpFileTime))
                return FALSE;

        // convert UTC file time to system time
    FILETIME localTime;
    FileTimeToLocalFileTime(lpFileTime, &localTime);
        SYSTEMTIME systemTime;
        FileTimeToSystemTime(&localTime, &systemTime);

        TCHAR szDate[80];
        GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systemTime,
                NULL, szDate, sizeof(szDate) / sizeof(TCHAR));

        SetDlgItemText(hDlg, nID, szDate);
        return TRUE;
}

static BOOL SetDlgItemTime(HWND hDlg, int nID, const FILETIME* lpFileTime)
{
    if (IsNullTime(lpFileTime))
                return FALSE;

        // convert UTC file time to system time
    FILETIME localTime;
    FileTimeToLocalFileTime(lpFileTime, &localTime);
        SYSTEMTIME systemTime;
        FileTimeToSystemTime(&localTime, &systemTime);

        if (systemTime.wHour || systemTime.wMinute || systemTime.wSecond)
        {
                TCHAR szTime[80];
                GetTimeFormat(LOCALE_USER_DEFAULT, 0, &systemTime,
                        NULL, szTime, sizeof(szTime)/sizeof(TCHAR));

                SetDlgItemText(hDlg, nID, szTime);
        }
        return TRUE;
}

BOOL FLinkPropsInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPLINKPROPS lpLP = (LPLINKPROPS)LpvStandardInit(hDlg, sizeof(LINKPROPS), &hFont);

        // LpvStandardInit send a termination to us already.
        if (NULL == lpLP)
                return FALSE;

        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lParam;
        LPOLEUILINKPROPS lpOLP = (LPOLEUILINKPROPS)lpPP->lParam;
        lpLP->lpOLP = lpOLP;
        lpLP->nIDD = IDD_LINKPROPS;

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                // Do this for as many controls as you need it for.
                SendDlgItemMessage(hDlg, IDC_LP_LINKSOURCE, WM_SETFONT, (WPARAM)hFont, 0);
                SendDlgItemMessage(hDlg, IDC_LP_DATE, WM_SETFONT, (WPARAM)hFont, 0);
                SendDlgItemMessage(hDlg, IDC_LP_TIME, WM_SETFONT, (WPARAM)hFont, 0);
        }

        // general "Unknown" string for unknown items
        TCHAR szUnknown[64];
        LoadString(_g_hOleStdResInst, IDS_OLE2UIUNKNOWN, szUnknown, 64);

        // get object information and fill in default fields
        LPOLEUIOBJECTPROPS lpOP = lpOLP->lpOP;
        LPOLEUILINKINFO lpLinkInfo = lpOP->lpLinkInfo;
        FILETIME lastUpdate; memset(&lastUpdate, 0, sizeof(lastUpdate));
        lpLinkInfo->GetLastUpdate(lpOP->dwLink, &lastUpdate);

        // initialize time and date static text
        if (IsNullTime(&lastUpdate))
        {
                // time and date are unknown
                SetDlgItemText(hDlg, IDC_LP_DATE, szUnknown);
                SetDlgItemText(hDlg, IDC_LP_TIME, szUnknown);
        }
        else
        {
                // time and date are known
                SetDlgItemDate(hDlg, IDC_LP_DATE, &lastUpdate);
                SetDlgItemTime(hDlg, IDC_LP_TIME, &lastUpdate);
        }

        // initialize source display name
        LPTSTR lpszDisplayName;
        lpLinkInfo->GetLinkSource(lpOP->dwLink, &lpszDisplayName,
                &lpLP->nFileLength, NULL, NULL, NULL, NULL);
        SetDlgItemText(hDlg, IDC_LP_LINKSOURCE, lpszDisplayName);
        OleStdFree(lpszDisplayName);

        // initialize automatic/manual update field
        DWORD dwUpdate;
        lpLinkInfo->GetLinkUpdateOptions(lpOP->dwLink, &dwUpdate);
        CheckRadioButton(hDlg, IDC_LP_AUTOMATIC, IDC_LP_MANUAL,
                dwUpdate == OLEUPDATE_ALWAYS ? IDC_LP_AUTOMATIC : IDC_LP_MANUAL);
        lpLP->dwUpdate = dwUpdate;

        if (!(lpOP->dwFlags & OPF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpLP, hDlg, WM_INITDIALOG, wParam, lpOLP->lCustData);
        return TRUE;
}

INT_PTR CALLBACK LinkPropsDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPLINKPROPS lpLP = (LPLINKPROPS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return (INT_PTR)uHook;

        // Get pointers to important info
        LPOLEUILINKPROPS lpOLP = NULL;
        LPOLEUIOBJECTPROPS lpOP = NULL;
        LPOLEUILINKINFO lpLinkInfo;
        if (lpLP != NULL)
        {
                lpOLP = lpLP->lpOLP;
                if (lpOLP != NULL)
                {
                        lpLinkInfo = lpOLP->lpOP->lpLinkInfo;
                        lpOP = lpOLP->lpOP;
                }
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
                FLinkPropsInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_LP_OPENSOURCE:
                        // force update
                        SendMessage(GetParent(hDlg), PSM_APPLY, 0, 0);

                        // launch the object
                        lpLinkInfo->OpenLinkSource(lpOP->dwLink);

                        // close the dialog
                        SendMessage(GetParent(hDlg), WM_COMMAND, IDOK, 0);
                        break;

                case IDC_LP_UPDATENOW:
                        {
                                // force update
                                SendMessage(GetParent(hDlg), PSM_APPLY, 0, 0);

                                // update the link via container provided callback
                                if (lpLinkInfo->UpdateLink(lpOP->dwLink, TRUE, FALSE) != NOERROR)
                                        break;

                                // since link was updated, update the time/date display
                                SYSTEMTIME systemTime; GetSystemTime(&systemTime);
                                FILETIME localTime; SystemTimeToFileTime(&systemTime, &localTime);
                                FILETIME lastUpdate; LocalFileTimeToFileTime(&localTime, &lastUpdate);
                                lpLinkInfo->GetLastUpdate(lpOP->dwLink, &lastUpdate);

                                SetDlgItemDate(hDlg, IDC_LP_DATE, &lastUpdate);
                                SetDlgItemTime(hDlg, IDC_LP_TIME, &lastUpdate);

                                // modification that cannot be undone
                                SendMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        }
                        break;

                case IDC_LP_BREAKLINK:
                        {
                                UINT uRet = PopupMessage(GetParent(hDlg), IDS_LINKPROPS,
                                        IDS_CONFIRMBREAKLINK, MB_YESNO|MB_ICONQUESTION);
                                if (uRet == IDYES)
                                {
                                        // cancel the link turning it into a picture
                                        lpLinkInfo->CancelLink(lpOP->dwLink);

                                        // allow other pages to refresh
                                        lpOP->dwFlags &= ~OPF_OBJECTISLINK;
                                        SendMessage(GetParent(hDlg), PSM_QUERYSIBLINGS,
                                                OLEUI_QUERY_LINKBROKEN, 0);

                                        // remove the links page (since this is no longer a link)
                                        SendMessage(GetParent(hDlg), PSM_REMOVEPAGE, 2, 0);

                                }
                        }
                        break;

                case IDC_LP_CHANGESOURCE:
                        {
                                // get current source in OLE memory
                                UINT nLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_LP_LINKSOURCE));
                                LPTSTR lpszDisplayName = (LPTSTR)OleStdMalloc((nLen+1) * sizeof(TCHAR));
                                GetDlgItemText(hDlg, IDC_LP_LINKSOURCE, lpszDisplayName, nLen+1);
                                if (lpszDisplayName == NULL)
                                        break;

                                // fill in the OLEUICHANGESOURCE struct
                                OLEUICHANGESOURCE cs; memset(&cs, 0, sizeof(cs));
                                cs.cbStruct = sizeof(cs);
                                cs.hWndOwner = GetParent(GetParent(hDlg));
                                cs.dwFlags = CSF_ONLYGETSOURCE;
                                if (lpOP->dwFlags & OPF_SHOWHELP)
                                        cs.dwFlags |= CSF_SHOWHELP;
                                cs.lpOleUILinkContainer = lpLinkInfo;
                                cs.dwLink = lpOP->dwLink;
                                cs.lpszDisplayName = lpszDisplayName;
                                cs.nFileLength = lpLP->nFileLength;

                                // allow the Change Souce dialog to be hooked
                                UINT uRet = UStandardHook(lpLP, hDlg, uMsgChangeSource, 0,
                                        (LPARAM)&cs);
                                if (!uRet)
                                {
                                        uRet = (OLEUI_OK == OleUIChangeSource(&cs));
                                        SetFocus(hDlg);
                                }
                                if (uRet)
                                {
                                        OleStdFree(lpLP->lpszDisplayName);

                                        lpLP->lpszDisplayName = cs.lpszDisplayName;
                                        lpLP->nFileLength = cs.nFileLength;
                                        SetDlgItemText(hDlg, IDC_LP_LINKSOURCE, lpLP->lpszDisplayName);

                                        OleStdFree(cs.lpszTo);
                                        OleStdFree(cs.lpszFrom);

                                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                                }
                        }
                        break;

                case IDC_LP_MANUAL:
                case IDC_LP_AUTOMATIC:
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        break;
                case IDC_OLEUIHELP:
                        PostMessage(GetParent(GetParent(hDlg)),
                                uMsgHelp,
                                (WPARAM)hDlg,
                                MAKELPARAM(IDD_LINKPROPS, 0));
                        return TRUE;

                }
                break;

        case WM_NOTIFY:
                switch (((NMHDR*)lParam)->code)
                {
                case PSN_HELP:
                    PostMessage(GetParent(GetParent(hDlg)), uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_LINKPROPS, 0));
                    break;
                case PSN_APPLY:
                        {
                                // update link update options first
                                DWORD dwUpdate;
                                if (SendDlgItemMessage(hDlg, IDC_LP_AUTOMATIC, BM_GETCHECK, 0, 0))
                                        dwUpdate = OLEUPDATE_ALWAYS;
                                else
                                        dwUpdate = OLEUPDATE_ONCALL;
                                if (dwUpdate != lpLP->dwUpdate)
                                        lpLinkInfo->SetLinkUpdateOptions(lpOP->dwLink, dwUpdate);

                                // set the link source
                                if (lpLP->lpszDisplayName != NULL)
                                {
                                        // try setting with validation first
                                        ULONG chEaten;
                                        if (NOERROR != lpLinkInfo->SetLinkSource(lpOP->dwLink,
                                                lpLP->lpszDisplayName, lpLP->nFileLength, &chEaten,
                                                TRUE))
                                        {
                                                UINT uRet = PopupMessage(GetParent(hDlg), IDS_LINKPROPS,
                                                        IDS_INVALIDSOURCE,  MB_ICONQUESTION|MB_YESNO);
                                                if (uRet == IDYES)
                                                {
                                                        // user wants to correct the link source
                                                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                                                        return TRUE;
                                                }
                                                // user doesn't care if link source is bogus
                                                lpLinkInfo->SetLinkSource(lpOP->dwLink,
                                                        lpLP->lpszDisplayName, lpLP->nFileLength, &chEaten,
                                                        FALSE);
                                        }
                                        OleStdFree(lpLP->lpszDisplayName);
                                        lpLP->lpszDisplayName = NULL;
                                }
                        }
                        SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                        PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        return TRUE;
                }
                break;

        case WM_DESTROY:
                if (lpLP != NULL)
                {
                        OleStdFree(lpLP->lpszDisplayName);
                        lpLP->lpszDisplayName = NULL;
                }
                StandardCleanup((PVOID)lpLP, hDlg);
                return TRUE;

        default:
                if (lpOP != NULL && lpOP->lpPS->hwndParent && iMsg == uMsgBrowseOFN)
                {
                        SendMessage(lpOP->lpPS->hwndParent, uMsgBrowseOFN, wParam, lParam);
                }
                break;
        }

        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Property Page initialization code

struct PROPPAGEDATA
{
        UINT    nTemplateID;
        UINT    nTemplateID4;
        DLGPROC pfnDlgProc;
        size_t  nPtrOffset;
};

#define PTR_OFFSET(x) offsetof(OLEUIOBJECTPROPS, x)
static PROPPAGEDATA pageData[3] =
{
        { IDD_GNRLPROPS,IDD_GNRLPROPS4, GnrlPropsDialogProc, PTR_OFFSET(lpGP), },
        { IDD_VIEWPROPS,IDD_VIEWPROPS,  ViewPropsDialogProc, PTR_OFFSET(lpVP), },
        { IDD_LINKPROPS,IDD_LINKPROPS4, LinkPropsDialogProc, PTR_OFFSET(lpLP), },
};
#undef PTR_OFFSET

static UINT WINAPI PrepareObjectProperties(LPOLEUIOBJECTPROPS lpOP)
{
        // setup back pointers from page structs to sheet structs
        lpOP->lpGP->lpOP = lpOP;
        lpOP->lpVP->lpOP = lpOP;
        if ((lpOP->dwFlags & OPF_OBJECTISLINK) && lpOP->lpLP != NULL)
                lpOP->lpLP->lpOP = lpOP;

        // pre-init GNRLPROPS struct
        LPOLEUIGNRLPROPS lpGP = lpOP->lpGP;

        // get ready to initialize PROPSHEET structs
        LPPROPSHEETHEADER lpPS = lpOP->lpPS;
        LPPROPSHEETPAGE lpPPs = (LPPROPSHEETPAGE)lpPS->ppsp;
        UINT nMaxPage = (lpOP->dwFlags & OPF_OBJECTISLINK ? 3 : 2);

        // setting OPF_NOFILLDEFAULT allows you to control almost everything
        if (!(lpOP->dwFlags & OPF_NOFILLDEFAULT))
        {
                // get array of 3 PROPSHEETPAGE structs if not provided
                if (lpPS->ppsp == NULL)
                {
                        lpPS->nPages = nMaxPage;
                        lpPPs = (LPPROPSHEETPAGE)
                                OleStdMalloc(nMaxPage * sizeof(PROPSHEETPAGE));
                        if (lpPPs == NULL)
                                return OLEUI_ERR_OLEMEMALLOC;
                        memset(lpPPs, 0, nMaxPage * sizeof(PROPSHEETPAGE));
                        lpPS->ppsp = lpPPs;
                }

                // fill in defaults for lpPS
                lpPS->dwFlags |= PSH_PROPSHEETPAGE;
                if (lpPS->hInstance == NULL)
                        lpPS->hInstance = _g_hOleStdResInst;

                // fill Defaults for Standard Property Pages
                LPPROPSHEETPAGE lpPP = lpPPs;
                for (UINT nPage = 0; nPage < nMaxPage; nPage++)
                {
                        PROPPAGEDATA* pPageData = &pageData[nPage];
                        if (lpPP->dwSize == 0)
                                lpPP->dwSize = sizeof(PROPSHEETPAGE);
                        if (lpPP->hInstance == NULL)
                                lpPP->hInstance = _g_hOleStdResInst;
                        UINT nIDD = bWin4 ?
                                pPageData->nTemplateID4 : pPageData->nTemplateID;
                        if (lpPP->pszTemplate == NULL)
                                lpPP->pszTemplate = MAKEINTRESOURCE(nIDD);
                        lpPP = (LPPROPSHEETPAGE)((LPBYTE)lpPP+lpPP->dwSize);
                }
        }

        // fill Property Page info which cannot be overridden
        LPPROPSHEETPAGE lpPP = lpPPs;
        for (UINT nPage = 0; nPage < nMaxPage; nPage++)
        {
                PROPPAGEDATA* pPageData = &pageData[nPage];
                lpPP->pfnDlgProc = pPageData->pfnDlgProc;
                lpPP->lParam = (LPARAM)
                        *(OLEUIGNRLPROPS**)((LPBYTE)lpOP + pPageData->nPtrOffset);
                lpPP = (LPPROPSHEETPAGE)((LPBYTE)lpPP+lpPP->dwSize);
        }
        return OLEUI_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\oledlgs.h ===
/*++ BUILD Version: 0002    Increment this if a change has global effects

Copyright (c) 1993-1995, Microsoft Corporation

Module Name:

        oledlgs.h

Abstract:

        Resource ID identifiers for the OLE common dialog boxes.

--*/

// Help Button Identifier
#define IDC_OLEUIHELP                   99

// Insert Object Dialog identifiers
#define IDC_IO_CREATENEW                2100
#define IDC_IO_CREATEFROMFILE           2101
#define IDC_IO_INSERTCONTROL            2102
#define IDC_IO_LINKFILE                 2103
#define IDC_IO_OBJECTTYPELIST           2104
#define IDC_IO_DISPLAYASICON            2105
#define IDC_IO_CHANGEICON               2106
#define IDC_IO_FILE                     2107
#define IDC_IO_FILEDISPLAY              2108
#define IDC_IO_RESULTIMAGE              2109
#define IDC_IO_RESULTTEXT               2110
#define IDC_IO_ICONDISPLAY              2111
#define IDC_IO_OBJECTTYPETEXT           2112
#define IDC_IO_FILETEXT                 2113
#define IDC_IO_FILETYPE                 2114
#define IDC_IO_ADDCONTROL               2115
#define IDC_IO_CONTROLTYPELIST          2116

// Paste Special Dialog identifiers
#define IDC_PS_PASTE                    500
#define IDC_PS_PASTELINK                501
#define IDC_PS_SOURCETEXT               502
#define IDC_PS_PASTELIST                503     //{{NOHELP}}
#define IDC_PS_PASTELINKLIST            504     //{{NOHELP}}
#define IDC_PS_DISPLAYLIST              505
#define IDC_PS_DISPLAYASICON            506
#define IDC_PS_ICONDISPLAY              507
#define IDC_PS_CHANGEICON               508
#define IDC_PS_RESULTIMAGE              509
#define IDC_PS_RESULTTEXT               510

// Change Icon Dialog identifiers
#define IDC_CI_GROUP                    120     //{{NOHELP}}
#define IDC_CI_CURRENT                  121
#define IDC_CI_CURRENTICON              122
#define IDC_CI_DEFAULT                  123
#define IDC_CI_DEFAULTICON              124
#define IDC_CI_FROMFILE                 125
#define IDC_CI_FROMFILEEDIT             126
#define IDC_CI_ICONLIST                 127
#define IDC_CI_LABEL                    128     //{{NOHELP}
#define IDC_CI_LABELEDIT                129
#define IDC_CI_BROWSE                   130
#define IDC_CI_ICONDISPLAY              131

// Convert Dialog identifiers
#define IDC_CV_OBJECTTYPE               150
#define IDC_CV_DISPLAYASICON            152
#define IDC_CV_CHANGEICON               153
#define IDC_CV_ACTIVATELIST             154
#define IDC_CV_CONVERTTO                155
#define IDC_CV_ACTIVATEAS               156
#define IDC_CV_RESULTTEXT               157
#define IDC_CV_CONVERTLIST              158
#define IDC_CV_ICONDISPLAY              165

// Edit Links Dialog identifiers
#define IDC_EL_CHANGESOURCE             201
#define IDC_EL_AUTOMATIC                202
#define IDC_EL_CANCELLINK               209
#define IDC_EL_UPDATENOW                210
#define IDC_EL_OPENSOURCE               211
#define IDC_EL_MANUAL                   212
#define IDC_EL_LINKSOURCE               216
#define IDC_EL_LINKTYPE                 217
#define IDC_EL_LINKSLISTBOX             206
#define IDC_EL_COL1                     220
#define IDC_EL_COL2                     221
#define IDC_EL_COL3                     222

// Busy dialog identifiers
#define IDC_BZ_RETRY                    600
#define IDC_BZ_ICON                     601
#define IDC_BZ_MESSAGE1                 602     //{{NOHELP}}
#define IDC_BZ_SWITCHTO                 604

// Update Links dialog identifiers
#define IDC_UL_METER                    1029    //{{NOHELP}}
#define IDC_UL_STOP                     1030    //{{NOHELP}}
#define IDC_UL_PERCENT                  1031    //{{NOHELP}}
#define IDC_UL_PROGRESS                 1032    //{{NOHELP}}

// User Prompt dialog identifiers
#define IDC_PU_LINKS                    900     //{{NOHELP}}
#define IDC_PU_TEXT                     901     //{{NOHELP}}
#define IDC_PU_CONVERT                  902     //{{NOHELP}}
#define IDC_PU_ICON                     908     //{{NOHELP}}

// General Properties identifiers
#define IDC_GP_OBJECTNAME               1009
#define IDC_GP_OBJECTTYPE               1010
#define IDC_GP_OBJECTSIZE               1011
#define IDC_GP_CONVERT                  1013
#define IDC_GP_OBJECTICON               1014    //{{NOHELP}}
#define IDC_GP_OBJECTLOCATION           1022

// View Properties identifiers
#define IDC_VP_PERCENT                  1000
#define IDC_VP_CHANGEICON               1001
#define IDC_VP_EDITABLE                 1002
#define IDC_VP_ASICON                   1003
#define IDC_VP_RELATIVE                 1005
#define IDC_VP_SPIN                     1006
#define IDC_VP_SCALETXT                 1034
#define IDC_VP_ICONDISPLAY              1021
#define IDC_VP_RESULTIMAGE              1033

// Link Properties identifiers
#define IDC_LP_OPENSOURCE               1006
#define IDC_LP_UPDATENOW                1007
#define IDC_LP_BREAKLINK                1008
#define IDC_LP_LINKSOURCE               1012
#define IDC_LP_CHANGESOURCE             1015
#define IDC_LP_AUTOMATIC                1016
#define IDC_LP_MANUAL                   1017
#define IDC_LP_DATE                     1018
#define IDC_LP_TIME                     1019

// Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT                1000
#define IDD_CHANGEICON                  1001
#define IDD_CONVERT                     1002
#define IDD_PASTESPECIAL                1003
#define IDD_EDITLINKS                   1004
#define IDD_BUSY                        1006
#define IDD_UPDATELINKS                 1007
#define IDD_CHANGESOURCE                1009
#define IDD_INSERTFILEBROWSE            1010
#define IDD_CHANGEICONBROWSE            1011
#define IDD_CONVERTONLY                 1012
#define IDD_CHANGESOURCE4               1013
#define IDD_GNRLPROPS                   1100
#define IDD_VIEWPROPS                   1101
#define IDD_LINKPROPS                   1102

// The following Dialogs are message dialogs used by OleUIPromptUser API
#define IDD_CANNOTUPDATELINK            1008
#define IDD_LINKSOURCEUNAVAILABLE       1020
#define IDD_SERVERNOTFOUND              1023
#define IDD_OUTOFMEMORY                 1024
#define IDD_SERVERNOTREGW               1021
#define IDD_LINKTYPECHANGEDW            1022
#define IDD_SERVERNOTREGA               1025
#define IDD_LINKTYPECHANGEDA            1026
#ifdef UNICODE
#define IDD_SERVERNOTREG                IDD_SERVERNOTREGW
#define IDD_LINKTYPECHANGED             IDD_LINKTYPECHANGEDW
#else
#define IDD_SERVERNOTREG                IDD_SERVERNOTREGA
#define IDD_LINKTYPECHANGED             IDD_LINKTYPECHANGEDA
#endif
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\oleutl.cpp ===
/*
 * OLEUTL.CPP
 *
 * Miscellaneous utility functions for OLE 2.0 Applications:
 *
 *  Function                      Purpose
 *  -------------------------------------------------------------------
 *  XformWidthInHimetricToPixels  Converts an int width from HiMetric units
 *  XformHeightInHimetricToPixels Converts an int height from HiMetric units
 *
 *  CommitStorage                 Commits all changes in a docfile
 *  CreateChildStorage            Creates child storage in another storage
 *  OpenChildStorage              Opens child storage in another storage
 *
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#include "precomp.h"
#include <stdlib.h>

//Internal function to this module. No need for UNICODE in this function
static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst);

/*
 * XformWidthInHimetricToPixels
 * XformHeightInHimetricToPixels
 *
 * Functions to convert an int between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */
STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
{
        int     iXppli;     //Pixels per logical inch along width
        int     iWidthInPix;
        BOOL    fSystemDC=FALSE;

        if (NULL==hDC)
        {
                hDC=GetDC(NULL);

                if (NULL==hDC)
                {
                    //What can we do if hDC is NULL here?  Just don't
                    //transform, I guess.
                    return iWidthInHiMetric;
                }

                fSystemDC=TRUE;
        }

        iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

        //We got logical HIMETRIC along the display, convert them to pixel units
        iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

        if (fSystemDC)
                ReleaseDC(NULL, hDC);

        return iWidthInPix;
}


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
{
        int     iYppli;     //Pixels per logical inch along height
        int     iHeightInPix;
        BOOL    fSystemDC=FALSE;

        if (NULL==hDC)
        {
                hDC=GetDC(NULL);
                
                if (NULL==hDC)
                {
                    //What can we do if hDC is NULL here?  Just don't
                    //transform, I guess.
                    return iHeightInHiMetric;
                }

                fSystemDC=TRUE;
        }

        iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

        //* We got logical HIMETRIC along the display, convert them to pixel units
        iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

        if (fSystemDC)
                ReleaseDC(NULL, hDC);

        return iHeightInPix;
}

/* GetWord
 * -------
 *
 * LPSTR lpszSrc - Pointer to a source string
 * LPSTR lpszDst - Pointer to destination buffer
 *
 * Will copy one space-terminated or null-terminated word from the source
 * string to the destination buffer.
 * returns: pointer to next character following the word.
 */
static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst)
{
        while (*lpszSrc && !(*lpszSrc == ' ' || *lpszSrc == '\t' || *lpszSrc == '\n'))
                *lpszDst++ = *lpszSrc++;

        *lpszDst = '\0';
        return lpszSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\precomp.h ===
/*
 * PRECOMP.H
 *
 * This file is used to precompile the OLEDLG.H header file
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

// only STRICT compiles are supported
#ifndef STRICT
#define STRICT
#endif

#include "oledlg.h"
#include "olestd.h"
#include "resource.h"
#include "commctrl.h"
#ifndef WM_NOTIFY

// WM_NOTIFY is new in later versions of Win32
#define WM_NOTIFY 0x004e
typedef struct tagNMHDR
{
        HWND hwndFrom;
        UINT idFrom;
        UINT code;
} NMHDR;
#endif  //!WM_NOTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\pastespl.cpp ===
/*
 * PASTESPL.CPP
 *
 * Implements the OleUIPasteSpecial function which invokes the complete
 * Paste Special dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Rights Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"
#include "strsafe.h"
#include <stdlib.h>

OLEDBGDATA

// Length of buffers to hold the strings 'Unknown Type', Unknown Source'
//   and 'the application which created it'
// Extra long to allow room for localization.
#define PS_UNKNOWNSTRLEN               200
#define PS_UNKNOWNNAMELEN              256

// Property label used to store clipboard viewer chain information
#define NEXTCBVIEWER        TEXT("NextCBViewer")

// Internally used structure
typedef struct tagPASTESPECIAL
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIPASTESPECIAL  lpOPS;                //Original structure passed.
        UINT            nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */

        DWORD                dwFlags;              // Local copy of paste special flags

        int                  nPasteListCurSel;     // Save the selection the user made last
        int                  nPasteLinkListCurSel; //    in the paste and pastelink lists
        int                  nSelectedIndex;       // Index in arrPasteEntries[] corresponding to user selection
        BOOL                 fLink;                // Indicates if Paste or PasteLink was selected by user

        HGLOBAL              hBuff;                // Scratch Buffer for building up strings
        TCHAR                szUnknownType[PS_UNKNOWNSTRLEN];    // Buffer for 'Unknown Type' string
        TCHAR                szUnknownSource[PS_UNKNOWNSTRLEN];  // Buffer for 'Unknown Source' string
        TCHAR                szAppName[OLEUI_CCHKEYMAX]; // Application name of Source. Used in the result text
                                                                                                         //   when Paste is selected. Obtained using clsidOD.

        // Information obtained from OBJECTDESCRIPTOR. This information is accessed when the Paste
        //    radio button is selected.
        CLSID                clsidOD;              // ClassID of source
        SIZEL                sizelOD;              // sizel transfered in
                                                                                           //  ObjectDescriptor
        TCHAR                szFullUserTypeNameOD[PS_UNKNOWNNAMELEN]; // Full User Type Name
        TCHAR                szSourceOfDataOD[PS_UNKNOWNNAMELEN];     // Source of Data
        BOOL                 fSrcAspectIconOD;     // Does Source specify DVASPECT_ICON?
        BOOL                 fSrcOnlyIconicOD;     // Does Source specify OLEMISC_ONLYICONIC?
        HGLOBAL              hMetaPictOD;          // Metafile containing icon and icon title
        HGLOBAL              hObjDesc;             // Handle to OBJECTDESCRIPTOR structure from which the
                                                                                           //   above information is obtained

        // Information obtained from LINKSRCDESCRIPTOR. This infomation is accessed when the PasteLink
        //   radio button is selected.
        CLSID                clsidLSD;             // ClassID of source
        SIZEL                sizelLSD;             // sizel transfered in
                                                                                           //  LinkSrcDescriptor
        TCHAR                szFullUserTypeNameLSD[PS_UNKNOWNNAMELEN];// Full User Type Name
        TCHAR                szSourceOfDataLSD[PS_UNKNOWNNAMELEN];    // Source of Data
        BOOL                 fSrcAspectIconLSD;    // Does Source specify DVASPECT_ICON?
        BOOL                 fSrcOnlyIconicLSD;    // Does Source specify OLEMISC_ONLYICONIC?
        HGLOBAL              hMetaPictLSD;         // Metafile containing icon and icon title
        HGLOBAL              hLinkSrcDesc;         // Handle to LINKSRCDESCRIPTOR structure from which the
                                                                                           //   above information is obtained

        BOOL                 fClipboardChanged;    // Has clipboard content changed
                                                                                           //   if so bring down dlg after
                                                                                           //   ChangeIcon dlg returns.
} PASTESPECIAL, *PPASTESPECIAL, FAR *LPPASTESPECIAL;

// Data corresponding to each list item. A pointer to this structure is attached to each
//   Paste\PasteLink list box item using LB_SETITEMDATA
typedef struct tagPASTELISTITEMDATA
{
   int                   nPasteEntriesIndex;   // Index of arrPasteEntries[] corresponding to list item
   BOOL                  fCntrEnableIcon;      // Does calling application (called container here)
                                                                                           //    specify OLEUIPASTE_ENABLEICON for this item?
} PASTELISTITEMDATA, *PPASTELISTITEMDATA, FAR *LPPASTELISTITEMDATA;

// Internal function prototypes
// PASTESPL.CPP
INT_PTR CALLBACK PasteSpecialDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FPasteSpecialInit(HWND hDlg, WPARAM, LPARAM);
BOOL FTogglePasteType(HWND, LPPASTESPECIAL, DWORD);
void ChangeListSelection(HWND, LPPASTESPECIAL, HWND);
void EnableDisplayAsIcon(HWND, LPPASTESPECIAL);
void ToggleDisplayAsIcon(HWND, LPPASTESPECIAL);
void ChangeIcon(HWND, LPPASTESPECIAL);
void SetPasteSpecialHelpResults(HWND, LPPASTESPECIAL);
BOOL FAddPasteListItem(HWND, BOOL, int, LPPASTESPECIAL, LPTSTR, UINT, LPTSTR);
BOOL FFillPasteList(HWND, LPPASTESPECIAL);
BOOL FFillPasteLinkList(HWND, LPPASTESPECIAL);
BOOL FHasPercentS(LPCTSTR, LPPASTESPECIAL);
HGLOBAL AllocateScratchMem(LPPASTESPECIAL);
void FreeListData(HWND);
BOOL FPasteSpecialReInit(HWND hDlg, LPPASTESPECIAL lpPS);

/*
 * OleUIPasteSpecial
 *
 * Purpose:
 *  Invokes the standard OLE Paste Special dialog box which allows the user
 *  to select the format of the clipboard object to be pasted or paste linked.
 *
 * Parameters:
 *  lpPS         LPOLEUIPasteSpecial pointing to the in-out structure
 *               for this dialog.
 *
 * Return Value:
 *  UINT        One of the following codes or one of the standard error codes (OLEUI_ERR_*)
 *              defined in OLEDLG.H, indicating success or error:
 *              OLEUI_OK                           User selected OK
 *              OLEUI_CANCEL                       User cancelled the dialog
 *              OLEUI_IOERR_SRCDATAOBJECTINVALID   lpSrcDataObject field of OLEUIPASTESPECIAL invalid
 *              OLEUI_IOERR_ARRPASTEENTRIESINVALID arrPasteEntries field of OLEUIPASTESPECIAL invalid
 *              OLEUI_IOERR_ARRLINKTYPESINVALID    arrLinkTypes field of OLEUIPASTESPECIAL invalid
 *              OLEUI_PSERR_CLIPBOARDCHANGED       Clipboard contents changed while dialog was up
 */
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL lpPS)
{
        UINT        uRet;
        HGLOBAL     hMemDlg=NULL;

        uRet = UStandardValidation((LPOLEUISTANDARD)lpPS, sizeof(OLEUIPASTESPECIAL),
                &hMemDlg);

        if (uRet != OLEUI_SUCCESS)
                return uRet;

        // Validate PasteSpecial specific fields
        if (NULL != lpPS->lpSrcDataObj && IsBadReadPtr(lpPS->lpSrcDataObj,  sizeof(IDataObject)))
        {
                uRet = OLEUI_IOERR_SRCDATAOBJECTINVALID;
        }
        if (NULL == lpPS->arrPasteEntries ||
                IsBadReadPtr(lpPS->arrPasteEntries,  lpPS->cPasteEntries * sizeof(OLEUIPASTEENTRY)))
        {
                uRet = OLEUI_IOERR_ARRPASTEENTRIESINVALID;
        }
        if (0 > lpPS->cLinkTypes || lpPS->cLinkTypes > PS_MAXLINKTYPES ||
                IsBadReadPtr(lpPS->arrLinkTypes, lpPS->cLinkTypes * sizeof(UINT)))
        {
                uRet = OLEUI_IOERR_ARRLINKTYPESINVALID;
        }

        if (0 != lpPS->cClsidExclude &&
                IsBadReadPtr(lpPS->lpClsidExclude, lpPS->cClsidExclude * sizeof(CLSID)))
        {
                uRet = OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

        // If IDataObject passed is NULL, collect it from the clipboard
        if (NULL == lpPS->lpSrcDataObj)
        {
                if (OleGetClipboard(&lpPS->lpSrcDataObj) != NOERROR)
                        uRet = OLEUI_PSERR_GETCLIPBOARDFAILED;

                if (NULL == lpPS->lpSrcDataObj)
                        uRet = OLEUI_PSERR_GETCLIPBOARDFAILED;
        }

        if (uRet >= OLEUI_ERR_STANDARDMIN)
        {
                return uRet;
        }

        UINT nIDD = bWin4 ? IDD_PASTESPECIAL4 : IDD_PASTESPECIAL;

        //Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(PasteSpecialDialogProc, (LPOLEUISTANDARD)lpPS,
                hMemDlg, MAKEINTRESOURCE(nIDD));

        return uRet;
}

/*
 * PasteSpecialDialogProc
 *
 * Purpose:
 *  Implements the OLE Paste Special dialog as invoked through the
 *  OleUIPasteSpecial function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */
INT_PTR CALLBACK PasteSpecialDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT fHook = FALSE;
        LPPASTESPECIAL lpPS = (LPPASTESPECIAL)LpvStandardEntry(
                hDlg, iMsg, wParam, lParam, &fHook);
        LPOLEUIPASTESPECIAL lpOPS = NULL;
        if (lpPS != NULL)
                lpOPS = lpPS->lpOPS;

        //If the hook processed the message, we're done.
        if (0!=fHook)
                return (INT_PTR)fHook;

        // Process help message from Change Icon
        if (iMsg == uMsgHelp)
        {
			    // if lPS is NULL (in low memory situations, just ignore it.
                if (lpPS && (lpPS->lpOPS) )
				{
                    PostMessage(lpPS->lpOPS->hWndOwner, uMsgHelp, wParam, lParam);
				}
                return FALSE;
        }

        //Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
            case WM_DESTROY:
                    if (lpPS)
                    {
                    HWND    hwndNextViewer;

                    // Free the icon/icon-title metafile corresponding to Paste/PasteList option which is not selected
                    if (lpPS->fLink)
                            OleUIMetafilePictIconFree(lpPS->hMetaPictOD);
                    else
                            OleUIMetafilePictIconFree(lpPS->hMetaPictLSD);

                    // Free data associated with each list box entry
                    FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELIST));
                    FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELINKLIST));

                    //Free any specific allocations before calling StandardCleanup
                    if (lpPS->hObjDesc) GlobalFree(lpPS->hObjDesc);
                    if (lpPS->hLinkSrcDesc) GlobalFree(lpPS->hLinkSrcDesc);
                    if (lpPS->hBuff)
                        {
                            GlobalFree(lpPS->hBuff);
                            lpPS->hBuff = NULL;
                        }

                    // Change the clipboard notification chain
                    hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                    if (hwndNextViewer != HWND_BROADCAST)
                    {
                            SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
                            ChangeClipboardChain(hDlg, hwndNextViewer);
                    }
                    RemoveProp(hDlg, NEXTCBVIEWER);

                    StandardCleanup(lpPS, hDlg);
                    }
                    break;
                case WM_INITDIALOG:
                        FPasteSpecialInit(hDlg, wParam, lParam);
                        return FALSE;

                case WM_DRAWCLIPBOARD:
                        {
                                HWND    hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                                HWND    hDlg_ChgIcon;

                                if (hwndNextViewer == HWND_BROADCAST)
                                        break;

                                if (hwndNextViewer)
                                {
                                        SendMessage(hwndNextViewer, iMsg, wParam, lParam);
                                        // Refresh next viewer in case it got modified
                                        //    by the SendMessage() (likely if multiple
                                        //    PasteSpecial dialogs are up simultaneously)
                                        hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                                }

                                if (!(lpPS->dwFlags & PSF_STAYONCLIPBOARDCHANGE))
                                {
                                        SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
                                        ChangeClipboardChain(hDlg, hwndNextViewer);

                                        /* OLE2NOTE: if the ChangeIcon dialog is currently up, then
                                        **    we need to defer bringing down PasteSpecial dialog
                                        **    until after ChangeIcon dialog returns. if the
                                        **    ChangeIcon dialog is NOT up, then we can bring down
                                        **    the PasteSpecial dialog immediately.
                                        */
                                        if ((hDlg_ChgIcon=(HWND)GetProp(hDlg,PROP_HWND_CHGICONDLG))!=NULL)
                                        {
                                                // ChangeIcon dialog is UP
                                                lpPS->fClipboardChanged = TRUE;
                                        }
                                        else
                                        {
                                                // ChangeIcon dialog is NOT up

                                                //  Free icon and icon title metafile
                                                SendDlgItemMessage(
                                                                hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0L);
                                                SendMessage(
                                                                hDlg, uMsgEndDialog, OLEUI_PSERR_CLIPBOARDCHANGED,0L);
                                        }
                                }
                                else
                                {
                                        // skip refresh, ignoring clipboard change if PSF_NOREFRESHDATAOBJECT
                                        if (lpPS->dwFlags & PSF_NOREFRESHDATAOBJECT)
                                                break;

                                        // release current data object
                                        if (lpOPS->lpSrcDataObj != NULL)
                                        {
                                                lpOPS->lpSrcDataObj->Release();
                                                lpOPS->lpSrcDataObj = NULL;
                                        }

                                        // obtain new one
                                        if (OleGetClipboard(&lpOPS->lpSrcDataObj) != NOERROR)
                                        {
                                                SendMessage(hDlg, uMsgEndDialog, OLEUI_PSERR_GETCLIPBOARDFAILED, 0);
                                                break;
                                        }

                                        // otherwise update the display to the new clipboard object
                                        FPasteSpecialReInit(hDlg, lpPS);
                                }
                        }
                        break;

                case WM_CHANGECBCHAIN:
                        {
                                HWND    hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                                if ((HWND)wParam == hwndNextViewer)
                                        SetProp(hDlg, NEXTCBVIEWER, (hwndNextViewer = (HWND)lParam));
                                else if (hwndNextViewer && hwndNextViewer != HWND_BROADCAST)
                                        SendMessage(hwndNextViewer, iMsg, wParam, lParam);
                        }
                        break;

                case WM_COMMAND:
                        switch (wID)
                        {
                        case IDC_PS_PASTE:
                                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTE);
                                break;

                        case IDC_PS_PASTELINK:
                                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTELINK);
                                break;

                        case IDC_PS_DISPLAYLIST:
                                switch (wCode)
                                {
                                case LBN_SELCHANGE:
                                        ChangeListSelection(hDlg, lpPS, hWndMsg);
                                        break;
                                case LBN_DBLCLK:
                                        // Same as pressing OK
                                        if (IsWindowEnabled(GetDlgItem(hDlg, IDOK)))
                                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                                        break;
                                }
                                break;

                        case IDC_PS_DISPLAYASICON:
                                ToggleDisplayAsIcon(hDlg, lpPS);
                                break;

                        case IDC_PS_CHANGEICON:
                                ChangeIcon(hDlg, lpPS);
                                if (lpPS->fClipboardChanged)
                                {
                                        // Free icon and icon title metafile
                                        SendDlgItemMessage(
                                                hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGEFREE,0,0L);
                                        SendMessage(hDlg, uMsgEndDialog,
                                                OLEUI_PSERR_CLIPBOARDCHANGED, 0L);
                                }
                                break;

                        case IDOK:
                                {
                                        BOOL fDestAspectIcon =
                                                        ((lpPS->dwFlags & PSF_CHECKDISPLAYASICON) ?
                                                                        TRUE : FALSE);
                                        // Return current flags
                                        lpOPS->dwFlags = lpPS->dwFlags;
                                        // Return index of arrPasteEntries[] corresponding to format selected by user
                                        lpOPS->nSelectedIndex = lpPS->nSelectedIndex;
                                        // Return if user selected Paste or PasteLink
                                        lpOPS->fLink = lpPS->fLink;

                                        /* if user selected same ASPECT as displayed in the
                                        **    source, then sizel passed in the
                                        **    ObjectDescriptor/LinkSrcDescriptor is
                                        **    applicable. otherwise, the sizel does not apply.
                                        */
                                        if (lpPS->fLink)
                                        {
                                                if (lpPS->fSrcAspectIconLSD == fDestAspectIcon)
                                                        lpOPS->sizel = lpPS->sizelLSD;
                                                else
                                                        lpOPS->sizel.cx = lpOPS->sizel.cy = 0;
                                        }
                                        else
                                        {
                                                if (lpPS->fSrcAspectIconOD == fDestAspectIcon)
                                                        lpOPS->sizel = lpPS->sizelOD;
                                                else
                                                        lpOPS->sizel.cx = lpOPS->sizel.cy = 0;
                                        }
                                        // Return metafile with icon and icon title that the user selected
                                        lpOPS->hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                                IDC_PS_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                        SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                                }
                                break;

                        case IDCANCEL:
                                // Free icon and icon title metafile
                                SendDlgItemMessage(
                                                hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0L);
                                SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                                break;

                        case IDC_OLEUIHELP:
                                PostMessage(lpPS->lpOPS->hWndOwner, uMsgHelp,
                                        (WPARAM)hDlg, MAKELPARAM(IDD_PASTESPECIAL, 0));
                                break;
                        }
                        break;
        }
        return FALSE;
}

BOOL FPasteSpecialReInit(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;

        // free the icon/icon-title metafiel
        if (lpPS->fLink)
                OleUIMetafilePictIconFree(lpPS->hMetaPictOD);
        else
                OleUIMetafilePictIconFree(lpPS->hMetaPictLSD);

        // Free data assocatiated with each list box entry
        FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELIST));
        FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELINKLIST));
        SendDlgItemMessage(hDlg, IDC_PS_DISPLAYLIST, LB_RESETCONTENT, 0, 0);

        // Initialize user selections in the Paste and PasteLink listboxes
        lpPS->nPasteListCurSel = 0;
        lpPS->nPasteLinkListCurSel = 0;

        // Free previous object descriptor/link descriptor data
        if (lpPS->hObjDesc != NULL)
        {
                GlobalFree(lpPS->hObjDesc);
                lpPS->hObjDesc = NULL;
        }
        if (lpPS->hLinkSrcDesc != NULL)
        {
                GlobalFree(lpPS->hLinkSrcDesc);
                lpPS->hLinkSrcDesc = NULL;
        }

        lpPS->szAppName[0] = '\0';

        // GetData CF_OBJECTDESCRIPTOR. If the object on the clipboard in an
        // OLE1 object (offering CF_OWNERLINK) or has been copied to
        // clipboard by FileMaager (offering CF_FILENAME), an
        // OBJECTDESCRIPTOR will be created will be created from CF_OWNERLINK
        // or CF_FILENAME. See OBJECTDESCRIPTOR for more info.

        STGMEDIUM medium;
        CLIPFORMAT cfFormat;
        lpPS->hObjDesc = OleStdFillObjectDescriptorFromData(
                lpOPS->lpSrcDataObj, &medium, &cfFormat);
        if (lpPS->hObjDesc)
        {
                LPOBJECTDESCRIPTOR lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(lpPS->hObjDesc);

                // Get FullUserTypeName, SourceOfCopy and CLSID
                if (lpOD->dwFullUserTypeName)
                        lstrcpyn(lpPS->szFullUserTypeNameOD, (LPTSTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), PS_UNKNOWNNAMELEN);
                else
                        lstrcpyn(lpPS->szFullUserTypeNameOD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);

                if (lpOD->dwSrcOfCopy)
                {
                        lstrcpyn(lpPS->szSourceOfDataOD, (LPTSTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), PS_UNKNOWNNAMELEN);
                        // If CF_FILENAME was offered, source of copy is a
                        // path name. Fit the path to the static control that will display it.
                        if (cfFormat == _g_cfFileName)
                        {
                                lstrcpyn(lpPS->szSourceOfDataOD, ChopText(GetDlgItem(hDlg, IDC_PS_SOURCETEXT), 0,
                                        lpPS->szSourceOfDataOD, 0), PS_UNKNOWNNAMELEN);
                        }
                }
                else
                        lstrcpyn(lpPS->szSourceOfDataOD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);

                lpPS->clsidOD = lpOD->clsid;
                lpPS->sizelOD = lpOD->sizel;

                // Does source specify DVASPECT_ICON?
                if (lpOD->dwDrawAspect & DVASPECT_ICON)
                        lpPS->fSrcAspectIconOD = TRUE;
                else
                        lpPS->fSrcAspectIconOD = FALSE;

                // Does source specify OLEMISC_ONLYICONIC?
                if (lpOD->dwStatus & OLEMISC_ONLYICONIC)
                        lpPS->fSrcOnlyIconicOD = TRUE;
                else
                        lpPS->fSrcOnlyIconicOD = FALSE;

                // Get application name of source from auxusertype3 in the registration database
                LPOLESTR lpszAppName = NULL;
                if (OleRegGetUserType(lpPS->clsidOD, USERCLASSTYPE_APPNAME,
                        &lpszAppName) == NOERROR)
                {
                        lstrcpyn(lpPS->szAppName, lpszAppName, OLEUI_CCHKEYMAX);
                        OleStdFree(lpszAppName);
                }
                else
                {
                         if (0 == LoadString(_g_hOleStdResInst, IDS_PSUNKNOWNAPP, lpPS->szAppName,
                                PS_UNKNOWNSTRLEN))
                         {
                                 PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                                 return FALSE;
                         }
                }

                // Retrieve an icon from the object
                if (lpPS->fSrcAspectIconOD)
                {
                        lpPS->hMetaPictOD = OleStdGetData(
                                lpOPS->lpSrcDataObj,
                                (CLIPFORMAT) CF_METAFILEPICT,
                                NULL,
                                DVASPECT_ICON,
                                &medium
                        );

                }
                // If object does not offer icon, obtain it from the CLSID
                if (NULL == lpPS->hMetaPictOD)
                        lpPS->hMetaPictOD = OleGetIconOfClass(lpPS->clsidOD, NULL, TRUE);
        }

        // Does object offer CF_LINKSRCDESCRIPTOR?
        lpPS->hLinkSrcDesc = OleStdGetData(
                        lpOPS->lpSrcDataObj,
                        (CLIPFORMAT) _g_cfLinkSrcDescriptor,
                        NULL,
                        DVASPECT_CONTENT,
                        &medium);
        if (lpPS->hLinkSrcDesc)
        {
                // Get FullUserTypeName, SourceOfCopy and CLSID
                LPLINKSRCDESCRIPTOR lpLSD = (LPLINKSRCDESCRIPTOR)GlobalLock(lpPS->hLinkSrcDesc);
                if (lpLSD->dwFullUserTypeName)
                        lstrcpyn(lpPS->szFullUserTypeNameLSD, (LPTSTR)((LPBYTE)lpLSD+lpLSD->dwFullUserTypeName), PS_UNKNOWNNAMELEN);
                else
                        lstrcpyn(lpPS->szFullUserTypeNameLSD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);

                if (lpLSD->dwSrcOfCopy)
                        lstrcpyn(lpPS->szSourceOfDataLSD, (LPTSTR)((LPBYTE)lpLSD+lpLSD->dwSrcOfCopy), PS_UNKNOWNNAMELEN);
                else
                        lstrcpyn(lpPS->szSourceOfDataLSD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);

                // if no ObjectDescriptor, then use LinkSourceDescriptor source string
                if (!lpPS->hObjDesc)
                        lstrcpyn(lpPS->szSourceOfDataOD, lpPS->szSourceOfDataLSD, PS_UNKNOWNNAMELEN);

                lpPS->clsidLSD = lpLSD->clsid;
                lpPS->sizelLSD = lpLSD->sizel;

                // Does source specify DVASPECT_ICON?
                if (lpLSD->dwDrawAspect & DVASPECT_ICON)
                        lpPS->fSrcAspectIconLSD = TRUE;
                else
                        lpPS->fSrcAspectIconLSD = FALSE;

                // Does source specify OLEMISC_ONLYICONIC?
                if (lpLSD->dwStatus & OLEMISC_ONLYICONIC)
                        lpPS->fSrcOnlyIconicLSD = TRUE;
                else
                        lpPS->fSrcOnlyIconicLSD = FALSE;

                // Retrieve an icon from the object
                if (lpPS->fSrcAspectIconLSD)
                {
                        lpPS->hMetaPictLSD = OleStdGetData(
                                lpOPS->lpSrcDataObj,
                                CF_METAFILEPICT,
                                NULL,
                                DVASPECT_ICON,
                                &medium
                        );
                }
                // If object does not offer icon, obtain it from the CLSID
                if (NULL == lpPS->hMetaPictLSD)
                {
                        HWND hIconWnd = GetDlgItem(hDlg, IDC_PS_ICONDISPLAY);
                        RECT IconRect; GetClientRect(hIconWnd, &IconRect);

                        LPTSTR lpszLabel = OleStdCopyString(lpPS->szSourceOfDataLSD);
                        // width is 2 times width of iconbox because it can wrap
                        int nWidth = (IconRect.right-IconRect.left) * 2;
                        // limit text to the width or max characters
                        LPTSTR lpszChopLabel = ChopText(hIconWnd, nWidth, lpszLabel,
                                lstrlen(lpszLabel));
                        lpPS->hMetaPictLSD =
                                OleGetIconOfClass(lpPS->clsidLSD, lpszChopLabel, FALSE);
                        OleStdFree(lpszLabel);
                }
        }
        else if (lpPS->hObjDesc)     // Does not offer CF_LINKSRCDESCRIPTOR but offers CF_OBJECTDESCRIPTOR
        {
                // Copy the values of OBJECTDESCRIPTOR
                lstrcpyn(lpPS->szFullUserTypeNameLSD, lpPS->szFullUserTypeNameOD, PS_UNKNOWNNAMELEN);
                lstrcpyn(lpPS->szSourceOfDataLSD, lpPS->szSourceOfDataOD, PS_UNKNOWNNAMELEN);
                lpPS->clsidLSD = lpPS->clsidOD;
                lpPS->sizelLSD = lpPS->sizelOD;
                lpPS->fSrcAspectIconLSD = lpPS->fSrcAspectIconOD;
                lpPS->fSrcOnlyIconicLSD = lpPS->fSrcOnlyIconicOD;

                // Don't copy the hMetaPict; instead get a separate copy
                if (lpPS->fSrcAspectIconLSD)
                {
                        lpPS->hMetaPictLSD = OleStdGetData(
                                lpOPS->lpSrcDataObj,
                                CF_METAFILEPICT,
                                NULL,
                                DVASPECT_ICON,
                                &medium
                        );
                }
                if (NULL == lpPS->hMetaPictLSD)
                {
                        HWND hIconWnd = GetDlgItem(hDlg, IDC_PS_ICONDISPLAY);
                        RECT IconRect; GetClientRect(hIconWnd, &IconRect);

                        LPTSTR lpszLabel = OleStdCopyString(lpPS->szSourceOfDataLSD);
                        // width is 2 times width of iconbox because it can wrap
                        int nWidth = (IconRect.right-IconRect.left) * 2;
                        // limit text to the width or max characters
                        LPTSTR lpszChopLabel = ChopText(hIconWnd, nWidth, lpszLabel,
                                lstrlen(lpszLabel));
                        lpPS->hMetaPictLSD =
                                OleGetIconOfClass(lpPS->clsidLSD, lpszChopLabel, FALSE);
                        OleStdFree(lpszLabel);
                }
        }

        // Not an OLE object
        if (lpPS->hObjDesc == NULL && lpPS->hLinkSrcDesc == NULL)
        {
                 lstrcpyn(lpPS->szFullUserTypeNameLSD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);
                 lstrcpyn(lpPS->szFullUserTypeNameOD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);
                 lstrcpyn(lpPS->szSourceOfDataLSD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);
                 lstrcpyn(lpPS->szSourceOfDataOD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);
                 lpPS->hMetaPictLSD = lpPS->hMetaPictOD = NULL;
        }

        // Allocate scratch memory to construct item names in the paste and pastelink listboxes
        if (lpPS->hBuff != NULL)
        {
                GlobalFree(lpPS->hBuff);
                lpPS->hBuff = NULL;
        }

        lpPS->hBuff = AllocateScratchMem(lpPS);
        if (lpPS->hBuff == NULL)
        {
           PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
           return FALSE;
        }

        // Select the Paste Link Button if specified. Otherwise select
        //      Paste Button by default
        if (lpPS->dwFlags & PSF_SELECTPASTELINK)
                lpPS->dwFlags = (lpPS->dwFlags & ~PSF_SELECTPASTE) | PSF_SELECTPASTELINK;
        else
                lpPS->dwFlags =(lpPS->dwFlags & ~PSF_SELECTPASTELINK) | PSF_SELECTPASTE;

        // Mark which PasteEntry formats are available from source data object
        OleStdMarkPasteEntryList(
                        lpOPS->lpSrcDataObj, lpOPS->arrPasteEntries, lpOPS->cPasteEntries);

        // Check if items are available to be pasted
        BOOL fPasteAvailable = FFillPasteList(hDlg, lpPS);
        if (!fPasteAvailable)
                lpPS->dwFlags &= ~PSF_SELECTPASTE;
        StandardEnableDlgItem(hDlg, IDC_PS_PASTE, fPasteAvailable);

        // Check if items are available to be paste-linked
        BOOL fPasteLinkAvailable = FFillPasteLinkList(hDlg, lpPS);
        if (!fPasteLinkAvailable)
                lpPS->dwFlags &= ~PSF_SELECTPASTELINK;
        StandardEnableDlgItem(hDlg, IDC_PS_PASTELINK, fPasteLinkAvailable);

        // If one of Paste or PasteLink is disabled, select the other one
        //    regardless of what the input flags say
        if (fPasteAvailable && !fPasteLinkAvailable)
                lpPS->dwFlags |= PSF_SELECTPASTE;
        if (fPasteLinkAvailable && !fPasteAvailable)
                lpPS->dwFlags |= PSF_SELECTPASTELINK;

        BOOL bEnabled = TRUE;
        if (lpPS->dwFlags & PSF_SELECTPASTE)
        {
                // FTogglePaste will set the PSF_SELECTPASTE flag, so clear it.
                lpPS->dwFlags &= ~PSF_SELECTPASTE;
                CheckRadioButton(hDlg, IDC_PS_PASTE, IDC_PS_PASTELINK, IDC_PS_PASTE);
                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTE);
        }
        else if (lpPS->dwFlags & PSF_SELECTPASTELINK)
        {
                // FTogglePaste will set the PSF_SELECTPASTELINK flag, so clear it.
                lpPS->dwFlags &= ~PSF_SELECTPASTELINK;
                CheckRadioButton(hDlg, IDC_PS_PASTE, IDC_PS_PASTELINK, IDC_PS_PASTELINK);
                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTELINK);
        }
        else  // Items are not available to be be Pasted or Paste-Linked
        {
                // Enable or disable DisplayAsIcon and set the result text and image
                EnableDisplayAsIcon(hDlg, lpPS);
                SetPasteSpecialHelpResults(hDlg, lpPS);
                SetDlgItemText(hDlg, IDC_PS_SOURCETEXT, lpPS->szSourceOfDataOD);
                CheckRadioButton(hDlg, IDC_PS_PASTE, IDC_PS_PASTELINK, 0);
                bEnabled = FALSE;
        }
        StandardEnableDlgItem(hDlg, IDOK, bEnabled);

        return TRUE;
}

/*
 * FPasteSpecialInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Paste Special dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FPasteSpecialInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPPASTESPECIAL lpPS = (LPPASTESPECIAL)LpvStandardInit(hDlg, sizeof(PASTESPECIAL), &hFont);

        // PvStandardInit sent a termination to us already.
        if (NULL == lpPS)
                return FALSE;

        LPOLEUIPASTESPECIAL lpOPS = (LPOLEUIPASTESPECIAL)lParam;

        // Copy other information from lpOPS that we might modify.
        lpPS->lpOPS = lpOPS;
        lpPS->nIDD = IDD_PASTESPECIAL;
        lpPS->dwFlags = lpOPS->dwFlags;

        // If we got a font, send it to the necessary controls.
        if (NULL!=hFont)
        {
                SendDlgItemMessage(hDlg, IDC_PS_SOURCETEXT, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_PS_RESULTTEXT, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Hide the help button if required
        if (!(lpPS->lpOPS->dwFlags & PSF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Show or hide the Change icon button
        if (lpPS->dwFlags & PSF_HIDECHANGEICON)
                DestroyWindow(GetDlgItem(hDlg, IDC_PS_CHANGEICON));

        // Hide all DisplayAsIcon related controls if it should be disabled
        if (lpPS->dwFlags & PSF_DISABLEDISPLAYASICON)
        {
                StandardShowDlgItem(hDlg, IDC_PS_DISPLAYASICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
        }

        // clear PSF_CHECKDISPLAYASICON -> it's an output parameter only
        lpPS->dwFlags &= ~ PSF_CHECKDISPLAYASICON;

        // Change the caption if required
        if (NULL != lpOPS->lpszCaption)
                SetWindowText(hDlg, lpOPS->lpszCaption);

        // Load 'Unknown Source' and 'Unknown Type' strings
        int n = LoadString(_g_hOleStdResInst, IDS_PSUNKNOWNTYPE, lpPS->szUnknownType, PS_UNKNOWNSTRLEN);
        if (n)
                n = LoadString(_g_hOleStdResInst, IDS_PSUNKNOWNSRC, lpPS->szUnknownSource, PS_UNKNOWNSTRLEN);
        if (!n)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                return FALSE;
        }

        if (!FPasteSpecialReInit(hDlg, lpPS))
                return FALSE;

        // Give initial focus to the list box
        SetFocus(GetDlgItem(hDlg, IDC_PS_DISPLAYLIST));

        // Set property to handle clipboard change notifications
        SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
        SetProp(hDlg, NEXTCBVIEWER, SetClipboardViewer(hDlg));

        lpPS->fClipboardChanged = FALSE;

        /*
         * PERFORM OTHER INITIALIZATION HERE.
         */

        // Call the hook with lCustData in lParam
        UStandardHook(lpPS, hDlg, WM_INITDIALOG, wParam, lpOPS->lCustData);
        return TRUE;
}

/*
 * FTogglePasteType
 *
 * Purpose:
 *  Toggles between Paste and Paste Link. The Paste list and PasteLink
 *  list are always invisible. The Display List is filled from either
 *  the Paste list or the PasteLink list depending on which Paste radio
 *  button is selected.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *  dwOption        Paste or PasteSpecial option
 *
 * Return Value:
 *  BOOL            Returns TRUE if the option has already been selected.
 *                  Otherwise the option is selected and FALSE is returned
 */
BOOL FTogglePasteType(HWND hDlg, LPPASTESPECIAL lpPS, DWORD dwOption)
{
        DWORD dwTemp;
        HWND hList, hListDisplay;
        LRESULT dwData;
        int i, nItems;
        LPTSTR lpsz;

        // Skip all this if the button is already selected
        if (lpPS->dwFlags & dwOption)
                return TRUE;

        dwTemp = PSF_SELECTPASTE | PSF_SELECTPASTELINK;
        lpPS->dwFlags = (lpPS->dwFlags & ~dwTemp) | dwOption;

        // Hide IconDisplay. This prevents flashing if the icon display is changed
        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);

        hListDisplay = GetDlgItem(hDlg, IDC_PS_DISPLAYLIST);

        // If Paste was selected
        if (lpPS->dwFlags & PSF_SELECTPASTE)
        {
                // Set the Source of the object in the clipboard
                SetDlgItemText(hDlg, IDC_PS_SOURCETEXT, lpPS->szSourceOfDataOD);

                // If an icon is available
                if (lpPS->hMetaPictOD)
                        // Set the icon display
                        SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGESET,
                                  0, (LPARAM)lpPS->hMetaPictOD);

                hList = GetDlgItem(hDlg, IDC_PS_PASTELIST);
                // We are switching from PasteLink to Paste. Remember current selection
                //    in PasteLink list so it can be restored.
                lpPS->nPasteLinkListCurSel = (int)SendMessage(hListDisplay, LB_GETCURSEL, 0, 0L);
                if (lpPS->nPasteLinkListCurSel == LB_ERR)
                        lpPS->nPasteLinkListCurSel = 0;
                // Remember if user selected Paste or PasteLink
                lpPS->fLink = FALSE;
        }
        else    // If PasteLink was selected
        {
                // Set the Source of the object in the clipboard
                SetDlgItemText(hDlg, IDC_PS_SOURCETEXT, lpPS->szSourceOfDataLSD);

                // If an icon is available
                if (lpPS->hMetaPictLSD)
                        // Set the icon display
                        SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGESET,
                                  0, (LPARAM)lpPS->hMetaPictLSD);

                hList = GetDlgItem(hDlg, IDC_PS_PASTELINKLIST);
                // We are switching from Paste to PasteLink. Remember current selection
                //    in Paste list so it can be restored.
                lpPS->nPasteListCurSel = (int)SendMessage(hListDisplay, LB_GETCURSEL, 0, 0L);
                if (lpPS->nPasteListCurSel == LB_ERR)
                        lpPS->nPasteListCurSel = 0;
                // Remember if user selected Paste or PasteLink
                lpPS->fLink = TRUE;
        }

        // Turn drawing off while the Display List is being filled
        SendMessage(hListDisplay, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        // Move data to Display list box
        SendMessage(hListDisplay, LB_RESETCONTENT, 0, 0L);
        nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);
        lpsz = (LPTSTR)GlobalLock(lpPS->hBuff);
        for (i = 0; i < nItems; i++)
        {
                SendMessage(hList, LB_GETTEXT, (WPARAM)i, (LPARAM)lpsz);
                dwData = SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
                SendMessage(hListDisplay, LB_INSERTSTRING, (WPARAM)i, (LPARAM)lpsz);
                SendMessage(hListDisplay, LB_SETITEMDATA, (WPARAM)i, dwData);
        }
        GlobalUnlock(lpPS->hBuff);

        // Restore the selection in the Display List from user's last selection
        if (lpPS->dwFlags & PSF_SELECTPASTE)
                SendMessage(hListDisplay, LB_SETCURSEL, lpPS->nPasteListCurSel, 0L);
        else
                SendMessage(hListDisplay, LB_SETCURSEL, lpPS->nPasteLinkListCurSel, 0L);

        // Paint Display List
        SendMessage(hListDisplay, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        InvalidateRect(hListDisplay, NULL, TRUE);
        UpdateWindow(hListDisplay);

        // Auto give the focus to the Display List
        if (GetForegroundWindow() == hDlg)
                SetFocus(hListDisplay);

        // Enable/Disable DisplayAsIcon and set the help result text and bitmap corresponding to
        //    the current selection
        ChangeListSelection(hDlg, lpPS, hListDisplay);

        return FALSE;
}

/*
 * ChangeListSelection
 *
 * Purpose:
 *  When the user changes the selection in the list, DisplayAsIcon is enabled or disabled,
 *  Result text and bitmap are updated and the index of the arrPasteEntries[] corresponding
 *  to the current format selection is saved.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *  hList           HWND of the List
 *
 * Return Value:
 *  No return value
 */
void ChangeListSelection(HWND hDlg, LPPASTESPECIAL lpPS, HWND hList)
{
        LPPASTELISTITEMDATA lpItemData;
        int nCurSel;

        EnableDisplayAsIcon(hDlg, lpPS);
        SetPasteSpecialHelpResults(hDlg, lpPS);

        // Remember index of arrPasteEntries[] corresponding to the current selection
        nCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        if (nCurSel == LB_ERR)
                return;
        lpItemData = (LPPASTELISTITEMDATA) SendMessage(hList, LB_GETITEMDATA,
                                (WPARAM)nCurSel, 0L);
        if ((LRESULT)lpItemData == LB_ERR)
                return;
        lpPS->nSelectedIndex = lpItemData->nPasteEntriesIndex;
}

/*
 * EnableDisplayAsIcon
 *
 * Purpose:
 *  Enable or disable the DisplayAsIcon button depending on whether
 *  the current selection can be displayed as an icon or not. The following table describes
 *  the state of DisplayAsIcon. The calling application is termed CONTAINER, the source
 *  of data on the clipboard is termed SOURCE.
 *  Y = Yes; N = No; Blank = State does not matter;
 * =====================================================================
 * SOURCE          SOURCE             CONTAINER             DisplayAsIcon
 * specifies       specifies          specifies             Initial State
 * DVASPECT_ICON   OLEMISC_ONLYICONIC OLEUIPASTE_ENABLEICON
 *
 *                                    N                     Unchecked&Disabled
 *                 Y                  Y                     Checked&Disabled
 * Y               N                  Y                     Checked&Enabled
 * N               N                  Y                     Unchecked&Enabled
 * =====================================================================
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  No return value
 */
void EnableDisplayAsIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
        int nIndex;
        BOOL fCntrEnableIcon;
        BOOL fSrcOnlyIconic = (lpPS->fLink) ? lpPS->fSrcOnlyIconicLSD : lpPS->fSrcOnlyIconicOD;
        BOOL fSrcAspectIcon = (lpPS->fLink) ? lpPS->fSrcAspectIconLSD : lpPS->fSrcAspectIconOD;
        HWND hList;
        LPPASTELISTITEMDATA lpItemData;
        HGLOBAL hMetaPict = (lpPS->fLink) ? lpPS->hMetaPictLSD : lpPS->hMetaPictOD;

        hList = GetDlgItem(hDlg, IDC_PS_DISPLAYLIST);

        // Get data corresponding to the current selection in the listbox
        nIndex = (int)SendMessage(hList, LB_GETCURSEL, 0, 0);
        if (nIndex != LB_ERR)
        {
                lpItemData = (LPPASTELISTITEMDATA) SendMessage(hList, LB_GETITEMDATA, (WPARAM)nIndex, 0L);
                if ((LRESULT)lpItemData != LB_ERR)
                        fCntrEnableIcon = lpItemData->fCntrEnableIcon;
                else fCntrEnableIcon = FALSE;
        }
        else fCntrEnableIcon = FALSE;

        // If there is an icon available
        if (hMetaPict != NULL)
        {
                if (!fCntrEnableIcon)          // Does CONTAINER specify OLEUIPASTE_ENABLEICON?
                {
                        // Uncheck & Disable DisplayAsIcon
                        lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
                        CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, FALSE);
                        StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, FALSE);

                        // Hide IconDisplay and ChangeIcon button
                        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
                        StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);
                }
                else if (fSrcOnlyIconic)       // Does SOURCE specify OLEMISC_ONLYICONIC?
                {
                        // Check & Disable DisplayAsIcon
                        lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
                        CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, TRUE);
                        StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, FALSE);

                        // Show IconDisplay and ChangeIcon button
                        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_SHOWNORMAL);
                        StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_SHOWNORMAL);
                }
                else if (fSrcAspectIcon)       // Does SOURCE specify DVASPECT_ICON?
                {
                         // Check & Enable DisplayAsIcon
                         lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
                         CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, TRUE);
                         StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, TRUE);

                         // Show IconDisplay and ChangeIcon button
                         StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_SHOWNORMAL);
                         StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_SHOWNORMAL);
                }
                else
                {
                         //Uncheck and Enable DisplayAsIcon
                         lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
                         CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, FALSE);
                         StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, TRUE);

                         // Hide IconDisplay and ChangeIcon button
                         StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
                         StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);

                }
        }
        else  // No icon available
        {
                // Unchecked & Disabled
                lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
                CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, FALSE);
                StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, FALSE);

                // Hide IconDisplay and ChangeIcon button
                StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);
        }
}

/*
 * ToggleDisplayAsIcon
 *
 * Purpose:
 *  Toggles the DisplayAsIcon button. Hides or shows the Icon Display and
 *  the ChangeIcon button and changes the help result text and bitmap.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  None
 *
 */
void ToggleDisplayAsIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
        BOOL fCheck;
        int i;

        fCheck = IsDlgButtonChecked(hDlg, IDC_PS_DISPLAYASICON);

        if (fCheck)
                lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
        else lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;

        // Set the help result text and bitmap
        SetPasteSpecialHelpResults(hDlg, lpPS);

        // Show or hide the Icon Display and ChangeIcon button depending
        // on the check state
        i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, i);
        StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, i);
}

/*
 * ChangeIcon
 *
 * Purpose:
 *  Brings up the ChangeIcon dialog which allows the user to change
 *  the icon and label.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  None
 *
 */

void ChangeIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
        OLEUICHANGEICON ci;
        UINT uRet;
        CLSID   clsid     = (lpPS->fLink) ? lpPS->clsidLSD : lpPS->clsidOD;

        //Initialize the structure
        memset((LPOLEUICHANGEICON)&ci, 0, sizeof(ci));

        ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY,
                IBXM_IMAGEGET, 0, 0L);
        ci.cbStruct = sizeof(ci);
        ci.hWndOwner = hDlg;
        ci.clsid = clsid;
        ci.dwFlags  = CIF_SELECTCURRENT;

        // Only show help in the ChangeIcon dialog if we're showing it in this dialog.
        if (lpPS->dwFlags & PSF_SHOWHELP)
                ci.dwFlags |= CIF_SHOWHELP;

        // Let the hook in to customize Change Icon if desired.
        uRet = UStandardHook(lpPS, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);

        if (0 == uRet)
                uRet=(UINT)(OLEUI_OK==OleUIChangeIcon(&ci));

        // Update the display if necessary.
        if (0!=uRet)
        {
                /*
                * OleUIChangeIcon will have already freed our
                * current hMetaPict that we passed in when OK is
                * pressed in that dialog.  So we use 0L as lParam
                * here so the IconBox doesn't try to free the
                * metafilepict again.
                */
                SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY,
                        IBXM_IMAGESET, 0, (LPARAM)ci.hMetaPict);
                // Remember the new icon chosen by the user. Note that Paste and PasteLink have separate
                //    icons - changing one does not change the other.
                if (lpPS->fLink)
                        lpPS->hMetaPictLSD = ci.hMetaPict;
                else
                        lpPS->hMetaPictOD = ci.hMetaPict;
        }
}

/*
 *SetPasteSpecialHelpResults
 *
 * Purpose:
 *  Sets the help result text and bitmap according to the current
 *  list selection. The following state table indicates which ResultText
 *  and ResultImage are selected. If %s in the lpstrFormatName is present,
 *  it is assumed that an object is being pasted/paste-linked, otherwise it
 *  is assumed that data is being pasted/paste-linked.
 *  Y = Yes; N = No; Blank = State does not matter;
 *  The numbers in the the ResultText and ResultImage columns refer to the table
 *  entries that follow.
 * =====================================================================
 * Paste/       lpstrFormatName in                DisplayAsIcon Result      Result
 * PasteLink    arrPasteEntry[]contains %s        checked       Text        Image
 *              (Is Object == Y, Is Data == N)
 * Paste        N                                               1           1
 * Paste        Y                                 N             2           2
 * Paste        Y                                 Y             3           3
 * PasteLink    N                                               4           4
 * PasteLink    Y                                 N             5           4
 * PasteLink    Y                                 Y             6           5
 * =====================================================================
 * Result Text:
 *
 * 1. "Inserts the contents of the Clipboard into your document as <native type name,
 *     and optionally an additional help sentence>"
 * 2. "Inserts the contents of the Clipboard into your document so that you may
 *     activate it using <object app name>"
 * 3. "Inserts the contents of the Clipboard into your document so that you may
 *     activate it using <object app name>.  It will be displayed as an icon."
 * 4. "Inserts the contents of the Clipboard into your document as <native type name>.
 *     Paste Link creates a link to the source file so that changes to the source file
 *     will be reflected in your document."
 * 5. "Inserts a picture of the Clipboard contents into your document.  Paste Link
 *     creates a link to the source file so that changes to the source file will be
 *     reflected in your document."
 * 6. "Inserts an icon into your document which represents the Clipboard contents.
 *     Paste Link creates a link to the source file so that changes to the source file
 *     will be reflected in your document."
 * =====================================================================
 * Result Image:
 *
 * 1. Clipboard Image
 * 2. Paste image, non-iconic.
 * 3. Paste image, iconic.
 * 4. Paste Link image, non-iconic
 * 5. Paste Link image, iconic
 * ====================================================================
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  No return value
 */
void SetPasteSpecialHelpResults(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPTSTR          psz1, psz2, psz3, psz4;
        UINT            i, iString, iImage, cch;
        int             nPasteEntriesIndex;
        BOOL            fDisplayAsIcon;
        BOOL            fIsObject;
        HWND            hList;
        LPPASTELISTITEMDATA  lpItemData;
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        LPTSTR          szFullUserTypeName = (lpPS->fLink) ?
                                        lpPS->szFullUserTypeNameLSD : lpPS->szFullUserTypeNameOD;
        LPTSTR          szInsert;

        hList = GetDlgItem(hDlg, IDC_PS_DISPLAYLIST);

        i=(UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        if (i != LB_ERR)
        {
                lpItemData = (LPPASTELISTITEMDATA)SendMessage(hList, LB_GETITEMDATA, i, 0L);
                if ((LRESULT)lpItemData == LB_ERR) return;
                nPasteEntriesIndex = lpItemData->nPasteEntriesIndex;
                // Check if there is a '%s' in the lpstrFormatName, then an object is being
                //   pasted/pastelinked. Otherwise Data is being pasted-pastelinked.
                fIsObject = FHasPercentS(lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrFormatName,
                                                                                lpPS);
        }
        else
            return;

        // Is DisplayAsIcon checked?
        fDisplayAsIcon=(0L!=(lpPS->dwFlags & PSF_CHECKDISPLAYASICON));

        szInsert = szFullUserTypeName;

        if (lpPS->dwFlags & PSF_SELECTPASTE)     // If user selected Paste
        {
                if (fIsObject)
                {
                        iString = fDisplayAsIcon ? IDS_PSPASTEOBJECTASICON : IDS_PSPASTEOBJECT;
                        iImage  = fDisplayAsIcon ? RESULTIMAGE_EMBEDICON   : RESULTIMAGE_EMBED;
                        szInsert = lpPS->szAppName;
                }
                else
                {
                        iString = IDS_PSPASTEDATA;
                        iImage  = RESULTIMAGE_PASTE;
                }
        }
        else if (lpPS->dwFlags & PSF_SELECTPASTELINK)   // User selected PasteLink
        {
                if (fIsObject)
                {
                        iString = fDisplayAsIcon ? IDS_PSPASTELINKOBJECTASICON : IDS_PSPASTELINKOBJECT;
                        iImage  = fDisplayAsIcon ? RESULTIMAGE_LINKICON : RESULTIMAGE_LINK;
                }
                else
                {
                        iString = IDS_PSPASTELINKDATA;
                        iImage  = RESULTIMAGE_LINK;
                }

        }
        else   // Should never occur.
        {
                iString = IDS_PSNONOLE;
                iImage = RESULTIMAGE_PASTE;
        }

        // hBuff contains enough space for the 4 buffers required to build up the help
        //   result text.
        cch = (UINT)(GlobalSize(lpPS->hBuff) / sizeof(TCHAR)) / 4;

        psz1 = (LPTSTR)GlobalLock(lpPS->hBuff);
        psz2 = psz1 + cch;
        psz3 = psz2 + cch;
        psz4 = psz3 + cch;

        // Default is an empty string.
        *psz1 = 0;

        if (0 != LoadString(_g_hOleStdResInst, iString, psz1, cch) &&
                nPasteEntriesIndex != -1)
        {
                // Insert the FullUserTypeName of the source object into the partial result text
                //   specified by the container.
                StringCchPrintf(psz3, cch, lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrResultText,
                        (LPTSTR)szInsert);
                // Insert the above partial result text into the standard result text.
                StringCchPrintf(psz4, cch, psz1, (LPTSTR)psz3);
                psz1 = psz4;
        }

        // If LoadString failed, we simply clear out the results (*psz1 = 0 above)
        SetDlgItemText(hDlg, IDC_PS_RESULTTEXT, psz1);

        GlobalUnlock(lpPS->hBuff);

        // Change the result bitmap
        SendDlgItemMessage(hDlg, IDC_PS_RESULTIMAGE, RIM_IMAGESET, iImage, 0L);
}

/*
 * FAddPasteListItem
 *
 * Purpose:
 *  Adds an item to the list box
 *
 * Parameters:
 *  hList            HWND List into which item is to be added
 *  fInsertFirst     BOOL Insert in the beginning of the list?
 *  nPasteEntriesIndex int Index of Paste Entry array this list item corresponsds to
 *  lpPS             Paste Special Dialog Structure
 *  lpszBuf          LPSTR Scratch buffer to build up string for list entry
 *  lpszFullUserTypeName LPSTR full user type name for object entry
 *
 * Return Value:
 *  BOOL            TRUE if sucessful.
 *                  FALSE if unsucessful.
 */
BOOL FAddPasteListItem(
                HWND hList, BOOL fInsertFirst, int nPasteEntriesIndex,
                LPPASTESPECIAL lpPS, LPTSTR lpszBuf, UINT cchBuf, LPTSTR lpszFullUserTypeName)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        LPPASTELISTITEMDATA lpItemData;
        int                 nIndex;

        // Allocate memory for each list box item
        lpItemData = (LPPASTELISTITEMDATA)OleStdMalloc(sizeof(PASTELISTITEMDATA));
        if (NULL == lpItemData)
                return FALSE;

        // Fill data associated with each list box item
        lpItemData->nPasteEntriesIndex = nPasteEntriesIndex;
        lpItemData->fCntrEnableIcon = ((lpOPS->arrPasteEntries[nPasteEntriesIndex].dwFlags &
                        OLEUIPASTE_ENABLEICON) ? TRUE : FALSE);

        // Build list box entry string, insert the string and add the data the corresponds to it
        StringCchPrintf(
                        lpszBuf, cchBuf,
                        lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrFormatName,
                        lpszFullUserTypeName
        );

        // only add to listbox if not a duplicate
        if (LB_ERR!=SendMessage(hList,LB_FINDSTRING, 0, (LPARAM)lpszBuf))
        {
                // item is already in list; SKIP this one
                OleStdFree((LPVOID)lpItemData);
                return TRUE;    // this is NOT an error
        }

        nIndex = (int)SendMessage(
                        hList,
                        (fInsertFirst ? LB_INSERTSTRING : LB_ADDSTRING),
                        0,
                        (LPARAM)lpszBuf
        );
        SendMessage(
                        hList,
                        LB_SETITEMDATA,
                        nIndex,
                        (LPARAM)(LPPASTELISTITEMDATA)lpItemData
        );
        return TRUE;
}


/*
 * FFillPasteList
 *
 * Purpose:
 *  Fills the invisible paste list with the formats offered by the clipboard object and
 *  asked for by the container.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  BOOL            TRUE if sucessful and if formats could be found.
 *                  FALSE if unsucessful or if no formats could be found.
 */
BOOL FFillPasteList(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        HWND                hList;
        int                 i, j;
        int                 nItems = 0;
        int                 nDefFormat = -1;
        BOOL                fTryObjFmt = FALSE;
        BOOL                fInsertFirst;
        BOOL                fExclude;

        hList = GetDlgItem(hDlg, IDC_PS_PASTELIST);
        SendMessage(hList, LB_RESETCONTENT, 0, 0);

        // Loop over the target's priority list of formats
        for (i = 0; i < lpOPS->cPasteEntries; i++)
        {
                if (lpOPS->arrPasteEntries[i].dwFlags != OLEUIPASTE_PASTEONLY &&
                                !(lpOPS->arrPasteEntries[i].dwFlags & OLEUIPASTE_PASTE))
                        continue;

                fInsertFirst = FALSE;

                if (lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfFileName
                                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfEmbeddedObject
                                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfEmbedSource)
                {
                        if (! fTryObjFmt)
                        {
                                fTryObjFmt = TRUE;      // only use 1st object format
                                fInsertFirst = TRUE;    // OLE obj format should always be 1st

                                //Check if this CLSID is in the exclusion list.
                                fExclude=FALSE;

                                for (j=0; j < (int)lpOPS->cClsidExclude; j++)
                                {
                                        if (IsEqualCLSID(lpPS->clsidOD, lpOPS->lpClsidExclude[j]))
                                        {
                                                fExclude=TRUE;
                                                break;
                                        }
                                }

                                if (fExclude)
                                        continue;   // don't add the object entry to list

                        }
                        else
                        {
                                continue;   // already added an object format to list
                        }
                }

                // add to list if entry is marked TRUE
                if (lpOPS->arrPasteEntries[i].dwScratchSpace)
                {
                        if (nDefFormat < 0)
                                nDefFormat = (fInsertFirst ? 0 : nItems);
                        else if (fInsertFirst)
                                nDefFormat++;   // adjust for obj fmt inserted 1st in list

                        LPTSTR lpszBuf  = (LPTSTR)GlobalLock(lpPS->hBuff);
                        if (lpszBuf)
                        {
                            UINT cchMax = (UINT)GlobalSize(lpPS->hBuff) / sizeof (TCHAR);
                            if (!FAddPasteListItem(hList, fInsertFirst, i, lpPS,
                                    lpszBuf, cchMax, lpPS->szFullUserTypeNameOD))
                            {
                                GlobalUnlock(lpPS->hBuff);
                                goto error;
                            }
                            GlobalUnlock(lpPS->hBuff);
                        }
                        nItems++;
                }
        }

        // initialize selection to first format matched in list
        if (nDefFormat >= 0)
                lpPS->nPasteListCurSel = nDefFormat;

        // Clean up

        // If no items have been added to the list box (none of the formats
        //   offered by the source matched those acceptable to the container),
        //   return FALSE
        if (nItems > 0)
                return TRUE;
        else
                return FALSE;

error:
        FreeListData(hList);

        return FALSE;
}


/*
 * FFillPasteLinkList
 *
 * Purpose:
 *  Fills the invisible paste link list with the formats offered by the clipboard object and
 *  asked for by the container.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  BOOL            TRUE if sucessful and if formats could be found.
 *                  FALSE if unsucessful or if no formats could be found.
 */
BOOL FFillPasteLinkList(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS        = lpPS->lpOPS;
        LPDATAOBJECT        lpSrcDataObj = lpOPS->lpSrcDataObj;
        LPENUMFORMATETC     lpEnumFmtEtc = NULL;
        OLEUIPASTEFLAG      pasteFlag;
        UINT arrLinkTypesSupported[PS_MAXLINKTYPES];  // Array of flags that
                                                                                                  // indicate which link types
                                                                                                  // are supported by source.
        FORMATETC           fmtetc;
        int                 i, j;
        int                 nItems = 0;
        BOOL                fLinkTypeSupported = FALSE;
        HWND                hList;
        int                 nDefFormat = -1;
        BOOL                fTryObjFmt = FALSE;
        BOOL                fInsertFirst;
        HRESULT             hrErr;

        // Remember which link type formats are offered by lpSrcDataObj.
        memset(&fmtetc, 0, sizeof(FORMATETC));
        for (i = 0; i < lpOPS->cLinkTypes; i++)
        {
                if (lpOPS->arrLinkTypes[i] == _g_cfLinkSource)
                {
                        OLEDBG_BEGIN2(TEXT("OleQueryLinkFromData called\r\n"))
                        hrErr = OleQueryLinkFromData(lpSrcDataObj);
                        OLEDBG_END2
                        if(NOERROR == hrErr)
                        {
                                arrLinkTypesSupported[i] = 1;
                                fLinkTypeSupported = TRUE;
                        }
                        else
                                arrLinkTypesSupported[i] = 0;
                }
                else
                {
                        fmtetc.cfFormat = (CLIPFORMAT)lpOPS->arrLinkTypes[i];
                        fmtetc.dwAspect = DVASPECT_CONTENT;
                        fmtetc.tymed    = 0xFFFFFFFF;       // All tymed values
                        fmtetc.lindex   = -1;
                        OLEDBG_BEGIN2(TEXT("IDataObject::QueryGetData called\r\n"))
                        hrErr = lpSrcDataObj->QueryGetData(&fmtetc);
                        OLEDBG_END2
                        if(NOERROR == hrErr)
                        {
                                arrLinkTypesSupported[i] = 1;
                                fLinkTypeSupported = TRUE;
                        }
                        else arrLinkTypesSupported[i] = 0;
                }
        }
        // No link types are offered by lpSrcDataObj
        if (! fLinkTypeSupported)
        {
                nItems = 0;
                goto cleanup;
        }

        hList = GetDlgItem(hDlg, IDC_PS_PASTELINKLIST);
        SendMessage(hList, LB_RESETCONTENT, 0, 0);

        // Enumerate the formats acceptable to container
        for (i = 0; i < lpOPS->cPasteEntries; i++)
        {
                fLinkTypeSupported = FALSE;

                // If container will accept any link type offered by source object
                if (lpOPS->arrPasteEntries[i].dwFlags & OLEUIPASTE_LINKANYTYPE)
                        fLinkTypeSupported = TRUE;
                else
                {
                        // Check if any of the link types offered by the source
                        //    object are acceptable to the container
                        // This code depends on the LINKTYPE enum values being powers of 2
                        for (pasteFlag = OLEUIPASTE_LINKTYPE1, j = 0;
                                 j < lpOPS->cLinkTypes;
                                 (UINT&)pasteFlag *= 2, j++)
                        {
                                if ((lpOPS->arrPasteEntries[i].dwFlags & pasteFlag) &&
                                                arrLinkTypesSupported[j])
                                {
                                        fLinkTypeSupported = TRUE;
                                        break;
                                }
                        }
                }

                fInsertFirst = FALSE;

                if (lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfFileName
                                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfLinkSource)
                                {
                        if (! fTryObjFmt)
                        {
                                fTryObjFmt = TRUE;      // only use 1st object format
                                fInsertFirst = TRUE;    // OLE obj format should always be 1st
                        }
                        else
                        {
                                continue;   // already added an object format to list
                        }
                }

                // add to list if entry is marked TRUE
                if (fLinkTypeSupported && lpOPS->arrPasteEntries[i].dwScratchSpace)
                {
                        if (nDefFormat < 0)
                                nDefFormat = (fInsertFirst ? 0 : nItems);
                        else if (fInsertFirst)
                                nDefFormat++;   // adjust for obj fmt inserted 1st in list

                        LPTSTR lpszBuf  = (LPTSTR)GlobalLock(lpPS->hBuff);
                        if (lpszBuf)
                        {
                            UINT cchMax = (UINT)GlobalSize(lpPS->hBuff) / sizeof(TCHAR);
                            if (!FAddPasteListItem(hList, fInsertFirst, i, lpPS,
                                            lpszBuf, cchMax, lpPS->szFullUserTypeNameLSD))
                            {
                                GlobalUnlock(lpPS->hBuff);
                                goto error;
                            }
                            GlobalUnlock(lpPS->hBuff);
                        }
                        nItems++;
                }
        } // end FOR

        nItems = (int)SendMessage(hList, LB_GETCOUNT, 0, 0L);

        // initialize selection to first format matched in list
        if (nDefFormat >= 0)
                lpPS->nPasteLinkListCurSel = nDefFormat;

cleanup:
        // Clean up

        // If no items have been added to the list box (none of the formats
        //   offered by the source matched those acceptable to the destination),
        //   return FALSE
        if (nItems > 0)
                return TRUE;
        else
                return FALSE;

error:
        FreeListData(hList);

        return FALSE;
}

/*
 * FreeListData
 *
 * Purpose:
 *  Free the local memory associated with each list box item
 *
 * Parameters:
 *  hList           HWND of the list
 *
 * Return Value:
 *  None
 */
void FreeListData(HWND hList)
{
        int                nItems, i;
        LPPASTELISTITEMDATA lpItemData;

        nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);
        for (i = 0; i < nItems; i++)
        {
                lpItemData = (LPPASTELISTITEMDATA)SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
                if ((LRESULT)lpItemData != LB_ERR)
                        OleStdFree((LPVOID)lpItemData);
        }
}

/*
 * FHasPercentS
 *
 * Purpose:
 *  Determines if string contains %s.
 *
 * Parameters:
 *  lpsz            LPCSTR string in which occurence of '%s' is looked for
 *
 * Return Value:
 *  BOOL            TRUE if %s is found, else FALSE.
 */
BOOL FHasPercentS(LPCTSTR lpsz, LPPASTESPECIAL lpPS)
{
   int n = 0;
   LPTSTR lpszTmp;

   if (!lpsz) return FALSE;
   // Copy input string to buffer. This allows caller to pass a
   //   code-based string. Code segments may be swapped out in low memory situations
   //   and so code-based strings need to be copied before string elements can be accessed.
   lpszTmp = (LPTSTR)GlobalLock(lpPS->hBuff);
   UINT cchMax = (UINT)GlobalSize(lpPS->hBuff)/sizeof(TCHAR);
   StringCchCopy(lpszTmp, cchMax, lpsz);

   while (*lpszTmp)
   {
           if (*lpszTmp == '%')
           {
                   lpszTmp = CharNext(lpszTmp);
                   if (*lpszTmp == 's')     // if %s, return
                   {
                           GlobalUnlock(lpPS->hBuff);
                           return TRUE;
                   }
                   else if (*lpszTmp == '%')    // if %%, skip to next character
                           lpszTmp = CharNext(lpszTmp);
           }
           else
                  lpszTmp = CharNext(lpszTmp);
   }

   GlobalUnlock(lpPS->hBuff);
   return FALSE;
}

/*
 * AllocateScratchMem
 *
 * Purpose:
 *  Allocates scratch memory for use by the PasteSpecial dialog. The memory is
 *  is used as the buffer for building up strings using wsprintf. Strings are built up
 *  using the buffer while inserting items into the Paste & PasteLink lists and while
 *  setting the help result text. It must be big  enough to handle the string that results after
 *  replacing the %s in the lpstrFormatName and lpstrResultText in arrPasteEntries[]
 *  by the FullUserTypeName. It must also be big enough to build the dialog's result text
 *  after %s substitutions by the FullUserTypeName or the ApplicationName.
 *
 * Parameters:
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  HGLOBAL         Handle to allocated global memory
 */
HGLOBAL AllocateScratchMem(LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        int nLen, i;
        int nSubstitutedText = 0;
        int nAlloc = 0;

        // Get the maximum length of the FullUserTypeNames specified by OBJECTDESCRIPTOR
        //   and the LINKSRCDESCRIPTOR and the Application Name. Any of these may be substituted
        //   for %s in the result-text/list entries.
        if (lpPS->szFullUserTypeNameOD)
                nSubstitutedText = lstrlen(lpPS->szFullUserTypeNameOD);
        if (lpPS->szFullUserTypeNameLSD)
                nSubstitutedText = __max(nSubstitutedText, lstrlen(lpPS->szFullUserTypeNameLSD));
        if (lpPS->szAppName)
                nSubstitutedText = __max(nSubstitutedText, lstrlen(lpPS->szAppName));

        // Get the maximum length of lpstrFormatNames & lpstrResultText in arrPasteEntries
        nLen = 0;
        for (i = 0; i < lpOPS->cPasteEntries; i++)
        {
           nLen = max(nLen, lstrlen(lpOPS->arrPasteEntries[i].lpstrFormatName));
           nLen = max(nLen, lstrlen(lpOPS->arrPasteEntries[i].lpstrResultText));
        }

        // Get the maximum length of lpstrFormatNames and lpstrResultText after %s  has
        //   been substituted (At most one %s can appear in each string).
        //   Add 1 to hold NULL terminator.
        nAlloc = (nLen+nSubstitutedText+1)*sizeof(TCHAR);

        // Allocate scratch memory to be used to build strings
        // nAlloc is big enough to hold any of the lpstrResultText or lpstrFormatName in arrPasteEntries[]
        //   after %s substitution.
        // We also need space to build up the help result text. 512 is the maximum length of the
        //   standard dialog help text before substitutions. 512+nAlloc is the maximum length
        //   after %s substition.
        // SetPasteSpecialHelpResults() requires 4 such buffers to build up the result text
        return GlobalAlloc(GHND, (DWORD)4*(512 * sizeof(TCHAR) + nAlloc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\olestd.cpp ===
/*************************************************************************
**
**    OLE 2 Standard Utilities
**
**    olestd.c
**
**    This file contains utilities that are useful for most standard
**        OLE 2.0 compound document type applications.
**
**    (c) Copyright Microsoft Corp. 1992 All Rights Reserved
**
*************************************************************************/

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include <stdlib.h>
#include <shellapi.h>
#include <wchar.h>
#include <reghelp.hxx>

OLEDBGDATA

#ifdef _DEBUG
static TCHAR szAssertMemAlloc[] = TEXT("CoGetMalloc failed");
#endif

static int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight);

/* OleStdInitialize
** ----------------
**    Call to initialize this library sample code
**
*/

UINT _g_cfObjectDescriptor;
UINT _g_cfLinkSrcDescriptor;
UINT _g_cfEmbedSource;
UINT _g_cfEmbeddedObject;
UINT _g_cfLinkSource;
UINT _g_cfOwnerLink;
UINT _g_cfFileName;
UINT _g_cfFileNameW;

HINSTANCE _g_hOleStdInst;
HINSTANCE _g_hOleStdResInst;

#pragma code_seg(".text$initseg")

STDAPI_(void) OleStdInitialize(HINSTANCE hInstance, HINSTANCE hResInstance)
{
        _g_hOleStdInst = hInstance;
        _g_hOleStdResInst = hResInstance ? hResInstance : hInstance;

        _g_cfObjectDescriptor  = RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);
        _g_cfLinkSrcDescriptor = RegisterClipboardFormat(CF_LINKSRCDESCRIPTOR);
        _g_cfEmbedSource       = RegisterClipboardFormat(CF_EMBEDSOURCE);
        _g_cfEmbeddedObject    = RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
        _g_cfLinkSource        = RegisterClipboardFormat(CF_LINKSOURCE);
        _g_cfOwnerLink         = RegisterClipboardFormat(CF_OWNERLINK);
        _g_cfFileName          = RegisterClipboardFormat(CF_FILENAME);
        _g_cfFileNameW         = RegisterClipboardFormat(CF_FILENAMEW);
}

#pragma code_seg()

/* OleStdIsOleLink
** ---------------
**    Returns TRUE if the OleObject is infact an OLE link object. this
**    checks if IOleLink interface is supported. if so, the object is a
**    link, otherwise not.
*/
STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk)
{
        LPUNKNOWN lpOleLink;
        lpOleLink = OleStdQueryInterface(lpUnk, IID_IOleLink);
        if (lpOleLink)
        {
                OleStdRelease(lpOleLink);
                return TRUE;
        }
        return FALSE;
}


/* OleStdQueryInterface
** --------------------
**    Returns the desired interface pointer if exposed by the given object.
**    Returns NULL if the interface is not available.
**    eg.:
**      lpDataObj = OleStdQueryInterface(lpOleObj, &IID_DataObject);
*/
STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid)
{
        LPUNKNOWN lpInterface;
        HRESULT hrErr;

        hrErr = lpUnk->QueryInterface(
                        riid,
                        (LPVOID FAR*)&lpInterface
        );

        if (hrErr == NOERROR)
                return lpInterface;
        else
                return NULL;
}


/* OleStdGetData
** -------------
**    Retrieve data from an IDataObject in a specified format on a
**    global memory block. This function ALWAYS returns a private copy
**    of the data to the caller. if necessary a copy is made of the
**    data (ie. if lpMedium->pUnkForRelease != NULL). The caller assumes
**    ownership of the data block in all cases and must free the data
**    when done with it. The caller may directly free the data handle
**    returned (taking care whether it is a simple HGLOBAL or a HANDLE
**    to a MetafilePict) or the caller may call
**    ReleaseStgMedium(lpMedium). this OLE helper function will do the
**    right thing.
**
**    PARAMETERS:
**        LPDATAOBJECT lpDataObj  -- object on which GetData should be
**                                                         called.
**        CLIPFORMAT cfFormat     -- desired clipboard format (eg. CF_TEXT)
**        DVTARGETDEVICE FAR* lpTargetDevice -- target device for which
**                                  the data should be composed. This may
**                                  be NULL. NULL can be used whenever the
**                                  data format is insensitive to target
**                                  device or when the caller does not care
**                                  what device is used.
**        LPSTGMEDIUM lpMedium    -- ptr to STGMEDIUM struct. the
**                                  resultant medium from the
**                                  IDataObject::GetData call is
**                                  returned.
**
**    RETURNS:
**       HGLOBAL -- global memory handle of retrieved data block.
**       NULL    -- if error.
*/
STDAPI_(HGLOBAL) OleStdGetData(
        LPDATAOBJECT        lpDataObj,
        CLIPFORMAT          cfFormat,
        DVTARGETDEVICE FAR* lpTargetDevice,
        DWORD               dwDrawAspect,
        LPSTGMEDIUM         lpMedium)
{
        HRESULT             hrErr;
        FORMATETC           formatetc;
        HGLOBAL             hGlobal = NULL;
        HGLOBAL             hCopy;
        LPVOID              lp;

        formatetc.cfFormat = cfFormat;
        formatetc.ptd = lpTargetDevice;
        formatetc.dwAspect = dwDrawAspect;
        formatetc.lindex = -1;

        switch (cfFormat)
        {
                case CF_METAFILEPICT:
                        formatetc.tymed = TYMED_MFPICT;
                        break;

                case CF_BITMAP:
                        formatetc.tymed = TYMED_GDI;
                        break;

                default:
                        formatetc.tymed = TYMED_HGLOBAL;
                        break;
        }

        OLEDBG_BEGIN2(TEXT("IDataObject::GetData called\r\n"))
        hrErr = lpDataObj->GetData(
                        (LPFORMATETC)&formatetc,
                        lpMedium
        );
        OLEDBG_END2

        if (hrErr != NOERROR)
                return NULL;

        if ((hGlobal = lpMedium->hGlobal) == NULL)
                return NULL;

        // Check if hGlobal really points to valid memory
        if ((lp = GlobalLock(hGlobal)) != NULL)
        {
                if (IsBadReadPtr(lp, 1))
                {
                        GlobalUnlock(hGlobal);
                        return NULL;    // ERROR: memory is NOT valid
                }
                GlobalUnlock(hGlobal);
        }

        if (hGlobal != NULL && lpMedium->pUnkForRelease != NULL)
        {
                /* OLE2NOTE: the callee wants to retain ownership of the data.
                **    this is indicated by passing a non-NULL pUnkForRelease.
                **    thus, we will make a copy of the data and release the
                **    callee's copy.
                */

                hCopy = OleDuplicateData(hGlobal, cfFormat, GHND|GMEM_SHARE);
                ReleaseStgMedium(lpMedium); // release callee's copy of data

                hGlobal = hCopy;
                lpMedium->hGlobal = hCopy;
                lpMedium->pUnkForRelease = NULL;
        }
        return hGlobal;
}


/* OleStdMalloc
** ------------
**    allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize)
{
        LPVOID pout;
        LPMALLOC pmalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return NULL;
        }
        pout = (LPVOID)pmalloc->Alloc(ulSize);
        pmalloc->Release();

        return pout;
}


/* OleStdRealloc
** -------------
**    re-allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize)
{
        LPVOID pout;
        LPMALLOC pmalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return NULL;
        }
        pout = (LPVOID)pmalloc->Realloc(pmem, ulSize);
        pmalloc->Release();

        return pout;
}


/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
        LPMALLOC pmalloc;

        if (pmem == NULL)
                return;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return;
        }
        if (1 == pmalloc->DidAlloc(pmem))
        {
            pmalloc->Free(pmem);
        }
        pmalloc->Release();
}


/* OleStdGetSize
** -------------
**    Get the size of a memory block that was allocated using the
**    currently active IMalloc* allocator.
*/
STDAPI_(ULONG) OleStdGetSize(LPVOID pmem)
{
        ULONG ulSize;
        LPMALLOC pmalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return (ULONG)-1;
        }
        ulSize = (ULONG) pmalloc->GetSize(pmem);
        pmalloc->Release();

        return ulSize;
}


/* OleStdLoadString
** ----------------
**    Load a string from resources.  The string is allocated
**        with the active IMalloc allocator.
*/
STDAPI_(LPTSTR) OleStdLoadString(HINSTANCE hInst, UINT nID)
{
        LPTSTR lpszResult = (LPTSTR)OleStdMalloc(256 * sizeof(TCHAR));
        if (lpszResult == NULL)
                return NULL;
        LoadString(hInst, nID, lpszResult, 256);
        return lpszResult;
}

/* OleStdCopyString
** ----------------
**    Copy a string into memory allocated with the currently active
**    IMalloc* allocator.
*/
STDAPI_(LPTSTR) OleStdCopyString(LPTSTR lpszSrc)
{
        UINT nSize = (lstrlen(lpszSrc)+1) * sizeof(TCHAR);
        LPTSTR lpszResult = (LPTSTR)OleStdMalloc(nSize);
        if (lpszResult == NULL)
                return NULL;
        memcpy(lpszResult, lpszSrc, nSize);
        return lpszResult;
}

/*
 * OleStdGetObjectDescriptorData
 *
 * Purpose:
 *  Fills and returns a OBJECTDESCRIPTOR structure.
 *  See OBJECTDESCRIPTOR for more information.
 *
 * Parameters:
 *  clsid           CLSID   CLSID of object being transferred
 *  dwDrawAspect    DWORD   Display Aspect of object
 *  sizel           SIZEL   Size of object in HIMETRIC
 *  pointl          POINTL  Offset from upper-left corner of object where mouse went
 *                          down for drag. Meaningful only when drag-drop is used.
 *  dwStatus        DWORD   OLEMISC flags
 *  lpszFullUserTypeName  LPSTR Full User Type Name
 *  lpszSrcOfCopy   LPSTR   Source of Copy
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData(
        CLSID       clsid,
        DWORD       dwDrawAspect,
        SIZEL       sizel,
        POINTL      pointl,
        DWORD       dwStatus,
        LPTSTR      lpszFullUserTypeName,
        LPTSTR      lpszSrcOfCopy)
{
        HGLOBAL     hMem = NULL;
        IBindCtx FAR    *pbc = NULL;
        LPOBJECTDESCRIPTOR lpOD;
        DWORD       dwObjectDescSize, dwFullUserTypeNameLen, dwSrcOfCopyLen;

        // Get the length of Full User Type Name; Add 1 for the null terminator
        dwFullUserTypeNameLen = lpszFullUserTypeName ? lstrlen(lpszFullUserTypeName)+1 : 0;
        // Get the Source of Copy string and it's length; Add 1 for the null terminator
        if (lpszSrcOfCopy)
           dwSrcOfCopyLen = lstrlen(lpszSrcOfCopy)+1;
        else
        {
           // No src moniker so use user type name as source string.
           lpszSrcOfCopy =  lpszFullUserTypeName;
           dwSrcOfCopyLen = dwFullUserTypeNameLen;
        }
        // Allocate space for OBJECTDESCRIPTOR and the additional string data
        dwObjectDescSize = sizeof(OBJECTDESCRIPTOR);
        hMem = GlobalAlloc(GHND|GMEM_SHARE, dwObjectDescSize +
           (dwFullUserTypeNameLen + dwSrcOfCopyLen) * sizeof(OLECHAR));
        if (!hMem)
                return NULL;

        lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem);

        // Set the FullUserTypeName offset and copy the string
        if (lpszFullUserTypeName)
        {
                lpOD->dwFullUserTypeName = dwObjectDescSize;
                lstrcpy((LPTSTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), lpszFullUserTypeName);
        }
        else
                lpOD->dwFullUserTypeName = 0;  // zero offset indicates that string is not present

        // Set the SrcOfCopy offset and copy the string
        if (lpszSrcOfCopy)
        {
                lpOD->dwSrcOfCopy = dwObjectDescSize + dwFullUserTypeNameLen * sizeof(OLECHAR);
                lstrcpy((LPTSTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), lpszSrcOfCopy);
        }
        else
                lpOD->dwSrcOfCopy = 0;  // zero offset indicates that string is not present

        // Initialize the rest of the OBJECTDESCRIPTOR
        lpOD->cbSize       = dwObjectDescSize +
                (dwFullUserTypeNameLen + dwSrcOfCopyLen) * sizeof(OLECHAR);
        lpOD->clsid        = clsid;
        lpOD->dwDrawAspect = dwDrawAspect;
        lpOD->sizel        = sizel;
        lpOD->pointl       = pointl;
        lpOD->dwStatus     = dwStatus;

        GlobalUnlock(hMem);
        return hMem;
}

/*
 * OleStdFillObjectDescriptorFromData
 *
 * Purpose:
 *  Fills and returns a OBJECTDESCRIPTOR structure. The source object will
 *  offer CF_OBJECTDESCRIPTOR if it is an OLE2 object, CF_OWNERLINK if it
 *  is an OLE1 object, or CF_FILENAME if it has been copied to the clipboard
 *  by FileManager.
 *
 * Parameters:
 *  lpDataObject    LPDATAOBJECT Source object
 *  lpmedium        LPSTGMEDIUM  Storage medium
 *  lpcfFmt         CLIPFORMAT FAR * Format offered by lpDataObject
 *                  (OUT parameter)
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */

STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData(
        LPDATAOBJECT    lpDataObject,
        LPSTGMEDIUM     lpmedium,
        CLIPFORMAT FAR* lpcfFmt)
{
        CLSID           clsid;
        SIZEL           sizelHim;
        POINTL          pointl;
        LPTSTR          lpsz, szFullUserTypeName, szSrcOfCopy, szClassName, szDocName, szItemName;
        int             nClassName, nDocName, nItemName, nFullUserTypeName;
        LPTSTR          szBuf = NULL;
        HGLOBAL         hMem = NULL;
        HKEY            hKey = NULL;
        DWORD           dw = OLEUI_CCHKEYMAX_SIZE;
        HGLOBAL         hObjDesc;
        HRESULT         hrErr;


        // GetData CF_OBJECTDESCRIPTOR format from the object on the clipboard.
        // Only OLE 2 objects on the clipboard will offer CF_OBJECTDESCRIPTOR
        hMem = OleStdGetData(
            lpDataObject,
            (CLIPFORMAT) _g_cfObjectDescriptor,
            NULL,
            DVASPECT_CONTENT,
            lpmedium);
        if (hMem)
        {
                *lpcfFmt = (CLIPFORMAT)_g_cfObjectDescriptor;
                return hMem;  // Don't drop to clean up at the end of this function
        }
        // If CF_OBJECTDESCRIPTOR is not available, i.e. if this is not an OLE2 object,
        //     check if this is an OLE 1 object. OLE 1 objects will offer CF_OWNERLINK
        else
        {
            hMem = OleStdGetData(
                lpDataObject,
                (CLIPFORMAT) _g_cfOwnerLink,
                NULL,
                DVASPECT_CONTENT,
                lpmedium);
            if (hMem)
            {
                    *lpcfFmt = (CLIPFORMAT)_g_cfOwnerLink;
                    // CF_OWNERLINK contains null-terminated strings for class name, document name
                    // and item name with two null terminating characters at the end
                    szClassName = (LPTSTR)GlobalLock(hMem);
                    nClassName = lstrlen(szClassName);
                    szDocName   = szClassName + nClassName + 1;
                    nDocName   = lstrlen(szDocName);
                    szItemName  = szDocName + nDocName + 1;
                    nItemName  =  lstrlen(szItemName);

                    // Find FullUserTypeName from Registration database using class name
                    if (OpenClassesRootKey(NULL, &hKey) != ERROR_SUCCESS)
                       goto error;

                    // Allocate space for szFullUserTypeName & szSrcOfCopy. Maximum length of FullUserTypeName
                    // is OLEUI_CCHKEYMAX_SIZE. SrcOfCopy is constructed by concatenating FullUserTypeName, Document
                    // Name and ItemName separated by spaces.
                    szBuf = (LPTSTR)OleStdMalloc(
                                                            (DWORD)2*OLEUI_CCHKEYMAX_SIZE+
                                    (nDocName+nItemName+4)*sizeof(TCHAR));
                    if (NULL == szBuf)
                            goto error;
                    szFullUserTypeName = szBuf;
                    szSrcOfCopy = szFullUserTypeName+OLEUI_CCHKEYMAX_SIZE+1;

                    // Get FullUserTypeName
                    if (RegQueryValue(hKey, NULL, szFullUserTypeName, (LONG*)&dw) != ERROR_SUCCESS)
                       goto error;

                    // Build up SrcOfCopy string from FullUserTypeName, DocumentName & ItemName
                    lpsz = szSrcOfCopy;
                    lstrcpy(lpsz, szFullUserTypeName);
                    nFullUserTypeName = lstrlen(szFullUserTypeName);
                    lpsz[nFullUserTypeName]= ' ';
                    lpsz += nFullUserTypeName+1;
                    lstrcpy(lpsz, szDocName);
                    lpsz[nDocName] = ' ';
                    lpsz += nDocName+1;
                    lstrcpy(lpsz, szItemName);

                    sizelHim.cx = sizelHim.cy = 0;
                    pointl.x = pointl.y = 0;

                    CLSIDFromProgID(szClassName, &clsid);
                    hObjDesc = OleStdGetObjectDescriptorData(
                                    clsid,
                                    DVASPECT_CONTENT,
                                    sizelHim,
                                    pointl,
                                    0,
                                    szFullUserTypeName,
                                    szSrcOfCopy
                    );
                    if (!hObjDesc)
                       goto error;
             }
             else
             {
                 BOOL fUnicode = TRUE;

                 hMem = OleStdGetData(
                    lpDataObject,
                    (CLIPFORMAT) _g_cfFileNameW,
                    NULL,
                    DVASPECT_CONTENT,
                    lpmedium);

                 if (!hMem)
                 {
                    hMem = OleStdGetData(
                       lpDataObject,
                       (CLIPFORMAT) _g_cfFileName,
                       NULL,
                       DVASPECT_CONTENT,
                       lpmedium);

                    fUnicode = FALSE;
                 }

                 if (hMem)
                 {
                         *lpcfFmt = fUnicode ? (CLIPFORMAT)_g_cfFileNameW : (CLIPFORMAT)_g_cfFileName;
                         lpsz = (LPTSTR)GlobalLock(hMem);
                         if (!fUnicode)
                         {
                             OLECHAR wsz[OLEUI_CCHKEYMAX];
                             ATOW(wsz, (LPSTR)lpsz, OLEUI_CCHKEYMAX);
                             hrErr = GetClassFile(wsz, &clsid);
                         }
                         else
                             hrErr = GetClassFile((LPWSTR)lpsz, &clsid);

                         /* OLE2NOTE: if the file does not have an OLE class
                         **    associated, then use the OLE 1 Packager as the class of
                         **    the object to be created. this is the behavior of
                         **    OleCreateFromData API
                         */
                         if (hrErr != NOERROR)
                                CLSIDFromProgID(OLESTR("Package"), &clsid);
                         sizelHim.cx = sizelHim.cy = 0;
                         pointl.x = pointl.y = 0;

                         if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &szBuf) != NOERROR)
                                goto error;

                         hObjDesc = OleStdGetObjectDescriptorData(
                                        clsid,
                                        DVASPECT_CONTENT,
                                        sizelHim,
                                        pointl,
                                        0,
                                        szBuf,
                                        lpsz
                        );
                        if (!hObjDesc)
                           goto error;
                 }
                 else
                        goto error;
             }
        }
         // Check if object is CF_FILENAME

         // Clean up
         OleStdFree(szBuf);
         if (hMem)
         {
                 GlobalUnlock(hMem);
                 GlobalFree(hMem);
         }
         if (hKey)
                 RegCloseKey(hKey);
         return hObjDesc;

error:
        OleStdFree(szBuf);
         if (hMem)
         {
                 GlobalUnlock(hMem);
                 GlobalFree(hMem);
         }
         if (hKey)
                 RegCloseKey(hKey);
         return NULL;
}

/* Call Release on the object that is NOT necessarily expected to go away.
*/
STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk)
{
        ULONG cRef;
        cRef = lpUnk->Release();

#ifdef _DEBUG
        {
                TCHAR szBuf[80];
                wsprintf(
                                szBuf,
                                TEXT("refcnt = %ld after object (0x%lx) release\n"),
                                cRef,
                                lpUnk
                );
                OleDbgOut4(szBuf);
        }
#endif
        return cRef;
}


/*
 * OleStdMarkPasteEntryList
 *
 * Purpose:
 *  Mark each entry in the PasteEntryList if its format is available from
 *  the source IDataObject*. the dwScratchSpace field of each PasteEntry
 *  is set to TRUE if available, else FALSE.
 *
 * Parameters:
 *  LPOLEUIPASTEENTRY   array of PasteEntry structures
 *  int                 count of elements in PasteEntry array
 *  LPDATAOBJECT        source IDataObject* pointer
 *
 * Return Value:
 *   none
 */
STDAPI_(void) OleStdMarkPasteEntryList(
        LPDATAOBJECT        lpSrcDataObj,
        LPOLEUIPASTEENTRY   lpPriorityList,
        int                 cEntries)
{
        LPENUMFORMATETC     lpEnumFmtEtc = NULL;
        #define FORMATETC_MAX 20
        FORMATETC           rgfmtetc[FORMATETC_MAX];
        int                 i;
        HRESULT             hrErr;
        DWORD               j, cFetched;

        // Clear all marks
        for (i = 0; i < cEntries; i++)
        {
                lpPriorityList[i].dwScratchSpace = FALSE;
                if (! lpPriorityList[i].fmtetc.cfFormat)
                {
                        // caller wants this item always considered available
                        // (by specifying a NULL format)
                        lpPriorityList[i].dwScratchSpace = TRUE;
                }
                else if (lpPriorityList[i].fmtetc.cfFormat == _g_cfEmbeddedObject
                                || lpPriorityList[i].fmtetc.cfFormat == _g_cfEmbedSource
                                || lpPriorityList[i].fmtetc.cfFormat == _g_cfFileName)
                {
                        // if there is an OLE object format, then handle it
                        // specially by calling OleQueryCreateFromData. the caller
                        // need only specify one object type format.
                        OLEDBG_BEGIN2(TEXT("OleQueryCreateFromData called\r\n"))
                        hrErr = OleQueryCreateFromData(lpSrcDataObj);
                        OLEDBG_END2
                        if(NOERROR == hrErr)
                                lpPriorityList[i].dwScratchSpace = TRUE;
                }
                else if (lpPriorityList[i].fmtetc.cfFormat == _g_cfLinkSource)
                {
                        // if there is OLE 2.0 LinkSource format, then handle it
                        // specially by calling OleQueryLinkFromData.
                        OLEDBG_BEGIN2(TEXT("OleQueryLinkFromData called\r\n"))
                        hrErr = OleQueryLinkFromData(lpSrcDataObj);
                        OLEDBG_END2
                        if(NOERROR == hrErr) {
                                lpPriorityList[i].dwScratchSpace = TRUE;
                        }
                }
        }

        OLEDBG_BEGIN2(TEXT("IDataObject::EnumFormatEtc called\r\n"))
        hrErr = lpSrcDataObj->EnumFormatEtc(
                        DATADIR_GET,
                        (LPENUMFORMATETC FAR*)&lpEnumFmtEtc
        );
        OLEDBG_END2

        if (hrErr != NOERROR)
                return;    // unable to get format enumerator

        // Enumerate the formats offered by the source
        // Loop over all formats offered by the source
        cFetched = 0;
        memset(rgfmtetc,0,sizeof(rgfmtetc));
        if (lpEnumFmtEtc->Next(
                        FORMATETC_MAX, rgfmtetc, &cFetched) == NOERROR
                || (cFetched > 0 && cFetched <= FORMATETC_MAX) )
        {
                for (j = 0; j < cFetched; j++)
                {
                        for (i = 0; i < cEntries; i++)
                        {
                                if (!lpPriorityList[i].dwScratchSpace &&
                                        IsCloseFormatEtc(&lpPriorityList[i].fmtetc, &rgfmtetc[j]))
                                {
                                        lpPriorityList[i].dwScratchSpace = TRUE;
                                }
                        }
                }
        } // endif

        OleStdRelease((LPUNKNOWN)lpEnumFmtEtc);
}


// returns 1 for a close match
//  (all fields match exactly except the tymed which simply overlaps)
// 0 for no match

int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight)
{
        if (pFetcLeft->cfFormat != pFetcRight->cfFormat)
                return 0;
        else if (!OleStdCompareTargetDevice (pFetcLeft->ptd, pFetcRight->ptd))
                return 0;
        if (pFetcLeft->dwAspect != pFetcRight->dwAspect)
                return 0;
        return((pFetcLeft->tymed | pFetcRight->tymed) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\olestd.h ===
/*************************************************************************
**
**    OLE 2.0 Utility Library
**
**    olestd.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. for the common OLE 2.0
**    utilities.
**    These utilities include the following:
**          Debuging Assert/Verify macros
**          HIMETRIC conversion routines
**          reference counting debug support
**          OleStd API's for common compound-document app support
**
**    (c) Copyright Microsoft Corp. 1990 - 1995 All Rights Reserved
**
*************************************************************************/

#ifndef _OLESTD_H_
#define _OLESTD_H_

#include <commdlg.h>    // needed for LPPRINTDLG
#include <shellapi.h>   // needed for HKEY
#include <oledlg.h>     // need some paste special defines

#ifdef __cplusplus
extern "C" {
#endif

STDAPI_(void) OleStdInitialize(HINSTANCE hInstance, HINSTANCE hResInstance);

// Clipboard Copy/Paste & Drag/Drop support support

// Clipboard format strings
#define CF_EMBEDSOURCE          TEXT("Embed Source")
#define CF_EMBEDDEDOBJECT       TEXT("Embedded Object")
#define CF_LINKSOURCE           TEXT("Link Source")
#define CF_OBJECTDESCRIPTOR     TEXT("Object Descriptor")
#define CF_LINKSRCDESCRIPTOR    TEXT("Link Source Descriptor")
#define CF_OWNERLINK            TEXT("OwnerLink")
#define CF_FILENAME             TEXT("FileName")
#define CF_FILENAMEW            TEXT("FileNameW")

// Other useful defines
#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

/****** DEBUG Support *****************************************************/

#ifdef _DEBUG

#ifndef _DBGTRACE
        #define _DEBUGLEVEL 2
#else
        #define _DEBUGLEVEL _DBGTRACE
#endif

#ifdef NOASSERT

#define OLEDBGASSERTDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)
#define OleDbgVerifySz(a, b)

#else   // ! NOASSERT

STDAPI OleStdAssert(LPTSTR lpstrExpr, LPTSTR lpstrMsg,
        LPTSTR lpstrFileName, UINT iLine);

#define OLEDBGASSERTDATA    \
                static TCHAR _szAssertFile[]= TEXT(__FILE__);

#define OleDbgAssert(a) \
                (!(a) ? OleStdAssert(TEXT(#a), NULL, _szAssertFile, __LINE__) : (HRESULT)1)

#define OleDbgAssertSz(a, b)    \
                (!(a) ? OleStdAssert(TEXT(#a), b, _szAssertFile, __LINE__) : (HRESULT)1)

#endif

#define OleDbgVerify(a) \
                OleDbgAssert(a)

#define OleDbgVerifySz(a, b)    \
                OleDbgAssertSz(a, b)

#define OLEDBGDATA_MAIN(szPrefix)   \
                TCHAR g_szDbgPrefix[] = szPrefix;    \
                OLEDBGASSERTDATA
#define OLEDBGDATA  \
                extern TCHAR g_szDbgPrefix[];    \
                OLEDBGASSERTDATA

#define OLEDBG_BEGIN(lpsz) \
                OleDbgPrintAlways(g_szDbgPrefix,lpsz,1);

#define OLEDBG_END  \
                OleDbgPrintAlways(g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOut(lpsz) \
                OleDbgPrintAlways(g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix(lpsz) \
                OleDbgPrintAlways(TEXT(""),lpsz,0)

#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)      \
                OleDbgPrintRefCntAlways(g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect(lpsz,lpRect)      \
                OleDbgPrintRectAlways(g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOutHResult(lpsz,hr)   \
                OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,GetScode(hr))

#define OleDbgOutScode(lpsz,sc) \
                OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,sc)

#define OleDbgOut1(lpsz)    \
                OleDbgPrint(1,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix1(lpsz)    \
                OleDbgPrint(1,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN1(lpsz)    \
                OleDbgPrint(1,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END1 \
                OleDbgPrint(1,g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(1,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect1(lpsz,lpRect)     \
                OleDbgPrintRect(1,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut2(lpsz)    \
                OleDbgPrint(2,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix2(lpsz)    \
                OleDbgPrint(2,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN2(lpsz)    \
                OleDbgPrint(2,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END2 \
                OleDbgPrint(2,g_szDbgPrefix, TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(2,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect2(lpsz,lpRect)     \
                OleDbgPrintRect(2,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut3(lpsz)    \
                OleDbgPrint(3,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix3(lpsz)    \
                OleDbgPrint(3,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN3(lpsz)    \
                OleDbgPrint(3,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END3 \
                OleDbgPrint(3,g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(3,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect3(lpsz,lpRect)     \
                OleDbgPrintRect(3,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut4(lpsz)    \
                OleDbgPrint(4,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix4(lpsz)    \
                OleDbgPrint(4,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN4(lpsz)    \
                OleDbgPrint(4,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END4 \
                OleDbgPrint(4,g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(4,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect4(lpsz,lpRect)     \
                OleDbgPrintRect(4,g_szDbgPrefix,lpsz,lpRect)

#else   //  !_DEBUG

#define OLEDBGDATA_MAIN(szPrefix)
#define OLEDBGDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)         (a)
#define OleDbgVerifySz(a, b)    (a)
#define OleDbgOutHResult(lpsz,hr)
#define OleDbgOutScode(lpsz,sc)
#define OLEDBG_BEGIN(lpsz)
#define OLEDBG_END
#define OleDbgOut(lpsz)
#define OleDbgOut1(lpsz)
#define OleDbgOut2(lpsz)
#define OleDbgOut3(lpsz)
#define OleDbgOut4(lpsz)
#define OleDbgOutNoPrefix(lpsz)
#define OleDbgOutNoPrefix1(lpsz)
#define OleDbgOutNoPrefix2(lpsz)
#define OleDbgOutNoPrefix3(lpsz)
#define OleDbgOutNoPrefix4(lpsz)
#define OLEDBG_BEGIN1(lpsz)
#define OLEDBG_BEGIN2(lpsz)
#define OLEDBG_BEGIN3(lpsz)
#define OLEDBG_BEGIN4(lpsz)
#define OLEDBG_END1
#define OLEDBG_END2
#define OLEDBG_END3
#define OLEDBG_END4
#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)
#define OleDbgOutRect(lpsz,lpRect)
#define OleDbgOutRect1(lpsz,lpRect)
#define OleDbgOutRect2(lpsz,lpRect)
#define OleDbgOutRect3(lpsz,lpRect)
#define OleDbgOutRect4(lpsz,lpRect)

#endif  //  _DEBUG

/*************************************************************************
** Function prototypes
*************************************************************************/

// OLESTD.CPP
STDAPI_(int) XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int) XformHeightInHimetricToPixels(HDC, int);

STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk);
STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid);
STDAPI_(HGLOBAL) OleStdGetData(
                LPDATAOBJECT        lpDataObj,
                CLIPFORMAT          cfFormat,
                DVTARGETDEVICE FAR* lpTargetDevice,
                DWORD               dwAspect,
                LPSTGMEDIUM         lpMedium
);
STDAPI_(void) OleStdMarkPasteEntryList(
                LPDATAOBJECT        lpSrcDataObj,
                LPOLEUIPASTEENTRY   lpPriorityList,
                int                 cEntries
);
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData(
                CLSID               clsid,
                DWORD               dwAspect,
                SIZEL               sizel,
                POINTL              pointl,
                DWORD               dwStatus,
                LPTSTR               lpszFullUserTypeName,
                LPTSTR               lpszSrcOfCopy
);
STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData(
                LPDATAOBJECT       lpDataObject,
                LPSTGMEDIUM        lpmedium,
                CLIPFORMAT FAR*    lpcfFmt
);

STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);
STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize);
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(ULONG) OleStdGetSize(LPVOID pmem);
STDAPI_(LPTSTR) OleStdCopyString(LPTSTR lpszSrc);
STDAPI_(LPTSTR) OleStdLoadString(HINSTANCE hInst, UINT nID);
STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk);

STDAPI_(BOOL) OleStdCompareTargetDevice
        (DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight);

STDAPI_(void) OleDbgPrint(
                int     nDbgLvl,
                LPTSTR   lpszPrefix,
                LPTSTR   lpszMsg,
                int     nIndent
);
STDAPI_(void) OleDbgPrintAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, int nIndent);
STDAPI_(void) OleDbgSetDbgLevel(int nDbgLvl);
STDAPI_(int) OleDbgGetDbgLevel( void );
STDAPI_(void) OleDbgIndent(int n);
STDAPI_(void) OleDbgPrintRefCnt(
                int         nDbgLvl,
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPVOID      lpObj,
                ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRefCntAlways(
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPVOID      lpObj,
                ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRect(
                int         nDbgLvl,
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintRectAlways(
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintScodeAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, SCODE sc);

#ifdef __cplusplus
}
#endif

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)

#endif // _OLESTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\resimage.cpp ===
/*
 * RESIMAGE.CPP
 *
 * Implementation of the Results Image control for OLE 2.0 UI dialogs.
 * We need a separate control for dialogs in order to control the repaints
 * properly and to provide a clean message interface for the dialog
 * implementations.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "resimage.h"
#include "uiclass.h"
OLEDBGDATA

//Reference counter indicating how many times fResultImageInitialize has been
//successfully called
static UINT     uRegistered = 0;

//Bitmap and image dimensions for result images.
static HBITMAP  hBmpResults = NULL;
static UINT     cxBmpResult;
static UINT     cyBmpResult;

/*
 * FResultImageInitialize
 *
 * Purpose:
 *  Attempts to load result bitmaps for the current display driver
 *  for use in OLE 2.0 UI dialogs.  Also registers the ResultImage
 *  control class.
 *
 * Parameters:
 *  hInst           HINSTANCE instance of the DLL.
 *
 *  hPrevInst       HINSTANCE of the previous instance.  Used to
 *                  determine whether to register window classes or not.
 *
 * Return Value:
 *  BOOL            TRUE if all initialization succeeded, FALSE otherwise.
 */

#pragma code_seg(".text$initseg")

BOOL FResultImageInitialize(HINSTANCE hInst, HINSTANCE hPrevInst)
{
        int         cx, iBmp;
        HDC         hDC;
        BITMAP      bm;

        WNDCLASS        wc;

        /*
         * Determine the aspect ratio of the display we're currently
         * running on and load the appropriate bitmap into the global
         * hBmpResults (used from the ResultImage control only).
         *
         * By retrieving the logical Y extent of the display driver, you
         * only have limited possibilities:
         *      LOGPIXELSY      Display
         *      ----------------------------------------
         *         48             CGA    (unsupported)
         *         72             EGA
         *         96             VGA
         *        120             8514/a (i.e. HiRes VGA)
         */

        hDC=GetDC(NULL);

        if (NULL==hDC)
                return FALSE;

        cx=GetDeviceCaps(hDC, LOGPIXELSY);
        ReleaseDC(NULL, hDC);

        /*
         * Instead of single comparisons, check ranges instead, so in case
         * we get something funky, we'll act reasonable.
         */
        if (72 >=cx)             iBmp=IDB_RESULTSEGA;
        if (72 < cx && 120 > cx) iBmp=IDB_RESULTSVGA;
        if (120 <=cx)            iBmp=IDB_RESULTSHIRESVGA;

        if (NULL == hBmpResults)
        {
            hBmpResults=LoadBitmap(hInst, MAKEINTRESOURCE(iBmp));

            if (NULL==hBmpResults)
            {
                    //On error, fail loading the DLL
                    OleDbgOut1(TEXT("FResultImageInitialize:  Failed LoadBitmap.\r\n"));
                    return FALSE;
            }
            OleDbgOut4(TEXT("FResultImageInitialize:  Loaded hBmpResults\r\n"));

            // Now that we have the bitmap, calculate image dimensions
            GetObject(hBmpResults, sizeof(BITMAP), &bm);
            cxBmpResult = bm.bmWidth/CIMAGESX;
            cyBmpResult = bm.bmHeight;
        }


        // Only register class if we're the first instance
        if (hPrevInst)
                uRegistered++;
        else
        {
                // Static flag fRegistered guards against calling this function more
                // than once in the same instance

                if (0 == uRegistered)
                {
                        wc.lpfnWndProc   =ResultImageWndProc;
                        wc.cbClsExtra    =0;
                        wc.cbWndExtra    =CBRESULTIMAGEWNDEXTRA;
                        wc.hInstance     =hInst;
                        wc.hIcon         =NULL;
                        wc.hCursor       =LoadCursor(NULL, IDC_ARROW);
                        wc.hbrBackground =NULL;
                        wc.lpszMenuName  =NULL;
                        wc.style         =CS_GLOBALCLASS | CS_VREDRAW | CS_HREDRAW;

                        wc.lpszClassName = TEXT(SZCLASSRESULTIMAGE1);
                        uRegistered = RegisterClass(&wc) ? 1 : 0;

                        wc.lpszClassName = TEXT(SZCLASSRESULTIMAGE2);
                        uRegistered = RegisterClass(&wc) ? 1 : 0;

                        wc.lpszClassName = TEXT(SZCLASSRESULTIMAGE3);
                        uRegistered = RegisterClass(&wc) ? 1 : 0;
                }
                else
                     uRegistered++;
        }

        return (uRegistered > 0);
}

#pragma code_seg()


/*
 * ResultImageUninitialize
 *
 * Purpose:
 *  Cleans up anything done in FResultImageInitialize, such as freeing
 *  the bitmaps.  Call from WEP.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void ResultImageUninitialize(void)
{
    --uRegistered;
    if (0 == uRegistered)
    {
        if (NULL != hBmpResults)
        {
                DeleteObject(hBmpResults);
                hBmpResults = NULL;
        }
    }
}


/*
 * ResultImageWndProc
 *
 * Purpose:
 *  Window Procedure for the ResultImage custom control.  Only handles
 *  WM_CREATE, WM_PAINT, and private messages to manipulate the bitmap.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

LRESULT CALLBACK ResultImageWndProc(HWND hWnd, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{
        UINT            iBmp;
        PAINTSTRUCT     ps;
        HDC             hDC;

        //Handle standard Windows messages.
        switch (iMsg)
        {
                case WM_CREATE:
                        SetWindowWord(hWnd, RIWW_IMAGEINDEX, RESULTIMAGE_NONE);
                        return (LRESULT)0;

                case WM_PAINT:
                        iBmp = GetWindowWord(hWnd, RIWW_IMAGEINDEX);
                        hDC = BeginPaint(hWnd, &ps);

                        RECT            rc;
                        UINT            x, y;
                        HDC             hDCDlg;
                        HBRUSH          hBr;
                        LOGBRUSH        lb;
                        HWND            hDlg;

                        /*
                         * Our job before using TransparentBlt is to figure out
                         * where to position the result image.  We place it centered
                         * on this control, so get our rect's center and subtract
                         * half of the image dimensions.
                         */
                        GetClientRect(hWnd, &rc);
                        x = (rc.right+rc.left-cxBmpResult)/2;
                        y = (rc.bottom+rc.top-cyBmpResult)/2;

                        // Get the backgroup color the dialog is using.
                        hDlg=GetParent(hWnd);
                        hDCDlg=GetDC(hDlg);
                        if (hDCDlg)
                        {
                            //hDCDlg might be NULL in low-memory situations.
                            hBr = (HBRUSH)SendMessage(hDlg,
                                                      WM_CTLCOLORDLG,
                                                      (WPARAM)hDCDlg,
                                                      (LPARAM)hDlg);
                            ReleaseDC(hDlg, hDCDlg);
                            GetObject(hBr, sizeof(LOGBRUSH), &lb);
                            SetBkColor(hDC, lb.lbColor);
                        }


                        if (RESULTIMAGE_NONE != iBmp)
                        {

                            TransparentBlt(hDC, x, y, hBmpResults, iBmp*cxBmpResult, 0,
                                    cxBmpResult, cyBmpResult, RGBTRANSPARENT);
                        }
                        else
                        {
                            FillRect(hDC, &rc, hBr);
                        }
                        EndPaint(hWnd, &ps);
                        break;

                case RIM_IMAGESET:
                        // wParam contains the new index.
                        iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);

                        // Validate the index before changing it and repainting
                        if (RESULTIMAGE_NONE==wParam ||
                                ((RESULTIMAGE_MAX >= wParam)))
                        {
                                SetWindowWord(hWnd, RIWW_IMAGEINDEX, (WORD)wParam);
                                InvalidateRect(hWnd, NULL, FALSE);
                                UpdateWindow(hWnd);
                        }
                        // Return the previous index.
                        return (LRESULT)iBmp;

                case RIM_IMAGEGET:
                        // Return the current index.
                        iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);
                        return (LRESULT)iBmp;

                default:
                        return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }

        return (LRESULT)0;
}


/*
 * TransparentBlt
 *
 * Purpose:
 *  Given a DC, a bitmap, and a color to assume as transparent in that
 *  bitmap, BitBlts the bitmap to the DC letting the existing background
 *  show in place of the transparent color.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  x, y            UINT location at which to draw the bitmap
 *  hBmp            HBITMIP to draw from
 *  xOrg, yOrg      UINT coordinates from which to draw the bitamp
 *  cx, cy          UINT dimensions of the bitmap to Blt.
 *  cr              COLORREF to consider as transparent.
 *
 * Return Value:
 *  None
 */

void TransparentBlt(HDC hDC, UINT x, UINT y, HBITMAP hBmp, UINT xOrg, UINT yOrg,
        UINT cx, UINT cy, COLORREF cr)
{
    if (hBmp)
	{
		// Get three intermediate DC's
		HDC hDCSrc = CreateCompatibleDC(hDC);
		if (hDCSrc)
		{
			HDC hDCMid = CreateCompatibleDC(hDC);
			if (hDCMid)
			{
				HDC hMemDC = CreateCompatibleDC(hDC);
				if (hMemDC)
				{ 
					SelectObject(hDCSrc, hBmp);

					// Create a monochrome bitmap for masking
					HBITMAP hBmpMono = CreateCompatibleBitmap(hDCMid, cx, cy);
					if (hBmpMono)
					{
						SelectObject(hDCMid, hBmpMono);

						// Create a middle bitmap
						HBITMAP hBmpT = CreateCompatibleBitmap(hDC, cx, cy);
						if (hBmpT)
						{
							SelectObject(hMemDC, hBmpT);

							// Create a monochrome mask where we have 0's in the image, 1's elsewhere.
							COLORREF crBack = SetBkColor(hDCSrc, cr);
							BitBlt(hDCMid, 0, 0, cx, cy, hDCSrc, xOrg, yOrg, SRCCOPY);
							SetBkColor(hDCSrc, crBack);

							// Put the unmodified image in the temporary bitmap
							BitBlt(hMemDC, 0, 0, cx, cy, hDCSrc, xOrg, yOrg, SRCCOPY);

							// Create an select a brush of the background color
							HBRUSH hBr = CreateSolidBrush(GetBkColor(hDC));
							if (hBr)
							{
								HBRUSH hBrT = (HBRUSH)SelectObject(hMemDC, hBr);

								// Force conversion of the monochrome to stay black and white.
								COLORREF crText = SetTextColor(hMemDC, 0L);
								crBack = SetBkColor(hMemDC, RGB(255, 255, 255));

								/*
								 * Where the monochrome mask is 1, Blt the brush; where the mono mask
								 * is 0, leave the destination untouches.  This results in painting
								 * around the image with the background brush.  We do this first
								 * in the temporary bitmap, then put the whole thing to the screen.
								 */
								BitBlt(hMemDC, 0, 0, cx, cy, hDCMid, 0, 0, ROP_DSPDxax);
								BitBlt(hDC,    x, y, cx, cy, hMemDC, 0, 0, SRCCOPY);

								SetTextColor(hMemDC, crText);
								SetBkColor(hMemDC, crBack);

								SelectObject(hMemDC, hBrT);
								DeleteObject(hBr);
							}								// if (hBr)
							DeleteObject(hBmpT);
						}									// if (hBmpT)
						DeleteObject(hBmpMono);
					}										// if (hBmpMono)
					DeleteDC(hMemDC);
				}											// if (hMemDC)
				DeleteDC(hDCMid);
			}												// if (hDCMid)
			DeleteDC(hDCSrc);
		}													// if (hDCSrc)
	}														// if (hBmp)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\resimage.h ===
/*
 * RESIMAGE.H
 *
 * Structures and definitions for the ResultImage control.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _RESIMAGE_H_
#define _RESIMAGE_H_

/*
 * Indices into the bitmaps to extract the right image.  Each bitmap
 * contains five images arranged vertically, so the offset to the correct
 * image is (iImage*cy)
 */

#define RESULTIMAGE_NONE                0xFFFF
#define RESULTIMAGE_PASTE               0
#define RESULTIMAGE_EMBED               1
#define RESULTIMAGE_EMBEDICON           2
#define RESULTIMAGE_LINK                3
#define RESULTIMAGE_LINKICON            4
#define RESULTIMAGE_LINKTOLINK          5
#define RESULTIMAGE_LINKTOLINKICON      6
#define RESULTIMAGE_EDITABLE                    7

#define RESULTIMAGE_MIN                 0
#define RESULTIMAGE_MAX                 7

// Total number of images in each bitmap.
#define CIMAGESX                                           (RESULTIMAGE_MAX+1)

// The color to use for transparancy (cyan)
#define RGBTRANSPARENT                  RGB(0, 255, 255)

// Function prototypes
LRESULT CALLBACK ResultImageWndProc(HWND, UINT, WPARAM, LPARAM);

BOOL FResultImageInitialize(HINSTANCE, HINSTANCE);
void ResultImageUninitialize(void);
void TransparentBlt(HDC, UINT, UINT, HBITMAP, UINT, UINT, UINT, UINT, COLORREF);

// Window extra bytes contain the bitmap index we deal with currently.
#define CBRESULTIMAGEWNDEXTRA          sizeof(UINT)
#define RIWW_IMAGEINDEX                0

// Control messages
#define RIM_IMAGESET                   (WM_USER+0)
#define RIM_IMAGEGET                   (WM_USER+1)

// Special ROP code for TransparentBlt.
#define ROP_DSPDxax  0x00E20746

#endif //_RESIMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by oledlg.rc
//
#define IDB_RESULTSEGA                  10
#define IDB_RESULTSVGA                  11
#define IDB_RESULTSHIRESVGA             12
#define IDS_FILTERS                     64
#define IDS_ICONFILTERS                 65
#define IDS_BROWSE                      66
#define IDS_OCX_FILTERS                 67
#define IDS_INSERT                      68
#define IDS_CHNGSRCOKBUTTON             69
#define IDS_IORESULTNEW                 256
#define IDS_IORESULTNEWICON             257
#define IDS_IORESULTFROMFILE1           258
#define IDS_IORESULTFROMFILE2           259
#define IDS_IORESULTFROMFILEICON2       260
#define IDS_IORESULTLINKFILE1           261
#define IDS_IORESULTLINKFILE2           262
#define IDS_IORESULTLINKFILEICON1       263
#define IDS_IORESULTLINKFILEICON2       264
#define IDS_CINOICONSINFILE             288
#define IDS_CIINVALIDFILE               289
#define IDS_CIFILEACCESS                290
#define IDS_CIFILESHARE                 291
#define IDS_CIFILEOPENFAIL              292
#define IDS_OLE2UIUNKNOWN               300
#define IDS_OLE2UILINK                  301
#define IDS_OLE2UIOBJECT                302
#define IDS_OLE2UIEDIT                  303
#define IDS_OLE2UICONVERT               304
#define IDS_OLE2UIEDITLINKCMD_1VERB     305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   306
#define IDS_OLE2UIEDITLINKCMD_NVERB     307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   308
#define IDS_OLE2UIEDITNOOBJCMD          309
#define IDS_DEFICONLABEL                310
#define IDS_OLE2UIPASTELINKEDTYPE       311
#define IDS_PSPASTEDATA                 400
#define IDS_PSPASTEOBJECT               401
#define IDS_PSPASTEOBJECTASICON         402
#define IDS_PSPASTELINKDATA             403
#define IDS_PSPASTELINKOBJECT           404
#define IDS_PSPASTELINKOBJECTASICON     405
#define IDS_PSNONOLE                    406
#define IDS_PSUNKNOWNTYPE               407
#define IDS_PSUNKNOWNSRC                408
#define IDS_PSUNKNOWNAPP                409
#define IDS_CVRESULTCONVERTLINK         500
#define IDS_CVRESULTCONVERTTO           501
#define IDS_CVRESULTNOCHANGE            502
#define IDS_CVRESULTDISPLAYASICON       503
#define IDS_CVRESULTACTIVATEAS          504
#define IDS_CVRESULTACTIVATEDIFF        505
#define IDS_BZRESULTTEXTBUSY            601
#define IDS_BZRESULTTEXTNOTRESPONDING   602
#define IDS_OLESTDNOCREATEFILE          700
#define IDS_OLESTDNOOPENFILE            701
#define IDS_OLESTDDISKFULL              702
#define IDS_LINK_AUTO                   800
#define IDS_LINK_MANUAL                 801
#define IDS_LINK_UNKNOWN                802
#define IDS_LINKS                       803
#define IDS_FAILED                      804
#define IDS_CHANGESOURCE                805
#define IDS_INVALIDSOURCE               806
#define IDS_ERR_GETLINKSOURCE           807
#define IDS_ERR_GETLINKUPDATEOPTIONS    808
#define IDS_ERR_ADDSTRING               809
#define IDS_CHANGEADDITIONALLINKS       810
#define IDS_CLOSE                       811
#define IDS_OBJECTPROPERTIES            812
#define IDS_LINKOBJECTPROPERTIES        813
#define IDS_LINKPROPS                   814
#define IDS_CONFIRMBREAKLINK            815
#define IDS_BYTES                       816
#define IDS_ORDERKB                     817
#define IDS_ORDERMB                     818
#define IDS_ORDERGB                     819
#define IDS_ORDERTB                     820
#define IDS_OBJECTSIZE                  821
#define IDS_CANNOTLOADOCX               822
#define IDS_NODLLREGISTERSERVER         823
#define IDS_DLLREGISTERFAILED           824
#define IDS_ADDCONTROL                  825
#define IDS_RANGEERROR                  826
#define IDS_INVALIDPERCENTAGE           827
#define IDS_VIEWPROPS                   828
#define RT_HELPINFO                     4096

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\strcache.cpp ===
//+----------------------------------------------------------------------------
//
//  File:       strcache.cpp
//
//  Contents:   String cache for insert object dialog.
//
//  Classes:    CStringCache
//
//  History:    02-May-99   MPrabhu      Created
//
//-----------------------------------------------------------------------------
#include "precomp.h"
#include "common.h"
#include "strcache.h"
#if USE_STRING_CACHE==1 

// Global instance of the string Cache object.
CStringCache gInsObjStringCache;

// Was the cache initialized successfully?
BOOL    gbCacheInit = FALSE;

// Is the cache in good shape currently?
// This is needed because errors may occur post-initialization
// during caching strings, setting up RegNotify etc. 
// If there is any error we do not take further risk and flag the cache 
// as useless all the way till process detach.
BOOL    gbOKToUseCache = FALSE;

// REVIEW: the above two globals could probably be folded into a single 
// dwFlags member in the cache.

//+-------------------------------------------------------------------------
//
//  Function:   InsertObjCacheInitialize, public
//
//  Synopsis:   Calls Init() method on the string cache and records 
//              success/failure for later use.
//
//  History:    02-May-99   MPrabhu      Created.
//
//--------------------------------------------------------------------------
BOOL InsertObjCacheInitialize()
{
    OleDbgAssert(gbCacheInit == FALSE);
    OleDbgAssert(gInsObjStringCache);
    if (gInsObjStringCache.Init())
    {
        gbCacheInit = TRUE;
        gbOKToUseCache = TRUE;
    }
    return gbCacheInit;
}

//+-------------------------------------------------------------------------
//
//  Function:   InsertObjCacheUninitialize, public
//
//  Synopsis:   Calls CleanUp method on the string cache if it was 
//              successfully initialized.
//
//  History:    02-May-99   MPrabhu      Created.
//
//--------------------------------------------------------------------------
void InsertObjCacheUninitialize()
{
    OleDbgAssert(gInsObjStringCache);
    if (gbCacheInit)
    {
        gInsObjStringCache.CleanUp();
    }
}
   
//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::CStringCache, Public
//
//  Synopsis:   Ctor (empty)
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
CStringCache::CStringCache()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::~CStringCache, Public
//
//  Synopsis:   Dtor (empty) 
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
CStringCache::~CStringCache()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::Init, Public
//
//  Synopsis:   Called during dll_proc_attach to set up the initial state
//              and allocate memory for the cache.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::Init()
{
    m_ulMaxBytes = 0;   //We will alloc this below
    m_ulMaxStringCount = 0;
    m_ulNextStringNum = 1;
    m_ulStringCount = 0;
    m_pOffsetTable = NULL;
    m_pStrings = NULL;
    m_cClsidExcludePrev = 0xFFFFFFFF;   // bogus initial values
    m_ioFlagsPrev = 0xFFFFFFFF;
    m_hRegEvent = CreateEventW( NULL,   // pointer to security attributes 
                                        // (NULL=>can't inherit)
                                FALSE,  // not Manual Reset
                                FALSE,  // not Signaled initially
                                NULL ); // pointer to event-object name
                                
    LONG ret = RegOpenKeyW( HKEY_CLASSES_ROOT, 
                            L"CLSID",           // szSubKey
                            &m_hRegKey );
                            
    if ( (!m_hRegEvent) || ((LONG)ERROR_SUCCESS!=ret) )
    {
        // No point in using the cache if we cannot watch key changes.
        return FALSE;  
    }
    
    ret = RegNotifyChangeKeyValue(  m_hRegKey,         // key to watch
                                    TRUE,              // watch subTree
                                    REG_NOTIFY_CHANGE_NAME            // name
                                      | REG_NOTIFY_CHANGE_LAST_SET, // value
                                    m_hRegEvent,        // event to signal
                                    TRUE );             // report asynchronously                                    
    if (ERROR_SUCCESS!=ret)
    {
        // No point in using the cache if we cannot watch key changes.
        return FALSE;
    }
    
    return (ExpandStringTable() && ExpandOffsetTable());
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::CleanUp, Public
//
//  Synopsis:   Called during dll_proc_detach to clean up the state
//              and free the memory allocated for the cache.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    

void CStringCache::CleanUp()
{
    FlushCache();
    CoTaskMemFree(m_pStrings); 
    CoTaskMemFree(m_pOffsetTable); 
    if (m_hRegEvent) 
        CloseHandle(m_hRegEvent);
    if (m_hRegKey)
        CloseHandle(m_hRegKey);
    gbCacheInit = FALSE;
    gbOKToUseCache = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::ExpandStringTable, Private
//
//  Synopsis:   Called to expand the memory block used to keep strings
//
//  History:    02-May-99   MPrabhu       Created
//
//  Notes:      This relies on MemRealloc to copy the existing contents.
//              Caller *must* mark cache state as bad if this fails.
//+-------------------------------------------------------------------------    

BOOL CStringCache::ExpandStringTable()
{
    // Note: we rely on the constructor to set m_ulMaxBytes to 0.
    if (m_ulMaxBytes == 0)  //first expansion
    {        
        OleDbgAssert(m_pStrings==NULL);
        m_ulMaxBytes = CACHE_MAX_BYTES_INITIAL;
    }
    else
    {
        // Each expansion doubles the current size.
        m_ulMaxBytes = m_ulMaxBytes*2;
    }

    // CoTaskMemRealloc does a simple alloc when m_pStrings is NULL.
    BYTE *pStrings = (BYTE *)CoTaskMemRealloc( m_pStrings, m_ulMaxBytes); 
    if (!pStrings) 
    {
        // Caller must mark cache as bad.
        return FALSE;
    }
    m_pStrings = pStrings;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::ExpandOffsetTable, Private
//
//  Synopsis:   Called to expand the memory block used to keep strings
//
//  History:    02-May-99   MPrabhu       Created
//
//  Notes:      This relies on MemRealloc to copy the existing contents.
//              Caller *must* mark cache state as bad if this fails.
//+-------------------------------------------------------------------------    
BOOL CStringCache::ExpandOffsetTable()
{
    // Note: we rely on the contructor to set m_ulMaxStringCount to 0.
    if (m_ulMaxStringCount == 0)
    {
        // first expansion
        OleDbgAssert(m_pOffsetTable==NULL);
        m_ulMaxStringCount =  MAX_INDEX_ENTRIES_INITIAL;
    }
    else
    {
        // at each expansion we double the current size.
        m_ulMaxStringCount = m_ulMaxStringCount*2;
    }
 
    // CoTaskMemRealloc does a simple alloc when m_pOffsetTable is NULL.
    ULONG *pTable = (ULONG *) CoTaskMemRealloc( m_pOffsetTable, 
                                sizeof(ULONG)*(m_ulMaxStringCount+1)); 
    if (!pTable) 
    {
        // Caller must mark the cache as bad.
        return FALSE;
    }
    m_pOffsetTable = pTable;
    if (m_ulMaxStringCount == (ULONG) MAX_INDEX_ENTRIES_INITIAL)
    {
        // initial expansion case
        m_pOffsetTable[0] = 0;  //byte offset for first string
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::NewCall, Public
//
//  Synopsis:   Called to notify the cache of a fresh OleUIInsertObject call
//
//  Parameters: [idFlags]       - dwFlags passed in LPOLEUIINSERTOBJECT struct
//              [cClsidExclude] - cClsidExclude   - do - 
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    

void CStringCache::NewCall(DWORD ioFlags, DWORD cClsidExclude)
{
    if ( (ioFlags != m_ioFlagsPrev)
        ||(cClsidExclude != m_cClsidExcludePrev) )
    {
        // We clear cache state if either:
        //       i) InsertObject call flags change from previous call
        //      ii) Number of clsIds to exclude has changed
        m_ioFlagsPrev = ioFlags;
        m_cClsidExcludePrev = cClsidExclude;
        
        FlushCache();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::IsUptodate, Public
//
//  Synopsis:   Called to check if the cache is up to date.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::IsUptodate()
{
    if (m_ulStringCount==0)
    {
        // The cache has never been setup or has been Flushed recently
        return FALSE;
    }

    BOOL bUptodate;
    
    // Check the notify event if it has fired since we set it up.
    DWORD res = WaitForSingleObject( m_hRegEvent, 
                                     0 );   // timeout for wait
    if (res == WAIT_TIMEOUT)
    {
        // Wait timed out => the reg key sub-tree has not changed
        // Our cache is up to date.
        bUptodate = TRUE;
    }
    else if (res == WAIT_OBJECT_0)
    {
        // Some CLSID must have changed => cache not up to date.
        bUptodate = FALSE;

        // We have to re-Register for the notification!
        ResetEvent(m_hRegEvent);
        res = RegNotifyChangeKeyValue(  m_hRegKey, 
                                        TRUE,   // watch sub-tree
                                        REG_NOTIFY_CHANGE_NAME 
                                      | REG_NOTIFY_CHANGE_LAST_SET,
                                        m_hRegEvent, 
                                        TRUE ); // asynchronous call                                        
        if (res != ERROR_SUCCESS)
        {
            // Cache is useless if we cannot watch CLSID sub-tree.
            gbOKToUseCache = FALSE;
        }
    }
    else
    {
        OleDbgAssert(!"Unexpected return from WaitForSingleObject");
        bUptodate = FALSE;
    }
    return bUptodate;
}


//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::AddString, Public
//
//  Synopsis:   Called to notify the cache of a fresh OleUIInsertObject call
//
//  Parameters: [lpStrAdd]  -   String to add to the cache.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::AddString(LPTSTR lpStrAdd)
{
    if (m_ulStringCount+2 == m_ulMaxStringCount)
    {
        // The offset array stores the offset of all the existing strings and
        // the next one to be added!
        // Hence at start of AddString, we must have enough space for the new
        // string being added *and* the next one (hence the +2 above)
        if (!ExpandOffsetTable())
        {
            // Something is really wrong.
            // Mark the cache as useless hereafter.
            gbOKToUseCache = FALSE;
            return FALSE;
        }
    }

    ULONG cbStrAdd = sizeof(TCHAR)*(lstrlen(lpStrAdd) + 1);
    ULONG offset = m_pOffsetTable[m_ulStringCount];

    if ( offset + cbStrAdd > m_ulMaxBytes )
    {
        // not enough space in the string block
        if (!ExpandStringTable())
        {
            // Something is really wrong.
            // Mark the cache as useless hereafter.
            gbOKToUseCache = FALSE;
            return FALSE;
        }
    }

    if (! lstrcpy( (TCHAR *)(m_pStrings+offset), lpStrAdd))
    {
        // Mark the cache as useless hereafter.
        gbOKToUseCache = FALSE;
        return FALSE;
    }

    // We have successfully added one more string to the cache.
    m_ulStringCount++;
    
    // Next string goes at this byte offset in m_pStrings.
    m_pOffsetTable[m_ulStringCount] =  offset + cbStrAdd;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::NextString, Public
//
//  Synopsis:   Used to obtain a pointer to the next string during
//              during cache enumeration.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
LPCTSTR CStringCache::NextString()
{
    if (m_ulNextStringNum > m_ulStringCount)
    {
        return NULL;
    }
    return (LPCTSTR) (m_pStrings+m_pOffsetTable[m_ulNextStringNum++-1]);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::ResetEnumerator, Public
//
//  Synopsis:   Used to reset the enumerator.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
void CStringCache::ResetEnumerator()
{
    m_ulNextStringNum = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::FlushCache, Public
//
//  Synopsis:   Invalidates the cache by clearing the counters.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::FlushCache()
{
    m_ulNextStringNum = 1;
    m_ulStringCount = 0;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::OKToUse, Public
//
//  Synopsis:   Used to check if cache is in good shape.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::OKToUse()
{
    return gbOKToUseCache;
}

#endif // USE_STRING_CACHE==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\uiclass.h ===
#define SZCLASSICONBOX1  "OLE2UIiconbox"
#define SZCLASSICONBOX2  "MFCUIA32iconbox"
#define SZCLASSICONBOX3  "MFCUIW32iconbox"
#define SZCLASSRESULTIMAGE1 "OLE2UIresimage"
#define SZCLASSRESULTIMAGE2 "MFCUIA32resimage"
#define SZCLASSRESULTIMAGE3 "MFCUIW32resimage"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\strcache.h ===
//+---------------------------------------------------------------------------
//
//  File:       strcache.h
//
//  Contents:   Insert object string caching support
//
//  Classes:    CStringCache
//
//  History:    02-May-99   MPrabhu      Created
//
//----------------------------------------------------------------------------
#ifndef _STRCACHE_H_
#define _STRCACHE_H_

#if USE_STRING_CACHE==1 

// Allocate enough memory to carry 64 UNICODE strings of MAX length each at init
#define CACHE_MAX_BYTES_INITIAL  (64 * (OLEUI_CCHKEYMAX_SIZE*2) * sizeof(TCHAR))

// Allocate enough memory for 128 string offsets at Init time
#define MAX_INDEX_ENTRIES_INITIAL   128

//+---------------------------------------------------------------------------
//
//  Class:      CStringCache
//
//  Contents:   Maintains the cache of insert object strings.
//
//  History:    02-May-99   MPrabhu      Created
//
//----------------------------------------------------------------------------
class CStringCache {
public:
    CStringCache();
    ~CStringCache(); 
    BOOL Init();
    void CleanUp();
    
    void NewCall(DWORD flags, DWORD cClsidExclude);

    BOOL AddString(LPTSTR lpStrAdd);
    LPCTSTR NextString();
    void ResetEnumerator();
    BOOL FlushCache();
    
    BOOL IsUptodate();
    BOOL OKToUse();
    
private:
    BOOL ExpandStringTable();
    BOOL ExpandOffsetTable();

    BYTE    *m_pStrings;        // All strings are stored sequentially in this.
    ULONG   *m_pOffsetTable;    // Array of offsets points to location of 
                                // strings in m_pStrings.
    ULONG   m_ulStringCount;    // Current count of strings.
    ULONG   m_ulMaxStringCount; // Current limit for # of strings cache can hold
    ULONG   m_ulMaxBytes;       // Current limit for byte size of string cache
                           // Since the cache grows as needed, both of these can
                           // change over time. However, that will be very rare.
    ULONG   m_ulNextStringNum;  // 1 based string sequence # for enumeration
    HANDLE  m_hRegEvent;        // We use these to watch changes to HKCR\ClsId
    HKEY    m_hRegKey;          // Set to HKCR\ClsID if Init() succeeds
    DWORD   m_ioFlagsPrev;      // Flags passed to a previous InsertObject call
    DWORD   m_cClsidExcludePrev;// cClsidExclude from a previous InsertObj call 
};

// Functions called through OleUIInitialize/OleUIUninitialize during
// DLL_PROCESS_ATTACH/DETACH.
BOOL InsertObjCacheInitialize();
void InsertObjCacheUninitialize();

#endif // USE_STRING_CACHE==1
#endif //_STRCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\targtdev.cpp ===
/*************************************************************************
**
**    OLE 2 Standard Utilities
**
**    olestd.c
**
**    This file contains utilities that are useful for dealing with
**    target devices.
**
**    (c) Copyright Microsoft Corp. 1992 All Rights Reserved
**
*************************************************************************/

#include "precomp.h"

STDAPI_(BOOL) OleStdCompareTargetDevice(
        DVTARGETDEVICE* ptdLeft, DVTARGETDEVICE* ptdRight)
{
        if (ptdLeft == ptdRight)
                // same address of td; must be same (handles NULL case)
                return TRUE;
        else if ((ptdRight == NULL) || (ptdLeft == NULL))
                return FALSE;
        else if (ptdLeft->tdSize != ptdRight->tdSize)
                // different sizes, not equal
                return FALSE;
        else if (memcmp(ptdLeft, ptdRight, ptdLeft->tdSize) != 0)
                // not same target device, not equal
                return FALSE;

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\utility.h ===
/*
 * UTILITY.H
 *
 * Miscellaneous prototypes and definitions for OLE UI dialogs.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _UTILITY_H_
#define _UTILITY_H_

#define CF_CLIPBOARDMIN   0xc000
#define CF_CLIPBOARDMAX   0xffff

// Function prototypes
// UTILITY.CPP
HCURSOR  WINAPI HourGlassOn(void);
void     WINAPI HourGlassOff(HCURSOR);

BOOL     WINAPI Browse(HWND, LPTSTR, LPTSTR, UINT, UINT, DWORD, UINT, LPOFNHOOKPROC);
int      WINAPI ReplaceCharWithNull(LPTSTR, int);
int      WINAPI ErrorWithFile(HWND, HINSTANCE, UINT, LPTSTR, UINT);
BOOL     WINAPI DoesFileExist(LPTSTR lpszFile, UINT cchMax);
LONG     WINAPI Atol(LPTSTR lpsz);
BOOL     WINAPI IsValidClassID(REFCLSID);
UINT     WINAPI GetFileName(LPCTSTR, LPTSTR, UINT);
BOOL     WINAPI IsValidMetaPict(HGLOBAL hMetaPict);

LPTSTR FindChar(LPTSTR lpsz, TCHAR ch);
LPTSTR FindReverseChar(LPTSTR lpsz, TCHAR ch);

LPTSTR FAR PASCAL PointerToNthField(LPTSTR, int, TCHAR);
BOOL FAR PASCAL GetAssociatedExecutable(LPTSTR, LPTSTR, UINT);
LPTSTR   WINAPI ChopText(HWND hwndStatic, int nWidth, LPTSTR lpch,
        int nMaxChars);
void     WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPTSTR lpszFile);
int WINAPI PopupMessage(HWND hwndParent, UINT idTitle, UINT idMessage, UINT fuStyle);
void WINAPI DiffPrefix(LPCTSTR lpsz1, LPCTSTR lpsz2, TCHAR FAR* FAR* lplpszPrefix1, TCHAR FAR* FAR* lplpszPrefix2);

// string formatting APIs
void WINAPI FormatStrings(LPTSTR, LPCTSTR, LPCTSTR*, int, int cchBuf);
void WINAPI FormatString1(LPTSTR, LPCTSTR, LPCTSTR, int cchBuf);
void WINAPI FormatString2(LPTSTR, LPCTSTR, LPCTSTR, LPCTSTR, int cchBuf);

// global instance to load strings/resources from
extern HINSTANCE _g_hOleStdInst;
extern HINSTANCE _g_hOleStdResInst;

// standard OLE 2.0 clipboard formats
extern UINT _g_cfObjectDescriptor;
extern UINT _g_cfLinkSrcDescriptor;
extern UINT _g_cfEmbedSource;
extern UINT _g_cfEmbeddedObject;
extern UINT _g_cfLinkSource;
extern UINT _g_cfOwnerLink;
extern UINT _g_cfFileName;

// Metafile utility functions
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPCRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPTSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL, LPTSTR, UINT FAR *);

#endif //_UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\template.h ===
/*
 * TEMPLATE.H
 *
 * CUSTOMIZATION INSTRUCTIONS:
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 *
 *
 *  1.  Replace <FILE> with the uppercased filename for this file.
 *      Lowercase the <FILE>.h entry
 *
 *  2.  Replace <NAME> with the mixed case dialog name in one word,
 *      such as InsertObject
 *
 *  3.  Replace <FULLNAME> with the mixed case dialog name in multiple
 *      words, such as Insert Object
 *
 *  4.  Replace <ABBREV> with the suffix for pointer variables, such
 *      as the IO in InsertObject's pIO or the CI in ChangeIcon's pCI.
 *      Check the alignment of the first variable declaration in the
 *      Dialog Proc after this.  I will probably be misaligned with the
 *      rest of the variables.
 *
 *  5.  Replace <STRUCT> with the uppercase structure name for this
 *      dialog sans OLEUI, such as INSERTOBJECT.  Changes OLEUI<STRUCT>
 *      in most cases, but we also use this for IDD_<STRUCT> as the
 *      standard template resource ID.
 *
 *  6.  Find <UFILL> fields and fill them out with whatever is appropriate.
 *
 *  7.  Delete this header up to the start of the next comment.
 *
 */


/*
 * <FILE>.H
 *
 * Internal definitions, structures, and function prototypes for the
 * OLE 2.0 UI <FULLNAME> dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef <UFILL>
#define <UFILL>

// UFILL>  Move from here to INTERNAL to to OLE2UI.H


typedef struct tagOLEUI<STRUCT>
{
	// These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCTSTR         lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCTSTR         lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	// Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.
} OLEUI<STRUCT>, *POLEUI<STRUCT>, FAR *LPOLEUI<STRUCT>;


// API Prototype
UINT FAR PASCAL OleUI<NAME>(LPOLEUI<STRUCT>);


// <FULLNAME> flags
#define <ABBREV>F_SHOWHELP                0x00000001L
<UFILL>


// <FULLNAME> specific error codes
// DEFINE AS OLEUI_<ABBREV>ERR_<ERROR>     (OLEUI_ERR_STANDARDMAX+n)
<UFILL>


// <FULLNAME> Dialog identifiers
// FILL IN DIALOG IDs HERE
<UFILL>





// INTERNAL INFORMATION STARTS HERE

// Internally used structure
typedef struct tag<STRUCT>
{
	//Keep this item first as the Standard* functions depend on it here.
	LPOLEUI<STRUCT>     lpO<ABBREV>;       //Original structure passed.
	UINT			nIDD;	// IDD of dialog (used for help info)

	/*
	 * What we store extra in this structure besides the original caller's
	 * pointer are those fields that we need to modify during the life of
	 * the dialog but that we don't want to change in the original structure
	 * until the user presses OK.
	 */

	<UFILL>
} <STRUCT>, *P<STRUCT>;


// Internal function prototypes
// <FILE>.CPP

BOOL FAR PASCAL <NAME>DialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL            F<NAME>Init(HWND hDlg, WPARAM, LPARAM);
<UFILL>


#endif //<UFILL>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\template.cpp ===
/*
 * TEMPLATE.CPP
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 *
 *
 * CUSTOMIZATION INSTRUCTIONS:
 *
 *  1.  Replace <FILE> with the uppercased filename for this file.
 *      Lowercase the <FILE>.h entry
 *
 *  2.  Replace <NAME> with the mixed case dialog name in one word,
 *      such as InsertObject
 *
 *  3.  Replace <FULLNAME> with the mixed case dialog name in multiple
 *      words, such as Insert Object
 *
 *  4.  Replace <ABBREV> with the suffix for pointer variables, such
 *      as the IO in InsertObject's pIO or the CI in ChangeIcon's pCI.
 *      Check the alignment of the first variable declaration in the
 *      Dialog Proc after this.  I will probably be misaligned with the
 *      rest of the variables.
 *
 *  5.  Replace <STRUCT> with the uppercase structure name for this
 *      dialog sans OLEUI, such as INSERTOBJECT.  Changes OLEUI<STRUCT>
 *      in most cases, but we also use this for IDD_<STRUCT> as the
 *      standard template resource ID.
 *
 *  6.  Find <UFILL> fields and fill them out with whatever is appropriate.
 *
 *  7.  Delete this header up to the start of the next comment.
 */


/*
 * <FILE>.CPP
 *
 * Implements the OleUI<NAME> function which invokes the complete
 * <FULLNAME> dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"

#include "template.h"

/*
 * OleUI<NAME>
 *
 * Purpose:
 *  Invokes the standard OLE <FULLNAME> dialog box allowing the user
 *  to <UFILL>
 *
 * Parameters:
 *  lp<ABBREV>            LPOLEUI<NAME> pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */

STDAPI_(UINT) OleUI<NAME>(LPOLEUI<STRUCT> lp<ABBREV>)
{
        UINT        uRet;
        HGLOBAL     hMemDlg=NULL;

        uRet = UStandardValidation((LPOLEUISTANDARD)lp<ABBREV>,
                sizeof(OLEUI<STRUCT>), &hMemDlg);

        if (OLEUI_SUCCESS!=uRet)
                return uRet;

        /*
         * PERFORM ANY STRUCTURE-SPECIFIC VALIDATION HERE!
         * ON FAILURE:
         *  {
         *  return OLEUI_<ABBREV>ERR_<ERROR>
         *  }
         */

        //Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(<NAME>DialogProc, (LPOLEUISTANDARD)lp<ABBREV>
                                                         , hMemDlg, MAKEINTRESOURCE(IDD_<STRUCT>));

        /*
         * IF YOU ARE CREATING ANYTHING BASED ON THE RESULTS, DO IT HERE.
         */
        <UFILL>

        return uRet;
}

/*
 * <NAME>DialogProc
 *
 * Purpose:
 *  Implements the OLE <FULLNAME> dialog as invoked through the
 *  OleUI<NAME> function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

BOOL CALLBACK <NAME>DialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        P<STRUCT>               p<ABBREV>;
        BOOL                    fHook=FALSE;

        //Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        //This will fail under WM_INITDIALOG, where we allocate it.
        p<ABBREV>=(<STRUCT>)PvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        //If the hook processed the message, we're done.
        if (0!=uHook)
                return (BOOL)uHook;

        //Process the temination message
        if (iMsg==uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (p<ABBREV>)
            {
                //Free any specific allocations before calling StandardCleanup
                StandardCleanup((PVOID)p<ABBREV>, hDlg);
            }
            break;
        case WM_INITDIALOG:
                F<NAME>Init(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDOK:
                        /*
                         * PERFORM WHATEVER FUNCTIONS ARE DEFAULT HERE.
                         */
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                        break;

                case IDCANCEL:
                        /*
                         * PERFORM ANY UNDOs HERE, BUT NOT CLEANUP THAT WILL
                         * ALWAYS HAPPEN WHICH SHOULD BE IN uMsgEndDialog.
                         */
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;

                case ID_OLEUIHELP:
                        PostMessage(p<ABBREV>->lpO<ABBREV>->hWndOwner, uMsgHelp
                                                , (WPARAM)hDlg, MAKELPARAM(IDD_<STRUCT>, 0));
                        break;
                }
        break;
        }
        return FALSE;
}


/*
 * F<NAME>Init
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the <FULLNAME> dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */

BOOL F<NAME>Init(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        P<STRUCT>               p<ABBREV>;
        LPOLEUI<STRUCT>         lpO<ABBREV>;
        HFONT                   hFont;

        //1.  Copy the structure at lParam into our instance memory.
        p<ABBREV>=(PSTRUCT)PvStandardInit(hDlg, sizeof(<STRUCT>), TRUE, &hFont);

        //PvStandardInit send a termination to us already.
        if (NULL==p<ABBREV>)
                return FALSE;

        lpO<ABBREV>=(LPOLEUI<STRUCT>)lParam);

        p<ABBREV>->lpO<ABBREV>=lpO<ABBREV>;

        //Copy other information from lpO<ABBREV> that we might modify.
        <UFILL>

        //2.  If we got a font, send it to the necessary controls.
        if (NULL!=hFont)
        {
                //Do this for as many controls as you need it for.
                SendDlgItemMessage(hDlg, ID_<UFILL>, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        //3.  Show or hide the help button
        if (!(p<ABBREV>->lpO<ABBREV>->dwFlags & <ABBREV>F_SHOWHELP))
                StandardShowDlgItem(hDlg, ID_OLEUIHELP, SW_HIDE);

        /*
         * PERFORM OTHER INITIALIZATION HERE.  ON ANY LoadString
         * FAILURE POST OLEUI_MSG_ENDDIALOG WITH OLEUI_ERR_LOADSTRING.
         */

        //n.  Call the hook with lCustData in lParam
        UStandardHook((PVOID)p<ABBREV>, hDlg, WM_INITDIALOG, wParam, lpO<ABBREV>->lCustData);
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\winres.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINDOWS.H
//          Version 3.10
//          Copyright (c) 1985-1992, Microsoft Corp. All rights reserved.
//

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#define OBM_CLOSE       32754
#define OBM_UPARROW     32753
#define OBM_DNARROW     32752
#define OBM_RGARROW     32751
#define OBM_LFARROW     32750
#define OBM_REDUCE      32749
#define OBM_ZOOM        32748
#define OBM_RESTORE     32747
#define OBM_REDUCED     32746
#define OBM_ZOOMD       32745
#define OBM_RESTORED    32744
#define OBM_UPARROWD    32743
#define OBM_DNARROWD    32742
#define OBM_RGARROWD    32741
#define OBM_LFARROWD    32740
#define OBM_MNARROW     32739
#define OBM_COMBO       32738
#define OBM_UPARROWI    32737
#define OBM_DNARROWI    32736
#define OBM_RGARROWI    32735
#define OBM_LFARROWI    32734
#define OBM_OLD_CLOSE   32767
#define OBM_SIZE        32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE      32761
#define OBM_CHECK       32760
#define OBM_CHECKBOXES  32759
#define OBM_BTNCORNERS  32758
#define OBM_OLD_REDUCE  32757
#define OBM_OLD_ZOOM    32756
#define OBM_OLD_RESTORE 32755
#define OCR_NORMAL      32512
#define OCR_IBEAM       32513
#define OCR_WAIT        32514
#define OCR_CROSS       32515
#define OCR_UP          32516
#define OCR_SIZE        32640
#define OCR_ICON        32641
#define OCR_SIZENWSE    32642
#define OCR_SIZENESW    32643
#define OCR_SIZEWE      32644
#define OCR_SIZENS      32645
#define OCR_SIZEALL     32646
#define OCR_ICOCUR      32647
#define OIC_SAMPLE      32512
#define OIC_HAND        32513
#define OIC_QUES        32514
#define OIC_BANG        32515
#define OIC_NOTE        32516

#define WS_OVERLAPPED   0x00000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_MINIMIZE     0x20000000L
#define WS_MAXIMIZE     0x01000000L
#define WS_CAPTION      0x00C00000L
#define WS_BORDER       0x00800000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_THICKFRAME   0x00040000L
#define WS_MINIMIZEBOX  0x00020000L
#define WS_MAXIMIZEBOX  0x00010000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

// other aliases
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW  (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW  (WS_CHILD)
#define WS_TILED        WS_OVERLAPPED
#define WS_ICONIC       WS_MINIMIZE
#define WS_SIZEBOX      WS_THICKFRAME
#define WS_TILEDWINDOW  WS_OVERLAPPEDWINDOW

#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

#define DS_ABSALIGN     0x01L
#define DS_SYSMODAL     0x02L
#define DS_LOCALEDIT    0x20L
#define DS_SETFONT      0x40L
#define DS_MODALFRAME   0x80L
#define DS_NOIDLEMSG    0x100L

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

#define SS_LEFT         0x00000000L
#define SS_CENTER       0x00000001L
#define SS_RIGHT        0x00000002L
#define SS_ICON         0x00000003L
#define SS_BLACKRECT    0x00000004L
#define SS_GRAYRECT     0x00000005L
#define SS_WHITERECT    0x00000006L
#define SS_BLACKFRAME   0x00000007L
#define SS_GRAYFRAME    0x00000008L
#define SS_WHITEFRAME   0x00000009L
#define SS_SIMPLE       0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_NOPREFIX     0x00000080L

#define BS_PUSHBUTTON   0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX     0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON  0x00000004L
#define BS_3STATE       0x00000005L
#define BS_AUTO3STATE   0x00000006L
#define BS_GROUPBOX     0x00000007L
#define BS_USERBUTTON   0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT     0x00000020L

#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L

#define SBS_HORZ        0x0000L
#define SBS_VERT        0x0001L
#define SBS_TOPALIGN    0x0002L
#define SBS_LEFTALIGN   0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN  0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX     0x0008L

#define LBS_NOTIFY      0x0001L
#define LBS_SORT        0x0002L
#define LBS_NOREDRAW    0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS  0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#define LBS_STANDARD    (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE      0x0001L
#define CBS_DROPDOWN    0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT  0x0080L
#define CBS_SORT        0x0100L
#define CBS_HASSTRINGS  0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L

// operation messages sent to DLGINIT
#define WM_USER         0x0400
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\utility.cpp ===
/*
 * UTILITY.CPP
 *
 * Utility routines for functions inside OLEDLG.DLL
 *
 *  General:
 *  ----------------------
 *  HourGlassOn             Displays the hourglass
 *  HourGlassOff            Hides the hourglass
 *
 *  Misc Tools:
 *  ----------------------
 *  Browse                  Displays the "File..." or "Browse..." dialog.
 *  ReplaceCharWithNull     Used to form filter strings for Browse.
 *  ErrorWithFile           Creates an error message with embedded filename
 *  OpenFileError           Give error message for OpenFile error return
 *  ChopText                Chop a file path to fit within a specified width
 *  DoesFileExist           Checks if file is valid
 *
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include <stdlib.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include "utility.h"
#include "strsafe.h"

OLEDBGDATA

// helper function for DisFileExists. Not for general use.
BOOL WINAPI FIsDiskFile(LPTSTR lpszFile)
{
    BOOL fRet = FALSE;
    
    if (lpszFile == NULL)
    {
        goto end;
    }
        
    HANDLE hFile = CreateFile(lpszFile,
                                   0, 0, NULL,
                                   OPEN_EXISTING,
                                   0, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (GetFileType(hFile) == FILE_TYPE_DISK)
        {
            fRet = TRUE;
        }
        
        CloseHandle(hFile);
    }
    

end:
    return fRet;
}



/*
 * HourGlassOn
 *
 * Purpose:
 *  Shows the hourglass cursor returning the last cursor in use.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HCURSOR         Cursor in use prior to showing the hourglass.
 */

HCURSOR WINAPI HourGlassOn(void)
{
        HCURSOR     hCur;

        hCur=SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowCursor(TRUE);

        return hCur;
}


/*
 * HourGlassOff
 *
 * Purpose:
 *  Turns off the hourglass restoring it to a previous cursor.
 *
 * Parameters:
 *  hCur            HCURSOR as returned from HourGlassOn
 *
 * Return Value:
 *  None
 */

void WINAPI HourGlassOff(HCURSOR hCur)
{
        ShowCursor(FALSE);
        SetCursor(hCur);
        return;
}


/*
 * Browse
 *
 * Purpose:
 *  Displays the standard GetOpenFileName dialog with the title of
 *  "Browse."  The types listed in this dialog are controlled through
 *  iFilterString.  If it's zero, then the types are filled with "*.*"
 *  Otherwise that string is loaded from resources and used.
 *
 * Parameters:
 *  hWndOwner       HWND owning the dialog
 *  lpszFile        LPSTR specifying the initial file and the buffer in
 *                  which to return the selected file.  If there is no
 *                  initial file the first character of this string should
 *                  be NULL.
 *  lpszInitialDir  LPSTR specifying the initial directory.  If none is to
 *                  set (ie, the cwd should be used), then this parameter
 *                  should be NULL.
 *  cchFile         UINT length of pszFile
 *  iFilterString   UINT index into the stringtable for the filter string.
 *  dwOfnFlags      DWORD flags to OR with OFN_HIDEREADONLY
 *  nBrowseID
 *  lpfnHook        Callback Hook Proceedure.  Set if OFN_ENABLE_HOOK is
 *                  in dwOfnFlags else it should be NULL.
 *
 * Return Value:
 *  BOOL            TRUE if the user selected a file and pressed OK.
 *                  FALSE otherwise, such as on pressing Cancel.
 */

BOOL WINAPI Browse(HWND hWndOwner, LPTSTR lpszFile, LPTSTR lpszInitialDir, UINT cchFile,
        UINT iFilterString, DWORD dwOfnFlags, UINT nBrowseID, LPOFNHOOKPROC lpfnHook)
{
        UINT    cch;
        TCHAR   szFilters[256];
        TCHAR   szDlgTitle[128];  // that should be big enough

        if (NULL == lpszFile || 0 == cchFile)
                return FALSE;

        /*
         * Exact contents of the filter combobox is TBD.  One idea
         * is to take all the extensions in the RegDB and place them in here
         * with the descriptive class name associate with them.  This has the
         * extra step of finding all extensions of the same class handler and
         * building one extension string for all of them.  Can get messy quick.
         * UI demo has only *.* which we do for now.
         */

        if (0 != iFilterString)
        {
                cch = LoadString(_g_hOleStdResInst, iFilterString, szFilters,
                        sizeof(szFilters)/sizeof(TCHAR));
        }
        else
        {
                szFilters[0] = 0;
                cch = 1;
        }

        if (0 == cch)
                return FALSE;

        ReplaceCharWithNull(szFilters, szFilters[cch-1]);

        // Prior string must also be initialized, if there is one.
        OPENFILENAME ofn;
        memset(&ofn, 0, sizeof(ofn));
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner   = hWndOwner;
        ofn.lpstrFile   = lpszFile;
        ofn.nMaxFile    = cchFile;
        ofn.lpstrFilter = szFilters;
        ofn.nFilterIndex = 1;
        ofn.lpfnHook = lpfnHook;
        if (LoadString(_g_hOleStdResInst, IDS_BROWSE, szDlgTitle, sizeof(szDlgTitle)/sizeof(TCHAR)))
                ofn.lpstrTitle  = szDlgTitle;
        ofn.hInstance = _g_hOleStdResInst;
        if (NULL != lpszInitialDir)
                ofn.lpstrInitialDir = lpszInitialDir;
        ofn.Flags = OFN_HIDEREADONLY | dwOfnFlags;
        if (bWin4)
            ofn.Flags |= OFN_EXPLORER;

        // Lastly, parent to tweak OFN parameters
        if (hWndOwner != NULL)
                SendMessage(hWndOwner, uMsgBrowseOFN, nBrowseID, (LPARAM)&ofn);

        // On success, copy the chosen filename to the static display
        BOOL bResult = StandardGetOpenFileName((LPOPENFILENAME)&ofn);
        return bResult;
}

/*
 * ReplaceCharWithNull
 *
 * Purpose:
 *  Walks a null-terminated string and replaces a given character
 *  with a zero.  Used to turn a single string for file open/save
 *  filters into the appropriate filter string as required by the
 *  common dialog API.
 *
 * Parameters:
 *  psz             LPTSTR to the string to process.
 *  ch              int character to replace.
 *
 * Return Value:
 *  int             Number of characters replaced.  -1 if psz is NULL.
 */

int WINAPI ReplaceCharWithNull(LPTSTR psz, int ch)
{
        int cChanged = 0;

        if (psz == NULL)
                return -1;

        while ('\0' != *psz)
        {
                if (ch == *psz)
                {
                        *psz++ = '\0';
                        cChanged++;
                        continue;
                }
                psz = CharNext(psz);
        }
        return cChanged;
}

/*
 * ErrorWithFile
 *
 * Purpose:
 *  Displays a message box built from a stringtable string containing
 *  one %s as a placeholder for a filename and from a string of the
 *  filename to place there.
 *
 * Parameters:
 *  hWnd            HWND owning the message box.  The caption of this
 *                  window is the caption of the message box.
 *  hInst           HINSTANCE from which to draw the idsErr string.
 *  idsErr          UINT identifier of a stringtable string containing
 *                  the error message with a %s.
 *  lpszFile        LPSTR to the filename to include in the message.
 *  uFlags          UINT flags to pass to MessageBox, like MB_OK.
 *
 * Return Value:
 *  int             Return value from MessageBox.
 */

int WINAPI ErrorWithFile(HWND hWnd, HINSTANCE hInst, UINT idsErr,
        LPTSTR pszFile, UINT uFlags)
{
        int             iRet=0;
        HANDLE          hMem;
        const UINT      cb = (2*MAX_PATH);
        LPTSTR          psz1, psz2, psz3;

        if (NULL == hInst || NULL == pszFile)
                return iRet;

        // Allocate three 2*MAX_PATH byte work buffers
        hMem=GlobalAlloc(GHND, (DWORD)(3*cb)*sizeof(TCHAR));

        if (NULL==hMem)
                return iRet;

        psz1 = (LPTSTR)GlobalLock(hMem);
        psz2 = psz1+cb;
        psz3 = psz2+cb;

        if (0 != LoadString(hInst, idsErr, psz1, cb))
        {
                StringCchPrintf(psz2, cb, psz1, pszFile);

                // Steal the caption of the dialog
                GetWindowText(hWnd, psz3, cb);
                iRet=MessageBox(hWnd, psz2, psz3, uFlags);
        }

        GlobalUnlock(hMem);
        GlobalFree(hMem);
        return iRet;
}

// returns width of line of text. this is a support routine for ChopText
static LONG GetTextWSize(HDC hDC, LPTSTR lpsz)
{
        SIZE size;

        if (GetTextExtentPoint(hDC, lpsz, lstrlen(lpsz), (LPSIZE)&size))
                return size.cx;
        else
                return 0;
}

LPTSTR FindChar(LPTSTR lpsz, TCHAR ch)
{
        while (*lpsz != 0)
        {
                if (*lpsz == ch)
                        return lpsz;
                lpsz = CharNext(lpsz);
        }
        return NULL;
}

LPTSTR FindReverseChar(LPTSTR lpsz, TCHAR ch)
{
        LPTSTR lpszLast = NULL;
        while (*lpsz != 0)
        {
                if (*lpsz == ch)
                        lpszLast = lpsz;
                lpsz = CharNext(lpsz);
        }
        return lpszLast;
}

static void WINAPI Abbreviate(HDC hdc, int nWidth, LPTSTR lpch, int nMaxChars)
{
        /* string is too long to fit; chop it */
        /* set up new prefix & determine remaining space in control */
        int cchNew = 0;
        LPTSTR lpszFileName = NULL;
        LPTSTR lpszCur = CharNext(CharNext(lpch));
        lpszCur = FindChar(lpszCur, TEXT('\\'));

        // algorithm will insert \... so allocate extra 4
        int cch = lstrlen(lpch) + 5;
        LPTSTR lpszNew = (LPTSTR)OleStdMalloc(cch * sizeof(TCHAR));
        if (lpszNew == NULL)
                return;

        if (lpszCur != NULL)  // at least one backslash
        {
                *lpszNew = (TCHAR)0;
                *lpszCur = (TCHAR)0;
                StringCchCopy(lpszNew, cch, lpch);
                *lpszCur = TEXT('\\');
                // lpszNew now contains c: or \\servername
                StringCchCat(lpszNew, cch, TEXT("\\..."));
                // lpszNew now contains c:\... or \\servername\...
                LPTSTR lpszEnd = lpszNew;
                while (*lpszEnd != (TCHAR)0)
                        lpszEnd = CharNext(lpszEnd);
                // lpszEnd is now at the end of c:\... or \\servername\...

                // move down directories until it fits or no more directories
                while (lpszCur != NULL)
                {
                        *lpszEnd = (TCHAR)0;
                        cchNew = lstrlen(lpszNew);
                        StringCchCat(lpszEnd, cch - cchNew, lpszCur);
                        if (GetTextWSize(hdc, lpszNew) <= nWidth &&
                                lstrlen(lpszNew) < nMaxChars)
                        {
                                StringCchCopy(lpch, nMaxChars, lpszNew);
                                OleStdFree(lpszNew);
                                return;
                        }
                        lpszCur = CharNext(lpszCur);    // advance past backslash
                        lpszCur = FindChar(lpszCur, TEXT('\\'));
                }

                // try just ...filename and then shortening filename
                lpszFileName = FindReverseChar(lpch, TEXT('\\'));
        }
        else
                lpszFileName = lpch;

        while (*lpszFileName != (TCHAR)0)
        {
                StringCchCopy(lpszNew, cch, TEXT("..."));
                StringCchCat(lpszNew, cch, lpszFileName);
                if (GetTextWSize(hdc, lpszNew) <= nWidth && lstrlen(lpszNew) < nMaxChars)
                {
                        lstrcpyn(lpch, lpszNew, nMaxChars);
                        OleStdFree(lpszNew);
                        return;
                }
                lpszFileName = CharNext(lpszFileName);
        }

        OleStdFree(lpszNew);

        // not even a single character fit
        *lpch = (TCHAR)0;
}

/*
 * ChopText
 *
 * Purpose:
 *  Parse a string (pathname) and convert it to be within a specified
 *  length by chopping the least significant part
 *
 * Parameters:
 *  hWnd            window handle in which the string resides
 *  nWidth          max width of string in pixels
 *                  use width of hWnd if zero
 *  lpch            pointer to beginning of the string
 *  nMaxChars       maximum allowable number of characters (0 ignore)
 *
 * Return Value:
 *  pointer to the modified string
 */
LPTSTR WINAPI ChopText(HWND hWnd, int nWidth, LPTSTR lpch, int nMaxChars)
{
        HDC     hdc;
        HFONT   hfont;
        HFONT   hfontOld = NULL;
        RECT    rc;

        if (!hWnd || !lpch)
            return NULL;

        if (nMaxChars == 0)
            nMaxChars = 32768; // big number

        /* Get length of static field. */
        if (!nWidth)
        {
            GetClientRect(hWnd, (LPRECT)&rc);
            nWidth = rc.right - rc.left;
        }
        
        /* Set up DC appropriately for the static control */
        hdc = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);
		
		/* CreateIC can return NULL in low memory situations */
		if (hdc != NULL)
		{
			hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
        
			if (NULL != hfont)   // WM_GETFONT returns NULL if window uses system font
				hfontOld = (HFONT)SelectObject(hdc, hfont);
        
			/* check horizontal extent of string */
			if (GetTextWSize(hdc, lpch) > nWidth || lstrlen(lpch) >= nMaxChars)
				Abbreviate(hdc, nWidth, lpch, nMaxChars);
        
			if (NULL != hfont)
				SelectObject(hdc, hfontOld);
			DeleteDC(hdc);
        }

        return lpch;
}

/*
 * OpenFileError
 *
 * Purpose:
 *  display message for error returned from OpenFile
 *
 * Parameters:
 *  hDlg            HWND of the dialog.
 *  nErrCode        UINT error code returned in OFSTRUCT passed to OpenFile
 *  lpszFile        LPSTR file name passed to OpenFile
 *
 * Return Value:
 *  None
 */
void WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPTSTR lpszFile)
{
        switch (nErrCode)
        {
        case 0x0005:    // Access denied
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIFILEACCESS, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;

        case 0x0020:    // Sharing violation
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIFILESHARE, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;

        case 0x0002:    // File not found
        case 0x0003:    // Path not found
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIINVALIDFILE, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;

        default:
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIFILEOPENFAIL, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;
        }
}

/*
 * DoesFileExist
 *
 * Purpose:
 *  Determines if a file path exists
 *
 * Parameters:
 *  lpszFile        LPTSTR - file name
 *  cchMax          UINT - size of the lpszFile string buffer in characters.
 *
 * Return Value:
 *  BOOL            TRUE if file exists, else FALSE.
 *
 * NOTE: lpszFile may be changed as a result of this call to match the first
 *       matching file name found by this routine.
 *
 */
BOOL WINAPI DoesFileExist(LPTSTR lpszFile, UINT cchMax)
{
        // First try to find the file with an exact match
        BOOL fFound = TRUE;
        // check the file's attributes
        DWORD dwAttrs = GetFileAttributes(lpszFile);
        
        if (dwAttrs == 0xFFFFFFFF)  // file wasn't found
        {
            fFound = FALSE;
            // look in path for file
            TCHAR szTempFileName[MAX_PATH];
            LPTSTR lpszFilePart;
            DWORD cch = SearchPath(NULL, lpszFile, NULL, MAX_PATH, szTempFileName, &lpszFilePart);
            
            // if cch > MAX_PATH, we won't process file.
            if (cch > MAX_PATH - 1)
            {
                goto end;
            }
            else if (cch > 0)
            {
                fFound = TRUE;
            }
                
            if (!fFound)
            {
                // File wasn't found in the search path
                // Try to append a .* and use FindFirstFile to try for a match in the current directory
                UINT cchFile = lstrlen(lpszFile);
                if (cchFile + 4 < MAX_PATH)
                {
                    WIN32_FIND_DATA sFindFileData;
                    StringCchCopy(szTempFileName, sizeof(szTempFileName)/sizeof(szTempFileName[0]), lpszFile);
                    StringCchCat(szTempFileName, sizeof(szTempFileName)/sizeof(szTempFileName[0]), TEXT("*.*"));
                    HANDLE hFindFile = FindFirstFile(szTempFileName, &sFindFileData);
                    if (INVALID_HANDLE_VALUE != hFindFile)
                    {
                        // found something
                        while (0 != (sFindFileData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_TEMPORARY)))
                        {
                            // found a directory or a temporary file try again
                            if (!FindNextFile(hFindFile, &sFindFileData))
                            {
                                // Could only match a directory or temporary file.
                                FindClose(hFindFile);
                                fFound = FALSE;
                                goto end;
                            }
                        }
                        // Copy the name of the found file into the end of the path in the
                        // temporary buffer (if any).
                        // First scan back for the last file separator.
                        UINT cchPath = lstrlen(szTempFileName);
                        while (cchPath)
                        {
                            if (_T('\\') == szTempFileName[cchPath - 1]
                                || _T('/') == szTempFileName[cchPath - 1])
                            {
                                break;
                            }
                            cchPath--;
                        }
                        lstrcpyn(&szTempFileName[cchPath], sFindFileData.cFileName, MAX_PATH - cchPath);
                        fFound = TRUE;
                        FindClose(hFindFile);
                    }
                }
            }
            
            if (fFound)
            {
                // copy the temporary buffer into szFile
                if (FIsDiskFile(szTempFileName))
                {
                    lstrcpyn(lpszFile, szTempFileName, cchMax -1);
                    goto end;
                }
                else
                {
                    fFound = FALSE;
                    goto end;
                }
            }
        }
        else if (dwAttrs & (FILE_ATTRIBUTE_DIRECTORY|
                FILE_ATTRIBUTE_TEMPORARY))
        {
                fFound = FALSE;
        }
        else if (!FIsDiskFile(lpszFile))
        {
            fFound = FALSE;
        }
   
end:

    return fFound;
}

/*
 * FormatStrings
 *
 * Purpose:
 *  Simple message formatting API compatible w/ different languages
 *
 * Note:
 *  Shamelessly stolen/modified from MFC source code
 *
 */

void WINAPI FormatStrings(LPTSTR lpszDest, LPCTSTR lpszFormat,
        LPCTSTR* rglpsz, int nString, int cchDest)
{
        LPCTSTR pchSrc = lpszFormat;
        while (*pchSrc != '\0' && cchDest > 1)
        {
                if (pchSrc[0] == '%' && (pchSrc[1] >= '1' && pchSrc[1] <= '9'))
                {
                        int i = pchSrc[1] - '1';
                        pchSrc += 2;
                        if (i >= nString)
                        {
                                *lpszDest++ = _T('?');
                                --cchDest;
                        }
                        else if (rglpsz[i] != NULL)
                        {
                                StringCchCopy(lpszDest, cchDest, rglpsz[i]);
                                cchDest -= lstrlen(lpszDest);
                                lpszDest += lstrlen(lpszDest);
                        }
                }
                else
                {
                        *lpszDest++ = *pchSrc++;
                        --cchDest;
                }
        }
        *lpszDest = _T('\0');
}

void WINAPI FormatString1(LPTSTR lpszDest, LPCTSTR lpszFormat, LPCTSTR lpsz1, int cchDest)
{
        FormatStrings(lpszDest, lpszFormat, &lpsz1, 1, cchDest);
}

void WINAPI FormatString2(LPTSTR lpszDest, LPCTSTR lpszFormat, LPCTSTR lpsz1,
        LPCTSTR lpsz2, int cchDest)
{
        LPCTSTR rglpsz[2];
        rglpsz[0] = lpsz1;
        rglpsz[1] = lpsz2;
        FormatStrings(lpszDest, lpszFormat, rglpsz, 2, cchDest);
}

// Replacement for stdlib atol,
// which didn't work and doesn't take far pointers.
// Must be tolerant of leading spaces.
//
//
LONG WINAPI Atol(LPTSTR lpsz)
{
        signed int sign = +1;
        UINT base = 10;
        LONG l = 0;

        if (NULL==lpsz)
        {
                OleDbgAssert (0);
                return 0;
        }
        while (*lpsz == ' ' || *lpsz == '\t' || *lpsz == '\n')
                lpsz++;

        if (*lpsz=='-')
        {
                lpsz++;
                sign = -1;
        }
        if (lpsz[0] == TEXT('0') && lpsz[1] == TEXT('x'))
        {
                base = 16;
                lpsz+=2;
        }

        if (base == 10)
        {
                while (*lpsz >= '0' && *lpsz <= '9')
                {
                        l = l * base + *lpsz - '0';
                        lpsz++;
                }
        }
        else
        {
                OleDbgAssert(base == 16);
                while (*lpsz >= '0' && *lpsz <= '9' ||
                        *lpsz >= 'A' && *lpsz <= 'F' ||
                        *lpsz >= 'a' && *lpsz <= 'f')
                {
                        l = l * base;
                        if (*lpsz >= '0' && *lpsz <= '9')
                                l += *lpsz - '0';
                        else if (*lpsz >= 'a' && *lpsz <= 'f')
                                l += *lpsz - 'a' + 10;
                        else
                                l += *lpsz - 'A' + 10;
                        lpsz++;
                }
        }
        return l * sign;
}

BOOL WINAPI IsValidClassID(REFCLSID clsid)
{
        return clsid != CLSID_NULL;
}

/* PopupMessage
 * ------------
 *
 *  Purpose:
 *      Popup messagebox and get some response from the user. It is the same
 *      as MessageBox() except that the title and message string are loaded
 *      from the resource file.
 *
 *  Parameters:
 *      hwndParent      parent window of message box
 *      idTitle         id of title string
 *      idMessage       id of message string
 *      fuStyle         style of message box
 */
int WINAPI PopupMessage(HWND hwndParent, UINT idTitle, UINT idMessage, UINT fuStyle)
{
        TCHAR szTitle[256];
        TCHAR szMsg[256];

        LoadString(_g_hOleStdResInst, idTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR));
        LoadString(_g_hOleStdResInst, idMessage, szMsg, sizeof(szMsg)/sizeof(TCHAR));
        return MessageBox(hwndParent, szMsg, szTitle, fuStyle);
}

/* DiffPrefix
 * ----------
 *
 *  Purpose:
 *      Compare (case-insensitive) two strings and return the prefixes of the
 *      the strings formed by removing the common suffix string from them.
 *      Integrity of tokens (directory name, filename and object names) are
 *      preserved. Note that the prefixes are converted to upper case
 *      characters.
 *
 *  Parameters:
 *      lpsz1           string 1
 *      lpsz2           string 2
 *      lplpszPrefix1   prefix of string 1
 *      lplpszPrefix2   prefix of string 2
 *
 *  Returns:
 *
 */
void WINAPI DiffPrefix(LPCTSTR lpsz1, LPCTSTR lpsz2, TCHAR FAR* FAR* lplpszPrefix1, TCHAR FAR* FAR* lplpszPrefix2)
{
        LPTSTR  lpstr1;
        LPTSTR  lpstr2;
        TCHAR   szTemp1[MAX_PATH];
        TCHAR   szTemp2[MAX_PATH];

        OleDbgAssert(lpsz1);
        OleDbgAssert(lpsz2);
        OleDbgAssert(*lpsz1);
        OleDbgAssert(*lpsz2);
        OleDbgAssert(lplpszPrefix1);
        OleDbgAssert(lplpszPrefix2);

        // need to copy into temporary for case insensitive compare
        StringCchCopy(szTemp1, sizeof(szTemp1)/sizeof(szTemp1[0]), lpsz1);
        StringCchCopy(szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0]), lpsz2);
        CharLower(szTemp1);
        CharLower(szTemp2);

        // do comparison
        lpstr1 = szTemp1 + lstrlen(szTemp1);
        lpstr2 = szTemp2 + lstrlen(szTemp2);

        while ((lpstr1 > szTemp1) && (lpstr2 > szTemp2))
        {
                lpstr1 = CharPrev(szTemp1, lpstr1);
                lpstr2 = CharPrev(szTemp2, lpstr2);
                if (*lpstr1 != *lpstr2)
                {
                        lpstr1 = CharNext(lpstr1);
                        lpstr2 = CharNext(lpstr2);
                        break;
                }
        }

        // scan forward to first delimiter
        while (*lpstr1 && *lpstr1 != '\\' && *lpstr1 != '!')
                lpstr1 = CharNext(lpstr1);
        while (*lpstr2 && *lpstr2 != '\\' && *lpstr2 != '!')
                lpstr2 = CharNext(lpstr2);

        *lpstr1 = '\0';
        *lpstr2 = '\0';

        // initialize in case of failure
        *lplpszPrefix1 = NULL;
        *lplpszPrefix2 = NULL;

        // allocate memory for the result
        *lplpszPrefix1 = (LPTSTR)OleStdMalloc((lstrlen(lpsz1)+1) * sizeof(TCHAR));
        if (!*lplpszPrefix1)
                return;

        *lplpszPrefix2 = (LPTSTR)OleStdMalloc((lstrlen(lpsz2)+1) * sizeof(TCHAR));
        if (!*lplpszPrefix2)
        {
                OleStdFree(*lplpszPrefix1);
                *lplpszPrefix1 = NULL;
                return;
        }

        // copy result
        lstrcpyn(*lplpszPrefix1, lpsz1, lstrlen(szTemp1)+1);
        lstrcpyn(*lplpszPrefix2, lpsz2, lstrlen(szTemp2)+1);
}

UINT WINAPI GetFileName(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax)
{
        // always capture the complete file name including extension (if present)
        LPTSTR lpszTemp = (LPTSTR)lpszPathName;
        for (LPCTSTR lpsz = lpszPathName; *lpsz != '\0'; lpsz = CharNext(lpsz))
        {
                // remember last directory/drive separator
                if (*lpsz == '\\' || *lpsz == '/' || *lpsz == ':')
                        lpszTemp = CharNext(lpsz);
        }

        // lpszTitle can be NULL which just returns the number of bytes
        if (lpszTitle == NULL)
                return lstrlen(lpszTemp)+1;

        // otherwise copy it into the buffer provided
        lstrcpyn(lpszTitle, lpszTemp, nMax);
        return 0;
}

BOOL WINAPI IsValidMetaPict(HGLOBAL hMetaPict)
{
    BOOL fReturn = FALSE;
    LPMETAFILEPICT pMF = (LPMETAFILEPICT) GlobalLock(hMetaPict);
    if (pMF != NULL)
    {
        if (!IsBadReadPtr( pMF, sizeof(METAFILEPICT)))
        {
            if (GetMetaFileBitsEx(pMF->hMF, 0, 0))
            {
                fReturn = TRUE;
            }
        }
        GlobalUnlock(hMetaPict);
    }
    return(fReturn);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\about.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       about.cxx
//
//  Contents:   implementation for a simple about dialog box
//
//  Classes:    CAbout
//
//  Functions:
//
//  History:    6-08-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "about.h"


//+---------------------------------------------------------------------------
//
//  Member:     CAbout::DialogProc
//
//  Synopsis:   dialog proc for the About dialog box
//
//  Arguments:  [uMsg]   - message
//              [wParam] - first message parameter
//              [lParam] - second message parameter
//
//  History:    4-12-94   stevebl   Created for MFract
//              6-08-94   stevebl   Stolen from MFract
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK CAbout::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return(TRUE);
    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK
            || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, TRUE);
            return(TRUE);
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\about.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       about.h
//
//  Contents:   definition for an about dialog box class
//
//  Classes:    CAbout
//
//  Functions:
//
//  History:    6-08-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __ABOUT_H__
#define __ABOUT_H__

#include <cdialog.h>

#ifdef __cplusplus

//+---------------------------------------------------------------------------
//
//  Class:      CAbout
//
//  Purpose:    implements the about dialog box
//
//  Interface:  DialogProc -- dialog procedure
//
//  History:    6-08-94   stevebl   Created
//
//----------------------------------------------------------------------------

class CAbout: public CHlprDialog
{
public:
    INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif //__cplusplus

#endif //__ABOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\mfcui\mfcui.cpp ===
// ===========================================================================
// File: M F C U I . C P P
// 
// Copyright 1995 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential
// ===========================================================================
#ifndef UNICODE

// %%Includes: ---------------------------------------------------------------
#include <windows.h>
#include <ole2.h>
#include <oledlg.h>

// %%Prototypes: -------------------------------------------------------------
STDAPI Ole2AnsiWFromA(REFIID riid, LPUNKNOWN punkWrappeeA, LPUNKNOWN *ppunkWrapperW);
STDAPI Ole2AnsiAFromW(REFIID riid, LPUNKNOWN punkWrappeeW, LPUNKNOWN *ppunkWrapperA);


// ---------------------------------------------------------------------------
// %%Function: OleUIAddVerbMenu                           %%Reviewed: 00/00/95
// 
// Description:
//  Wraps OleUIAddVerbMenu to OLEDLG.DLL for MFC clients, which expect to be
// able to pass Ansi IOleObject's.
// ---------------------------------------------------------------------------
#undef OleUIAddVerbMenu     // overrides the Ansi/Unicode macros in OLEDLG.H
 STDAPI_(BOOL)
OleUIAddVerbMenu(LPOLEOBJECT lpOleObjA, LPCSTR lpszShortType,
        HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu)
{
    LPOLEOBJECT lpOleObjW = NULL;
    BOOL        fResult = FALSE;

    // allow NULL IOleObject (OleUIAddVerbMenuA handles this by making an empty menu), but
    // otherwise wrap the Ansi IOleObject to Unicode.
    if (lpOleObjA == NULL ||
        SUCCEEDED(Ole2AnsiWFromA(IID_IOleObject, (LPUNKNOWN)lpOleObjA, (LPUNKNOWN *)&lpOleObjW)))
        {
        fResult = OleUIAddVerbMenuA(lpOleObjW, lpszShortType, hMenu, uPos, uIDVerbMin,
            uIDVerbMax, bAddConvert, idConvert, lphMenu);

        // release the Unicode IOleObject if it was created
        if (lpOleObjW != NULL)
            lpOleObjW->Release();
        }

    return fResult;
}  // OleUIAddVerbMenu

// ---------------------------------------------------------------------------
// %%Function: OleUIInsertObject                          %%Reviewed: 00/00/95
// 
// Description:
//  Wraps OleUIInsertObject to OLEDLG.DLL for MFC clients, which expect to be
// able to pass Ansi IOleClientSite and IStorage in and receive Ansi interfaces
// out in ppvObj.
// ---------------------------------------------------------------------------
#undef OleUIInsertObject    // overrides the Ansi/Unicode macros in OLEDLG.H
 STDAPI_(UINT)
OleUIInsertObject(LPOLEUIINSERTOBJECTA lpio)
{
    LPOLECLIENTSITE lpIOleClientSiteA = NULL;
    LPSTORAGE       lpIStorageA = NULL;
    LPVOID FAR      *ppvObjA;
    LPUNKNOWN       punkObjW = NULL;
    BOOL            fCreatingObject;
    UINT            wResult;
    HRESULT         hr = S_OK;

    // validate the structure superficially: let the actual function do most of the validation
    if (!lpio)
        return OLEUI_ERR_STRUCTURENULL;
    if (IsBadReadPtr(lpio, sizeof(LPOLEUIINSERTOBJECTA)) ||
        IsBadWritePtr(lpio, sizeof(LPOLEUIINSERTOBJECTA)))
        return OLEUI_ERR_STRUCTUREINVALID;
    if (lpio->cbStruct < sizeof(LPOLEUIINSERTOBJECTA))
        return OLEUI_ERR_CBSTRUCTINCORRECT;

    if (fCreatingObject = (lpio->dwFlags & (IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT | IOF_CREATELINKOBJECT)))
        {
        // verify these parameters, otherwise cleanup becomes complicated
        if (IsBadWritePtr(lpio->ppvObj, sizeof(LPUNKNOWN)))
            return OLEUI_IOERR_PPVOBJINVALID;
        if (lpio->lpIOleClientSite != NULL && IsBadReadPtr(lpio->lpIOleClientSite, sizeof(IOleClientSite)))
            return OLEUI_IOERR_LPIOLECLIENTSITEINVALID;
        if (lpio->lpIStorage != NULL && IsBadReadPtr(lpio->lpIStorage, sizeof(IStorage)))
            return OLEUI_IOERR_LPISTORAGEINVALID;

        // save away the Ansi IOleClientSite, stuff in our Unicode one.
        // if it's NULL, OleUIInsertObjectA() will handle the error appropriately and we'll clean up correctly, below.
        if (lpIOleClientSiteA = lpio->lpIOleClientSite)
            {
            hr = Ole2AnsiWFromA(IID_IOleClientSite, (LPUNKNOWN)lpIOleClientSiteA, (LPUNKNOWN *)&lpio->lpIOleClientSite);
            if (FAILED(hr))
                {
                lpio->lpIOleClientSite = lpIOleClientSiteA;
                lpio->sc = hr;
                return OLEUI_IOERR_SCODEHASERROR;
                }
            }

        // save away the Ansi IStorage, stuff in our Unicode one.
        // if it's NULL, OleUIInsertObjectA() will handle the error appropriately and we'll clean up correctly, below.
        if (lpIStorageA = lpio->lpIStorage)
            {
            hr = Ole2AnsiWFromA(IID_IStorage, (LPUNKNOWN)lpIStorageA, (LPUNKNOWN *)&lpio->lpIStorage);
            if (FAILED(hr))
                {
                // make sure to free the Unicode IOleClientSite which we converted above.
                if (lpio->lpIOleClientSite)
                    {
                    lpio->lpIOleClientSite->Release();
                    lpio->lpIOleClientSite = lpIOleClientSiteA;
                    }
                lpio->lpIStorage = lpIStorageA;
                lpio->sc = hr;
                return OLEUI_IOERR_SCODEHASERROR;
                }
            }

        // save the current Ansi ppvObj, stuff in our Unicode one
        ppvObjA = lpio->ppvObj;
        lpio->ppvObj = (LPVOID FAR *)&punkObjW;
        }

    wResult = OleUIInsertObjectA(lpio);

    // regardless of success or failure of the above call, we have to clean up the wrapping we did
    if (fCreatingObject)
        {
        // return the Ansi versions of the IOleClientSite and IStorage to
        // the structure, and release the Unicode ones
        if (lpio->lpIOleClientSite)
            {
            lpio->lpIOleClientSite->Release();
            lpio->lpIOleClientSite = lpIOleClientSiteA;
            }
        if (lpio->lpIStorage)
            {
            lpio->lpIStorage->Release();
            lpio->lpIStorage = lpIStorageA;
            }

        // return the Ansi object pointer to the structure
        lpio->ppvObj = ppvObjA;

        // convert
        if (punkObjW != NULL)
            {
            HRESULT hr;
            // if we were creating an object and we succeeded, punkObjW must be valid and contain an interface
            // of type iid. if not, there is a problem in OleUIInsertObjectA(), not in this code. we could assert
            // here if this code wanted to, but wouldn't be able to properly circumvent the error anyway.
            if (FAILED(hr = Ole2AnsiAFromW(lpio->iid, (LPUNKNOWN)punkObjW, (LPUNKNOWN *)ppvObjA)))
                {
                lpio->sc = hr;
                }
            punkObjW->Release();
            if (lpio->sc != S_OK)
                return OLEUI_IOERR_SCODEHASERROR;
            }
        }
    
    return wResult;
}  // OleUIInsertObject

// ---------------------------------------------------------------------------
// %%Function: OleUIPasteSpecial                          %%Reviewed: 00/00/95
// 
// Description:
//  Wraps OleUIPasteSpecial to OLEDLG.DLL for MFC clients, which expect to be
// able to pass in and get back Ansi IDataObject's.
// ---------------------------------------------------------------------------
#undef OleUIPasteSpecial    // overrides the Ansi/Unicode macros in OLEDLG.H
 STDAPI_(UINT)
OleUIPasteSpecial(LPOLEUIPASTESPECIALA lpps)
{
    LPDATAOBJECT    lpSrcDataObjA;
    UINT            wResult;

    // validate the structure superficially: let the actual function do most of the validation
    if (!lpps)
        return OLEUI_ERR_STRUCTURENULL;
    if (IsBadReadPtr(lpps, sizeof(LPOLEUIPASTESPECIALA)) ||
        IsBadWritePtr(lpps, sizeof(LPOLEUIPASTESPECIALA)))
        return OLEUI_ERR_STRUCTUREINVALID;
    if (lpps->cbStruct < sizeof(LPOLEUIPASTESPECIALA))
        return OLEUI_ERR_CBSTRUCTINCORRECT;
    if (NULL != lpps->lpSrcDataObj && IsBadReadPtr(lpps->lpSrcDataObj, sizeof(IDataObject)))
        return OLEUI_IOERR_SRCDATAOBJECTINVALID;

    if (!(lpSrcDataObjA = lpps->lpSrcDataObj) ||
        SUCCEEDED(Ole2AnsiWFromA(IID_IDataObject, (LPUNKNOWN)lpSrcDataObjA, (LPUNKNOWN *)&lpps->lpSrcDataObj)))
        {
        wResult = OleUIPasteSpecialA(lpps);

        // if we had an Ansi IDataObject on entry, put it back and release the Unicode wrapper.
        if (lpSrcDataObjA != NULL)
            {
            lpps->lpSrcDataObj->Release();
            lpps->lpSrcDataObj = lpSrcDataObjA;
            }
        // otherwise check to see if OleUIPasteSpecialA() placed a Unicode IDataObject into our structure.
        // if it did, wrap it to make sure an Ansi one gets sent back out.
        else if (lpps->lpSrcDataObj != NULL)
            {
            if (FAILED(Ole2AnsiAFromW(IID_IDataObject, (LPUNKNOWN)lpps->lpSrcDataObj, (LPUNKNOWN *)&lpSrcDataObjA)))
                {
                lpps->lpSrcDataObj->Release();
                lpps->lpSrcDataObj = NULL;
                return OLEUI_PSERR_GETCLIPBOARDFAILED; // well, that's pretty much what happened, after all
                }
            lpps->lpSrcDataObj->Release();
            lpps->lpSrcDataObj = lpSrcDataObjA;
            }
        }

    return wResult;
}  // OleUIPasteSpecial

#endif // !UNICODE
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\wrapstub.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapstub.cpp
//
//  Contents:   ANSI to Unicode wrappers and Unicode stubs
//
//  Classes:    WrappedIOleUILinkContainer
//              WrappedIOleUIObjInfo
//              WrappedIOleUILinkInfo
//
//  Functions:
#ifdef UNICODE
//            OleUIAddVerbMenuA
//            OleUIInsertObjectA
//            OleUIPasteSpecialA
//            OleUIEditLinksA
//            OleUIChangeIconA
//            OleUIConvertA
//            OleUIBusyA
//            OleUIUpdateLinksA
//            OleUIObjectPropertiesA
//            OleUIChangeSourceA
//            OleUIPromptUserA
#else
//            OleUIAddVerbMenuW
//            OleUIInsertObjectW
//            OleUIPasteSpecialW
//            OleUIEditLinksW
//            OleUIChangeIconW
//            OleUIConvertW
//            OleUIBusyW
//            OleUIUpdateLinksW
//            OleUIObjectPropertiesW
//            OleUIChangeSourceW
//            OleUIPromptUserW
#endif
//
//  History:    11-02-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "precomp.h"
#include "common.h"

#ifdef UNICODE
// ANSI to Unicode Wrappers

//+---------------------------------------------------------------------------
//
//  Function:   OleUIAddVerbMenuA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [lpOleObj]      -
//              [lpszShortType] - [in] on heap
//              [hMenu]         -
//              [uPos]          -
//              [uIDVerbMin]    -
//              [uIDVerbMax]    -
//              [bAddConvert]   -
//              [idConvert]     -
//              [lphMenu]       -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) OleUIAddVerbMenuA(LPOLEOBJECT lpOleObj, LPCSTR lpszShortType,
        HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu)
{
    LPWSTR lpwszShortType = NULL;
    if (lpszShortType && !IsBadReadPtr(lpszShortType, 1))
    {
        UINT uSize = ATOWLEN(lpszShortType);
        lpwszShortType = (LPWSTR)OleStdMalloc(sizeof(WCHAR) * uSize);
        if (lpwszShortType)
        {
            ATOW(lpwszShortType, lpszShortType, uSize);
        }
    }

    // NOTE - if OleStdMalloc fails, this routine must still go ahead and
    // succeed as best as it can since there is no way to report failure.

    BOOL fReturn = OleUIAddVerbMenuW(lpOleObj, lpwszShortType, hMenu, uPos,
        uIDVerbMin, uIDVerbMax, bAddConvert, idConvert, lphMenu);

    if (lpwszShortType)
        OleStdFree((LPVOID)lpwszShortType);

    return(fReturn);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIInsertObjectA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              lpszFile        [in, out] on stack
//              dwFlags         [out]
//              clsid           [out]
//              lpIStorage      [out]
//              ppvObj          [out]
//              sc              [out]
//              hMetaPict       [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIInsertObjectA(LPOLEUIINSERTOBJECTA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    if (NULL != psA->lpszFile &&
        (psA->cchFile <= 0 || psA->cchFile > MAX_PATH))
    {
        return(OLEUI_IOERR_CCHFILEINVALID);
    }

    // NULL is NOT valid for lpszFile
    if (psA->lpszFile == NULL)
    {
        return(OLEUI_IOERR_LPSZFILEINVALID);
    }

    if (IsBadWritePtr(psA->lpszFile, psA->cchFile*sizeof(char)))
        return(OLEUI_IOERR_LPSZFILEINVALID);

    OLEUIINSERTOBJECTW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH], szFile[MAX_PATH];

    memcpy(&sW, psA, sizeof(OLEUIINSERTOBJECTW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    if (psA->lpszFile)
    {
        ATOW(szFile, psA->lpszFile, MAX_PATH);
        sW.lpszFile = szFile;
    }

    uRet = OleUIInsertObjectW(&sW);

    if (psA->lpszFile)
    {
        WTOA(psA->lpszFile, sW.lpszFile, psA->cchFile);
    }
    memcpy(&psA->clsid, &sW.clsid, sizeof(CLSID));
    psA->dwFlags = sW.dwFlags;
    psA->lpIStorage = sW.lpIStorage;
    psA->ppvObj = sW.ppvObj;
    psA->sc = sW.sc;
    psA->hMetaPict = sW.hMetaPict;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIPasteSpecialA
//
//  Synopsis:   convers call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              arrPasteEntries [in] on heap
//              arrPasteEntries[n].lpstrFormatName [in] on heap
//              dwFlags         [out]
//              nSelectedIndex  [out]
//              fLink           [out]
//              hMetaPict       [out]
//              sizel           [out]
//
//----------------------------------------------------------------------------


STDAPI_(UINT) OleUIPasteSpecialA(LPOLEUIPASTESPECIALA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    // Validate PasteSpecial specific fields
    if (NULL == psA->arrPasteEntries || IsBadReadPtr(psA->arrPasteEntries, psA->cPasteEntries * sizeof(OLEUIPASTEENTRYA)))
        return(OLEUI_IOERR_ARRPASTEENTRIESINVALID);

    OLEUIPASTESPECIALW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;
    UINT uIndex;

    memcpy(&sW, psA, sizeof(OLEUIPASTESPECIALW));

    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    if (psA->cPasteEntries)
    {
        sW.arrPasteEntries = new OLEUIPASTEENTRYW[psA->cPasteEntries];
        if (NULL == sW.arrPasteEntries)
        {
            return(uRet);
        }
        for (uIndex = psA->cPasteEntries; uIndex--;)
        {
            sW.arrPasteEntries[uIndex].lpstrFormatName = NULL;
            sW.arrPasteEntries[uIndex].lpstrResultText = NULL;
        }
        for (uIndex = psA->cPasteEntries; uIndex--;)
        {
            sW.arrPasteEntries[uIndex].fmtetc = psA->arrPasteEntries[uIndex].fmtetc;
            sW.arrPasteEntries[uIndex].dwFlags = psA->arrPasteEntries[uIndex].dwFlags;
            sW.arrPasteEntries[uIndex].dwScratchSpace = psA->arrPasteEntries[uIndex].dwScratchSpace;
            if (psA->arrPasteEntries[uIndex].lpstrFormatName)
            {
                UINT uLength = ATOWLEN(psA->arrPasteEntries[uIndex].lpstrFormatName);
                sW.arrPasteEntries[uIndex].lpstrFormatName = new WCHAR[uLength];
                if (NULL == sW.arrPasteEntries[uIndex].lpstrFormatName)
                {
                    goto oom_error;
                }
                ATOW((WCHAR *)sW.arrPasteEntries[uIndex].lpstrFormatName,
                    psA->arrPasteEntries[uIndex].lpstrFormatName,
                    uLength);
            }
            if (psA->arrPasteEntries[uIndex].lpstrResultText)
            {
                UINT uLength = ATOWLEN(psA->arrPasteEntries[uIndex].lpstrResultText);
                sW.arrPasteEntries[uIndex].lpstrResultText = new WCHAR[uLength];
                if (NULL == sW.arrPasteEntries[uIndex].lpstrResultText)
                {
                    goto oom_error;
                }
                ATOW((WCHAR *)sW.arrPasteEntries[uIndex].lpstrResultText,
                    psA->arrPasteEntries[uIndex].lpstrResultText,
                    uLength);
            }
        }
    }

    uRet = OleUIPasteSpecialW(&sW);
    psA->lpSrcDataObj = sW.lpSrcDataObj;
    psA->dwFlags = sW.dwFlags;
    psA->nSelectedIndex = sW.nSelectedIndex;
    psA->fLink = sW.fLink;
    psA->hMetaPict = sW.hMetaPict;
    psA->sizel = sW.sizel;

oom_error:
    for (uIndex = psA->cPasteEntries; uIndex--;)
    {
        if (sW.arrPasteEntries[uIndex].lpstrFormatName)
        {
            delete[] (WCHAR*)sW.arrPasteEntries[uIndex].lpstrFormatName;
        }
        if (sW.arrPasteEntries[uIndex].lpstrResultText)
        {
            delete[] (WCHAR *)sW.arrPasteEntries[uIndex].lpstrResultText;
        }
    }
    delete[] sW.arrPasteEntries;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Class:      WrappedIOleUILinkContainer
//
//  Purpose:    Wraps IOleUILinkContainerA with IOleUILinkContainerW methods
//              so it can be passed on to Unicode methods within OLE2UI32.
//
//  Interface:  QueryInterface              --
//              AddRef                      --
//              Release                     --
//              GetNextLink                 --
//              SetLinkUpdateOptions        --
//              GetLinkUpdateOptions        --
//              SetLinkSource               -- requires string conversion
//              GetLinkSource               -- requires string conversion
//              OpenLinkSource              --
//              UpdateLink                  --
//              CancelLink                  --
//              WrappedIOleUILinkContainer  -- constructor
//              ~WrappedIOleUILinkContainer -- destructor
//
//  History:    11-04-94   stevebl   Created
//
//  Notes:      This is a private interface wrapper.  QueryInterface is not
//              supported and the wrapped interface may not be used outside
//              of the OLE2UI32 code.
//
//----------------------------------------------------------------------------

class WrappedIOleUILinkContainer: public IOleUILinkContainerW
{
public:
    // *** IUnknown methods *** //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IOleUILinkContainer *** //
    STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink);
    STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD dwUpdateOpt);
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt);
    STDMETHOD(SetLinkSource) (THIS_ DWORD dwLink, LPWSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource);
    STDMETHOD(GetLinkSource) (THIS_ DWORD dwLink,
            LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected);
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink);
    STDMETHOD(UpdateLink) (THIS_ DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction);
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink);

    // *** Constructor and Destructor *** //
    WrappedIOleUILinkContainer(IOleUILinkContainerA *pilc);
    ~WrappedIOleUILinkContainer();
private:
    IOleUILinkContainerA * m_pilc;
    ULONG m_uRefCount;
};

// *** IUnknown methods *** //
HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    return(E_NOTIMPL);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkContainer::AddRef()
{
    return(m_uRefCount++);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkContainer::Release()
{
    ULONG uRet = --m_uRefCount;
    if (0 == uRet)
    {
        delete(this);
    }
    return(uRet);
}

// *** IOleUILinkContainer *** //
DWORD STDMETHODCALLTYPE WrappedIOleUILinkContainer::GetNextLink(DWORD dwLink)
{
    return(m_pilc->GetNextLink(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::SetLinkUpdateOptions (DWORD dwLink,
        DWORD dwUpdateOpt)
{
    return(m_pilc->SetLinkUpdateOptions(dwLink, dwUpdateOpt));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::GetLinkUpdateOptions (DWORD dwLink,
        DWORD FAR* lpdwUpdateOpt)
{
    return(m_pilc->GetLinkUpdateOptions(dwLink, lpdwUpdateOpt));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkContainer::SetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]          -
//              [lpszDisplayName] - [in] converted on stack
//              [lenFileName]     -
//              [pchEaten]        -
//              [fValidateSource] -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::SetLinkSource (DWORD dwLink, LPWSTR lpszDisplayName,
        ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource)
{
    char szDisplayName[MAX_PATH];
    char * lpszDisplayNameA;
    if (lpszDisplayName)
    {
        WTOA(szDisplayName, lpszDisplayName, MAX_PATH);
        lpszDisplayNameA = szDisplayName;
    }
    else
        lpszDisplayNameA = NULL;

    return(m_pilc->SetLinkSource(dwLink, lpszDisplayNameA, lenFileName, pchEaten, fValidateSource));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkContainer::GetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]              -
//              [lplpszDisplayName]   - [out] converted on heap
//              [lplenFileName]       -
//              [lplpszFullLinkType]  - [out] converted on heap
//              [lplpszShortLinkType] - [out] converted on heap
//              [lpfSourceAvailable]  -
//              [lpfIsSelected]       -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::GetLinkSource (DWORD dwLink,
        LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
        LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
        BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected)
{
    LPSTR lpszDisplayName = NULL;
    LPSTR lpszFullLinkType = NULL;
    LPSTR lpszShortLinkType = NULL;
    LPSTR * lplpszDisplayNameA = NULL;
    LPSTR * lplpszFullLinkTypeA = NULL;
    LPSTR * lplpszShortLinkTypeA = NULL;
    if (lplpszDisplayName)
    {
        lplpszDisplayNameA = &lpszDisplayName;
    }
    if (lplpszFullLinkType)
    {
        lplpszFullLinkTypeA = &lpszFullLinkType;
    }
    if (lplpszShortLinkType)
    {
        lplpszShortLinkTypeA = &lpszShortLinkType;
    }
    HRESULT hrReturn = m_pilc->GetLinkSource(dwLink,
        lplpszDisplayNameA,
        lplenFileName,
        lplpszFullLinkTypeA,
        lplpszShortLinkTypeA,
        lpfSourceAvailable,
        lpfIsSelected);
    if (lplpszDisplayName)
    {
        *lplpszDisplayName = NULL;
        if (lpszDisplayName)
        {
            UINT uLen = ATOWLEN(lpszDisplayName);
            *lplpszDisplayName = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszDisplayName)
            {
                ATOW(*lplpszDisplayName, lpszDisplayName, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszDisplayName);
        }
    }
    if (lplpszFullLinkType)
    {
        *lplpszFullLinkType = NULL;
        if (lpszFullLinkType)
        {
            UINT uLen = ATOWLEN(lpszFullLinkType);
            *lplpszFullLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszFullLinkType)
            {
                ATOW(*lplpszFullLinkType, lpszFullLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszFullLinkType);
        }
    }
    if (lplpszShortLinkType)
    {
        *lplpszShortLinkType = NULL;
        if (lpszShortLinkType)
        {
            UINT uLen = ATOWLEN(lpszShortLinkType);
            *lplpszShortLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszShortLinkType)
            {
                ATOW(*lplpszShortLinkType, lpszShortLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszShortLinkType);
        }
    }
    return(hrReturn);
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::OpenLinkSource (DWORD dwLink)
{
    return(m_pilc->OpenLinkSource(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::UpdateLink (DWORD dwLink,
        BOOL fErrorMessage, BOOL fErrorAction)
{
    return(m_pilc->UpdateLink(dwLink, fErrorMessage, fErrorAction));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::CancelLink (DWORD dwLink)
{
    return(m_pilc->CancelLink(dwLink));
}

WrappedIOleUILinkContainer::WrappedIOleUILinkContainer(IOleUILinkContainerA *pilc)
{
    m_pilc = pilc;
    m_pilc->AddRef();
    m_uRefCount=1;
}

WrappedIOleUILinkContainer::~WrappedIOleUILinkContainer()
{
    m_pilc->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIEditLinksA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Notes:      Uses the WrappedIOleUILinkContainer interface wrapper.
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              dwFlags         [out]
//              lpOleUILinkContainer [in] wrapped interface
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIEditLinksA(LPOLEUIEDITLINKSA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    uRet = OLEUI_SUCCESS;

    // Validate interface.
    if (NULL == psA->lpOleUILinkContainer)
    {
        uRet = OLEUI_ELERR_LINKCNTRNULL;
    }
    else if(IsBadReadPtr(psA->lpOleUILinkContainer, sizeof(IOleUILinkContainerA)))
    {
        uRet = OLEUI_ELERR_LINKCNTRINVALID;
    }

    if (OLEUI_SUCCESS != uRet)
    {
        return(uRet);
    }


    OLEUIEDITLINKSW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;

    memcpy(&sW, psA, sizeof(OLEUIEDITLINKSW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }

    sW.lpOleUILinkContainer = new WrappedIOleUILinkContainer(psA->lpOleUILinkContainer);
    if (NULL == sW.lpOleUILinkContainer)
    {
        return(uRet);
    }

    uRet = OleUIEditLinksW(&sW);

    psA->dwFlags = sW.dwFlags;
    sW.lpOleUILinkContainer->Release();
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIChangeIconA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              szIconExe       [in] array embedded in structure
//              dwFlags         [out]
//              hMetaPict       [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIChangeIconA(LPOLEUICHANGEICONA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    OLEUICHANGEICONW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];

    memcpy(&sW, psA, sizeof(OLEUICHANGEICONA));

    sW.cbStruct = sizeof(OLEUICHANGEICONW);

    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    ATOW(sW.szIconExe, psA->szIconExe, MAX_PATH);
    sW.cchIconExe = psA->cchIconExe;


    uRet = OleUIChangeIconW(&sW);

    psA->dwFlags = sW.dwFlags;
    psA->hMetaPict = sW.hMetaPict;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIConvertA
//
//  Synopsis:   converts a call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              lpszUserType    [in] on heap
//                              [out] always freed and returned as NULL
//              lpszDefLabel    [in] on heap
//              lpszDefLabel    [out] always freed and returned as NULL
//              dwFlags         [out]
//              clsidNew        [out]
//              dvAspect        [out]
//              hMetaPict       [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIConvertA(LPOLEUICONVERTA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    if ((NULL != psA->lpszUserType)
        && (IsBadReadPtr(psA->lpszUserType, 1)))
        return(OLEUI_CTERR_STRINGINVALID);

    if ( (NULL != psA->lpszDefLabel)
        && (IsBadReadPtr(psA->lpszDefLabel, 1)) )
        return(OLEUI_CTERR_STRINGINVALID);

    OLEUICONVERTW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;

    memcpy(&sW, psA, sizeof(OLEUICONVERTW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    sW.lpszUserType = sW.lpszDefLabel = NULL;
    if (psA->lpszUserType)
    {
        UINT uLen = ATOWLEN(psA->lpszUserType);
        sW.lpszUserType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
        if (!sW.lpszUserType)
        {
            goto oom_error;
        }
        ATOW(sW.lpszUserType, psA->lpszUserType, uLen);
    }
    if (psA->lpszDefLabel)
    {
        UINT uLen = ATOWLEN(psA->lpszDefLabel);
        sW.lpszDefLabel = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
        if (!sW.lpszDefLabel)
        {
            goto oom_error;
        }
        ATOW(sW.lpszDefLabel, psA->lpszDefLabel, uLen);
    }

    uRet = OleUIConvertW(&sW);

    psA->dwFlags = sW.dwFlags;
    memcpy(&psA->clsidNew, &sW.clsidNew, sizeof(CLSID));
    psA->dvAspect = sW.dvAspect;
    psA->hMetaPict = sW.hMetaPict;
    psA->fObjectsIconChanged = sW.fObjectsIconChanged;
oom_error:
    if (sW.lpszUserType)
    {
        OleStdFree((LPVOID)sW.lpszUserType);
    }
    if (sW.lpszDefLabel)
    {
        OleStdFree((LPVOID)sW.lpszDefLabel);
    }
    if (psA->lpszUserType)
    {
        OleStdFree((LPVOID)psA->lpszUserType);
        psA->lpszUserType = NULL;
    }
    if (psA->lpszDefLabel)
    {
        OleStdFree((LPVOID)psA->lpszDefLabel);
        psA->lpszDefLabel = NULL;
    }
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIBusyA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              dwFlags         [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIBusyA(LPOLEUIBUSYA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    OLEUIBUSYW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];

    memcpy(&sW, psA, sizeof(OLEUIBUSYW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    uRet = OleUIBusyW(&sW);

    psA->dwFlags = sW.dwFlags;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIUpdateLinksA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [lpOleUILinkCntr] - [in] wrapped with Unicode version
//              [hwndParent]      -
//              [lpszTitle]       - [in] on stack
//              [cLinks]          -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) OleUIUpdateLinksA(LPOLEUILINKCONTAINERA lpOleUILinkCntr,
        HWND hwndParent, LPSTR lpszTitle, int cLinks)
{
    WrappedIOleUILinkContainer * lpWrappedOleUILinkCntr = NULL;

    if (NULL != lpszTitle && IsBadReadPtr(lpszTitle, 1))
        return(FALSE);

    if (NULL == lpOleUILinkCntr || IsBadReadPtr(lpOleUILinkCntr, sizeof(IOleUILinkContainerA)))
        return(FALSE);

    lpWrappedOleUILinkCntr = new WrappedIOleUILinkContainer(lpOleUILinkCntr);
    if (NULL == lpWrappedOleUILinkCntr)
        return(FALSE); // ran out of memory

    WCHAR wszTitle[MAX_PATH];
    WCHAR *lpwszTitle;
    if (lpszTitle)
    {
        ATOW(wszTitle, lpszTitle, MAX_PATH);
        lpwszTitle = wszTitle;
    }
    else
        lpwszTitle = NULL;
    BOOL fReturn = OleUIUpdateLinksW(lpWrappedOleUILinkCntr, hwndParent, lpwszTitle, cLinks);

    lpWrappedOleUILinkCntr->Release();

    return(fReturn);
}

//+---------------------------------------------------------------------------
//
//  Class:      WrappedIOleUIObjInfo
//
//  Purpose:    Wraps IOleUIObjInfoA with IOleUIObjInfoW methods
//              so it can be passed on to Unicode methods within OLE2UI32.
//
//  Interface:  QueryInterface        --
//              AddRef                --
//              Release               --
//              GetObjectInfo         -- requires string conversion
//              GetConvertInfo        --
//              ConvertObject         --
//              GetViewInfo           --
//              SetViewInfo           --
//              WrappedIOleUIObjInfo  -- constructor
//              ~WrappedIOleUIObjInfo -- destructor
//
//  History:    11-08-94   stevebl   Created
//
//  Notes:      This is a private interface wrapper.  QueryInterface is not
//              supported and the wrapped interface may not be used outside
//              of the OLE2UI32 code.
//
//----------------------------------------------------------------------------

class WrappedIOleUIObjInfo: public IOleUIObjInfoW
{
public:
    // *** IUnknown methods *** //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** extra for General Properties *** //
    STDMETHOD(GetObjectInfo) (THIS_ DWORD dwObject,
            DWORD FAR* lpdwObjSize, LPWSTR FAR* lplpszLabel,
            LPWSTR FAR* lplpszType, LPWSTR FAR* lplpszShortType,
            LPWSTR FAR* lplpszLocation);
    STDMETHOD(GetConvertInfo) (THIS_ DWORD dwObject,
            CLSID FAR* lpClassID, WORD FAR* lpwFormat,
            CLSID FAR* lpConvertDefaultClassID,
            LPCLSID FAR* lplpClsidExclude, UINT FAR* lpcClsidExclude);
    STDMETHOD(ConvertObject) (THIS_ DWORD dwObject, REFCLSID clsidNew);

    // *** extra for View Properties *** //
    STDMETHOD(GetViewInfo) (THIS_ DWORD dwObject,
            HGLOBAL FAR* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale);
    STDMETHOD(SetViewInfo) (THIS_ DWORD dwObject,
            HGLOBAL hMetaPict, DWORD dvAspect,
            int nCurrentScale, BOOL bRelativeToOrig);
    // *** Constructor and Destructor *** //
    WrappedIOleUIObjInfo(IOleUIObjInfoA * pioi);
    ~WrappedIOleUIObjInfo();
private:
    IOleUIObjInfoA * m_pioi;
    ULONG m_uRefCount;
};

// *** IUnknown methods *** //
HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    return(E_NOTIMPL);
}

ULONG STDMETHODCALLTYPE WrappedIOleUIObjInfo::AddRef()
{
    return(m_uRefCount++);
}

ULONG STDMETHODCALLTYPE WrappedIOleUIObjInfo::Release()
{
    ULONG uRet = --m_uRefCount;
    if (0 == uRet)
    {
        delete(this);
    }
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUIObjInfo::GetObjectInfo
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwObject]        -
//              [lpdwObjSize]     -
//              [lplpszLabel]     - [out] converted on heap
//              [lplpszType]      - [out] converted on heap
//              [lplpszShortType] - [out] converted on heap
//              [lplpszLocation]  - [out] converted on heap
//
//  History:    11-09-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::GetObjectInfo(DWORD dwObject,
        DWORD FAR* lpdwObjSize, LPWSTR FAR* lplpszLabel,
        LPWSTR FAR* lplpszType, LPWSTR FAR* lplpszShortType,
        LPWSTR FAR* lplpszLocation)
{
    LPSTR lpszLabel = NULL;
    LPSTR lpszType = NULL;
    LPSTR lpszShortType = NULL;
    LPSTR lpszLocation = NULL;
    LPSTR * lplpszLabelA = NULL;
    LPSTR * lplpszTypeA = NULL;
    LPSTR * lplpszShortTypeA = NULL;
    LPSTR * lplpszLocationA = NULL;
    if (lplpszLabel)
    {
        lplpszLabelA = &lpszLabel;
    }
    if (lplpszType)
    {
        lplpszTypeA = &lpszType;
    }
    if (lplpszShortType)
    {
        lplpszShortTypeA = &lpszShortType;
    }
    if (lplpszLocation)
    {
        lplpszLocationA = &lpszLocation;
    }
    HRESULT hrReturn = m_pioi->GetObjectInfo(dwObject,
        lpdwObjSize,
        lplpszLabelA,
        lplpszTypeA,
        lplpszShortTypeA,
        lplpszLocationA);
    if (lplpszLabel)
    {
        *lplpszLabel = NULL;
        if (lpszLabel)
        {
            UINT uLen = ATOWLEN(lpszLabel);
            *lplpszLabel = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszLabel)
            {
                ATOW(*lplpszLabel, lpszLabel, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszLabel);
        }
    }
    if (lplpszType)
    {
        *lplpszType = NULL;
        if (lpszType)
        {
            UINT uLen = ATOWLEN(lpszType);
            *lplpszType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszType)
            {
                ATOW(*lplpszType, lpszType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszType);
        }
    }
    if (lplpszShortType)
    {
        *lplpszShortType = NULL;
        if (lpszShortType)
        {
            UINT uLen = ATOWLEN(lpszShortType);
            *lplpszShortType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszShortType)
            {
                ATOW(*lplpszShortType, lpszShortType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszShortType);
        }
    }
    if (lplpszLocation)
    {
        *lplpszLocation = NULL;
        if (lpszLocation)
        {
            UINT uLen = ATOWLEN(lpszLocation);
            *lplpszLocation = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszLocation)
            {
                ATOW(*lplpszLocation, lpszLocation, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszLocation);
        }
    }
    return(hrReturn);
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::GetConvertInfo(DWORD dwObject,
        CLSID FAR* lpClassID, WORD FAR* lpwFormat,
        CLSID FAR* lpConvertDefaultClassID,
        LPCLSID FAR* lplpClsidExclude, UINT FAR* lpcClsidExclude)
{
    return(m_pioi->GetConvertInfo(dwObject,
        lpClassID,
        lpwFormat,
        lpConvertDefaultClassID,
        lplpClsidExclude,
        lpcClsidExclude));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::ConvertObject(DWORD dwObject, REFCLSID clsidNew)
{
    return(m_pioi->ConvertObject(dwObject, clsidNew));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::GetViewInfo(DWORD dwObject,
        HGLOBAL FAR* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale)
{
    return(m_pioi->GetViewInfo(dwObject, phMetaPict, pdvAspect, pnCurrentScale));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::SetViewInfo(DWORD dwObject,
        HGLOBAL hMetaPict, DWORD dvAspect,
        int nCurrentScale, BOOL bRelativeToOrig)
{
    return(m_pioi->SetViewInfo(dwObject, hMetaPict, dvAspect, nCurrentScale, bRelativeToOrig));
}

WrappedIOleUIObjInfo::WrappedIOleUIObjInfo(IOleUIObjInfoA *pioi)
{
    m_pioi = pioi;
    m_pioi->AddRef();
    m_uRefCount=1;
}

WrappedIOleUIObjInfo::~WrappedIOleUIObjInfo()
{
    m_pioi->Release();
}


//+---------------------------------------------------------------------------
//
//  Class:      WrappedIOleUILinkInfo
//
//  Purpose:    Wraps IOleUILinkInfoA with IOleUILinkInfoW methods
//              so it can be passed on to Unicode methods within OLE2UI32.
//
//  Interface:  QueryInterface         --
//              AddRef                 --
//              Release                --
//              GetNextLink            --
//              SetLinkUpdateOptions   --
//              GetLinkUpdateOptions   --
//              SetLinkSource          -- requires string conversion
//              GetLinkSource          -- requires string conversion
//              OpenLinkSource         --
//              UpdateLink             --
//              CancelLink             --
//              GetLastUpdate          --
//              WrappedIOleUILinkInfo  -- constructor
//              ~WrappedIOleUILinkInfo -- destructor
//
//  History:    11-08-94   stevebl   Created
//
//  Notes:      This is a private interface wrapper.  QueryInterface is not
//              supported and the wrapped interface may not be used outside
//              of the OLE2UI32 code.
//
//----------------------------------------------------------------------------

class WrappedIOleUILinkInfo: public IOleUILinkInfoW
{
public:
    // *** IUnknown methods *** //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IOleUILinkContainer *** //
    STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink);
    STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD dwUpdateOpt);
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt);
    STDMETHOD(SetLinkSource) (THIS_ DWORD dwLink, LPWSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource);
    STDMETHOD(GetLinkSource) (THIS_ DWORD dwLink,
            LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected);
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink);
    STDMETHOD(UpdateLink) (THIS_ DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction);
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink);

    // *** extra for Link Properties ***//
    STDMETHOD(GetLastUpdate) (THIS_ DWORD dwLink,
            FILETIME FAR* lpLastUpdate);

    // *** Constructor and Destructor *** //
    WrappedIOleUILinkInfo(IOleUILinkInfoA *pili);
    ~WrappedIOleUILinkInfo();
private:
    IOleUILinkInfoA * m_pili;
    ULONG m_uRefCount;
};

// *** IUnknown methods *** //
HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    return(E_NOTIMPL);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkInfo::AddRef()
{
    return(m_uRefCount++);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkInfo::Release()
{
    ULONG uRet = --m_uRefCount;
    if (0 == uRet)
    {
        delete(this);
    }
    return(uRet);
}

// *** IOleUILinkInfo *** //
DWORD STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetNextLink(DWORD dwLink)
{
    return(m_pili->GetNextLink(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::SetLinkUpdateOptions (DWORD dwLink,
        DWORD dwUpdateOpt)
{
    return(m_pili->SetLinkUpdateOptions(dwLink, dwUpdateOpt));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetLinkUpdateOptions (DWORD dwLink,
        DWORD FAR* lpdwUpdateOpt)
{
    return(m_pili->GetLinkUpdateOptions(dwLink, lpdwUpdateOpt));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkInfo::SetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]          -
//              [lpszDisplayName] - [in] converted on stack
//              [lenFileName]     -
//              [pchEaten]        -
//              [fValidateSource] -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::SetLinkSource (DWORD dwLink, LPWSTR lpszDisplayName,
        ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource)
{
    char szDisplayName[MAX_PATH];
    char * lpszDisplayNameA;
    if (lpszDisplayName)
    {
        WTOA(szDisplayName, lpszDisplayName, MAX_PATH);
        lpszDisplayNameA = szDisplayName;
    }
    else
        lpszDisplayNameA = NULL;

    return(m_pili->SetLinkSource(dwLink, lpszDisplayNameA, lenFileName, pchEaten, fValidateSource));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkInfo::GetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]              -
//              [lplpszDisplayName]   - [out] converted on heap
//              [lplenFileName]       -
//              [lplpszFullLinkType]  - [out] converted on heap
//              [lplpszShortLinkType] - [out] converted on heap
//              [lpfSourceAvailable]  -
//              [lpfIsSelected]       -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetLinkSource (DWORD dwLink,
        LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
        LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
        BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected)
{
    LPSTR lpszDisplayName = NULL;
    LPSTR lpszFullLinkType = NULL;
    LPSTR lpszShortLinkType = NULL;
    LPSTR * lplpszDisplayNameA = NULL;
    LPSTR * lplpszFullLinkTypeA = NULL;
    LPSTR * lplpszShortLinkTypeA = NULL;
    if (lplpszDisplayName)
    {
        lplpszDisplayNameA = &lpszDisplayName;
    }
    if (lplpszFullLinkType)
    {
        lplpszFullLinkTypeA = &lpszFullLinkType;
    }
    if (lplpszShortLinkType)
    {
        lplpszShortLinkTypeA = &lpszShortLinkType;
    }
    HRESULT hrReturn = m_pili->GetLinkSource(dwLink,
        lplpszDisplayNameA,
        lplenFileName,
        lplpszFullLinkTypeA,
        lplpszShortLinkTypeA,
        lpfSourceAvailable,
        lpfIsSelected);
    if (lplpszDisplayName)
    {
        *lplpszDisplayName = NULL;
        if (lpszDisplayName)
        {
            UINT uLen = ATOWLEN(lpszDisplayName);
            *lplpszDisplayName = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszDisplayName)
            {
                ATOW(*lplpszDisplayName, lpszDisplayName, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszDisplayName);
        }
    }
    if (lplpszFullLinkType)
    {
        *lplpszFullLinkType = NULL;
        if (lpszFullLinkType)
        {
            UINT uLen = ATOWLEN(lpszFullLinkType);
            *lplpszFullLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszFullLinkType)
            {
                ATOW(*lplpszFullLinkType, lpszFullLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszFullLinkType);
        }
    }
    if (lplpszShortLinkType)
    {
        *lplpszShortLinkType = NULL;
        if (lpszShortLinkType)
        {
            UINT uLen = ATOWLEN(lpszShortLinkType);
            *lplpszShortLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszShortLinkType)
            {
                ATOW(*lplpszShortLinkType, lpszShortLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszShortLinkType);
        }
    }
    return(hrReturn);
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::OpenLinkSource (DWORD dwLink)
{
    return(m_pili->OpenLinkSource(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::UpdateLink (DWORD dwLink,
        BOOL fErrorMessage, BOOL fErrorAction)
{
    return(m_pili->UpdateLink(dwLink, fErrorMessage, fErrorAction));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::CancelLink (DWORD dwLink)
{
    return(m_pili->CancelLink(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetLastUpdate (DWORD dwLink,
            FILETIME FAR* lpLastUpdate)
{
    return(m_pili->GetLastUpdate(dwLink, lpLastUpdate));
}

WrappedIOleUILinkInfo::WrappedIOleUILinkInfo(IOleUILinkInfoA *pili)
{
    m_pili = pili;
    m_pili->AddRef();
    m_uRefCount=1;
}

WrappedIOleUILinkInfo::~WrappedIOleUILinkInfo()
{
    m_pili->Release();
}


//+---------------------------------------------------------------------------
//
//  Function:   OleUIObjectPropertiesA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpPS            [in]
//              lpObjInfo       [in] wrapped with Unicode interface
//              lpLinkInfo      [in] wrapped with Unicode interface
//              lpGP            [in] (no data conversion, only type conversion)
//              lpVP            [in] (no data conversion, only type conversion)
//              lpLP            [in] (no data conversion, only type conversion)
//
//              dwFlags         [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIObjectPropertiesA(LPOLEUIOBJECTPROPSA psA)
{
    if (NULL == psA)
    {
        return(OLEUI_ERR_STRUCTURENULL);
    }

    if (IsBadWritePtr(psA, sizeof(OLEUIOBJECTPROPSA)))
        return OLEUI_ERR_STRUCTUREINVALID;

    LPOLEUIOBJECTPROPSW psW;
    UINT uRet = OLEUI_ERR_LOCALMEMALLOC;

    if (NULL == psA->lpObjInfo)
    {
        return(OLEUI_OPERR_OBJINFOINVALID);
    }

    if (IsBadReadPtr(psA->lpObjInfo, sizeof(IOleUIObjInfoA)))
    {
        return(OLEUI_OPERR_OBJINFOINVALID);
    }

    if (psA->dwFlags & OPF_OBJECTISLINK)
    {
        if (NULL == psA->lpLinkInfo)
        {
            return(OLEUI_OPERR_LINKINFOINVALID);
        }

        if (IsBadReadPtr(psA->lpLinkInfo, sizeof(IOleUILinkInfoA)))
        {
            return(OLEUI_OPERR_LINKINFOINVALID);
        }
    }

    BOOL fWrappedIOleUILinkInfo = FALSE;
    psW = (LPOLEUIOBJECTPROPSW) OleStdMalloc(sizeof(OLEUIOBJECTPROPSW));
    if (NULL != psW)
    {
        memcpy(psW, psA, sizeof(OLEUIOBJECTPROPSW));
        psW->lpObjInfo = new WrappedIOleUIObjInfo(psA->lpObjInfo);
        if (NULL == psW->lpObjInfo)
        {
            OleStdFree(psW);
            return(uRet);
        }
        if (psW->dwFlags & OPF_OBJECTISLINK)
        {
            psW->lpLinkInfo = new WrappedIOleUILinkInfo(psA->lpLinkInfo);
            if (NULL == psW->lpLinkInfo)
            {
                psW->lpObjInfo->Release();
                OleStdFree(psW);
                return(uRet);
            }
            fWrappedIOleUILinkInfo = TRUE;
        }
        uRet = InternalObjectProperties(psW, FALSE);
        psA->dwFlags = psW->dwFlags;
        psW->lpObjInfo->Release();
        if (fWrappedIOleUILinkInfo)
        {
            psW->lpLinkInfo->Release();
        }
        OleStdFree(psW);
    }
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIChangeSourceA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              lpszDisplayName [in, out] on heap
//              lpszFrom        [out] on heap
//              lpszTo          [out] on heap
//              lpOleUILinkContainer  [in] wrapped interface
//              dwFlags         [out]
//              nFileLength     [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIChangeSourceA(LPOLEUICHANGESOURCEA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    // lpszFrom and lpszTo must be NULL (they are out only)
    if (psA->lpszFrom != NULL)
    {
        return(OLEUI_CSERR_FROMNOTNULL);
    }
    if (psA->lpszTo != NULL)
    {
        return(OLEUI_CSERR_TONOTNULL);
    }

    // lpszDisplayName must be valid or NULL
    if (psA->lpszDisplayName != NULL &&
        IsBadReadPtr(psA->lpszDisplayName, 1))
    {
        return(OLEUI_CSERR_SOURCEINVALID);
    }

    OLEUICHANGESOURCEW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;

    memcpy(&sW, psA, sizeof(OLEUICHANGESOURCEW));
    if (psA->lpszCaption != NULL)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    if (psA->lpszDisplayName)
    {
        UINT uLen = ATOWLEN(psA->lpszDisplayName);
        sW.lpszDisplayName = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
        if (!sW.lpszDisplayName)
        {
            return(uRet);
        }
        ATOW(sW.lpszDisplayName, psA->lpszDisplayName, uLen);
    }
    if (NULL != psA->lpOleUILinkContainer)
    {
        if (IsBadReadPtr(psA->lpOleUILinkContainer, sizeof(IOleUILinkContainerA)))
        {
            return(OLEUI_CSERR_LINKCNTRINVALID);
        }
        sW.lpOleUILinkContainer = new WrappedIOleUILinkContainer(psA->lpOleUILinkContainer);
        if (NULL == sW.lpOleUILinkContainer)
        {
            return(uRet);
        }
    }

    uRet = OleUIChangeSourceW(&sW);
    if (psA->lpszDisplayName)
    {
        OleStdFree((LPVOID)psA->lpszDisplayName);
        psA->lpszDisplayName = NULL;
    }
    if (sW.lpszDisplayName)
    {
        UINT uLen = WTOALEN(sW.lpszDisplayName);
        psA->lpszDisplayName = (LPSTR)OleStdMalloc(uLen * sizeof(char));
        if (!psA->lpszDisplayName)
        {
            uRet = OLEUI_ERR_LOCALMEMALLOC;
        }
        else
        {
            WTOA(psA->lpszDisplayName, sW.lpszDisplayName, uLen);
        }
        OleStdFree((LPVOID)sW.lpszDisplayName);
    }
    if (sW.lpszFrom)
    {
        UINT uLen = WTOALEN(sW.lpszFrom);
        psA->lpszFrom = (LPSTR)OleStdMalloc(uLen * sizeof(char));
        if (!psA->lpszFrom)
        {
            uRet = OLEUI_ERR_LOCALMEMALLOC;
        }
        else
        {
            WTOA(psA->lpszFrom, sW.lpszFrom, uLen);
        }
        OleStdFree((LPVOID)sW.lpszFrom);
    }
    if (sW.lpszTo)
    {
        UINT uLen = WTOALEN(sW.lpszTo);
        psA->lpszTo = (LPSTR)OleStdMalloc(uLen * sizeof(char));
        if (!psA->lpszTo)
        {
            uRet = OLEUI_ERR_LOCALMEMALLOC;
        }
        else
        {
            WTOA(psA->lpszTo, sW.lpszTo, uLen);
        }
        OleStdFree((LPVOID)sW.lpszTo);
    }
    psA->dwFlags = sW.dwFlags;
    psA->nFileLength = sW.nFileLength;
    if (NULL != sW.lpOleUILinkContainer)
    {
        sW.lpOleUILinkContainer->Release();
    }
    return(uRet);
}

int OleUIPromptUserInternal(int nTemplate, HWND hwndParent, LPTSTR szTitle, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   OleUIPromptUserA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [nTemplate]  - template ID
//              [hwndParent] - parent's HWND
//              [lpszTitle]  - title of the window
//              [...]        - variable argument list
//
//  History:    11-30-94   stevebl   Created
//
//  Notes:      The first parameter passed in by this function is always the
//              title for the dialog.  It must be converted to Unicode before
//              forwarding the call.  The other parameters do not need to
//              be converted because the template ID will indicate the dialog
//              that contains the correct wsprintf formatting string for
//              converting the other ANSI parameters to Unicode when the
//              function calls wsprintf to build it's text.
//
//----------------------------------------------------------------------------

int FAR CDECL OleUIPromptUserA(int nTemplate, HWND hwndParent, ...)
{
    WCHAR wszTemp[MAX_PATH];
    WCHAR * wszTitle = NULL;
    va_list arglist;
    va_start(arglist, hwndParent);
    LPSTR szTitle = va_arg(arglist, LPSTR);
    if (szTitle != NULL)
    {
        ATOW(wszTemp, szTitle, MAX_PATH);
        wszTitle = wszTemp;
    }
    int nRet = OleUIPromptUserInternal(nTemplate, hwndParent, wszTitle, arglist);
    va_end(arglist);

    return(nRet);
}

#else // UNICODE not defined
// Stubbed out Wide entry points

STDAPI_(BOOL) OleUIAddVerbMenuW(LPOLEOBJECT lpOleObj, LPCWSTR lpszShortType,
        HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu)
{
    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReturnError
//
//  Synopsis:   Used to stub out the following entry points:
//                  OleUIInsertObjectW
//                  OleUIPasteSpecialW
//                  OleUIEditLinksW
//                  OleUIChangeIconW
//                  OleUIConvertW
//                  OleUIBusyW
//                  OleUIObjectPropertiesW
//                  OleUIChangeSourceW
//
//  Returns:    OLEUI_ERR_DIALOGFAILURE
//
//  History:    12-29-94   stevebl   Created
//
//  Notes:      The entry points listed above are all mapped to this function
//              in the Chicago version of OLEDLG.DEF.
//
//----------------------------------------------------------------------------

STDAPI_(UINT) ReturnError(void * p)
{
    return(OLEUI_ERR_DIALOGFAILURE);
}

STDAPI_(BOOL) OleUIUpdateLinksW(LPOLEUILINKCONTAINERW lpOleUILinkCntr,
        HWND hwndParent, LPWSTR lpszTitle, int cLinks)
{
    return(FALSE);
}

int FAR CDECL OleUIPromptUserW(int nTemplate, HWND hwndParent, LPWSTR lpszTitle, ...)
{
    return(2); // same as if user had cancelled the dialog
}
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\cwindow.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cwindow.cxx
//
//  Contents:   implementation for a window class
//
//  Classes:    CHlprWindow
//
//  Functions:  WindowProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "cwindow.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHlprWindow::Create
//
//  Synopsis:   Special version of CreateWindow.
//
//  Arguments:  [lpszClassName]  - address of registered class name
//              [lpszWindowName] - address of window name
//              [dwStyle]        - window style
//              [x]              - horizontal position of window
//              [y]              - vertical position of window
//              [nWidth]         - window width
//              [nHeight]        - window height
//              [hwndParent]     - handle of parent or owner window
//              [hmenu]          - handle of menu, or child window identifier
//              [hinst]          - handle of application instance
//
//  Returns:    HWND of the created window
//
//  Modifies:   _hwnd, _hInstance
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      The window class must have been previously registered (as
//              is normal Windows procedure) and the callback function
//              must have been registered as ::WindowProc.  ::WindowProc will
//              then forward all messages on to the CHlprWindow::WindowProc
//              method, allowing the window to directly access class members
//              (i.e. giving the WindowProc access to the "this" pointer).
//
//----------------------------------------------------------------------------

HWND CHlprWindow::Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HMENU hmenu,
    HINSTANCE hinst)
{
    _hInstance = hinst;
    return(_hwnd =
        CreateWindow(
            lpszClassName,
            lpszWindowName,
            dwStyle,
            x,
            y,
            nWidth,
            nHeight,
            hwndParent,
            hmenu,
            hinst,
            this));
}

//+---------------------------------------------------------------------------
//
//  Function:   WindowProc
//
//  Synopsis:   Standard WindowProc that forwards Windows messages on to the
//              CHlprWindow::WindowProc method.
//
//  Arguments:  [hwnd]   - window handle
//              [uMsg]   - message
//              [wParam] - first message parameter
//              [lParam] - second message parameter
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This Window procedure expects that it will receive a "this"
//              pointer as the lpCreateParams member passed as part of the
//              WM_CREATE message.  It saves the "this" pointer in the
//              GWL_USERDATA field of the window structure.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprWindow * pw;
    switch (uMsg)
    {
    case WM_CREATE:
        // Since this is the first time that we can get ahold of
        // a pointer to the window class object, all messages that might
        // have been sent before this are never seen by the Windows object
        // and only get passed on to te DefWindowProc

        // get a pointer to the window class object
        pw = (CHlprWindow *) ((CREATESTRUCT *)lParam)->lpCreateParams;
        // set its USERDATA DWORD to point to the class object
        SetWindowLong(hwnd, GWL_USERDATA, (long) pw);
        // Set it's protected _hwnd member variable to ensure that
        // member functions have access to the correct window handle.
        pw->_hwnd = hwnd;
        break;
    case WM_DESTROY:
        // This is our signal to destroy the window class object.

        pw = (CHlprWindow *) GetWindowLong(hwnd, GWL_USERDATA);
        SetWindowLong(hwnd, GWL_USERDATA, 0);
        delete pw;
        pw = (CHlprWindow *) 0;
        break;
    default:
        // get a pointer to the window class object
        pw = (CHlprWindow *) GetWindowLong(hwnd, GWL_USERDATA);
        break;
    }
    // and call its message proc method
    if (pw != (CHlprWindow *) 0)
    {
        return(pw->WindowProc(uMsg, wParam, lParam));
    }
    else
    {
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\cwindow.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cwindow.h
//
//  Contents:   definition of a virtual window class
//
//  Classes:    CHlprWindow
//
//  Functions:  WindowProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------


#ifndef __CWINDOW_H__
#define __CWINDOW_H__

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

LRESULT CALLBACK WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprWindow
//
//  Purpose:    virtual base class for wrapping a window
//
//  Interface:  Create     -- analagous to Windows' CreateWindow function
//              WindowProc -- pure virtual WindowProc for the window
//              ~CHlprWindow   -- destructor
//              CHlprWindow    -- constructor
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This class allows a window to be cleanly wrapped in a
//              c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a WindowProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprWindow
{
public:
    HWND Create(
        LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName,
        DWORD dwStyle,
        int x,
        int y,
        int nWidth,
        int nHeight,
        HWND hwndParent,
        HMENU hmenu,
        HINSTANCE hinst);
    virtual LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprWindow(){};
    HWND GetHwnd(void)
    {
        return(_hwnd);
    }
    CHlprWindow()
    {
        _hwnd = NULL;
        _hInstance = NULL;
    };
protected:
friend LRESULT CALLBACK ::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
    HWND _hwnd;
    HINSTANCE _hInstance;
};

#endif

#endif //__CWINDOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\cdialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cdialog.h
//
//  Contents:   definition for common dialog functionality
//
//  Classes:    CHlprDialog (pure virtual class)
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprDialog
//
//  Purpose:    virtual base class for wrapping Windows' dialog functionality
//
//  Interface:  ShowDialog -- analagous to the Windows DialogBox function
//              DialogProc -- pure virtual DialogProc for the dialog box
//              ~CHlprDialog   -- destructor
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This class allows a dialog box to be cleanly wrapped in
//              a c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a DialogProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprDialog
{
public:
    virtual int ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner);
    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprDialog(){};
protected:
    HINSTANCE _hInstance;
};

#endif //__cplusplus

#endif //__CDIALOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\cdialog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dialog.cxx
//
//  Contents:
//
//  Classes:    CHlprDialog
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "cdialog.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHlprDialog::ShowDialog
//
//  Synopsis:   Creates the dialog so that it's DialogProc member function can
//              be invoked.
//
//  Arguments:  [hinst]        - handle of the application instance
//              [lpszTemplate] - identifies the dialog box template
//              [hwndOwner]    - handle of the owner window
//
//  Returns:    return value from the dialog box
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      The dialog box object exists until deleted by the caller.
//              It can be shown any number of times.
//
//              This function is analgous to Windows' DialogBox function.  The
//              main difference being that you don't specify a DialogProc;
//              you override the pure virtal function CHlprDialog::DialogProc.
//
//----------------------------------------------------------------------------

int CHlprDialog::ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner)
{
    _hInstance = hinst;
    return(DialogBoxParam(hinst, lpszTemplate, hwndOwner, ::DialogProc, (long)this));
}

//+---------------------------------------------------------------------------
//
//  Function:   DialogProc
//
//  Synopsis:   Common DialogProc used by all CHlprDialog class objects.
//
//  Arguments:  [hwndDlg] - handle of dialog box
//              [uMsg]    - message
//              [wParam]  - first message parameter
//              [lParam]  - second message parameter
//
//  Returns:    response from the CHlprDialog::DialogProc method
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This procedure is the DialogProc registered for all dialogs
//              created with the CHlprDialog class.  It uses the parameter
//              passed with the WM_INITDIALOG message to identify the dialog
//              classes' "this" pointer which it then stores in the window
//              structure's GWL_USERDATA field.  All subsequent messages
//              can then be forwarded on to the correct dialog class's
//              DialogProc method by using the pointer stored in the
//              GWL_USERDATA field.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprDialog * pdlg;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This message is how we identify the dialog object.

        // get a pointer to the window class object
        pdlg = (CHlprDialog *) lParam;
        // set its USERDATA word to point to the class object
        SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdlg);
        break;
    default:
        // get a pointer to the window class object
        pdlg = (CHlprDialog *) GetWindowLong(hwndDlg, GWL_USERDATA);
        break;
    }
    // and call its message proc method
    if (pdlg != (CHlprDialog *) 0)
    {
        return(pdlg->DialogProc(hwndDlg, uMsg, wParam, lParam));
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\linkcntr.cxx ===
#include <windows.h>
#include <assert.h>
#include <oledlg.h>
#include "linkcntr.h"

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)
{
    return(E_NOTIMPL);
};

ULONG STDMETHODCALLTYPE CMyOleUILinkContainer::AddRef()
{
    return(0);
};

ULONG STDMETHODCALLTYPE CMyOleUILinkContainer::Release()
{
    return(0);
}

DWORD STDMETHODCALLTYPE CMyOleUILinkContainer::GetNextLink(DWORD dwLink)
{
    return(0);
}

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::SetLinkUpdateOptions(DWORD dwLink, DWORD dwUpdateOpt)
{
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::GetLinkUpdateOptions(DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt)
{
    *lpdwUpdateOpt = OLEUPDATE_ONCALL;
    return(S_OK);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::SetLinkSource(DWORD dwLink, LPTSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::GetLinkSource(DWORD dwLink,
            LPTSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPTSTR FAR* lplpszFullLinkType, LPTSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::OpenLinkSource(DWORD dwLink)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::UpdateLink(DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::CancelLink(DWORD dwLink)
{
    return(E_NOTIMPL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\linkcntr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       linkcntr.h
//
//  Contents:   bogus implementation of IOleUILinkContainer
//
//  Classes: CMyOleUILinkContainer
//
//  Functions:
//
//  History:    11-28-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef _LINKCNTR_H_
#define _LINKCNTR_H_

class CMyOleUILinkContainer: public IOleUILinkContainer
{
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD_(DWORD, GetNextLink)(THIS_ DWORD dwLink);
    STDMETHOD(SetLinkUpdateOptions)(THIS_ DWORD dwLink, DWORD dwUpdateOpt);
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt);
    STDMETHOD(SetLinkSource) (THIS_ DWORD dwLink, LPTSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource);
    STDMETHOD(GetLinkSource) (THIS_ DWORD dwLink,
            LPTSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPTSTR FAR* lplpszFullLinkType, LPTSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected);
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink);
    STDMETHOD(UpdateLink) (THIS_ DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction);
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink);
};

#endif // _LINKCNTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\message.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       message.cxx
//
//  Contents:   Helper functions for popup message boxes.
//
//  Classes:
//
//  Functions:  MessageBoxFromSringIds
//
//  History:    6-24-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "message.h"

//+---------------------------------------------------------------------------
//
//  Function:   MessageBoxFromStringIds
//
//  Synopsis:   Displays a simple message box taking its text from a string
//              table instead of from user allocated strings.
//
//  Arguments:  [hwndOwner]      - window handle for the message box's owner
//              [hinst]          - instance associated with the string table
//              [idText]         - string id for the box's text string
//              [idTitle]        - string id for the box's title string
//              [fuStyle]        - style of message box
//                                 (see Windows function MessageBox for styles)
//
//  Returns:    result from MessageBox
//
//  History:    6-24-94   stevebl   Created
//
//  Notes:      Each string is limited to MAX_STRING_LENGTH characters.
//
//----------------------------------------------------------------------------

int MessageBoxFromStringIds(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idText,
    const UINT idTitle,
    const UINT fuStyle)
{
    int iReturn = 0;
    TCHAR szTitle[MAX_STRING_LENGTH];
    TCHAR szText[MAX_STRING_LENGTH];
    if (LoadString(hinst, idTitle, szTitle, MAX_STRING_LENGTH))
    {
        if (LoadString(hinst, idText, szText, MAX_STRING_LENGTH))
        {
            iReturn = MessageBox(
                hwndOwner,
                szText,
                szTitle,
                fuStyle);
        }
    }
    return(iReturn);
}

//+---------------------------------------------------------------------------
//
//  Function:   MessageBoxFromStringIdsAndArgs
//
//  Synopsis:   Creates a message box from a pair of string IDs similar
//              to MessageBoxFromStringIds.  The principle difference
//              is that idFormat is an ID for a string which is a printf
//              format string suitable for passing to wsprintf.
//              The variable argument list is combined with the format
//              string to create the text of the message box.
//
//  Arguments:  [hwndOwner] - window handle for the message box's owner
//              [hinst]     - instance associated with the string table
//              [idFormat]  - string id for the format of the box's text
//              [idTitle]   - string id for the box's title string
//              [fuStyle]   - style of the dialog box
//              [...]       - argument list for text format string
//
//  Returns:    result from MessageBox
//
//  History:    6-24-94   stevebl   Created
//
//  Notes:      Neither the composed text string nor the title must be
//              longer than MAX_STRING_LENGTH characters.
//
//----------------------------------------------------------------------------

int MessageBoxFromStringIdsAndArgs(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idFormat,
    const UINT idTitle,
    const UINT fuStyle, ...)
{
    int iReturn = 0;
    va_list arglist;
    va_start(arglist, fuStyle);
    TCHAR szTitle[MAX_STRING_LENGTH];
    TCHAR szText[MAX_STRING_LENGTH];
    TCHAR szFormat[MAX_STRING_LENGTH];
    if (LoadString(hinst, idTitle, szTitle, MAX_STRING_LENGTH))
    {
        if (LoadString(hinst, idFormat, szFormat, MAX_STRING_LENGTH))
        {
            wvsprintf(szText, szFormat, arglist);
            iReturn = MessageBox(
                hwndOwner,
                szText,
                szTitle,
                fuStyle);
        }
    }
    return(iReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\message.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       message.h
//
//  Contents:   Helper functions for popup message boxes.
//
//  Classes:
//
//  Functions:  MessageBoxFromStringIds
//
//  History:    6-24-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __MESSAGE_H__
#define __MESSAGE_H__

#define MAX_STRING_LENGTH           256

int MessageBoxFromStringIds(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idText,
    const UINT idTitle,
    const UINT fuStyle);

int MessageBoxFromStringIdsAndArgs(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idText,
    const UINT idTitle,
    const UINT fuStyle,
    ...);

#endif //__MESSAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\mwclass.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       mwclass.cxx
//
//  Contents:   implementation for the main window class
//
//  Classes:    CMainWindow
//
//  Functions:  Exists
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "test.h"
#include "mwclass.h"
#include "about.h"
#include <assert.h>
#include <oledlg.h>
#include "linkcntr.h"

CMyOleUILinkContainer MyOleUILinkContainer;


//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::CMainWindow
//
//  Synopsis:   constructor
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

CMainWindow::CMainWindow()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::~CMainWindow
//
//  Synopsis:   destructor
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      Destruction of the main window indicates that the app should
//              quit.
//
//----------------------------------------------------------------------------

CMainWindow::~CMainWindow()
{
    PostQuitMessage(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::InitInstance
//
//  Synopsis:   Instantiates an instance of the Galactic War window.
//
//  Arguments:  [hInstance] - instance of the app
//              [nCmdShow]  - command to pass to ShowWindow
//
//  Returns:    TRUE on success
//              FALSE on failure
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      This method must be called only once, immediately after
//              class construction.
//
//----------------------------------------------------------------------------

BOOL CMainWindow::InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    // Note, the Create method sets the _hwnd member for me so I don't
    // need to set it myself.
    if (!Create(
        TEXT(MAIN_WINDOW_CLASS_NAME),
        TEXT(VER_INTERNALNAME_STR),
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX
            | WS_MAXIMIZEBOX | WS_THICKFRAME,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance))
    {
        return(FALSE);
    }

    ShowWindow(_hwnd, nCmdShow);
    UpdateWindow(_hwnd);

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::WindowProc
//
//  Synopsis:   main window procedure
//
//  Arguments:  [uMsg]   - Windows message
//              [wParam] - first message parameter
//              [lParam] - second message parameter
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      See CHlprWindow for a description of how this method gets
//              called by the global WinProc.
//
//----------------------------------------------------------------------------

LRESULT CMainWindow::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CREATE:
        return(TRUE);
    case WM_COMMAND:
        return DoMenu(wParam, lParam);
    case WM_QUIT:
    case WM_CLOSE:
    default:
        return(DefWindowProc(_hwnd, uMsg, wParam, lParam));
    }
    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::DoMenu
//
//  Synopsis:   implements the main menu commands
//
//  Arguments:  [wParam] - first window parameter
//              [lParam] - second window parameter
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

LRESULT CMainWindow::DoMenu(WPARAM wParam, LPARAM lParam)
{
    switch (LOWORD(wParam))
    {
    case IDM_INSERTOBJECT:
        TestInsertObject();
        break;
    case IDM_PASTESPECIAL:
        TestPasteSpecial();
        break;
    case IDM_EDITLINKS:
        TestEditLinks();
        break;
    case IDM_CHANGEICON:
        TestChangeIcon();
        break;
    case IDM_CONVERT:
        TestConvert();
        break;
    case IDM_CANCONVERT:
        TestCanConvert();
        break;
    case IDM_BUSY:
        TestBusy();
        break;
    case IDM_CHANGESOURCE:
        TestChangeSource();
        break;
    case IDM_OBJECTPROPS:
        TestObjectProps();
        break;
    case IDD_LINKSOURCEUNAVAILABLE:
    case IDD_CANNOTUPDATELINK:
    case IDD_SERVERNOTREG:
    case IDD_LINKTYPECHANGED:
    case IDD_SERVERNOTFOUND:
    case IDD_OUTOFMEMORY:
        TestPromptUser((int)LOWORD(wParam));
        break;
    case IDM_UPDATELINKS:
        TestUpdateLinks();
        break;
    case IDM_EXIT:
        SendMessage(_hwnd, WM_CLOSE, 0, 0);
        break;
    case IDM_ABOUT:
        {
            CAbout dlgAbout;
            dlgAbout.ShowDialog(_hInstance, MAKEINTRESOURCE(IDM_ABOUT), _hwnd);
        }
        break;
    default:
        return(DefWindowProc(_hwnd, WM_COMMAND, wParam, lParam));
    }
    return(FALSE);
}

void CMainWindow::TestInsertObject()
{
    TCHAR szFile[MAX_PATH];
    OLEUIINSERTOBJECT io;
    memset(&io, 0, sizeof(OLEUIINSERTOBJECT));
    io.cbStruct = sizeof(io);
    io.dwFlags = IOF_SELECTCREATECONTROL | IOF_SHOWINSERTCONTROL;
//    io.dwFlags = IOF_SHOWINSERTCONTROL;
    io.hWndOwner = _hwnd;
    io.lpszFile = szFile;
    io.cchFile = MAX_PATH;
    io.lpszCaption = TEXT("Testing OleUIInsertObject dialog");
    memset(szFile, 0, sizeof(szFile));

    UINT uReturn = OleUIInsertObject(&io);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_INSERTOBJECT,
        IDS_RETURN,
        MB_OK,
        uReturn,
        io.dwFlags,
        io.lpszFile,
        io.sc);
}

void CMainWindow::TestPasteSpecial()
{
    LPDATAOBJECT lpClipboardDataObj = NULL;
    HRESULT hr = OleGetClipboard(&lpClipboardDataObj);
    if (SUCCEEDED(NOERROR))
    {
        OLEUIPASTEENTRY rgPe[1];
        rgPe[0].fmtetc.cfFormat = CF_TEXT;
        rgPe[0].fmtetc.ptd = NULL;
        rgPe[0].fmtetc.dwAspect = DVASPECT_CONTENT;
        rgPe[0].fmtetc.tymed = TYMED_HGLOBAL;
        rgPe[0].fmtetc.lindex = -1;
        rgPe[0].lpstrFormatName = TEXT("Text");
        rgPe[0].lpstrResultText = TEXT("Text");
        rgPe[0].dwFlags = OLEUIPASTE_PASTEONLY;

        OLEUIPASTESPECIAL ps;
        memset(&ps, 0, sizeof(ps));
        ps.cbStruct = sizeof(ps);
        ps.dwFlags = IOF_SHOWHELP | PSF_SELECTPASTE;
        ps.hWndOwner = _hwnd;
        ps.lpszCaption = TEXT("Paste Special");
        ps.lpSrcDataObj = lpClipboardDataObj;
        ps.arrPasteEntries = rgPe;
        ps.cPasteEntries = 1;
        ps.lpszCaption = TEXT("Testing OleUIPasteSpecial dialog");

        UINT uReturn = OleUIPasteSpecial(&ps);

        MessageBoxFromStringIdsAndArgs(
            _hwnd,
            _hInstance,
            IDS_PASTESPECIAL,
            IDS_RETURN,
            MB_OK,
            uReturn,
            ps.dwFlags,
            ps.nSelectedIndex,
            ps.fLink,
            ps.sizel);
        if (lpClipboardDataObj)
        {
            lpClipboardDataObj->Release();
        }
    }
    else
    {
        MessageBoxFromStringIdsAndArgs(
            _hwnd,
            _hInstance,
            IDS_NOCLIPBOARD,
            IDS_ERROR,
            MB_OK,
            hr);
        // report failure getting clipboard object
    }
}

void CMainWindow::TestEditLinks()
{
    OLEUIEDITLINKS el;
    memset(&el, 0, sizeof(el));
    el.cbStruct = sizeof(el);
    el.dwFlags = ELF_SHOWHELP;
    el.hWndOwner = _hwnd;
    el.lpOleUILinkContainer = &MyOleUILinkContainer;
    el.lpszCaption = TEXT("Testing OleUIEditLinks dialog");

    UINT uReturn = OleUIEditLinks(&el);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_EDITLINKS,
        IDS_RETURN,
        MB_OK,
        uReturn,
        el.dwFlags);
}

void CMainWindow::TestChangeIcon()
{
    OLEUICHANGEICON ci;
    memset(&ci, 0, sizeof(ci));
    ci.cbStruct = sizeof(ci);
    ci.dwFlags = CIF_SHOWHELP | CIF_SELECTCURRENT;
    ci.hWndOwner = _hwnd;
    ci.lpszCaption = TEXT("Testing OleUIChangeIcon dialog");

    UINT uReturn = OleUIChangeIcon(&ci);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CHANGEICON,
        IDS_RETURN,
        MB_OK,
        uReturn,
        ci.dwFlags);
}

void CMainWindow::TestConvert()
{
    OLEUICONVERT cv;
    memset(&cv, 0, sizeof(cv));
    cv.cbStruct = sizeof(cv);
    cv.dwFlags = CF_SHOWHELPBUTTON;
    cv.hWndOwner = _hwnd;
    cv.lpszCaption = TEXT("Testing OleUIConvert dialog");

    UINT uReturn = OleUIConvert(&cv);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CONVERT,
        IDS_RETURN,
        MB_OK,
        uReturn,
        cv.dwFlags);
}

void CMainWindow::TestCanConvert()
{
    CLSID cid = { /* 00030003-0000-0000-c000-000000000046 ("Word Document") */
        0x00030003,
        0x0000,
        0x0000,
        {0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}
    };
    BOOL fReturn = OleUICanConvertOrActivateAs(cid, FALSE, CF_TEXT);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CANCONVERT,
        IDS_RETURN,
        MB_OK,
        fReturn);
}

void CMainWindow::TestBusy()
{
    OLEUIBUSY bz;
    memset(&bz, 0, sizeof(bz));
    bz.cbStruct = sizeof(bz);
    bz.hWndOwner = _hwnd;
    bz.lpszCaption = TEXT("Testing OleUIBusy dialog");

    UINT uReturn = OleUIBusy(&bz);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_BUSY,
        IDS_RETURN,
        MB_OK,
        uReturn,
        bz.dwFlags);
}

void CMainWindow::TestChangeSource()
{
    OLEUICHANGESOURCE cs;
    memset(&cs, 0, sizeof(cs));
    cs.cbStruct = sizeof(cs);
    cs.hWndOwner = _hwnd;
    cs.lpszCaption = TEXT("Testing OleUIChangeSource dialog");

    UINT uReturn = OleUIChangeSource(&cs);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CHANGESOURCE,
        IDS_RETURN,
        MB_OK,
        uReturn,
        cs.dwFlags);
}

void CMainWindow::TestObjectProps()
{
    OLEUIOBJECTPROPS op;
    memset(&op, 0, sizeof(op));
    op.cbStruct = sizeof(op);

    UINT uReturn = OleUIObjectProperties(&op);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_OBJECTPROPS,
        IDS_RETURN,
        MB_OK,
        uReturn,
        op.dwFlags);
}

void CMainWindow::TestPromptUser(int nTemplate)
{
    UINT uReturn = OleUIPromptUser(
        nTemplate,
        _hwnd,
        // string arguments:
        TEXT("Testing OleUIPromptUser"),
        TEXT("BAR"),
        TEXT("FOO"));
    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_PROMPTUSER,
        IDS_RETURN,
        MB_OK,
        uReturn);
}

void CMainWindow::TestUpdateLinks()
{
    UINT cLinks = 0;
    BOOL fReturn = OleUIUpdateLinks(
        &MyOleUILinkContainer,
        _hwnd,
        TEXT("Testing OleUIUpdateLinks dialog"),
        cLinks);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_UPDATELINKS,
        IDS_RETURN,
        MB_OK,
        fReturn);
}

//+---------------------------------------------------------------------------
//
//  Function:   Exists
//
//  Synopsis:   simple function to test for the existance of a file
//
//  History:    6-16-93   stevebl   Created
//
//----------------------------------------------------------------------------

int Exists(TCHAR *sz)
{
    HANDLE h;
    h = CreateFile(sz,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        0);
    if (h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(h);
        return(1);
    }
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\mwclass.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       mwclass.h
//
//  Contents:   definition of the main window class
//
//  Classes:    CMainWindow
//
//  Functions:  Exists
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __MWCLASS_H__
#define __MWCLASS_H__

#include <cwindow.h>
#include <commdlg.h>

#ifdef __cplusplus

int Exists(TCHAR *sz);

//+---------------------------------------------------------------------------
//
//  Class:      CMainWindow
//
//  Purpose:    Code for the main Galactic War window and the main menu.
//
//  Interface:  CMainWindow          -- constructor
//              InitInstance         -- instantiates the main window
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      only the public interface is listed here
//
//----------------------------------------------------------------------------

class CMainWindow: public CHlprWindow
{
public:
    CMainWindow();
    BOOL InitInstance(HINSTANCE, int);
protected:
    ~CMainWindow();
    LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
    LRESULT DoMenu(WPARAM wParam, LPARAM lParam);
    void TestInsertObject();
    void TestPasteSpecial();
    void TestEditLinks();
    void TestChangeIcon();
    void TestConvert();
    void TestCanConvert();
    void TestBusy();
    void TestChangeSource();
    void TestObjectProps();
    void TestPromptUser(int nTemplate);
    void TestUpdateLinks();
};

#endif // __cplusplus

#endif // __MWCLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\test.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       test.h
//
//  Contents:   globaly defined constance, IDs and structures for Galactic War
//
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __TEST_H__
#define __TEST_H__

#include <windows.h>
#include "message.h"

// string constants
#define VER_FILEDESCRIPTION_STR     "OLE2UI32 Test Ap"
#define VER_INTERNALNAME_STR        "TOLE2UI"
#define VER_ORIGINALFILENAME_STR    "TOLE2UI.EXE"
#define MAIN_WINDOW_CLASS_NAME      "TOLE2UIWindow"
#define MAIN_WINDOW_CLASS_MENU      TOLE2UIMenu
#define MAIN_WINDOW_CLASS_MENU_STR  "TOLE2UIMenu"

// menu command identifiers
#define IDM_EXIT            101
#define IDM_INSERTOBJECT    102
#define IDM_PASTESPECIAL    103
#define IDM_EDITLINKS       104
#define IDM_CHANGEICON      105
#define IDM_CONVERT         106
#define IDM_CANCONVERT      107
#define IDM_BUSY            108
#define IDM_CHANGESOURCE    110
#define IDM_OBJECTPROPS     111
#define IDM_PROMPTUSER      112
#define IDM_UPDATELINKS     113

#define IDM_HELP            202
#define IDM_ABOUT           202

// string identifiers
#define IDS_ERROR           1000
#define IDS_OUTOFMEMORY     1001
#define IDS_OLEINITFAILED   1002
#define IDS_BADOLEVERSION   1003
#define IDS_RETURN          1004
#define IDS_INSERTOBJECT    1005
#define IDS_PASTESPECIAL    1006
#define IDS_NOCLIPBOARD     1007
#define IDS_EDITLINKS       1008
#define IDS_CHANGEICON      1009
#define IDS_CONVERT         1010
#define IDS_CANCONVERT      1011
#define IDS_BUSY            1012
#define IDS_CHANGESOURCE    1013
#define IDS_OBJECTPROPS     1014
#define IDS_PROMPTUSER      1015
#define IDS_UPDATELINKS     1016

#endif // __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole2ui32\test\winmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       winmain.cxx
//
//  Contents:   main entry point
//
//  Classes:
//
//  Functions:  WinMain
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "test.h"
#include "mwclass.h"
#include <ole2ver.h>

//+---------------------------------------------------------------------------
//
//  Function:   InitApplication
//
//  Synopsis:   initializes the application and registers its window class
//              (called once for all instances)
//
//  Arguments:  [hInstance] - handle to the first instance
//
//  Returns:    TRUE on success
//
//  History:    4-11-94   stevebl   Created for MFract
//              9-30-94   stevebl   Stolen from MFract
//
//----------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = &WindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hCursor = (HCURSOR) LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.hIcon = LoadIcon(hInstance, TEXT("AppIcon"));
    wc.lpszMenuName = TEXT(MAIN_WINDOW_CLASS_MENU_STR);
    wc.lpszClassName = TEXT(MAIN_WINDOW_CLASS_NAME);
    return(RegisterClass(&wc));
}

//+---------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main window proceedure
//
//  Arguments:  [hInstance]     - instance handle
//              [hPrevInstance] - handle of the previous instance (if any)
//              [lpCmdLine]     - pointer to the command line
//              [nCmdShow]      - show state
//
//  History:    4-11-94   stevebl   Created for MFract
//              9-30-94   stevebl   Stolen from MFract
//
//  Notes:      initializes application and starts message loop
//
//----------------------------------------------------------------------------

extern "C" int PASCAL WinMain(HINSTANCE hInstance,
            HINSTANCE hPrevInstance,
            LPSTR lpCmdLine,
            int nCmdShow)
{
    DWORD dwBuildVersion = OleBuildVersion();
    if (HIWORD(dwBuildVersion) != rmm || LOWORD(dwBuildVersion) < rup)
    {
        // alert the caller that the OLE version is incompatible
        // with this build.
        MessageBoxFromStringIds(
                    NULL,
                    hInstance,
                    IDS_BADOLEVERSION,
                    IDS_ERROR,
                    MB_OK);
        return(FALSE);
    }
    if (FAILED(OleInitialize(NULL)))
    {
        // alert the caller that OLE couldn't be initialized
        MessageBoxFromStringIds(
                    NULL,
                    hInstance,
                    IDS_OLEINITFAILED,
                    IDS_ERROR,
                    MB_OK);
        return(FALSE);
    }
    if (!hPrevInstance)
    {
        if (!InitApplication(hInstance))
        {
            return(FALSE);
        }
    }
    CMainWindow * pw = new CMainWindow;
    if (pw == NULL)
    {
        return(FALSE);
    }
    if (!pw->InitInstance(hInstance, nCmdShow))
    {
        // Note, if InitInstance has failed then it would have
        // already deleted pw for me so I don't delete it here.
        // This is because when WM_CREATE returns -1 (failure)
        // Windows sends the WM_DESTROY message to the window
        // and the the CHlprWindow class destroys itself whenever
        // it receives this message.
        return(FALSE);
    }

    MSG msg;
    HACCEL haccel = LoadAccelerators(hInstance, TEXT("AppAccel"));
    if (haccel == NULL)
    {
        return(FALSE);
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(
            pw->GetHwnd(),
            haccel,
            &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    OleUninitialize();
    return(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    daytona.inc

Abstract:

    This file is included from all of the daytona sources files. It
    is handy for doing things like turning off precompiled headers
    to get around compiler bugs, and other such global activities.

!ENDIF

!include ole.inc

C_DEFINES=    \
              $(C_DEFINES)\
              -DNOEXCEPTIONS\
              -DINC_OLE2\
              -DFLAT\
              -DWIN32=100\
              -DDIRECTORY_SERVICE\
              -D_NT1X_=100\
              -D_WIN32_WINNT=0x0501\
              -DUNICODE\
              -D_UNICODE\
              -DCAIROLE_DOWNLEVEL\
              -DDCOM\
              -DASYNC\
              -DMSWMSG\
              -DDCOM_SECURITY\
              -DDFSACTIVATION\
              -DNEWPROPS\
              -D_TRACKLINK_=1\
              -DLITTLEENDIAN=1\
              -DLOCK_PERF=0\
              -D_SRVRHR=0\
              -DSSL\
              -DLIGHTNA\
              $(TRACELOG)

# For the x86, we have the few C runtime routines we use self-contained.
USE_MSVCRT=1

GPCH_BUILD=daytona

DEST_TREE=daytona

BUFFER_OVERFLOW_CHECKS=NO_NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ole.inc

Abstract:

    This file is included from all of the sources files for all platforms
    built in the ole tree.  It is handy for defining common options and
    paths used in building for different platformsn.

!ENDIF

# This *should* be the only place the root of the project is defined or
# used in building the ole source tree.  If you want to build this
# project with a different root either edit this file or set OLEDIR in your
# environment.
# But, OLEDIR is also used in olethunk\ole16\makefile.inc

!ifndef OLEDIR
OLEDIR=$(PROJECT_ROOT)\ole32
!endif

#   We define _OLE32_ so that when building ole32.dll we don't have
#   DECLSPEC_IMPORT defined (see objbase.h)

!if "$(MINORCOMP)"=="com" || "$(MINORCOMP)"=="stg"||"$(MINORCOMP)"=="ole232"|| \
    "$(MINORCOMP)"=="common" || "$(MINORCOMP)"=="proxy" ||\
     "$(MINORCOMP)"=="comcat" || "$(MINORCOMP)"=="txfole"
C_DEFINES=    \
              $(C_DEFINES)          \
              -D_OLE32_
!endif

MSC_WARNING_LEVEL=/W4
COMPILER_WARNINGS=/FIWarningControl.h

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\actprops\actstrm.cxx ===
//+-------------------------------------------------------------------
//
//  File:       actstrm.cxx
//
//  Contents:   code for providing a stream with an IBuffer interface
//              as well as providing marshalled interface data for 
//              RPC.
//
//  Classes:    ActivationStream
//
//  History:    30-Jan-93   Ricksa      Created CXmitRpcStream
//              04-Feb-98   Vinaykr     ActivationStream
//
//  Description: All requirements of CXmitRpcStream, plus the additional
//               requirement of being able to support a buffer interface
//               for activation custom marshalling.
//--------------------------------------------------------------------

#include <ole2int.h>

#include    <actstrm.hxx>


HRESULT GetActivationStream(REFIID riid, void** ppv, DWORD size)
{
    ActivationStream *st = new ActivationStream(size);
    if (st==NULL)
        return E_OUTOFMEMORY;
    return st->QueryInterface(riid, ppv);
    return S_OK;
}



STDMETHODIMP ActivationStream::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
        IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = (IStream*)this;
        AddRef();
    }
    else
    if (IsEqualIID(iidInterface, IID_IBuffer))
    {
        *ppvObj = (IBuffer*)this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) ActivationStream::AddRef(void)
{
    Win4Assert((_clRefs != 0) && "ActivationStream::AddRef");
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) ActivationStream::Release(void)
{
    Win4Assert((_clRefs != 0) && "ActivationStream::Release");

    ULONG ulRefs = InterlockedDecrement(&_clRefs);
    if (ulRefs == 0)
    {
        delete this;
    }

    return ulRefs;
}

STDMETHODIMP ActivationStream::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if (cb > _cbData - _lOffset)
    {
        cb = _cbData - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv,_pifData->abData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP ActivationStream::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite > _cbData - _lOffset)
    {
        // the current stream is too small, try to grow it.

		// Validate that we can fulfill this request (this class doesn't
		// support buffers bigger than MAX_ULONG, so we need to avoid
		// overflow)
		UINT64 cbReq = sizeof(DWORD) + cbToWrite + _lOffset + 64;
        if(cbReq > ULONG_MAX)
        	return E_OUTOFMEMORY;

		// We have a valid request
        ULONG ulLen = (ULONG) cbReq;
 			
        if (!_fFree)
        {
            // The stream doesn't own the buffer so it can't reallocate it
            return STG_E_WRITEFAULT;
        }

        // Reallocate the size of the buffer
        // NOTE: The constant (64) added to the size allocated is a number
        // designed simply to try and decrease the number of follow on
        // allocations.

        BYTE *pbNewBuf = (BYTE *) ActMemAlloc(ulLen);

        if (pbNewBuf == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if (_pifData)
        {
            // we had a buffer from before, copy that in, and free the old one.
            memcpy(pbNewBuf, _pifData, sizeof(DWORD) + _cbData);
            ActMemFree(_pifData);
        }

        _cbData = cbToWrite + _lOffset + 64;
        _pifData = (InterfaceData *)pbNewBuf;
    }


    // copy in the new data
    memcpy(_pifData->abData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
        *pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
        _cSize = _lOffset;
    }

    return hresult;
}

STDMETHODIMP ActivationStream::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

/*
can't use this code until the stuff in ole2pr32.dll is fixed.

    // check against -2^31-1 <= x <= 2^31-1
    if (dlibMoveIN.HighPart == 0 && dlibMoveIN.LowPart < 0x80000000)
        // positive 31 bit value
        ;
    else if (dlibMoveIN.HighPart == -1L && dlibMoveIN.LowPart >= 0x80000000)
        // negative 31 bit value
        ;
    else
        return STG_E_SEEKERROR;
*/

    LONG dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

        if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
            _lOffset = _cbData + dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP ActivationStream::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP ActivationStream::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP ActivationStream::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP ActivationStream::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP ActivationStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP ActivationStream::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP ActivationStream::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    if (!pstatstg)
        return E_POINTER;
    
    memset(pstatstg, 0, sizeof(STATSTG));

    pstatstg->type = STGTY_LOCKBYTES;
    pstatstg->cbSize.LowPart = _cbData;

    // Everything else is zero or null, including the name

    return S_OK;
}

STDMETHODIMP ActivationStream::SetCopyAlignment(DWORD alignment)
{
    _copyAlignment = alignment;
    return S_OK;
}

inline ActivationStream *ActivationStream::Clone()
{
    DWORD len;
    BYTE *newBuff;
    DWORD alignmentOffset=0;

    // Assume 8 byte alignment for new buffer
    ActivationStream *strm = new ActivationStream(_cbData+_copyAlignment-1);
    if (strm == NULL)
        return strm;

    // make sure we were able to allocate an internal buffer
    if (_cbData != 0)
    {
        strm->GetLength(&len);
        if (len == 0)
        {
            delete strm;
            return NULL;
        }
    }
    
    strm->GetBuffer(&len, &newBuff);
   
    ASSERT(len==(_cbData+_copyAlignment-1));
    ASSERT( sizeof(_lOffset) == sizeof(LONG) );
    if ((UINT_PTR)(newBuff+_lOffset) & (_copyAlignment-1))
    {
        alignmentOffset = _copyAlignment - 
                               ( PtrToUlong(newBuff+_lOffset) & (_copyAlignment-1) );
    }
    GetCopy(newBuff+alignmentOffset);
    strm->SetPosition(len, _lOffset+alignmentOffset);
    return strm;
}

STDMETHODIMP ActivationStream::Clone(IStream FAR * FAR *ppstm)
{
    *ppstm = Clone();
    if (*ppstm==NULL)
        return E_OUTOFMEMORY;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetOrCreateBuffer(DWORD dwReq, DWORD *pdwLength, BYTE **ppBuff)
{
    if (((_cbData - _lOffset) < dwReq) || (!_pifData))
    {
        BYTE* pbNewBuf = (BYTE*)ActMemAlloc(sizeof(DWORD)+dwReq+_cbData-_lOffset);
        if (pbNewBuf==NULL)
            return E_OUTOFMEMORY;

        if (_pifData)
        {
            // we had a buffer from before, copy that in, and free the old one.
            memcpy(pbNewBuf, _pifData, sizeof(DWORD) + _cbData);
            ActMemFree(_pifData);
        } 
        // update _cbData
        _cbData = dwReq + _cbData - _lOffset;

        _pifData = (InterfaceData*)pbNewBuf;
    }
    *ppBuff = _pifData->abData + _lOffset;
    *pdwLength = _cbData - _lOffset;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetBuffer(DWORD *pdwLength, BYTE **ppBuff)
{
    *pdwLength = _cbData-_lOffset;
    *ppBuff = _pifData->abData + _lOffset;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetLength(DWORD *pdwLength)
{
    *pdwLength = _cbData;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetCopy(BYTE *pBuff)
{
    memcpy(pBuff, _pifData->abData, _cbData);
    return S_OK;
}

STDMETHODIMP ActivationStream::SetPosition(DWORD dwLenFromEnd, DWORD dwPosFromStart)
{
    if (dwPosFromStart > dwLenFromEnd)
        return E_FAIL;
    _lOffset = _cbData - dwLenFromEnd + dwPosFromStart;
    if (_cSize < _lOffset)
        _cSize = _lOffset;
    return S_OK;
}

STDMETHODIMP ActivationStream::SetBuffer(DWORD dwLength, BYTE *pBuff)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\actprops\actprops.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       actprops.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Functions:  Implements classes in Actprops.hxx
//
//  History:    24-Jan-98 Vinaykr   Created
//              24-Jul-98 CBiks     Fixed RAID# 199660.
//              14-Sep-98 CBiks     Fixed RAID# 214719.
//              29-Sep-98 vinaykr   Fixed RAID# 169084,
//                                  inproc unmarshaller for perf
//              14-Sep-98 CBiks     Fixed RAID# 151056.
//              22-Oct-98 TarunA    Fixed RAID# 234750
//
//--------------------------------------------------------------------------

#include <ole2int.h>

#include <actprops.hxx>
#include <stdidx.h>

//---------------------------------------------------------------------------
// GUIDs need to be declared here since they have to
// live in both the SCM and OLE32.
//---------------------------------------------------------------------------
// catalog query helper defined in ..\com\objact.cxx
HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo);

CLSID CLSID_Grammatik = {0xc9da6c40,0x83b1,0x11ce,
                         {0x81, 0xac, 0x00, 0x60, 0x8c, 0xb9, 0xf8, 0x3b}};
CLSID CLSID_WonderWare = {0x28dd9320, 0x6f69, 0x11ce,
                          {0x8b, 0x69, 0x00, 0x60, 0x8c, 0xc9, 0x7d, 0x5b}};
CLSID CLSID_WPNatLangTools = {0xe6246810, 0x030f, 0x11cf,
                              {0x88, 0x75, 0x00, 0x60, 0x8c, 0xf5, 0xab, 0x6f}};
CLSID CLSID_Grammatik8 = {0xc0e10005, 0x0201, 0x0180,
                          {0xc0, 0xe1, 0xc0, 0xe1, 0xc0, 0xe1, 0xc0, 0xe1}};

InprocActpropsUnmarshaller InprocActpropsUnmarshaller::_InprocActUnmarshaller;

CLSID *arBrokenRefCount[] =
{
    &CLSID_Grammatik,
    &CLSID_WonderWare,
    &CLSID_WPNatLangTools,
    &CLSID_Grammatik8
};

//
// Marshalling functions.  They are here because we cannot link to ole32.dll
// if we are in the SCM.
//
PFN_CORELEASEMARSHALDATA pfnCoReleaseMarshalData = NULL;
PFN_COUNMARSHALINTERFACE pfnCoUnmarshalInterface = NULL;
PFN_COGETMARSHALSIZEMAX  pfnCoGetMarshalSizeMax  = NULL;
PFN_COMARSHALINTERFACE   pfnCoMarshalInterface   = NULL;


// Resolve the function pointers for marshalling.  Call this before you
// use any of the above functions, or you WILL crash, ole32 or not.
void InitMarshalling(void)
{
    static int init = 0;

    // Only attempt to initialize once.
    if (init)
        return;

    // Do not load ole32.dll, but if it is loaded then we are linked into it,
    // and this will work.
    HMODULE hOle32 = GetModuleHandle(L"ole32.dll");
    if (hOle32)
    {
        // Get the functions we need.  
        pfnCoGetMarshalSizeMax = (PFN_COGETMARSHALSIZEMAX)GetProcAddress(hOle32, "CoGetMarshalSizeMax");
        Win4Assert(pfnCoGetMarshalSizeMax && "Could not get CoGetMarshalSizeMax!");

        pfnCoMarshalInterface = (PFN_COMARSHALINTERFACE)GetProcAddress(hOle32, "CoMarshalInterface");
        Win4Assert(pfnCoMarshalInterface && "Could not get CoMarshalInterface!");

        pfnCoUnmarshalInterface = (PFN_COUNMARSHALINTERFACE)GetProcAddress(hOle32, "CoUnmarshalInterface");
        Win4Assert(pfnCoUnmarshalInterface && "Could not get CoUnmarshalInterface!");

        pfnCoReleaseMarshalData = (PFN_CORELEASEMARSHALDATA)GetProcAddress(hOle32, "CoReleaseMarshalData");
        Win4Assert(pfnCoReleaseMarshalData && "Could not get CoReleaseMarshalData!");
    }
    // NOTE:  We leave them NULL otherwise, callers must check.  Note that this condition should not occur
    //        because we are either 1) in RPCSS, in which case it shouldn't be doing the marshalling, or 
    //        2) We are being called from ole32

    init = 1;
}

//+----------------------------------------------------------------------------
//
//  Function:      IsBrokenRefCount
//
//  Synopsis:      Check to see if this clsid is known to have broken reference
//                 counting.
//
//  History:       21-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
BOOL IsBrokenRefCount(CLSID *pClsId)
{

    ULONG i;
    ULONG len = sizeof(arBrokenRefCount)/sizeof(CLSID*);
    for (i = 0; i < len; i++)
    {
        if (IsEqualIID(*pClsId, *(arBrokenRefCount[i])))
        {
            return TRUE;
        }
    }
    return FALSE;

}

//---------------------------------------------------------------------------
//  Internal Class Factories for Activation Properties
//---------------------------------------------------------------------------
HRESULT CActivationPropertiesInCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    ActivationPropertiesIn * actin =
        new ActivationPropertiesIn();

    if (actin==NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = actin->QueryInterface(riid, ppv);
    actin->Release();
    return hr;
}

HRESULT CActivationPropertiesOutCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    ActivationPropertiesOut * actout =
        new ActivationPropertiesOut(FALSE /* fBrokenRefCount */ );

    if (actout==NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = actout->QueryInterface(riid, ppv);
    actout->Release();
    return hr;
}

HRESULT CInprocActpropsUnmarshallerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    InprocActpropsUnmarshaller *pInst;

    pInst = InprocActpropsUnmarshaller::GetInstance();

    Win4Assert(pInst);

    return pInst->QueryInterface(riid, ppv);
}

//---------------------------------------------------------------------------
// ActivationProperties is a helper class for marshalling
// different property objects. It implements ISerializableParent
// and manages a set of serializable interfaces.
// Assumptions are:
//                  a. QI'ing an interface can bring an
//                     instance into existence.
//                  b. It is possible for some interfaces
//                     to never be instantiatable on
//                     an unserialized Actprops object.
//                     This is achieved through GetClass()
//                  c. It is possible for some interfaces
//                     to never be instantiated again
//                     after they are unserialized(at
//                     least once). Achieved by returning
//                     a size of 0 in GetMarshalSizeMax
//                     Used to turn off  propagation at a
//                     particular stage.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//             Methods for ActivationProperties
//---------------------------------------------------------------------------
ActivationProperties::ActivationProperties()
{
    memset(&_serHeader, 0, sizeof(CustomHeader));
    memset(&_unSerHeader, 0, sizeof(CustomHeader));
    _ifsIndex = 0;
    _unSerialized = FALSE;
    _unSerializedInproc = FALSE;
    _pUnSer = 0;
    _serHeader.destCtx = MSHCTX_CROSSCTX;
    _marshalFlags = MSHLFLAGS_NORMAL;
    _toDelete = TRUE;
    _fDestruct = FALSE;
    _marshalState = NOT_MARSHALLED;
    _fInprocSerializationRequired = FALSE;
}

ActivationProperties::~ActivationProperties()
{
    //-------------------------------------------------------------------
    //  Release reference to unserialized stream
    //-------------------------------------------------------------------
    if (_pUnSer)
        _pUnSer->Release();

    //-------------------------------------------------------------------
    //  Release unserialized data
    //-------------------------------------------------------------------
    if (_unSerialized)
    {
        ActMemFree(_unSerHeader.pclsid);
        ActMemFree(_unSerHeader.pSizes);
    }

    if (_serHeader.cOpaqueData)
    {
        for (DWORD i=0; i<_serHeader.cOpaqueData;i++)
            ActMemFree(_serHeader.opaqueData[i].data);

        ActMemFree(_serHeader.opaqueData);
    }
}


//---------------------------------------------------------------------------
//  Methods for IUnknown
//---------------------------------------------------------------------------

    //-----------------------------------------------------------------------
    //  Assumption is that the Top-level ActivationProperties object
    //  supports interfaces of the objects contained within it.
    //  QI'ing an interface of a property object can bring it into
    //  existence. GetClass is used for this.
    //  When this is unmarshalled, the contained objects are not
    //  unserialized. They are unserialized when QI's for using
    //  UnSerializeCallback().
    //-----------------------------------------------------------------------
STDMETHODIMP ActivationProperties::QueryInterface( REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  Check for Top level interfaces
    //-------------------------------------------------------------------
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IActivationProperties*)this;
    else
        if (IsEqualIID(riid, IID_IActivationProperties))
            *ppv = (IActivationProperties*)this;
        else
            if (IsEqualIID(riid, IID_ISerializableParent))
                *ppv = (ISerializableParent*)this;
            else
                if (IsEqualIID(riid, IID_IMarshal))
                    *ppv = (IMarshal*)this;
                else
                    if (IsEqualIID(riid, IID_IMarshal2))
                        *ppv = (IMarshal2*)this;
                    else
                        if (IsEqualIID(riid, IID_IGetCatalogObject))
                            *ppv = (IGetCatalogObject*)this;
                        else
                            if (IsEqualIID(riid, CLSID_ActivationProperties))
                            {
                                // Don't addref for this one
                                *ppv = (ActivationProperties*)this;
                                return S_OK;
                            }
                            else
                                *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    //-------------------------------------------------------------------
    //  Check Contained objects
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex; i++)
        if (serializableIfsCollection[i])
            if (serializableIfsCollection[i]->SerializableQueryInterface(riid, ppv) == S_OK)
                return S_OK;

    //-------------------------------------------------------------------
    //  Check for unserialized objects                                 */
    //-------------------------------------------------------------------
    SerializableProperty *pSer;
    if (_unSerialized)
    {
        if ((hr = UnSerializeCallBack(riid, &pSer)) == S_OK)
        {
            if (pSer->SerializableQueryInterface(riid, ppv) == S_OK)
                return S_OK;
        }
        else
            if (hr != E_FAIL)
            {
                *ppv = NULL;
                return hr;
            }
    }

    //-------------------------------------------------------------------
    // Check if interface supported here                               */
    //-------------------------------------------------------------------
    if (GetClass(riid, &pSer, TRUE) == S_OK)
    {
        AddSerializableIfs(pSer);
        HRESULT hr = pSer->SerializableQueryInterface(riid, ppv);
        Win4Assert(hr==S_OK);
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG ActivationProperties::AddRef(void)
{
    return InterlockedIncrement(&_refCount);
}

ULONG ActivationProperties::Release(void)
{
    ULONG count;
    if ((count = InterlockedDecrement(&_refCount)) == 0)
    {
        //-------------------------------------------------------------------
        //  Relinquish parent-child relationship and send child off into
        //  the big bad world.
        //-------------------------------------------------------------------
        for (DWORD i=0; i<_ifsIndex; i++)
            if (serializableIfsCollection[i])
            {
                serializableIfsCollection[i]->SetParent(NULL);
            }

        return 0;
    }

    return count;
}

//---------------------------------------------------------------------------
//  Custom marshalling Methods(IMarshal)                                   */
//  Ignore Table marshalling
//---------------------------------------------------------------------------

STDMETHODIMP ActivationProperties::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags)
{
    HRESULT hr;
    BOOL fReleaseThis;

    //-------------------------------------------------------------------
    //  Check to see that requested interface is supported
    //-------------------------------------------------------------------
    void *ppv;
    if (!SUCCEEDED(hr=QueryInterface(riid, &ppv)))
    {
        return hr;
    }
    else
        fReleaseThis = TRUE;

    RpcTryExcept
        {
            //-------------------------------------------------------------------
            //  Internal marshalling distance flag already set up by
            //  GetMarshalSizeMax
            //-------------------------------------------------------------------

            void *pv;
            if (MARSHALCTX_WITHIN_PROCESS(dwDestContext))
            {
                pv = (void*)((ActivationProperties*) this);


                fReleaseThis = FALSE;
            }
            else
                pv = NULL;

            //-------------------------------------------------------------------
            //  Create Serializer for serialization
            //-------------------------------------------------------------------
            Serializer ser(_serHeader.destCtx, dwDestContext, _marshalFlags);
            hr = ser.InitStream(pStm, _serHeader.totalSize,
                                Serializer::DIRECTION_WRITE, pv);

            if (FAILED(hr))
            {
                if(fReleaseThis)
                    Release();
                return hr;
            }

            if ((!pv) || _fInprocSerializationRequired)
                hr = Serialize(ser);
            else
                hr = S_OK;

            _marshalState = MARSHALLED;
        }

    RpcExcept(TRUE)
        {
            hr = HRESULT_FROM_WIN32(RpcExceptionCode());
        }

    RpcEndExcept

        if (fReleaseThis)
            Release();

    return hr;
}

inline HRESULT ActivationProperties::Serialize(Serializer &ser)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  First encode Generic header
    //-------------------------------------------------------------------
    handle_t handle = NULL;
    hr = ser.GetSerializationHandle((void*) &handle);
    if (FAILED(hr))
        return hr;
    CustomHeader_Encode(handle, &_serHeader);
    hr = ser.IncrementPosition(_headerSize);
    if (FAILED(hr))
        return hr;
    DWORD unSerializedPosition=_unSerHeader.headerSize;
    DWORD totalinc = 0;

    //-------------------------------------------------------------------
    //  Now serialize all contained objects
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex;i++)
    {
        if (!_sizeArray[i])
            continue;
        if ((_unSerialized) && (!serializableIfsCollection[i]))
        {
            hr = _pUnSer->CopyTo(&ser, unSerializedPosition, _sizeArray[i]);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            hr = serializableIfsCollection[i]->Serialize(&ser);
            if (hr != S_OK)
                return hr;
            hr = ser.IncrementPosition(_sizeArray[i]);
            if (FAILED(hr))
                return hr;
        }
        if (_unSerialized && (i<_unSerHeader.cIfs))
            unSerializedPosition += _unSerHeader.pSizes[i];
    }


    //-------------------------------------------------------------------
    //  Commit to stream
    //-------------------------------------------------------------------
    return ser.Commit();
}


inline HRESULT ActivationProperties::SetupForUnserializing(Serializer *pSer)
{
    //---------------------------------------------------------------
    //  Read Custom header
    //  Make a copy to hold still unserialized objects for future
    //  Set up state for next serialization
    //---------------------------------------------------------------
    HRESULT hr;
    handle_t handle = NULL;
    pSer->GetSerializationHandle((void*) &handle);
    _unSerHeader.pclsid = 0;
    _unSerHeader.pSizes = 0;
    _unSerHeader.opaqueData = 0;
    CustomHeader_Decode(handle, &_unSerHeader);
    hr = pSer->IncrementPosition(_unSerHeader.headerSize);
    if (FAILED(hr))
        return hr;
    hr = pSer->GetCopy(&_pUnSer);
    if (FAILED(hr))
        return hr;
    hr = pSer->Commit();
    if (FAILED(hr))
        return hr;
    _unSerialized = TRUE;
    _ifsIndex = _unSerHeader.cIfs;
    _serHeader.destCtx = _unSerHeader.destCtx;
    _serHeader.cOpaqueData = _unSerHeader.cOpaqueData;
    _serHeader.opaqueData = _unSerHeader.opaqueData;
    return S_OK;
}

STDMETHODIMP InprocActpropsUnmarshaller::UnmarshalInterface(IStream *pStm,
                                                            REFIID riid,
                                                            void **ppv)
{
    ActivationProperties *pAct = NULL;

    RpcTryExcept
        {
            HRESULT hr;
            DWORD dwSize;
            void *pv = NULL;
            //---------------------------------------------------------------
            //  Init Serializer for reading from stream
            //---------------------------------------------------------------
            Serializer ser;
            hr = ser.InitStream(pStm, dwSize,
                                Serializer::DIRECTION_READ, pv);


            if (!SUCCEEDED(hr))
                return hr;

            pAct = (ActivationProperties*) pv;

            Win4Assert(pAct);

            if (!pAct)
                return(E_UNEXPECTED);


            //---------------------------------------------------------------
            // If we received a pointer, check if any further unserialization
            // required. If so set up stream inside object pointed to
            //---------------------------------------------------------------
            Win4Assert(pAct->_marshalState !=
                       ActivationProperties::UNMARSHALLED);

            if (dwSize != 0)
                hr = pAct->SetupForUnserializing(&ser);

            if (SUCCEEDED(hr))
            {
                if (ppv != NULL)
                    hr = pAct->QueryInterface(riid, ppv);
                else
                    hr = E_UNEXPECTED;
            }


            pAct->_marshalState = ActivationProperties::UNMARSHALLED;

            pAct->Release();


            return hr;
        }

    RpcExcept(TRUE)
        {
            //---------------------------------------------------------------
            // If we get here and have a pAct then we must release it
            //---------------------------------------------------------------
            if (pAct)
            {
                pAct->Release();
            }

            return HRESULT_FROM_WIN32(RpcExceptionCode());
        }

    RpcEndExcept

        // Should never get here !
        Win4Assert(0 && "Should never reach here");
    return E_UNEXPECTED;

}

STDMETHODIMP ActivationProperties::UnmarshalInterface(IStream *pStm,
                                                      REFIID riid,
                                                      void **ppv)
{
    RpcTryExcept
        {

            Win4Assert(_marshalState != UNMARSHALLED);

            HRESULT hr;
            DWORD dwSize;

            void *pv = NULL;

            //---------------------------------------------------------------
            //  Init Serializer for reading from stream
            //---------------------------------------------------------------
            Serializer ser;
            hr = ser.InitStream(pStm, dwSize,
                                Serializer::DIRECTION_READ, pv);


            if (!SUCCEEDED(hr))
                return hr;

            hr = SetupForUnserializing(&ser);

            if (FAILED(hr))
                return hr;

            for (DWORD i=0; i<_ifsIndex;i++)
                serializableIfsCollection[i] = 0;

            _marshalState = UNMARSHALLED;
        }

    RpcExcept(TRUE)
        {
            return HRESULT_FROM_WIN32(RpcExceptionCode());
        }

    RpcEndExcept


        //-------------------------------------------------------------------
        //  Query for requested interface to return
        //-------------------------------------------------------------------
        if (ppv != NULL)
            return QueryInterface(riid, ppv);
        else
            return S_OK;
}

STDMETHODIMP ActivationProperties::GetMarshalSizeMax(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    DWORD *pSize)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  If already know size, return it
    //-------------------------------------------------------------------
    if (_marshalState == SIZED)
    {
        *pSize = _size;
        return S_OK;
    }
    else
    {
        //---------------------------------------------------------------
        //  First set internal marshalling distance flag
        //---------------------------------------------------------------
        SetDestCtx(dwDestContext);

        if (MARSHALCTX_WITHIN_PROCESS(dwDestContext) &&
            (!_fInprocSerializationRequired))
        {
            _size = 0;
            hr = S_OK;
        }
        else
        {
            RpcTryExcept
                {
                    //---------------------------------------------------------------
                    //  Create Serializer for serialization
                    //---------------------------------------------------------------
                    Serializer ser(_serHeader.destCtx, dwDestContext, _marshalFlags);

                    hr = GetSize(ser, pSize);
                    _size = *pSize;
                    if (!_size)
                        _fInprocSerializationRequired = FALSE;
                }

            RpcExcept(TRUE)
                {
                    hr = HRESULT_FROM_WIN32(RpcExceptionCode());
                }

            RpcEndExcept
                }
    }

    if (SUCCEEDED(hr))
    {
        // Add fixed serializer header size to serialization size
        _size += Serializer::GetSize();
        *pSize = _size;
        _marshalState = SIZED;
    }

    return hr;
}

inline HRESULT ActivationProperties::GetSize(Serializer &ser, DWORD *pSize)
{

    HRESULT hr;
    DWORD size = 0;

    //-------------------------------------------------------------------
    //  Get sizes of contained objects
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex;i++)
    {
        //---------------------------------------------------------------
        //  If object was never unserialized then simply use old size
        //---------------------------------------------------------------
        if ((_unSerialized) && (!serializableIfsCollection[i]))
        {
            _clsidArray[i] = _unSerHeader.pclsid[i];
            _sizeArray[i] = _unSerHeader.pSizes[i];
        }
        else
        {
            hr = serializableIfsCollection[i]->GetCLSID(&_clsidArray[i]);
            Win4Assert(hr==S_OK);
            hr = serializableIfsCollection[i]->GetSize(&ser, &_sizeArray[i]);
            if (FAILED(hr))
                return hr;

            _sizeArray[i] = (_sizeArray[i]+7) & ~7;
        }
        size += _sizeArray[i];
    }

    //-------------------------------------------------------------------
    //  Set up header for serialization and get its size if we need
    //  to marshal any information(i.e size>0)
    //-------------------------------------------------------------------
    if (size)
    {
        _serHeader.cIfs = _ifsIndex;
        _serHeader.pSizes = _sizeArray;
        _serHeader.pclsid = _clsidArray;

        handle_t   handle;
        hr = ser.GetSizingHandle((void*) &handle);

        if (FAILED(hr))
            return hr;

        _headerSize = (DWORD) CustomHeader_AlignSize(handle, &_serHeader);
        MesHandleFree(handle);
        _serHeader.headerSize = _headerSize;
        size += _headerSize;
    }

    // return serialization size
    _serHeader.totalSize = size;
    *pSize = size;

    return S_OK;
}

STDMETHODIMP ActivationProperties::GetUnmarshalClass(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    CLSID *pCid)
{
    if (MARSHALCTX_WITHIN_PROCESS(dwDestContext))
        *pCid = CLSID_InprocActpropsUnmarshaller;
    else
        *pCid = _actCLSID;

    return S_OK;
}

STDMETHODIMP ActivationProperties::ReleaseMarshalData(IStream *pStm)
{
    return E_NOTIMPL;
}

STDMETHODIMP ActivationProperties::DisconnectObject(DWORD dwReserved)
{
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//      Methods from ISerializableParent
//---------------------------------------------------------------------------


    //-----------------------------------------------------------------------
    //  Returns serializer pointing to unserialized data for referenced
    //  CLSID
    //-----------------------------------------------------------------------
STDMETHODIMP ActivationProperties::GetUnserialized(REFCLSID clsid,
                                                   void **ppISer,
                                                   DWORD *pSize, DWORD *pPos)
{
    if (!_unSerialized)
        return E_FAIL;

    DWORD pos = _unSerHeader.headerSize;
    HRESULT hr;
    for (DWORD i=0; i<_ifsIndex; i++)
    {
        if (IsEqualIID(clsid,_unSerHeader.pclsid[i]))
        {
            hr = _pUnSer->SetPosition(pos);
	    if (FAILED (hr)) 
	    {
	       return hr;
	    }
            *pSize = _unSerHeader.pSizes[i];
            *ppISer = _pUnSer;
            *pPos = pos;
            return S_OK;
        }
        pos +=_unSerHeader.pSizes[i];
    }

    return E_FAIL;
}

//-----------------------------------------------------------------------
//  Used to do late unserialization via a QueryInterface
//  returns -
//            E_NOINTERFACE: implies that this interface can
//                           never be supported here(even if GetClass
//                           returns a valid instance).
//                           Implication is that once a class is
//                           signalled in the activation stream to
//                           not be marshalled by setting its size
//                           to zero, it can never be QI'd again.
//            E_FAIL:        implies that this interface was not
//                           part of the serialized packet(but could
//                           be supported if GetClass succeeds).
//-----------------------------------------------------------------------
inline HRESULT ActivationProperties::UnSerializeCallBack(REFCLSID clsid,
                                                         SerializableProperty **ppSer)
{
    HRESULT hr;
    SerializableProperty *pClass = NULL;
    BOOL pClassUsed = FALSE;
    Win4Assert(_unSerialized!=0);

    //-------------------------------------------------------------------
    //  Position past header
    //-------------------------------------------------------------------
    DWORD pos = _unSerHeader.headerSize;
    CLSID realclsid;
    //-------------------------------------------------------------------
    //  Check to see if class supported at all
    //-------------------------------------------------------------------
    BOOL bZeroSizeOk;
    if ((hr = GetClass(clsid, &pClass, FALSE, &bZeroSizeOk))==S_OK)
        pClass->GetCLSID(&realclsid);
    else
        return hr;

    hr = E_FAIL;
    for (DWORD i=0; i<_unSerHeader.cIfs; i++)
    {
        //---------------------------------------------------------------
        //  Check if contained objects match requested class ID
        //  If so then it may or may not be unserialized.
        //---------------------------------------------------------------
        if (IsEqualIID(realclsid,_unSerHeader.pclsid[i]))
        {

            RpcTryExcept
                {
                    //-------------------------------------------------------
                    //  If size is zero for a matched object then it is an
                    //  interface that is no longer supported unless we
                    //  are told otherwise
                    //-------------------------------------------------------
                    if ((!_unSerHeader.pSizes[i]) && (!bZeroSizeOk))
                    {
                        hr = E_NOINTERFACE;
                        break;
                    }

                    //-------------------------------------------------------
                    //  Set position for serializer for unserializing
                    //-------------------------------------------------------
                    hr = S_OK;
                    hr = _pUnSer->SetPosition(pos);
		    if (FAILED(hr)) 
		    {
		       break;
		    }
                    //-------------------------------------------------------
                    //  If unserializing add it to our collection and make it
                    //  a child and return found object.
                    //-------------------------------------------------------
                    if (serializableIfsCollection[i] == NULL)
                    {
                        SetSerializableIfs(i, pClass);
                        pClassUsed = TRUE;
                        if (FAILED(hr = pClass->UnSerialize(_pUnSer)))
                        {
                            serializableIfsCollection[i] = NULL;
                            pClass->SetParent(NULL);
                            pClassUsed = FALSE;
                        }
                    }
                    else
                    {
                        hr = serializableIfsCollection[i]->UnSerialize(_pUnSer);
                    }

                    if (ppSer)
                        *ppSer = serializableIfsCollection[i];
                }

            RpcExcept(TRUE)
                {
                    hr = HRESULT_FROM_WIN32(RpcExceptionCode());
                }

            RpcEndExcept

                //
                // E_FAIL is not considered catastrophic by caller
                // But this is a catastrophic condition since we could
                // not unserialize.
                //
                if (hr == E_FAIL)
                    hr = E_UNEXPECTED;

            break;
        }

        //---------------------------------------------------------------
        //  Increment position for next one
        //---------------------------------------------------------------
        pos +=_unSerHeader.pSizes[i];
    }

    if (pClass != NULL && !pClassUsed)
    {
        ReturnClass (clsid, pClass);
    }

    return hr;
}


//-----------------------------------------------------------------------
//  Do things required to make a child
//-----------------------------------------------------------------------
inline void ActivationProperties::SetSerializableIfs(DWORD index,
                                                     SerializableProperty *pSer)
{
    serializableIfsCollection[index]= pSer;
    pSer->SetParent((ISerializableParent*) this);
    pSer->Added();
}

//-----------------------------------------------------------------------
//  Add a serializiable object to the collection
//-----------------------------------------------------------------------
inline void ActivationProperties::AddSerializableIfs(SerializableProperty *pSer)
{
    if (pSer->IsAdded())
        return;

    Win4Assert(_ifsIndex < MAX_ACTARRAY_SIZE);


    SetSerializableIfs(_ifsIndex, pSer);
    _ifsIndex++;
}

//---------------------------------------------------------------------------
//            Methods for ActivationPropertiesIn
//---------------------------------------------------------------------------
ActivationPropertiesIn::ActivationPropertiesIn()
{
    _customIndex = 0;
    _cCustomAct = 0;
    _actCLSID=CLSID_ActivationPropertiesIn;
    _refCount = 1;
    _pinst = NULL;
    _pPersist = NULL;
    _pContextInfo = NULL;
    _pServerLocationInfo = NULL;
    _pSecurityInfo = NULL;
    _pSpecialProperties = NULL;
    _pClassInfo = NULL;
    _customActList = NULL;
    _delegated = FALSE;
    _actOut.SetNotDelete();
    _pDip = NULL;
    _clientToken = NULL;
    _fComplusOnly = FALSE;
    _fUseSystemIdentity = FALSE;
    _dwInitialContext = 0;
}

ActivationPropertiesIn::~ActivationPropertiesIn()
{
    if (_pClassInfo)
    {
        _pClassInfo->Unlock();
        _pClassInfo->Release();
    }
}

//-----------------------------------------------------------------------
//  Methods from IUnknown
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::QueryInterface( REFIID riid, LPVOID* ppv)
{
    // USE CLSID_ActivationPropertiesIn to get at the real object
    // Note that this is a hidden contract to be used by COM only and
    // the object is not AddRef'd as an optimization
    if (IsEqualIID(riid, CLSID_ActivationPropertiesIn))
    {
        *ppv = (ActivationPropertiesIn*)this;
        return S_OK;
    }
    else
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IActivationPropertiesIn))
            *ppv = (IActivationPropertiesIn*)this;
        else
            if (IsEqualIID(riid, IID_IPrivActivationPropertiesIn))
                *ppv = (IPrivActivationPropertiesIn*)this;
            else
                if (IsEqualIID(riid, IID_IInitActivationPropertiesIn))
                    *ppv = (IInitActivationPropertiesIn*)this;
                else
                    if (IsEqualIID(riid, IID_IActivationStageInfo))
                        *ppv = (IActivationStageInfo*)this;
                    else
                        *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    return ActivationProperties::QueryInterface(riid, ppv);
}

ULONG ActivationPropertiesIn::AddRef(void)
{
    return ActivationProperties::AddRef();
}

ULONG ActivationPropertiesIn::Release(void)
{
    ULONG ret=ActivationProperties::Release();

    if (ret==0)
    {
        if (_toDelete)
            delete this;
        else
            if (_fDestruct)
                this->ActivationPropertiesIn::~ActivationPropertiesIn();
    }

    return ret;
}


//---------------------------------------------------------------------------
//      Methods from IInitActivationPropertiesIn
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesIn::SetClsctx (DWORD dwClsCtx)
{
    if (dwClsCtx && _pClassInfo)
    {
        DWORD dwAcceptableClsCtx;

        //Note:  hack for VB since it cannot specify CLSCTX_REMOTE_SERVER
        if (dwClsCtx & CLSCTX_LOCAL_SERVER)
            dwClsCtx |= CLSCTX_REMOTE_SERVER;

        //  Before we filter the specified class context by the class
        //  info, we remember the original class context.
        
        if (_dwInitialContext == 0)
            _dwInitialContext = dwClsCtx;

        //  Here we figure out the desired ClsCtx
        //  by anding the one in the catalog with the
        //  one requested by the user.
        //  If the GetClassContext()
        //  returns an error, we just go ahead and
        //  use the one the user passed.

        HRESULT hr = _pClassInfo->GetClassContext( (CLSCTX) dwClsCtx,
                                                   (CLSCTX*) &dwAcceptableClsCtx);

        if (SUCCEEDED(hr))
        {
            dwClsCtx &= (dwAcceptableClsCtx |
                         (CLSCTX_PS_DLL | CLSCTX_LOCAL_SERVER));

        }
    }

    InstantiationInfo* pii = GetInstantiationInfo();
    if (pii)
        return pii->SetClsctx(dwClsCtx);
    else
        return E_OUTOFMEMORY;

}

STDMETHODIMP ActivationPropertiesIn::SetActivationFlags (IN DWORD actvflags)
{
    InstantiationInfo* pii = GetInstantiationInfo();
    if (pii)
        return pii->SetActivationFlags(actvflags);
    else
        return E_OUTOFMEMORY;

    // The following code was the original implementation by CBiks.
    // This code is no longer executes because we delegate above.
    //
    /*
      HRESULT hr;
      hr = GetPropertyInfo(IID_IInstantiationInfo, (void**) &_pinst);
      if (SUCCEEDED(hr))
      {
      Win4Assert(_pinst != NULL);
      hr = _pinst->SetActivationFlags(actvflags);
      }
      return hr;
    */
}

STDMETHODIMP ActivationPropertiesIn::SetClassInfo (IUnknown* pUnkClassInfo)
{

    if (_pClassInfo)
    {
        _pClassInfo->Unlock();
        _pClassInfo->Release();
        _pClassInfo = NULL;
    }
        
	// useful and tests minimal usefulness of the object given
    HRESULT hr = pUnkClassInfo->QueryInterface(IID_IComClassInfo,(LPVOID*)&_pClassInfo);

    CLSID *pclsid;

    if (FAILED(hr))
        return hr;

    _pClassInfo->Lock();

    hr = _pClassInfo->GetConfiguredClsid(&pclsid);

    if(SUCCEEDED(hr))
    {
        InstantiationInfo* pii = GetInstantiationInfo();
        if (pii)
            pii->SetClsid(*pclsid);
        else
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr) && _dwInitialContext)
    {
        // Somebody has specifically set the class 
        // context on this actprops, but has now changed 
        // the IComClassInfo.  We need to change our
        // filtered CLSCTX to match the new ClassInfo.
        hr = SetClsctx(_dwInitialContext);
    }

    return hr;
}

STDMETHODIMP ActivationPropertiesIn::SetContextInfo (
    IContext* pClientContext,
    IContext* pPrototypeContext)
{
    HRESULT hr;

    ContextInfo *pactctx= GetContextInfo();
    Win4Assert(pactctx != NULL);

    hr = pactctx->SetClientContext(pClientContext);
    if (hr != S_OK)
        return hr;

    hr = pactctx->SetPrototypeContext(pPrototypeContext);
    return hr;
}

STDMETHODIMP ActivationPropertiesIn::SetConstructFromStorage (IStorage* pStorage)
{
    HRESULT hr;
    GetPersistInfo();
    Win4Assert(_pPersist != NULL);
    // This is an optimization for inproc marshalling. We know
    // that the storage pointer is the only one that requires
    // inproc serialization in the ActivationPropertiesIn object.
    _fInprocSerializationRequired = TRUE;
    return _pPersist->SetStorage(pStorage);
}

STDMETHODIMP ActivationPropertiesIn::SetConstructFromFile (WCHAR* wszFileName, DWORD dwMode)
{
    GetPersistInfo();
    Win4Assert(_pPersist != NULL);
    return _pPersist->SetFile(wszFileName, dwMode);
}

//---------------------------------------------------------------------------
//  Methods for IActivationPropertiesIn
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesIn::GetClsctx(OUT DWORD *pdwClsctx)
{
    InstantiationInfo* pii = GetInstantiationInfo();
    if (pii)
        return pii->GetClsctx(pdwClsctx);
    else
        return E_OUTOFMEMORY;
}


STDMETHODIMP ActivationPropertiesIn::AddRequestedIIDs(IN DWORD cIfs,
                                                      IN IID *pIID)
{
    InstantiationInfo* pii = GetInstantiationInfo();
    if (pii)
        return pii->AddRequestedIIDs(cIfs, pIID);
    else
        return E_OUTOFMEMORY;
}


STDMETHODIMP ActivationPropertiesIn::GetRequestedIIDs(OUT DWORD  *pcIfs,
                                                      OUT IID  **ppIID)
{
    InstantiationInfo* pii = GetInstantiationInfo();
    if (pii)    	
        return pii->GetRequestedIIDs(pcIfs, ppIID);
    else
        return E_OUTOFMEMORY;
}


STDMETHODIMP ActivationPropertiesIn::GetActivationID(OUT GUID  *pActivationID)
{
    *pActivationID = GUID_NULL;  // currently unused and not supported
    return E_NOTIMPL;
}

STDMETHODIMP ActivationPropertiesIn::GetActivationFlags(OUT DWORD *pactvflags)
{
    InstantiationInfo* pii = GetInstantiationInfo();
    if (pii)
        return pii->GetActivationFlags(pactvflags);
    else
        return E_OUTOFMEMORY;

    // The following code was the original implementation by CBiks.
    // This code is no longer executes because we delegate above.
    //
    /*
      HRESULT hr;
      hr = GetPropertyInfo(IID_IInstantiationInfo, (void**) &_pinst);
      if (SUCCEEDED(hr))
      {
      Win4Assert(_pinst != NULL);
      return _pinst->GetActivationFlags(pactvflags);
      }
      return hr;
    */
}

//-----------------------------------------------------------------------
//  The Following 3 routines should be called at the tail end of the
//  activation path to get activation properties for return
//  Only the first one is meant to be pubicly used
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::GetReturnActivationProperties(
    IN  IUnknown *pobj,
    OUT IActivationPropertiesOut **ppActOut)
{
    HRESULT hr;

    *ppActOut = NULL;

    //-------------------------------------------------------------------
    //  If no punk then don't return an out object
    //-------------------------------------------------------------------
    if (!pobj)
    {
        return E_FAIL;
    }

    if (_unSerialized)
        hr = GetPropertyInfo(IID_IInstantiationInfo, (void**) &_pinst);

    Win4Assert(_pinst != NULL);

    CLSID clsid;
    hr = _pinst->GetClsid(&clsid);
    Win4Assert(hr == S_OK);
    //-------------------------------------------------------------------
    //  Create Return Object
    //-------------------------------------------------------------------
    ActivationPropertiesOut *pout;
    if (!_unSerialized && !_toDelete && !IsBrokenRefCount(&clsid))
    {
        _actOut.Initialize();
        pout = &_actOut;
    }
    else
    {
        pout = new ActivationPropertiesOut(IsBrokenRefCount(&clsid));
        if (pout==NULL)
            return E_OUTOFMEMORY;
    }


    //-------------------------------------------------------------------
    //  Set the marshal and dest context flags for marshalling returns
    //-------------------------------------------------------------------
    pout->SetMarshalFlags(_marshalFlags);
    pout->SetDestCtx(_serHeader.destCtx);

    //-------------------------------------------------------------------
    //  Check to see if we are handling a persistent instance
    //  NOTE: cannot call GetPeristInfo because we need to QI to
    //        so that this will only cause this interface to exist
    //        if it was ever added to the properties object
    //-------------------------------------------------------------------
    if (_unSerialized)
        hr = GetPropertyInfo(IID_IInstanceInfo, (void**) &_pPersist);

    if (_pPersist)
    {
        hr = LoadPersistentObject(pobj, _pPersist);
        if (FAILED(hr))
        {
            pout->Release();
            return hr;
        }
    }

    //-------------------------------------------------------------------
    //  Set COMVERSION of client for marshalling
    //-------------------------------------------------------------------
    Win4Assert(_pinst != NULL);

    COMVERSION *pVersion;
    GetInstantiationInfo()->GetClientCOMVersion(&pVersion);
    pout->SetClientCOMVersion(*pVersion);

    //-------------------------------------------------------------------
    //      Get IIDs requested and set them for return
    //-------------------------------------------------------------------
    DWORD cifs;
    IID *pIID;
    hr = _pinst->GetRequestedIIDs(&cifs, &pIID);
    Win4Assert(hr==S_OK);

    hr = pout->SetObjectInterfaces(cifs, pIID, pobj);

   	*ppActOut = pout;

    CleanupLocalState();
    
    return hr;
}

STDMETHODIMP ActivationPropertiesIn::PrivGetReturnActivationProperties(
    OUT IPrivActivationPropertiesOut **ppActOut)
{
    //-------------------------------------------------------------------
    //  Create Return Object
    //-------------------------------------------------------------------
    ActivationPropertiesOut *pout = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */  );
    if (pout==NULL)
        return E_OUTOFMEMORY;

        //-------------------------------------------------------------------
        //  Set the marshal and dest context flags for marshalling returns
        //-------------------------------------------------------------------
    pout->SetMarshalFlags(_marshalFlags);
    pout->SetDestCtx(_serHeader.destCtx);

    *ppActOut = (IPrivActivationPropertiesOut*) pout;
    CleanupLocalState();
    return S_OK;
}

STDMETHODIMP ActivationPropertiesIn::GetReturnActivationProperties(
    ActivationPropertiesOut **ppActOut)
{
    //-------------------------------------------------------------------
    //  Create Return Object
    //-------------------------------------------------------------------
    *ppActOut = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */ );
    if (*ppActOut==NULL)
        return E_OUTOFMEMORY;


        //-------------------------------------------------------------------
        //  Set the marshal and dest context flags for marshalling returns
        //-------------------------------------------------------------------
    (*ppActOut)->SetMarshalFlags(_marshalFlags);
    (*ppActOut)->SetDestCtx(_serHeader.destCtx);

    CleanupLocalState();
    return S_OK;
}


//-----------------------------------------------------------------------
//  Following two routines are used delegate through a chain of custom
//  activators. When the chain is exhausted, the COM activator for the
//  current stage is invoked.
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::DelegateGetClassObject(
    OUT IActivationPropertiesOut  **pActPropsOut)
{
    Win4Assert(_customIndex <= _cCustomAct && (LONG) _customIndex >= 0);
    _delegated=TRUE;

    if ((_cCustomAct == 0) || (_customIndex == _cCustomAct))
    {
        ISystemActivator *pComAct = GetComActivatorForStage(_stage);
        return pComAct->GetClassObject(this, pActPropsOut);
    }

    _customIndex++;
    // Sajia - Support for partitions.
    // a) See if the activator supports IReplaceClassInfo
    // b) If yes, this is the partition activator.Delegate to it.
    //    If the partition activator switches the classinfo, 
    //    it returns ERROR_RETRY. It will not delegate in this case. 
    //    Otherwise, it simply delegates  down the chain.
    // c) If it returns ERROR_RETRY, call IReplaceClassInfo->GetClassInfo().
    //    Switch our class info and return ERROR_RETRY so our caller 
    //    knows to restart the activation chain.      
    //     
       
    IReplaceClassInfo *pReplaceClassInfo = NULL;
    HRESULT hr = _customActList[_customIndex-1]->QueryInterface(IID_IReplaceClassInfo, (void**)&pReplaceClassInfo);
    if (SUCCEEDED(hr)) 
    {
        Win4Assert(pReplaceClassInfo && "QI Error");
        // Assert that the partition activator is supported only
        // in the SCM and Server Process stage and must be the 
        // first activator in the stage.
        Win4Assert((_customIndex == 1) && (_stage == SERVER_MACHINE_STAGE || _stage == SERVER_PROCESS_STAGE || _stage == CLIENT_CONTEXT_STAGE));
        hr = _customActList[_customIndex-1]->GetClassObject(this, pActPropsOut);
        if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
        {
            CLSID clsid;
            IUnknown     *pClassInfo;
            hr = GetClsid(&clsid);
            Win4Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) 
            {
                hr = pReplaceClassInfo->GetClassInfo(clsid, IID_IUnknown, (void**)&pClassInfo);
                Win4Assert(SUCCEEDED(hr));
                if (SUCCEEDED(hr)) 
                {
                    hr = SetClassInfo(pClassInfo);
                    Win4Assert(SUCCEEDED(hr));
                    pClassInfo->Release();
                    if (SUCCEEDED(hr)) 
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_RETRY);
                    }
                }
            }
        }
        pReplaceClassInfo->Release();
        return hr;
    }
    else
        return _customActList[_customIndex-1]->GetClassObject(this, pActPropsOut);
}

STDMETHODIMP ActivationPropertiesIn::DelegateCreateInstance(
    IN IUnknown  *pUnkOuter,
    OUT IActivationPropertiesOut  **ppActPropsOut)
{
    Win4Assert(_customIndex <= _cCustomAct && (LONG) _customIndex >= 0);
    _delegated=TRUE;

    if ((_cCustomAct == 0) || (_customIndex == _cCustomAct))
    {
        ISystemActivator *pComAct = GetComActivatorForStage(_stage);
        return pComAct->CreateInstance(pUnkOuter, this, ppActPropsOut);
    }

    _customIndex++;
    // Sajia - Support for partitions.
    // a) See if the activator supports IReplaceClassInfo
    // b) If yes, this is the partition activator.Delegate to it.
    //    If the partition activator switches the classinfo, 
    //    it returns ERROR_RETRY. It will not delegate in this case. 
    //    Otherwise, it simply delegates  down the chain.
    // c) If it returns ERROR_RETRY, call IReplaceClassInfo->GetClassInfo().
    //    Switch our class info and return ERROR_RETRY so our caller 
    //    knows to restart the activation chain.      
    //     
       
    IReplaceClassInfo *pReplaceClassInfo = NULL;
    HRESULT hr = _customActList[_customIndex-1]->QueryInterface(IID_IReplaceClassInfo, (void**)&pReplaceClassInfo);
    if (SUCCEEDED(hr)) 
    {
        Win4Assert(pReplaceClassInfo && "QI Error");
        // Assert that the partition activator is supported only
        // in the SCM and Server Process stage and must be the 
        // first activator in the stage.
        Win4Assert((_customIndex == 1) && (_stage == SERVER_MACHINE_STAGE || _stage == SERVER_PROCESS_STAGE || _stage == CLIENT_CONTEXT_STAGE));
        hr = _customActList[_customIndex-1]->CreateInstance(pUnkOuter, this, ppActPropsOut);
        if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
        {
            CLSID clsid;
            IUnknown     *pClassInfo;
            hr = GetClsid(&clsid);
            Win4Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) 
            {
                hr = pReplaceClassInfo->GetClassInfo(clsid, IID_IUnknown, (void**)&pClassInfo);
                Win4Assert(SUCCEEDED(hr));
                if (SUCCEEDED(hr)) 
                {
                    hr = SetClassInfo(pClassInfo);
                    Win4Assert(SUCCEEDED(hr));
                    pClassInfo->Release();
                    if (SUCCEEDED(hr)) 
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_RETRY);
                    }
                }
            }
        }
        pReplaceClassInfo->Release();
        return hr;
    }
    else
        return _customActList[_customIndex-1]->CreateInstance(pUnkOuter, this, ppActPropsOut);
}

//-----------------------------------------------------------------------
// Note that this function could return a NULL Class Factory if an
// intercepting custom activator returns an object.
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::DelegateCIAndGetCF(
    IN IUnknown  *pUnkOuter,
    OUT IActivationPropertiesOut  **ppActPropsOut,
    OUT IClassFactory **ppCF)
{
    if (_stage != SERVER_CONTEXT_STAGE)
        return E_UNEXPECTED;

    HRESULT hr = DelegateCreateInstance(pUnkOuter, ppActPropsOut);

    if (FAILED(hr))
        return hr;

    ActivationPropertiesOut *pActOut;
    hr = (*ppActPropsOut)->QueryInterface(CLSID_ActivationPropertiesOut,
                                          (void**) &pActOut);
    Win4Assert(SUCCEEDED(hr));

    *ppCF = pActOut->GetCF();

    return S_OK;
}


//-----------------------------------------------------------------------
//  Instantiate classes supported by this interfaces given an IID
//-----------------------------------------------------------------------
HRESULT ActivationPropertiesIn::GetClass(REFIID iid,
                                         SerializableProperty **ppSer,
                                         BOOL forQI,
                                         BOOL *pbZeroSizeOk)
{
    if (pbZeroSizeOk)
        *pbZeroSizeOk = FALSE;

    if ((iid == IID_IActivationSecurityInfo) || (iid == IID_ILegacyInfo))
        *ppSer = &_securityInfo;
    else
        if (iid == IID_IServerLocationInfo)
            *ppSer = &_serverLocationInfo;
        else
            if (iid == IID_IInstantiationInfo)
                *ppSer = &_instantiationInfo;
            else
                if (iid == IID_IActivationContextInfo || iid == IID_IPrivActivationContextInfo)
                    *ppSer = &_contextInfo;
                else
                    if ((!(_delegated && forQI)) && (iid == IID_IInstanceInfo))
                        *ppSer = &_instanceInfo;
                    else
                        if (iid == IID_IScmRequestInfo)
                            *ppSer = &_scmRequestInfo;
                        else
                            if (iid == IID_ISpecialSystemProperties)
                            {
                                *ppSer = &_specialProperties;
                            }
                            else
                                if (iid == IID_IOpaqueDataInfo)
                                {
                                    *ppSer = new OpaqueDataInfo();
                                    if(*ppSer == NULL)
                                    	return E_OUTOFMEMORY;
                                    
                                    if (pbZeroSizeOk)
                                        *pbZeroSizeOk = TRUE;
                                }
                                else
                                    return E_NOINTERFACE;

    return S_OK;
}

HRESULT ActivationProperties::ReturnClass(REFIID iid, SerializableProperty *pSer)
{
    if (iid == IID_IOpaqueDataInfo)
    {
        delete (OpaqueDataInfo*) pSer;
        return S_OK;
    }

    return S_FALSE;
}

//---------------------------------------------------------------------------
//  Methods from IActivationStageInfo
//---------------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::SetStageAndIndex(ACTIVATION_STAGE stage,
                                                      int index)
{
    _stage = stage;
    _customIndex = index;
    _cCustomAct = 0;
    _customActList = NULL;

    HRESULT hr = E_UNEXPECTED;

    // JSimmons -- 6/30/99 added this assert:
    Win4Assert(_pClassInfo && "SetStageAndIndex called and _pClassInfo is not set");

    if (_pClassInfo)
    {
        hr = _pClassInfo->GetCustomActivatorCount(stage,&_cCustomAct);
        if (SUCCEEDED (hr) && _cCustomAct)
        {
            hr = _pClassInfo->GetCustomActivators(stage,&_customActList);
            if (FAILED (hr))
            {
                _cCustomAct = 0;
                _customActList = NULL;
            }
        }
    }

    return hr;
}

STDMETHODIMP ActivationPropertiesIn::UnmarshalInterface(IStream *pStm,REFIID riid,void **ppv)
{
    if (!ppv)
        return E_POINTER;
    
    *ppv = NULL;
    HRESULT hr = ActivationProperties::UnmarshalInterface(pStm, riid,ppv);

    if (hr != S_OK)
        return hr;

    CLSID clsid;

    hr = GetClsid(&clsid);		// this will cause unmarshal of the InstantiationInfo, to get us the Clsid.
    if (FAILED(hr))	
        goto Cleanup;

    Win4Assert(clsid != GUID_NULL);	// sanity check in checked builds

    hr = GetClassInfoFromClsid(clsid, &_pClassInfo);

    if ((hr == S_OK) && _pClassInfo)
    {
        _pClassInfo->Lock();
    }

    _delegated=TRUE; //assume unmarshalling imples that delegation happened

Cleanup:
	
    if (FAILED(hr) && (*ppv))
    {
    	IUnknown* pUnk = (IUnknown*)*ppv;
        pUnk->Release();
        *ppv = NULL;
    }

    return hr;
}


//---------------------------------------------------------------------------
//            Methods for ActivationPropertiesOut
//---------------------------------------------------------------------------
ActivationPropertiesOut::ActivationPropertiesOut(BOOL fBrokenRefCount)
    : _outSer(fBrokenRefCount)
{
    _pOutSer=0;
    _refCount = 1;
    _actCLSID=CLSID_ActivationPropertiesOut;
    _fBrokenRefCount = fBrokenRefCount;
    _fInprocSerializationRequired = TRUE;
}

ActivationPropertiesOut::~ActivationPropertiesOut()
{
}

//---------------------------------------------------------------------------
//  Methods for IUnknown
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesOut::QueryInterface( REFIID riid, LPVOID* ppv)
{
    // USE CLSID_ActivationPropertiesOut to get at the real object
    // Note that this is a hidden contract to be used by COM only and
    // the object is not AddRef'd as an optimization
    if (IsEqualIID(riid, CLSID_ActivationPropertiesOut))
    {
        *ppv = (ActivationPropertiesOut*)this;
        return S_OK;
    }
    else
        if (IsEqualIID(riid, IID_IUnknown))
            *ppv = (IActivationPropertiesOut*)this;
        else
            if (IsEqualIID(riid, IID_IPrivActivationPropertiesOut))
                *ppv = (IPrivActivationPropertiesOut*)this;
            else
                if (IsEqualIID(riid, IID_IActivationPropertiesOut))
                    *ppv = (IActivationPropertiesOut*)this;
                else
                    *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    return ActivationProperties::QueryInterface(riid, ppv);
}

ULONG ActivationPropertiesOut::AddRef(void)
{
    return ActivationProperties::AddRef();
}

ULONG ActivationPropertiesOut::Release(void)
{
    ULONG ret=ActivationProperties::Release();

    if (ret==0)
    {
        if (_toDelete)
            delete this;
        else
            if (_fDestruct)
                this->ActivationPropertiesOut::~ActivationPropertiesOut();
    }

    return ret;
}

STDMETHODIMP ActivationPropertiesOut::GetActivationID(OUT GUID  *pActivationID)
{
    *pActivationID = GUID_NULL; // currently unused and not supported
    return E_NOTIMPL;
}


//-----------------------------------------------------------------------
//  Set Marshalled interface data that are results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::SetMarshalledResults(
    IN DWORD cIfs,
    IN IID *pIID,
    IN HRESULT *pHr,
    IN MInterfacePointer **ppIntfData)
{
    if (!_pOutSer)
    {
        _pOutSer = &_outSer;
        AddSerializableIfs((SerializableProperty*) _pOutSer);
    }

    _pOutSer->_info.cIfs = cIfs;

    //
    // Allocate new storage and copy parameters
    //
    _pOutSer->_info.piid = (IID*) ActMemAlloc(sizeof(IID)*cIfs);
    if (_pOutSer->_info.piid == NULL)
    {
       _pOutSer->_info.cIfs=0;
       return E_OUTOFMEMORY;
    }
    _pOutSer->_info.ppIntfData = (MInterfacePointer**)
        ActMemAlloc(sizeof(MInterfacePointer*)*cIfs);
    if (_pOutSer->_info.ppIntfData == NULL)
    {
       _pOutSer->_info.cIfs=0;
       ActMemFree(_pOutSer->_info.piid);
       _pOutSer->_info.piid = NULL;
       return E_OUTOFMEMORY;
    }
    _pOutSer->_info.phresults = (HRESULT*) ActMemAlloc(sizeof(HRESULT)*cIfs);
    if (_pOutSer->_info.phresults == NULL)
    {
       _pOutSer->_info.cIfs=0;
       ActMemFree(_pOutSer->_info.piid);
       _pOutSer->_info.piid = NULL;
       ActMemFree(_pOutSer->_info.ppIntfData);
       _pOutSer->_info.ppIntfData = NULL;
       return E_OUTOFMEMORY;
    }
    for (DWORD i=0; i< cIfs; i++)
    {
        _pOutSer->_info.piid[i] = pIID[i];
        if (ppIntfData[i])
        {
            //
            // Use stream cloning to copy marshalled stuff
            //
            ActivationStream strm((InterfaceData*) ppIntfData[i]);
            ActivationStream *newStrm;
            newStrm = strm.Clone();
            if (newStrm == NULL)
	    {
	       _pOutSer->_info.cIfs=0;
	       ActMemFree(_pOutSer->_info.piid);
	       _pOutSer->_info.piid = NULL;
	       ActMemFree(_pOutSer->_info.ppIntfData);
	       _pOutSer->_info.ppIntfData = NULL;
	       ActMemFree(_pOutSer->_info.phresults);
	       _pOutSer->_info.phresults = NULL;
	       return E_OUTOFMEMORY;
	    }
            newStrm->AssignSerializedInterface(
                (InterfaceData**)&_pOutSer->_info.ppIntfData[i]);
            newStrm->Release();
        }
        else
            _pOutSer->_info.ppIntfData[i] = NULL;

        _pOutSer->_info.phresults[i] = pHr[i];
    }

    return S_OK;
}

//-----------------------------------------------------------------------
//  Get results of activation in marshalled form
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::GetMarshalledResults(OUT DWORD *pcIfs,
                                                           OUT IID **ppIID,
                                                           OUT HRESULT **ppHr,
                                                           OUT MInterfacePointer ***pppIntfData)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if ((!_pOutSer) && (_unSerialized))
    {
        if (!SUCCEEDED(hr = UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                                (SerializableProperty**)&_pOutSer)))
            return hr;

    }

    Win4Assert(_pOutSer != NULL);

    //-------------------------------------------------------------------
    //  If user passed holders, copy into them otherwise allocate
    //-------------------------------------------------------------------

    //-------------------------------------------------------------------
    //  First do IIDs
    //-------------------------------------------------------------------
    *pcIfs = _pOutSer->_info.cIfs;
    DWORD i;
    if (*ppIID == NULL)
        *ppIID = _pOutSer->_info.piid;
    else
    {
        IID *pIID = *ppIID;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
            pIID[i] = _pOutSer->_info.piid[i];
    }

    //-------------------------------------------------------------------
    //  Do Marshalled results
    //-------------------------------------------------------------------
    if (*pppIntfData == NULL)
        *pppIntfData = _pOutSer->_info.ppIntfData;
    else
    {
        MInterfacePointer **ppIntfData = *pppIntfData;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
        {
            ActivationStream strm((InterfaceData*)_pOutSer->_info.ppIntfData[i]);
            ActivationStream *newStrm;
            newStrm = strm.Clone();
            if (newStrm==NULL)
                return E_OUTOFMEMORY;
            newStrm->AssignSerializedInterface((InterfaceData**)&ppIntfData[i]);
            newStrm->Release();
        }
    }

    //-------------------------------------------------------------------
    //  Set error codes and return appropriate one as result
    //  Call suceeds if at least one interface exists
    //-------------------------------------------------------------------
    HRESULT rethr = E_NOINTERFACE;
    if (*ppHr == NULL)
    {
        *ppHr = _pOutSer->_info.phresults;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
            if (_pOutSer->_info.phresults[i] == S_OK)
            {
                rethr = S_OK;
                break;
            }

    }
    else
    {
        HRESULT *phr = *ppHr;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
        {
            phr[i] = _pOutSer->_info.phresults[i];
            if (phr[i] == S_OK)
                rethr = S_OK;
        }
    }

    return rethr;
}

//-----------------------------------------------------------------------
//  Set results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::SetObjectInterfaces(
    IN DWORD  cIfs,
    IN IID *pIID,
    IN IUnknown *pUnk)
{
    if (!cIfs)
        return E_FAIL;

    if (!_pOutSer)
    {
        _pOutSer = &_outSer;
        _pOutSer->_pClientCOMVersion = &_clientCOMVersion;
        AddSerializableIfs((SerializableProperty*) _pOutSer);
    }

    _pOutSer->_info.cIfs = cIfs;
    if (cIfs > MAX_ACTARRAY_SIZE)
    {
        _pOutSer->_info.piid = (IID*) ActMemAlloc(sizeof(IID)*cIfs);
        if (_pOutSer->_info.piid == NULL)
            return E_OUTOFMEMORY;
    }
    else
        _pOutSer->_info.piid = _pOutSer->_pIIDs;
    for (DWORD i=0; i< cIfs; i++)
        _pOutSer->_info.piid[i] = pIID[i];
    _pOutSer->_pUnk = pUnk;


    if (!_fBrokenRefCount)
    {
        pUnk->AddRef();
    }
    _pOutSer->_info.phresults = NULL;

    return S_OK;
}

//-----------------------------------------------------------------------
//  Get results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::GetObjectInterface(
    IN REFIID riid,
    IN DWORD actvflags,
    OUT void **ppv)
{
    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if (!_pOutSer)
    {
        if (_unSerialized)
        {
            HRESULT rethr;
            rethr = UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                        (SerializableProperty**)&_pOutSer);
            if (FAILED(rethr))
                return rethr;
        }
        else
            return E_UNEXPECTED; // We must have a _pOutSer
    }

    Win4Assert(_pOutSer);


    IUnknown *punk = NULL;
    *ppv = NULL;
    BOOL fCountedPunk = FALSE;    // Indicates whether we hold a reference
    // to punk and must release it.

    if (!_pOutSer->_ppvObj)
    {
        Win4Assert(_pOutSer->_pUnk!=NULL);
        punk = _pOutSer->_pUnk;
    }
    else
        for (DWORD i=0; i<_pOutSer->_info.cIfs; i++)
        {
            if (IsEqualIID(riid, _pOutSer->_info.piid[i]))
            {
                _pOutSer->UnmarshalAtIndex(i);

                if (_pOutSer->_info.phresults[i] == S_OK)
                {
                    _fInprocSerializationRequired = TRUE;
                    punk = (IUnknown*) _pOutSer->_ppvObj[i];
                    *ppv = punk;
                    punk->AddRef();
                    return S_OK;
                }
            }
        }

    if (!punk)
    {
        if (!IsEqualIID(IID_IUnknown, riid))
        {
            // If we get a punk back here, it will be counted, so we
            // must release it.

            HRESULT hr = GetObjectInterface(IID_IUnknown,
                                            NULL,
                                            (void**) &punk);
            if (FAILED(hr))
                punk = NULL;
            else
                fCountedPunk = TRUE;
        }
        else
            for (DWORD i=0; i<_pOutSer->_info.cIfs; i++)
            {
                _pOutSer->UnmarshalAtIndex(i);

                if (_pOutSer->_info.phresults[i] == S_OK)
                {
                    _fInprocSerializationRequired = TRUE;
                    punk = (IUnknown*) _pOutSer->_ppvObj[i];
                }
            }
    }

    if (punk)
    {
        HRESULT hr = punk->QueryInterface(riid, ppv);
        
        // If we hold a reference on the punk, release it.
        if (fCountedPunk)
            punk->Release();

        return hr;
    }
    else
        return E_NOINTERFACE;
}

//-----------------------------------------------------------------------
//  Get results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::GetObjectInterfaces(
    IN DWORD  cIfs,
    IN DWORD actvflags,
    IN MULTI_QI  *pMultiQi)
{
    HRESULT rethr;

    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if (!_pOutSer)
    {
        if (_unSerialized)
        {
            rethr = UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                        (SerializableProperty**)&_pOutSer);
            if (FAILED(rethr))
                return rethr;
        }
        else
            return E_UNEXPECTED; // We must have a _pOutSer
    }

    Win4Assert(_pOutSer);

    rethr = E_NOINTERFACE;
    //-------------------------------------------------------------------
    //  Either Interfaces already unmarshalled or marshalling never
    //  took place.
    //  Set error codes and return appropriate one as result
    //-------------------------------------------------------------------
    for (DWORD i=0; i<cIfs; i++)
    {
        //---------------------------------------------------------------
        //  If no umarshalled result then we have to have a pUnk
        //---------------------------------------------------------------
        if (!_pOutSer->_ppvObj)
        {
            Win4Assert(_pOutSer->_pUnk!=NULL);

            if (_fBrokenRefCount && (i == 0))
            {

                pMultiQi[i].pItf = _pOutSer->_pUnk;
                pMultiQi[i].hr = S_OK;
            }
            else
            {
                pMultiQi[i].hr =
                    _pOutSer->_pUnk->QueryInterface(*pMultiQi[i].pIID,
                                                    (void**) &pMultiQi[i].pItf);
            }
        }
        else
            //---------------------------------------------------------------
            //  If IIDs don't match then we're inefficient(order n-square)
            //  anyway so call to get a single interface.
            //---------------------------------------------------------------
            if ((_pOutSer->_info.piid[i] != *pMultiQi[i].pIID)||
                (_pOutSer->_info.ppIntfData[i] == NULL))
            {
                pMultiQi[i].hr = GetObjectInterface(*pMultiQi[i].pIID,
                                                    actvflags,
                                                    (void**)&pMultiQi[i].pItf);

            }
            else
                //---------------------------------------------------------------
                //  Common case where we are returning originally requested
                //  IIDs after unmarshalling.
                //---------------------------------------------------------------
            {
                Win4Assert(!_fBrokenRefCount);
                Win4Assert(_outSer._info.ppIntfData != NULL);
                _pOutSer->UnmarshalAtIndex(i);
                _fInprocSerializationRequired = TRUE;
                pMultiQi[i].pItf = (IUnknown*) _pOutSer->_ppvObj[i];
                pMultiQi[i].hr = _pOutSer->_info.phresults[i];
                if (pMultiQi[i].hr == S_OK)
                    ((IUnknown*)_pOutSer->_ppvObj[i])->AddRef();
            }

        //---------------------------------------------------------------
        //  Call suceeds if at least one interface exists
        //---------------------------------------------------------------
        if (rethr != S_OK)
            rethr = pMultiQi[i].hr;
    }

    return rethr;
}

//-----------------------------------------------------------------------
//  Removes requested IIDs: to be used by custom activators
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::RemoveRequestedIIDs(
    IN DWORD cIfs,
    IN IID  *pIID)
{
    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if (!_pOutSer)
    {
        if (!_unSerialized)
            return E_INVALIDARG;

        if (UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                (SerializableProperty**)&_pOutSer)!= S_OK)
            return E_FAIL;

        Win4Assert(_pOutSer != NULL);
    }

    //
    //Assume that we never remove originally requested ones
    //
    if ((cIfs > _pOutSer->_info.cIfs) || (cIfs == 0))
        return E_INVALIDARG;

    LONG i,j;
    DWORD dec = 0;

        //
        //First try to do it efficiently assuming
        //that we always added to end
        //
    for (i=_pOutSer->_info.cIfs-1; i>=0 && cIfs; i--)
    {
        if (_pOutSer->_info.piid[i]==pIID[cIfs-1])
        {
            //
            //If we still have interface data then make sure
            //that we give to duplicate entry if it exists and does'nt
            //have one. Otherwise free it
            //
            if (_pOutSer->_info.ppIntfData)
            {
                if (_pOutSer->_info.ppIntfData[i])
                {
                    for (j=0;j<i;j++)
                    {
                        if ((_pOutSer->_info.piid[i]==_pOutSer->_info.piid[j]) &&
                            (_pOutSer->_info.ppIntfData[j] == NULL))
                        {
                            _pOutSer->_info.ppIntfData[j] =
                                _pOutSer->_info.ppIntfData[i];
                            _pOutSer->_info.ppIntfData[i] = NULL;
                            _pOutSer->_info.phresults[j] =
                                _pOutSer->_info.phresults[i];
                            Win4Assert(_pOutSer->_info.phresults[j]==S_OK);
                            if (_pOutSer->_ppvObj && _pOutSer->_ppvObj[j])
                            {
                                ((IUnknown*)_pOutSer->_ppvObj[j])->Release();
                                _pOutSer->_ppvObj[j] = NULL;
                            }

                        }
                    }

                    // If we did'nt give it away release it
                    if (_pOutSer->_info.ppIntfData[i])
                    {
                        ReleaseIFD(_pOutSer->_info.ppIntfData[i]);
                        ActMemFree(_pOutSer->_info.ppIntfData[i]);
                        _pOutSer->_info.ppIntfData[i] = NULL;
                    }
                }
                else
                    // Release Unmarshalled object
                    if (_pOutSer->_ppvObj && _pOutSer->_ppvObj[i])
                    {
                        ((IUnknown*)_pOutSer->_ppvObj[i])->Release();
                        _pOutSer->_ppvObj[i] = NULL;
                    }
            }
            _pOutSer->_info.cIfs--;
            cIfs--;
            dec++;
        }
        else
            break;
    }

    //
    //Do inefficiently if we still have leftover IIDs
    //
    if (cIfs)
    {
        IID *newIIDs=NULL;
        MInterfacePointer **newIFD=NULL;
        void **newppv = NULL;
        HRESULT *newhr=NULL;

        BOOL *pFound = (BOOL*) ActMemAlloc(sizeof(BOOL) * cIfs);
        if (pFound == NULL)
            return E_OUTOFMEMORY;

        DWORD newLen = _pOutSer->_info.cIfs-cIfs;

        //
        // Allocate storage for new stuff
        //
        if (newLen)
        {
            newIIDs =  (IID*) ActMemAlloc(sizeof(IID)*newLen);
            if (_marshalState == UNMARSHALLED)
            {
                newIFD = (MInterfacePointer**)
                    ActMemAlloc(sizeof(MInterfacePointer*)*
                                newLen);
                newppv = (void**) ActMemAlloc(sizeof(IUnknown*)*newLen);

                newhr = (HRESULT*) ActMemAlloc(sizeof(HRESULT)*newLen);

                if ((newIIDs==NULL) || (newppv==NULL) ||
                    (newIFD==NULL) || (newhr == NULL))
                {
                    ActMemFree(newppv);
                    ActMemFree(newIIDs);
                    ActMemFree(newIFD);
                    ActMemFree(newhr);
		    ActMemFree(pFound);
                    return E_OUTOFMEMORY;
                }
            }
        }



        for (i=0;i<(LONG)cIfs;i++)
            pFound[i] = FALSE;

        DWORD newIndex=0;
        //
        // Loop trying to establish new arrays
        //
        for (i=0;i<(LONG)_pOutSer->_info.cIfs;i++)
        {
            BOOL found=FALSE;
            for (j=0;j<(LONG)cIfs;j++)
                if (!pFound[j])
                {
                    if (_pOutSer->_info.piid[i] == pIID[j])
                    {
                        found = TRUE;
                        pFound[j] = TRUE;
                        if ((_marshalState == UNMARSHALLED) &&
                            (SUCCEEDED(_pOutSer->_info.phresults[i])))
                        {
                            if (_pOutSer->_info.ppIntfData[i])
                            {
                                ReleaseIFD(_pOutSer->_info.ppIntfData[i]);
                                ActMemFree(_pOutSer->_info.ppIntfData[i]);
                                _pOutSer->_info.ppIntfData[i] = NULL;
                            }
                            else
                                if (_pOutSer->_ppvObj && _pOutSer->_ppvObj[i])
                                {
                                    ((IUnknown*)_pOutSer->_ppvObj[i])->Release();
                                    _pOutSer->_ppvObj[i] = NULL;
                                }
                        }
                        break;
                    }
                }

            // If this was'nt part of passed in array we need to
            // keep it
            if ((!found) && newLen)
            {
                newIIDs[newIndex] = _pOutSer->_info.piid[i];

                if (_marshalState == UNMARSHALLED)
                {
                    newIFD[newIndex] = _pOutSer->_info.ppIntfData[i];
                    newppv[newIndex] = _pOutSer->_ppvObj[i];
                    newhr[newIndex] =  _pOutSer->_info.phresults[i];
                }

                newIndex++;
            }
        }

        Win4Assert(newIndex == newLen);

        ActMemFree(pFound);

        //
        //Free old ones and set new ones
        //
        _pOutSer->_info.cIfs = newLen;
        if (_pOutSer->_info.piid != _pOutSer->_pIIDs)
            ActMemFree(_pOutSer->_info.piid);
        _pOutSer->_info.piid = newIIDs;
        if (_marshalState == UNMARSHALLED)
        {
            ActMemFree(_pOutSer->_info.ppIntfData);
            _pOutSer->_info.ppIntfData = newIFD;
            ActMemFree(_pOutSer->_ppvObj);
            _pOutSer->_ppvObj = newppv;
            ActMemFree(_pOutSer->_info.phresults);
            _pOutSer->_info.phresults = newhr;
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------
//  Get classes supported by this interfaces given an IID
//-----------------------------------------------------------------------
HRESULT ActivationPropertiesOut::GetClass(REFIID iid,
                                          SerializableProperty **ppSer,
                                          BOOL forQI,
                                          BOOL *pbZeroSizeOk)
{

    if (pbZeroSizeOk)
        *pbZeroSizeOk = FALSE;

    if (iid == CLSID_ActivationPropertiesOut)
        *ppSer = &_outSer;
    else
        if (iid == IID_IScmReplyInfo)
            *ppSer = &_scmReplyInfo;
        else
            if (iid == IID_IOpaqueDataInfo)
            {
                *ppSer = new OpaqueDataInfo();
                if(*ppSer == NULL)
                	return E_OUTOFMEMORY;
                
                if (pbZeroSizeOk)
                    *pbZeroSizeOk = TRUE;
            }
            else
                return E_NOINTERFACE;

    return S_OK;
}



//---------------------------------------------------------------------------
//   Methods for ActivationPropertiesOut::OutSerializer
//---------------------------------------------------------------------------

ActivationPropertiesOut::OutSerializer::OutSerializer(BOOL fBrokenRefCount)
{
    memset(&_info, 0, sizeof(PropsOutInfo));
    _ppvObj = NULL;
    _unSerialized=FALSE;
    _pUnk = NULL;
    _parent = NULL;
    _fBrokenRefCount = fBrokenRefCount;
    _fToReleaseIFD = FALSE;
}

ActivationPropertiesOut::OutSerializer::~OutSerializer()
{
    //-------------------------------------------------------------------
    //  Free marshalled data
    //-------------------------------------------------------------------
    if (_info.ppIntfData)
    {
        for (DWORD i=0;i<_info.cIfs;i++)
        {
            if ((_info.ppIntfData[i]) && (_fToReleaseIFD))
                ReleaseIFD(_info.ppIntfData[i]);
            ActMemFree(_info.ppIntfData[i]);
            if (_ppvObj && _ppvObj[i])
                ((IUnknown*)_ppvObj[i])->Release();
        }
        ActMemFree(_info.ppIntfData);
        ActMemFree(_ppvObj);
    }

    ActMemFree(_info.phresults);

    if (_info.piid != _pIIDs)
        ActMemFree(_info.piid);

    if (_pUnk && !_fBrokenRefCount)
    {
        _pUnk->Release();
    }
}

inline void ActivationPropertiesOut::OutSerializer::UnmarshalAtIndex(DWORD index)
{
    InitMarshalling();

    Win4Assert(_info.ppIntfData != NULL);
    if (_info.ppIntfData[index] && (_info.phresults[index] == S_OK))
    {
        ActivationStream strm((InterfaceData*)_info.ppIntfData[index]);
        if (IsInterfaceImplementedByProxy(_info.piid[index]))
        {
            IUnknown* pUnk = NULL;

            HRESULT hr;

            if (pfnCoUnmarshalInterface)
            {
                hr = pfnCoUnmarshalInterface(&strm, IID_IUnknown, (void**) &pUnk);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                _info.phresults[index] = pUnk->QueryInterface (_info.piid[index], &_ppvObj[index]);
                pUnk->Release();
            }
            else
            {
                _info.phresults[index] = hr;
                _ppvObj[index] = (void*) pUnk;
            }
        }
        else
        {
            if (pfnCoUnmarshalInterface)
            {
                _info.phresults[index] = pfnCoUnmarshalInterface(&strm, _info.piid[index], &_ppvObj[index]);
            }
            else
            {
                _info.phresults[index] = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }
        }

        if (_info.phresults[index] != S_OK)
            _ppvObj[index] = NULL;

        ActMemFree(_info.ppIntfData[index]);
        _info.ppIntfData[index] = NULL;
    }
}


//---------------------------------------------------------------------------
//   Methods from IUnknown
//---------------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::OutSerializer::QueryInterface( REFIID riid, LPVOID* ppvObj)
{
    if (_parent)
        return _parent->QueryInterface(riid, ppvObj);
    else
        return SerializableQueryInterface(riid, ppvObj);
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG ActivationPropertiesOut::OutSerializer::AddRef(void)
{
    if (_parent)
        return _parent->AddRef();

    return 1;
}

ULONG ActivationPropertiesOut::OutSerializer::Release(void)
{
    if (_parent)
        return _parent->Release();

    return 0;
}


//---------------------------------------------------------------------------
//   Methods from ISerializable
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesOut::OutSerializer::Serialize(void *pv)
{
    HRESULT hr;
    Serializer *pSer = (Serializer*) pv;

    //-------------------------------------------------------------------
    //  Encode this object
    //-------------------------------------------------------------------
    handle_t handle = NULL;
    hr = pSer->GetSerializationHandle((void*) &handle);
    PropsOutInfo_Encode(handle, &_info);

    return S_OK;
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::UnSerialize(void *pv)
{
    Serializer *pSer = (Serializer*) pv;
    //-------------------------------------------------------------------
    //  If not unserialized then read header
    //-------------------------------------------------------------------
    if (!_unSerialized)
    {
        handle_t handle = NULL;
        pSer->GetSerializationHandle((void*) &handle);
        if (_info.piid)
            ActMemFree(_info.piid);
        _info.piid = 0;
        if (_info.phresults)
            ActMemFree(_info.phresults);
        _info.phresults = 0;
        PropsOutInfo_Decode(handle, &_info);
        if (_info.ppIntfData)
        {
            Win4Assert(_info.cIfs != 0);
            _ppvObj = (void**) ActMemAlloc(sizeof(IUnknown*)*_info.cIfs);
            if (_ppvObj == NULL)
                return E_OUTOFMEMORY;
            for (DWORD i=0; i<_info.cIfs; i++)
                _ppvObj[i] = NULL;
        }
        else
            _ppvObj = NULL;
    }

    return S_OK;
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::GetSize(IN void *pv, OUT DWORD *pdwSize)
{
    Serializer *pSer = (Serializer*) pv;
    //-------------------------------------------------------------------
    //  Need to marshal interfaces to calculate size
    //-------------------------------------------------------------------
    DWORD dwMaxDestCtx;
    BOOL firstMarshal;
    DWORD i;
    HRESULT hr;

    InitMarshalling();

    pSer->GetMaxDestCtx(&dwMaxDestCtx);

    if (!_info.cIfs)
        goto EncodeOut;


    if (_info.ppIntfData == NULL)
    {
        _info.ppIntfData = (MInterfacePointer**)
            ActMemAlloc(sizeof(MInterfacePointer*)
                        * _info.cIfs);

        if (_info.ppIntfData == NULL)
            return E_OUTOFMEMORY;
        for (DWORD i=0; i< _info.cIfs; i++)
            _info.ppIntfData[i] = NULL;

        Win4Assert(_info.phresults == NULL);

        _info.phresults = (HRESULT *)
            ActMemAlloc(sizeof(HRESULT)*_info.cIfs);
        if (_info.phresults == NULL)
	{
	   ActMemFree(_info.ppIntfData);
	   _info.ppIntfData=NULL;
	   return E_OUTOFMEMORY;
	}
        firstMarshal = TRUE;
    }
    else
        firstMarshal = FALSE;


    for (i=0; i< _info.cIfs; i++)
    {
        if ((!firstMarshal) &&
            ((_info.ppIntfData[i]) ||
             (FAILED(_info.phresults[i]))))
            continue;

        // Stream to put marshaled interface in
        ActivationStream xrpc;

        DWORD dwMarshalFlags;
        pSer->GetMarshalFlags(&dwMarshalFlags);

        IUnknown *punk;

        if (firstMarshal)
            punk = _pUnk;
        else
            punk = (IUnknown*) _ppvObj[i];

        Win4Assert(punk != NULL);

        void *pvDestCtx = NULL;
        if (dwMaxDestCtx == MSHCTX_DIFFERENTMACHINE)
        {
            pvDestCtx = GetDestCtxPtr(_pClientCOMVersion);
            if (pvDestCtx == NULL)
            {
	       ActMemFree(_info.ppIntfData);
	       _info.ppIntfData=NULL;
	       ActMemFree(_info.phresults);
	       _info.phresults = NULL;
	       return E_OUTOFMEMORY;
            }
        }

        if (pfnCoMarshalInterface)
        {
            if (IsInterfaceImplementedByProxy(_info.piid[i]))
            {
                hr = pfnCoMarshalInterface(&xrpc,
                                           IID_IUnknown,
                                           punk,
                                           dwMaxDestCtx,
                                           pvDestCtx,
                                           dwMarshalFlags);
            }
            else
            {
                hr = pfnCoMarshalInterface(&xrpc,
                                           _info.piid[i],
                                           punk,
                                           dwMaxDestCtx,
                                           pvDestCtx,
                                           dwMarshalFlags);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }

        if (pvDestCtx != NULL)
        {
            delete pvDestCtx;
            pvDestCtx = NULL;
        }

        _info.phresults[i] = hr;
        if (SUCCEEDED(hr))
        {
            xrpc.AssignSerializedInterface(
                (InterfaceData**)&_info.ppIntfData[i]);
        }
        else
        {
            _info.ppIntfData[i] = NULL;

            // If MSHLFLAGS_NOTIFYACTIVATION is set then
            // it is an error path in the LocalServer case
            // (CobjServer) and it is possible for the server
            // to linger around forever unless the LockServer
            // api is toggled on the class factory
            if (dwMarshalFlags & MSHLFLAGS_NOTIFYACTIVATION)
            {
                Win4Assert(_info.cIfs == 1);

                IClassFactory *pcf;

                BOOL fToRelease;

                if (_info.piid[0] != IID_IClassFactory)
                {
                    HRESULT hr2;
                    hr2 = punk->QueryInterface(IID_IClassFactory,
                                               (void**) &pcf);
                    if (FAILED(hr2))
                        pcf = NULL;

                    fToRelease = TRUE;
                }
                else
                {
                    pcf = (IClassFactory*)punk;
                    fToRelease = FALSE;
                }

                if (pcf)
                {
                    pcf->LockServer(TRUE);
                    pcf->LockServer(FALSE);

                    if (fToRelease)
                        pcf->Release();
                }
            }
        }
    }


 EncodeOut:
    DWORD dwCurrDestCtx;
    pSer->GetCurrDestCtx(&dwCurrDestCtx);

    // If marshalling within process, set up as though unmarshalled
    if (MARSHALCTX_WITHIN_PROCESS(dwCurrDestCtx))
    {
        if (_info.ppIntfData)
        {
            Win4Assert(_info.cIfs != 0);
            if (!_ppvObj)
                _ppvObj = (void**) ActMemAlloc(sizeof(IUnknown*)*_info.cIfs);

            if (_ppvObj == NULL)
	    {
	       ActMemFree(_info.ppIntfData);
	       _info.ppIntfData=NULL;
	       ActMemFree(_info.phresults);
	       _info.phresults = NULL;
	       return E_OUTOFMEMORY;
	    }

            for (DWORD i=0; i<_info.cIfs; i++)
                _ppvObj[i] = NULL;

            // Release punk since destructor won't get called
            if (_pUnk)
            {
                if (!_fBrokenRefCount)
                    _pUnk->Release();
                _pUnk = NULL;
            }
        }
        else
            _ppvObj = NULL;

        _size = 0;
    }
    else
    {
        _fToReleaseIFD = FALSE;

        //-------------------------------------------------------------------
        //  Get Header size
        //-------------------------------------------------------------------
        handle_t   handle = NULL;
        hr = pSer->GetSizingHandle((void*) &handle);

        if (FAILED(hr))
            return hr;

        _size = (DWORD) PropsOutInfo_AlignSize(handle, &_info);
        MesHandleFree(handle);
    }

    *pdwSize = _size;

    return S_OK;
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::GetCLSID(OUT CLSID *pclsid)
{
    *pclsid = CLSID_ActivationPropertiesOut;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Function:   ActPropsMarshalHelper
//
//  Synopsis:   Makes an "on the wire" representation of an ActProps
//
//  Arguments:  [pact] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data so we can give it to RPC
//
//---------------------------------------------------------------------------
HRESULT ActPropsMarshalHelper(
    IActivationProperties *pact,
    REFIID    riid,
    DWORD     destCtx,
    DWORD     mshlflags,
    MInterfacePointer **ppIRD)
{
    HRESULT hr;

    // This should'nt really get used by functions
    // called. If that changes we should really QI
    IUnknown *punk = (IUnknown *)pact;


    // Do Marshalling ourselves since this is also
    // used in the SCM. Code collapsed and copied from
    // dcomrem for Custom marshalling
    ULONG dwSize, objrefSize;

    hr = pact->GetMarshalSizeMax(riid,
                                 (void*) punk,
                                 destCtx,
                                 NULL,
                                 mshlflags,
                                 &dwSize);

    if (FAILED(hr))
        return hr;

    objrefSize = dwSize + sizeof(OBJREF);

    // Stream to put marshaled interface in
    ActivationStream xrpc(objrefSize);

    // get the clsid for unmarshaling
    CLSID UnmarshalCLSID;
    hr = pact->GetUnmarshalClass(riid, punk, destCtx, NULL,
                                 mshlflags, &UnmarshalCLSID);


    if (FAILED(hr))
        return hr;

    OBJREF objref;

    objref.signature = OBJREF_SIGNATURE;
    objref.flags     = OBJREF_CUSTOM;
    objref.iid       = riid;
    objref.u_objref.u_custom.clsid     = UnmarshalCLSID;
    objref.u_objref.u_custom.size      = dwSize;

    // currently we dont write any extensions into the custom
    // objref. The provision is there so we can do it in the
    // future, for example,  if the unmarshaler does not have the
    // unmarshal class code available we could to provide a callback
    // mechanism by putting the OXID, and saResAddr in there.

    objref.u_objref.u_custom.cbExtension = 0;

    // write the objref header info into the stream
    ULONG cbToWrite = PtrToUlong( (LPVOID)( (BYTE *)(&objref.u_objref.u_custom.pData)
                                            - (BYTE *)&objref ) );
    hr = xrpc.Write(&objref, cbToWrite, NULL);

    if (FAILED(hr))
        return hr;

    hr = pact->MarshalInterface(&xrpc, riid, punk,
                                destCtx, NULL,
                                mshlflags);

    if (SUCCEEDED(hr))
        xrpc.AssignSerializedInterface((InterfaceData**)ppIRD);

    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   ActPropsUnMarshalHelper
//
//  Synopsis:   Unmarshals an Activation Properties given an IFD
//
//  Arguments:  [pact] - Object to unmarshal into
//              [riid] - iid to unmarshal
//              [pIFP] - pointer to marshaled data
//
//  Returns:    S_OK - object successfully unmarshaled.
//
//---------------------------------------------------------------------------
HRESULT ActPropsUnMarshalHelper(
    IActivationProperties *pAct,
    MInterfacePointer *pIFP,
    REFIID riid,
    void **ppv
)
{
    HRESULT hr = E_INVALIDARG;

    if (pIFP && ppv)
    {
        ActivationStream Stm((InterfaceData *) pIFP);

        *ppv = NULL;

        hr = pAct->UnmarshalInterface(&Stm, riid, ppv);
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   GetIFDFromInterface
//
//  Synopsis:   Makes an "on the wire" representation of an interface
//
//  Arguments:  [punk] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data
//
//---------------------------------------------------------------------------
HRESULT GetIFDFromInterface(
    IUnknown *pUnk,
    REFIID    riid,
    DWORD     destCtx,
    DWORD     mshlflags,
    MInterfacePointer **ppIRD)
{
    DWORD sz = 0;

    InitMarshalling();

    HRESULT rethr;

    if (pfnCoGetMarshalSizeMax)
    {
        rethr = pfnCoGetMarshalSizeMax(&sz, riid , pUnk,
                                           destCtx,
                                           NULL, mshlflags);
    }
    else
    {
        rethr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
    }

    if (rethr == S_OK)
    {
        ActivationStream stream(sz);
        if (pfnCoMarshalInterface)
        {
            rethr = pfnCoMarshalInterface(&stream, riid , pUnk,
                                          destCtx, NULL, mshlflags);
        }
        else
        {
            rethr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }

        if (rethr == S_OK)
            stream.AssignSerializedInterface((InterfaceData**)ppIRD);
        else
            *ppIRD = NULL;
    }
    return rethr;
}

//---------------------------------------------------------------------------
//
//  Function:   ReleaseIFD
//
//  Synopsis:   Releases Marshalled Data
//
//  Arguments:   [pIRD] - Marshalled Data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data
//
//---------------------------------------------------------------------------
HRESULT ReleaseIFD(
    MInterfacePointer *pIRD)
{
    InitMarshalling();

    if (pIRD == NULL)
        return S_OK;

    if (pfnCoReleaseMarshalData == NULL)
        return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);

    ActivationStream Strm((InterfaceData *) pIRD);

    return pfnCoReleaseMarshalData(&Strm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\actprops\propifs.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       propifs.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Functions:  Implements classes in propifs.hxx
//
//  History:    24-Jan-98 Vinaykr    Created
//
///--------------------------------------------------------------------------

#include <ole2int.h>

#include <context.hxx>
#include <actprops.hxx>
#include <serial.hxx>
#include <hash.hxx>

//---------------------------------------------------------------------------   
// This file contains implementations of serializable      
// interfaces                                              
//---------------------------------------------------------------------------   

//---------------------------------------------------------------------------   
//             Methods for InstantiationInfo               
//---------------------------------------------------------------------------   

    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstantiationInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP InstantiationInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       //Use IID_InstantiationInfo to return the real object right now
       if (IsEqualIID(riid, IID_IInstantiationInfo))  
       {
          *ppvObj = (InstantiationInfo*) this;
          AddRef();
          return S_OK;
       }
       else
       if  (IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IInstantiationInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG InstantiationInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG InstantiationInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   

    STDMETHODIMP InstantiationInfo::Serialize(void *pv)
    {
        HRESULT hr;
        Serializer *pSer = (Serializer*) pv;

        handle_t handle = NULL;
        hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);
    
        InstantiationInfoData_Encode(handle, &_instantiationInfoData);
        return S_OK;
    }

    STDMETHODIMP InstantiationInfo::UnSerialize(void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle = NULL;
            HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            _instantiationInfoData.pIID = 0;
            InstantiationInfoData_Decode(handle, &_instantiationInfoData);

            _unSerialized = TRUE;
       }

       return S_OK;
    }

    STDMETHODIMP InstantiationInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = (DWORD) InstantiationInfoData_AlignSize(handle, 
                                                       &_instantiationInfoData);
            MesHandleFree(handle);
            _instantiationInfoData.thisSize = *pdwSize;
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP InstantiationInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IInstantiationInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for ServerLocationInfo              
//---------------------------------------------------------------------------   

    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ServerLocationInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ServerLocationInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       if (IsEqualIID(riid, IID_IServerLocationInfo) || 
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IServerLocationInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ServerLocationInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ServerLocationInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }
    
    //-----------------------------------------------------------------------   
    // Constructor/destructor
    //-----------------------------------------------------------------------   
    ServerLocationInfo::ServerLocationInfo()
    {
        ZeroMemory(&_locationInfoData, sizeof(LocationInfoData));
        _pObjectContext = NULL;
        _pISSP = NULL;
    }

    ServerLocationInfo::~ServerLocationInfo()
    {
        if (_locationInfoData.machineName)
            ActMemFree(_locationInfoData.machineName);
        if (_pObjectContext)
            _pObjectContext->InternalRelease();

        // do not release _pISSP
    }

    //-----------------------------------------------------------------------   
    // Methods
    //-----------------------------------------------------------------------   
    STDMETHODIMP ServerLocationInfo::SetRemoteServerName(IN WCHAR  *pwszMachineName)
    {
        HRESULT hr;

        if (_locationInfoData.machineName)
        {
            ActMemFree(_locationInfoData.machineName);
            _locationInfoData.machineName = NULL;
        }

        Win4Assert(_locationInfoData.machineName == NULL);

        if (pwszMachineName)
        {
            //
            // Some apps may unnecessarily put slashes before their
            // server names.  We'll allow this and strip them off.
            //
            if (pwszMachineName[0]  == L'\\' &&
                pwszMachineName[1] == L'\\' )
                pwszMachineName += 2;

            if ( 0 == *pwszMachineName)
                return CO_E_BAD_SERVER_NAME;

            BOOL fIsSelf;

            _locationInfoData.machineName =
                makeWStringCopy(pwszMachineName);
            if (_locationInfoData.machineName == NULL)
                return E_OUTOFMEMORY;
        }

        return S_OK;
    }
  
    STDMETHODIMP ServerLocationInfo::SetProcess(IN DWORD processId, OUT DWORD dwPRT)
    {
        HRESULT hr;
        ISpecialSystemProperties* pISSP = NULL;

        // This is necessary since we didn't want to break the wire-format
        // after RC2.   If it wasn't for that, we could have put the storage for
        // dwPRT right into _locationInfoData. 

        // Note:   calling this method before this object is aggregated into the
        // actpropsin object means that this QI will fail (see 
        // ServerLocationInfo::QueryInterface up above, _pParent will still be NULL)
        hr = this->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP);
        if (SUCCEEDED(hr))
        {
            hr = pISSP->SetProcessRequestType(dwPRT);
            if (SUCCEEDED(hr))
            {
                _locationInfoData.processId = processId;
            }
            pISSP->Release();
        }

        return hr;       
	}

    STDMETHODIMP ServerLocationInfo::GetProcess(OUT DWORD *pProcessId, OUT DWORD* pdwPRT)
    {
        HRESULT hr;
        ISpecialSystemProperties* pISSP = NULL;

        // This is necessary since we didn't want to break the wire-format
        // after RC2.   If it wasn't for that, we could have put the storage for
        // dwPRT right into _locationInfoData. 

        // Note:   calling this method before this object is aggregated into the
        // actpropsin object means that this QI will fail (see 
        // ServerLocationInfo::QueryInterface up above, _pParent will still be NULL)
        hr = this->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP);
        if (SUCCEEDED(hr))
        {
            hr = pISSP->GetProcessRequestType(pdwPRT);
            if (SUCCEEDED(hr))
            {
                *pProcessId = _locationInfoData.processId;
            }
            pISSP->Release();
        }

        return hr;       
    }

    
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ServerLocationInfo::Serialize(void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        handle_t handle = NULL;
        HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);

        LocationInfoData_Encode(handle, &_locationInfoData);
        return S_OK;
    }

    STDMETHODIMP ServerLocationInfo::UnSerialize(void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            _locationInfoData.machineName=0;
            handle_t handle = NULL;
            pSer->GetSerializationHandle((void*) &handle);
            LocationInfoData_Decode(handle, &_locationInfoData);

            _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP ServerLocationInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = (DWORD) LocationInfoData_AlignSize(handle, &_locationInfoData);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP ServerLocationInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IServerLocationInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for SecurityInfo                    
//---------------------------------------------------------------------------   

    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP SecurityInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP SecurityInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       if (IsEqualIID(riid, IID_IActivationSecurityInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IActivationSecurityInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ILegacyInfo))
       {
           *ppvObj = (ILegacyInfo*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG SecurityInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG SecurityInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();
       return 0;
    }

    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP SecurityInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle = NULL;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       SecurityInfoData_Encode(handle, &_securityInfoData);
       return S_OK;
    }

    STDMETHODIMP SecurityInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle = NULL;
            HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            _securityInfoData.pServerInfo = 0;
            _securityInfoData.pAuthIdentityInfo = 0;
            SecurityInfoData_Decode(handle, &_securityInfoData);
     
            _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP SecurityInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = (DWORD) SecurityInfoData_AlignSize(handle, &_securityInfoData);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP SecurityInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IActivationSecurityInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for ScmRequestInfo                  
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmRequestInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ScmRequestInfo::SerializableQueryInterface( REFIID riid, LPVOID*
ppvObj)
    {
       if (IsEqualIID(riid, IID_IScmRequestInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IScmRequestInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ScmRequestInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ScmRequestInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmRequestInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle = NULL;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       ScmRequestInfoData_Encode(handle, &_scmRequestInfoData);
       return S_OK;
    }

    STDMETHODIMP ScmRequestInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle = NULL;
           HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
           Win4Assert(hr==S_OK);
           _scmRequestInfoData.pScmInfo = 0;
           _scmRequestInfoData.remoteRequest = 0;
           ScmRequestInfoData_Decode(handle, &_scmRequestInfoData);
           _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP ScmRequestInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = (DWORD) ScmRequestInfoData_AlignSize(handle, &_scmRequestInfoData);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP ScmRequestInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IScmRequestInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for ScmReplyInfo                    
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmReplyInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ScmReplyInfo::SerializableQueryInterface( REFIID riid, LPVOID*
ppvObj)
    {
       if (IsEqualIID(riid, IID_IScmReplyInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IScmReplyInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ScmReplyInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ScmReplyInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

       
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmReplyInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle = NULL;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       ScmReplyInfoData_Encode(handle, &_scmReplyInfoData);
       return S_OK;
    }

    STDMETHODIMP ScmReplyInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle = NULL;
           HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
           Win4Assert(hr==S_OK);
           _scmReplyInfoData.remoteReply = 0;
           _scmReplyInfoData.pResolverInfo = 0;
           ScmReplyInfoData_Decode(handle, &_scmReplyInfoData);
           _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP ScmReplyInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        handle_t   handle;
        HRESULT hr = pSer->GetSizingHandle((void*) &handle);
        if (FAILED(hr))
            return hr;
        *pdwSize = (DWORD) ScmReplyInfoData_AlignSize(handle, &_scmReplyInfoData);
        MesHandleFree(handle);

        return S_OK;
    }

    STDMETHODIMP ScmReplyInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IScmReplyInfo;
        return S_OK;
    }


//---------------------------------------------------------------------------   
//             Methods for ContextInfo                     
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ContextInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ContextInfo::SerializableQueryInterface(REFIID riid, 
                                                         LPVOID* ppvObj)
    {
       if (IsEqualIID(riid, IID_IPrivActivationContextInfo))
       {
           *ppvObj = (IPrivActivationContextInfo*) this;
           AddRef();
           return S_OK;
       }
       else if (IsEqualIID(riid, IID_IActivationContextInfo)
           || IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IActivationContextInfo*) this;
           AddRef();
           return S_OK;
       }
       else if (IsEqualIID(riid, IID_IOverrideTargetContext))
       {
           *ppvObj = (IOverrideTargetContext*) this;
           AddRef();
           return S_OK;
       }
       else if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ContextInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ContextInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    HRESULT ContextInfo::GetClientContext(OUT IContext **ppCtx)
    {
        CObjectContext *pCtx;
        HRESULT hr = GetInternalClientContext(&pCtx);
        if (SUCCEEDED(hr) && pCtx)
        {
            pCtx->AddRef();
            pCtx->InternalRelease();
            *ppCtx = (IContext*)pCtx;
        }
        
        return hr;
    }
    
    HRESULT ContextInfo::GetInternalClientContext(OUT CObjectContext **ppCtx)
    {
        HRESULT hr = S_OK;

        InitMarshalling();

        if ((_unSerialized) && 
            (_pClientCtx==NULL)   && 
            (_contextInfoData.pIFDClientCtx != NULL))
        {
            if (pfnCoUnmarshalInterface)
            {
                ActivationStream stream((InterfaceData*)_contextInfoData.pIFDClientCtx);
                hr = pfnCoUnmarshalInterface(&stream, 
                                             IID_IStdObjectContext,
                                             (void**)&_pClientCtx);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                // Unmarshaling the context gives a user reference.  We want
                // an internal ref, so we take one and release the user ref.
                _pClientCtx->InternalAddRef();
                _pClientCtx->Release();
            }

            ActMemFree(_contextInfoData.pIFDClientCtx);
            _contextInfoData.pIFDClientCtx = NULL;
        }

        if (_pClientCtx)
            _pClientCtx->InternalAddRef();
        else
           SetClientContextNotOK();

        *ppCtx = _pClientCtx;

        return hr;
    }

    STDMETHODIMP ContextInfo::GetPrototypeContext(OUT IContext **ppCtx)
    {
        CObjectContext *pCtx;
        HRESULT hr = GetInternalPrototypeContext(&pCtx);
        if (SUCCEEDED(hr))
        {
            pCtx->AddRef();
            pCtx->InternalRelease();
            *ppCtx = (IContext*)pCtx;
        }
        return hr;
    }

    HRESULT ContextInfo::GetInternalPrototypeContext(OUT CObjectContext **ppCtx)
    {
        extern HRESULT CObjectContextCF_CreateInstance(IUnknown *pUnkOuter, 
                                                       REFIID riid, 
                                                       void** ppv);

        InitMarshalling();
                                                   
        HRESULT hr = S_OK;

        if ((_unSerialized) && 
            (_pPrototypeCtx==NULL)   && 
            (_contextInfoData.pIFDPrototypeCtx != NULL))
        {
            if (pfnCoUnmarshalInterface)
            {
                ActivationStream stream((InterfaceData*)_contextInfoData.pIFDPrototypeCtx);
                hr = pfnCoUnmarshalInterface(&stream, 
                                             IID_IStdObjectContext, 
                                             (void**)&_pPrototypeCtx);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                // Unmarshaling the context gives a user reference.  We want
                // an internal ref, so we take one and release the user ref.
                _pPrototypeCtx->InternalAddRef();
                _pPrototypeCtx->Release();
            }

            ActMemFree(_contextInfoData.pIFDPrototypeCtx);
            _contextInfoData.pIFDPrototypeCtx = NULL;
        }
        else 
        if (!_pPrototypeCtx)
        {
            hr = CObjectContextCF_CreateInstance(NULL,
                                                 IID_IStdObjectContext,
                                                 (void**) &_pPrototypeCtx);
            if (SUCCEEDED(hr))
            {
                // Creating the context gives a user reference.  We want
                // an internal ref, so we take one and release the user ref.
                _pPrototypeCtx->InternalAddRef();
                _pPrototypeCtx->Release();
            }
        }

        if (SUCCEEDED(hr))        
            _pPrototypeCtx->InternalAddRef();

        *ppCtx = _pPrototypeCtx;

        return hr;
    }
    
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ContextInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        //-------------------------------------------------------------------   
        //       Encode header                             
        //-------------------------------------------------------------------   
        handle_t handle = NULL;
        HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);
        ActivationContextInfoData_Encode(handle, &_contextInfoData);
        _unSerialized = FALSE;
        return S_OK;
    }

    STDMETHODIMP ContextInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle = NULL;
            HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            _pClientCtx = 0;
            _pPrototypeCtx = 0;
            ActivationContextInfoData_Decode(handle, &_contextInfoData);
            _unSerialized = TRUE;
        }

        return S_OK;
    }

    STDMETHODIMP ContextInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        HRESULT rethr=S_OK;

       //--------------------------------------------------------------------   
       // If Is an inproc path, no need to marshal context
       //--------------------------------------------------------------------   
        if (IsInproc(pSer))
        {
            *pdwSize = 0;
            return S_OK;
        }

        _toReleaseIFD = FALSE;

        if (_pClientCtx)
        {
            rethr = GetIFDFromInterface((IUnknown*)(IObjContext*) _pClientCtx,
                                         IID_IContext,
                                         MSHCTX_DIFFERENTMACHINE,
                                         MSHLFLAGS_NORMAL,
                                         &_contextInfoData.pIFDClientCtx);
            if (FAILED(rethr))
            {
               _contextInfoData.pIFDClientCtx = NULL;
                return rethr;
            }
        }
   
        if (_pPrototypeCtx)
        {
            rethr = GetIFDFromInterface((IUnknown*)(IObjContext*) _pPrototypeCtx,
                                         IID_IContext,
                                         MSHCTX_DIFFERENTMACHINE,
                                         MSHLFLAGS_NORMAL,
                                         &_contextInfoData.pIFDPrototypeCtx);
   
            if (FAILED(rethr))
            {
               _contextInfoData.pIFDPrototypeCtx = NULL;
                return rethr;
            }
        }

        handle_t   handle;
        rethr = pSer->GetSizingHandle((void*) &handle);

        if (SUCCEEDED(rethr))
        {
            *pdwSize = (DWORD) ActivationContextInfoData_AlignSize(handle, 
                                                        &_contextInfoData);
            MesHandleFree(handle);
        }
        
        return rethr;
    }

    STDMETHODIMP ContextInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IActivationContextInfo;
        return S_OK;
    }


//---------------------------------------------------------------------------   
//             Methods for InstanceInfo                     
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP InstanceInfo::SerializableQueryInterface( REFIID riid, LPVOID*
ppvObj)
    {
       if (IsEqualIID(riid, IID_IInstanceInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IInstanceInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG InstanceInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG InstanceInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    
    //-----------------------------------------------------------------------   
    // Methods from IInstanceInfo                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::SetStorage(IN IStorage *pstg)
    {
        _pstg = pstg;

        if (_pstg)
            _pstg->AddRef();

        return S_OK;
    }

    STDMETHODIMP InstanceInfo::GetStorage(OUT IStorage **ppstg)
    {
        HRESULT hr = S_OK;

        InitMarshalling();

        if ((_pstg==NULL)   && 
            (_instanceInfoData.ifdStg != NULL))
        {
            if (pfnCoUnmarshalInterface)
            {
                ActivationStream stream((InterfaceData*)_instanceInfoData.ifdStg);
                hr = pfnCoUnmarshalInterface(&stream, IID_IStorage, (void**)&_pstg);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }
        }

        if (_pstg)
            _pstg->AddRef();

        *ppstg = _pstg;
        return hr;
    }

       
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        handle_t handle = NULL;
        HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);
        InstanceInfoData_Encode(handle, &_instanceInfoData);
        _unSerialized = FALSE;
        return hr;
    }

    STDMETHODIMP InstanceInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        HRESULT hr = S_OK;

        if (!_unSerialized)
        {
            handle_t handle = NULL;
            hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            InstanceInfoData_Decode(handle, &_instanceInfoData);
            _unSerialized = TRUE;
        }

        return hr;
    }

    //-----------------------------------------------------------------------   
    // NOTE: This function should only get called if a storage pointer is
    //       present during inproc/crossctx marshalling
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        HRESULT rethr=S_OK;

        DWORD dwCurrDestCtx;
        pSer->GetCurrDestCtx(&dwCurrDestCtx);
        
        //-------------------------------------------------------------------   
        //Need to marshal interface first to compute size   
        //-------------------------------------------------------------------   
        if (_pstg)
        {
           //----------------------------------------------------------------   
           // Need to free previously marshalled data       
           //----------------------------------------------------------------   
            if (_instanceInfoData.ifdStg) 
               ActMemFree(_instanceInfoData.ifdStg);

            if (dwCurrDestCtx == MSHCTX_LOCAL)
                dwCurrDestCtx = MSHCTX_DIFFERENTMACHINE;

            rethr = GetIFDFromInterface((IUnknown*) _pstg,
                                               IID_IStorage,
                                         dwCurrDestCtx,
                                         MSHLFLAGS_NORMAL,
                                         &_instanceInfoData.ifdStg);
            if (FAILED(rethr))
            {
                _instanceInfoData.ifdStg = NULL; 
                return rethr;
            }

            _pstg->Release();
            _pstg = NULL;
        
        }

        if (IsInproc(pSer))
        {
            *pdwSize = 0;
        }
        else
        {
        //-------------------------------------------------------------------   
        // Encode header                                    
        //-------------------------------------------------------------------   
            handle_t   handle = NULL;
            rethr = pSer->GetSizingHandle((void*) &handle);
            if (SUCCEEDED(rethr))
            {
                *pdwSize = (DWORD) InstanceInfoData_AlignSize(handle, 
                                                &_instanceInfoData);
                MesHandleFree(handle);
            }
        }

        return rethr;
    }

    STDMETHODIMP InstanceInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IInstanceInfo;
        return S_OK;
    }

    //-----------------------------------------------------------------------
    // Methods from IOpaqueDataInfo
    //-----------------------------------------------------------------------
    STDMETHODIMP OpaqueDataInfo::AddOpaqueData (OpaqueData *pData)
    {
        HRESULT hr;

        if (_cOpaqueData == _dwCollSize)
        {
            OpaqueData *pNew = (OpaqueData*)
                    ActMemAlloc(sizeof(OpaqueData) *(_dwCollSize+20)); 

            if (pNew == NULL)
            {
                return E_OUTOFMEMORY;
            }

            _dwCollSize += 20;

            CopyOpaqueData(pNew, _pOpaqueData, 
                           _cOpaqueData, FALSE);

            ActMemFree(_pOpaqueData);

            _pOpaqueData = pNew;
        }


        hr = CopyOpaqueData(&_pOpaqueData[_cOpaqueData], pData, 
                            1, TRUE);

        if (FAILED(hr))
            return hr;

        _cOpaqueData++;

        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::GetOpaqueData (REFGUID guid,
                                   OpaqueData **pData)
    {
        for (DWORD i=0; i < _cOpaqueData ; i++)
        {
            if (_pOpaqueData[i].guid == guid)
            {
                *pData = &_pOpaqueData[i];
                return S_OK;
            }
        }

        return E_FAIL;
    }

    STDMETHODIMP  OpaqueDataInfo::DeleteOpaqueData (REFGUID guid)
    {
        BOOL found = FALSE;

        for (DWORD i=0; i < _cOpaqueData ; i++)
        {
            if (_pOpaqueData[i].guid == guid)
            {
                found = TRUE;
                break;
            }
        }

        if (!found)
            return E_FAIL;

        ActMemFree(_pOpaqueData[i].data);

        for (i=i+1; i < _cOpaqueData ; i++)
        {
            CopyOpaqueData(&_pOpaqueData[i-1],
                           &_pOpaqueData[i],
                           1, FALSE);
        }


        _cOpaqueData--;

        return S_OK;
    }

    STDMETHODIMP  OpaqueDataInfo::GetOpaqueDataCount (ULONG *pulCount)
    {
        *pulCount = _cOpaqueData;

        return S_OK;
    }

    STDMETHODIMP  OpaqueDataInfo::GetAllOpaqueData (OpaqueData **prgData)
    {
        *prgData = _pOpaqueData;

        return S_OK;
    }

    //-----------------------------------------------------------------------
    // Methods from ISerializable
    //-----------------------------------------------------------------------
    STDMETHODIMP OpaqueDataInfo::Serialize(IN void *pv)
    {
        _unSerialized = FALSE;
        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::UnSerialize(IN void *pv)
    {
        if (!_parent)
            return E_INVALIDARG;

        HRESULT hr = S_OK;
        if (!_unSerialized)
        {
            hr = ((ActivationProperties*)_pAct)->GetOpaqueDataInfo(&_cOpaqueData, &_pOpaqueData);
            _unSerialized = TRUE;
        }

        return hr;
    }

    STDMETHODIMP OpaqueDataInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        if (!_parent)
            return E_INVALIDARG;

        *pdwSize = 0;

        Serializer *pSer = (Serializer*) pv;

        if ((!IsInproc(pSer)) && _cOpaqueData) 
        {
            ((ActivationProperties*)_pAct)->SetOpaqueDataInfo(_cOpaqueData,
                                                                _pOpaqueData);

            _cOpaqueData = 0;
            _pOpaqueData = NULL;
        }

        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IOpaqueDataInfo;
        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::SetParent(ISerializableParent *pParent)
    {
        _parent = pParent;

        if (pParent)
            return pParent->QueryInterface(CLSID_ActivationProperties, 
                                           &_pAct);

        return S_OK;
    }

    //-----------------------------------------------------------------------
    // Methods from IUnknown
    //-----------------------------------------------------------------------
    STDMETHODIMP OpaqueDataInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP OpaqueDataInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       //Use IID_OpaqueDataInfo to return the real object right now
       if (IsEqualIID(riid, IID_IOpaqueDataInfo))
       {
          *ppvObj = (OpaqueDataInfo*) this;
          AddRef();
          return S_OK;
       }
       else
       if  (IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IOpaqueDataInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       *ppvObj = NULL;

       return E_NOINTERFACE;
    }

    ULONG OpaqueDataInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG OpaqueDataInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }


    //-----------------------------------------------------------------------
    // Methods from IUnknown
    //-----------------------------------------------------------------------
    STDMETHODIMP SpecialProperties::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP SpecialProperties::SerializableQueryInterface( REFIID riid, LPVOID
* ppvObj)
    {
       //Use IID_ISpecialSystemProperties to return the real object right now
       if (IsEqualIID(riid, IID_ISpecialSystemProperties))
       {
          *ppvObj = (SpecialProperties*) this;
          AddRef();
          return S_OK;
       }
       else
       if  (IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (ISpecialSystemProperties*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       *ppvObj = NULL;

       return E_NOINTERFACE;
    }

    ULONG SpecialProperties::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG SpecialProperties::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    //-----------------------------------------------------------------------
    // Methods from ISerializable
    //-----------------------------------------------------------------------
    STDMETHODIMP SpecialProperties::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle = NULL;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       SpecialPropertiesData_Encode(handle, &_data);
       return S_OK;
    }

    STDMETHODIMP SpecialProperties::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle = NULL;
           HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
           Win4Assert(hr==S_OK);
           SpecialPropertiesData_Decode(handle, &_data);
           _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP SpecialProperties::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;

        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = (DWORD) SpecialPropertiesData_AlignSize(handle, &_data);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP SpecialProperties::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_ISpecialSystemProperties;
        return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\actprops\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   actprops
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\ih;..;..\..\com\inc;..\..\com\dcomrem
INCLUDES=     $(INCLUDES);..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES=    \
              $(C_DEFINES)

SOURCES=      \
              ..\actprops.cxx   \
              ..\propifs.cxx \
              ..\actstrm.cxx

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\catalog\classic\cat_dll.cpp ===
/* cat_dll.cpp */

#include <windows.h>
#include <comdef.h>


const GUID CLSID_COMCatalog = { 0x00000346, 0, 0, 0xC0,0,0,0,0,0,0,0x46 };

HRESULT __stdcall GetCatalogObject
(
    /* [in] */ REFIID riid,
    /* [out, iis_is(riid)] */ void ** ppv
)
{
    return CoCreateInstance (CLSID_COMCatalog, NULL, CLSCTX_INPROC, riid, ppv);
}


#define CLSID_CATALOG "{1A26EFEF-9F04-11D1-8F36-00C04FD8FF5E}"

const CLSID g_clsid_catalog =
    {0x1A26EFEF,0x9F04,0x11D1,{0x8F,0x36,0x00,0xC0,0x4F,0xD8,0xFF,0x5E}};

class CClassFactory : public IClassFactory
{
public:
    CClassFactory(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

private:
    long m_cRef;
};

CClassFactory::CClassFactory(void) : m_cRef(0) { }

STDMETHODIMP CClassFactory::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IClassFactory) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IClassFactory *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
    {
        delete this;
    }

    return(cRef);
}


STDMETHODIMP CClassFactory::CreateInstance(
        LPUNKNOWN pUnkOuter,
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    HRESULT hr;

    *ppvObj = NULL;

    if (pUnkOuter)
    {
        return(CLASS_E_NOAGGREGATION);
    }

    hr = CoCreateInstance (CLSID_COMCatalog, NULL, CLSCTX_INPROC, riid, ppvObj);

    return(hr);
}


STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    return(S_OK);
}


static HINSTANCE g_hInst = NULL;

STDAPI_(BOOL) APIENTRY DllMain
(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
)
{
    g_hInst = hInst;
    return(TRUE);
}


STDAPI DllCanUnloadNow(void)
{
    return( S_FALSE );
}


STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR* ppvObj
)
{
    if (rclsid != g_clsid_catalog)
    {
        return(E_FAIL);
    }

    if (ppvObj == NULL)
    {
        return E_INVALIDARG;
    }
    *ppvObj = NULL;

    CClassFactory *pcf = new CClassFactory;
    if (pcf == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pcf->AddRef();
    HRESULT hRes = pcf->QueryInterface(riid, ppvObj);
    pcf->Release();

    return(hRes);
}


typedef struct
{
    char *KeyName;
    char *ValueName;
    char *Value;
} REGISTRATION_ENTRY;

REGISTRATION_ENTRY registration[] =
{
    { "CLSID\\" CLSID_CATALOG, NULL, "COM+ Catalog Queries" },
    { "CLSID\\" CLSID_CATALOG "\\InprocServer32", NULL, /* dynamic */ },
    { "CLSID\\" CLSID_CATALOG "\\InprocServer32", "ThreadingModel", "Both" }
};

#define NUM_REGISTRATION_VALUES (sizeof(registration) / sizeof(registration[0]))
#define REGISTRATION_SERVER (1)


STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    char szModuleName[MAX_PATH+1];

    GetModuleFileNameA(g_hInst, szModuleName, sizeof(szModuleName)/sizeof(szModuleName[0]));
    szModuleName[sizeof(szModuleName)/sizeof(szModuleName[0])-1]= '\0';
    registration[REGISTRATION_SERVER].Value = szModuleName;

    for (int i = 0; i < NUM_REGISTRATION_VALUES; i++)
    {
        HKEY hKey;
        hr = RegCreateKeyA(HKEY_CLASSES_ROOT, registration[i].KeyName, &hKey);
        if (hr == ERROR_SUCCESS)
        {
            hr = RegSetValueExA(hKey,
                    registration[i].ValueName,
                    0,
                    REG_SZ,
                    (BYTE *) registration[i].Value,
                    strlen(registration[i].Value) + 1);

            RegCloseKey(hKey);
        }

        if (hr != ERROR_SUCCESS)
        {
            DllUnregisterServer();

            return(SELFREG_E_CLASS);
        }
    }

    return(S_OK);
}


STDAPI DllUnregisterServer(void)
{
    for (int i = NUM_REGISTRATION_VALUES - 1; i >= 0; i--)
    {
        RegDeleteKeyA(HKEY_CLASSES_ROOT, registration[i].KeyName);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\precomp2.inc ===
#//+---------------------------------------------------------------
#//
#//  File:	precom2.inc
#//
#//  Contents:	directives for global precompiled include file when the
#//		sources file is two directories below com (or wherever
#//		this file is located).  We could easily have precomp3 and
#//		precomp4 for other areas.  The ole2int.* files should not
#//		otherwise be mentioned in the sources files.
#//
#//  History:	18-May-94   CraigWi	Created
#//
#//----------------------------------------------------------------

!ifdef OLE32ROOT
PCH_ROOT=$(OLE32ROOT)\com
!else
PCH_ROOT=..\..
!endif

# The precompiled header needs something out of these inc paths...
INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\ole2int.h
PRECOMPILED_TARGET=..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.pch
PRECOMPILED_OPTION=/Yuole2int.h /Fp..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.pch
PRECOMPILED_OBJ=$(PCH_ROOT)\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\acsrv.cxx ===
//+---------------------------------------------------------------------------
//
// File: acsrv.cxx
//
// Description: This file contains code to initialize the access control
//              globals
//
// Functions: InitializeAccessControl
//
//+---------------------------------------------------------------------------

#include "ole2int.h"
#include <windows.h>
#include <iaccess.h>
#include <stdio.h>

#include "acpickl.h"  //
#include "cache.h"    //
#include "caccctrl.h" // Declaration of COAccessControl class factory

// Global variables
BOOL    g_bInitialized = FALSE; // Module initialization flag
IMalloc *g_pIMalloc;            // Cache a pointer to the task allocator for

BOOL g_bServerLockInitialized = FALSE;
CRITICAL_SECTION g_ServerLock;


ULONG   g_ulHeaderSize;         // Since the encoded size of the header
                                // is frequently used by the CImpAccessControl
                                // methods, I just make it a one time
                                // initialized global value.

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: InitializeAccessControl
//
// Summary: This function performs per-process initialization
//          The major bulk of module initialization
//          code has been moved to ComGetClassObject to avoid circular module
//          initialization dependency. Right now, the function will only
//          initialize a critical section
//
// Args:
//
// Modifies: CRITICAL_SECTIOn g_ServerLock - This CRITICAL_SECTION object is
//                                           used to prevent simultaneous
//                                           initialization of the module in
//                                           ComGetClassObj. g_cServerLock is
//                                           destroyed when the
//                                           UninitializeAccessControl is
//                                           called.
//
// Return: BOOL - This function should always S_OK.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
HRESULT InitializeAccessControl()
{
    NTSTATUS status;

    status = RtlInitializeCriticalSection(&g_ServerLock);
    if (NT_SUCCESS(status))
        g_bServerLockInitialized = TRUE;

    return NT_SUCCESS(status) ? S_OK : E_UNEXPECTED;
}

/****************************************************************************

    Function:   UninitializeAccessControl

    Summary:    Cleans up this module.

****************************************************************************/
void UninitializeAccessControl()
{
    // If the module is unloaded after it is initialized,
    // then make sure that the task memory allocator pointer
    // is freed.
    if(g_bInitialized)
    {
        g_pIMalloc->Release();
        g_bInitialized = FALSE;
    }
    // The g_ServerLock CRITICAL_SECTION object should always
    // be destroyed.
    if (g_bServerLockInitialized)
    {
        DeleteCriticalSection(&g_ServerLock);
        g_bServerLockInitialized = FALSE;
    }
}


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: InitGlobals
//
// Summary: This function initializes globals for this module.  All threads
//          that call this function
//          will be blocked by the g_ServerLock CRITICAL_SECTION object until
//          the first thread that arrives has completed the module initialization
//          sequence.
//
// Modifies: g_ProcessID - The current processID of the Dll module. This
//                         process ID is used by CImpAccessControl object to
//                         compose filename.
//
//           g_HeaderSize - Size of the STREAM_HEAEDER structure when it is
//                          encoded into
//           Chicago only:
//           g_uiCodePage - The console code page that is currently in use.
//                          This code page is used for translating Unicode
//                          string to ANSI string on Chicago.
//
// Return: HRESULT
//                 - E_FAIL: The function failed to create
//                           a message encoding handle.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
HRESULT InitGlobals()
{
    EnterCriticalSection(&g_ServerLock);
    if(g_bInitialized == FALSE)
    {

        // Cache a pointer to the task memory allocator
        // This pointer is used by the global functions LocalMemAlloc,
        // LocalMemFree, midl_user_allocate, and midl_user_free.
        if (FAILED(CoGetMalloc(MEMCTX_TASK, &g_pIMalloc)))
        {
            // CoGetMalloc will never fail.
            Win4Assert(!"CoGetMalloc failed!  Fix this right now!");
        }


        // The following segment of code is for computing the encoded size of
        // StTREAM_HEADER structure.
        RPC_STATUS status;
        CHAR          DummyBuffer[64];
        ULONG         ulEncodedSize;
        STREAM_HEADER DummyHeader;
        handle_t      PickleHandle;
        CHAR          *pEncodingBuffer;

        pEncodingBuffer = (CHAR *)(((UINT_PTR)DummyBuffer + 8) & ~7);
        if(status = (MesEncodeFixedBufferHandleCreate( pEncodingBuffer
                                                     , 56
                                                     , &ulEncodedSize
                                                     , &PickleHandle)) != RPC_S_OK )
        {
            ComDebOut((DEB_COMPOBJ, "MesEncodeFixedBufferHandelCreate failed with return code %x.\n", status));
            LeaveCriticalSection(&g_ServerLock);
            return E_FAIL;
        }

        STREAM_HEADER_Encode(PickleHandle, &DummyHeader);
        g_ulHeaderSize = ulEncodedSize;
        MesHandleFree(PickleHandle);

        // Set server initialization flag
        g_bInitialized = TRUE;

    }
    LeaveCriticalSection(&g_ServerLock);
    return S_OK;
} // InitGlobals
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\caccctrl.cxx ===
//+---------------------------------------------------------------------------
//
// File: caccctrl.cxx
//
// Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
// Description: This file contains the method definitions of the DCOM
//              IAccessControl implementation classes
//
// Classes:  COAccessControl - This is the implementation component of DCOM
//                             IAccessControl. For aggregation support, the
//                             COAccessControl component is implemented as a
//                             nested class containing the CImpAccessControl
//                             class. The COAccessControl object itself
//                             contains a non-delegating implementation of
//                             IUknown that exposed the IUnknown, IPersist,
//                             IPersistStream, and the IAccessControl
//                             interfaces.
//           CImpAccessControl - This is the class nested within the
//                               COAccessControl component class. It
//                               contains the implementation of IAccessControl
//                               and IPersistStream and an implementation
//                               of IUnknown that always delegates the call
//                               to the controlling unknown.
//           CFAccessControl - The class factory for manufacturing COAccessControl
//                             objects.
//
// CODEWORK:
//      Use PrivMemAllow everywhere.
//      Always check m_bInitialized before argument validation.
//
//+---------------------------------------------------------------------------
#include "ole2int.h"
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include "iaccess.h"   // IAccessControl interface definition
#include "Cache.h"    // Effective permissions cache
#include "acpickl.h"  // Pickling support
#include "caccctrl.h" // COAccessControl, CImpAccessControl and CFAccessControl
                      // class declarations.

// External variables
#include "acext.h"

GENERIC_MAPPING gDummyMapping   = {0,0,0,0};
PRIVILEGE_SET   gDummyPrivilege = {1,0};
SID             gEveryone       = {1,1,SECURITY_WORLD_SID_AUTHORITY,
                                   SECURITY_WORLD_RID};

// Internal function prototypes, please see the function headers for details
HRESULT InitGlobals                   ();
void    AddACEToStreamACL             (STREAM_ACE *, PCB *);
void    CleanAllMemoryResources       (ACL_DESCRIPTOR *, PCB *);
void    CleanUpStreamACL              (STREAM_ACL *pStreamACL);
HRESULT EnlargeStreamACL              (PCB *, ULONG);
void    FreePicklingBuff              (PCB *);
BOOL    IsValidAccessMask             (DWORD);
void    *LocalMemAlloc                (SIZE_T);
void    LocalMemFree                  (void *);
HRESULT MapStreamACLToAccessList      (PCB *, PACTRL_ACCESSW *);
HRESULT ResizePicklingBuff            (PCB *, ULONG);
HRESULT ValidateTrusteeString         (LPWSTR);
HRESULT ValidateTrustee               (PTRUSTEE_W);
HRESULT ValidateAccessCheckClient     (PTRUSTEE_W);
HRESULT ValidateAndTransformAccReqList(PACTRL_ACCESSW ,STREAM_ACE **, void **, ULONG *, ULONG *, ULONG *);

HRESULT ComputeEffectiveAccess        (ACL_DESCRIPTOR *, STREAM_ACL *, HANDLE, DWORD *);
BOOL    DeleteACEFromStreamACL        (PTRUSTEE_W, ULONG, ACL_DESCRIPTOR *, PCB *);
HRESULT GetSIDFromName                (PSID *, LPWSTR, TRUSTEE_TYPE *);
HRESULT GetNameFromSID                (LPWSTR *, PSID, TRUSTEE_TYPE *);
HRESULT InitSecDescInACLDesc          (ACL_DESCRIPTOR *);
void    NTMaskToStandardMask          (ACCESS_MASK *, DWORD *);
HRESULT PutStreamACLIntoSecDesc       (STREAM_ACL *, ACL_DESCRIPTOR *);
HRESULT ReadACLFromStream             (IStream *, PCB *, ACL_DESCRIPTOR *);
void    StandardMaskToNTMask          (DWORD *, ACCESS_MASK *);
HRESULT ValidateAndFixStreamACL       (STREAM_ACL *, ULONG *, ULONG *);

//////////////////////////////////////////////////////////////////////////////
// CFAccessControl methods (Class Factory)
//////////////////////////////////////////////////////////////////////////////

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Function: CAccessControlCF_CreateInstance(), public
//
// Summary: This function creates an instance of the CAccesControl object
//          and returns a requested interface pointer to the object. If the
//          caller of this method intends to aggregate with the COAccessControl
//          component, it will pass it's IUnknown pointer to this method which
//          will in turn be passed into the COAccessControl contructor.
//          Owing to the fact that the COAccessControl object supports
//          aggregation, and COM rules dictate that a client must only ask for
//          the IUnknown interface at creation of an aggregatable object,
//          the caller must pass in IID_IUnknown as the riid parameter,
//          otherwise this call will fail and return E_INVALIDARG.
//
// Args: IUnknown *pUnkOuter [in] - IUnknown pointer to the controlling object which
//                                  can be NULL if the COAccessControl object is not
//                                  created as part of an aggregate.
//       REFIID riid [in] - Reference to the identifier of the interface that
//                          the client has requested.
//       void **ppv [out] - Reference to the interface pointer to be returned to
//                          the caller.
//
// Return: HRESULT -S_OK: Succeeded.
//                  E_INVALIDARG: ppv is NULL, or the client ask for an interface
//                                other than IUnknown
//                  E_OUTOFMEMORY: Not enough memory to create new object.
//                  E_NOINTERFACE: The interface requested by the client
//                                 was not supported by the COM IAccessControl
//                                 object.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
HRESULT CAccessControlCF_CreateInstance(IUnknown *pUnkOuter,
                                        REFIID riid, void **ppv)
{
    HRESULT hr = InitGlobals();
    if (FAILED(hr))
    {
        return hr;
    }

    hr = E_OUTOFMEMORY;
    COAccessControl *pAccessControl = new COAccessControl;
    if (pAccessControl)
    {
        hr = pAccessControl->Init(pUnkOuter);
        if (SUCCEEDED(hr))
        {
            hr = pAccessControl->QueryInterface(riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pAccessControl;
        }
    }

    return hr;
} // CFAccessControl::CreateInstance

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CFAccessControl::LockServer() , public
//
// Summary: This function either increases of decreases the server lock count.
//
// Args: BOOL fLock [in] - This flag tells the function whether to increment or
//                         decrement the server lock count.
//                         TRUE - Increment the server lock count.
//                         FALSE - Decrement the server lock count.
//                         The server can be unloaded if the server lock count
//                         and the object count are both zero.
//
// Return: S_OK: This function cannot fail.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

STDMETHODIMP_(HRESULT)
CFAccessControl::LockServer
(
BOOL fLock
)
{
    return S_OK;
} // CFAccessControl::LockServer

//////////////////////////////////////////////////////////////////////////////
// COAccessControl methods
//////////////////////////////////////////////////////////////////////////////

// Constructor, destructor

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::COAccessControl(), public
//
// Summary: Object constructor. This function sets the object's reference count
//          to zero.
//
// Args:  void
//
// Modifies: m_cRefs
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
COAccessControl::COAccessControl
(
void
)
{
    // Set object reference count to zero
    m_cRefs = 0;
    m_ImpObj = NULL;
    return;

} // COAccessControl::COAccessControl

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::Init(), public
//
// Summary: COAccessControl initialization method. Notice that this function
//          initialize the COAccessControl object in a sense different from
//          that of COAccessControl::Load. COAccessControl::Load initializes
//          COAccessControl
//
// Args:  IUnknown pUnkOuter - Pointer to the controlling object. This pointer
//                             can be NULL if the COAccessControl object
//                             is not part of an aggregate.
//
// Modifies: m_ImpObj
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::Init
(
IUnknown *pUnkOuter
)
{
    // Initialize inner object
    HRESULT hr = E_OUTOFMEMORY;
    m_ImpObj = new CImpAccessControl(this, pUnkOuter, &hr);
    if(m_ImpObj == NULL)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        if (FAILED(hr)) 
        {
            delete m_ImpObj;
            m_ImpObj = NULL;
            return hr;
        }
        return m_ImpObj->Load( NULL );
    }

} // COAccessControl::Init

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::~COAccessControl(), public
//
// Summary: Object destructor. This function does nothing at the moment.
//
// Args:  void
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
COAccessControl::~COAccessControl
(
void
)
{
    // Destroy inner object
    delete m_ImpObj;
    return;
} // COAccessControl::~COAccessControl

// IUnknown methods

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::QueryInterface() , public
//
// Summary: This function queries the COAccessControl object for an
//          interface pointer for the caller.
//
// Args: [in] REFIID riid - Reference to the identifier of the interface
//                          that the client wants.
//       [out] void **ppv - Interface pointer returned.
//
// Modifies: m_cRefs.
//
// Return: HRESULT - S_OK: Succeeded.
//                 - E_NOINTERFACE: The requested interface is not supported.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

STDMETHODIMP_(HRESULT)
COAccessControl::QueryInterface
(
REFIID riid,
void   **ppv
)
{

    HRESULT hr = E_NOINTERFACE;

    // Since the CImpAccessControl class inherits from multiple
    // virtual classes, it is important that the interface pointer
    // returned is type cast properly.
    if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)this;
    }
    else if (IsEqualGUID(riid, IID_IPersist))
    {
        *ppv = (IPersist *)m_ImpObj;
    }
    else if (IsEqualGUID(riid, IID_IPersistStream))
    {
        *ppv = (IPersistStream *)m_ImpObj;
    }
    else if (IsEqualGUID(riid, IID_IAccessControl))
    {
        *ppv = (IAccessControl *)m_ImpObj;
    }
    else
    {
        *ppv = NULL;
    }

    if(*ppv != NULL)
    {

        // Obey COM reference counting rules, call
        // AddRef on the interface pointer returned.
        ((IUnknown *)(*ppv))->AddRef();
        hr = S_OK;
    }
    return hr;

} // COAccessControl::QueryInterface

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::AddRef(), public
//
// Summary: Increments the COAccessControl object reference count.
//
// Args: void
//
// Modifies: m_cRefs.
//
// Return: ULONG
//          New reference count of the object.
//
// Remark: The modification of m_cRefs is made thread-safe by using the
//         InterlockedIncrement function.
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::AddRef
(
void
)
{
    ULONG cRefs = m_cRefs + 1;
    InterlockedIncrement(&m_cRefs);
    return cRefs;
} // COAccessControl::AddRef

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::Release(), public
//
// Summary: Decrements the COAccessControl object reference count and deletes
//          the object when the reference drops to zero. After the object itself
//          is destroyed, this function will also decrement the server's object
//          count. Modification of object's reference count and the server's
//          object count must be made thread-safe by using the
//          InterlockedIncrement and the InterlockedDecrement functions.
//
// Args: void
//
// Modifies: m_cRefs.
//
// Return: ULONG
//          New reference count of the object. This number may not be accurate
//          in a multithreaded environment.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::Release
(
void
)
{
    ULONG cRefs = m_cRefs - 1;
    if(InterlockedDecrement(&m_cRefs) == 0)
    {
        // self-destruct
        delete this;
        return 0;
    }
    else
    {
        return cRefs;
    }

} // COAccessControl::Release

//////////////////////////////////////////////////////////////////////////////
// CImpAccessControl
//////////////////////////////////////////////////////////////////////////////

// Constructor, destructor

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::CImpAccessControl, public
//
// Summary: Object contructor. This function is responsible for initializing
//          the initialization flag and the dirty flag to false, setting
//          the object's two major structures, the ACL descriptor and the
//          pickling control block, to NULL, and initializing the object's
//          outer unknown pointer to point to the appropriate object depending
//          on whether the COAccessControl object is part of an aggregate.
//
// Args: IUnknown *pBackPtr [in] - IUnknown pointer to the outer object ie.
//                                 the COAccessControl control that contains
//                                 the current CImpAccessControl object.
//       IUnknown *pUnkOuter [in] - IUnknown pointer to the controlling unknown
//                                  which is NULL if the COAccessControl object
//                                  is not part of an aggregation.
//       HRESULT *phrCtorResult [out] - Hresult pointer which contains the result
//                                      of the constructor.  Do not use object if
//                                      hr is failed.
//
// Modifies: m_bDirty, m_bInitialized, m_pUnkOuter, m_ACLDesc, m_pcb
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

COAccessControl::CImpAccessControl::CImpAccessControl
(
IUnknown *pBackPtr,
IUnknown *pUnkOuter,
HRESULT *phrCtorResult
)
{
    m_pUnkOuter = (pUnkOuter == NULL) ? pBackPtr : pUnkOuter;
    m_bInitialized = FALSE;
    m_bDirty = FALSE;
    // Initialize the structures within the object...
    memset(&m_ACLDesc, 0, sizeof(ACL_DESCRIPTOR));
    memset(&m_pcb, 0, sizeof(PCB));

    m_bLockValid = NT_SUCCESS(RtlInitializeCriticalSection(&m_ACLLock));

    *phrCtorResult = m_bLockValid ? S_OK : E_OUTOFMEMORY;

    return;
} // COAccessControl::CImpAccessControl::CImpAccessControl


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::~CImpAccessControl(), public
//
// Summary: Object destructor. This function releases all the memory allocated
//          for an initialized CImpAccessControl object and destroys the
//          critical section object for guarding the internal from concurrent
//          access.
//
// Args: void
//
// Modifies: m_ACLDesc, m_pcb.
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
COAccessControl::CImpAccessControl::~CImpAccessControl
(
void
)
{
    if(m_bInitialized)
    {
        CleanAllMemoryResources(&m_ACLDesc, &m_pcb);
    } // if

    if (m_bLockValid)
    {
        DeleteCriticalSection(&m_ACLLock);
    }
}  //COAccessControl::CImpAccessControl:~CImpAccessControl

// IUnknown methods

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::QueryInterface(), public
//
// Summary: This function simply delegates the QueryInterface call to the
//          outer unknown's QueryInterface method.
//
// Args:  REFIID riif [in] - Reference to the interface identifier that signifies
//                           the interface that the client wanted.
//
//
// Return: HRESULT - See outer unknown implementation for details.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::QueryInterface
(
REFIID riid,
void   **ppv
)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
} // COAccessControl:CImpAccessControl::QueryInterface

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::AddRef(), public
//
// Summary: This function simply delegates the AddRef call to the outer unknown's
//          AddRef method.
//
// Args:  void
//
// Modifies: Outer unknown reference count.
//
// Return: HRESULT - See outer unknown implementation for details
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::CImpAccessControl::AddRef
(
void
)
{
    // AddRef of the outer object must be thread-safe
    return m_pUnkOuter->AddRef();
} // COAccessControl::CImpAccessControl::AddRef

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::Release(), public
//
// Summary: This function simply delegates the Release call to the outer unknown's
//          Release method.
//
// Args:  void
//
// Modifies: Outer unknown reference count
//
// Return: ULONG - See outer unknown implementation for details.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::CImpAccessControl::Release
(
void
)
{
    // Release of the outer object must be thread safe
    return m_pUnkOuter->Release();
} // COAccessControl::CImpAccessControl::Release

// IPersist method

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetClassID(), public
//
// Summary: This function returns the class id of the COAccessControl component.
//          pClassID must be pointing to a valid memory block big enough to
//          hold the returned class ID.
//
// Args: CLSID *pCLSID [out] - Pointer to the returned CLSID.
//
// Modifies: Nothing
//
// Return: HRESULT - E_INVALIDARG: pClassID == NULL.
//                   S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetClassID
(
CLSID *pClassID
)
{
    if (pClassID == NULL)
    {
        return E_INVALIDARG;
    } // if
    *pClassID = CLSID_DCOMAccessControl;
    return S_OK;
} // COAccessControl::CImpAccessControl::GetClassID

// IPersistStream methods

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::IsDirty(), public
//
// Summary: This function returns TRUE if the object has been modified since
//          the last time it was saved and FALSE otherwise.
//
// Args: void.
//
// Return: HRESULT - S_OK: The object has changed since the last save.
//                   S_FALSE: The object has not changed since the last save.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::IsDirty
(
void
)
{
    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    return (m_bDirty? S_OK:S_FALSE);
} // COAccessControl::CimpAccessControl::IsDirty


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::Load(), public
//
// Summary: This function is the initialization method of CImpAccessControl
//          and it must be called before any non-IUnknown methods.
//
// Args: IStream *pStm [in] - Interface pointer to a stream object from which
//                            access control data is loaded into the object.
//                            The seek pointer of the stream should be at the
//                            beginning of the stream header.
//                            If pStm is NULL, this function will initialize
//                            an empty DCOM IAccessControl object.
//
// Modifies: m_ACLDesc, m_pcb
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_INVALIDARG: This method will return E_INVALIDARG if
//                                 either
//                                 a) the ACL in the stream provided by the
//                                    user contains an invalid access mask, or
//                                 b) one of STREAM_ACE structure in the ACL
//                                    provided by the user contains a null
//                                    pTrusteeName pointer.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_FAILEDTOGETWINDIR: (Windows 95 only)Unable to obtain
//                                           the Windows directory.
//                   CO_E_PATHTOOLONG: (Windows 95 only)The path generated by
//                                     the GenerateFile function was longer
//                                     than the system's limit.
//                   CO_E_FAILEDTOGENUUID: (Windows 95 only)Unable to generate
//                                         a uuid using the UuidCreate funciton.
//                   CO_E_FAILEDTOCREATEFILE: (Windows 95 only)Unable to create
//                                            a dummy file.
//                   CO_E_FAILEDTOCLOSEHANDLE: Unable to close a serialization
//                                             handle.
//                   CO_E_SETSERLHNDLFAILED: Unable to (re)set a serialization
//                                           handle.
//                   CO_E_EXCEEDSYSACLLIMIT: The number of ACEs in the ACL
//                                           provided by the user exceeded the
//                                           limit imposed by the system that
//                                           is loading the ACL. On Windows 95,
//                                           the system can handle 32767
//                                           ACTRL_ACCESS_DENIED ACEs and 32767
//                                           ACTRL_ACCESS_ALLOWED ACEs. On Windows NT,
//                                           the system can only handle 32767
//                                           ACTRL_ACCESS_DENIED and ACTRL_ACCESS_ALLOWED ACEs
//                                           combined.
//                   CO_E_ACESINWRONGORDER: Not all ACTRL_ACCESS_DENIED ACEs in the ACL
//                                          provided by the user were arranged
//                                          in front of the ACTRL_ACCESS_ALLOWED ACEs.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The ACL provided by the user
//                                                contained a trustee name
//                                                string that didn't conform
//                                                to the <Domain>\<Account>
//                                                syntax.
//                   CO_E_INVALIDSID: (Windows NT only)The ACL provided by the
//                                    user contained an invalid security
//                                    identifier.
//                   CO_E_LOOKUPACCNAMEFAILED: (Window NT only) The system call,
//                                             LookupAccountName, failed. The
//                                             user can call GetLastError to
//                                             obtain extended error information.
//                   CO_E_NOMATCHINGSIDFOUND: (Windows NT only) At least one of
//                                            the trustee name in the ACL provided
//                                            by the user had no corresponding
//                                            security identifier.
//                   CO_E_CONVERSIONFAILED: (Windows 95 only) WideCharToMultiByte
//                                          failed.
//
//                   CO_E_FAILEDTOOPENPROCESSTOKEN: (Windows NT only)The system
//                                                  call, OpenProcessToken,
//                                                  failed. The user can get
//                                                  extended information by
//                                                  calling GetLastError.
//                   CO_E_FAILEDTOGETTOKENINFO: (Windows Nt only)The system call,
//                                              GetTokenInformation, failed.
//                                              The user can call GetLastError to
//                                              get extended error information.
//                   CO_E_DECODEFAILED: Unable to decode the ACL in the
//                                      IStream object.
//                   CO_E_INCOMPATIBLESTREAMVERSION: The version code in the
//                                                   stream header was not
//                                                   supported by this version
//                                                   of IAccessControl.
//                   Error codes from IStream::Read - See the Win32 SDK
//                   documentation for detail descriptions of the following
//                   error codes.
//                   STG_E_ACCESSDENIED:
//                   STG_E_INVALIDPOINTER:
//                   STG_E_REVERTED:
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::Load
(
IStream *pStm
)
{

    HRESULT        hr;                     // Function return code
    ACL_DESCRIPTOR ACLDescBackup;          // Backup of the original ACL descriptor in the object
    PCB            PCBBackup;              // Backup of the original PCB in the object.
	
    // There are too much things happening in this
    // function so I'll simply lock the whole thing
    EnterCriticalSection(&m_ACLLock);

    // Take a snapshot of the old ACL so that if anything goes wrong, I can restore to the
    // old configuration
    memcpy(&PCBBackup, &m_pcb, sizeof(PCB));
    memcpy(&ACLDescBackup,&m_ACLDesc,sizeof(ACL_DESCRIPTOR));

    // Set the original ACL descritpor and the PCB to NULL just to be save
    memset(&m_ACLDesc, 0, sizeof(ACL_DESCRIPTOR));
    memset(&m_pcb, 0, sizeof(PCB));

    if (pStm != NULL)
    {

        // Read the ACL in the stream into the pickle control block
        if(FAILED(hr = ReadACLFromStream(pStm, &m_pcb, &m_ACLDesc)))
        {
            if(hr != CO_E_NOMATCHINGSIDFOUND && hr != CO_E_LOOKUPACCNAMEFAILED)
            {
                goto Error;
            } // if
        }

    }
    else
    {

        if (FAILED(hr = EnlargeStreamACL(&m_pcb, 10)))
        {
            goto Error;
        }
        m_pcb.ulBytesUsed = sizeof(STREAM_ACL)
                          + sizeof(STREAM_ACE)
                          + 256;
        m_pcb.bPickled = FALSE;
        if (FAILED(hr = ResizePicklingBuff(&m_pcb, m_pcb.ulBytesUsed + 800)))
        {
            goto Error;
        }


    } // if (pStm != NULL)
    m_pcb.ulNumOfStreamACEs = m_pcb.StreamACL.ulNumOfDenyEntries
                            + m_pcb.StreamACL.ulNumOfGrantEntries;

    if(FAILED(hr = InitSecDescInACLDesc(&m_ACLDesc)))
    {
        goto Error;
    } // if

    // Create a new pickling handle for the new ACL
    if (MesEncodeFixedBufferHandleCreate( m_pcb.pPicklingBuff
                                        , m_pcb.ulPicklingBuffSize
                                        , &(m_pcb.ulBytesUsed)
                                        , &(m_pcb.PickleHandle)) != RPC_S_OK)
    {
        hr = CO_E_SETSERLHNDLFAILED;
        goto Error;
    } // if

    m_pcb.bDirtyHandle = FALSE;

    if(m_bInitialized)
    {
        CleanAllMemoryResources(&ACLDescBackup, &PCBBackup);
        m_Cache.FlushCache();
    }
    else
    {
        m_bInitialized = TRUE;
    } // if
    // Set dirty flag to false
    m_bDirty = FALSE;

    LeaveCriticalSection(&m_ACLLock);
    return S_OK;

// Error handling code
Error:

    // Cleanup the stream ACL
    if(m_pcb.StreamACL.pACL != NULL)
    {
        CleanUpStreamACL(&(m_pcb.StreamACL));
    }// if

    // Release the decoding handle
    if (m_pcb.PickleHandle != NULL)
    {
        MesHandleFree(m_pcb.PickleHandle);
    } // if

    // Release the pickling buffer
    if (m_pcb.pPicklingBuff != NULL)
    {
        FreePicklingBuff(&m_pcb);
    } // if

    // Restore the old ACL
    memcpy(&m_pcb, &PCBBackup, sizeof(PCB));
    memcpy(&m_ACLDesc, &ACLDescBackup, sizeof(ACL_DESCRIPTOR));
    LeaveCriticalSection(&m_ACLLock);
    return hr;

} // COAccessControl::CImpAccessControl::Load

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::Save(), public
//
// Summary: This function saves the object's ACL to a user provided stream.
//
// Args: IStream *pStm [in,out] - Pointer to a user provided stream object.
//       BOOL fClearDirty [in] - Flag indicating whether the object should clear
//                               its dirty flag after the save.
//
// Modifies: m_bDirty
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//                   E_INVALIDARG: pStm was NULL.
//                   CO_E_SETSERLHNDLFAILED - Failed to (re)set serializtion
//                                            handle.
//                   Error codes that can be returned by the write operation.
//                   See Win32 SDK help for details
//                   STG_E_MEDIUMFULL
//                   STG_E_ACCESSDENIED
//                   STG_E_CANTSAVE
//                   STG_E_INVALIDPOINTER
//                   STG_E_REVERTED
//                   STG_E_WRITEFAULT
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::Save
(
IStream *pStm,
BOOL    fClearDirty
)
{
    HRESULT        hr = S_OK;
    handle_t       HeaderHandle;
    CHAR           HeaderBuffer[64];
    CHAR           *pHeaderBuffPtr;
    STREAM_HEADER  StreamHeader;
    LARGE_INTEGER  liOffset;
    ULONG          ulEncodedSize;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (pStm == NULL)
    {
        return E_INVALIDARG;
    } // if

    // Other threads shouldn't mess with the object
    // when the object is saving its state

    EnterCriticalSection(&m_ACLLock);

    if (m_pcb.bDirtyHandle)
    {

        if (MesBufferHandleReset( m_pcb.PickleHandle
                                , MES_FIXED_BUFFER_HANDLE
                                , MES_ENCODE
                                , &(m_pcb.pPicklingBuff)
                                , m_pcb.ulPicklingBuffSize
                                , &(m_pcb.ulBytesUsed)) != RPC_S_OK)

        {
            hr = CO_E_SETSERLHNDLFAILED;
            goto Error;
        } // if

        m_pcb.bDirtyHandle = FALSE;

    } // if

    if (!(m_pcb.bPickled))
    {
        // Encode the STREAM_ACL structure into the pickling buffer
        STREAM_ACL_Encode(m_pcb.PickleHandle, &(m_pcb.StreamACL));
        m_pcb.bPickled = TRUE;
        m_pcb.bDirtyHandle = TRUE;
    } // if

    pHeaderBuffPtr = (CHAR *)(((ULONG_PTR)HeaderBuffer + 8) & ~7);

    // Create encoding handle
    if (MesEncodeFixedBufferHandleCreate( pHeaderBuffPtr
                                        , 56
                                        , &ulEncodedSize
                                        , &HeaderHandle ) != RPC_S_OK)
    {
        hr = CO_E_SETSERLHNDLFAILED;
        goto Error;
    } // if


    StreamHeader.ulStreamVersion = STREAM_VERSION;
    StreamHeader.ulPickledSize = m_pcb.ulBytesUsed;

    STREAM_HEADER_Encode(HeaderHandle, &StreamHeader);

    MesHandleFree(HeaderHandle);

    if(FAILED(hr = pStm->Write(pHeaderBuffPtr, ulEncodedSize, NULL)))
    {
        goto Error;
    } // if

    // Write encoded buffer to stream
    hr = pStm->Write(m_pcb.pPicklingBuff, m_pcb.ulBytesUsed, NULL);
    if (FAILED(hr))
    {
        goto Error;
    } // if

    // Reset the object's dirty flag if the user say so
    if (fClearDirty)
    {
        m_bDirty = FALSE;
    } // if

Error:
    LeaveCriticalSection(&m_ACLLock);
    return hr;

} // COAccessControl::CImpAccessControl::Save

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetSizeMax(), public
//
// Summary: This function returns the number of bytes required to store the
//          object's ACL to a stream. Notice that only the lower 32-bit of the
//          the ULARGE_INTEGER *pcbSize is used.
//
// Args: ULARGE_INTEGER *pcbSize [in] - Number of bytes required to store the
//                                      object's ACL.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//                   CO_E_SETSERLHNDLFAILED: Failed to reset the serialization
//                                           handle.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetSizeMax
(
ULARGE_INTEGER *pcbSize
)
{
    HRESULT       hr = S_OK;
    STREAM_HEADER StreamHeader;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;
    if (pcbSize == NULL)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ACLLock);
    if (m_pcb.bDirtyHandle)
    {

        if (MesBufferHandleReset( m_pcb.PickleHandle
                                , MES_FIXED_BUFFER_HANDLE
                                , MES_ENCODE
                                , &(m_pcb.pPicklingBuff)
                                , m_pcb.ulPicklingBuffSize
                                , &(m_pcb.ulBytesUsed)) != RPC_S_OK)

        {
            hr = CO_E_SETSERLHNDLFAILED;
            goto Error;
        } // if

        m_pcb.bDirtyHandle = FALSE;

    } // if

    if (!(m_pcb.bPickled))
    {
        STREAM_ACL_Encode(m_pcb.PickleHandle, &(m_pcb.StreamACL));
        m_pcb.bPickled = TRUE;
        m_pcb.bDirtyHandle = TRUE;

    } // if

    pcbSize->HighPart = 0;
    pcbSize->LowPart  = m_pcb.ulBytesUsed + g_ulHeaderSize;

Error:
    LeaveCriticalSection(&m_ACLLock);
    return hr;
} // COAccessControl::CImpAccessControl::GetSizeMax

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GrantAccessRights()
//
// Args:
//       PACTRL_ACCESSW [in] - The array of ACTRL_ACCCESS_ENTRY structures to
//                             be processed.
// Modifies: m_ACLDesc, m_bDirty
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//                   E_INVALIDARG: This method will return E_INVALIDARG if
//                                 one of the following is true:
//                      1) One of the access mask specfied by the user is
//                         invalid.
//                      2) The pMultipleTrustee field in one of the user
//                         specified TRUSTEE_W structure is not NULL.
//                      3) The MultipleTrusteeOPeration field in one of the
//                         user specified TRUSTEE_W structure is not
//                         NO_MULTIPLE_TRUSTEE.
//                      4) The TrusteeType field in one of the user specified
//                         TRUSTEE_W structure has the value TRUSTEE_IS_UNKNOWN.
//                      5) (On Windows 95 only) The TrusteeForm field in one
//                         of the user specified TRUSTEE_W structure has
//                         the value TRUSTEE_IS_SID.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operations.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: One of the trustee name
//                      specified by the client didn't conform to the
//                      <Domain>\<Account> syntax.
//                   CO_E_INVALIDSID: One of the security identifiers
//                      specified by the client was invalid.
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed during the reprocessing
//                          of the ACL. The client can call GetLastError to
//                          obtain extended error inforamtion.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed during the reprocessing
//                          of the ACL. The client can call GetLastError
//                          to obtain extended error information.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GrantAccessRights
(
PACTRL_ACCESSW pAccessList
)
{

    STREAM_ACE        *pStreamACEReqs;     // Pointer to an array
                                           // of stream ACEs
                                           // converted from the
                                           // access request list
    ULONG             ulEstPickledSize;
    HRESULT           hr = S_OK;
    void             *pACEReqs;
    ULONG             cGrant;
    ULONG             cDeny;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (FAILED(hr = ValidateAndTransformAccReqList( pAccessList
                                                  , &pStreamACEReqs
                                                  , &pACEReqs
                                                  , &ulEstPickledSize
                                                  , &cGrant
                                                  , &cDeny )))
    {
        return hr;
    } // if

    EnterCriticalSection(&m_ACLLock);

    hr = AddAccessList( pStreamACEReqs, pACEReqs, ulEstPickledSize, cGrant,
                        cDeny );

    LeaveCriticalSection(&m_ACLLock);

    CleanupAccessList( FAILED(hr), pStreamACEReqs, pACEReqs, cGrant, cDeny );
    return hr;

} // COAccessControl::CImpAccessControl::GrantAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
//
// Method: COAccessControl::CImpAccessControl::CleanupAccessList()
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(void)
COAccessControl::CImpAccessControl::CleanupAccessList
(
BOOL           fReleaseAll,
STREAM_ACE    *pStreamACEReqs,
void          *pvACEReqs,
ULONG          cGrant,
ULONG          cDeny
)
{
    ULONG              cCount;
    ULONG              i;
    STREAM_ACE        *pStreamACEReqsPtr;  // Pointer for stepping
                                           // through the array of
                                           // access requests
                                           // transformed into
                                           // STREAM_ACE structures

    if (fReleaseAll)
    {
        cCount = cGrant + cDeny;
        pStreamACEReqsPtr = pStreamACEReqs;
        for (i = 0; i < cCount; i++, pStreamACEReqsPtr++)
        {
            midl_user_free(pStreamACEReqsPtr->pTrusteeName);
            midl_user_free(pStreamACEReqsPtr->pSID);
        } // for
    }
    LocalMemFree(pStreamACEReqs);
}

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
//
// Method: COAccessControl::CImpAccessControl::AddAccessList()
//
// Notes: This function assumes that the access list has been validated.  It
//        Can only fail if it runs out of memory.  In all failure conditions
//        the object's state is unchanged.  The caller must take the lock.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::AddAccessList
(
STREAM_ACE    *pStreamACEReqs,
void          *pvACEReqs,
ULONG          ulEstPickledSize,
ULONG          cGrant,
ULONG          cDeny
)
{

    ULONG             i;                   // Loop counters
    STREAM_ACE        *pStreamACEReqsPtr;  // Pointer for stepping
                                           // through the array of
                                           // access requests
                                           // transformed into
                                           // STREAM_ACE structures
    HRESULT           hr = S_OK;
    ULONG             cCount;

    // Extend the stream ACL, the ACL image and the pickling
    // buffer to accomodate the new entries
    cCount = cGrant + cDeny;
    if(FAILED(hr = EnlargeStreamACL( &m_pcb
                                   , m_pcb.ulNumOfStreamACEs
                                   + cCount)))
    {
        return hr;
    } // if

    if(FAILED(hr = ResizePicklingBuff( &m_pcb, m_pcb.ulBytesUsed
                                     + ulEstPickledSize
                                     + 800)))
    {
        return hr;
    } // if
    m_pcb.ulBytesUsed += ulEstPickledSize;

    for ( pStreamACEReqsPtr = pStreamACEReqs,i = 0
        ; i < cCount
        ; i++
        , pStreamACEReqsPtr++)
    {


        m_ACLDesc.ulSIDSize += GetLengthSid(pStreamACEReqsPtr->pSID);
        AddACEToStreamACL(pStreamACEReqsPtr, &m_pcb);

    } // for

    // fixing up the cache
    m_Cache.FlushCache();

    // Re-compute the encoded size of the stream ACL
    m_pcb.bPickled = FALSE;
    m_bDirty = TRUE;
    m_ACLDesc.bDirtyACL = TRUE;

    return S_OK;

} // COAccessControl::CImpAccessControl::GrantAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::SetOwner(), public
//
// Summary: This method is not implemented at this moment
//
// Args:
//
// Modifies:
//
// Return: HRESULT - This method will always return E_NOTIMPL.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::SetOwner
(
PTRUSTEEW pOwner,
PTRUSTEEW pGroup
)
{
    return E_NOTIMPL;
} // COAccessControl::CimpAccessControl::SetOwner

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::SetAccessRights(), public
//
// Summary: This function replace the internal ACL with an array of
//          ACTRL_ACCESS_ENTRY structures provided by the caller of this method.
//          Note that this function does not literally replace the internal
//          ACL, instead it will map the array of ACTTRL_ACCESS_ENTRY structures
//          into the internal representation of an ACL.
//          This function will also merge entries with the same access mode
//          and trustee name together into one internal ACE.
//
// Args:
//       PACTRL_ACCESSW [in] - The array of ACTRL_ACCCESS_ENTRY structures to
//                             be processed.
//
// Modifies: m_ACLDesc, m_bDirty, m_pcb
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_INVALIDARG: This method will return E_INVALIDARG if one of
//                                 the following is true:
//                   1) pExplicitAccessList is a NULL pointer.
//                   2) Inside one of the ACTRL_ACCESS_ENTRY structures specified
//                      by the client, either
//                      i) the grfAccessPermissions field contained an invalid
//                         access mask, or
//                      ii) the grfAccessMode field was neither ACTRL_ACCESS_ALLOWED
//                          nor ACTRL_ACCESS_DENIED, or
//                      iii) the grfInheritace field was not NO_INHERITANCE or
//                      iv) the pMultipleTrustee field in the TRUSTEE_W structure
//                          was not NULL, or
//                      v) the MultipleTrusteeOperation field in the TRUSTEE_W
//                         structure was not NO_MULTIPLE_TRUSTEE, or
//                      vi) the TrusteeType field in the TRUSTEE_Wstructure was
//                          TRUSTEE_IS_UNKNOWN, or
//                      vii) the ptstrNameFiled in the TRUSTEE_W structure was
//                           NULL, or
//                      On Windows 95 only:
//                      viii) the TrusteeForm field inside the TRUSTEE_W
//                            structure was TRUSTEE_IS_SID.
//                   E_OUTOFMEMORY: The system ran out of memory for crucial
//                                  operation.
//                   CO_E_ACNOTINITIALIZED: The DCOM IAccessCOntrol object was
//                                        not initialized by the load method
//                                        before this method is called.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee name in the
//                          TRUSTEE_W structure inside one of the ACTRL_ACCESS_ENTRY
//                          structure specified by the client didn't conform to the
//                          <Domain>\<Account> syntax.
//                   CO_E_INVALIDSID: The security identifier in the TRUSTEE_W
//                                    structure inside one of the ACTRL_ACCESS_ENTRY
//                                    structure specified by the client was
//                                    invalid.
//                   (The following error codes are for Windows NT only)
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed during the reprocessing
//                          of the ACL. The client can call GetLastError to
//                          obtain extended error inforamtion.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed during the reprocessing
//                          of the ACL. The client can call GetLastError to
//                          obtain extended error information.
//
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::SetAccessRights
(
PACTRL_ACCESSW pAccessList
)
{
    ACL_DESCRIPTOR     ACLDescBackup;      // Backup copy of the object's
                                           // original ACL descriptor
    PCB                pcbBackup;          // Backup copy of the object's
                                           // original pickle control
                                           // block
    STREAM_ACE        *pStreamACEReqs;     // Pointer to an array
                                           // of stream ACEs
                                           // converted from the
                                           // access request list
    ULONG             ulEstPickledSize;
    HRESULT           hr = S_OK;
    void             *pACEReqs;
    ULONG             cGrant;
    ULONG             cDeny;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (FAILED(hr = ValidateAndTransformAccReqList( pAccessList
                                                  , &pStreamACEReqs
                                                  , &pACEReqs
                                                  , &ulEstPickledSize
                                                  , &cGrant
                                                  , &cDeny )))
    {
        return hr;
    } // if

    EnterCriticalSection(&m_ACLLock);

    // Take a snapshot of the old ACL descriptor and the old PCB
    memcpy(&ACLDescBackup, &m_ACLDesc, sizeof(ACL_DESCRIPTOR));
    memset(&m_ACLDesc, 0, sizeof(ACL_DESCRIPTOR));

    memcpy(&pcbBackup, &m_pcb, sizeof(PCB));
    memset(&m_pcb, 0, sizeof(PCB));

    // Try to add the new entries.
    hr = AddAccessList( pStreamACEReqs, pACEReqs, ulEstPickledSize, cGrant,
                        cDeny );

    // If successful, move some resources from the backup
    if (SUCCEEDED(hr))
    {
        memcpy(&(m_ACLDesc.SecDesc),&(ACLDescBackup.SecDesc), sizeof(SECURITY_DESCRIPTOR));
        ACLDescBackup.SecDesc.Owner  = NULL;
        ACLDescBackup.SecDesc.Group  = NULL;
        m_ACLDesc.bDirtyACL          = TRUE;

        m_pcb.PickleHandle     = pcbBackup.PickleHandle;
        pcbBackup.PickleHandle = NULL;

        // Free the old ACL descriptor and PCB
        CleanAllMemoryResources(&ACLDescBackup, &pcbBackup);
    }

    // Restore the orignal ACL and PCB
    else
    {
        // Free the new ACL descriptor and PCB
        CleanAllMemoryResources(&m_ACLDesc, &m_pcb);

        memcpy(&m_ACLDesc, &ACLDescBackup, sizeof(ACL_DESCRIPTOR));
        memcpy(&m_pcb, &pcbBackup, sizeof(PCB));
    }
    LeaveCriticalSection(&m_ACLLock);

    CleanupAccessList( FAILED(hr), pStreamACEReqs, pACEReqs, cGrant, cDeny );
    return hr;

} // COAccessControl::CImpAccessControl::SetAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::RevokeAccessRights()
//         , public
//
// Summary: This function removes all ACEs (both ACTRL_ACCESS_ALLOWED mode and
//          ACTRL_ACCESS_DENIED mode entries) associated with the list of of trustees
//          listed in pTrustee from the object's internal ACL.
//
// Args:
//       LPWSTR    lpProperty [in] - Property name, must be NULL.
//       ULONG     cCount     [in] - Number of trustee to be revoked from the
//                                   ACL.
//       TRUSTEE_W pTrustee   [in] - A list of trustees to be revoked.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED
//                   E_INVALIDARG: Either pTrustee was NULL, or cCount was
//                                 zero, or one of the following was true
//                                 about at least one of the TRUSTEE_W structure
//                                 specified by the user:
//
//            1) The value of the pMultipleTrustee field in the TRUSTEE_W
//               structure was not NULL.
//            2) The value of the MultipleTrusteeOperation field in the
//               TRUSTEE_W structure was not NO_MULTIPLE_TRUSTEE.
//            3) The value of the TrusteeType field in the TRUSTEE_W
//               structure was TRUSTEE_IS_UNKNOWN.
//            4) The value of the ptstrName field in the TRUSTEE_W structure
//               was NULL.
//            On Windows 95 only:
//            5) The value of the TrusteeForm field in the TRUSTEE_W structure
//               was TRUSTEE_IS_SID.
//                   CO_E_WORNGTRUSTEENAMESYNTAX: At least one of the TRUSTEE_W
//                                                structures specified by the
//                                                user contained a trustee name
//                                                that did not conform to the
//                                                <Domain>/<Account Name>
//                                                syntax.
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//                   E_OUTOFMEMORY: There was not enough memory for allocating
//                                  a string conversion buffer.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::RevokeAccessRights
(
LPWSTR    lpProperty,
ULONG     cCount,
TRUSTEE_W pTrustee[]
)
{
    BOOL     bDeleted = FALSE;    // This flag indicates if any entry is
                                  // removed from theACL.
    ULONG     i;                  // Loop counter
    HRESULT   hr;                 // Function return code
    TRUSTEE_W *pLocalTrustee;     // Pointer for traversing the list of
                                  // trustees.
    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (cCount == 0 || lpProperty != NULL)
    {
        return E_INVALIDARG;
    } // if


    // The following loop validates the TRUSTEE_W structures
    // specified by the user. On Windows 95, this function
    // will also determine the length of the longest trustee
    // name in multibyte characters.
    pLocalTrustee = pTrustee;
    for (i = 0; i < cCount; i++, pLocalTrustee++)
    {

        if(FAILED(hr = ValidateTrustee(pLocalTrustee)))
        {
            return hr;
        } // if
    } // for

    EnterCriticalSection(&m_ACLLock);


    pLocalTrustee = pTrustee;
    for (i = 0; i < cCount ; i++, pLocalTrustee++)
    {
        if (DeleteACEFromStreamACL( pLocalTrustee
                                  , ACTRL_ACCESS_DENIED
                                  , &m_ACLDesc
                                  , &m_pcb))
        {
            bDeleted = TRUE;
        } // if

        if (DeleteACEFromStreamACL( pLocalTrustee
                                  , ACTRL_ACCESS_ALLOWED
                                  , &m_ACLDesc
                                  , &m_pcb))
        {
            bDeleted = TRUE;
        } // if

    } // for

    if (bDeleted)
    {
        m_bDirty = TRUE;
        m_ACLDesc.bDirtyACL = TRUE;

        // Fix up the cache
        m_Cache.FlushCache();
        m_pcb.bPickled = FALSE;
    } // if

    LeaveCriticalSection(&m_ACLLock);

    return S_OK;

} // COAccessControl::CImpAccessControl::RevokeAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::IsAccessAllowed(), public
//
// Summary: This function performs access checking for the client.
//          Only the execute permission is supported at this moment and the
//          the trustee specified by the client must be the client itself.
//
// Args:
//       TRUSTEE      *pTrustee     [in]     - Pointer to the trustee to
//                                             perform access check for.
//       LPWSTR        lpProperty   [in]     - Must be NULL.
//       ACCESS_RIGHTS AccessRights [in]     - A bit mask representing the set
//                                             of permissions the client wants
//                                             to check.
//       BOOL         *pfAccessAllowed [out] - Set TRUE only if trustee has
//                                             requested access.
//
// Common on both Windows 95 and Windows NT:
// Return: HRESULT - S_OK: Succeeded, and the requested access was granted to
//                         the trustee.
//                   CO_E_ACNOTINITIALIZED: The COM IAccessControl object
//                                        was not initialized before
//                                        this method was called.
//                   E_ACCESSDENIED: The requested access was denied
//                                   from the trustee.
//                   E_INVALIDARG: Either one of the following was true:
//
//            1) The value of the pMultipleTrustee field in the TRUSTEE_W
//               structure was not NULL.
//            2) The value of the MultipleTrusteeOperation field in the
//               TRUSTEE_W structure was not NO_MULTIPLE_TRUSTEE.
//            3) The value of the TrusteeType field in the TRUSTEE_W
//               structure was TRUSTEE_IS_UNKNOWN.
//            4) The value of the ptstrName field in the TRUSTEE_W structure
//               was NULL.
//
//                   CO_E_TRUSTEEDOESNTMATCHCLIENT: The trustee specified by the
//                                                  client was not the current
//                                                  ORPC client.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee name inside the
//                                                TRUSTEE_W structure specified
//                                                by the user is not of the
//                                                form <Domain>\<Account Name>.
//                   CO_E_FAILEDTOQUERYCLIENTBLANKET: Unable to query for the
//                                                    client's security blanket.
//                   E_UNEXPECTED: This function should not return E_UNEXPECTED
//                                 under all circumstances.
//
//
// On Windows 95
// Return: HRESULT - E_INVALIDARG: In addition to the four cases stated above,
//                                 E_INVALIDARG will be returned if the
//                                 TrusteeForm field of the TRUSTEE_W structure
//                                 pointed to by the pTrustee parameter is
//                                 TRUSTEE_IS_SID.
//                   CO_E_NETACCESSAPIFAILED: Either the NetAccessAdd API or
//                                            the NetAccessDel APi returned
//                                            an error code in
//                                            ComputeEffectiveAccess.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned zero.
//                                          The caller can get extended error
//                                          information by calling GetLastError.
//                   E_OUTOFMEMORY: Either there was not enough memory to
//                                  convert the Unicode trustee name into a
//                                  multibyte string in
//                                  ValidateAccessCheckClient of there
//                                  was not enough memory to do the same in
//                                  ComputeEffectiveAccess.
// On Windows NT:
//                   CO_E_FAILEDTOGETSECCTX: Failed to obtain an IServerSecurity
//                                           pointer to the current server
//                                           security context.
//                   CO_E_FAILEDTOIMPERSONATE: The GetEffAccUsingSID/Name was
//                                             unable to impersonate
//                                             the client who calls this
//                                             function.
//                   CO_E_FAILEDOPENTHREADTOKEN: The GetEffAccUsingSID/Name
//                                               method was unable to open the
//                                               access token assciated
//                                               with the current thread. The
//                                               client of this method can
//                                               call GetLastError to get
//                                               extended error information.
//                   CO_E_FAILEDTOGETTOKENINFO: The GetEffAccUsingSID/Name
//                                              method was unable to obtain
//                                              obtain information from the
//                                              access token associated with
//                                              the current thread. The client
//                                              of this method can call
//                                              GetLastError to get extended
//                                              error information.
//                   CO_E_ACCESSCHECKFAILED: The system function, AccessCheck,
//                                           returned FALSE in
//                                           ComputeEffectiveAccess. The
//                                           caller of this method can call
//                                           GetLastError to obtain extended
//                                           error information.
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   E_OUTOFMEMORY: The system ran out of memory for mapping the
//                                  DCOM IAccessControl object's STREAM_ACL
//                                  structure to an NT ACL or the system
//                                  could not allocate memory for the TOKEN_USER
//                                  structure returned by GetTokenInformation.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::IsAccessAllowed
(
TRUSTEE_W     *pTrustee,
LPWSTR         lpProperty,
ACCESS_RIGHTS  AccessRights,
BOOL          *pfAccessAllowed
)
{
    DWORD   dwPermissions = 0;
    HRESULT hr;

    // Initialize access allowed to FALSE.
    if (pfAccessAllowed == NULL)
    {
        return E_INVALIDARG;
    }
    *pfAccessAllowed = FALSE;

    // Validate the arguments.
    if (!IsValidAccessMask(AccessRights) ||
        lpProperty != NULL)
    {
        return E_INVALIDARG;
    } // if
    if (FAILED(hr = ValidateAccessCheckClient(pTrustee)))
    {
        return hr;
    } // if

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    hr = GetEffAccRights( pTrustee , &dwPermissions );

    if(FAILED(hr))
    {
        return hr;
    }

    // Indicate failure by setting pfAccessAllowed.
    if ((dwPermissions & AccessRights) == AccessRights)
    {
        *pfAccessAllowed = TRUE;
    }
    return S_OK;

} // COAccessControl::CImpAccessControl::IsAccessAllowed

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetEffAccRights, Private
//
// Summary: Given a Unicode string representing the name of a user, this
//          function computes the effective access permission that the
//          specified user has on the secured object. Notice that the current
//          implementation of this method limits the trustee specified by the
//          client to be the name of the same client calling this method.
//
// Args: LPWSTR pwszTrusteeName [in] - Pointer to a Unicode string
//                                     representing the user whose effective
//                                     access permissions on the secured object
//                                     is about to be determined by this
//                                     method. Notice that this parameter must
//                                     specify the name of the client calling
//                                     this function.
//       DWORD *pdwRights [out] - Address of an access mask representing the
//                                set of effective access rights the user
//                                specified by the pwszTrusteeName parameter
//                                has on the secured object.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_FAILEDTOGETSECCTX: Failed to obtain an IServerSecurity
//                                           pointer to the current server
//                                           security context.
//                   CO_E_FAILEDTOIMPERSONATE: This method was unable to
//                                             impersonate the client who calls
//                                             this function.
//                   CO_E_FAILEDOPENTHREADTOKEN: This method was unable to
//                                               open the access token assciated
//                                               with the current thread. The
//                                               client of this method can call
//                                               GetLastError to get extended
//                                               error information.
//                   CO_E_FAILEDTOGETTOKENINFO: This method was unable to obtain
//                                              obtain information from the
//                                              access token associated with
//                                              the current thread. The client
//                                              of this method can call
//                                              GetLAstError to get extended
//                                              error information.
//                   CO_E_FAILEDTOQUERYCLIENTBLANKET: Failed to query for the
//                                                    client's security blanket.
//                   CO_E_ACCESSCHECKFAILED: The system function, AccessCheck,
//                                           returned FALSE in
//                                           ComputeEffectiveAccess. The
//                                           caller of this method can call
//                                           GetLastError to obtain extended
//                                           error information.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   E_OUTOFMEMORY: The system ran out of memory for mapping the
//                                  DCOM IAccessControl object's STREAM_ACL
//                                  structure to an NT ACL or the system
//                                  could not allocate memory for the TOKEN_USER
//                                  structure returned by GetTokenInformation.
//
// Remarks: It is neccessary for this method to impersonate the client
//          in order to obtain the client's access token for access checking.
//          If the call context has the impersonate flag TRUE, the server
//          may be impersonating anyone and we must save the current thread
//          token and restore it before returning.  We cannot call Revert
//          because that would change the server's state.  If the call
//          context does not have the impersonate flag TRUE, we can do
//          anything to the thread token after impersonating because Revert
//          will restore the token that was on the thread on entry to this
//          method.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetEffAccRights
(
TRUSTEE_W *pTrustee,
DWORD     *pdwRights
)
{
    IServerSecurity *pSSec                 = NULL;
    HRESULT          hr                    = S_OK;
    BOOL             bImpersonatingOnEnter = FALSE;
    BOOL             bImpersonated         = FALSE;
    HANDLE           hEnter                = INVALID_HANDLE_VALUE;
    HANDLE           hImpersonate          = INVALID_HANDLE_VALUE;
    TOKEN_STATISTICS sTokenStatistics;
    DWORD            dwInfoLength          = sizeof(sTokenStatistics);
    BOOL             bSuccess;

    // Call get call context to obtain an IServerSecurity
    // pointer corresponding to the call context of the
    // current thread.
    hr = CoGetCallContext( IID_IServerSecurity
                         , (void **)&pSSec);
    if (FAILED(hr))
    {
        return CO_E_FAILEDTOGETSECCTX;
    } // if

    EnterCriticalSection(&m_ACLLock);

    // Check if the server is already impersonating someone.  If so,
    // save that token.  Ignore errors since there is no possible recovery.
    bImpersonatingOnEnter = pSSec->IsImpersonating();
    if (bImpersonatingOnEnter)
    {
        OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE, &hEnter );
    } // if

    // Impersonate the server's current caller.
    hr = pSSec->ImpersonateClient();
    if (FAILED(hr))
    {
        hr = CO_E_FAILEDTOIMPERSONATE;
        goto Error;
    } // if
    bImpersonated = TRUE;

    // Open the current thread token, it should be the
    // access token of the client.
    bSuccess = OpenThreadToken( GetCurrentThread()
                              , TOKEN_READ
                              , TRUE
                              , &hImpersonate);
    if (!bSuccess)
    {
        hr = CO_E_FAILEDTOOPENTHREADTOKEN;
        goto Error;
    } // if

    // Remove the thread token so the APIs below succeed.  Ignore errors
    // because there is no possible recovery.
    Verify( SetThreadToken( NULL, NULL ) );

    // Get the SID from the access token for cache lookup
    bSuccess = GetTokenInformation( hImpersonate
                                  , TokenStatistics
                                  , &sTokenStatistics
                                  , dwInfoLength
                                  , &dwInfoLength );
    if (!bSuccess)
    {
        hr = CO_E_FAILEDTOGETTOKENINFO;
        goto Error;
    } // if

    // Use the SID inside ClientInfo to lookup the
    // the effective access rights in the cache
    bSuccess = m_Cache.LookUpEntry(sTokenStatistics.ModifiedId, pdwRights);
    if (!bSuccess)
    {
        // Perform access checking
        hr = ComputeEffectiveAccess( &m_ACLDesc
                                   , &(m_pcb.StreamACL)
                                   , hImpersonate
                                   , pdwRights);
        if (FAILED(hr))
        {
            goto Error;
        } // if
        m_Cache.WriteEntry(sTokenStatistics.ModifiedId, *pdwRights);
    } // if

Error:
    LeaveCriticalSection(&m_ACLLock);

    // Release the impersonation token handle
    if (hImpersonate != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hImpersonate);
    } // if

    // Restore the impersonation status
    if (bImpersonated)
    {
        // If the server was impersonating, don't Revert.
        if (bImpersonatingOnEnter)
            Verify( SetThreadToken( NULL, hEnter ) );
        else
            pSSec->RevertToSelf();
    } // if

    // Release the saved token handle
    if (hEnter != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hEnter);
    } // if

    // Release the IServerSecurity pointer
    if (pSSec != NULL)
    {
        pSSec->Release();
    } // if

    return hr;

} // COAccessControl::CImpAccessControl:GetEffAccRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetAllAccessRights(), public
//
// Summary: This function returns an array of ACTRL_ACCESS_ENTRY structures which
//          represents the ACL that belongs to the secured object. Notice
//          that memory is allocated by the callee for the array of
//          structures and the trustee string within each
//          structure.  The client of this method must call
//          CoTaskMemFree to free those memory blocks when they are no longer
//          in use. Notice that in a multi-threaded environment, the array
//          returned may not accurately represent the object's ACL by
//          the time the caller receives it.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: Not enough memory to allocate the
//                                  ACTRL_ACCESS_ENTRY array to be return.
//                   E_INVALIDARG: If one of the arguments passed in is NULL
//                   CO_E_ACNOTINITIALIZED: The DCOM IAccessControl implementation
//                                        object was not initialized properly
//                                        by the load method before this method
//                                        was called.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetAllAccessRights
(
LPWSTR              lpProperty,
PACTRL_ACCESSW     *ppAccessList,
PTRUSTEEW          *ppOwner,
PTRUSTEEW          *ppGroup
)
{
    HRESULT  hr = S_OK;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    // Validate the arguments
    if (lpProperty != NULL || ppAccessList == NULL)
    {
        return E_INVALIDARG;
    } // if

    if (ppOwner != NULL)
    {
        *ppOwner = NULL;
    }
    if (ppGroup != NULL)
    {
        *ppGroup = NULL;
    }

    EnterCriticalSection(&m_ACLLock);

    hr = MapStreamACLToAccessList( &m_pcb, ppAccessList );

    LeaveCriticalSection(&m_ACLLock);
    return hr;
} // COAccessControl::CImpAccessControl::GetAllAccessRights

//////////////////////////////////////////////////////////////////////////////
// Miscellaneous utility functions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// functions that are common on both platform
//////////////////////////////////////////////////////////////////////////////

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ResizePicklingBuff
//
// Summary: This function resize the pickling buffer within a pickling
//          control block. Note that this function doesn't copy the content
//          in the old buffer over to the new buffer.
//
// Args: PCB *ppcb [in,out] - Pointer to the pickling control block
//                            that contains the pickling buffer to be resized.
//       ULONG ulBytesRequired [in] - Number of bytes required in the new
//                                    pickling buffer.
//
// Return: HRESULT - S_OK: Success.
//                   E_OUTOFMEMORY: Out of memory.
//
// Called by: COAccessControl::CImpAccessControl::Load
//            AddACEToACL
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ResizePicklingBuff
(
PCB    *ppcb,
ULONG  ulBytesRequired
)
{
    CHAR *pNewTruePointer;

    if (ulBytesRequired > ppcb->ulPicklingBuffSize)
    {
        pNewTruePointer = (CHAR *)LocalMemAlloc((ulBytesRequired + 7));
            // At most 7 more bytes are needed to align the pickling buffer
        if (pNewTruePointer == NULL)
        {
            return E_OUTOFMEMORY;
        } // if

        LocalMemFree(ppcb->pTruePicklingBuff);

        ppcb->pTruePicklingBuff = pNewTruePointer;
        // 8-byte align the pickling buffer
        ppcb->pPicklingBuff = (char *)(((ULONG_PTR)(pNewTruePointer + 7))&~7);
        ppcb->ulPicklingBuffSize = ulBytesRequired;
        ppcb->bDirtyHandle = TRUE;
    } // if
    return S_OK;
} // ResizePicklingBuff

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: FreePicklingBuff
//
// Summary: This function releases the memmory allocated for a pickling
//          buffer.
//
// Args: PCB *ppcb [in] - Pickling control block that contains the pickling
//                        buffer to be released
//
// Return: void
//
// Called by: CleanAllMemoryResources
//            COAccessControl::CImpAccessControl::Load
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void FreePicklingBuff
(
PCB *ppcb
)
{
  LocalMemFree(ppcb->pTruePicklingBuff);
  ppcb->pPicklingBuff = NULL;
  ppcb->pTruePicklingBuff = NULL;
  ppcb->ulPicklingBuffSize = 0;

} // FreePicklingBuff

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: EnlargeStreamACL
//
// Summary: This function reallocates the stream ACE array inside a pickle
//          control block to a bigger memory block in order to accomodate the
//          the extra number of stream ACEs needed by the user.
//
// Args: PCB *ppcb [in] - Pickle control block containing the stream ACE array
//                        to be resized.
//
// Return: HRESULT - S_OK: Success
//                   E_OUTOFMEMORY: Out of memory
//
// Called by: AddACEToACL
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT EnlargeStreamACL
(
PCB   *ppcb,
ULONG ulNumOfEntries
)
{
    ULONG         ulNewSize;
    ULONG         ulOldSize;
    STREAM_ACE    *pNewStreamACL;

	// Check for arithmetic overflow
	if(ulNumOfEntries + ppcb->ulNumOfStreamACEs < ulNumOfEntries)
		return E_OUTOFMEMORY;
	
    if (ulNumOfEntries + ppcb->ulNumOfStreamACEs > ppcb->ulMaxNumOfStreamACEs)
    {
        ulNewSize = ppcb->ulMaxNumOfStreamACEs + ulNumOfEntries;

        pNewStreamACL = (STREAM_ACE *)midl_user_allocate((ulNewSize + 10)
                      * sizeof(STREAM_ACE));
        if (pNewStreamACL == NULL)
        {
            return E_OUTOFMEMORY;
        } // if

        if (ppcb->StreamACL.pACL != NULL)
        {
            memcpy( pNewStreamACL
                  , ppcb->StreamACL.pACL
                  , ppcb->ulNumOfStreamACEs * sizeof(STREAM_ACE));
            midl_user_free(ppcb->StreamACL.pACL);
        } // if

        ppcb->ulMaxNumOfStreamACEs = ulNewSize;
        ppcb->StreamACL.pACL = pNewStreamACL;
    } // if

    return S_OK;
} // EnlargeStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ReadACLFromStream
//
// Summary: This function reads an ACL from an IStream object into the
//          STREAM_ACL struture of an pickle control block.
//
// Args: IStream *pStm [in] - Pointer to an IStream object containing
//                           an ACL.
//       PCB *ppcb [in,out] - Pointer to a PCB structure containing the
//                            STREAM_ACL into which the ACL in the IStream
//                            object is going to be decoded.
//
// Return: HRESULT - S_OK: Success.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_SETSERLHNDLFAILED: Unable to (re)set a serialization
//                                           handle.
//                   CO_E_DECODEFAILED: Unable to decode the ACL in the
//                                      IStream object.
//                   CO_E_INCOMPATIBLESTREAMVERSION: The version code in the
//                                                   stream header was not
//                                                   supported by this version
//                                                   of IAccessControl.
//                   CO_E_FAILEDTOCLOSEHANDLE: Unable to close a serialization
//                                             handle.
//                   CO_E_EXCEEDSYSACLLIMIT: The number of ACEs in the ACL
//                                           provided by the user exceeded the
//                                           limit imposed by the system that
//                                           is loading the ACL. On Windows 95,
//                                           the system can handle 32767
//                                           ACTRL_ACCESS_DENIED ACEs and 32767
//                                           ACTRL_ACCESS_ALLOWED ACEs. On Windows NT,
//                                           the system can only handle 32767
//                                           ACTRL_ACCESS_DENIED and ACTRL_ACCESS_ALLOWED ACEs
//                                           combined.
//                   E_INVALIDARG: This method will return E_INVALIDARG if
//                                 either
//                                 a) the ACL in the stream provided by the
//                                    user contains an invalid access mask, or
//                                 b) one of STREAM_ACE structure in the ACL
//                                    provided by the user contains a null
//                                    pTrusteeName pointer.
//                   CO_E_ACESINWRONGORDER: Not all ACTRL_ACCESS_DENIED ACEs in the ACL
//                                          provided by the user were arranged
//                                          in front of the ACTRL_ACCESS_ALLOWED ACEs.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The ACL provided by the user
//                                                contained a trustee name
//                                                string that didn't conform
//                                                to the <Domain>\<Account>
//                                                syntax.
//                   CO_E_LOOKUPACCNAMEFAILED: (Window NT only) The system call,
//                                             LookupAccountName, failed. The user can
//                                             call GetLastError to obtain extended error
//                                             information.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//
// Called by: COAccessControl:CImpAccessControl::Load
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ReadACLFromStream
(
IStream *pStm,
PCB     *ppcb,
ACL_DESCRIPTOR *pACLDesc
)
{
    HRESULT       hr = S_OK;
    ULONG         ulBuffSize = 0;
    STREAM_HEADER StreamHeader;
    ULONG         ulTotalSIDSize;
    ULONG         ulEstAdditionalSIDSize;

    if (FAILED(hr = ResizePicklingBuff(ppcb, g_ulHeaderSize)))
    {
        return hr;
    } // if

    // Set up fixed buffer decoding handle
    if ( MesDecodeBufferHandleCreate( ppcb->pPicklingBuff
                                    , g_ulHeaderSize
                                    , &(ppcb->PickleHandle)) != RPC_S_OK )
    {
        return CO_E_SETSERLHNDLFAILED;
    } // if

    if (FAILED(hr = pStm->Read((void *)(ppcb->pPicklingBuff), g_ulHeaderSize, NULL)))
    {
        return hr;
    } // if

    // Decode the stream header
    RpcTryExcept
    {
        STREAM_HEADER_Decode(ppcb->PickleHandle, &StreamHeader);
    }
    RpcExcept(1)
    {
        return CO_E_DECODEFAILED;
    }
    RpcEndExcept

    if (StreamHeader.ulStreamVersion != STREAM_VERSION)
    {
        return CO_E_INCOMPATIBLESTREAMVERSION;
    } // if

    ulBuffSize = StreamHeader.ulPickledSize;

    // Allocate a buffer that is big enough to hold the
    // the stream
    if (FAILED(hr = ResizePicklingBuff(ppcb, ulBuffSize + 800)))
    {
        return hr;
    } // if

    if(FAILED(hr = pStm->Read((void *)(ppcb->pPicklingBuff), ulBuffSize, NULL)))
    {
        return hr;
    } // if

    // Re-create a decoding handle
    if (MesBufferHandleReset( ppcb->PickleHandle
                            , MES_FIXED_BUFFER_HANDLE
                            , MES_DECODE
                            , &(ppcb->pPicklingBuff)
                            , ppcb->ulPicklingBuffSize
                            , &(ppcb->ulBytesUsed)) != RPC_S_OK)
    {
        return CO_E_SETSERLHNDLFAILED;
    } // if

    // Decode the stream content into the stream ACL
    RpcTryExcept
    {
        STREAM_ACL_Decode(ppcb->PickleHandle, &(ppcb->StreamACL));
    }
    RpcExcept(1)
    {
        return CO_E_DECODEFAILED;
    }
    RpcEndExcept

    ppcb->ulBytesUsed = ulBuffSize;

    // Free the decoding handle
    hr = MesHandleFree(ppcb->PickleHandle);
    ppcb->PickleHandle = NULL;
    if (hr != RPC_S_OK)
    {
        return CO_E_FAILEDTOCLOSEHANDLE;
    } // if

    ppcb->bPickled = TRUE;

    // Validate the stream ACL
    if(FAILED(hr = ValidateAndFixStreamACL( &(ppcb->StreamACL)
                                          , &ulTotalSIDSize
                                          , &ulEstAdditionalSIDSize)))
    {
        if((hr != CO_E_NOMATCHINGSIDFOUND) && (hr != CO_E_LOOKUPACCNAMEFAILED))
        {
            return hr;
        } // if
    } // if

    // Windows NT, the size of the ACL may have changed after
    // fixing the stream ACL so we may have to reallocate the
    // pickling buffer
    if (ulEstAdditionalSIDSize > 0)
    {
        if(FAILED(hr = ResizePicklingBuff( ppcb
                                         , ppcb->ulBytesUsed
                                         + ulEstAdditionalSIDSize
                                         + 800)))
        {
            return hr;
        } // if
        ppcb->bPickled = FALSE;
    } // if

    pACLDesc->ulSIDSize = ulTotalSIDSize;

    return hr;
} // ReadACLFromStream

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: AddACEToStreamACL
//
// Summary: This function inserts a STREAM_ACE structure into an existing
//          STREAM_ACE array in a PCB structure. This function assumes that
//          the STREAM_ACL inside the pcb is large enough to hold the new entry.
//
// Args: STREAM_ACE *pStreamACE [in] - Pointer to the StreamACE structure to be added
//
//       PCB *ppcb [in,out] - Pointer to the pickle control block that contains
//                            the stream ACL to which the new stream ACE is added.
//
// Return: void
//
// Called by: COAccessControl:CImpAccessControl::GrantAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void AddACEToStreamACL
(
STREAM_ACE       *pStreamACE,
PCB              *ppcb
)
{
    STREAM_ACE *pLastEntry;         // Pointer to the last ACE with the specified
                                    // access mode
    STREAM_ACE *pInsertionPoint;    // Pointer to STREAM_ACE slot in the STREAM_ACE
                                    // array that the new STREAM_ACE structure will be
                                    // inserted.

    pLastEntry = ppcb->StreamACL.pACL
               + ppcb->ulNumOfStreamACEs;
    if (pStreamACE->grfAccessMode == ACTRL_ACCESS_DENIED)
    {
        pInsertionPoint = ppcb->StreamACL.pACL
                        + ppcb->StreamACL.ulNumOfDenyEntries;
        memcpy(pLastEntry, pInsertionPoint, sizeof(STREAM_ACE));
        ppcb->StreamACL.ulNumOfDenyEntries++;
    }
    else
    {
        pInsertionPoint = pLastEntry;
        ppcb->StreamACL.ulNumOfGrantEntries++;
    }

    memcpy(pInsertionPoint, pStreamACE, sizeof(STREAM_ACE));
    ppcb->ulNumOfStreamACEs++;

} // AddACEToStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: IsValidAccessMask
//
// Summary:  This function checks if an access permission mask provided by
//           the user is valid or not.
//
// Args: DWORD stdmask [in] - Standard mask to be validated.
//
// Return: BOOL - TRUE: The mask is valid
//                FALSE: Otherwise
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
BOOL IsValidAccessMask
(
DWORD stdmask
)
{
    return ((stdmask & ~COM_RIGHTS_ALL) ? FALSE : TRUE);
} // IsValidAccessMask

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: DeleteACEFromStreamACL
//
// Summary: This function remove all the ACEs that matches the input trustee
//          name from the stream ACL.
//
// Args: LPWSTR pTrustee [in] - Pointer to the trustee string that identifies
//                              the ACE to be removed from the stream ACL.
//       ULONG AccessMode [in] - Access mode of the entry that the
//                                     the caller is interested in removing.
//       SID_TRUSTEE *pSIDTrustee [out] - (Windows NT only) Pointer to
//                   a SID_TRUSTEE structure. This structure is used to pass
//                   out the string name and the SID of first ACE removed from
//                   the STREAM_ACL. These two pieces of information are
//                   used by the caller to update the cache and the
//                   caller must free the memory for the SID and
//                   trustee name afterwards.
//       PCB *ppcb [in,out] - Pointer to the pickle control block which
//                            contains a STREAM_ACL structure.
//
// Return: BOOL FALSE: Successful completion of the operation but the trustee
//                     could not be found in the relevant portion of the
//                     STREAM_ACE array inside the STREAM_ACL structure.
//              TRUE: Successful completion of the operation. All the
//                    ACEs that have a matching trustee name from the
//                    relevant portion of STREAM_ACE array.
//
// Called by: COAccessControl::CImpAccessControl::RevokeAccessRights.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
BOOL DeleteACEFromStreamACL
(
PTRUSTEE_W     pTrustee,
ULONG          AccessMode,
ACL_DESCRIPTOR *pACLDesc,
PCB            *ppcb
)
{
    ULONG      i;                       // Loop counter
    STREAM_ACE *pStreamACE;             // Pointer for traversing the array
                                        // of STREAM_ACE structures inside the
                                        // STREAM_ACL structure of the pickle control block.
    STREAM_ACE *pLastEntry;             // Pointer to the 'last' ACE with the
                                        // the specified access mode.
    ULONG      *pulNumOfEntries;        // The total number of ACEs in the STREAM_ACL
                                        // structure with the specified
                                        // acces mode.
    BOOL       bResult = FALSE;         // Internal function return code.

    switch (AccessMode)
    {
        case ACTRL_ACCESS_DENIED:
            pulNumOfEntries = &(ppcb->StreamACL.ulNumOfDenyEntries);
            pStreamACE = ppcb->StreamACL.pACL;
            break;
        case ACTRL_ACCESS_ALLOWED:
            pulNumOfEntries = &(ppcb->StreamACL.ulNumOfGrantEntries);
            pStreamACE = ppcb->StreamACL.pACL
                       + ppcb->StreamACL.ulNumOfDenyEntries;
            break;

        default:

            Win4Assert (!"Should never reach this");
            return FALSE;
    } // switch

    pLastEntry = ppcb->StreamACL.pACL
               + ppcb->StreamACL.ulNumOfGrantEntries
               + ppcb->StreamACL.ulNumOfDenyEntries - 1;

    for (i = 0; i < *pulNumOfEntries ; i++ )
    {
        // The following while loop is necessary to handle
        // cases where the matching STREAM_ACEs are bunched
        // up at the 'end' of the relevant portion of the
        // STREAM_ACE array.
        while( (i < *pulNumOfEntries) &&
               (((pTrustee->TrusteeForm == TRUSTEE_IS_NAME) &&
                 (lstrcmpiW( pTrustee->ptstrName
                           , pStreamACE->pTrusteeName) == 0)) ||
                ((pTrustee->TrusteeForm == TRUSTEE_IS_SID) &&
                 (pStreamACE->pSID != NULL &&
                  EqualSid( (PSID)(pTrustee->ptstrName)
                          , (PSID)(pStreamACE->pSID))))))
        {
            (*pulNumOfEntries)--;
            ppcb->ulNumOfStreamACEs--;

            if (pStreamACE->pSID != NULL)
            {
                pACLDesc->ulSIDSize -= GetLengthSid(pStreamACE->pSID);
                midl_user_free(pStreamACE->pSID);
            } // if

            midl_user_free(pStreamACE->pTrusteeName);
            switch(AccessMode)
            {
                case ACTRL_ACCESS_DENIED:
                    if (i < (*pulNumOfEntries))
                    {
                        memcpy( pStreamACE
                              , ppcb->StreamACL.pACL + *pulNumOfEntries
                              , sizeof(STREAM_ACE));
                    } // if
                    memcpy( ppcb->StreamACL.pACL + *pulNumOfEntries
                          , pLastEntry
                          , sizeof(STREAM_ACE));

                    break;
                case ACTRL_ACCESS_ALLOWED:
                    if (i < (*pulNumOfEntries))
                    {
                        memcpy(pStreamACE, pLastEntry, sizeof(STREAM_ACE));
                    } //  if
                    break;
            } // switch

            memset(pLastEntry, 0, sizeof(STREAM_ACE));
            pLastEntry--;
            bResult = TRUE;
        } // while
        pStreamACE++;
    } // for
    return bResult;

} // DeleteACEFromStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: MapStreamACLToAccessList
//
// Summary: This function maps a stream ACL to an array of
//          ACTRL_ACCESS_ENTRY structures. This function allocates all
//          memory needed for the output access list.  It cleans up all
//          memory in case of error.
//
// Return: HRESULT S_OK: Succeeded
//                 E_OUTOFMEMORY: The system ran out of memory for allocating
//                                the trustee identifiers to be returned.
//
// Called by: COAccessControl::CImpAccessControl::GetAllAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT MapStreamACLToAccessList
(
PCB                *ppcb,
PACTRL_ACCESSW     *ppAccessList
)
{
    PACTRL_ACCESSW             pAccessList;
    PACTRL_PROPERTY_ENTRYW     pProperty;
    PACTRL_ACCESS_ENTRY_LISTW  pEntryList;
    PACTRL_ACCESS_ENTRYW       pEntry;
    PACTRL_ACCESS_ENTRYW       pCurrEntry;
    char                      *pTrusteeName = NULL;

    STREAM_ACE         *pStreamACEsPtr;          // Pointer for stepping through
                                                 // the stream ACL
    ULONG              i = 0;
    LPWSTR             pwszName;                 // Pointer to the trustee name
                                                 // inside the stream ACE of the
                                                 // current iteration
    ULONG              ulNumOfEntries;           // Total number of stream ACEs to map
    ULONG              ulSize;

    // Compute the amount of memory needed for the trustee names and sids.
    ulNumOfEntries = ppcb->ulNumOfStreamACEs;
    pStreamACEsPtr = ppcb->StreamACL.pACL;
    ulSize         = 0;
    for (i = 0; i < ulNumOfEntries; i++)
    {
        if(pStreamACEsPtr->TrusteeForm == TRUSTEE_IS_NAME)
        {
            ulSize += (lstrlenW(pStreamACEsPtr->pTrusteeName) + 1) *
                      sizeof(WCHAR);
        }
        else
        {
            ulSize += GetLengthSid((PISID)pStreamACEsPtr->pSID);
        } // if

        pStreamACEsPtr++;
    } // for

    // Allocate memory for everything
    ulSize += sizeof(ACTRL_ACCESSW) + sizeof(ACTRL_PROPERTY_ENTRYW) +
              sizeof(ACTRL_ACCESS_ENTRY_LISTW) +
              sizeof(ACTRL_ACCESS_ENTRYW) * ulNumOfEntries;
    pAccessList    = (PACTRL_ACCESSW) LocalMemAlloc( ulSize );
    if (pAccessList == NULL)
    {
        *ppAccessList = NULL;
        return E_OUTOFMEMORY;
    }
    pProperty      = (PACTRL_PROPERTY_ENTRYW) (pAccessList + 1);
    pEntryList     = (PACTRL_ACCESS_ENTRY_LISTW) (pProperty + 1);
    if (ulNumOfEntries != 0)
    {
        pEntry       = (PACTRL_ACCESS_ENTRYW) (pEntryList + 1);
        pTrusteeName = (char *) (pEntry + ulNumOfEntries);
    }
    else
    {
        pEntry       = NULL;
    }

    // Initialize the top three levels of structures.
    pAccessList->cEntries            = 1;
    pAccessList->pPropertyAccessList = pProperty;
    pProperty->lpProperty            = NULL;
    pProperty->pAccessEntryList      = pEntryList;
    pProperty->fListFlags            = 0;
    pEntryList->cEntries             = ulNumOfEntries;
    pEntryList->pAccessList          = pEntry;

    pCurrEntry     = pEntry;
    pStreamACEsPtr = ppcb->StreamACL.pACL;
    for (i = 0; i < ulNumOfEntries; i++)
    {
        pwszName = pStreamACEsPtr->pTrusteeName;

        // On Windows 95, the only form of trustee identifier supported is
        // a Unicode string while a security identifier or a Unicode string
        // can be used to specify a trustee on Windows NT.
        if(pStreamACEsPtr->TrusteeForm == TRUSTEE_IS_NAME)
        {
            ulSize = (lstrlenW(pwszName) + 1) * sizeof(WCHAR);
            memcpy( pTrusteeName, pwszName, ulSize );
        }
        else
        {
            ulSize = GetLengthSid((PISID)pStreamACEsPtr->pSID);
            CopySid(ulSize, (PSID)pTrusteeName, pStreamACEsPtr->pSID);
        } // if

        pCurrEntry->Trustee.ptstrName        = (WCHAR *) pTrusteeName;
        pCurrEntry->Trustee.TrusteeType      = pStreamACEsPtr->TrusteeType;
        pCurrEntry->Trustee.TrusteeForm      = pStreamACEsPtr->TrusteeForm;
        pCurrEntry->Trustee.pMultipleTrustee = NULL;       // Not supported
        pCurrEntry->Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE; // Not supported
        pCurrEntry->Access                   = pStreamACEsPtr->grfAccessPermissions;
        pCurrEntry->ProvSpecificAccess       = 0;
        pCurrEntry->Inheritance              = NO_INHERITANCE; // Not supported
        pCurrEntry->lpInheritProperty        = NULL;
        pCurrEntry->fAccessFlags             = pStreamACEsPtr->grfAccessMode;
        pTrusteeName                        += ulSize;
        pStreamACEsPtr++;
        pCurrEntry++;
    } // for

    *ppAccessList = pAccessList;
    return S_OK;
} // MapStreamACLToAccessList

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: CleanAllMemoryResources()
//
// Summary: This function frees all the memory allocated for an initialized
//          COAccessControl object. On Windows 95, this function will release
//          all the memory allocated for the ACL_DESCRIPTOR structure except
//          for the two resource name in the LAN Manager ACL embedded in the
//          ACL_DESCRIPTOR structure. The idea behind such an arrange is to
//          reuse existing resource as much as possible so that performanace
//          can be improved.
//
// Args: ACL_DESCRIPTOR *pACLDesc [in,out] - This structure describes
//                      how DCOM IAccessControl implementaion object packages
//                      platform specific ACL.
//       PCB *ppcb [in,out] - The pickling control block owned by the
//                            same object.
//
// Return: void
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void CleanAllMemoryResources
(
ACL_DESCRIPTOR *pACLDesc,
PCB            *ppcb
)
{
    // Clean up old Stream ACL
    FreePicklingBuff(ppcb);
    MesHandleFree(ppcb->PickleHandle);
    CleanUpStreamACL(&(ppcb->StreamACL));

    // Cleanup the ACL images
    LocalMemFree(pACLDesc->pACLBuffer);
    LocalMemFree(pACLDesc->SecDesc.Owner);
    LocalMemFree(pACLDesc->SecDesc.Group);

} // CleanAllMemoryResources


//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ComputeEffectiveAccess, NT version
//
// Summary: Given a handle to an access token representing a user, an
//          ACL_DESCRIPTOR structure and a STREAM_ACL structure , this function
//          will compute the effective access permissions that the user
//          represented by the access token has.
//
// Args: ACL_DESCRIPTOR *pACLDesc [in,out] - Pointer to the NT version of the
//                      ACL_DESCRIPTOR structure. Thsi structure should contain
//                      a buffer for the NT ACL structure, a NT security
//                      descriptor, a control flag and size information.
//       STREAM_ACL *pStreamACL [in] - It may be the case that the STREAM_ACL
//                  structure of an DCOM IAccessControl implementation object
//                  has not been mapped into the security descriptor's dacl
//                  inside the ACL_DESCRIPTOR, so it is necessary that object
//                  that calls this function to pass in its STREAM_ACL
//                  structure. In fact, this is only place where a STREAM_ACL
//                  will be mapped into a dacl.
//       HANDLE TokenHandle [in] - This should be the access token of the
//              user that the caller wants to compute the effective access
//              permissions for.
//       DWORD *pdwRights [out] - Address of the effective access permissions
//                                that the user corresponding to the
//                                access token specified in the TokenHandle
//                                has on the secured object.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: The system ran out of memory for
//                                  allocating the NT ACL.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   CO_E_ACCESSCHECKFAILED: The system function, AccessCheck,
//                                           returned FALSE in
//                                           ComputeEffectiveAccess. The
//                                           caller of this method can call
//                                           GetLastError to obtain extended
//                                           error information.
//
//
// Called by: COAccessControl:CImpAccessControl:GetEffAccRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ComputeEffectiveAccess
(
ACL_DESCRIPTOR *pACLDesc,
STREAM_ACL     *pStreamACL,
HANDLE         TokenHandle,
DWORD          *pdwRights
)
{
    HRESULT         hr = S_OK;
    ACCESS_MASK     AccessMaskOut = 0; // Access mask returned by
                                       // AccessCheck
    ACCESS_MASK     AccessMaskIn = 0;  // Access permissions to check for
    BOOL            bAccessStatus;     // Access checking status.
                                       // TRUE - Access granted.
                                       // FALSE - Access denied.
                                       // This function doesn't really care
                                       // about this result, all it wants
                                       // is the set the of permissions
                                       // that a user effectively has.
    DWORD           dwSetLen;          // Length of the privilege set.

    dwSetLen = sizeof(gDummyPrivilege);

    // If the ACL has not been set into the security
    // security inside the ACL descriptor, do so now.
    if (pACLDesc->bDirtyACL)
    {
        if(FAILED(hr = PutStreamACLIntoSecDesc( pStreamACL
                                              , pACLDesc)))
        {
            return hr;
        } // if

    } // if

    // Call access check
    if(!AccessCheck( &(pACLDesc->SecDesc)
                   , TokenHandle
                   , NT_RIGHTS_ALL
                   , &gDummyMapping
                   , &gDummyPrivilege
                   , &dwSetLen
                   , &AccessMaskOut
                   , &bAccessStatus))
    {
        return CO_E_ACCESSCHECKFAILED;
    } // if

    // Convert the NT access mask back to IAccessControl access mask.
    NTMaskToStandardMask(&AccessMaskOut, pdwRights);

    return S_OK;


} // ComputeEffectiveAccess


//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateAndTransformAccReqList
//
// Summary: This function validates the fields inside a list of ACCESS_REQUEST
//          structures and transform it into a list of stream ACE structures.
//          This function is
//          also responsible for estimating the total size of the STREAM_ACE
//          structures returned to the caller if they are serialized into a
//          buffer using RPC serialization service. On WIndows 95, this function
//          will set up an array of access_list_2 structures representing the
//          input access request list for the caller. On Windows NT, this function
//          will lookup the SID or the trustee name for each access request depending
//          on which one is specified by the caller.
//
// Args: PACCESS_REQUEST_W pAccReqList [in] - Pointer to the access request to
//                                            be validated and transformed.
//       ULONG ulNumOfRequestIn [in] - Number of ACCESS_REQUEST_W structures
//       STREAM_ACE **ppStreamACEs [out] - Pointer to an array of stream ACEs
//                  transformed from the access request list. The array of
//                  STREAM_ACE structures and the SID and trustee name inside
//                  each of the STREAM_ACE structure returned are allocated by
//                  this function using midl_user_allocate so the caller should
//                  release the memory allocated for these structures using
//                  midl_user_allocate.
//       access_list_2 **ppACEs [out] - (Chicago only)Address of a pointer to
//                     an array of access_list_2 structures to be returned to the
//                     caller. Notice that this function will allocate memory
//                     for the array and the User/group name in each of
//                     access_list_2 structure returned using LocalMemAlloc.
//                     Once the caller receives this output parameter, it
//                     becomes the caller's responsiblility to release the
//                     memory allocated for this structure when it is no
//                     longer in use.
//       ULONG *pulEstPickledSize [out] - Pointer to the estimated number of
//                                        bytes needed for serializing the
//                                        STREAM_ACE structures returned. The
//                                        estimated
//                                        number of bytes required to serialize
//                                        a STREAM_ACE structure into a buffer
//                                        using RPC serialization service is
//                                        computed by the folowing formula:
//       Size of the Unicode trustee string + Size of the SID + Size of the
//       STREAM_ACE structure + 48
//       The number 48 is an arbitrary large number that should account for
//       all the extra space required by RPC to align the data structure and
//       to add additional information to the header.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operations.
//                   E_INVALIDARG: The access mask in one of the
//                                 ACCESS_REQUEST_W structures was invalid of
//                                 the TRUSTEE structure provided by the user
//                                 was invalid.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned zero.
//                                          The caller can get extended error
//                                          information by calling GetLastError.
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed. The client can call
//                          GetLastError to obtain extended error inforamtion.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed. The client can call
//                          GetLastError to obtain extended error information.
//
// Called by: COAccessControl::CImpAccessControl::GrantAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateAndTransformAccReqList
(
PACTRL_ACCESSW      pAccessList,
STREAM_ACE        **ppStreamACEs,
void              **ppACEs,
ULONG              *pulEstPickledSize,
ULONG              *pcGrant,
ULONG              *pcDeny
)
{
    HRESULT               hr = S_OK;
    STREAM_ACE           *pStreamACEs;    // Pointer to an array of stream ACEs
    STREAM_ACE           *pStreamACEsPtr; // Pointer for traversing the
                                          // array of stream ACEs
    PACTRL_ACCESS_ENTRYW  pCurrEntry;     // Pointer for traversing the
                                          // access request list
    PTRUSTEE_W            pTrustee;       // Pointer to the TRUSTEE structure in
                                          // the access request structure
    ULONG                 ulSIDLen;       // Length of the SID that is currently being
                                          // examined.
    ULONG                 ulStrLen;       // Length of the trustee string in number
                                          // of Unicode characters
    ULONG                 i,j;            // Loop counters
    ULONG                 ulEstPickledSize = 0; // Estimated pickled size of the access
                                          // requests if they all turn into stream ACEs
    TRUSTEE_TYPE          TrusteeType = TRUSTEE_IS_UNKNOWN;
    ULONG                 cCount;

    // Initialize ACE counts.
    *pcGrant = 0;
    *pcDeny  = 0;

    // Validate the top three levels of the structure.
    if (pAccessList == NULL                                  ||
        pAccessList->cEntries != 1                           ||
        pAccessList->pPropertyAccessList == NULL             ||
        pAccessList->pPropertyAccessList->lpProperty != NULL ||
        pAccessList->pPropertyAccessList->fListFlags != 0    ||
        pAccessList->pPropertyAccessList->pAccessEntryList == NULL)
    {
        return E_INVALIDARG;
    }
    cCount = pAccessList->pPropertyAccessList->pAccessEntryList->cEntries;
    pCurrEntry = pAccessList->pPropertyAccessList->pAccessEntryList->pAccessList;
    if (cCount != 0 && pCurrEntry == NULL)
    {
        return E_INVALIDARG;
    }

    // Allocate an array of stream ACEs
    pStreamACEs = (STREAM_ACE *)LocalMemAlloc( sizeof(STREAM_ACE) * cCount);
    if (pStreamACEs == NULL)
    {
        return E_OUTOFMEMORY;
    } // if

    // Map the access requests to stream ACEs and validates the fields in
    // of the access requests as we go along
    pStreamACEsPtr = pStreamACEs;
    for (i = 0; i < cCount; i++)
    {
        pTrustee = &(pCurrEntry->Trustee);
        TrusteeType = pTrustee->TrusteeType;

        // Validate this entry.
        if (!IsValidAccessMask(pCurrEntry->Access))
        {
            hr = E_INVALIDARG;
            goto Error;
        } // if
        if(FAILED(hr = ValidateTrustee(pTrustee)))
        {
            goto Error;
        }
        if (pCurrEntry->ProvSpecificAccess != 0       ||
            pCurrEntry->Inheritance != NO_INHERITANCE ||
            pCurrEntry->lpInheritProperty != NULL     ||
            (pCurrEntry->fAccessFlags != ACTRL_ACCESS_ALLOWED &&
             pCurrEntry->fAccessFlags != ACTRL_ACCESS_DENIED))
        {
            hr = E_INVALIDARG;
            goto Error;
        }

        if (pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
        {
            ulStrLen                     = lstrlenW(pTrustee->ptstrName);
            ulEstPickledSize            += (ulStrLen + 1) * sizeof(WCHAR);
            pStreamACEsPtr->pTrusteeName = (LPWSTR)
                midl_user_allocate( (ulStrLen + 1) * sizeof(WCHAR));
            if (pStreamACEsPtr->pTrusteeName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            memcpy( pStreamACEsPtr->pTrusteeName
                  , pTrustee->ptstrName
                  , sizeof(WCHAR) * (ulStrLen + 1));
            pStreamACEsPtr->pSID = NULL;

            if (FAILED(hr = GetSIDFromName( (void **)&(pStreamACEsPtr->pSID)
                                          , pStreamACEsPtr->pTrusteeName
                                          , &TrusteeType)))
            {
                LocalMemFree(pStreamACEsPtr->pTrusteeName);
                goto Error;
            } // if
            ulEstPickledSize += GetLengthSid(pStreamACEsPtr->pSID);
        }
        else
        {

            // Copy the SID to the stream ACE strusture
            ulSIDLen             = GetLengthSid((PISID)(pTrustee->ptstrName));
            ulEstPickledSize    += ulSIDLen;
            pStreamACEsPtr->pSID = (PSTREAM_SID)midl_user_allocate(ulSIDLen);
            if (pStreamACEsPtr->pSID == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            } //if
            CopySid(ulSIDLen, (PSID)(pStreamACEsPtr->pSID),
                    (PSID)(pTrustee->ptstrName));

            if(FAILED(hr = GetNameFromSID( &(pStreamACEsPtr->pTrusteeName)
                                         , (PSID)(pStreamACEsPtr->pSID)
                                         , &TrusteeType)))
            {
                LocalMemFree(pStreamACEsPtr->pSID);
                goto Error;
            } // if

            ulEstPickledSize += lstrlenW(pStreamACEsPtr->pTrusteeName);
        } // if

        pStreamACEsPtr->TrusteeForm          = pCurrEntry->Trustee.TrusteeForm;
        pStreamACEsPtr->grfAccessPermissions = pCurrEntry->Access;
        pStreamACEsPtr->TrusteeType          = TrusteeType;
        pStreamACEsPtr->grfAccessMode        = (ACCESS_MODE) pCurrEntry->fAccessFlags;
        if (pCurrEntry->fAccessFlags == ACTRL_ACCESS_ALLOWED)
        {
            (*pcGrant)++;
        }
        else
        {
            (*pcDeny)++;
        }
        pStreamACEsPtr++;

        pCurrEntry++;

    } // for

    *ppStreamACEs = pStreamACEs;
    *pulEstPickledSize = ulEstPickledSize
                       + cCount
                       * (sizeof(WCHAR)
                       + 48 + sizeof(STREAM_ACE));
    return S_OK;

Error:
    pStreamACEsPtr = pStreamACEs;

    // Release the memory allocated for the
    // trustee strings and SIDs inside the
    // each of the STREAM_ACE and access_list_2
    // structures.
    for ( j = 0; j < i; j++, pStreamACEsPtr++)
    {
        LocalMemFree(pStreamACEsPtr->pTrusteeName);
        LocalMemFree(pStreamACEsPtr->pSID);
    } // for

    // Release the array of STREAM_ACE structures
    if (pStreamACEs != NULL)
    {
        LocalMemFree(pStreamACEs);
    }
    *pulEstPickledSize = 0;
    *ppStreamACEs = NULL;
    return hr;

} // ValidateAndTransformAccessRequests


//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateAndFixStreamACL
//
// Summary: This function validates the fields in a STREAM_ACL structure and all
//          the STREAM_ACE structures that it contains. On Windows 95, this function
//          will make sure that the value of the TrusteeType field in
//          each of the STREAM_ACE structure is TRUSTEE_IS_NAME. On Windows NT,
//          this function will make sure that each STREAM_ACE structure contains
//          both the trustee name and the SID. Besides making sure that both the
//          trustee name and the SID are in every STREAM_ACE structure, this function
//          has to compute the total size in bytes of all the SIDs in the
//          stream ACL and the estimated "pickled" size of all the SIDs that
//          this function has found missing in the original stream ACL on
//          Windows NT.
//
// Args: STREAM_ACL *pStreamACL [in] - Pointer to the STREAM_ACL strucutre to be
//                                     validated.
//       On Windows NT:
//       ULONG *pulTotalSIDSize [out] - Address of the total size of all the SIDs
//                                      in the stream ACL in bytes. This number
//                                      is used by other parts of the module to
//                                      compute the expected size of the NT
//                                      ACL.
//       ULONG *pulEstAdditionalSIDSize [out] - Address of the estimated total
//                                              size of all the missing SID
//                                              that this function has filled-
//                                              in when they are serialized into
//                                              a buffer using the RPC serialization
//                                              service. This number is used
//                                              by the caller to estimate
//                                              size of the buffer required to
//                                              serialize the STREAM_ACL structure.
//                                              The estimated number of bytes
//                                              required for serializing each
//                                              additonal SID is computed by
//                                              the following formula:
//                    Size of the SID + 32
//         Notice that it is neccessary to add extra bytes to the estimate
//         because RPC may need extra bytes for alignment and additional
//         information in the header. 32 is an arbitrary number that should
//         be big enough to accomodate the extra bytes required for alignment
//         and extra header information. Any estimate that produces a number
//         greater than or equal to the actual serialized size of an SID
//         should be considered as good asthe the one provided above.
//
// Return: HRESULT - S_OK: Success.
//                   CO_E_EXCEEDSYSACLLIMIT: The number of ACEs in the ACL
//                                           provided by the user exceeded the
//                                           limit imposed by the system that
//                                           is loading the ACL. On Windows 95,
//                                           the system can handle 32767
//                                           ACTRL_ACCESS_DENIED ACEs and 32767
//                                           ACTRL_ACCESS_ALLOWED ACEs. On Windows NT,
//                                           the system can only handle 32767
//                                           ACTRL_ACCESS_DENIED and ACTRL_ACCESS_ALLOWED ACEs
//                                           combined.
//                   E_INVALIDARG: This function will return E_INVALIDARG if
//                                 either
//                                 a) the ACL in the stream provided by the
//                                    user contains an invalid access mask, or
//                                 b) one of STREAM_ACE structure in the ACL
//                                    provided by the user contains a null
//                                    pTrusteeName pointer.
//                   CO_E_ACESINWRONGORDER: Not all ACTRL_ACCESS_DENIED ACEs in the ACL
//                                          provided by the user were arranged
//                                          in front of the ACTRL_ACCESS_ALLOWED ACEs.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The ACL provided by the user
//                                                contained a trustee name
//                                                string that didn't conform
//                                                to the <Domain>\<Account>
//                                                syntax.
//                   CO_E_LOOKUPACCNAMEFAILED: (Window NT only) The system call,
//                                             LookupAccountName, failed. The user can
//                                             call GetLastError to obtain extended error
//                                             information.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_NOMATCHINGSIDFOUND: (Windows NT only) At least one of the trustee
//                                            name in the ACL provided by the user had
//                                            no corresponding security identifier.
//
// Called by: ReadACLFromStream
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateAndFixStreamACL
(
STREAM_ACL *pStreamACL,
ULONG      *pulTotalSIDSize,
ULONG      *pulEstAdditionalSIDSize
)
{
    ULONG        ulNumOfDenyEntries;
    ULONG        ulNumOfEntries;
    STREAM_ACE   *pStreamACEsPtr;
    ULONG        i;
    ULONG        AccessMode;
    HRESULT      hr = S_OK;


    *pulTotalSIDSize = 0;
    *pulEstAdditionalSIDSize = 0;

    AccessMode = ACTRL_ACCESS_DENIED;
    ulNumOfDenyEntries = pStreamACL->ulNumOfDenyEntries;
    ulNumOfEntries = ulNumOfDenyEntries + pStreamACL->ulNumOfGrantEntries;

    if(ulNumOfEntries > 32767)
    {
        return CO_E_EXCEEDSYSACLLIMIT;
    } // if

    for ( i = 0, pStreamACEsPtr = pStreamACL->pACL
        ; i < ulNumOfEntries
        ; i++, pStreamACEsPtr++)
    {
        if (i == ulNumOfDenyEntries)
        {
            AccessMode = ACTRL_ACCESS_ALLOWED;
        } // if

        if (!IsValidAccessMask(pStreamACEsPtr->grfAccessPermissions) ||
            ((pStreamACEsPtr->TrusteeType != TRUSTEE_IS_USER) &&
             (pStreamACEsPtr->TrusteeType != TRUSTEE_IS_GROUP)))
        {
            hr = E_INVALIDARG;
            break;
        } // if
        if((ULONG) pStreamACEsPtr->grfAccessMode != AccessMode)
        {
            // The stream ACL is either a) not in proper order, or
            //                          b) doesn't contain the number of stream ACEs
            //                             stated in the header.
            hr = CO_E_ACESINWRONGORDER;
            break;
        } // if

        if (FAILED(hr = ValidateTrusteeString(pStreamACEsPtr->pTrusteeName) ))
        {
            break;
        } // if

        if(pStreamACEsPtr->pSID == NULL)
        {
            if(!(FAILED(hr = GetSIDFromName( (void **)&(pStreamACEsPtr->pSID)
                                           , pStreamACEsPtr->pTrusteeName
                                           , &pStreamACEsPtr->TrusteeType))))
            {
                // 32 more bytes is added to the estimated pickled size of the SID
                // because the RPC serialization mechanism may need extra space
                // in the header and alignment.
                *pulEstAdditionalSIDSize += GetLengthSid(pStreamACEsPtr->pSID)
                                         + 32;
            } // if


        } // if
        else
        {
            if(!IsValidSid(pStreamACEsPtr->pSID))
            {
                hr = CO_E_INVALIDSID;
                break;
            } // if
        } // if

        if(pStreamACEsPtr->pSID != NULL)
        {
            *pulTotalSIDSize += GetLengthSid(pStreamACEsPtr->pSID);
        }
        else
        {
            pStreamACEsPtr->TrusteeType = TRUSTEE_IS_UNKNOWN;
        } // if
    } // for
    return hr;

} // ValidateAndFixStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateTrusteeString
//
// Summary: This function checks if a trustee string is not NULL.
//
// Args: LPWSTR pTrusteeName [in] - Pointer to the trustee name to be
//                                  validated.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateTrusteeString
(
LPWSTR pTrusteeName
)
{
    if(pTrusteeName == NULL)
    {
        return E_INVALIDARG;
    } //if

    // If we see the magic string that specifies everyone,
    // we return S_OK.
    if(pTrusteeName[0] == L'*' && pTrusteeName[1] == L'\0')
    {
        return S_OK;
    } // if

    // A more sophisticated check can be put in here
    while(*pTrusteeName != L'\0')
    {
        if (*pTrusteeName == L'\\')
            return S_OK;
        pTrusteeName++;
    }
    return CO_E_WRONGTRUSTEENAMESYNTAX;
} // ValidateTrusteeString

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateTrustee
//
// Summary: This function validates the fields in a TRUSTEE_Wstructure.
//
// Args: PTRUSTEE_W pTrustee [in] - Pointer to the TRUSTEE_W structure
//                                  to be validated.
//
// Return: HRESULT - S_OK: The TRUSTEE structure provided by the user was valid.
//                   E_INVALIDARG: The TRUSTEE structure provided by the user
//                                 contained values that were not supported by
//                                 the COM implementation of IAccessControl.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee string doesn't
//                                                contain the '\' character.
//                   Windows NT only
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateTrustee
(
PTRUSTEE_W pTrustee
)
{
    HRESULT hr = S_OK;

    if( (pTrustee == NULL)                                           ||
        (pTrustee->pMultipleTrustee != NULL)                         ||
         (pTrustee->MultipleTrusteeOperation != NO_MULTIPLE_TRUSTEE) ||
         ((pTrustee->TrusteeForm != TRUSTEE_IS_NAME) &&
          (pTrustee->TrusteeForm != TRUSTEE_IS_SID))                 ||
         ((pTrustee->TrusteeType != TRUSTEE_IS_USER) &&
          (pTrustee->TrusteeType != TRUSTEE_IS_GROUP))               ||
         (pTrustee->ptstrName == NULL) )
    {
        return E_INVALIDARG;
    }

    if (pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        if(FAILED(hr = ValidateTrusteeString(pTrustee->ptstrName)))
        {
            return hr;
        }
    }
    else
    {
        if(!IsValidSid((PSID)(pTrustee->ptstrName)))
        {
            return CO_E_INVALIDSID;
        }
    } // if

    return S_OK;
} // ValidateTrustee

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateAccessCheckClient
//
// Summary: This function checks to see if the current ORPC client matches
//          the trustee name provided for access checking and it also validates
//          the fields in the TRUSTEE structure.
//          The SID case is not optimized because DCOM doesn't use it and
//          this class is meant to be used only by DCOM.
//
// Args: PTRUSTEE_W pTrustee [in] - Pointer to the trustee structure
//                                  which contains the trustee name for
//                                  comparison with the name with the current
//                                  ORPC client.
//
// Return: HRESULT S_OK: The TRUSTEE structure provided by the user was valid
//                       and it specfied the current ORPC client.
//                   CO_E_TRUSTEEDOESNTMATCHCLIENT: The trustee specified by the
//                                                  client was not the current
//                                                  ORPC client.
//                   CO_E_FAILEDTOQUERYCLIENTBLANKET: Unable to query for the
//                                                    client's security blanket.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee name inside the
//                                                TRUSTEE_W structure specified
//                                                by the user is not of the
//                                                form <Domain>\<Account Name>.
//                   E_INVALIDARG: The TRUSTEE structure provided by the user
//                                 contained values that were not supported by
//                                 the COM implementation of IAccessControl.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateAccessCheckClient
(
PTRUSTEE_W pTrustee
)
{

    WCHAR   *pwcszClientName;        // Pointer to the name of the ORPC client
                                     // in multibyte format.
    HRESULT       hr;
    BOOL          fSuccess;
    HANDLE        hClient     = NULL;
    BYTE          aMemory[256];
    TOKEN_USER   *pTokenUser  = (TOKEN_USER *) &aMemory;
    DWORD         lIgnore;
    BOOL          fImpersonated = FALSE;

    if (FAILED(hr = ValidateTrustee(pTrustee)))
    {
        return hr;
    }

    // Validate the name.
    if (pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        if(FAILED(CoQueryClientBlanket( NULL
                                      , NULL
                                      , NULL
                                      , NULL
                                      , NULL
                                      , (RPC_AUTHZ_HANDLE *)&pwcszClientName
                                      , NULL)))
        {
            return CO_E_FAILEDTOQUERYCLIENTBLANKET;
        } // if

        if (lstrcmpiW(pwcszClientName, pTrustee->ptstrName) != 0)
        {
            return CO_E_TRUSTEEDOESNTMATCHCLIENT;
        } // if
    }

    // Validate the SID.
    else
    {
        // Impersonate.
        hr = CoImpersonateClient();

        // Open the thread token.
        if (SUCCEEDED(hr))
        {
			fImpersonated = TRUE;
            fSuccess = OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE,
                                        &hClient );
            if (!fSuccess)
                hr = CO_E_FAILEDTOOPENTHREADTOKEN;
        }

        // Check the SID.
        if (SUCCEEDED(hr))
        {
            fSuccess = GetTokenInformation( hClient, TokenUser, pTokenUser,
                                            sizeof(aMemory), &lIgnore );
            if (!fSuccess)
                hr = CO_E_FAILEDTOGETTOKENINFO;
            else if (!EqualSid( pTokenUser->User.Sid, (SID *) pTrustee->ptstrName ))
                hr = CO_E_TRUSTEEDOESNTMATCHCLIENT;
        }

        // Revert.
		if(fImpersonated)
	        CoRevertToSelf();

        // Close the token handle.
        if (hClient != NULL)
            CloseHandle( hClient );
    }
    return hr;

} // ValidateAccessCheckClient

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: LocalMemAlloc
//
// Summary: This fucntion makes memory allocation more efficient by using the
//          cached g_pIMalloc pointer.
//
// Args: ULONG cb [in] = Number of bytes to be allocated.
//
// Return: void * - Pointer to the a newly allocated memory block.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void * LocalMemAlloc(SIZE_T cb)
{
    return g_pIMalloc->Alloc(cb);
} // LocalMemAlloc

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: LocalMemFree
//
// Summary: This function frees memory allocated by LocalMemAlloc.
//
// Args: void *pBlock - Pointer to the memory block to be freed.
//
// Return: void
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void LocalMemFree(void *pBlock)
{
    g_pIMalloc->Free(pBlock);
} // LocalMemFree

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: CleanUpStreamACL, Common
//
// Summary: This function releases all the memory allocated for the array
//          of STREAM_ACE structures inside a STREAM_ACL structure. This
//          includes all the trustee string and SID inside each of the
//          STREAM_ACE structure.
//
// Args:  STREAM_ACL *pStreamACL [in] - Pointer to the stream ACL structure
//                                      to be cleaned up.
//
// Return: void
//
// Called by: COAccessControl::CImpAccessControl::Load()
//            COAccessControl::CImpAccessControl::ReplaceAllAccessRights()
//            CleanAllMemoryResources
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void CleanUpStreamACL
(
STREAM_ACL *pStreamACL
)
{
    ULONG      ulNumOfEntries; // Total number of entries in the stream ACL
    ULONG      i;              // Loop index
    STREAM_ACE *pACE;          // Pointer to elements in the stream ACL

    ulNumOfEntries = pStreamACL->ulNumOfDenyEntries
                   + pStreamACL->ulNumOfGrantEntries;

    pACE = pStreamACL->pACL;

    for (i = 0; i < ulNumOfEntries; i++)
    {
        midl_user_free(pACE->pTrusteeName);
        midl_user_free(pACE->pSID);
        pACE++;
    } // for

    pStreamACL->ulNumOfDenyEntries = 0;
    pStreamACL->ulNumOfGrantEntries = 0;

    // free the stream ACL itself and set the pointer to NULL
    midl_user_free(pStreamACL->pACL);
    pStreamACL->pACL = NULL;

} // CleanUpStreamACL

/////////////////////////////////////////////////////////////////////////////
// Functions that are specific to the Windows NT platform
/////////////////////////////////////////////////////////////////////////////

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: InitSecDescInACLDesc, NT specific
//
// Summary: This function initializes the group field and the user field of the
//          security descriptor in an ACL_DESCRIPTOR structure the user SID of
//          the current process.
//
// Args: ACL_DESCRIPTOR pACLDesc [in,out] - Pointer to ACL descriptor containing
//                                          the security identifier to be
//                                          initialized.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_FAILEDTOOPENPROCESSTOKEN: The system call,
//                                                  OpenProcessToken, failed.
//                                                  The user can get extended
//                                                  information by calling
//                                                  GetLastError.
//                   CO_E_FAILEDTOGETTOKENINFO: The system call,
//                                              GetTokenInformation, failed.
//                                              The user can call GetLastError
//                                              to get extended error
//                                              information.
//                   E_OUTOFMEMORY: There was not enough memory for allocating
//                                  the SIDs in the security descriptor.
//
// Called by: COAccessControl:CImpAccessControl:Load
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT InitSecDescInACLDesc
(
ACL_DESCRIPTOR *pACLDesc
)
{
    // Set up a security descriptor with the current process owner
    // and primary group
    TOKEN_USER *pTokenUser = NULL;
    HANDLE     hToken;
    ULONG      ulLen;
    HANDLE     hProcess;
    DWORD      dwLastError;
    PSID       pOwner = NULL;
    PSID       pGroup = NULL;
    DWORD      dwSIDLen;
    HRESULT    hr = S_OK;

    hProcess = GetCurrentProcess();

    if(!OpenProcessToken( hProcess
                        , TOKEN_QUERY
                        , &hToken ))
    {
        hr = CO_E_FAILEDTOOPENPROCESSTOKEN;
        goto Error;
    } // if

    GetTokenInformation( hToken
                       , TokenUser
                       , pTokenUser
                       , 0
                       , &ulLen);
    dwLastError = GetLastError();
    if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
    {
        pTokenUser = (TOKEN_USER *)LocalMemAlloc(ulLen);
        if (pTokenUser == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        } // if

        if(!GetTokenInformation( hToken
                               , TokenUser
                               , pTokenUser
                               , ulLen
                               , &ulLen))
        {
            hr = CO_E_FAILEDTOGETTOKENINFO;
            goto Error;
        }

    }
    else
    {
        hr = CO_E_FAILEDTOGETTOKENINFO;
        goto Error;
    } // if

    dwSIDLen = GetLengthSid(pTokenUser->User.Sid);

    pOwner = (PSID)LocalMemAlloc(dwSIDLen);
    if(pOwner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    pGroup = (PSID)LocalMemAlloc(dwSIDLen);
    if(pGroup == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    CopySid(dwSIDLen, pOwner, pTokenUser->User.Sid);
    CopySid(dwSIDLen, pGroup, pTokenUser->User.Sid);

    InitializeSecurityDescriptor( &(pACLDesc->SecDesc)
                                , SECURITY_DESCRIPTOR_REVISION);
    pACLDesc->SecDesc.Owner = pOwner;
    pACLDesc->SecDesc.Group = pGroup;

    // Close the token handle
    CloseHandle(hToken);
    // Free the token user buffer
    LocalMemFree(pTokenUser);

    pACLDesc->bDirtyACL = TRUE;
    return hr;

Error:
    if (pTokenUser != NULL)
    {
        LocalMemFree(pTokenUser);
    } // if
    if (pOwner != NULL)
    {
        LocalMemFree(pOwner);
    } // if
    if (pGroup != NULL)
    {
        LocalMemFree(pGroup);
    } // if
    return hr;

} // InitSecDescInACLDesc

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: GetSIDFromName, NT specific
//
// Summary: This function takes an account name of the form <Domain>\<User name>
//          as an input and returns the corresponding security identifier (SID).
//          This function will automatically allocates memory for the SID
//          returned to the caller so the caller should release the SID pointer
//          using LocalMemFree as soon as the SID is no longer in use.
//
// Args: PSID   *ppSID [out] - Address of the pointer to the returned security
//                             identifier. The caller must free the memory
//                             allocated for the securrity identifier using
//                             LocalMemFree when the security identifier is no
//                             longer in use.
//       LPWSTR pwszTrustee [in] - Pointer to the trustee name of the form
//                                 <Domain>\<User name>. The SID returned
//                                 should belong to this trustee.
//       TRUSTEE_TYPE TrusteeType [in] - Type of the trustee which is either
//                                       TRUSTE_IS_NAME or TRUSTEE_IS_GROUP
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed. The client can
//                          call GetLastError to obtain extended error
//                          information.
//                   E_OUTOFMEMORY: The system ran out of memory for
//                                  allocating the SID to be returned
//                                  the caller.
//
//
// Called by: ValidateAndFixStreamACL
//            ValidateAndTransformAccReqList
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT GetSIDFromName
(
PSID            *ppSID,
LPWSTR          pwszTrustee,
TRUSTEE_TYPE    *pTrusteeType
)
{
    PSID            pSID           = NULL;
    DWORD           dwSIDSize;          // Buffer size for the SID
    LPWSTR          pwszUserName;       // Pointer to the user name portion of the
                                        // trustee
    DWORD           dwLastError;        // Error code obtained from GetLastError
    DWORD           dwDomainLength;     // Length of domain name
    LPWSTR          pwszDomainName = NULL;
    SID_NAME_USE    SIDUse;             // The type of SID returned.
    HRESULT         hr;

    // We trap the magic string "*' which specifies everyone
    if (pwszTrustee[0] == L'*' && pwszTrustee[1] == L'\0')
    {
        if (*pTrusteeType != TRUSTEE_IS_GROUP)
        {
            return E_INVALIDARG;
        } // if

        if(*ppSID = (PSID)LocalMemAlloc(sizeof(gEveryone)))
        {
            CopySid(sizeof(gEveryone), *ppSID, &gEveryone);
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        } // if
    } // if

    // Assign an arbitrarily large SID size so that the function
    // can avoid LookupAccountName twice for most of the time.
    pwszUserName   = pwszTrustee;
    dwDomainLength = 64;
    dwSIDSize      = 64;
    pSID           = (PSID)midl_user_allocate(dwSIDSize);
    if (pSID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    dwDomainLength++;
    pwszDomainName = (LPWSTR)LocalMemAlloc(sizeof(WCHAR) * dwDomainLength);
    if (pwszDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    if (!LookupAccountNameW( NULL
                           , pwszUserName
                           , pSID
                           , &dwSIDSize
                           , pwszDomainName
                           , &dwDomainLength
                           , &SIDUse))

    {
        dwLastError = GetLastError();

        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {

            // If it is not the domain buffer that is too small, it must be
            // the SID that is too small. In this cas, we should expand the
            // buffer and call LookupAccountW again.
            midl_user_free(pSID);
            pSID = (PSID)midl_user_allocate(dwSIDSize);
            if (pSID== NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            } // if

            if(!LookupAccountNameW( NULL
                                  , pwszUserName
                                  , pSID
                                  , &dwSIDSize
                                  , pwszDomainName
                                  , &dwDomainLength
                                  , &SIDUse ))
            {
                // If LookupAccountW crashes again, we quit and return
                // an error code.
                hr = CO_E_LOOKUPACCNAMEFAILED;
                goto Error;
            } // if
        }
        else
        {
            // LookupAccountW may not be able to find the SID for the
            // trustee or some other fatal errors occured. In any case, we
            // return an error code and the caller can look at the details
            // by calling GetLastError
            hr = CO_E_LOOKUPACCNAMEFAILED;
            goto Error;
        } // if
    } // if

    // Check to see if the trustee type provided by the caller matches the SID
    // type obtained from LookupAccountName. If not, we're in trouble.  All
    // well known SIDs are of type SidTypeWellKnownGroup.
    if( !(SIDUse == SidTypeUser && *pTrusteeType == TRUSTEE_IS_USER) &&
        !(SIDUse == SidTypeGroup && *pTrusteeType == TRUSTEE_IS_GROUP) &&
        SIDUse != SidTypeWellKnownGroup && SIDUse != SidTypeAlias)
    {
        hr = CO_E_NOMATCHINGSIDFOUND;
        goto Error;
    } // if

    LocalMemFree(pwszDomainName);
    *ppSID = pSID;
    return 0;

Error:
    if (pwszDomainName != NULL)
    {
        LocalMemFree(pwszDomainName);
    }
    if (pSID != NULL)
    {
        midl_user_free(pSID);
    }
    return hr;
} // GetSIDFromName

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: GetNameFromSID, NT specific
//
// Summary: This function takes a security identifier (SID) as an input
//          and finds the trustee name in the form <Domain>\<User name> that
//          corresponds to the SID. This function will allocate memory for
//          the trustee name returned to the caller so the caller should
//          release the trustee name pointer using LocalMemFree whem the
//          trustee name is no longer in use.
//
// Args: LPWSTR *ppwszTrustee [out] - Address of the pointer to the trustee
//                                    name to be returned to the caller. The
//                                    trustee name returned is in the form
//                                    <Domain>\<User name>. The caller is
//                                    responsible for releasiung the memory
//                                    allocated for the trustee string once
//                                    it is no longer in use.
//
//       PSID   pSID [in] - Pointer to a security identifier. This function
//                          will return the trustee name corresponding to
//                          this security identifier through the ppwszTrustee
//                          argument.
//
//       TRUSTEE_TYPE TrusteeType [in] - The type associating with the
//                                       trustee name that the caller is
//                                       expecting.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed. The client can call
//                          GetLastError to obtain extended error inforamtion.
//                   E_OUTOFMEMORY: The system ran out of memory.
//
// Called by: ValidateAndTransformAccReqList
//
// Notes: On error LookupAccountSid returns strlen+1, on success it returns
//        only strlen.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT GetNameFromSID
(
LPWSTR          *ppwszTrustee,
PSID            pSID,
TRUSTEE_TYPE    *pTrusteeType
)
{
    LPWSTR          pwszDomainName  = NULL;
    DWORD           dwDomainLength;  // Length of the domain string
    LPWSTR          pwszAccountName = NULL;
    DWORD           dwAccountLength; // Length of the account string
    LPWSTR          pwszTrustee;     // Pointer to the trustee string in the form
                                     // <Domain>\<User name>
    DWORD           dwLastError;     // Return code obtained from GetLastError
    HRESULT         hr = S_OK;
    SID_NAME_USE    SIDUse;          // An enumerated variable indicating
                                     // what the SID returned by LookupAccountSD.

    // We trap the magic SID that specifies everyone
    if (EqualSid(&gEveryone, pSID))
    {

        if (*pTrusteeType != TRUSTEE_IS_GROUP)
        {
            return E_INVALIDARG;
        } // if

        if (*ppwszTrustee = (LPWSTR)LocalMemAlloc(2*sizeof(WCHAR)))
        {
            (*ppwszTrustee)[0] = L'*';
            (*ppwszTrustee)[1] = L'\0';
            *pTrusteeType = TRUSTEE_IS_GROUP;
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    } // if


    // Assign some arbitrary large number as the size of the domain name and
    // the account name. Hopefully, these numbers are large enough so that
    // the function can avoid calling LookupAccountSidW the second time
    dwDomainLength = 32;
    dwAccountLength = 64;

    // Initilize the domain name pointer and the account name pointer to NULL
    pwszDomainName = NULL;
    pwszAccountName = NULL;

    // Allocate big buffers for the domain name and the account name
    // to minimize the chance of call LookupAccountSid twice.
    pwszDomainName = (LPWSTR)LocalMemAlloc(dwDomainLength * sizeof(WCHAR));

    if (pwszDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    pwszAccountName = (LPWSTR)LocalMemAlloc(dwAccountLength * sizeof(WCHAR));
    if (pwszAccountName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    if(!LookupAccountSidW( NULL
                         , pSID
                         , pwszAccountName
                         , &dwAccountLength
                         , pwszDomainName
                         , &dwDomainLength
                         , &SIDUse))
    {
        dwLastError = GetLastError();
        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            if(dwDomainLength > 32)
            {
                LocalMemFree(pwszDomainName);
                pwszDomainName = (LPWSTR)LocalMemAlloc(dwDomainLength *
                                                       sizeof(WCHAR));
                if (pwszDomainName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Error;
                } //if
            } // if

            if(dwAccountLength > 64)
            {
                LocalMemFree(pwszAccountName);
                pwszAccountName = (LPWSTR)LocalMemAlloc(dwAccountLength *
                                                        sizeof(WCHAR));
                if (pwszAccountName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Error;
                } // if
            } // if

            if(!LookupAccountSidW( NULL
                                 , pSID
                                 , pwszAccountName
                                 , &dwAccountLength
                                 , pwszDomainName
                                 , &dwDomainLength
                                 , &SIDUse ))
            {
                // Either the SID doesn't belong to any account or something
                // has gone terribly wrong. In either case, the caller should
                // call GetLastError to get more information about the error
                hr = CO_E_LOOKUPACCSIDFAILED;
                goto Error;
            } // if

        } // if
        else
        {
            // The caller should call GetLastError to obtain more information
            hr = CO_E_LOOKUPACCSIDFAILED;
            goto Error;
        } // if

    } // if

    // Check to see if the SIDtype retuned by LookupAccountSidW matches the
    // trustee type provided by the caller. If not, we're in trouble.
    // SidTypeWellKnownGroup and SidTypeAlias can be either.
    if( !(SIDUse == SidTypeUser && *pTrusteeType == TRUSTEE_IS_USER)   &&
        !(SIDUse == SidTypeGroup && *pTrusteeType == TRUSTEE_IS_GROUP) &&
        SIDUse != SidTypeWellKnownGroup && SIDUse != SidTypeAlias)
    {
        hr = CO_E_NOMATCHINGSIDFOUND;
        goto Error;
    } // if

    // Allocate memory for the trustee string to be returned
    // Add 2 for null terminating the string and '\\'

    // We need to use the correct lengths now. The docs for LookUpAccountSID
    // do not promise that it returns corrected lengths upon success.
    dwDomainLength = lstrlenW(pwszDomainName);
    dwAccountLength = lstrlenW(pwszAccountName);

    pwszTrustee = (LPWSTR)midl_user_allocate( (dwDomainLength
                                               + dwAccountLength
                                               + 2) * sizeof(WCHAR)
                                            );

    if (pwszTrustee == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    // Compose the trustee string
    memcpy(pwszTrustee, pwszDomainName, dwDomainLength * sizeof(WCHAR));
    pwszTrustee[dwDomainLength] = L'\\';
    memcpy(&pwszTrustee[dwDomainLength+1], pwszAccountName, 
                (dwAccountLength+1) * sizeof(WCHAR));   //copies NULL terminator

    *ppwszTrustee = pwszTrustee;

Error:
    // Release the domain name string and the account name string
    if (pwszAccountName != NULL)
    {
        LocalMemFree(pwszAccountName);
    } // if
    if (pwszDomainName != NULL)
    {
        LocalMemFree(pwszDomainName);
    } // if
    return hr;
} // GetNameFromSID

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: PutStreamACLIntoSecDesc, NT specific
//
// Summary: This functions takes a STREAM_ACL structure and maps it to a
//          discretionary ACL in a security descriptor. The buffer for the
//          discretionary ACL and the security descriptor are packaged
//          into the NT version of ACL_DESCRICPTOR.
//
// Args: STREAM_ACL *pStreamACL [in] - The STREAM_ACL structure to be mapped
//                                     to a discretionary ACL.
//       ACL_DESCRIPTOR *pACLDesc [in,out] - The NT version of ACL_DESCRIPTOR
//                                           structure. This structure contains
//                                           a buffer for the discretionary
//                                           ACL, a security descriptor, size
//                                           information, and a control flag.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   E_OUTOFMEMORY: The system ran out of memory for allocating
//                                  the NT ACL.
//
// Called by: ComputeEffectiveAccess
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT PutStreamACLIntoSecDesc
(
STREAM_ACL     *pStreamACL,
ACL_DESCRIPTOR *pACLDesc
)
{
    ACL        *pACLHeader;         // Pointer to the ACL structure in the ACL
                                    // buffer.
    ULONG      i;                   // Loop counter
    CHAR       *pBufferPtr;         // Pointer for traversing the ACL buffer.
    ULONG      ulNumOfStreamACEs;   // Total number of STREAM_ACE structures to map.
    STREAM_ACE *pStreamACEsPtr;     // Pointer for traversing the array of
                                    // of STREAM_ACE structures to be mapped.
    ACE_HEADER *pACEHeader;         // Pointer to the header of an ACE.
    ULONG      ulACLSize;
    WORD       wSIDSize;            // Size of the SID to be copied into an ACE.

    // Compute the total size of the ACL buffer
    ulACLSize = pACLDesc->ulSIDSize
              + (pStreamACL->ulNumOfGrantEntries + pStreamACL->ulNumOfDenyEntries)
              * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
              + sizeof(ACL);

    // Reallocate a new buffer for the NT ACL if the current buffer is not
    // big enough. Note that an extra 64 bytes is padded at the end to
    // minimize the need for reallocating the buffer if the internal ACL
    // is changed in a minor way.
    if (pACLDesc->ulACLBufferSize < ulACLSize)
    {
        LocalMemFree(pACLDesc->pACLBuffer);
        pACLDesc->pACLBuffer = (CHAR *)LocalMemAlloc(ulACLSize + 64);
        if (pACLDesc->pACLBuffer == NULL)
        {
            pACLDesc->ulACLBufferSize = 0;
            return E_OUTOFMEMORY;
        } // if
        pACLDesc->ulACLBufferSize = ulACLSize + 64;
    } // if

    // Map the stream ACL to the NT ACL
    ulNumOfStreamACEs = pStreamACL->ulNumOfDenyEntries
                      + pStreamACL->ulNumOfGrantEntries;

    // Set up the ACL header first
    pACLHeader = (ACL *)(pACLDesc->pACLBuffer);
    pACLHeader->AclRevision = ACL_REVISION2;
    pACLHeader->AclSize = (USHORT)ulACLSize;
    pACLHeader->AceCount = (USHORT)ulNumOfStreamACEs;


    pBufferPtr = (CHAR *)(pACLDesc->pACLBuffer) + sizeof(ACL);
    pStreamACEsPtr = pStreamACL->pACL;

    // The following for loop maps the STREAM_ACE structures into the
    // ACL buffer for NT.
    for (i = 0; i < ulNumOfStreamACEs; i++)
    {
        // ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACE are
        // structurally equivalent, so I may as well use one of them
        pACEHeader = &(((ACCESS_ALLOWED_ACE *)pBufferPtr)->Header);

        // Skip ACEs with NULL SID
        if(pStreamACEsPtr->pSID == NULL)
        {
            continue;
        } // if

        if (pStreamACEsPtr->grfAccessMode == ACTRL_ACCESS_DENIED)
        {
            pACEHeader->AceType = ACCESS_DENIED_ACE_TYPE;
        }
        else
        {
            pACEHeader->AceType = ACCESS_ALLOWED_ACE_TYPE;
        } // if

        pACEHeader->AceFlags = NULL;
        StandardMaskToNTMask( &(pStreamACEsPtr->grfAccessPermissions)
                            , &(((ACCESS_ALLOWED_ACE *)pBufferPtr)->Mask));
        wSIDSize = (USHORT)GetLengthSid(pStreamACEsPtr->pSID);
        CopySid( wSIDSize
               , &(((ACCESS_ALLOWED_ACE *)pBufferPtr)->SidStart)
               , pStreamACEsPtr->pSID);
        pACEHeader->AceSize = sizeof(ACCESS_ALLOWED_ACE)
                            - sizeof(DWORD)
                            + wSIDSize;

        // Increment the ACL buffer to the next available slot
        // for the the next ACE
        pBufferPtr += pACEHeader->AceSize;

        // Increment the stream ACE porinter to point to the next
        // STREAM_ACE structure to be mapped
        pStreamACEsPtr++;
    } // for

    // Call SetSecurityDescriptorDACL to put the mapped
    // NT ACL into the security desriptor. The security should be initialized
    // with a group SID and a group SID by now. See the
    // COAccessControl::CImpAccessControl:Load method for details.
    if(!SetSecurityDescriptorDacl( &(pACLDesc->SecDesc)
                                 , TRUE
                                 , (ACL *)(pACLDesc->pACLBuffer)
                                 , FALSE))
    {
        return CO_E_FAILEDTOSETDACL;
    } // if

    pACLDesc->bDirtyACL = FALSE;
    return 0;

} // PutStreamACLIntoSecurityDescriptor

/////////////////////////////////////////////////////////////////////////////
//
// The access mask conversion routines
//
// Notes: The DCOM implementation of IAccessControl only supports the
//        execute permission and so the following functions are hard-coded to
//        convert the execute permission only. However, these function can be
//        extended to support a wider range of permissions without
//        substantantial changes in the rest of the code. For an even more
//        generic architecture, a table of mask conversion can be used.
//
/////////////////////////////////////////////////////////////////////////////

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: StandardMaskToNTMask
//
// Summary: This function maps the content of a access permissions
//          supported by IAccessControl to the corresponding NT
//          security access mask.
//
// Args:  DWORD *pStdMask [in] - The standard mask to be converted to NT
//                               mask.
//        ACCESS_MASK *pNTMask [out] - Reference to the converted mask.
//
//
// Return: void
//
// Called by: PutStreamACLIntoSecDesc
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void StandardMaskToNTMask
(
DWORD       *pStdMask,
ACCESS_MASK *pNTMask
)
{
    *pNTMask= 0;


    if ((*pStdMask & COM_RIGHTS_EXECUTE) != 0)
    {
        *pNTMask |= NT_RIGHTS_EXECUTE;
    } // if

} // StandardMaskToNTMask

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: NTMaskToStandardMask, NT specific
//
// Summary: This function maps the content of an NT access mask to a
//          corresponding IAccessControl access mask.
//
// Args:  ACCESS_MASK *pNTMask [in] - Address of the NT mask to be covnverted.
//        DWORD *pStdMask [in] - Address of the converted IAccessControl
//                               access mask.
//
// Return: void
//
// Called by: ComputeEffectiveAccess
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void NTMaskToStandardMask
(
ACCESS_MASK *pNTMask,
DWORD       *pStdMask
)
{
    *pStdMask= 0;

    if ((*pNTMask & NT_RIGHTS_EXECUTE) != 0)
    {
        *pStdMask |= COM_RIGHTS_EXECUTE;
    } // if

} // NTMaskToStandardMask

// End of caccctrl.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\acext.h ===
//+-------------------------------------------------------------------
//
//  File:       acext.h
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  Contents:   Definitions shared by access control implementation
//
//--------------------------------------------------------------------

// Variables imported from the acsrv module
extern IMalloc *g_pIMalloc;  // Cached pointer to memory allocator
extern ULONG g_ulHeaderSize;
extern UINT  g_uiCodePage;   // Code page used for Chicago string converion

// Define the set of access mask supported
// Memory management functions local to the server
extern void * LocalMemAlloc(SIZE_T);
extern void   LocalMemFree(void *);

// A table can be used to store mask in a more elegant manner
// COM_RIGHTS_EXECUTE is defined in objbase.h

#ifndef COM_RIGHTS_EXECUTE
#define COM_RIGHTS_EXECUTE      0x00000001
#endif
#define COM_RIGHTS_ALL          (COM_RIGHTS_EXECUTE)

#define NT_RIGHTS_EXECUTE       (COM_RIGHTS_EXECUTE)
#define NT_RIGHTS_ALL           (NT_RIGHTS_EXECUTE)

// Define the stream version code
#define STREAM_VERSION 0x00000001

// A GUID string containing the braces and dashes
// but no null character at the end has exactly
// 38 characters.
#define GUID_SIZE 38
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\caccctrl.h ===
/*---------------------------------------------------------------------------

 File: CAccCntrl.h

 Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.

 Description: This file contains the class definitions of COAccessControl,
              CImpAccessControl, and CFAccessControl.
              Note that the class and structure declarations contained in
              are not meant to be used and seen directly by developers who
              only uses the IAccessControl interface.

 Classes:  COAccessControl - This is the principle class that implements
                             the DCOM IAccessControl component object.
                             Except the nondelegating IUnknown interface, the
                             COAccessControl class supports the IPersist,
                             IPersistStream and IAccessControl interfaces by
                             exposing its inner CImpAccessCOntrol pointer.
                             Through this arrangement, the COAccessControl
                             class is able to support aggregation by
                             controlling the object to which the IUnknown
                             calls of the inner CImpAccess control are
                             delegated at object contruction.

           CImpAccessControl - This is the class that nested inside
                               COAccessControl. CImpAccessControl
                               implements the IPersist, IPersistStream,
                               IAccessControl  interfaces and the IUnknown
                               interface which always delegates the call to
                               the IUnknown methods of the controlling object.
                               When COAccessControl is not part of an
                               aggregate CImpAccessControl IUnknown calls
                               should be delegated to its outer
                               COAccessControl, otherwise the IUnknown calls
                               should be delegated to the object controlling
                               the outer COAccessControl object.

           CFAccessControl - Class factory for manufacturing COAccessControl
                             objects.

 Notes: The definition of IAccessControl interface can be found in
        oleext.h in ...sdk\inc and the data types that are defined to use with
        IAccessControl can be found in sdk\inc\accctrl.h.

--------------------------------------------------------------------------*/

#ifndef _CACCCNTRL_H_
#define _CACCCNTRL_H_

//////////////////////////////////////////////////////////////////////////////
// Internal data types
//////////////////////////////////////////////////////////////////////////////

/*////////////////////////////////////////////////////////////////////////////
 PCB- Pickle Control Block.
      Originally intended to be a structure for maintaining the information
      about the pickling buffer, the PCB has become something that transcends
      its intended purposes. Besides data related to the pickling buffer, the
      structure also contains a copy of the access control object's ACL in a
      format that can readily be serialized into a buffer by one of the type
      encoding function generated by the midl compiler, see acpickl.idl for
      details. The bDirtyHandle and the bPickled fields in the PCB structure
      are control flags which allows better coordination between different
      methods in CImpAccessControl. The purpose of the bDirtyHandle flag is
      to minimize the number of times the encoding handle has to be reset
      and the purpose of the bPickled flag is to minimize the number of times
      the ACL has to be serialized into a buffer.

////////////////////////////////////////////////////////////////////////////*/
typedef struct tagPCB
{
    char       *pPicklingBuff;      // This pointer is always aligned on the 8-byte
                                    // boundary
    char       *pTruePicklingBuff;  // This is the true pickling buffer pointer
    ULONG      ulPicklingBuffSize;  // Size of the pickling buffer after the 8-byte alignment
    ULONG      ulBytesUsed;         // This field indicates the number of bytes requires
                                    // to serialize the interanl ACL
    STREAM_ACL StreamACL;           // The stream format ACL
    handle_t   PickleHandle;        // Handle for encoding and decoding
    BOOL       bDirtyHandle;        // This flag indicates whether the handle needs to be reset
    BOOL       bPickled;            // This flag indicates whether the current stream ACL has been encoded
                                    // into the pickling buffer.
    ULONG      ulMaxNumOfStreamACEs;// The maximum number of stream ACEs that the StreamACL structure has been allocated for
    ULONG      ulNumOfStreamACEs;   // The number of stream ACEs that the StreamACL structure is holding

} PCB;

///////////////////////////////////////////////////////////////////////////////
// The following is supposed to be the ACL descriptor on the Windows NT
// platform. Since the Windows NT version of DCOM IAccessControl implementation
// is still under developement, the content of the following structure may
// change in the future.
//////////////////////////////////////////////////////////////////////////////
typedef struct tagACL_DESCRIPTOR
{
    void                *pACLBuffer;     // Pointer to the NT ACL buffer
    ULONG               ulACLBufferSize; // Size of the ACL buffer
    ULONG               ulSIDSize;       // Exacted size of all the SIDs in the NT ACL
    BOOL                bDirtyACL;       // This flag indicates whether the internal
                                         // ACL has been chcanged since the last time
                                         // it was mapped to an NT ACL.
    SECURITY_DESCRIPTOR SecDesc;         // We need the security descriptor to call
                                         // AccessCheck

} ACL_DESCRIPTOR;

//////////////////////////////////////////////////////////////////////////////
// CFAccessControl - COAccessControl class factory.
//////////////////////////////////////////////////////////////////////////////

class CFAccessControl : public IClassFactory
{
private:

    // Private variables.
    LONG               m_cRefs; // Object reference count

public:

    // IUnknown methods

    STDMETHODIMP_(HRESULT) QueryInterface
    (
    REFIID iid,
    void   **ppv
    );

    STDMETHODIMP_(ULONG) AddRef(void);

    // If the object's reference count reaches zero, the RElease method will
    // decrement the global object count named g_cObjects in acsrv.cxx.
    STDMETHODIMP_(ULONG) Release(void);


    // IClassFactory methods
    // Upon successful creation of a new COAccessControl object,
    // the following function will increment the global object
    // count named g_cObjects by one.
    STDMETHODIMP_(HRESULT) CreateInstance
    (
    IUnknown *pUnkOuter,
    REFIID   riid,
    void     **ppv
    );

    // The following method relies on a global lock count named g_cServer
    // which is maintained inside acsrv.cxx.
    STDMETHODIMP_(HRESULT) LockServer
    (
    BOOL fLock
    );

    // Constructor
    CFAccessControl(void);

    // Destructor
    ~CFAccessControl(void);

}; // CFAccessControl

//////////////////////////////////////////////////////////////////////////////
// COAccessControl - The DCOM IAccessControl implementation component. The
//                   COAccessControl componnet is implemented as a nested
//                   class to support aggregation.
//////////////////////////////////////////////////////////////////////////////
class COAccessControl : public IUnknown
{
public:

    // Main object IUnknown Methods - These IUnknown methods are non-delegating
    STDMETHODIMP_(HRESULT) QueryInterface
    (
    REFIID riid,
    void   **ppv
    );

    STDMETHODIMP_(ULONG) AddRef(void);

    // The following method relies on a global lock count named g_cServer
    // which is maintained inside acsrv.cxx.
    STDMETHODIMP_(ULONG) Release(void);

    // Constructor
    COAccessControl(void);
    STDMETHODIMP_(HRESULT) Init(IUnknown *pOuter);

    // Destructor
    ~COAccessControl(void);

    //////////////////////////////////////////////////////////////////////
    // CImpAccessControl - This class is nested inside COAccessControl.
    //                     The CImpAccessControl class implements
    //                     the IPersistStream interface, IPersist interface
    //                     , and the IAccessControl interface
    //////////////////////////////////////////////////////////////////////
    class CImpAccessControl : public IPersistStream, public IAccessControl
    {
    public:

        // IUnknown methods, all calls are delegated to the controlling object.
        STDMETHODIMP_(HRESULT) QueryInterface
        (
        REFIID riid,
        void   **ppv
        );

        STDMETHODIMP_(ULONG) AddRef(void);

        STDMETHODIMP_(ULONG) Release(void);

        // IPersist method

        STDMETHODIMP_(HRESULT) GetClassID
        (
        CLSID *pClassID
        );

        // IPersistStream Methods
        STDMETHODIMP_(HRESULT) IsDirty
        (
        void
        );
		
        // Object initialization method. This method must be called
        // before any non-IUnknown methods.
        STDMETHODIMP_(HRESULT)Load
        (
        IStream *pStm
        );

        STDMETHODIMP_(HRESULT)Save
        (
        IStream *pStm,
        BOOL    fClearDirty
        );

        STDMETHODIMP_(HRESULT) GetSizeMax
        (
        ULARGE_INTEGER *pcdSize
        );

        // IAccessControl Methods
        STDMETHODIMP_(HRESULT) GrantAccessRights
        (
        PACTRL_ACCESSW pAccessList
        );

        // This function is not implemented.
        STDMETHODIMP_(HRESULT) SetAccessRights
        (
        PACTRL_ACCESSW pAccessList
        );

        // This function is not implemented.
        STDMETHODIMP_(HRESULT) SetOwner
        (
        PTRUSTEEW pOwner,
        PTRUSTEEW pGroup
        );

        STDMETHODIMP_(HRESULT) RevokeAccessRights
        (
        LPWSTR         lpProperty,
        ULONG          cCount,
        TRUSTEEW       pTrustee[]
        );

        STDMETHODIMP_(HRESULT) GetAllAccessRights
        (
        LPWSTR               lpProperty,
        PACTRL_ACCESSW      *ppAccessList,
        PTRUSTEEW           *ppOwner,
        PTRUSTEEW           *ppGroup
        );

        STDMETHODIMP_(HRESULT) IsAccessAllowed
        (
        PTRUSTEEW            pTrustee,
        LPWSTR               lpProperty,
        ACCESS_RIGHTS        AccessRights,
        BOOL                *pfAccessAllowed
        );

        // Constructor
        CImpAccessControl
        (
        IUnknown *pBackPtr,
        IUnknown *pUnkOuter,
        HRESULT *phrCtorResult
        );

        // Destructor
        ~CImpAccessControl(void);


    private:

        STDMETHODIMP_(void) CleanupAccessList
        (
        BOOL           fReleaseAll,
        STREAM_ACE    *pStreamACEReqs,
        void          *pACEReqs,
        ULONG          cGrant,
        ULONG          cDeny
        );

        STDMETHODIMP_(HRESULT) AddAccessList
        (
        STREAM_ACE    *pStreamACEReqs,
        void          *pACEReqs,
        ULONG          ulEstPickledSize,
        ULONG          cGrant,
        ULONG          cDeny
        );

        STDMETHODIMP_(HRESULT) GetEffAccRights
        (
        TRUSTEE_W *pTrustee,
        DWORD     *pdwRights
        );

        // Static data members
        BOOL                 m_bInitialized; // Object initialization flag.
        BOOL                 m_bDirty;       // This flag is set to TRUE if the
                                             // object has been changed since the
                                             // last save.
        BOOL                 m_bLockValid;   // TRUE if m_ACLLock was initialized
        IUnknown             *m_pUnkOuter;   // Pointer to the controlling object's
                                             // IUnkown implementation.
        CRITICAL_SECTION     m_ACLLock;      // Critical section object for
                                             // protecting the ACL from concurrent
                                             // access.
        CEffPermsCacheLUID   m_Cache;        // Access check results cache indexed
                                             // by LUID.
        ACL_DESCRIPTOR       m_ACLDesc;      // Platform dependent  representation
                                             // of the ACL
        PCB                  m_pcb;          // Pickle control block

    }; // COAccessControl::CImpAccessControl

    // Private variables

    LONG              m_cRefs;       // Object's reference count
    CImpAccessControl *m_ImpObj;     // Pointer to the inner CImpAccessControl object

}; // COAccessControl


#endif // #ifndef _CACCCNTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\cache.h ===
//+---------------------------------------------------------------------------
//
// File: Cache.h
//
// Description: This file contains the definition of the CEffectivePermsCache
//              class which is used by the COleDs_AcccessControl class to
//              speed up the access checking process. Access to the cache is
//              made thread safe through the use of a critical section object.
// Classes:  CEffectivePermsCache
//
// See the Cache.cpp source file for detail description of each of the
// methods.
//+---------------------------------------------------------------------------

#ifndef _CACHE_H_
#define _CACHE_H_
#define CACHE_SIZE 23

class CEffPermsCacheLUID
{
public:

    BOOL LookUpEntry
    (
    LUID   lClient,
    DWORD *pdwEffectivePermissions
    );

    BOOL WriteEntry
    (
    LUID  lClient,
    DWORD dwEffectivePermissions
    );

    BOOL DeleteEntry
    (
    LUID lClient
    );

    void FlushCache(void);

    void DumpCache(void);

    // constructor
    CEffPermsCacheLUID(void);

    // destructor
    ~CEffPermsCacheLUID(void);


private:

    typedef struct tagCACHE_ENTRY
    {
        LUID    lClient;
        DWORD   dwEffectivePermissions;
    } CACHE_ENTRY;

    CACHE_ENTRY m_cache[CACHE_SIZE];
    DWORD Hash(LUID lClient);
    CRITICAL_SECTION m_CacheLock;
    BOOL m_bLockValid;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\makeidl.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

MIDL_FLAGS= \
        -Zp8 \
        -Oicf \
        -I$(INCLUDES:;= -I) -I.. \
        -char unsigned \
        -error allocation \
        -error bounds_check \
        -error stub_data \
        -robust \
        -cpp_cmd $(TARGET_CPP) \
        -DMIDL_PASS $(C_DEFINES)

$(O)\acpickl.h: ..\acpickl.idl ..\acpickl.acf
        $(MIDL) $(MIDL_FLAGS) \
		-server none -header $@ -cstub $(@:.h=_c.c) ..\acpickl.idl

allidl: $(O)\acpickl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\cache.cxx ===
//+---------------------------------------------------------------------------
//
// File: cache.cxx
//
// Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
// Description: This file contains the implementation of the
//              CEffectivePermsCache class. The cache is implemented as a hash
//              without any fancy mechanism to handle collisions. If a
//              collision occur, the old entry is simply overwritten.
//
// Classes:  CEffectivePermsCache
//
//+---------------------------------------------------------------------------

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include "Cache.h"
#define BIG_PRIME 48271
#define SMALL_PRIME 2683

#include "acext.h"

const DWORD LUID_LEN = 8;

inline BOOL IsEqualLUID( LUID x, LUID y )
{
  return x.LowPart == y.LowPart && x.HighPart == y.HighPart;
}

CEffPermsCacheLUID::CEffPermsCacheLUID(void)
{
    // Set the whole cache to null
    memset(m_cache, 0 , CACHE_SIZE * sizeof(CACHE_ENTRY));
    // Create an instance of the critical section object.
    m_bLockValid = NT_SUCCESS(RtlInitializeCriticalSection(&m_CacheLock));
}

// destructor
CEffPermsCacheLUID::~CEffPermsCacheLUID(void)
{
    // Flush the cache to free memory allocated for strings
    FlushCache();
    // Destroy critical section object
    if (m_bLockValid)
        DeleteCriticalSection(&m_CacheLock);
}


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::Hash, private
//
// Summary: This function returns a hash value for a security identifier.
//
// Args: PLUID pLUID [in] - Pointer to a security identifier.
//
// Modifies: Nothing
//
// Return: DWORD - The hash value of the LUID.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

DWORD CEffPermsCacheLUID::Hash
(
LUID lClient
)
{
    DWORD  dwHashValue = 0;
    CHAR   *pLUIDBuff = (CHAR *)&lClient;

    for (USHORT i = 0; i < LUID_LEN; i++, pLUIDBuff++)
    {
        dwHashValue = ((dwHashValue + *pLUIDBuff) * SMALL_PRIME) % BIG_PRIME;
    } // for

    return (dwHashValue % CACHE_SIZE);

} // Hash

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::LookUpEntry
//
// Summary: This function search for the effective permission of a trustee
//          given the trustee's security identifier.
//
// Args: PLUID pLUID [in] - Security identifier of the trustee.
//
// Modifies: Nothing.
//
// Return: TRUE - If the the trustee's effective permission is found in
//                the cache.
//         FALSE - Otherwise.
//
// Actions: 1) Computes the hash value of the input LUID, k.
//          2) Compares the LUID in the kth entry of the cache with the
//             trustee's LUID.
//          3) If the trustee's LUID matches, sets *pdwEffectivePermissions to the
//             effective permissions in the cache entry and return TRUE.
//          4) Returns FALSE otherwise.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffPermsCacheLUID::LookUpEntry
(
LUID    lClient,
DWORD  *pdwEffectivePermissions
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(lClient);
    BOOL         fFound      = FALSE;
	
    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    if (IsEqualLUID(pCacheEntry->lClient, lClient))
    {
        *pdwEffectivePermissions = pCacheEntry->dwEffectivePermissions;
        fFound = TRUE;
    } // if

    LeaveCriticalSection(&m_CacheLock);
    return fFound;
} // LookUpEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::DeleteEntry
//
// Summary: This function search for the effective permission of a
//
// Args: PLUID pLUID [in] - Security identifier of the trustee.
//
// Modifies: Nothing.
//
// Return: TRUE - If the the trustee's effective permission is found in
//                the cache.
//         FALSE - Otherwise.
//
// Actions: 1) Computes the hash value of the input LUID, k.
//          2) Compares the LUID in the kth entry of the cache with the
//             trustee's LUID.
//          3) If the trustee's LUID matches, frees memory allocated for
//             *pCacheEntry->pLUID, sets *pCacheEntry->pLUID to
//             NULL and returns TRUE.
//          4) Returns FALSE otherwise.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffPermsCacheLUID::DeleteEntry
(
LUID lClient
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(lClient);
    BOOL fFound = FALSE;

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    if (IsEqualLUID(pCacheEntry->lClient, lClient ))
    {
        fFound = TRUE;
        pCacheEntry->lClient.HighPart = 0;
        pCacheEntry->lClient.LowPart  = 0;
    } // if

    LeaveCriticalSection(&m_CacheLock);
    return fFound;
} // DeleteEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::WriteEntry
//
// Summary: This function writes a new entry to the cache. In case of a hash
//          collision the old entry is overwritten.
//
// Args: PLUID pLUID [in] - Security identifier of the trustee.
//       DWORD  dwEffectivePermissions [in] - The set of effective
//                                            permissions that belong to the
//                                            trustee.
//
// Modifies: m_cache - The object's private hash table.
//
// Return: TRUE - If the operation is successful.
//         FALSE - If there is not enough memory to allocate the new string.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffPermsCacheLUID::WriteEntry
(
LUID   lClient,
DWORD  dwEffectivePermissions
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(lClient);

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    pCacheEntry->lClient                = lClient;
    pCacheEntry->dwEffectivePermissions = dwEffectivePermissions;
    LeaveCriticalSection(&m_CacheLock);
    return TRUE;
} // WriteEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::FlushCache
//
// Summary: This function empties the cache
//
// Args: void
//
// Modifies: m_cache - The object's private hash table
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

void CEffPermsCacheLUID::FlushCache
(
void
)
{
    USHORT i = 0;
    CACHE_ENTRY *pCache;

    if (!m_bLockValid)
        return;

    EnterCriticalSection(&m_CacheLock);
    for ( i = 0, pCache = m_cache
        ; i < CACHE_SIZE
        ; i++, pCache++)
    {
        pCache->lClient.LowPart = 0;
        pCache->lClient.HighPart = 0;
    } // for
    LeaveCriticalSection(&m_CacheLock);
    return;
} // FlushCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   accctrl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES= $(O)
INCLUDES= $(INCLUDES);..\..\inc;..\..\..\ih;..\..\dcomrem;..\..\objact
INCLUDES= $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES= $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES= $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES= $(INCLUDES);$(BASE_INC_PATH);$(SDK_INC_PATH)


C_DEFINES=    \
              $(C_DEFINES)  \
              -D_WIN32_DCOM

SOURCES=      \
              $(O)\acpickl_c.c   \
              ..\acsrv.cxx  \
              ..\cache.cxx  \
              ..\caccctrl.cxx

# Generate stubs from idl files
NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\accctrl\daytona\makefile.inc ===
!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\apcompat\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   apcompat
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = obj
INCLUDES=     $(INCLUDES);..\..\..\idl\public\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\inc
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)


C_DEFINES=    $(C_DEFINES) -DDARWIN_ENABLED -DMSWMSG

SOURCES=      $(SOURCES)                                      \
              ..\apcompat.cxx

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\apcompat\apcompat.cxx ===
//+-------------------------------------------------------------------
//
//  File:       apcompat.cxx
//
//  Contents:   Code that provides information about app compatibility 
//              flags for the current process
//
//  Classes:    None
//
//  Functions:  GetAppCompatInfo
//              UseFTMFromCurrentApartment
//              ValidateInPointers
//              ValidateOutPointers
//              ValidateCodePointers
//              ValidateInterfaces
//              ValidateIIDs
//              
//
//  History:    05-Apr-2000   mfeingol
//
//--------------------------------------------------------------------

#include <ole2int.h>

#include "apcompat.hxx"


STDAPI_(BOOL) UseFTMFromCurrentApartment()
{
    return (BOOL)APPCOMPATFLAG(KACF_FTMFROMCURRENTAPT);
}

STDAPI_(BOOL) DisallowDynamicORBindingChanges()
{
    return (BOOL)APPCOMPATFLAG(KACF_DISALLOWORBINDINGCHANGES);
}


STDAPI_(BOOL) ValidateInPointers()
{
    return (BOOL)APPCOMPATFLAG(KACF_OLE32VALIDATEPTRS);
}

STDAPI_(BOOL) ValidateOutPointers()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}

STDAPI_(BOOL) ValidateCodePointers()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}

STDAPI_(BOOL) ValidateInterfaces()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}

STDAPI_(BOOL) ValidateIIDs()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\catalog.cxx ===
/* catalog.cxx */
#include <windows.h>
#include <comdef.h>
#include <debnot.h>

#define CATALOG_DEFINES
#include "globals.hxx"
#undef CATALOG_DEFINES

#include "catalog.h"        // from catalog.idl
#include "catalog_i.c"      // from catalog.idl
#include "partitions.h"     // from partitions.idl

#include "notify.hxx"       // CNotify needed for CCache
#include "cache.hxx"        // CCache

#include "catalog.hxx"      // CComCatalog
#include "regcat.hxx"       // Registry Catalog interface
#include "sxscat.hxx"       // side-by-side catalog interface

#include "noclass.hxx"      // CComNoClassInfo
#include "services.hxx"     // Hash()

#define MAX_SID             (128)   /* 28 is typical */

/*
 *  globals
 */

LONG g_bInSCM=FALSE;

const WCHAR g_wszCom3ActivationValue[] = L"Com+Enabled";

CComCatalog s_catalogObject;
CCache* s_pCacheClassInfo = NULL;         // CLSID->ClassInfo cache
CCache* s_pCacheApplicationInfo = NULL;   // APPID->ApplicationInfo cache
CCache* s_pCacheProcessInfo = NULL;       // ProcessID->ProcessInfo cache
CCache* s_pCacheServerGroupInfo = NULL;
CCache* s_pCacheRetQueueInfo = NULL;
CCache* s_pCacheProgID = NULL;            // ProgID->ClassInfo cache

DECLARE_INFOLEVEL(Catalog);               // Catalog debug tracing

/* need this here.... */

static void * __cdecl operator new(size_t cbAlloc, size_t cbExtra)
{
    return(::new char[cbAlloc + cbExtra]);
}

BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_CatalogLock.Initialize();
        break;

    case DLL_PROCESS_DETACH:
        g_CatalogLock.Cleanup();
        break;
    }

    return(TRUE);
}


STDAPI GetCatalogHelper
(
/* [in] */ REFIID riid,
/* [out, iis_is(riid)] */ void ** ppv
)
{
    return s_catalogObject.QueryInterface(riid, ppv);
}

HRESULT CComCatalogCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }
    else if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        return s_catalogObject.QueryInterface(riid, ppv);
    }
}

/*
 *  class CComCatalog
 */

BOOL CComCatalog::ms_fComPlusEnabled = FALSE;
BOOL CComCatalog::ms_fComPlusEnabledInitialized = FALSE;
BOOL CComCatalog::ms_fComPlusCatalogsResolved = FALSE;

CComCatalog::CComCatalog(void) : m_pCatalogRegNative(NULL), m_pCatalogRegNonNative(NULL), m_pCatalogCOMBaseInCLB(NULL),
                                 m_pCatalogCLB(NULL), m_cRef(0), m_pCatalogSxS(NULL)
{
}


STDMETHODIMP CComCatalog::QueryInterface
(
    REFIID riid,
    LPVOID FAR* ppvObj
)
{
    HRESULT hr;

    *ppvObj = NULL;

    if (riid == IID_IComCatalog)
    {
        *ppvObj = (LPVOID) (IComCatalog *) this;
    }
    else if (riid == IID_IComCatalog2)
    {
        *ppvObj = (LPVOID) (IComCatalog2 *) this;
    }
    else if (riid == IID_IComCatalogSCM)
    {
        *ppvObj = (LPVOID) (IComCatalogSCM *) this;
    }
    else if (riid == IID_IComCatalogInternal)
    {
        *ppvObj = (LPVOID) (IComCatalogInternal *) this;
    }
    else if (riid == IID_IComCatalog2Internal)
    {
        *ppvObj = (LPVOID) (IComCatalog2Internal *) this;
    }
    else if (riid == IID_IUnknown)
    {
        *ppvObj = (LPVOID) (IComCatalog *) this;
    }
    else if (riid == IID_IComCatalogSettings)
    {
        *ppvObj = (LPVOID) (IComCatalogSettings *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN) *ppvObj)->AddRef();

        return(NOERROR);
    }

    /* maybe the Component Library's catalog interface supports this mystery IID */
    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return(hr);
        }
    }

    if (m_pCatalogCOMBaseInCLB != NULL)
    {
        hr = m_pCatalogCOMBaseInCLB->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return (hr);
        }
    }

    /* maybe the registry's catalog interface supports this mystery IID */
    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return(hr);
        }
    }

    /* maybe the side by side catalog supports this mystery IID */
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return(hr);
        }
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComCatalog::AddRef(void)
{
    long cRef;

    if (!ms_fComPlusCatalogsResolved)
        TryToLoadCLB();

    g_CatalogLock.AcquireWriterLock();

    if ( m_cRef == 0 )
    {
        /* Start up registry and COM+ catalog providers */

        /* Use the process default registry             */
        GetRegCatalogObject(IID_IComCatalogInternal, 
                            (void **) &m_pCatalogRegNative, 
                            0);
        
        GetSxSCatalogObject(IID_IComCatalogInternal,
                            (void **) &m_pCatalogSxS);

#if defined(_WIN64)
        /* On Win64, the SCM needs to have a look at the 32 bit registry too */

        /* Note: the logic in here that decides when we create the non-native registry provider needs to be
           the same as the logic in com1x/src/comcat/catalogqueries/clbcatq/legcat.cxx that decides when to 
           request a non-native registry provider.  If they get out of sync, bad things will happen. */

        if (g_bInSCM)
        {
            GetRegCatalogObject(IID_IComCatalogInternal, 
                                (void **) &m_pCatalogRegNonNative,
                                KEY_WOW64_32KEY);
        }
#endif

        /* Initializes caches */

        s_regNotifyMgr.Initialize();
        
        /* If you comment out one of these "new" calls and the associated */
        /* SetupNotify's, that will safely disable the particular cache */

        if (s_pCacheClassInfo == NULL)
        {
            s_pCacheClassInfo = new CCache;
        }
            
        if(s_pCacheClassInfo)
        {
            s_pCacheClassInfo->SetupNotify (REGNOTIFY_HKLM_CLASSES | REGNOTIFY_HKLM_COM3 | REGNOTIFY_HKU);
        }

        if (s_pCacheProgID == NULL)
        {
            s_pCacheProgID = new CCache;
        }

        if (s_pCacheProgID)
        {
            s_pCacheProgID->SetupNotify (REGNOTIFY_HKLM_CLASSES | REGNOTIFY_HKLM_COM3 | REGNOTIFY_HKU);
        }
            
        if (s_pCacheApplicationInfo == NULL)
        {
            s_pCacheApplicationInfo = new CCache;
        }
            
        if(s_pCacheApplicationInfo)
        {
            s_pCacheApplicationInfo->SetupNotify (REGNOTIFY_HKLM_COM3 | REGNOTIFY_HKLM_CLASSES_CLSID);
        }
            
        if (s_pCacheProcessInfo == NULL)
        {
            s_pCacheProcessInfo = new CCache;
        }
            
        if(s_pCacheProcessInfo)
        {
            s_pCacheProcessInfo->SetupNotify (REGNOTIFY_HKLM_CLASSES | REGNOTIFY_HKLM_COM3 | REGNOTIFY_HKU);
        }

        if (s_pCacheServerGroupInfo == NULL)
        {
            s_pCacheServerGroupInfo = new CCache;
        }
            
        if(s_pCacheServerGroupInfo)
        {
            s_pCacheServerGroupInfo->SetupNotify (REGNOTIFY_HKLM_COM3);
        }

        if (s_pCacheRetQueueInfo == NULL)
        {
            s_pCacheRetQueueInfo = new CCache;
        }

        if(s_pCacheRetQueueInfo)
        {
            s_pCacheRetQueueInfo->SetupNotify (REGNOTIFY_HKLM_COM3 | REGNOTIFY_HKLM_CLASSES_CLSID);
        }

        s_regNotifyMgr.CreateNotification (this, REGNOTIFY_HKLM_CLASSES | REGNOTIFY_HKLM_COM3, NULL);
    }

    cRef = ++m_cRef;

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


STDMETHODIMP_(ULONG) CComCatalog::Release(void)
{
    long cRef;

    g_CatalogLock.AcquireWriterLock();

    cRef = --m_cRef;
    if ( m_cRef == 0 )
    {
        if (s_pCacheClassInfo != NULL)
        {
            s_pCacheClassInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheClassInfo;
            s_pCacheClassInfo = NULL;
        }

        if (s_pCacheProgID != NULL)
        {
            s_pCacheProgID->Flush(CCACHE_F_ALL);

            delete s_pCacheProgID;
            s_pCacheProgID = NULL;
        }

        if (s_pCacheApplicationInfo != NULL)
        {
            s_pCacheApplicationInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheApplicationInfo;
            s_pCacheApplicationInfo = NULL;       
        }

        if (s_pCacheProcessInfo != NULL)
        {
            s_pCacheProcessInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheProcessInfo;
            s_pCacheProcessInfo = NULL; 
        }

        if (s_pCacheServerGroupInfo != NULL)
        {
            s_pCacheServerGroupInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheServerGroupInfo;
            s_pCacheServerGroupInfo = NULL;  
        }

        if (s_pCacheRetQueueInfo != NULL)
        {
            s_pCacheRetQueueInfo->Flush(CCACHE_F_ALL);
            
            delete s_pCacheRetQueueInfo;
            s_pCacheRetQueueInfo = NULL;  
        }

        if (m_pCatalogRegNative != NULL)
        {
            m_pCatalogRegNative->Release();
            m_pCatalogRegNative = NULL;
        }

        if (m_pCatalogRegNonNative != NULL)
        {
            m_pCatalogRegNonNative->Release();
            m_pCatalogRegNonNative = NULL;
        }

        if ( m_pCatalogCLB != NULL )
        {
            m_pCatalogCLB->Release();
            m_pCatalogCLB = NULL;
        }

        if (m_pCatalogCOMBaseInCLB != NULL)
        {
            m_pCatalogCOMBaseInCLB->Release();
            m_pCatalogCOMBaseInCLB = NULL;
        }

        ms_fComPlusEnabled = FALSE;
        ms_fComPlusEnabledInitialized = FALSE;
        ms_fComPlusCatalogsResolved = FALSE;

        if (m_pCatalogSxS != NULL)
        {
            m_pCatalogSxS->Release();
            m_pCatalogSxS = NULL;
        }

        s_regNotifyMgr.Uninitialize();
    }

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


/* IComCatalog methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfo
(
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfo (IComCatalog)\n"));

    hr = GetClassInfoInternal (CLSCTX_ALL, NULL, guidConfiguredClsid, riid, 
                               ppv, NULL);

    CatalogDebugOut((DEB_CLASSINFO, 
                     "CComCatalog::GetClassInfo (IComCatalog) returning 0x%08x\n", hr));

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfo
(
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfo (NULL, guidApplId, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfo
(
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetProcessInfoInternal (0, NULL, guidProcess, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetServerGroupInfo
(
/* [in] */ REFGUID guidServerGroup,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetServerGroupInfo (NULL, guidServerGroup, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetRetQueueInfo
(
/* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetRetQueueInfo (NULL, wszFormatName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfoForExe
(
/* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfoForExe (NULL, pwszExeName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetTypeLibrary
(
/* [in] */ REFGUID guidTypeLib,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetTypeLibrary (NULL, guidTypeLib, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetInterfaceInfo
(
/* [in] */ REFIID iidInterface,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetInterfaceInfo (NULL, iidInterface, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::FlushCache(void)
{
    g_CatalogLock.AcquireWriterLock();

    if (s_pCacheClassInfo != NULL) s_pCacheClassInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheProgID != NULL) s_pCacheProgID->Flush(CCACHE_F_ALL);
    if (s_pCacheApplicationInfo != NULL) s_pCacheApplicationInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheProcessInfo != NULL) s_pCacheProcessInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheServerGroupInfo != NULL) s_pCacheServerGroupInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheRetQueueInfo != NULL) s_pCacheRetQueueInfo->Flush(CCACHE_F_ALL);

    FlushProviderCaches();

    g_CatalogLock.ReleaseWriterLock();
    return(S_OK);
}

void STDMETHODCALLTYPE CComCatalog::FlushProviderCaches()
{
    if (m_pCatalogCLB != NULL)
    {
        m_pCatalogCLB->FlushCache();
    }

    if (m_pCatalogCOMBaseInCLB != NULL)
    {
        m_pCatalogCOMBaseInCLB->FlushCache();
    }

    if (m_pCatalogRegNative != NULL)
    {
        m_pCatalogRegNative->FlushCache();
    }

    if (m_pCatalogRegNonNative != NULL)
    {   
        m_pCatalogRegNonNative->FlushCache();
    }

    // The SxS catalog does not have a cache, but to be uniform with the rest of the providers,
    // we'll tell it to flush its cache.
    if (m_pCatalogSxS != NULL)
    {
        m_pCatalogSxS->FlushCache();
    }
}

//
//  FlushIdleEntries
// 
//  A directive to flush idle and otherwise recently-unused
//  elements.
//
HRESULT STDMETHODCALLTYPE CComCatalog::FlushIdleEntries()
{
    // This method was once used to flush out idle cached
    // tokens.  Now we don't cache tokens.  So this is a 
    // noop.  Might be useful in future though.

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoFromProgId
(
/* [in] */ WCHAR __RPC_FAR *wszProgID,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetClassInfoFromProgId (NULL, wszProgID, riid, ppv, NULL);

    return(hr);
}

/* IComCatalog2 methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByPartition
(
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetClassInfoByPartition(NULL, guidConfiguredClsid, guidPartitionId, riid, ppv, NULL);

    return(hr);
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByApplication
(
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetClassInfoByApplication(NULL, guidConfiguredClsid, guidPartitionId, guidApplId, riid, ppv, NULL);

    return(hr);
}

/* IComCatalogSCM methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfo
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    CatalogDebugOut((DEB_CLASSINFO, 
                     "CComCatalog::GetClassInfo (IComCatalogSCM) flags = %x\n",flags));

    hr = GetClassInfoInternal (flags, pUserToken, guidConfiguredClsid, riid, 
                               ppv, NULL);

    CatalogDebugOut((DEB_CLASSINFO, 
                     "CComCatalog::GetClassInfo (IComCatalogSCM) returning 0x%08x\n", hr));

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfo
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfo (pUserToken, guidApplId, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfo
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetProcessInfoInternal (flags, pUserToken, guidProcess, riid, 
                                 ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetServerGroupInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidServerGroup,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetServerGroupInfo (pUserToken, guidServerGroup, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetRetQueueInfo
(
/* [in] */ IUserToken* pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetRetQueueInfo (pUserToken, wszFormatName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfoForExe
(
/* [in] */ IUserToken* pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfoForExe (pUserToken, pwszExeName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetTypeLibrary
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFGUID guidTypeLib,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetTypeLibrary (pUserToken, guidTypeLib, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetInterfaceInfo
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFIID iidInterface,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetInterfaceInfo (pUserToken, iidInterface, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoFromProgId
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ WCHAR __RPC_FAR *wszProgID,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetClassInfoFromProgId (pUserToken, wszProgID, riid, ppv, NULL);

    return(hr);
}


/* IComCatalogInternal methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    return GetClassInfoInternal (CLSCTX_ALL, pUserToken, guidConfiguredClsid,
                                 riid, ppv, pComCatalog);
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pApplicationInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    EnsureCatalogProviders();

    // Give the side-by-side catalog first crack at providing the data because
    // it needs to override any cached definitions.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (s_pCacheApplicationInfo != NULL)
    {
        hr = s_pCacheApplicationInfo->GetElement(
            guidApplId.Data1,
            (BYTE *) &guidApplId,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            &pApplicationInfo);
        if (hr == S_OK)
        {
            hr = pApplicationInfo->QueryInterface(riid, ppv);

            pApplicationInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheApplicationInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheApplicationInfo->AddElement(
            guidApplId.Data1,
            (BYTE *) &guidApplId,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pApplicationInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pApplicationInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pApplicationInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pApplicationInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    return GetProcessInfoInternal (0, pUserToken, guidProcess, riid, ppv,
                                   pComCatalog);
}


//
// This is the static helper version of GetProcessInfoInternal.
// This is called by the CComClassInfo object to get the associated 
// CComProcessInfo.
//
HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfoInternal
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;
    IUnknown *pProcessInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    s_catalogObject.EnsureCatalogProviders();

    // Check the side-by-side catalog before checking the cache because the active activation context
    // must take precedent over any cached activation metadata.
    if (s_catalogObject.m_pCatalogSxS != NULL)
    {
        hr = s_catalogObject.m_pCatalogSxS->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, NULL);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;
            goto addToCache;
        }
    }

    if (s_pCacheProcessInfo != NULL)
    {
        BYTE *rgpbKeys[]  = { (BYTE *)&guidProcess, pSid,  (BYTE *)&flags };
        USHORT rgcbKeys[] = { sizeof(GUID),         cbSid, sizeof(flags)  };

        hr = s_pCacheProcessInfo->GetElement(
            guidProcess.Data1,
            sizeof(rgpbKeys) / sizeof(rgpbKeys[0]),
            rgpbKeys,
            rgcbKeys,
            &fValueFlags,
            &pProcessInfo);
        if (hr == S_OK)
        {
            hr = pProcessInfo->QueryInterface(riid, ppv);

            pProcessInfo->Release();

            return(hr);
        }
    }

    //See which catalog is needed...
    if (flags & CAT_REG32_ONLY)
    {
        //This should only happen if we're getting a request from a
        //CComClassInfo object that the SCM created from the 32 bit registry.
        Win4Assert (g_bInSCM);
        Win4Assert (s_catalogObject.m_pCatalogRegNonNative);

        //Force to lookup in the 32bit registry...
        hr = s_catalogObject.m_pCatalogRegNonNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **)&pProcessInfo, NULL);

        fValueFlags = CCACHE_F_CLASSIC32;
    }
    else
    {
        //Lookup in default registry...
        hr = s_catalogObject.m_pCatalogRegNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, NULL);

        fValueFlags = CCACHE_F_CLASSIC;
    }

    if (hr != S_OK)
    {
        return(hr);
    }

addToCache:

    if (s_pCacheProcessInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        BYTE *rgpbKeys[]  = { (BYTE *)&guidProcess, pSid,  (BYTE *)&flags };
        USHORT rgcbKeys[] = { sizeof(GUID),         cbSid, sizeof(flags)  };

        hr = s_pCacheProcessInfo->AddElement(
            guidProcess.Data1,
            sizeof(rgpbKeys) / sizeof(rgpbKeys[0]),
            rgpbKeys,
            rgcbKeys,
            &fValueFlags,
            pProcessInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pProcessInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pProcessInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }
    
    *ppv = pProcessInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetServerGroupInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidServerGroup,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pServerGroupInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    EnsureCatalogProviders();

    // Check the side-by-side catalog before checking the cache because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (s_pCacheServerGroupInfo != NULL)
    {
        hr = s_pCacheServerGroupInfo->GetElement(
            guidServerGroup.Data1,
            (BYTE *) &guidServerGroup,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            &pServerGroupInfo);
        if (hr == S_OK)
        {
            hr = pServerGroupInfo->QueryInterface(riid, ppv);

            pServerGroupInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheServerGroupInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheServerGroupInfo->AddElement(
            guidServerGroup.Data1,
            (BYTE *) &guidServerGroup,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pServerGroupInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pServerGroupInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pServerGroupInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pServerGroupInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetRetQueueInfo
(
/* [in] */ IUserToken *pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pRetQueueInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    USHORT cbFormatName;
    DWORD iHashValue;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    cbFormatName = (USHORT) (2 * lstrlenW(wszFormatName));

    iHashValue = Hash((byte *) wszFormatName, cbFormatName);

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    EnsureCatalogProviders();

    // Check the side-by-side catalog before checking the cache because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (s_pCacheRetQueueInfo != NULL)
    {
        hr = s_pCacheRetQueueInfo->GetElement(
            iHashValue,
            (BYTE *) wszFormatName,
            cbFormatName,
            pSid,
            cbSid,
            &fValueFlags,
            &pRetQueueInfo);
        if (hr == S_OK)
        {
            hr = pRetQueueInfo->QueryInterface(riid, ppv);

            pRetQueueInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }


    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheRetQueueInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheRetQueueInfo->AddElement(
            iHashValue,
            (BYTE *) wszFormatName,
            cbFormatName,
            pSid,
            cbSid,
            &fValueFlags,
            pRetQueueInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pRetQueueInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pRetQueueInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pRetQueueInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfoForExe
(
/* [in] */ IUserToken *pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;

    *ppv = NULL;

    EnsureCatalogProviders();

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetTypeLibrary
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidTypeLib,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;

    *ppv = NULL;

    EnsureCatalogProviders();

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetInterfaceInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFIID iidInterface,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;

    *ppv = NULL;

    EnsureCatalogProviders();

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoFromProgId
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ WCHAR __RPC_FAR *wszProgID,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pClassInfo = NULL;
    IUnknown *pPrevious = NULL;
    IUnknown *pNoClassInfo = NULL;
    USHORT fValueFlags;


    *ppv = NULL;

    if (wszProgID == NULL)
        return E_INVALIDARG;

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetClassInfoFromProgId(pUserToken, wszProgID, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    // I got this hash from COM+'s map_t.h.
    DWORD dwHash = 0x01234567;
    WCHAR *pwc = wszProgID;
    while (*pwc) dwHash = (dwHash << 5) + (dwHash >> 27) + *pwc++;
    USHORT cbProgID = (USHORT)((pwc - wszProgID + 1) * sizeof(WCHAR));

    EnsureCatalogProviders();

    if (s_pCacheProgID != NULL)
    {
        hr = s_pCacheClassInfo->GetElement(dwHash,
                                           (BYTE *)wszProgID,
                                           cbProgID,
                                           &fValueFlags,
                                           &pClassInfo);
        if (hr == S_OK)
        {
            if (pClassInfo != NULL)
            {
                hr = pClassInfo->QueryInterface(riid, ppv);
                
                pClassInfo->Release();
                
                if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;            
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCOMBaseInCLB != NULL)
    {
        hr = m_pCatalogCOMBaseInCLB->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }


    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            // Or with CCACHE_F_ALWAYSCHECK to force a re-read of the
            // registry when things are cached and the registry changes.
            fValueFlags = CCACHE_F_CLASSIC | CCACHE_F_ALWAYSCHECK;
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

/****
 * Just skip it... I don't think I need to worry about bitness issues here.
 * If I do, I also need to modify the implementation of 
 * CComRegCatalog::GetClassInfoFromProgId.
 *
 *  if (m_pCatalogRegNonNative != NULL)
 *  {
 *      hr = m_pCatalogRegNonNative->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
 *      if (hr == S_OK)
 *      {
 *          fValueFlags = CCACHE_F_CLASSIC32;
 *          goto addToCache;
 *      }
 *      else if (hr == E_NOINTERFACE)
 *      {
 *          return(hr);
 *      }
 *  }
 */

    pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(wszProgID);
    if (pNoClassInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);

    if (hr != S_OK)
    {
        delete pClassInfo;
        return(hr);
    }

    fValueFlags = CCACHE_F_NOTREGISTERED;

 addToCache:

    if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheClassInfo->AddElement(dwHash,
                                           (BYTE *)wszProgID,
                                           cbProgID,
                                           &fValueFlags,
                                           pClassInfo,
                                           &pPrevious);
        if (hr == E_CACHE_DUPLICATE)
        {
            if (pClassInfo != NULL)
            {
                pClassInfo->Release();
            }

            if (pPrevious != NULL)
            {
                hr = pPrevious->QueryInterface(riid, (void **)&pClassInfo);
                pPrevious->Release();
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            if (hr != S_OK)
                return(hr);
        }
    }

    *ppv = pClassInfo;

    if (fValueFlags & CCACHE_F_NOTREGISTERED)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


/* IComCatalog2Internal */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByPartition
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFGUID guidPartitionId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pClassInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    IUnknown *pNoClassInfo = NULL;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    EnsureCatalogProviders();

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    CLSID key[2];
    key[0] = guidConfiguredClsid;
    key[1] = guidPartitionId;

    if (s_pCacheClassInfo != NULL)
    {
        hr = s_pCacheClassInfo->GetElement(
                                          guidConfiguredClsid.Data1,
                                          (BYTE *) key,
                                          sizeof(key),
                                          pSid,
                                          cbSid,
                                          &fValueFlags,
                                          &pClassInfo);
        if (hr == S_OK)
        {
            if (pClassInfo != NULL)
            {
                hr = pClassInfo->QueryInterface(riid, ppv);

                pClassInfo->Release();

                if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            return(hr);
        }

    }

    if (m_pCatalogCLB != NULL)
    {
        IComCatalog2Internal *pCatalogCLB2 = NULL;
        hr = m_pCatalogCLB->QueryInterface(IID_IComCatalog2Internal, (void**) &pCatalogCLB2);

        if(SUCCEEDED(hr))
        {
            hr = pCatalogCLB2->GetClassInfoByPartition(pUserToken, guidConfiguredClsid, guidPartitionId, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
            pCatalogCLB2->Release();

            if (hr == S_OK)
            {
                fValueFlags = CCACHE_F_REGDB;

                goto addToCache;
            }
            else if (hr != REGDB_E_CLASSNOTREG)
            {
                return(hr);
            }
        }
        else
        {
            hr = REGDB_E_CLASSNOTREG;
        }
    }

    pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(guidConfiguredClsid);
    if (pNoClassInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);
    if (hr != S_OK)
    {
        delete pClassInfo;
        return(hr);
    }
  
    fValueFlags = CCACHE_F_NOTREGISTERED;

    addToCache:

    if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheClassInfo->AddElement(
                                          guidConfiguredClsid.Data1,
                                          (BYTE *) key,
                                          sizeof(key),
                                          pSid,
                                          cbSid,
                                          &fValueFlags,
                                          pClassInfo,
                                          &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            if (pClassInfo != NULL)
            {
                pClassInfo->Release();
            }

            if (pPrevious != NULL)
            {
                hr = pPrevious->QueryInterface(riid, (void **) &pClassInfo);

                pPrevious->Release();
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pClassInfo;

    if (fValueFlags & CCACHE_F_NOTREGISTERED)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return(hr);
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByApplication
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFGUID guidPartitionId,
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pClassInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    IUnknown *pNoClassInfo = NULL;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    EnsureCatalogProviders();

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    CLSID key[3];
    key[0] = guidConfiguredClsid;
    key[1] = guidPartitionId;
    key[2] = guidApplId;

    if (s_pCacheClassInfo != NULL)
    {
        hr = s_pCacheClassInfo->GetElement(
                                          guidConfiguredClsid.Data1,
                                          (BYTE *) key,
                                          sizeof(key),
                                          pSid,
                                          cbSid,
                                          &fValueFlags,
                                          &pClassInfo);
        if (hr == S_OK)
        {
            if (pClassInfo != NULL)
            {
                hr = pClassInfo->QueryInterface(riid, ppv);

                pClassInfo->Release();

                if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            return(hr);
        }

    }

    if (m_pCatalogCLB != NULL)
    {
        IComCatalog2Internal *pCatalogCLB2 = NULL;
        hr = m_pCatalogCLB->QueryInterface(IID_IComCatalog2Internal, (void**) &pCatalogCLB2);

        if(SUCCEEDED(hr))
        {
            hr = pCatalogCLB2->GetClassInfoByApplication(pUserToken, guidConfiguredClsid, guidPartitionId, guidApplId, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
            pCatalogCLB2->Release();

            if (hr == S_OK)
            {
                fValueFlags = CCACHE_F_REGDB;

                goto addToCache;
            }
            else if (hr != REGDB_E_CLASSNOTREG)
            {
                return(hr);
            }
        }
        else
        {
            hr = REGDB_E_CLASSNOTREG;
        }
    }

    pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(guidConfiguredClsid);
    if (pNoClassInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);
    if (hr != S_OK)
    {
        delete pClassInfo;
        return(hr);
    }
  
    fValueFlags = CCACHE_F_NOTREGISTERED;

    addToCache:

    if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheClassInfo->AddElement(
                                          guidConfiguredClsid.Data1,
                                          (BYTE *) key,
                                          sizeof(key),
                                          pSid,
                                          cbSid,
                                          &fValueFlags,
                                          pClassInfo,
                                          &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            if (pClassInfo != NULL)
            {
                pClassInfo->Release();
            }

            if (pPrevious != NULL)
            {
                hr = pPrevious->QueryInterface(riid, (void **) &pClassInfo);

                pPrevious->Release();
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pClassInfo;

    if (fValueFlags & CCACHE_F_NOTREGISTERED)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return(hr);
}


// Allows a way for somebody to get a reference on our legacy pure-registry-based
// catalog providers.
HRESULT STDMETHODCALLTYPE CComCatalog::GetNativeRegistryCatalog(REFIID riid, void** ppv)
{
    EnsureCatalogProviders();

    return m_pCatalogRegNative ? m_pCatalogRegNative->QueryInterface(riid, ppv) : E_OUTOFMEMORY;
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetNonNativeRegistryCatalog(REFIID riid, void** ppv)
{
    EnsureCatalogProviders();

    return m_pCatalogRegNonNative ? m_pCatalogRegNonNative->QueryInterface(riid, ppv) : E_OUTOFMEMORY;
}

/* private methods */


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoInternal
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pClassInfo = NULL;
    IUnknown *pPrevious = NULL;
    IComClassInfo *pICCI = NULL;
    USHORT fValueFlags = 0;
    IUnknown *pNoClassInfo = NULL;
    BYTE *pSid = NULL;
    USHORT cbSid;
    DWORD clsctxFilter;
    DWORD clsctxPrevious;

    // The keys for the cache.   
    BYTE   *apKey[3];
    USHORT  acbKey[3];


    CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal flags=%x\n", flags));
    CatalogDebugOut((DEB_CLASSINFO, 
                     "CComCatalog::GetClassInfoInternal CLSID={%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n", 
                     (DWORD)guidConfiguredClsid.Data1,
                     (DWORD)guidConfiguredClsid.Data2,
                     (DWORD)guidConfiguredClsid.Data3,
                     (DWORD)guidConfiguredClsid.Data4[0],
                     (DWORD)guidConfiguredClsid.Data4[1],
                     (DWORD)guidConfiguredClsid.Data4[2],
                     (DWORD)guidConfiguredClsid.Data4[3],
                     (DWORD)guidConfiguredClsid.Data4[4],
                     (DWORD)guidConfiguredClsid.Data4[5],
                     (DWORD)guidConfiguredClsid.Data4[6],
                     (DWORD)guidConfiguredClsid.Data4[7]));
    *ppv = NULL;

    EnsureCatalogProviders();

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before any others (including a cache) because the active 
    // activation context  must take precedent over any cached activation metadata.
    if (m_pCatalogSxS)
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in COM SxS Catalog...\n"));    
        hr = m_pCatalogSxS->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in COM SxS Catalog!\n"));
            fValueFlags = CCACHE_F_SXS;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
                    pICCI->Release();
                }
            } 
            else 
            {
                clsctxFilter = 1;
            }

            if (SUCCEEDED(hr) && clsctxFilter)
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                goto addToCache; // REVIEW: Do you really need to do this?
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    // Fill in the keys for cache lookup.
    apKey[0]  = (BYTE *)&guidConfiguredClsid; // Key 1: CLSID
    acbKey[0] = sizeof(CLSID);
    apKey[1]  = pSid;                         // Key 2: SID
    acbKey[1] = cbSid;
    apKey[2]  = (BYTE *)&flags;               // Key 3: Validation flags
    acbKey[2] = sizeof(DWORD);
    
    if (s_pCacheClassInfo != NULL)
    {
        // Use the multi-key version lookup
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in cache\n"));

        hr = s_pCacheClassInfo->GetElement(guidConfiguredClsid.Data1,
                                           3,
                                           apKey,
                                           acbKey,
                                           &fValueFlags,
                                           &pClassInfo);
        if (hr == S_OK)
        {
            // There is no need to validate the response from the cache as
            // we would other pieces-- if the data got into the cache with
            // the matching flags, then it had already passed all the 
            // reqirements.
            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in cache!\n"));
            if (pClassInfo != NULL)
            {
                hr = pClassInfo->QueryInterface(riid, ppv);

                pClassInfo->Release();

                if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            return(hr);
        }

    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    if (m_pCatalogCLB != NULL)
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in REGDB\n"));
        hr = m_pCatalogCLB->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in REGDB!\n"));
            fValueFlags = CCACHE_F_REGDB;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
                    pICCI->Release();
                }
            } 
            else 
            {
                clsctxFilter = 1;
            }

            if (SUCCEEDED(hr) && clsctxFilter)
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                goto addToCache;
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    if (m_pCatalogCOMBaseInCLB)
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in COM Base CLB...\n"));   
        hr = m_pCatalogCOMBaseInCLB->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in COM Base CLB!\n"));
            fValueFlags = CCACHE_F_REGDB;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
                    pICCI->Release();
                }
            } 
            else 
            {
                clsctxFilter = 1;
            }

            if (SUCCEEDED(hr) && clsctxFilter)
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                goto addToCache;
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }


    //
    // The registry catalog providers.
    //
    // Since the introduction of reflection in the 64bit world, things are not so pretty.
    // We need to make sure that we are always on the correct side of the registry.  Instead
    // of trying to invent some generic mechanism for deciding among all of the different
    // providers, though, I'm just going to hard-code the logic for the registry provider
    // here.  
    //
    // 1. If the CLSID provided by the 64bit registry supports CLSCTX_LOCAL_SERVER, choose
    //    it.
    // 2. If the CLSID provided by the 32bit registry supports CLSCTX_LOCAL_SERVER, choose
    //    IT.
    // 3. Otherwise, choose the 64bit registry provider.
    //
    // This is only in a 64bit SCM.
    //
    if ((m_pCatalogRegNative != NULL) && !(flags & CAT_REG32_ONLY))
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in registry...\n"));
        hr = m_pCatalogRegNative->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in registry!\n"));
            fValueFlags = CCACHE_F_CLASSIC;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
                    pICCI->Release();
                }

                // SPECIAL REGISTRY CATALOG LOGIC
                if (SUCCEEDED(hr) && clsctxFilter)
                {
                    // If we asked for LOCAL_SERVER, make sure we get the right one here.
                    if ((clsctxFilter & CLSCTX_LOCAL_SERVER) || !(flags & CLSCTX_LOCAL_SERVER))
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                        if (pPrevious)
                        {
                            pPrevious->Release();
                            pPrevious = NULL;
                        }
                        goto addToCache;
                    }
                    else
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Not quite acceptable, but all right...\n"));
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...so we'll check the next provider.\n"));

                        // Hold on to this result so we can use it in the 32bit registry (next)
                        clsctxPrevious = clsctxFilter;
                        pPrevious = pClassInfo;
                        pPrevious->AddRef();
                    }
                }
            }
            else 
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable (by default)!\n"));
                goto addToCache;
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    if ((m_pCatalogRegNonNative != NULL) && !(flags & CAT_REG64_ONLY))
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in 32bit registry...\n"));
        hr = m_pCatalogRegNonNative->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in 32bit registry!\n"));
            fValueFlags = CCACHE_F_CLASSIC32;

            //If the caller wants, make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
                    pICCI->Release();
                }

                // SPECIAL REGISTRY CATALOG LOGIC
                if (SUCCEEDED(hr) && clsctxFilter)
                {
                    // If we asked for LOCAL_SERVER, make sure we get the right one here.
                    if ((clsctxFilter & CLSCTX_LOCAL_SERVER) || !(flags & CLSCTX_LOCAL_SERVER))
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                        if (pPrevious)
                        {
                            pPrevious->Release();
                            pPrevious = NULL;
                        }
                        goto addToCache;
                    }
                    else
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Not quite acceptable, but all right...\n"));
                        if (pPrevious)
                        {
                            // Favor 64bit in this situation.
                            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...so we favor the previous result.\n"));
                            pClassInfo->Release();
                            pClassInfo = pPrevious;
                            pPrevious = NULL;
                        }
                        else
                        {
                            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...so we take it anyway.\n"));
                        }

                        // OBVIOUS SPECIAL CASE:
                        // go to addToCache here because it's a success at the end of the line.
                        goto addToCache;
                    }
                }
            }
            else 
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable (by default)!\n"));
                goto addToCache;
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pPrevious)
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...nothing else was better.  Take it.\n"));
        pClassInfo = pPrevious;
        pPrevious = NULL;
        goto addToCache;
    }

    CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Not found...\n"));
    pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(guidConfiguredClsid);
    if (pNoClassInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);
    if (hr != S_OK)
    {
        delete pClassInfo;
        return(hr);
    }

    fValueFlags = CCACHE_F_NOTREGISTERED;

 addToCache:

    if (s_pCacheClassInfo != NULL && (fValueFlags & CCACHE_F_CACHEABLE))
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Add to cache...\n"));
        // Use the multi-key version
        hr = s_pCacheClassInfo->AddElement(
            guidConfiguredClsid.Data1,
            3,
            apKey,
            acbKey,
            &fValueFlags,
            pClassInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            if (pClassInfo != NULL)
            {
                pClassInfo->Release();
            }

            if (pPrevious != NULL)
            {
                hr = pPrevious->QueryInterface(riid, (void **) &pClassInfo);

                pPrevious->Release();
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pClassInfo;

    if (fValueFlags & CCACHE_F_NOTREGISTERED)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal returning 0x%08x\n", hr));
    return(hr);
}



HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfoInternal
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pProcessInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    // The keys for the cache.
    BYTE   *apKey[3];
    USHORT  acbKey[3];

    *ppv = NULL;

    EnsureCatalogProviders();

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    // Fill in the keys for cache lookup.
    apKey[0]  = (BYTE *)&guidProcess;  // Key 1: Process GUID
    acbKey[0] = sizeof(CLSID);
    apKey[1]  = pSid;                  // Key 2: SID
    acbKey[1] = cbSid;
    apKey[2]  = (BYTE *)&flags;        // Key 3: Validation flags
    acbKey[2] = sizeof(DWORD);

    if (s_pCacheProcessInfo != NULL)
    {
        hr = s_pCacheProcessInfo->GetElement(
            guidProcess.Data1,
            3,
            apKey,
            acbKey,
            &fValueFlags,
            &pProcessInfo);
        if (hr == S_OK)
        {
            hr = pProcessInfo->QueryInterface(riid, ppv);

            pProcessInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }


    // If the SCM requests it, we can ignore this catalog.
    if ((m_pCatalogRegNative != NULL) && !(flags & CAT_REG32_ONLY))
    {
        hr = m_pCatalogRegNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    // The SCM can also request to ignore this catalog.
    if ((m_pCatalogRegNonNative != NULL) && !(flags & CAT_REG64_ONLY))
    {
        hr = m_pCatalogRegNonNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheProcessInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheProcessInfo->AddElement(
            guidProcess.Data1,
            (BYTE *) &guidProcess,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pProcessInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pProcessInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pProcessInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pProcessInfo;

    return(S_OK);
}

void CComCatalog::EnsureCatalogProviders(void)
{
    // Attempt to initialize our catalog providers.
    //
    // All of these are best faith, and nobody depends on
    // any of these catalog providers actually being functional.
    // (Well I suppose the guy calling CoCreateInstance wants 
    // at least ONE of these to be functional, but he won't crash
    // if they aren't.)
    //
    if (!ms_fComPlusCatalogsResolved)
        TryToLoadCLB();

    BOOL fNeedLock = FALSE;
    if (m_pCatalogRegNative == NULL)
    {
        fNeedLock = TRUE;
    }
#if defined(_WIN64)
    else
    {
        if ((m_pCatalogRegNonNative == NULL) && (g_bInSCM))
        {
            fNeedLock = TRUE;
        }
    }
#endif

    if (fNeedLock)
    {
        g_CatalogLock.AcquireWriterLock();
                
        if (m_pCatalogRegNative == NULL)
        {
            HRESULT hr = GetRegCatalogObject(IID_IComCatalogInternal, (void **) &m_pCatalogRegNative, 0);
            if (FAILED(hr))
            {
                CatalogDebugOut((DEB_ERROR, 
                                 "EnsureCatalogProviders: Create m_pCatalogRegNative failed with 0x%08x\n", 
                                 hr));
            }
        }

#if defined(_WIN64)
        if ((m_pCatalogRegNonNative == NULL) && (g_bInSCM))
        {
            HRESULT hr = GetRegCatalogObject(IID_IComCatalogInternal, (void **) &m_pCatalogRegNonNative,
                                             KEY_WOW64_32KEY);            
            if (FAILED(hr))
            {
                CatalogDebugOut((DEB_ERROR, 
                                 "EnsureCatalogProviders: Create m_pCatalogRegNonNative failed with 0x%08x\n", 
                                 hr));
            }
        }
#endif
        
        g_CatalogLock.ReleaseWriterLock();
    }
}


BOOL CComCatalog::ComPlusEnabled()
{
    BOOL fEnabled = FALSE;
    HKEY hCom3Key = NULL;
    LONG lStatus;

    lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE, g_wszCom3, 0, KEY_READ, &hCom3Key);
    if (lStatus == ERROR_SUCCESS)
    {
        DWORD dwData = 0, dwType = REG_DWORD, dwDataSize = sizeof (dwData);
        
        lStatus = RegQueryValueExW (hCom3Key, g_wszCom3ActivationValue, 0, &dwType, (BYTE*) &dwData, &dwDataSize);
        if (lStatus == ERROR_SUCCESS && dwData != 0)
        {
            fEnabled = TRUE;
        }

        RegCloseKey (hCom3Key);
    }

    return fEnabled;
}


HRESULT CComCatalog::TryToLoadCLB(void)
{
    HRESULT hr = S_OK;
    
    if (!ms_fComPlusEnabledInitialized)
    {
        g_CatalogLock.AcquireWriterLock();
        if (!ms_fComPlusEnabledInitialized)
        {
            ms_fComPlusEnabled = ComPlusEnabled();
            if (!ms_fComPlusEnabled)
                ms_fComPlusCatalogsResolved = TRUE;

            ms_fComPlusEnabledInitialized = TRUE;
        }
        g_CatalogLock.ReleaseWriterLock();
    }

    if (ms_fComPlusEnabled)
    {
        if (!m_pCatalogCLB)
        {
            IComCatalogInternal* pCatalogCLB = NULL;
            hr = GetCatalogObject (IID_IComCatalogInternal, (void**) &pCatalogCLB);
            if (SUCCEEDED (hr))
            {
                // Best effort set SCM location
                IComCatalogLocation* pCatLocation = NULL;
                hr = pCatalogCLB->QueryInterface (IID_IComCatalogLocation, (void**) &pCatLocation);
                if (SUCCEEDED (hr) && pCatLocation != NULL)
                {
                    pCatLocation->SetCatalogLocation (g_bInSCM);
                    pCatLocation->Release();
                }

                if (InterlockedCompareExchangePointer ((void**) &m_pCatalogCLB, pCatalogCLB, NULL) != NULL)
                {
                    // We lost the race
                    pCatalogCLB->Release();
                }
                else
                {
                    FlushCache();
                }
            }
        }

        if (!m_pCatalogCOMBaseInCLB)
        {
            IComCatalogInternal* pCatalogCOMBaseInCLB = NULL;
            hr = GetCatalogObject2 (IID_IComCatalogInternal, (void **) &pCatalogCOMBaseInCLB);
            if (SUCCEEDED(hr))
            {
                // Best effort set SCM location
                IComCatalogLocation* pCatLocation = NULL;
                hr = pCatalogCOMBaseInCLB->QueryInterface (IID_IComCatalogLocation, (void **) &pCatLocation);
                if (SUCCEEDED (hr) && pCatLocation != NULL)
                {
                    pCatLocation->SetCatalogLocation (g_bInSCM);
                    pCatLocation->Release();
                }

                if (InterlockedCompareExchangePointer ((void**) &m_pCatalogCOMBaseInCLB, pCatalogCOMBaseInCLB, NULL) != NULL)
                {
                    // We lost the race
                    pCatalogCOMBaseInCLB->Release();
                }
                else
                {
                    FlushCache();
                }
            }
        }

        if (m_pCatalogCLB && m_pCatalogCOMBaseInCLB)
        {
            ms_fComPlusCatalogsResolved = TRUE;
        }
    }

    return S_OK;
}

HRESULT CComCatalog::RefreshComPlusEnabled()
{
    ms_fComPlusEnabledInitialized = FALSE;
    ms_fComPlusCatalogsResolved = FALSE;

    return S_OK;
}

void UpdateCOMPlusEnabled()
{
    // Refresh the catalog's COM+ enabled setting
    IComCatalogSettings* pCatSettings = NULL;
    HRESULT hr = GetCatalogHelper (IID_IComCatalogSettings, (void**) &pCatSettings);
    if (SUCCEEDED (hr))
    {
        pCatSettings->RefreshComPlusEnabled();
        pCatSettings->Release();
    }
}


//
// IRegNotify
//

void CComCatalog::Notify (ULONG ulNotifyMask)
{
    // We only expect notification for these events
    Win4Assert (!(ulNotifyMask & ~(REGNOTIFY_HKLM_CLASSES | REGNOTIFY_HKLM_COM3)));

    // Note: we can't take the catalog lock here because we risk deadlock with any of the cache locks,
    // which might be held by the current thread when we get this notification
    FlushProviderCaches();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\noclass.cxx ===
/* noclass.cxx */

#include <windows.h>
#include <comdef.h>

#include "globals.hxx"

#include "catalog.h"
#include "partitions.h"
#include "noclass.hxx"

#if DBG
#include <debnot.h>
#endif


/*
 *  class CComNoClassInfo
 */

CComNoClassInfo::CComNoClassInfo(REFGUID rclsid)
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_clsid = rclsid;
    m_wszProgID = NULL;

    m_ValueFlags = NCI_HAVECLSID;
}

CComNoClassInfo::CComNoClassInfo(WCHAR *wszProgID)
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_clsid = GUID_NULL;

    SIZE_T cchProgID = lstrlenW(wszProgID) + 1;
    m_wszProgID = new WCHAR[cchProgID];
    if (m_wszProgID)
    {
        m_ValueFlags = NCI_HAVEPROGID;
        memcpy(m_wszProgID, wszProgID, cchProgID * sizeof(WCHAR));
    }
}

CComNoClassInfo::CComNoClassInfo(REFGUID rclsid, WCHAR *wszProgID)
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_clsid = rclsid;
    m_ValueFlags = NCI_HAVECLSID;

    SIZE_T cchProgID = lstrlenW(wszProgID) + 1;
    m_wszProgID = new WCHAR[cchProgID];
    if (m_wszProgID)
    {
        m_ValueFlags |= NCI_HAVEPROGID;
        memcpy(m_wszProgID, wszProgID, cchProgID * sizeof(WCHAR));
    }
}


STDMETHODIMP CComNoClassInfo::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (riid == IID_IComClassInfo)
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }
    else if (riid == IID_IClassClassicInfo)
    {
    	*ppvObj = (LPVOID) (IClassClassicInfo *) this;
    }
#if DBG
    else if (riid == IID_ICacheControl)
    {
        *ppvObj = (LPVOID) (ICacheControl *) this;
    }
#endif
    else if (riid == IID_IUnknown)
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return(NOERROR);
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComNoClassInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComNoClassInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned NoClassInfo object");
#endif

        delete this;
    }

    return(cRef);
}


/* IComClassInfo methods */

HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetConfiguredClsid
(
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
)
{
    if (m_ValueFlags & NCI_HAVECLSID)
    {
        *ppguidClsid = &m_clsid;

        return(S_OK);
    }
    
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetProgId
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProgid
)
{
    if (m_ValueFlags & NCI_HAVEPROGID)
    {
        *pwszProgid = m_wszProgID;

        return (S_OK);
    }

    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetClassName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszClassName
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetApplication
(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetClassContext
(
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX __RPC_FAR *pclsctx
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetCustomActivatorCount
(
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long __RPC_FAR *pulCount
)
{
    // This does not return REGDB_E_CLASSNOTREG because the main activation
    // paths will blow up and not attempt class downloads.  (see GetInstanceHelper,
    // ICoCreateInstanceEx, and ICoGetClassObject in objact.cxx).  Plus
    // returning zero is an honest answer for an unregistered class...
    *pulCount = 0;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetCustomActivatorClsids
(
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *prgguidClsid
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetCustomActivators
(
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator __RPC_FAR *__RPC_FAR *__RPC_FAR *prgpActivator
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetTypeInfo
(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::IsComPlusConfiguredClass
(
    /* [out] */ BOOL __RPC_FAR *pfComPlusConfiguredClass
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::MustRunInClientContext
(
    /* [out] */ BOOL __RPC_FAR *pbMustRunInClientContext
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetVersionNumber
(
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::Lock(void)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::Unlock(void)
{
    return(REGDB_E_CLASSNOTREG);
}


/* IClassClassicInfo methods */

HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetThreadingModel
(
    /* [out] */ ThreadingModel __RPC_FAR *pthreadmodel
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetModulePath
(
    /* [in] */ CLSCTX clsctx,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszDllName
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetImplementedClsid
(
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
)
{
    *ppguidClsid = &m_clsid;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetProcess
(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetRemoteServerName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetLocalServerType
(
    /* [out] */ LocalServerType __RPC_FAR *pType
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetSurrogateCommandLine
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogateCommandLine
)
{
    return(REGDB_E_CLASSNOTREG);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComNoClassInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComNoClassInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\cache.cxx ===
/* cache.cxx */

#include <windows.h>
#include <comdef.h>

#include "notify.hxx"

#include "cache.hxx"

#if DBG
#include "partitions.h"    // ICacheControl
#endif

#include "catdbg.hxx"

#pragma warning(disable:4200)   /* zero-sized array in ELEMENT */

#define MIN_NOTIFY_TICKS    (100U)  /* minimum mS between notify checks */
#define ELEMENT_TIMEOUT_TICKS (30000)  /* minimum ticks before timing out unused elements */

typedef struct tagElement
{
    struct tagElement  *pNext;
    DWORD               iHashValue;
    DWORD               dwTickCountLastUsed;
    USHORT              fValueFlags;
    USHORT              cbKey;
    IUnknown           *pUnknown;
    BYTE                abKey[ /* cbKey */ 0 ];
} ELEMENT;

/* class CCache */

CCache::CCache(BOOL bTraceElementLastTimeUsed)
{
    m_paBuckets = NULL;
    m_cBuckets = 0;
    m_cElements = 0;
    m_fNeedFlush = FALSE;
    m_notifyCookie = REGNOTIFY_INVALID_COOKIE;
    m_bTraceElementLastTimeUsed = bTraceElementLastTimeUsed;
    m_Lock.Initialize();
}


CCache::~CCache(void)
{
    Flush(CCACHE_F_ALL);

    m_Lock.Cleanup();
}


HRESULT STDMETHODCALLTYPE CCache::SetupNotify
(
ULONG ulNotifyMask
)
{
    return s_regNotifyMgr.CreateNotification (this, ulNotifyMask, &m_notifyCookie);
}

void CCache::Notify(ULONG ulNotifyMask)
{
    m_fNeedFlush = TRUE;
}

HRESULT STDMETHODCALLTYPE CCache::CheckNotify
(
BOOL fForceCheck,
BOOL *pfChanged
)
{
    // Pick up a delayed flush if we have one
    if (InterlockedCompareExchange (&m_fNeedFlush, FALSE, TRUE) == TRUE)
    {
        *pfChanged = TRUE;
        return S_OK;
    }        

    *pfChanged = FALSE;

    ULONG ulMask;
    HRESULT hr = s_regNotifyMgr.QueryNotification (m_notifyCookie, fForceCheck, &ulMask);
    if (SUCCEEDED (hr))
    {
        *pfChanged = (ulMask != 0);
    }

    return hr;
}


// This is the real work-horse version of this method... all the work is
// really done based on a single key blob.  (This gets called directly when
// you've got a single key.)
HRESULT STDMETHODCALLTYPE CCache::AddElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
USHORT *pfValueFlags,
IUnknown *pUnknown,
IUnknown **ppExistingUnknown
)

{
    DWORD iHashBucket = 0;
    ELEMENT *pElement;
    BOOL fForceCheck, fChanged = FALSE;
#if DBG
    ICacheControl *pControl;
#endif

    if ( ppExistingUnknown )
    {
        *ppExistingUnknown = NULL;
    }

    if ( (pbKey == NULL) || (cbKey == 0) )
    {
        return(E_CACHE_BAD_KEY);
    }

    m_Lock.AcquireWriterLock();

    /* see if this key is already present */

    if ( m_cBuckets != 0 )
    {
        iHashBucket = iHashValue % m_cBuckets;

        for ( pElement = m_paBuckets[iHashBucket];
            pElement != NULL;
            pElement = pElement->pNext )
        {
            if ( (pElement->iHashValue == iHashValue) &&
                 (pElement->cbKey == cbKey) &&
                 (memcmp(pElement->abKey, pbKey, cbKey) == 0) )
            {
                if ( pElement->fValueFlags & CCACHE_F_NOTREGISTERED )
                {
                    fForceCheck = TRUE;
                }
                else
                {
                    fForceCheck = FALSE;
                }

                CheckNotify(fForceCheck, &fChanged);

                if ( fChanged )
                {
                    Flush(CCACHE_F_ALL);
                    break;
                }

                if ( ppExistingUnknown != NULL )
                {
                    *ppExistingUnknown = pElement->pUnknown;

                    if ( pElement->pUnknown != NULL )
                    {
                        pElement->pUnknown->AddRef();
                    }

                    *pfValueFlags = pElement->fValueFlags;
                }

                m_Lock.ReleaseWriterLock();
                return E_CACHE_DUPLICATE;
            }
        }
    }


    /* time to grow the cache? */

    if ( (m_cElements + 1) > m_cBuckets )
    {
        DWORD cBucketsNew;
        ELEMENT **paBucketsNew;

        cBucketsNew = m_cBuckets * 2 + 16;     // 0, 16, 48, 112, ...

        paBucketsNew = (ELEMENT **) new ELEMENT *[cBucketsNew];
        if ( paBucketsNew == NULL )
        {
            if ( m_cBuckets == 0 )
            {
                m_Lock.ReleaseWriterLock();
                return E_CACHE_NO_MEMORY;
            }
        }
        else
        {
            memset(paBucketsNew, 0, sizeof(ELEMENT *) * cBucketsNew);

            for ( iHashBucket = 0; iHashBucket < m_cBuckets; iHashBucket++ )
            {
                pElement = m_paBuckets[iHashBucket];

                while ( pElement != NULL )
                {
                    ELEMENT *pElementNext;
                    DWORD iHashBucketNew;

                    pElementNext = pElement->pNext;

                    iHashBucketNew = pElement->iHashValue % cBucketsNew;

                    pElement->pNext = paBucketsNew[iHashBucketNew];
                    paBucketsNew[iHashBucketNew] = pElement;

                    pElement = pElementNext;
                }
            }

            if ( m_paBuckets != NULL )
            {
                delete m_paBuckets;
            }

            m_paBuckets = paBucketsNew;
            m_cBuckets = cBucketsNew;

            iHashBucket = iHashValue % m_cBuckets;
        }
    }

    pElement = (ELEMENT *) new BYTE[sizeof(ELEMENT) + cbKey];
    if ( pElement == NULL )
    {
        m_Lock.ReleaseWriterLock();
        return E_CACHE_NO_MEMORY;
    }

    pElement->fValueFlags = *pfValueFlags;
    pElement->cbKey = cbKey;
    pElement->iHashValue = iHashValue;

    if (m_bTraceElementLastTimeUsed)
    {
      pElement->dwTickCountLastUsed = GetTickCount();
    }
    else
      pElement->dwTickCountLastUsed = -1;

    pElement->pUnknown = pUnknown;
    memcpy(pElement->abKey, pbKey, cbKey);

    pElement->pNext = m_paBuckets[iHashBucket];
    m_paBuckets[iHashBucket] = pElement;

    if ( pUnknown != NULL )
    {
        pUnknown->AddRef();
#if DBG
        if ( pUnknown->QueryInterface(IID_ICacheControl, (void **) &pControl) == S_OK )
        {
            pControl->CacheAddRef();
            pControl->Release();
        }
#endif
    }

    m_cElements++;

    m_Lock.ReleaseWriterLock();
    return S_OK;
}


// This version of AddElement takes two keys and fuses them into a single
// key.
HRESULT STDMETHODCALLTYPE CCache::AddElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
BYTE *pbKey2,
USHORT cbKey2,
USHORT *pfValueFlags,
IUnknown *pUnknown,
IUnknown **ppExistingUnknown
)
{
    BYTE *pbSingleKey = (BYTE *)_alloca(cbKey + cbKey2);

    if ((pbKey == NULL) || (cbKey == 0))
    {
        return E_CACHE_BAD_KEY;
    }

    memcpy(pbSingleKey, pbKey, cbKey);

    if (cbKey2 && pbKey2)
        memcpy (pbSingleKey + cbKey, pbKey2, cbKey2);

    return AddElement (iHashValue,
                       pbSingleKey,
                       cbKey + cbKey2,
                       pfValueFlags,
                       pUnknown,
                       ppExistingUnknown);
}

// This version of AddElement takes an arbitrary number of keys
// and fuses them into a single key.
HRESULT STDMETHODCALLTYPE CCache::AddElement
(
DWORD iHashValue,
USHORT cKeys,
BYTE **pbKey,
USHORT *cbKey,
USHORT *pfValueFlags,
IUnknown *pUnknown,
IUnknown **ppExistingUnknown
)
{
    BYTE *pbSingleKey = NULL;
    USHORT cbSingleKey = 0;
    USHORT i;
    HRESULT hr;

    for (i=0; i < cKeys; i++)
    {
		if (pbKey[i] != NULL) 
			cbSingleKey = cbSingleKey + cbKey[i];
    }

    if (cbSingleKey)
    {
        pbSingleKey = (BYTE *)_alloca(cbSingleKey);

        cbSingleKey = 0;
        for (i=0; i < cKeys; i++)
        {
			if (!((pbKey[i] == NULL) || (cbKey[i] == 0)))
			{
				memcpy (pbSingleKey + cbSingleKey, pbKey[i], cbKey[i]);
				cbSingleKey = cbSingleKey + cbKey[i];
			}
        }

        hr = AddElement(iHashValue,
                        pbSingleKey,
                        cbSingleKey,
                        pfValueFlags,
                        pUnknown,
                        ppExistingUnknown);
    }
    else
        hr = E_CACHE_BAD_KEY;

    return hr;
}

// Like AddElement, the single-key version is the one that does all the work.
HRESULT STDMETHODCALLTYPE CCache::GetElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
USHORT *pfValueFlags,
IUnknown **ppUnknown
)
{
    DWORD iHashBucket;
    ELEMENT *pElement;
    BOOL fForceCheck, fChanged = FALSE;

    *ppUnknown = NULL;

    if ( (pbKey == NULL) || (cbKey == 0) )
    {
        return(E_CACHE_BAD_KEY);
    }

    m_Lock.AssertNotHeld();
    m_Lock.AcquireReaderLock();

    if ( m_cBuckets != 0 )
    {
        iHashBucket = iHashValue % m_cBuckets;

        for ( pElement = m_paBuckets[iHashBucket];
            pElement != NULL;
            pElement = pElement->pNext )
        {
            if ( (pElement->iHashValue == iHashValue) &&
                 (pElement->cbKey == cbKey) &&
                 (memcmp(pElement->abKey, pbKey, cbKey) == 0) )
            {
                if ( pElement->fValueFlags & ( CCACHE_F_NOTREGISTERED | CCACHE_F_ALWAYSCHECK ) )
                {
                    fForceCheck = TRUE;
                }
                else
                {
                    fForceCheck = FALSE;
                }

                CheckNotify(fForceCheck, &fChanged);

                if ( fChanged )
                {
                    break;
                }

                if ( pElement->pUnknown != NULL )
                {
                    pElement->pUnknown->AddRef();
                }

                *ppUnknown = pElement->pUnknown;
                *pfValueFlags = pElement->fValueFlags;

                // Store the time of the access
                if (m_bTraceElementLastTimeUsed)
                  pElement->dwTickCountLastUsed = GetTickCount();
                
                m_Lock.ReleaseReaderLock();

				CatalogDebugOut((DEB_CACHE, "CComCatalog-- CACHE HIT! %d\n", m_cElements));
                return S_OK;
            }
        }
    }

    m_Lock.ReleaseReaderLock();

    if (fChanged)
    {
        Flush(CCACHE_F_ALL);
    }

	CatalogDebugOut((DEB_CACHE, "CComCatalog-- CACHE MISS! %d\n", m_cElements));
    return E_CACHE_NOT_FOUND;
}


// This version of GetElement takes two keys and fuses them into a single
// key.
HRESULT STDMETHODCALLTYPE CCache::GetElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
BYTE *pbKey2,
USHORT cbKey2,
USHORT *pfValueFlags,
IUnknown **ppUnknown
)
{
    BYTE *pbSingleKey = (BYTE *)_alloca(cbKey + cbKey2);

    if ((pbKey == NULL) || (cbKey == 0))
    {
        return E_CACHE_BAD_KEY;
    }

    memcpy(pbSingleKey, pbKey, cbKey);

    if (cbKey2 && pbKey2)
        memcpy (pbSingleKey + cbKey, pbKey2, cbKey2);

    return GetElement (iHashValue,
                       pbSingleKey,
                       cbKey + cbKey2,
                       pfValueFlags,
                       ppUnknown);
}

// This version of GetElement takes an arbitrary number of keys
// and fuses them into a single key.
HRESULT STDMETHODCALLTYPE CCache::GetElement
(
DWORD iHashValue,
USHORT cKeys,
BYTE **pbKey,
USHORT *cbKey,
USHORT *pfValueFlags,
IUnknown **ppUnknown
)
{
    BYTE  *pbSingleKey = NULL;
    USHORT cbSingleKey = 0;
    USHORT i;
    HRESULT hr;

    for (i=0; i < cKeys; i++)
    {
		if (pbKey[i] != NULL)
			cbSingleKey = cbSingleKey + cbKey[i];
    }

    if (cbSingleKey)
    {
        pbSingleKey = (BYTE *)_alloca(cbSingleKey);

        cbSingleKey = 0;
        for (i=0; i < cKeys; i++)
        {
			if (!((pbKey[i] == NULL) || (cbKey[i] == 0)))
			{
				memcpy (pbSingleKey + cbSingleKey, pbKey[i], cbKey[i]);
				cbSingleKey = cbSingleKey + cbKey[i];
			}
        }

        hr = GetElement(iHashValue,
                        pbSingleKey,
                        cbSingleKey,
                        pfValueFlags,
                        ppUnknown);
    }
    else
        hr = E_CACHE_BAD_KEY;

    return hr;
}


HRESULT STDMETHODCALLTYPE CCache::Flush
(
USHORT fValueFlags
)
{
    DWORD iHashBucket;
#if DBG
    ICacheControl *pControl;
#endif

	CatalogDebugOut((DEB_CACHE, "CComCatalog-- CACHE FLUSH! %d\n", m_cElements));

    m_Lock.AcquireWriterLock();

    for ( iHashBucket = 0; iHashBucket < m_cBuckets; iHashBucket++ )
    {
        ELEMENT *pElement = m_paBuckets[iHashBucket];

        while ( pElement != NULL )
        {
            ELEMENT *pElementNext = pElement->pNext;

            if ( pElement->pUnknown != NULL )
            {
#if DBG
                if ( pElement->pUnknown->QueryInterface(IID_ICacheControl, (void **) &pControl) == S_OK )
                {
                    pControl->CacheRelease();
                    pControl->Release();
                }
#endif
                pElement->pUnknown->Release();
            }

            delete pElement;

            pElement = pElementNext;
        }
    }

    if ( m_paBuckets != NULL )
    {
        delete m_paBuckets;
    }

    m_paBuckets = NULL;
    m_cBuckets = 0;
    m_cElements = 0;

    m_Lock.ReleaseWriterLock();
    return(S_OK);
}


//
//  Function:  CCache::FlushStaleElements
//
//  Synopsis:  Removes old elements from the cache.
//             First checks for said stale elements
//             under a reader lock to avoid contention
//             in the common case.   Only if old items
//             are found will it take the write lock.
//
//  Returns:   S_OK
//
HRESULT CCache::FlushStaleElements()
{
  BOOL bWeHaveStaleElements;
  
  // Can't flush if we're not tracking access times
  if (!m_bTraceElementLastTimeUsed)
    return S_OK;

  CheckForAndMaybeRemoveStaleElements(FALSE, &bWeHaveStaleElements);

  if (bWeHaveStaleElements)
  {
    //  call it again, this time removing the dead ones
    CheckForAndMaybeRemoveStaleElements(TRUE, &bWeHaveStaleElements);
  }

  return S_OK;
};

//
//  Function:  CCache::CheckForAndMaybeRemoveStaleElements
//
//  Synopsis:  Enumerates thru the items in the cache.  If any
//             any old items are found, and bRemove is TRUE, then
//             those items will be removed; if bRemove is FALSE 
//             they will be left alone.  *pbHadStaleItems will be
//             set to TRUE if old elements were found, FALSE otherwise.
// 
//  Returns:   S_OK
//
HRESULT STDMETHODCALLTYPE CCache::CheckForAndMaybeRemoveStaleElements(BOOL bRemove, BOOL* pbHadStaleItems)
{
  DWORD iHashBucket;
  DWORD dwTickCountNow = GetTickCount();

  *pbHadStaleItems = FALSE;

  if (bRemove)
    m_Lock.AcquireWriterLock();
  else
    m_Lock.AcquireReaderLock();
  
  for ( iHashBucket = 0; iHashBucket < m_cBuckets; iHashBucket++ )
  {
    ELEMENT* pPrevious =                           // points to the previous element; note that when 1st initialized,
         (ELEMENT*)&(m_paBuckets[iHashBucket]);    // this really only points to the an array element; we can do
                                                   // this since pNext is the first member of the struct

    ELEMENT* pElement = m_paBuckets[iHashBucket];  // points to the current element 
    
    while ( pElement != NULL )
    { 
      if ( (dwTickCountNow - pElement->dwTickCountLastUsed) >= ELEMENT_TIMEOUT_TICKS)
      {        
        *pbHadStaleItems = TRUE;

        if (bRemove)
        {
          // Found an old cache element, nuke it
          if ( pElement->pUnknown != NULL )
          {
            pElement->pUnknown->Release();
          }
        
          // Unlink it from the chain
          ELEMENT* pDeletedElem;
          pPrevious->pNext = pElement->pNext;
          pDeletedElem = pElement;
          pElement = pElement->pNext;

          // Delete the memory
          pDeletedElem->dwTickCountLastUsed = -2;
          delete pDeletedElem;
        }
        else
        {
          pPrevious = pElement;
          pElement = pElement->pNext;
        }
      }
      else
      {
        pPrevious = pElement;
        pElement = pElement->pNext;
      }
    }
  }

  if (bRemove)
    m_Lock.ReleaseWriterLock();
  else
    m_Lock.ReleaseReaderLock();
  
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\notify.cxx ===
/* notify.cxx */
#include <nt.h> 
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

#include <windows.h>

#include "notify.hxx"
#include "catdbg.hxx"

//
// Key metadata
//

#define g_wszCLSID      L"Software\\Classes\\CLSID"
#define g_wszClasses    L"Software\\Classes"

struct RegNotifyKeyData
{
    HKEY hKey;
    LPCWSTR pwszSubKey;
    ULONG ulMask;
};

static const RegNotifyKeyData s_NotifyKeys [REGNOTIFY_MAX_KEYS] =
{
    { HKEY_LOCAL_MACHINE, g_wszClasses, REGNOTIFY_HKLM_CLASSES },
    { HKEY_LOCAL_MACHINE, g_wszCLSID, REGNOTIFY_HKLM_CLASSES_CLSID },
    { HKEY_LOCAL_MACHINE, g_wszCom3, REGNOTIFY_HKLM_COM3 },
    { HKEY_USERS, NULL, REGNOTIFY_HKU }
};

#define IS_PREDEFINED_HKEY(h)	(((ULONG_PTR) (h)) & 0x80000000)

//
// Code
//

CRegNotifyManager s_regNotifyMgr;

CRegNotifyManager::CRegNotifyManager()
{
    Init();
}

CRegNotifyManager::~CRegNotifyManager()
{
    Clear();
}

void CRegNotifyManager::Clear()
{
    for (ULONG i = 0; i < REGNOTIFY_MAX_KEYS; i ++)
    {
        //
        // This code can race with process shutdown because
        // it's called from both last CoUninit and the destructor
        // If the former thread is terminated by a process shutdown,
        // then we might stop executing in the middle of this function,
        // which in the past caused "invalid handle close" verifier stops.
        // What we do now is null out the global state before closing the handles,
        // so the worst that can happen on a process shutdown race is that we leak.
        //
        
        HKEY hKey = m_aKeys[i].hKey;
        HANDLE hEvent = m_aKeys[i].hEvent;

        m_aKeys[i].fActive = FALSE;
        
        if (hKey)
        {
            m_aKeys[i].hKey = NULL;
            RegCloseKey (hKey);
        }

        if (hEvent)
        {
            m_aKeys[i].hEvent = NULL;
            CloseHandle (hEvent);
        }
    }

    Init();
}

void CRegNotifyManager::Init()
{
    ZeroMemory (m_aKeys, sizeof (m_aKeys));
    ZeroMemory (m_aNotifications, sizeof (m_aNotifications));

    m_cNotifications = 0;
    m_dwLastNotifyTickCount = GetTickCount();
}

HRESULT CRegNotifyManager::Initialize()
{
    // Set up the pre-defined keys of interest
    HRESULT hr = S_OK;

    for (ULONG i = 0; i < REGNOTIFY_MAX_KEYS; i ++)
    {
        HKEY hKey = NULL;
        HANDLE hEvent = NULL;
        HRESULT hrCurrent = S_OK;
        
        // Open the key the right way
        LONG lRet = OpenRegKey (s_NotifyKeys[i].hKey, s_NotifyKeys[i].pwszSubKey, KEY_NOTIFY, &hKey);
        if (ERROR_SUCCESS != lRet)
        {
            hrCurrent = HRESULT_FROM_WIN32 (lRet);
        }
        else
        {
            hEvent = CreateEventW (NULL, FALSE, FALSE, NULL);
            if (!hEvent)
            {
                hrCurrent = HRESULT_FROM_WIN32 (GetLastError());
            }
            else
            {
                lRet = RegNotifyChangeKeyValue (
                    hKey, TRUE, REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET, hEvent, TRUE);

                if (ERROR_SUCCESS != lRet)
                {
                    hrCurrent = HRESULT_FROM_WIN32 (lRet);
                }
            }
        }

        if (SUCCEEDED (hrCurrent))
        {
            m_aKeys[i].hKey = hKey;
            m_aKeys[i].hEvent = hEvent;
            m_aKeys[i].fActive = TRUE;
        }
        else
        {
            if (hKey)
                RegCloseKey (hKey);

            if (hEvent)
                CloseHandle (hEvent);

            if (SUCCEEDED (hr))
            {
                hr = hrCurrent;
            }
        }
    }

    return hr;
}

void CRegNotifyManager::Uninitialize()
{
    Clear();
}

HRESULT CRegNotifyManager::CreateNotification (IRegNotify* pINotify, ULONG ulNotifyMask, RegNotifyCookie* pCookie)
{
    ULONG cNotifications = InterlockedIncrement ((LONG*) &m_cNotifications);
    if (cNotifications > REGNOTIFY_MAX_NOTIFICATIONS)
    {
        InterlockedDecrement ((LONG*) &m_cNotifications);
        Win4Assert (!"Static number of registry notifications is insufficient");
        return E_UNEXPECTED;
    }

    if (ulNotifyMask & (~REGNOTIFY_ALL))
    {
        Win4Assert (!"Invalid notification mask");
        return E_UNEXPECTED;
    }

    cNotifications --;

    // Set the pointer first, so the mask is zero until the pointer is valid
    m_aNotifications[cNotifications].pINotify = pINotify;
    m_aNotifications[cNotifications].ulMask = ulNotifyMask;

    if (pCookie)
    {
        *pCookie = cNotifications;
    }

    return S_OK;
}

HRESULT CRegNotifyManager::QueryNotification (RegNotifyCookie cookie,  BOOL fForceCheck, ULONG* plChangedMask)
{
    if (cookie >= m_cNotifications)
    {
        Win4Assert (!"Invalid notification cookie");
        return E_UNEXPECTED;
    }

    *plChangedMask = 0;

    // Maybe we checked a minute ago?
    if (!fForceCheck && (GetTickCount() - m_dwLastNotifyTickCount) < REGNOTIFY_MIN_TICKS)
    {
        return S_OK;
    }

    // Get caller's key mask
    ULONG i, ulChangedMask = 0;

    for (i = 0; i < REGNOTIFY_MAX_KEYS; i ++)
    {
        if (!m_aKeys[i].fActive)
        {
            // This means that we either couldn't initialize the key,
            // or we failed to renew the notification sometime later
            // In this case, in order to respect old behavior, we
            // assume that an inactive key has always changed.
            ulChangedMask |= s_NotifyKeys[i].ulMask;
            continue;
        }

        Win4Assert (m_aKeys[i].hEvent);
        DWORD dwWait = WaitForSingleObject (m_aKeys[i].hEvent, 0);
        if (WAIT_OBJECT_0 == dwWait)
        {            
            // Try to recreate the notification
            LONG lRet = RegNotifyChangeKeyValue (
                m_aKeys[i].hKey, TRUE, REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET, m_aKeys[i].hEvent, TRUE);

            if (ERROR_SUCCESS != lRet)
            {
                CatalogDebugOut ((DEB_NOTIFY, "Couldn't recreate key notification; lRet = %d\n", lRet));

                // We'll just turn off the key for future use
                // It would be nice to close the key and the event handle,
                // but we can't really do that for fear of races and verifier stops
                m_aKeys[i].fActive = FALSE;
            }

            ulChangedMask |= s_NotifyKeys[i].ulMask;
        }

        else Win4Assert (WAIT_TIMEOUT == dwWait);
    }

    if (ulChangedMask)
    {
        // At least one of the notifications was triggered...
        for (i = 0; i < m_cNotifications; i ++)
        {
            ULONG ulAnd = m_aNotifications[i].ulMask & ulChangedMask;
            if (ulAnd)
            {
                // ... and this notification object is interested
                if (cookie == i)
                {
                    *plChangedMask = ulAnd;
                }
                else
                {
                    m_aNotifications[i].pINotify->Notify (ulAnd);
                }
            }
        }
    }

    m_dwLastNotifyTickCount = GetTickCount();

    return S_OK;
}

LONG CRegNotifyManager::RegKeyOpenNt (HKEY hKeyParent, LPCWSTR szKeyName, REGSAM samDesired, HKEY *phKey )
{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   OA;

    RtlInitUnicodeString(&UnicodeString, szKeyName);
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, hKeyParent, NULL);

    Status = NtOpenKey((PHANDLE)phKey, samDesired, &OA);
    
    return RtlNtStatusToDosError( Status );
}


LONG CRegNotifyManager::CreateHandleFromPredefinedKey(HKEY hkeyPredefined, REGSAM samDesired, HKEY *hkeyNew)
{
    struct{
        HKEY hKey;
        LPWSTR wszKeyString;
    }KeyMapping[] = {

        {HKEY_CLASSES_ROOT,  L"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"},
        {HKEY_CURRENT_USER,  L"\\REGISTRY\\CURRENT_USER"},
        {HKEY_USERS,         L"\\REGISTRY\\USER"},
        {HKEY_LOCAL_MACHINE, L"\\REGISTRY\\MACHINE"},
    };

    for(int i = 0; i < sizeof(KeyMapping)/sizeof(*KeyMapping); i++)
    {
        if(KeyMapping[i].hKey == hkeyPredefined)
        {
            return RegKeyOpenNt (NULL, KeyMapping[i].wszKeyString, samDesired, hkeyNew );
        }
    }

    return ERROR_FILE_NOT_FOUND;
}

LONG CRegNotifyManager::OpenRegKey (HKEY hKeyParent, LPCWSTR pwszSubKeyName, REGSAM samDesired, HKEY* phKey)
{
    LONG res;

    if (IS_PREDEFINED_HKEY (hKeyParent) && ((pwszSubKeyName == NULL) || (*pwszSubKeyName == L'\0')))
    {
        res = CreateHandleFromPredefinedKey (hKeyParent, samDesired, phKey);
    }
    else
    {
    	res = RegOpenKeyExW (hKeyParent, pwszSubKeyName, 0, samDesired, phKey);
    }

    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\class.cxx ===
/* class.cxx */

#include <ole2int.h>
#include <appmgmt.h>
#include <msi.h>
#include <comdef.h>
#include <string.h>
#include <wow64reg.h>

#include "globals.hxx"
#include "services.hxx"

#include "catalog.h"
#include "partitions.h"
#include "class.hxx"
#include "catalog.hxx"

#define SAFEALLOCA_ASSERT Win4Assert
#include <alloca.h>

#if DBG
#include <debnot.h>
#endif

const WCHAR g_wszInprocServer32[] = L"InprocServer32";
const WCHAR g_wszInprocHandler32[] = L"InprocHandler32";
const WCHAR g_wszLocalServer32[] = L"LocalServer32";
const WCHAR g_wszServerExecutable[] = L"ServerExecutable";
const WCHAR g_wszLocalServer16[] = L"LocalServer";
const WCHAR g_wszInprocServer16[] = L"InprocServer";
const WCHAR g_wszRemoteServerName[] = L"RemoteServerName";
const WCHAR g_wszInprocHandler16[] = L"InprocHandler";
const WCHAR g_wszThreadingModel[] = L"ThreadingModel";
const WCHAR g_wszOle32Dll[] = L"OLE32.DLL";
const WCHAR g_wszApartment[] = L"Apartment";
const WCHAR g_wszBoth[] = L"Both";
const WCHAR g_wszFree[] = L"Free";
const WCHAR g_wszNeutral[] = L"Neutral";
const WCHAR g_wszProgId[] = L"Progid";
const WCHAR g_wszProcessId[] = L"AppID";
const WCHAR g_wszAppidTemplate[] = L"AppID\\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";
const WCHAR g_wszLocalService[] = L"LocalService";
const WCHAR g_wszDllSurrogate[] = L"DllSurrogate";
const WCHAR g_wszDllSurrogateExecutable[] = L"DllSurrogateExecutable";
const WCHAR g_wszDebugSurrogate[] = L"DebugSurrogate";
const WCHAR g_wszDllHostSlashProcessId[] = L"DllHost.exe /Processid:";
const WCHAR g_wszDllHost[] = L"DllHost.exe";
const WCHAR g_wszEmbedding[] = L" -Embedding";

#define STRLEN_WCHAR(s) ((sizeof((s)) / sizeof((s)[0])) -1)

#define STRLEN_OLE32DLL (STRLEN_WCHAR(g_wszOle32Dll))

#ifdef _WIN64

HRESULT GetFileTypeFromRegString (LPCWSTR pwszRegString, CoModuleType* pFileType)
{
    // We need to get the file type of the binary in the inputstring.
    // However, there may be cmd line arguments at the end complicating matters.
    //
    // As a heuristic, we'll look for an initial quote.
    // If there's a quote, then we'll scan to the end of the quote 
    // and cut off everything else off.
    // If there isn't a quote, we'll scan until we hit a space

    HRESULT hr;

    size_t stDiff, stStrLen = wcslen (pwszRegString) + 1;
    WCHAR* pwsEnd, * pwszFileName = (WCHAR*) _alloca (stStrLen * sizeof (WCHAR));

    if (pwszRegString[0] == L'\"')
    {
        // Search for the end quote
        pwsEnd = wcsstr (pwszRegString + 1, L"\"");
        if (pwsEnd == NULL)
        {
            // Ill formed string;  copy without the quote and hope it works
            wcscpy (pwszFileName, pwszRegString + 1);
        }
        else
        {
            // Copy everything inside the quotes, stripping the quotes
            // because Create Process doesn't like quotes
            // This covers cases like: "C:\Program Files\Directory\Exe.exe" or 
            // "C:\Program Files\Directory\Exe.exe" /Surrogate
            stDiff = pwsEnd - pwszRegString - 1;
            wcsncpy (pwszFileName, pwszRegString + 1, stDiff);
            pwszFileName[stDiff] = L'\0';
        }
    }
    else
    {
        // Search for a space
        pwsEnd = wcsstr (pwszRegString + 1, L" ");
        if (pwsEnd == NULL)
        {
            // Just copy the line
            // This covers cases like: C:\Progra~1\Directory\Exe.exe
            wcscpy (pwszFileName, pwszRegString);
        }
        else
        {
            // Copy to the space
            // This covers cases like: C:\Progra~1\Directory\Exe.exe /Surrogate
            stDiff = pwsEnd - pwszRegString;
            wcsncpy (pwszFileName, pwszRegString, stDiff);
            pwszFileName[stDiff] = L'\0';
        }
    }

    // Now that we have the right kind of string, get the file type
    hr = CoGetModuleType (pwszFileName, pFileType);

    return hr;
}

#endif

/*
 *  class CComClassInfo
 */

CComClassInfo::CComClassInfo()
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_cLocks = 0;
    m_hKeyClassesRoot = NULL;
    m_fValues = VALUE_NONE;
    m_clsctx = 0;
    m_pwszProgid = NULL;
    m_pwszClassName = NULL;

    m_pwszInprocServer32 = NULL;
    m_pwszInprocHandler32 = NULL;
    m_pwszLocalServer = NULL;
    m_pwszInprocServer16 = NULL;
    m_pwszRemoteServerName = NULL;
    m_pwszInprocHandler16 = NULL;
    m_pwszSurrogateCommand = NULL;
    m_pwszServerExecutable = NULL;
    m_pUserToken = NULL;
}


HRESULT CComClassInfo::FinalConstruct(
    IUserToken *pUserToken,
    HKEY hKeyClassesRoot,
    const GUID *pClsid,
    WCHAR *pwszClsidString,
    HKEY hKey,
    REGSAM regType
)
{
    HRESULT hr = S_OK;

    CatalogDebugOut((DEB_CLASSINFO, 
                     "CComClassInfo::FinalConstruct: this %p hkcr %p clsid %ws\n", 
                     this, hKeyClassesRoot, pwszClsidString));

    wcsncpy(m_wszClsidString, pwszClsidString, sizeof(m_wszClsidString)/sizeof(*m_wszClsidString));
    m_wszClsidString[sizeof(m_wszClsidString)/sizeof(*m_wszClsidString) - 1] = L'\0';
    m_regType = regType;
    m_clsid   = *pClsid;

    m_pUserToken = pUserToken;
    if (m_pUserToken != NULL)
        m_pUserToken->AddRef();
    LONG lRet = RegOpenKeyEx(hKeyClassesRoot,
                             NULL,
                             0,
                             KEY_READ,
                             &m_hKeyClassesRoot);
    if (lRet != ERROR_SUCCESS)
       hr = HRESULT_FROM_WIN32(lRet);

    CatalogDebugOut((DEB_CLASSINFO, "CComClassInfo::FinalConstruct: returning 0x%08x\n", hr));

    return hr;
}


#define DELETE_CLASS_STRING(p)                      \
    if (((p) != NULL) && ((p) != g_wszEmptyString)) \
    {                                               \
        delete [] (p);                                 \
    }


CComClassInfo::~CComClassInfo()
{
    DELETE_CLASS_STRING(m_pwszProgid);
    DELETE_CLASS_STRING(m_pwszClassName);
    DELETE_CLASS_STRING(m_pwszInprocServer32);
    DELETE_CLASS_STRING(m_pwszInprocHandler32);
    DELETE_CLASS_STRING(m_pwszLocalServer);
    DELETE_CLASS_STRING(m_pwszInprocServer16);
    DELETE_CLASS_STRING(m_pwszRemoteServerName);
    DELETE_CLASS_STRING(m_pwszInprocHandler16);
    DELETE_CLASS_STRING(m_pwszSurrogateCommand);
    DELETE_CLASS_STRING(m_pwszServerExecutable);

    if ( m_pUserToken != NULL )
    {
        m_pUserToken->Release();
    }
    if (m_hKeyClassesRoot)
    {
       RegCloseKey(m_hKeyClassesRoot);
       m_hKeyClassesRoot = NULL;
    }
}


/* IUnknown methods */

STDMETHODIMP CComClassInfo::QueryInterface(
                                          REFIID riid,
                                          LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ( riid == IID_IComClassInfo )
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }
    else if ( riid == IID_IClassClassicInfo )
    {
        *ppvObj = (LPVOID) (IClassClassicInfo *) this;
    }
    else if ( riid == IID_IClassClassicInfo2 )
    {
        *ppvObj = (LPVOID) (IClassClassicInfo2 *) this;
    }
#if DBG
    else if ( riid == IID_ICacheControl )
    {
        *ppvObj = (LPVOID) (ICacheControl *) this;
    }
#endif
    else if ( riid == IID_IUnknown )
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }

    if ( *ppvObj != NULL )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComClassInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComClassInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned ClassInfo object");
#endif
        delete this;
    }

    return(cRef);
}


/* IComClassInfo methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetConfiguredClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    *ppguidClsid = &m_clsid;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetProgId
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProgid
    )
{
    HKEY hKey;

    if ( (m_fValues & VALUE_PROGID) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_PROGID) == 0 )
        {
            if ( ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey) )
            {
                GetRegistryStringValue(hKey, g_wszProgId, NULL, RQ_ALLOWQUOTEQUOTE, &m_pwszProgid);
                RegCloseKey(hKey);
            }

            m_fValues |= VALUE_PROGID;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    *pwszProgid = m_pwszProgid;

    if ( m_pwszProgid != NULL && m_pwszProgid[0] != L'\0' )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetClassName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszClassName
    )
{
    HKEY hKey;

    if ( (m_fValues & VALUE_CLASSNAME) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_CLASSNAME) == 0 )
        {
            if (ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey))
            {
                GetRegistryStringValue(hKey, NULL, NULL, RQ_ALLOWQUOTEQUOTE, &m_pwszClassName);
                RegCloseKey(hKey);
            }

            m_fValues |= VALUE_CLASSNAME;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    *pwszClassName = m_pwszClassName;

    if ( (m_pwszClassName != NULL) && (*m_pwszClassName != L'\0') )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetApplication
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    return(E_FAIL);
}

#ifdef DARWIN_ENABLED
HRESULT CComClassInfo::GetDarwinIdentifier(HKEY hKey, LPCWSTR wszInprocServerRegValue, LPWSTR *lpwszInprocServerKey)
{
    // The Darwin identifiers are stored in a named value of the same name as the
    // server subkey.  Thus a LocalServer32 named value could exist under the
    // LocalSever32 CLSID subkey, or an InprocServer32 named value could exist
    // under the InprocServer32 subkey.  16 bit servers are not supported.
    //
    // Additional details can be found in the ZAW spec on
    // \\popcorn\razzle1\src\spec\zawdes.doc.
    LPWSTR pwszDarwinId=NULL;

    // Read Darwin identifier if present
    HRESULT hr = GetRegistryStringValue(hKey, wszInprocServerRegValue, wszInprocServerRegValue, RQ_MULTISZ, &pwszDarwinId);
    if (SUCCEEDED(hr))
    {
        // Found a Darwin descriptor
        // Call Darwin and use the returned path as IPS32
        hr=GetPathFromDarwinDescriptor(pwszDarwinId, lpwszInprocServerKey);

        DELETE_CLASS_STRING(pwszDarwinId);

        if (SUCCEEDED(hr))
        {
            // Darwin might give back a quoted string: unquote it
            if ((*lpwszInprocServerKey)[0] == L'"')
            {
                size_t cbValue = wcslen(*lpwszInprocServerKey);

                if ((cbValue >= 2) && ((*lpwszInprocServerKey)[cbValue - 1] == L'"'))
                {
                    WCHAR *t = *lpwszInprocServerKey;
                    WCHAR *s = t + 1;

                    (*lpwszInprocServerKey)[cbValue - 1] = L'\0';

                    while (*t++ = *s++)
                    {
                        /* slide the string down */
                    }
                }
            }
        }
    }

    return hr;
}
#endif


HRESULT STDMETHODCALLTYPE CComClassInfo::GetClassContext
    (
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX __RPC_FAR *pclsctx
    )
{
    HRESULT hr;
    LONG res;
    HKEY hKey = NULL;
    HKEY hKey2;
    WCHAR *pwsz;
    int clsctxNotValid;
    _GUID *pguidProcess;

    // If there's any chance we'll need hKey, get it now so we don't have to
    // open it once for the Darwin code and again down below. If another
    // thread beats us in, then we wind up not using hKey after all, but
    // that's okay - we optimize the normal case.
    if ( clsctxFilter & ~m_fValues )
    {
        res = RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey);
        if (res != ERROR_SUCCESS)
        {       
            return HRESULT_FROM_WIN32(res);
        }
    }

#ifdef DARWIN_ENABLED
    WCHAR   *pwszDarwinLocalServer = NULL;
    WCHAR   *pwszDarwinInprocServer32 = NULL;

    // See if we *might* need to get class info from Darwin. We don't want to
    // serialize threads through possibly lengthy Darwin code, so we accept the
    // fact that multiple threads could pass through here for the same class.
    // We take care to avoid updating any member variables in this unprotected
    // section.

    clsctxNotValid = clsctxFilter & ~m_fValues & (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER);

    if ( clsctxNotValid & CLSCTX_INPROC_SERVER )
    {
        hr = GetDarwinIdentifier(hKey, g_wszInprocServer32, &pwszDarwinInprocServer32);
        //Win4Assert( SUCCEEDED(hr) || pwszDarwinInprocServer32 == NULL);
    }

    if ( clsctxNotValid & CLSCTX_LOCAL_SERVER )
    {
        // The Darwin identifiers are stored in a named value of the same name as the
        // server subkey.  Thus a LocalServer32 named value could exist under the
        // LocalSever32 CLSID subkey, or an InprocServer32 named value could exist
        // under the InprocServer32 subkey.  16 bit servers are not supported.
        //
        // Additional details can be found in the ZAW spec on
        // \\popcorn\razzle1\src\spec\zawdes.doc.
        LPWSTR pwszDarwinId = NULL;

        // Read Darwin identifier if present
        hr = GetRegistryStringValue(hKey, g_wszLocalServer32, g_wszLocalServer32, RQ_MULTISZ, &pwszDarwinId);
        if ( SUCCEEDED(hr) )
        {
            // Found a Darwin descriptor
            // We purposefully resolve Darwin ids in the client as well so that
            // we can see the install UI.  This is not possible from rpcss since
            // it is not in Winsta0.

            // Get the path from Darwin: this can cause files to be copied, registry keys to
            // be written or pretty much anything else...
            hr = GetPathFromDarwinDescriptor(pwszDarwinId, &pwszDarwinLocalServer);
            //Win4Assert( SUCCEEDED(hr) || pwszDarwinLocalServer == NULL);

            DELETE_CLASS_STRING(pwszDarwinId);
        }
    }
#endif

    // Second pass through after loading all Darwin info...
    if ( clsctxFilter & ~m_fValues )
    {
        g_CatalogLock.AcquireWriterLock();

        clsctxNotValid = clsctxFilter & ~m_fValues & ~CLSCTX_REMOTE_SERVER;

        if ( clsctxNotValid & CLSCTX_INPROC_SERVER )
        {
#ifdef DARWIN_ENABLED
            if (pwszDarwinInprocServer32)
            {
                m_clsctx |= CLSCTX_INPROC_SERVER;

                m_pwszInprocServer32 = pwszDarwinInprocServer32;
                pwszDarwinInprocServer32 = NULL;

                goto foundInprocServer;
            }
#endif

            hr = GetRegistryStringValue(hKey, g_wszInprocServer32, NULL, 0, &m_pwszInprocServer32);
            if ( SUCCEEDED(hr) )
            {
                if ( m_pwszInprocServer32 && *m_pwszInprocServer32 )
                {
                    m_clsctx |= CLSCTX_INPROC_SERVER;
                }
                else
                {
                    DELETE_CLASS_STRING(m_pwszInprocServer32);
                    m_pwszInprocServer32=NULL;
                }
            }
            foundInprocServer:
           
            m_fValues |= VALUE_INPROC_SERVER;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_HANDLER )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocHandler32, NULL, 0, &m_pwszInprocHandler32);
            if ( SUCCEEDED(hr) )
            {
                if ( m_pwszInprocHandler32 && *m_pwszInprocHandler32 )
                {
                    m_clsctx |= CLSCTX_INPROC_HANDLER;
                }
                else
                {
                    DELETE_CLASS_STRING(m_pwszInprocHandler32);
                    m_pwszInprocHandler32=NULL;
                }
            }

            m_fValues |= VALUE_INPROC_HANDLER;
        }

        if ( clsctxNotValid & CLSCTX_LOCAL_SERVER )
        {                    
#ifdef DARWIN_ENABLED
            if (pwszDarwinLocalServer)
            {
                m_clsctx |= CLSCTX_LOCAL_SERVER;
                m_pwszLocalServer = pwszDarwinLocalServer;
                pwszDarwinLocalServer = NULL;
                m_fValues |= VALUE_LOCALSERVERIS32;
                goto foundLocalServer;
            }
#endif

            hr = GetRegistryStringValue(hKey, g_wszLocalServer32, NULL, 0, &m_pwszLocalServer);
            if ( SUCCEEDED(hr) )
            {
                Win4Assert(m_pwszLocalServer != NULL);

#ifdef _WIN64
                BOOL fValid = TRUE;

                // Because all the AppID settings are not reflected, we need to
                // make sure we're dealing with the correct side of the registry.
                //
                // In RPCSS, the bitness of the executable in the LocalServer32 
                // key must match our bitness.  In practice, we only check if we 
                // are not the 32bit registry.  (If there turn out to be more registries
                // later, we will need to change this.... hahaha)
                if (g_bInSCM && (m_regType != KEY_WOW64_32KEY))
                {
                    CoModuleType processType;
                    RPC_STATUS status;

                    // Best effort impersonate before hitting the disk, because rpcss
                    // credentials may not have access to the file

                    status = RpcImpersonateClient (NULL);

                    if (SUCCEEDED (GetFileTypeFromRegString (m_pwszLocalServer, &processType)))
                    {
                        // If this is the processType that gets the other
                        // side of the registry, then *I* am not qualified
                        // to answer *ANY* configuration questions about this class.
                        // Go bother someone else.
                        if (processType == CO_MODULE_32BIT)
                        {
                            CatalogDebugOut((DEB_CLASSINFO,
                                             "CComClassInfo appears valid, but is for the wrong process type.\n"));

                            delete [] m_pwszLocalServer; 
                            m_pwszLocalServer = NULL;

                            fValid = FALSE;
                        }
                    }
                    else
                    {
                        // If GetProcessType failed then I say the LocalServer32
                        // key is invalid.
                        delete [] m_pwszLocalServer; 
                        m_pwszLocalServer = NULL;

                        fValid = FALSE;
                    }

                    if (status == RPC_S_OK)
                    {
                        RpcRevertToSelf();
                    }
                }

                if (fValid)
#endif
                {
                    m_clsctx |= CLSCTX_LOCAL_SERVER;
                    m_fValues |= VALUE_LOCALSERVERIS32;
                    goto foundLocalServer;
                }
            }

            hr = GetRegistryStringValue(hKey, g_wszLocalServer16, NULL, 0, &m_pwszLocalServer);            
            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_LOCAL_SERVER;
                goto foundLocalServer;
            }

            hr = GetProcessId(&pguidProcess);
            if ( hr == S_OK )
            {
				WCHAR wszAppidString[45];

                wcscpy(wszAppidString, g_wszAppidTemplate);
                GUIDToString(pguidProcess, wszAppidString + 7);

                res = RegOpenKeyExW (m_hKeyClassesRoot, wszAppidString, 0, KEY_READ | m_regType, &hKey2);
                if ( ERROR_SUCCESS == res )
                {
                    const DWORD cchValue = 10;
                    WCHAR wszValue [cchValue + 1];
                    DWORD cbValue = 0;
                    
                    res = RegQueryValueExW(hKey2, g_wszDllSurrogate, NULL, NULL, NULL, &cbValue);
                    if (ERROR_SUCCESS == res && cbValue > 1)
                    {
                        WCHAR* pwszSurrogate = (WCHAR*) _alloca (cbValue + sizeof (WCHAR));
                        res = RegQueryValueExW(hKey2, g_wszDllSurrogate, NULL, NULL, (BYTE *) pwszSurrogate, &cbValue);
                        if (ERROR_SUCCESS == res)
                        {
                            BOOL bAcceptable = TRUE;
                            
                            // We found a surrogate
                            //
                            // We need to be careful, though - if we're in the 64 bit registry
                            // and the surrogate is a custom surrogate and it's 32 bit, 
                            // we shouldn't add local server to our acceptable contexts because 
                            // this way we'll fall through to a 32 bit classinfo that will do the right thing
#ifdef _WIN64
                            if (g_bInSCM && m_regType != KEY_WOW64_32KEY && pwszSurrogate[0] != L'\0')
                            {
                                CoModuleType processType;
                                RPC_STATUS status;
            
                                status = RpcImpersonateClient (NULL);

                                hr = GetFileTypeFromRegString (pwszSurrogate, &processType);
                                if (FAILED (hr) || processType != CO_MODULE_64BIT)
                                {
                                    bAcceptable = FALSE;
                                }

                                if (status == RPC_S_OK)
                                {
                                    RpcRevertToSelf();
                                }
                            }
#endif
                            if (bAcceptable)
                            {
                                RegCloseKey(hKey2);
                                m_clsctx |= CLSCTX_LOCAL_SERVER;
                                goto foundLocalServer;
                            }
                        }
                    }
                    
                    cbValue = (DWORD) (cchValue * sizeof(WCHAR));

                    res = RegQueryValueExW(hKey2, g_wszLocalService, NULL, NULL, (BYTE *) wszValue, &cbValue);

                    if ((cbValue > 3) &&
                        ((ERROR_SUCCESS == res) || (ERROR_MORE_DATA == res)))
                    {
                        RegCloseKey(hKey2);
                        m_clsctx |= CLSCTX_LOCAL_SERVER;
                        goto foundLocalServer;
                    }

                    RegCloseKey(hKey2);
                }
            }

            foundLocalServer:

            m_fValues |= VALUE_LOCAL_SERVER;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_SERVER16 )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocServer16, NULL, 0, &m_pwszInprocServer16);

            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_INPROC_SERVER16;
            }
            m_fValues |= VALUE_INPROC_SERVER16;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_HANDLER16 )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocHandler16, NULL, 0, &m_pwszInprocHandler16);

            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_INPROC_HANDLER16;
            }
            m_fValues |= VALUE_INPROC_HANDLER16;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    if (hKey)
    {
        RegCloseKey(hKey);
    }


    *pclsctx = (CLSCTX) (((int) clsctxFilter) & (m_clsctx | 
                                                 CLSCTX_REMOTE_SERVER |  
                                                 CLSCTX_INPROC_HANDLER | 
                                                 CLSCTX_INPROC_HANDLER16 | 
                                                 CLSCTX_NO_FAILURE_LOG));

#ifdef DARWIN_ENABLED
    // Normally, these are assigned to member variables, but if we had multiple
    // threads racing through the unprotected Darwin calls, we might need to
    // free memory that was allocated by the "losing" thread(s).
    DELETE_CLASS_STRING(pwszDarwinInprocServer32);
    DELETE_CLASS_STRING(pwszDarwinLocalServer);
#endif

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetCustomActivatorCount
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long __RPC_FAR *pulCount
    )
{
    *pulCount = 0;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetCustomActivatorClsids
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *prgguidClsid
    )
{
    *prgguidClsid = NULL;

    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetCustomActivators
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator __RPC_FAR *__RPC_FAR *__RPC_FAR *prgpActivator
    )
{
    *prgpActivator = NULL;
    return(S_FALSE);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetTypeInfo
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;

    return(E_NOTIMPL);        
}


HRESULT STDMETHODCALLTYPE CComClassInfo::IsComPlusConfiguredClass
    (
    /* [out] */ BOOL __RPC_FAR *pfComPlusConfiguredClass
    )
{
    *pfComPlusConfiguredClass = FALSE;

    return(S_OK);
}


/* IClassClassicInfo methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetThreadingModel
    (
    /* [out] */ ThreadingModel __RPC_FAR *pthreadmodel
    )
{
    HRESULT hr;
    HKEY hKey;
    CLSCTX clsctx;

    if ( (m_fValues & VALUE_THREADINGMODEL) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_THREADINGMODEL) == 0 )
        {
            m_threadingmodel = SingleThreaded;  /* default */

            if ( (m_fValues & VALUE_INPROC_SERVER) == 0 )
            {
                GetClassContext(CLSCTX_INPROC_SERVER, &clsctx);
            }

            if ( m_pwszInprocServer32 != NULL )
            {
                /* OLE32.DLL is always BOTH */

                /* check for "ole32.dll" or anypath+"\ole32.dll" */

                const size_t cch = wcslen(m_pwszInprocServer32);

                if ( ((cch == STRLEN_OLE32DLL) ||
                      ((cch > STRLEN_OLE32DLL) && (m_pwszInprocServer32[cch - STRLEN_OLE32DLL - 1] == L'\\')))
                     && ( _wcsicmp(m_pwszInprocServer32 + cch - STRLEN_OLE32DLL, g_wszOle32Dll) == 0) )
                {
                    m_threadingmodel = BothThreaded;
                }
                else
                {
                    if ( ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey) )
                    {
						WCHAR wszValue[25];

                        hr = ReadRegistryStringValue(hKey,
                                                     g_wszInprocServer32,
													 g_wszThreadingModel,
                                                     FALSE, 
													 wszValue, 
													 sizeof(wszValue)/sizeof(WCHAR));
                        if ( SUCCEEDED(hr) )
                        {
                            if ( _wcsicmp(wszValue, g_wszApartment) == 0 )
                            {
                                m_threadingmodel = ApartmentThreaded;
                            }
                            else if ( _wcsicmp(wszValue, g_wszBoth) == 0 )
                            {
                                m_threadingmodel = BothThreaded;
                            }
                            else if ( _wcsicmp(wszValue, g_wszFree) == 0 )
                            {
                                m_threadingmodel = FreeThreaded;
                            }
                            else if ( _wcsicmp(wszValue, g_wszNeutral) == 0 )
                            {
                                m_threadingmodel = NeutralThreaded;
                            }
                            else if ( *wszValue == L'\0' )
                            {
                                // Treat this as if the value wasn't specified at all
                            }
                            else if ( _wcsicmp(wszValue, L"Single") == 0 )
                            {
                              // NT #339216 - Some vendors thought ThreadingModel=Single
                              // was valid. Treat this as if the value wasn't specified at all
                            }
                            else
                            {
                                m_threadingmodel = -1;  /* unrecognized */
                            }
                        }

                        RegCloseKey(hKey);
                    }
                }
            }

            m_fValues |= VALUE_THREADINGMODEL;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    if ( m_threadingmodel != -1 )
    {
        *pthreadmodel = (ThreadingModel) m_threadingmodel;

        return(S_OK);
    }
    else
    {
        return(REGDB_E_INVALIDVALUE);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetModulePath
    (
    /* [in] */ CLSCTX clsctx,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszDllName
    )
{
    int clsctxAvailable;
    WCHAR *pwsz;

    *pwszDllName = NULL;

    /* make sure exactly one context is requested */

    if ( (clsctx & (clsctx - 1)) != 0 )
    {
        return(E_FAIL);
    }

    GetClassContext(clsctx, (CLSCTX *) &clsctxAvailable);

    if ( clsctx & clsctxAvailable )
    {
        switch ( clsctx )
        {
        case CLSCTX_INPROC_SERVER:
            pwsz = m_pwszInprocServer32;
            break;

        case CLSCTX_INPROC_HANDLER:
            pwsz = m_pwszInprocHandler32;
            break;

        case CLSCTX_LOCAL_SERVER:
            pwsz = m_pwszLocalServer;
            break;

        case CLSCTX_INPROC_SERVER16:
            pwsz = m_pwszInprocServer16;
            break;

        case CLSCTX_REMOTE_SERVER:
            GetRemoteServerName(&pwsz);
            break;

        case CLSCTX_INPROC_HANDLER16:
            pwsz = m_pwszInprocHandler16;
            break;

        default:
            Win4Assert (!"Unexpected class context");
            return E_UNEXPECTED;
        }

        if ( pwsz != NULL )
        {
            *pwszDllName = pwsz;

            return(S_OK);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetImplementedClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    *ppguidClsid = &m_clsid;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CComClassInfo::GetProcess
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;

    _GUID *pProcessId;

    HRESULT hr = GetProcessId(&pProcessId);
    if ( hr == S_OK )
    {		
        DWORD flags = 0;

		// Make sure that if we're a 32bit ClassInfo we take the 
		// 32bit ProcessInfo
		if (m_regType == KEY_WOW64_32KEY)
			flags = CAT_REG32_ONLY;

        hr = CComCatalog::GetProcessInfoInternal(flags, m_pUserToken, m_guidProcessId, riid, ppv);
    }
    else
    {
        hr = E_FAIL;
    }

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetRemoteServerName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
    )
{
    HRESULT hr;

    if ( (m_fValues & VALUE_REMOTE_SERVER) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_REMOTE_SERVER) == 0 )
        {
			_GUID *pguidProcess;

            hr = GetProcessId(&pguidProcess);
            if ( hr == S_OK )
            {
				WCHAR wszAppidString[45];

                wcscpy(wszAppidString, g_wszAppidTemplate);

                GUIDToString(pguidProcess, wszAppidString + 7);

				HKEY hKey;

                if (ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, wszAppidString, 0, KEY_READ | m_regType, &hKey))
                {
                    hr = GetRegistryStringValue(hKey, NULL, g_wszRemoteServerName, (RQ_MULTISZ | RQ_ALLOWQUOTEQUOTE), &m_pwszRemoteServerName);
                    if ( SUCCEEDED(hr) )
                    {
                        m_clsctx |= CLSCTX_REMOTE_SERVER;
                    }

                    RegCloseKey(hKey);
                }
            }

            m_fValues |= VALUE_REMOTE_SERVER;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    *pwszServerName = m_pwszRemoteServerName;

    if ( m_pwszRemoteServerName != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetLocalServerType
    (
    /* [out] */ LocalServerType __RPC_FAR *pType
    )
{
    CLSCTX clsctx;

    GetClassContext(CLSCTX_LOCAL_SERVER, &clsctx);

    if ( m_pwszLocalServer == NULL )
    {
        return(E_FAIL);
    }
    else if ( m_fValues & VALUE_LOCALSERVERIS32 )
    {
        *pType = LocalServerType32;
    }
    else
    {
        *pType = LocalServerType16;
    }

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetSurrogateCommandLine
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogateCommandLine
    )
{
    HRESULT hr;
    IComProcessInfo *pProcess;
    size_t cch;
    _GUID *pguidProcess;

    if ( (m_fValues & VALUE_SURROGATE_COMMAND) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_SURROGATE_COMMAND) == 0 )
        {
            hr = GetProcessId(&pguidProcess);
            if ( hr == S_OK )
            {
                WCHAR wszAppidString[45];

                wcscpy(wszAppidString, g_wszAppidTemplate);
                GUIDToString(pguidProcess, wszAppidString + 7);

                HKEY hKey;
                DWORD res = RegOpenKeyExW (m_hKeyClassesRoot, wszAppidString, 0, KEY_READ | m_regType, &hKey);
                if (res != ERROR_SUCCESS)
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
                else
                {
                    hr = GetRegistryStringValue(hKey, NULL, g_wszDebugSurrogate, 0, &m_pwszSurrogateCommand);
                    RegCloseKey(hKey);
                }

                if ( SUCCEEDED(hr) )
                {
                    m_fValues |= VALUE_SURROGATE_IS_DBG;
                    goto gotCommandLine;
                }
            }

            hr = GetProcess(IID_IComProcessInfo, (void **) &pProcess);
            if ( hr == S_OK )
            {
                ProcessType eProcessType;

                hr = pProcess->GetProcessType(&eProcessType);
                if ( hr == S_OK )
                {
                    if ( eProcessType == ProcessTypeComPlus )
                    {
                        WCHAR wszSystemDirectory[MAX_PATH] = L"";
                        
                        if (m_regType == KEY_WOW64_32KEY)
                        {
                            // Point over to the 32bit dllhost instead of the 64bit one.
                            cch = GetSystemWow64Directory(wszSystemDirectory, STRLEN_WCHAR(wszSystemDirectory));
                        } 
                        else 
                        {
                            cch = GetSystemDirectory(wszSystemDirectory, STRLEN_WCHAR(wszSystemDirectory));
                        }

                        if (cch > 0)
                        {
                        
                            if ( wszSystemDirectory[cch - 1] != L'\\' )
                            {
                                wszSystemDirectory[cch] = L'\\';
                                cch++;
                                wszSystemDirectory[cch] = L'\0';
                            }
                            
                            m_pwszSurrogateCommand = new WCHAR[
                                cch + STRLEN_WCHAR(g_wszDllHostSlashProcessId) + STRLEN_CURLY_GUID + 1];
                            if ( m_pwszSurrogateCommand != NULL )
                            {
                                wcscpy(m_pwszSurrogateCommand, wszSystemDirectory);
                                wcscpy(m_pwszSurrogateCommand + cch, g_wszDllHostSlashProcessId);
                                cch += STRLEN_WCHAR(g_wszDllHostSlashProcessId);
                                GUIDToCurlyString(&m_guidProcessId,
                                    m_pwszSurrogateCommand + cch);
                                cch += STRLEN_CURLY_GUID;
                                m_pwszSurrogateCommand[cch] = L'\0';
                            }
                        }
                    }
                    else if ( eProcessType == ProcessTypeLegacySurrogate )
                    {
					    WCHAR *pwszSurrogatePath;

                        hr = pProcess->GetSurrogatePath(&pwszSurrogatePath);
                        if ( hr == S_OK )
                        {
                            cch = wcslen(pwszSurrogatePath);

                            m_pwszSurrogateCommand = new WCHAR[
                                cch + 1 + STRLEN_CURLY_GUID + STRLEN_WCHAR(g_wszEmbedding) + 1];
                            if ( m_pwszSurrogateCommand != NULL )
                            {
                                wcscpy(m_pwszSurrogateCommand, pwszSurrogatePath);
                                m_pwszSurrogateCommand[cch] = L' ';
                                cch += 1;
                                GUIDToCurlyString(&m_clsid, m_pwszSurrogateCommand + cch);
                                cch += STRLEN_CURLY_GUID;
                                wcscpy(m_pwszSurrogateCommand + cch, g_wszEmbedding);
                            }
                        }
                    }
                }
                
                pProcess->Release();
            }
            
gotCommandLine:            
            m_fValues |= VALUE_SURROGATE_COMMAND;
        }
        
        g_CatalogLock.ReleaseWriterLock();
    }

    if ( m_pwszSurrogateCommand != NULL )
    {
        *pwszSurrogateCommandLine = m_pwszSurrogateCommand;

        return(S_OK);
    }
    else
    {
        return(E_OUTOFMEMORY);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::MustRunInClientContext
    (
    /* [out] */ BOOL __RPC_FAR *pbMustRunInClientContext
    )
{
    *pbMustRunInClientContext = FALSE;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetVersionNumber
    (
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS
    )
{
    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::Lock(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::Unlock(void)
{
    return(S_OK);
}

/* IClassClassicInfo2 methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetServerExecutable
    (
    /* [out] */ WCHAR **pwszServerExecutable
    )
{
    IComProcessInfo *pProcess = NULL;
    HRESULT hr = S_OK;

    *pwszServerExecutable = NULL;

    if (!(m_fValues & VALUE_SERVER_EXECUTABLE))
    {
        // If we can't to CLSCTX_LOCAL_SERVER, then this whole thing
        // is pointless anyway.
        CLSCTX clsctx;
        hr = GetClassContext(CLSCTX_LOCAL_SERVER, &clsctx);
        if (clsctx & CLSCTX_LOCAL_SERVER)
        {
            if (m_pwszLocalServer != NULL)
            {
                // We've got a LocalServer32.
                HKEY hkeyBase = NULL;
                DWORD res = RegOpenKeyExW(m_hKeyClassesRoot,
                                          m_wszClsidString,
                                          0,
                                          KEY_READ | m_regType,
                                          &hkeyBase);
                if (res == ERROR_SUCCESS)
                {
                    hr = GetRegistryStringValue(hkeyBase, 
                                                g_wszLocalServer32,
                                                g_wszServerExecutable,
                                                0, 
                                                &m_pwszServerExecutable);
                    RegCloseKey(hkeyBase);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(res);
                }
            }
            else
            {
                hr = GetProcess(IID_IComProcessInfo, (void **) &pProcess);
                if ( hr == S_OK )
                {
                    ProcessType eProcessType;
                    
                    hr = pProcess->GetProcessType(&eProcessType);
                    if (SUCCEEDED(hr))
                    {   
                        if ((eProcessType == ProcessTypeComPlus) || 
                            (eProcessType == ProcessTypeLegacySurrogate))
                        {
                            // Attempt to fault in surrogate command line, so we can check
                            // to see if we're using the debug surrogate value.  If so, then
                            // we don't want to have a ServerExecutable.
                            //
                            LPWSTR wszDummy = NULL;
                            hr = GetSurrogateCommandLine(&wszDummy);
                            if (FAILED(hr)) goto gotServerExe;
                            
                            if (m_fValues & VALUE_SURROGATE_IS_DBG)
                            {
                                // Don't read the registry-- you asked for the debug surrogate
                                // key.
                                hr = S_OK;
                                goto gotServerExe;
                            }
                        }
                        
                        if (eProcessType == ProcessTypeComPlus)
                        {
                            // No registry reading for us-- you're a dllhost!
                            WCHAR wszSystemDirectory[MAX_PATH+1] = L"";
                            SIZE_T cch;
                            
                            if (m_regType == KEY_WOW64_32KEY)
                            {
                                // Point over to the 32bit dllhost instead of the 64bit one.
                                cch = GetSystemWow64Directory(wszSystemDirectory, 
                                                              STRLEN_WCHAR(wszSystemDirectory));
                            } 
                            else 
                            {
                                cch = GetSystemDirectory(wszSystemDirectory, 
                                                         STRLEN_WCHAR(wszSystemDirectory));
                            }
                            
                            if (cch > 0)
                            {                            
                                if ( wszSystemDirectory[cch - 1] != L'\\' )
                                {
                                    wszSystemDirectory[cch] = L'\\';
                                    cch++;
                                    wszSystemDirectory[cch] = L'\0';
                                }
                                
                                m_pwszServerExecutable = new WCHAR[cch + STRLEN_WCHAR(g_wszDllHost) + 1];
                                if (m_pwszServerExecutable)
                                {
                                    wcscpy(m_pwszServerExecutable, wszSystemDirectory);
                                    wcscpy(m_pwszServerExecutable+cch, g_wszDllHost);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                        else if (eProcessType == ProcessTypeLegacySurrogate)
                        {
                            HKEY hkeyBase = NULL;
                            
                            GUID *pguidProcess;
                            hr = GetProcessId(&pguidProcess);
                            if (hr == S_OK)
                            {
                                WCHAR wszAppidString[45];
                                wcscpy(wszAppidString, g_wszAppidTemplate);
                                GUIDToString(pguidProcess, wszAppidString + 7);
                                
                                DWORD res = RegOpenKeyExW (m_hKeyClassesRoot, 
                                                           wszAppidString, 
                                                           0, 
                                                           KEY_READ | m_regType, 
                                                           &hkeyBase);
                                if (res == ERROR_SUCCESS)
                                {
                                    hr = GetRegistryStringValue(hkeyBase, 
                                                                NULL,
                                                                g_wszDllSurrogateExecutable,
                                                                0, 
                                                                &m_pwszServerExecutable);
                                    RegCloseKey(hkeyBase);
                                }
                                else
                                {
                                    hr = HRESULT_FROM_WIN32(res);
                                }
                            }
                        }
                        else
                        {
                            // Not any of these things, so there's no ServerExecutable
                            // to get.
                            hr = S_OK;
                        }
                    }
                }
            }
        }

gotServerExe:
        if (hr != E_OUTOFMEMORY)
        {
            // Well, at least we tried.
            m_fValues |= VALUE_SERVER_EXECUTABLE;
            hr = S_OK;
        }
    }

    if (pProcess)
    {
        pProcess->Release();
    }

    *pwszServerExecutable = m_pwszServerExecutable;
    return hr;
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComClassInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComClassInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif


/* private methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetProcessId
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidProcessId
    )
{
    HRESULT hr;
    HKEY hKey;

    if ( (m_fValues & VALUE_PROCESSID) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_PROCESSID) == 0 )
        {
            if ( ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey) )
            {
				WCHAR wszValue[50];

                hr = ReadRegistryStringValue(hKey, NULL, g_wszProcessId, FALSE, wszValue, sizeof(wszValue)/sizeof(WCHAR));

                if ( SUCCEEDED(hr) )
                {
                    if ( CurlyStringToGUID(wszValue, &m_guidProcessId) == TRUE )
                    {
                        m_fValues |= VALUE_PROCESSID_VALID;
                    }
                }

                RegCloseKey(hKey);
            }

            m_fValues |= VALUE_PROCESSID;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    if ( m_fValues & VALUE_PROCESSID_VALID )
    {
        *ppguidProcessId = &m_guidProcessId;

        return(S_OK);
    }
    else
    {
        *ppguidProcessId = NULL;

        return(E_FAIL);
    }
}


#ifdef DARWIN_ENABLED

//-------------------------------------------------------------------------
//
// CComClassInfo::GetPathFromDarwinDescriptor
//
// Looks for Darwin identifiers for a CLSID in the registry, and calls
// MSI apis to process the identifiers into real paths.
//
// This method can cause Darwin applications to be installed for the calling
// user.  It should always be called before trying to load full CLSID settings.
//
//
//-------------------------------------------------------------------------
HRESULT CComClassInfo::GetPathFromDarwinDescriptor(LPWSTR pszDarwinId, LPWSTR* ppszPath)
{
    INSTALLUILEVEL  OldUILevel = INSTALLUILEVEL_NONE;
    WCHAR       wszPath[MAX_PATH];
    WCHAR *     pwszPath;
    DWORD       PathLength;
    int         MsiStatus;
    HRESULT     hr;

    *ppszPath = 0;

    hr = S_OK;
    pwszPath = wszPath;
    PathLength = sizeof(wszPath) / sizeof(WCHAR);

    if ( g_bInSCM )
    {
        // Though we attempt to force all install actions to be done in the client,
        // there may still be instances when Darwin will want to put up install
        // UI when called from SCM.  So we explicitly set the UI level to none
        // to prevent any possible UI calls from hanging this thread.
        
        // Note: we delay-load link to msi!MsiSetInternalUI, but the api cannot
        // return an error directly, given the way it is prototyped.  The dload 
        // error stub sets GLE to indicate a problem occurred.
        SetLastError(ERROR_SUCCESS);        
        OldUILevel = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
        if (ERROR_PROC_NOT_FOUND == GetLastError())
            return CO_E_MSI_ERROR;

        //
        // Impersonate so that Darwin can figure out the proper
        // HKU Software\Classes subkey.
        //
        if (RpcImpersonateClient( 0 ) != RPC_S_OK) 
        {
            // Reset the UI level before we leave...
            MsiSetInternalUI(OldUILevel, NULL);            
            return CO_E_MSI_ERROR;
        }
    }

    for ( ;; )
    {
        //
        // On input, PathLength is number of wchars in pwszPath.  On output
        // it is the length of the (needed) returned path in wchars, not including
        // the null.
        //
        MsiStatus = CommandLineFromMsiDescriptor( pszDarwinId, pwszPath, &PathLength );

        PathLength++;

        if ( ERROR_MORE_DATA == MsiStatus )
        {
            pwszPath = (WCHAR *) new WCHAR[PathLength];
            if ( ! pwszPath )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            continue;
        }

        if ( MsiStatus != ERROR_SUCCESS )
            hr = CO_E_MSI_ERROR;

        break;
    }

    if ( g_bInSCM )
    {
        RevertToSelf();
        MsiSetInternalUI(OldUILevel, NULL);
    }

    if ( S_OK == hr )
    {
        *ppszPath = new WCHAR[PathLength];

        if ( *ppszPath )
            wcscpy( *ppszPath, pwszPath );
    }

    if ( pwszPath != wszPath )
        delete [] pwszPath;

    if ( hr != S_OK )
        return(hr);

    if ( ! *ppszPath )
        return(E_OUTOFMEMORY);

    return hr;
}

#endif // DARWIN_ENABLED

//+-------------------------------------------------------------------
//
//  Function:   CoGetModuleType  (this api is currently unpublished!)
//
//  Synopsis:   API to retrieve the type of a given module (mainly, 32 vs 64 bit)
//
//  Algorithm:  Memory map the file and deduce its type from its headers
//
//  History:    12-Feb-2002   mfeingol   Created
//
//+-------------------------------------------------------------------
STDAPI CoGetModuleType (LPCWSTR pwszModule, CoModuleType* pModType )
{
    HRESULT hr = S_OK;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileMapping = NULL;

    WCHAR* pwszFullPath = NULL;

    LPVOID pBase = NULL;

    // Verify args
    // (CreateFile can't handle a path with quotes)
    if (pwszModule == NULL || pModType == NULL || pwszModule[0] == L'\"')
        return E_INVALIDARG;

    *pModType = CO_MODULE_UNKNOWN;
 
    // Memmap the requested file
    hFile = CreateFileW (
        pwszModule,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE && GetLastError() == ERROR_FILE_NOT_FOUND)
    {
        WCHAR* pszTmpFileName;

        SafeAllocaAllocate (pwszFullPath, (MAX_PATH + 1) * sizeof (WCHAR));
        if (!pwszFullPath)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        DWORD dwRetVal = SearchPathW (
            NULL,
            pwszModule,
            NULL,
            MAX_PATH,
            pwszFullPath,
            &pszTmpFileName
            );

        if (dwRetVal == 0 || dwRetVal > MAX_PATH)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            goto Cleanup;
        }

        hFile = CreateFileW (
            pwszFullPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );
    }
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    hFileMapping = CreateFileMapping (
        hFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
        );
    
    if (hFileMapping == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    pBase = MapViewOfFile (hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (pBase == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    // Get image header
    PIMAGE_NT_HEADERS pImage = RtlImageNtHeader (pBase);
    if (pImage == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    // Determine type
    switch (pImage->FileHeader.Machine)
    {
    case IMAGE_FILE_MACHINE_I386:
        
        *pModType = CO_MODULE_32BIT;
        break;
        
    case IMAGE_FILE_MACHINE_IA64:
    case IMAGE_FILE_MACHINE_AMD64:
        
        *pModType = CO_MODULE_64BIT;
        break;

    default:
        
        // Couldn't determine type
        hr = E_INVALIDARG;
        break;
    }

Cleanup:

    if (pBase != NULL)
        UnmapViewOfFile (pBase);

    if (hFileMapping != NULL)
        CloseHandle (hFileMapping);

    if (hFile != INVALID_HANDLE_VALUE && hFile != NULL)
        CloseHandle (hFile);

    SafeAllocaFree (pwszFullPath);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\noenum.cxx ===
/* noenum.cxx */

#include <windows.h>
#include <comdef.h>

#include "globals.hxx"

#include "noenum.hxx"


/*
 *  class CNoEnum
 */

CNoEnum::CNoEnum(void)
{
    m_cRef = 0;
}


/* IUnknown methods */

STDMETHODIMP CNoEnum::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IEnumUnknown) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IEnumUnknown *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return(NOERROR);
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CNoEnum::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CNoEnum::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return(cRef);
}


/* IEnumUnknown methods */

HRESULT STDMETHODCALLTYPE CNoEnum::Next
(
    /* [in] */ ULONG celt,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched
)
{
    if (pceltFetched != NULL)
    {
        *pceltFetched = 0;
    }

    if (celt == 0)
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}


HRESULT STDMETHODCALLTYPE CNoEnum::Skip
(
    /* [in] */ ULONG celt
)
{
    if (celt == 0)
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}


HRESULT STDMETHODCALLTYPE CNoEnum::Reset(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CNoEnum::Clone
(
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum
)
{
    AddRef();

    *ppenum = this;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\regcat.cxx ===
/* regcat.cxx */

#include <windows.h>
#include <comdef.h>
#include <debnot.h>

#include "globals.hxx"

#include "catalog.h"        // from catalog.idl
#include "partitions.h"     // from partitions.idl
#include "partitions_i.c"   // from partitions.idl

#include "regcat.hxx"       // CComRegCatalog
#include "class.hxx"        // CComClassInfo
#include "process.hxx"      // CComProcessInfo
#include "noclass.hxx"      // CComNoClassInfo
#include "services.hxx"
#include <reghelp.hxx>

#include "catdbg.hxx"

/*
 *  globals
 */

const WCHAR g_wszClsidTemplate[] = L"CLSID\\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";
const WCHAR g_wszAppidTemplate[] = L"AppID\\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";
const WCHAR g_wszTreatAs[] = L"TreatAs";
const WCHAR g_wszOle32[] = L"ole32.dll";
const WCHAR g_wszSoftwareClasses[] = L"Software\\Classes";

extern const WCHAR g_wszLocalServer32[];
extern const WCHAR g_wszProcessId[];

extern LONG g_bInSCM;

typedef HRESULT (__stdcall *pfnCFOC)(LPCWSTR, LPCLSID, BOOL);
pfnCFOC pfnCLSIDFromOle1Class = NULL;

/*
 *  (DLL export) GetRegCatalogObject()
 */

HRESULT __stdcall GetRegCatalogObject
(
    /* [in] */ REFIID riid,
    /* [out, iis_is(riid)] */ void ** ppv,
    /* [in] */ REGSAM regType
)
{
	CComRegCatalog *pRegCatalogObject;
    HRESULT hr = S_OK;
    HKEY hkcr = NULL;

    *ppv = NULL;

    // Because the regcat object will be needing it, get pfnCLSIDFromOle1Class
    // Ignore failures.
    if (pfnCLSIDFromOle1Class == NULL)
    {
        HMODULE hOle32 = GetModuleHandle(g_wszOle32);
        if (hOle32)
        {
            pfnCLSIDFromOle1Class = (pfnCFOC)GetProcAddress(hOle32, "CLSIDFromOle1Class");
        }
    }


	LONG lResult = OpenClassesRootKey(NULL,&hkcr);
    if (lResult == ERROR_SUCCESS)
    {
        pRegCatalogObject = new CComRegCatalog(hkcr, regType);
        if ( pRegCatalogObject == NULL )
        {
            RegCloseKey(hkcr);
            
            hr = E_OUTOFMEMORY;
        }
        else
        {   
            pRegCatalogObject->AddRef();
            hr = pRegCatalogObject->QueryInterface(riid, ppv);
            pRegCatalogObject->Release();
        }
    }

    return(hr);
};


/*
 *  class CComRegCatalog
 */
CComRegCatalog::CComRegCatalog(HKEY hkcr, REGSAM regType)
{
    m_cRef            = 0;
    m_regType         = regType;
    m_hkeyClassesRoot = hkcr;
}

CComRegCatalog::~CComRegCatalog()
{
    if (m_hkeyClassesRoot)
        RegCloseKey(m_hkeyClassesRoot);
}

STDMETHODIMP CComRegCatalog::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IComCatalogInternal) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IComCatalogInternal *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN) *ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComRegCatalog::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComRegCatalog::Release(void)
{
    long cRef;

    g_CatalogLock.AcquireWriterLock();

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
		delete this;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


/* IComCatalogInternal methods */

HRESULT STDMETHODCALLTYPE CComRegCatalog::GetClassInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    LONG res;
    WCHAR wszClassString[45];
    WCHAR wszTreatAsString[100];
    const GUID *pGuid;
    GUID guidTreatAsCLSID;
    HKEY hKey;
    IComClassInfo *pClassInfo;
    long cbValue;
    int cTreatAsHops;
    HKEY hKeyRoot;
    BOOL fForceToHKLM;

#define TREATAS_HOPS_MAX (50)

    *ppv = NULL;
    cTreatAsHops = 0;
    fForceToHKLM = FALSE;

    lstrcpyW(wszClassString, g_wszClsidTemplate);

    hr = REGDB_E_CLASSNOTREG;

    pGuid = &guidConfiguredClsid;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserClassesRootKey(&hKeyRoot);
    }
    else
    {
        hKeyRoot = m_hkeyClassesRoot;
    }

    if (hKeyRoot == NULL)
    {
        return E_OUTOFMEMORY;
    }

    do
    {
        GUIDToString(pGuid, wszClassString + 7);

        res=RegOpenKeyExW(hKeyRoot, wszClassString, 0,
						  KEY_READ | m_regType, &hKey);
        if (ERROR_SUCCESS!=res)
        {
            break;
        }

        cbValue = sizeof(wszTreatAsString);

        res = RegQueryValueW(hKey, g_wszTreatAs, wszTreatAsString, &cbValue);

        if ((ERROR_SUCCESS==res) &&
            ((cbValue / 2) >= 37) &&
            (CurlyStringToGUID(wszTreatAsString, &guidTreatAsCLSID) == TRUE))
        {
            RegCloseKey(hKey);

            pGuid = &guidTreatAsCLSID;
        }
        else
        {
            CComClassInfo *pCI = new CComClassInfo();
            if (pCI != NULL)
            {
                hr = pCI->FinalConstruct(pUserToken, 
                                         hKeyRoot,
                                         pGuid, 
                                         wszClassString, 
                                         hKey, 
                                         m_regType);

                if (FAILED(hr))
                    delete pCI;
            }
            else
                hr = E_OUTOFMEMORY;

            RegCloseKey(hKey);
            if (FAILED(hr)) break;

            
            hr = S_OK;
            pClassInfo = (IComClassInfo *)pCI;
            pClassInfo->AddRef();
            if (g_bInSCM && !fForceToHKLM)
            {
                hr = CheckForceHKLMForClass(pClassInfo, &fForceToHKLM);
                if (SUCCEEDED(hr) && fForceToHKLM)
                {
                    // Try again, same CLSID, but force hKey to HKLM\Software\Classes.
                    if (pUserToken)
                        pUserToken->ReleaseUserClassesRootKey();
                    
                    hKeyRoot = NULL;                    
                    res = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                                        g_wszSoftwareClasses, 
                                        0,
                                        KEY_READ, 
                                        &hKeyRoot);
                    if (res == ERROR_SUCCESS)
                    {
                        // Destroy the open class info.
                        pClassInfo->Release();
                        pClassInfo = NULL;

                        // Reset treatas count.
                        cTreatAsHops = 0;
                        
                        // Loop around to the top again.
                        continue;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(res);
                    }
                }
            }
            
            if (SUCCEEDED(hr))
            {
                hr = pClassInfo->QueryInterface(riid, ppv);
            }
            pClassInfo->Release();

            break;
        }

    } while (cTreatAsHops++ < TREATAS_HOPS_MAX);

    if (fForceToHKLM)
    {
        if (hKeyRoot != NULL)
            RegCloseKey(hKeyRoot);
    }
	else if (pUserToken)
    {
        pUserToken->ReleaseUserClassesRootKey();
    }

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetApplicationInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetProcessInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    LONG res;
    WCHAR wszAppidString[45];
    HKEY hKey;
    IComProcessInfo *pProcessInfo;
    HKEY hKeyRoot;
    BOOL fForceToHKLM;

	CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
					 "CComRegCatalog::GetProcessInfo: ProcID={%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n", 
                     (DWORD)guidProcess.Data1,
                     (DWORD)guidProcess.Data2,
                     (DWORD)guidProcess.Data3,
                     (DWORD)guidProcess.Data4[0],
                     (DWORD)guidProcess.Data4[1],
                     (DWORD)guidProcess.Data4[2],
                     (DWORD)guidProcess.Data4[3],
                     (DWORD)guidProcess.Data4[4],
                     (DWORD)guidProcess.Data4[5],
                     (DWORD)guidProcess.Data4[6],
                     (DWORD)guidProcess.Data4[7]));


    *ppv = NULL;
    fForceToHKLM = FALSE;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserClassesRootKey(&hKeyRoot);
    }
    else
    {
        hKeyRoot = m_hkeyClassesRoot;
    }
    
    if (hKeyRoot == NULL)
    {
        return E_OUTOFMEMORY;
    }

retry:
    lstrcpyW(wszAppidString, g_wszAppidTemplate);
    GUIDToString(&guidProcess, wszAppidString + 7);
    
    res = RegOpenKeyExW(hKeyRoot, wszAppidString, 0, 
                        KEY_READ | m_regType, &hKey);
    if (ERROR_SUCCESS==res)
    {
        pProcessInfo = (IComProcessInfo *) new CComProcessInfo(pUserToken, guidProcess, wszAppidString, hKey);
        if (pProcessInfo == NULL)
        {
            CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                             "CComRegCatalog::GetProcessInfo: Failed to allocate ProcInfo\n"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
            pProcessInfo->AddRef();
            if (g_bInSCM && !fForceToHKLM)
            {
                CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                                 "CComRegCatalog::GetProcessInfo: Checking ForceToHKLM...\n"));
                hr = CheckForceHKLMForProcess(pProcessInfo, &fForceToHKLM);
                if (SUCCEEDED(hr) && (fForceToHKLM))
                {
                    CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                                     "CComRegCatalog::GetProcessInfo: ForceToHKLM true...\n"));
                    
                    if (pUserToken != NULL)
                        pUserToken->ReleaseUserClassesRootKey();

                    // Try again, same ProcessID, but use HKLM\Software\Classes as the root.
                    hKeyRoot = NULL;
                    res = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                                        g_wszSoftwareClasses, 
                                        0,
                                        KEY_READ, 
                                        &hKeyRoot);
                    if (res == ERROR_SUCCESS)
                    {
                        CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                                         "CComRegCatalog::GetProcessInfo: Opened HKLM\\Software\\Classes\n"));
                        
                        // Release the process info we just got.
                        pProcessInfo->Release();
                        pProcessInfo = NULL;
                        
                        // Skip back to the top of the loop, re-get process info.
                        CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                                         "CComRegCatalog::GetProcessInfo: Back to the top...\n"));

                        RegCloseKey(hKey);
                        goto retry;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                                         "CComRegCatalog::GetProcessInfo: ForceToHKLM false\n"));
                    }
                    else
                    {
                        CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                                         "CComRegCatalog::GetProcessInfo: Error checking ForceToHKLM 0x%08x\n", hr));
                    }
                }
            }
            
            if (SUCCEEDED(hr))
            {
                hr = pProcessInfo->QueryInterface(riid, ppv);
                CatalogDebugOut((DEB_PROCESSINFO, "CComRegCatalog::GetProcessInfo: Everything's good, QI... (0x%08x)\n", hr));
            }               
            pProcessInfo->Release();
        }
        
        RegCloseKey(hKey);
    }
    else
    {
        CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, "CComRegCatalog::GetProcessInfo: Failed to open APPID key\n"));
        hr = E_FAIL;
    }

    if (fForceToHKLM)
    {
        if (hKeyRoot != NULL)
            RegCloseKey(hKeyRoot);
    }
	else if (pUserToken)
    {
        pUserToken->ReleaseUserClassesRootKey();
    }

	CatalogDebugOut((DEB_PROCESSINFO | DEB_REGCAT, 
                     "CComRegCatalog::GetProcessInfo: returning 0x%08x (ppv %p)\n", hr, *ppv));

    return(hr);
}

HRESULT STDMETHODCALLTYPE CComRegCatalog::GetServerGroupInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetRetQueueInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetApplicationInfoForExe
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetTypeLibrary
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetInterfaceInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::FlushCache(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetClassInfoFromProgId
(
    /* [in] */ IUserToken __RPC_FAR *pUserToken,
    /* [in] */ WCHAR __RPC_FAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    CLSID clsid;

    *ppv = NULL;

    // Classic implementation resides in OLE32, but answer the question
    // here so we can cache things.
    if (pfnCLSIDFromOle1Class)
    {
        hr = pfnCLSIDFromOle1Class(pwszProgID, &clsid, FALSE);
        if (SUCCEEDED(hr))
        {
            // If the catalog supports IComCatalogSCM then we'll use that, so we can
            // explicitly turn off CLSCTX validation, otherwise, we'll use IComCatalogInternal
            // and hope for the best.
            //
            IComCatalogSCM *pCCS = NULL;
            hr = ((IUnknown *)pComCatalog)->QueryInterface(IID_IComCatalogSCM, (void **)&pCCS);
            if (SUCCEEDED(hr))
            {
                hr = pCCS->GetClassInfo(0, pUserToken, clsid, riid, ppv);
                pCCS->Release();
            }
            else
            {            
                IComCatalogInternal *pCCI = NULL;
                hr = ((IUnknown *)pComCatalog)->QueryInterface(IID_IComCatalogInternal, (void **)&pCCI);
                Win4Assert(SUCCEEDED(hr) && "pComCatalog doesn't support IComCatalogInternal??");
            
                hr = pCCI->GetClassInfo(pUserToken, clsid, riid, ppv, pComCatalog);
                pCCI->Release();
            }

            if (hr != S_OK)
            {
                // pfnCLSIDFromOle1Class succeeded, but the class is not
                // actually registered.  Create a class info here that has
                // the CLSID and the ProgID right, but nothing else.
                //
                // This has interesting cache implications.  In this case,
                // the ClassInfo cache for GetClassInfo will have a failure
                // entry in it, which means that it will always check the
                // registry on the next access, while the cache for 
                // GetClassInfoFromProgId will have a success in it.  The
                // only saving grace here is that the catalog already treats
                // success from this function with suspicion, and so always
                // checks the registry for changes.
                if (*ppv)
                {
                     ((IUnknown *)(*ppv))->Release();
                     *ppv = NULL;
                }

                // Created with zero references...
                CComNoClassInfo *pNoClassInfo = new CComNoClassInfo(clsid, pwszProgID);
                if (pNoClassInfo)
                {
                    // Adds the first reference...
                    hr = pNoClassInfo->QueryInterface(riid, ppv);
                    if (hr != S_OK)
                    {
                        *ppv = NULL;
                        delete pNoClassInfo;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        } 
        else 
        {
            // Put forward a kosher response.
            hr = REGDB_E_CLASSNOTREG;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

HRESULT CComRegCatalog::CheckForceHKLMForClass
(
    IComClassInfo *pCCI, 
    BOOL *pfForceHKLM
)
{
    IComProcessInfo *pCPI = NULL;
    IClassClassicInfo *pClassicInfo = NULL;
    CLSCTX ctxIn  = (CLSCTX)CLSCTX_SERVER;
    CLSCTX ctxOut = (CLSCTX)0;
    HRESULT hr    = S_OK;

    *pfForceHKLM  = FALSE;

    // Step 1: Get the class context.  This has the additional benefit
    //         of faulting in darwin stuff.    
    //
    hr = pCCI->GetClassContext(ctxIn, &ctxOut);
    Win4Assert(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    
    // Step 2: Get the related process info, if any.
    //
    hr = pCCI->QueryInterface(IID_IClassClassicInfo, (void **)&pClassicInfo);
    Win4Assert(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        hr = pClassicInfo->GetProcess(IID_IComProcessInfo, (void **)&pCPI);
        pClassicInfo->Release();
    }
    if (SUCCEEDED(hr) && (pCPI != NULL))
    {
        // Step 3: Figure out if the process info needs to come from 
        //         HKLM.  If so, then so do we.
        //
        hr = CheckForceHKLMForProcess(pCPI, pfForceHKLM);

        pCPI->Release();
    }
    else if (hr == E_FAIL)
    {
        // E_FAIL is returned when the process info does not exist.
        //
        // No process info, must not be have run-as info, so don't
        // bother forcing to HKLM.
        //
        *pfForceHKLM = FALSE;
        hr = S_OK;
    }

    return hr;
}

HRESULT CComRegCatalog::CheckForceHKLMForProcess
(
    IComProcessInfo *pICPI, 
    BOOL *pfForceHKLM
)
{
    RunAsType rat;
    HRESULT hr = pICPI->GetRunAsType(&rat);
    Win4Assert(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    if (rat != RunAsLaunchingUser)
    {
        // Anything except activate-as-activator needs to be only from
        // HKLM.
        *pfForceHKLM = TRUE;
    }
    else
    {
        *pfForceHKLM = FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\regmisc.c ===
#include <nt.h> 
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

//HACKHACK: Stolen from registry redirector people, only for debug out.
BOOL
HandleToKeyName ( 
    HANDLE Key,
    PWCHAR KeyName,
    DWORD * dwLen
    )
/*++

Routine Description:

    Determine the text equivalent for key handle

Arguments:

    Key - is key handle for which to obtain its text
    KeyName - Unicode string to receive the Name of the key.
    dwLen   - Length of the buffer pointed by KeyName. (Number of unicode char)

Return Value:

    TRUE if the handle text is fetched OK.  FALSE if not (ie. error or
    Key is an illegal handle, etc.)

--*/
{
    NTSTATUS Status;
    ULONG Length;

    POBJECT_NAME_INFORMATION ObjectName;

    CHAR Buffer[sizeof(OBJECT_NAME_INFORMATION) +STATIC_UNICODE_BUFFER_LENGTH*2];
    ObjectName = (POBJECT_NAME_INFORMATION)Buffer;

    if (Key == NULL)
        return FALSE;

    Status = NtQueryObject(Key,
                       ObjectNameInformation,
                       ObjectName,
                       sizeof(Buffer),
                       &Length
                       );

    if (!NT_SUCCESS(Status) || !Length || Length >= sizeof(Buffer))
        return FALSE;

    //
    //  buffer overflow condition check
    //

    if (*dwLen < (ObjectName->Name.Length/sizeof(WCHAR) + 1) ) {
        *dwLen = 1 + ObjectName->Name.Length / sizeof(WCHAR) + 1;
        return FALSE;  //buffer overflow
    }

    wcsncpy(KeyName, ObjectName->Name.Buffer, ObjectName->Name.Length/sizeof(WCHAR));
    KeyName[ObjectName->Name.Length/sizeof(WCHAR)]=UNICODE_NULL;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   catalog
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = obj
INCLUDES=     $(INCLUDES);..\..\..\idl\public\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\inc
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH);$(DS_INC_PATH)


C_DEFINES=    $(C_DEFINES) -DDARWIN_ENABLED -DMSWMSG

SOURCES=      $(SOURCES)                                      \
              ..\cache.cxx                                    \
              ..\catalog.cxx                                  \
              ..\class.cxx                                    \
              ..\noclass.cxx                                  \
              ..\noenum.cxx                                   \
              ..\notify.cxx                                   \
              ..\process.cxx                                  \
              ..\regcat.cxx                                   \
              ..\services.cxx                                 \
              ..\sxscat.cxx                                   \
              ..\sxsclass.cxx                                 \
              ..\regmisc.c

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\services.cxx ===
/* services.cxx */

#include <ole2int.h> // Get OLE2INT_ROUND_UP
#include <comdef.h>
#include <string.h>
#include "globals.hxx"

#include "services.hxx"

#include "catdbg.hxx" // Support for tracing and logging

#include <impersonate.hxx>

// Moved this from ole32\com\dcomrem\security.cxx

// Versions of the permissions in the registry.
const WORD COM_PERMISSION_SECDESC = 1;
const WORD COM_PERMISSION_ACCCTRL = 2;

// This leaves space for 8 sub authorities.  Currently NT only uses 6 and
// Cairo uses 7.
const DWORD SIZEOF_SID          = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL          = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                  2 * SIZEOF_SID;

const DWORD SIZEOF_TOKEN_USER   = sizeof(TOKEN_USER) + SIZEOF_SID;

const SID   LOCAL_SYSTEM_SID    = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_LOCAL_SYSTEM_RID };

const SID   RESTRICTED_SID      = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_RESTRICTED_CODE_RID };
// End security.cxx

const WCHAR g_wszSoftwareClasses[] = L"Software\\Classes";

HANDLE g_ProcessHeap = NULL;

//  abcdefgh-ijkl-mnop-qrst-uvwxyzABCDEF
//  0000000000111111111122222222223333333
//  0123456789012345678901234567890123456

//  00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
//  gh ef cd ab kl ij op mn qr st uv wx yz AB CD EF

#define SEPARATOR1 (8)
#define SEPARATOR2 (13)
#define SEPARATOR3 (18)
#define SEPARATOR4 (23)

int guidByteToStringPosition[] =
{
#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)
    6, 4, 2, 0, 11, 9, 16, 14, 19, 21, 24, 26, 28, 30, 32, 34, -1
#else
#error Processor-specific code needed in services.cxx
#endif
};

//  {abcdefgh-ijkl-mnop-qrst-uvwxyzABCDEF}
//  000000000011111111112222222222333333333
//  012345678901234567890123456789012345678

#define CURLY_OPEN  (0)
#define CURLY_CLOSE (37)


void GUIDToString(const _GUID *pGuid, WCHAR *pwszString)
{
    int *pPosition = guidByteToStringPosition;
    BYTE *pGuidByte = (BYTE *) pGuid;
    WCHAR c;
    WCHAR *pchOut;
    BYTE b;

    while (*pPosition >= 0)
    {
        pchOut = pwszString + *pPosition++;
        b = *pGuidByte++;

        c = (WCHAR) ((b >> 4) & 0x0F) + '0';
        if (c > '9')
        {
            c += ('A' - '0' - 10);
        }

        *pchOut++ = c;

        c = (WCHAR) (b & 0x0F) + '0';
        if (c > '9')
        {
            c += ('A' - '0' - 10);
        }

        *pchOut = c;
    }

    pwszString[SEPARATOR1] = '-';
    pwszString[SEPARATOR2] = '-';
    pwszString[SEPARATOR3] = '-';
    pwszString[SEPARATOR4] = '-';
}


bool StringToGUID(const WCHAR *pwszString, _GUID *pGuid)
{
    int *pPosition = guidByteToStringPosition;
    BYTE *pGuidByte = (BYTE *) pGuid;
    WCHAR c;
    const WCHAR *pchIn;
    BYTE b;

    while (*pPosition >= 0)
    {
        pchIn = pwszString + *pPosition++;

        c = *pchIn++;

        if ((c >= '0') && (c <= '9'))
        {
            b = (BYTE) (c - '0');
        }
        else if ((c >= 'A') && (c <= 'Z'))
        {
            b = (BYTE) (c - 'A' + 10);
        }
        else if ((c >= 'a') && (c <= 'z'))
        {
            b = (BYTE) (c - 'a' + 10);
        }
        else
        {
            return(FALSE);
        }

        b <<= 4;

        c = *pchIn++;

        if ((c >= '0') && (c <= '9'))
        {
            b |= (c - '0');
        }
        else if ((c >= 'A') && (c <= 'Z'))
        {
            b |= (c - 'A' + 10);
        }
        else if ((c >= 'a') && (c <= 'z'))
        {
            b |= (c - 'a' + 10);
        }
        else
        {
            return(FALSE);
        }

        *pGuidByte++ = b;
    }

    if ((pwszString[SEPARATOR1] != '-') ||
        (pwszString[SEPARATOR2] != '-') ||
        (pwszString[SEPARATOR3] != '-') ||
        (pwszString[SEPARATOR4] != '-'))
    {
        return(FALSE);
    }

    return(TRUE);
}


void GUIDToCurlyString(const _GUID *pGuid, WCHAR *pszString)
{
    pszString[CURLY_OPEN] = L'{';
    pszString[CURLY_CLOSE] = L'}';

    GUIDToString(pGuid, pszString + 1);
}


bool CurlyStringToGUID(const WCHAR *pszString, _GUID *pGuid)
{
    if ((pszString[CURLY_OPEN] == '{') &&
        (pszString[CURLY_CLOSE] == '}'))
    {
        return(StringToGUID(pszString + 1, pGuid));
    }
    else
    {
        return(FALSE);
    }
}

#define MAX_VALUE_CHARS (500)

const WCHAR g_wszEmptyString[] = L"\0";   /* an empty MULTI_SZ string */
const WCHAR g_wszQuoteQuote[] = L"\"\"";  /* a string consisting of two quotes */

HRESULT GetRegistryStringValue
(
    HKEY hParent,
    const WCHAR *pwszSubKeyName,
    const WCHAR *pwszValueName,
    DWORD dwQueryFlags,
    WCHAR **ppwszValue
)
{
    LONG res;
    HKEY hKey;
    LPWSTR pszValue = NULL;
    BOOL fMultiSz = dwQueryFlags & RQ_MULTISZ;
    BOOL fAllowQuoteQuote = dwQueryFlags & RQ_ALLOWQUOTEQUOTE;

    *ppwszValue = NULL;

#ifdef DBG
	if (CatalogInfoLevel & DEB_READREGISTRY)
	{
		LPWSTR pszValueDebug = new WCHAR[MAX_VALUE_CHARS + 2];

		if (NULL == pszValueDebug)
		{
			return E_OUTOFMEMORY;
		}

		// Sometimes we add two trailing NUL characters after the character array, so allocate 2 extra bytes

		DWORD cchValue = MAX_VALUE_CHARS ;			// character count

		BOOL ret = HandleToKeyName(hParent, pszValueDebug, &cchValue);
		
		CatalogDebugOut((DEB_READREGISTRY, 
						 "GetRegistryStringValue: %ws%ws%ws%ws%ws\n",
						 (ret ? pszValueDebug : L"???"),
						 (pwszSubKeyName ? L"\\" : L""),
						 (pwszSubKeyName ? pwszSubKeyName : L""),
						 (pwszValueName  ? L"\\" : L""),
						 (pwszValueName  ? pwszValueName  : L"")));

		delete [] pszValueDebug;
	}
#endif

    /* read value */

    if (pwszSubKeyName != NULL)
    {
        res = RegOpenKeyExW(hParent, pwszSubKeyName, 0, KEY_READ, &hKey);
        if (ERROR_SUCCESS!=res)
        {
			HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
			CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue Fail RegOpenKeyW hr = 0x%08x\n", hr));
            return hr;
        }
    }
    else
    {
        hKey = hParent;
    }

    pszValue = new WCHAR[MAX_VALUE_CHARS + 2];
    if (NULL == pszValue)
    {
        if (pwszSubKeyName != NULL)
        {
            RegCloseKey(hKey);
        }
	    return E_OUTOFMEMORY;
    }

    DWORD cbValue = sizeof(WCHAR) * MAX_VALUE_CHARS;
	DWORD dwValueType = REG_NONE;

    memset(pszValue, 0, cbValue);  // need to init buffer for rest of logic to work

    res = RegQueryValueExW(hKey, pwszValueName, NULL, &dwValueType, (unsigned char *) pszValue, &cbValue);

    if (pwszSubKeyName != NULL)
    {
        RegCloseKey(hKey);
    }
    hKey = NULL;

    if (ERROR_SUCCESS != res)
    {
		HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
		CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue Fail RegQueryValueEx hr = 0x%08x\n", hr));

		delete [] pszValue;
		return hr;
    }

    if (dwValueType == REG_NONE)
    {
        dwValueType = REG_SZ;
        cbValue = 0;
    }

    DWORD cchValue = MAX_VALUE_CHARS ;

    /* expand environment strings if indicated */

    if (dwValueType == REG_EXPAND_SZ)
    {
        pszValue[cchValue] = L'\0';

		LPWSTR pszValueTranslated = new WCHAR[MAX_VALUE_CHARS + 2];

		if (NULL == pszValueTranslated)
		{
			delete [] pszValue;
			return E_OUTOFMEMORY;
		}

        cchValue = ExpandEnvironmentStringsW( pszValue, pszValueTranslated, MAX_VALUE_CHARS);

		delete [] pszValue;
		pszValue = NULL;

        if ((cchValue == 0) || (cchValue > MAX_VALUE_CHARS))
        {
            return(REGDB_E_INVALIDVALUE);
        }

        dwValueType = REG_SZ;

        pszValue = pszValueTranslated;
    }

    /* make sure it's a string, or multi if allowed */

    if ((dwValueType != REG_SZ) && ((dwValueType != REG_MULTI_SZ) || !fMultiSz))
    {
        CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue hr = 0x%08x\n", REGDB_E_INVALIDVALUE));

        delete [] pszValue;
        return(REGDB_E_INVALIDVALUE);
    }


    /* trim appropriately */

    while ((cchValue >= 1) && (pszValue[cchValue - 1] == L'\0'))
    {
        cchValue--;     /* discard trailing NULs */
    }

    if (!fMultiSz)
    {
        while ((cchValue >= 1) && (pszValue[cchValue - 1] == L' '))
        {
            cchValue--; /* discard trailing blanks */
        }

        while ((cchValue >= 1) && (pszValue[0] == L' '))
        {
            cchValue--; /* discard leading blanks */
            pszValue++;
        }

///////////////////////////////////////////////////////////////////////////
//
//  NT #319961 - why did we ever strip quotes off those darn strings?
//
//        if ((cchValue >= 2) &&
//            (pszValue[0] == L'"') &&
//            (pszValue[cchValue - 1] == L'"'))
//        {
//            cchValue -= 2;  /* discard matching quotes */
//            pszValue++;
//        }
//
///////////////////////////////////////////////////////////////////////////

    }

    /* don't allocate empty strings; return static instance instead */
    if (cchValue == 0)
    {
        *ppwszValue = (WCHAR*)g_wszEmptyString;
        delete [] pszValue;
        return(S_OK);
    }

    // Some people put "" in the registry, caller can say he
    // doesn't want to accept them.
    if (!fAllowQuoteQuote)
    {
        if (!lstrcmpW(pszValue, g_wszQuoteQuote))
        {
            delete [] pszValue;
            return(REGDB_E_INVALIDVALUE);
        }
    }

    pszValue[cchValue++] = L'\0';       /* terminate REG_SZ */

    if (fMultiSz)
    {
        pszValue[cchValue++] = L'\0';  /* terminate REG_MULTI_SZ */
    }

    /* allocate & return copy of polished string */

    LPWSTR pwszResult = new WCHAR[cchValue];

    if (pwszResult == NULL)
    {
        CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue hr = 0x%08x\n", E_OUTOFMEMORY));
        delete [] pszValue;
        return(E_OUTOFMEMORY);
    }

    memcpy(pwszResult, pszValue, sizeof(WCHAR) * cchValue);

    *ppwszValue = pwszResult;

    delete [] pszValue;

    CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue returning %ws\n", pwszResult));

    return(S_OK);
}


HRESULT ReadRegistryStringValue
(
    HKEY hParent,
    const WCHAR *pwszSubKeyName,
    const WCHAR *pwszValueName,
    BOOL fMultiSz,
    WCHAR *pwszValueBuffer,
    DWORD cchBuffer
)
{
    LONG res;
    HKEY hKey;

#ifdef DBG
	if (CatalogInfoLevel & DEB_READREGISTRY)
	{
		LPWSTR pszValueDebug = new WCHAR[MAX_VALUE_CHARS + 2];
		
		if (NULL == pszValueDebug)
		{
			return E_OUTOFMEMORY;
		}

		DWORD cch = MAX_VALUE_CHARS;

		BOOL ret = HandleToKeyName(hParent, pszValueDebug, &cch);
		
		CatalogDebugOut((DEB_READREGISTRY, 
						 "ReadRegistryStringValue: %ws%ws%ws%ws%ws\n",
						 (ret ? pszValueDebug : L"???"),
						 (pwszSubKeyName ? L"\\" : L""),
						 (pwszSubKeyName ? pwszSubKeyName : L""),
						 (pwszValueName  ? L"\\" : L""),
						 (pwszValueName  ? pwszValueName  : L"")));

		delete [] pszValueDebug;
	}
#endif

    /* read value */

    if (pwszSubKeyName != NULL)
    {
        res = RegOpenKeyExW(hParent, pwszSubKeyName, 0, KEY_READ, &hKey);
        if (ERROR_SUCCESS!=res)
        {
			HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
			CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue Fail RegOpenKeyW hr = 0x%08x\n", hr));
            return hr;
        }
    }
    else
    {
        hKey = hParent;
    }

    DWORD cbValue = sizeof(WCHAR) * cchBuffer;
	DWORD dwValueType = REG_NONE;

    res=RegQueryValueExW(hKey, pwszValueName, NULL, &dwValueType, (unsigned char *) pwszValueBuffer, &cbValue);

    if (pwszSubKeyName != NULL)
    {
        RegCloseKey(hKey);
    }
    hKey = NULL;

    if (ERROR_SUCCESS!=res)
    {
		HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
		CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue Fail RegQueryValueExW hr = 0x%08x\n", hr));
        return hr;
    }

    if (dwValueType == REG_NONE)
    {
        dwValueType = REG_SZ;
        cbValue = 0;
    }

    DWORD cchValue = cbValue / sizeof(WCHAR);

    /* expand environment strings if indicated */

    if (dwValueType == REG_EXPAND_SZ)
    {
        pwszValueBuffer[cchValue] = L'\0';

		LPWSTR pszValueTranslated = new WCHAR[MAX_VALUE_CHARS + 2];

		if (NULL == pszValueTranslated)
		{
			return E_OUTOFMEMORY;
		}

        cchValue = ExpandEnvironmentStringsW( pwszValueBuffer, pszValueTranslated, MAX_VALUE_CHARS);

        if ((cchValue == 0) || (cchValue > MAX_VALUE_CHARS))
        {
			delete [] pszValueTranslated;

            return(REGDB_E_INVALIDVALUE);
        }

        dwValueType = REG_SZ;

        memcpy(pwszValueBuffer, pszValueTranslated, sizeof(WCHAR) * (cchValue + 1));

		delete [] pszValueTranslated;
    }


    /* make sure it's a string, or multi if allowed */

    if ((dwValueType != REG_SZ) && ((dwValueType != REG_MULTI_SZ) || !fMultiSz))
    {
		CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue hr = 0x%08x\n", REGDB_E_INVALIDVALUE));
        return(REGDB_E_INVALIDVALUE);
    }

    /* trim & terminate appropriately */

    while ((cchValue >= 1) && (pwszValueBuffer[cchValue - 1] == L'\0'))
    {
        cchValue--;
    }

    if (!fMultiSz)
    {
        while ((cchValue >= 1) && (pwszValueBuffer[cchValue - 1] == L' '))
        {
            cchValue--;
        }

        while ((cchValue >= 1) && (pwszValueBuffer[0] == L' '))
        {
            DWORD cch;
            WCHAR *p;

            cchValue--;

            for (cch = cchValue, p = pwszValueBuffer; cch > 0; cch--, p++)
            {
                *p = *(p+1);
            }
        }

        if ((cchValue >= 2) &&
            (pwszValueBuffer[0] == L'"') &&
            (pwszValueBuffer[cchValue - 1] == L'"'))
        {
            DWORD cch;
            WCHAR *p;

            cchValue -= 2;

            for (cch = cchValue, p = pwszValueBuffer; cch > 0; cch--, p++)
            {
                *p = *(p+1);
            }
        }

        pwszValueBuffer[cchValue++] = L'\0';
    }
    else
    {
        pwszValueBuffer[cchValue++] = L'\0';
        pwszValueBuffer[cchValue++] = L'\0';
    }

	CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue returning %ws\n", pwszValueBuffer));
    return(S_OK);
}



HRESULT GetRegistrySecurityDescriptor
(
    /* [in] */  HKEY hKey,
    /* [in] */  const WCHAR *pValue,
    /* [out] */ SECURITY_DESCRIPTOR **ppSD,
    /* [out] */ DWORD *pCapabilities,
    /* [out] */ DWORD *pdwDescriptorLength
)
{
    DWORD   cbSD;
    DWORD   cbSD2;
    LONG    res;
    DWORD   dwType;
    SECURITY_DESCRIPTOR *pSD;
    WORD    wVersion=0;
    *ppSD = NULL;

    cbSD = 0;
    *pdwDescriptorLength = 0;

    res = RegQueryValueExW( hKey, pValue, NULL, &dwType, NULL, &cbSD );
    if (res == ERROR_FILE_NOT_FOUND)
    {
        return(REGDB_E_KEYMISSING);
    }
    else if (((res != ERROR_SUCCESS) && (res != ERROR_MORE_DATA)) ||
        (dwType != REG_BINARY) ||
        (cbSD < sizeof(WORD)))
    {
        return(REGDB_E_INVALIDVALUE);
    }

    cbSD2 = cbSD;

#ifdef _WIN64
    {
        DWORD deltaSize;

        deltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE );
        // Win4Assert (deltaSize < sizeof( SECURITY_DESCRIPTOR ));
        deltaSize = (DWORD) OLE2INT_ROUND_UP( deltaSize, sizeof(PVOID) );

        cbSD2 = cbSD2 + deltaSize;
    }
#endif // _WIN64

    pSD = (SECURITY_DESCRIPTOR *) new unsigned char[cbSD2];
    if (pSD == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    res = RegQueryValueExW( hKey, pValue, NULL, &dwType, (unsigned char *) pSD, &cbSD );
    if (res != ERROR_SUCCESS)
    {
        delete [] reinterpret_cast<unsigned char*>(pSD);

        return(REGDB_E_READREGDB);
    }

    //if (!pCapabilities)
    //{
        // LaunchPermission SD is being read: fix it up if necessary
        wVersion= *((WORD*) pSD);
        if ((wVersion == COM_PERMISSION_SECDESC) &&
            (cbSD >= sizeof(SECURITY_DESCRIPTOR)))
        {

#ifdef _WIN64
            if ( MakeAbsoluteSD2( pSD, &cbSD2 ) == FALSE )   {
                delete [] reinterpret_cast<unsigned char*>(pSD);
                return(REGDB_E_INVALIDVALUE);
            }
#else  // !_WIN64

            pSD->Control &= ~SE_SELF_RELATIVE;

            pSD->Sacl = NULL;

            if (pSD->Dacl != NULL)
            {
                if ((cbSD < (sizeof(SECURITY_DESCRIPTOR) + sizeof(ACL))) ||
                    (cbSD < (((ULONG) pSD->Dacl) + sizeof(ACL))))
                {
                    delete [] reinterpret_cast<unsigned char*>(pSD);

                    return(REGDB_E_INVALIDVALUE);
                }

                pSD->Dacl = (ACL *) (((BYTE *) pSD) + ((ULONG) pSD->Dacl));

                if (cbSD < (pSD->Dacl->AclSize + sizeof(SECURITY_DESCRIPTOR)))
                {
                    delete [] reinterpret_cast<unsigned char*>(pSD);

                    return(REGDB_E_INVALIDVALUE);
                }
            }

            if ((pSD->Group == 0) ||
                (pSD->Owner == 0) ||
                (cbSD < (((ULONG) pSD->Group) + sizeof(SID))) ||
                (cbSD < (((ULONG) pSD->Owner) + sizeof(SID))))
            {
                delete [] reinterpret_cast<unsigned char*>(pSD);

                return(REGDB_E_INVALIDVALUE);
            }

            pSD->Group = (SID *) (((BYTE *) pSD) + (ULONG) pSD->Group);
            pSD->Owner = (SID *) (((BYTE *) pSD) + (ULONG) pSD->Owner);

#endif // !_WIN64

        }
        else if (wVersion == COM_PERMISSION_ACCCTRL)
        {
            *pdwDescriptorLength = cbSD;
        }
        else
        {
            delete [] reinterpret_cast<unsigned char*>(pSD);
            return (REGDB_E_INVALIDVALUE);
        }
    //}
    //else
    //{
    //    // pCapabilities !=NULL: AccessPermission being requested: don't fix it up
    //}

    *ppSD = pSD;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Function:   MakeSecDesc, private
//
//  Synopsis:   Make a security descriptor that allows the current user
//              and local system access.
//
//  NOTE: Compute the length of the sids used rather then using constants.
//
//--------------------------------------------------------------------
HRESULT CatalogMakeSecDesc( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities)
{
    HRESULT            hr         = S_OK;
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lIgnore;
    HANDLE             hThread;

    //Win4Assert( *pSD == NULL );

    // Open the process's token.
    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        // If the thread has a token, remove it and try again.
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
                              &hThread ))
        {
            //Win4Assert( !"How can both OpenThreadToken and OpenProcessToken fail?" );
            return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }
        if (!SetThreadToken( NULL, NULL ))
        {
            hr =MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
            CloseHandle( hThread );
            return hr;
        }
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        SetThreadToken( NULL, hThread );
        CloseHandle( hThread );
        if (FAILED(hr))
            return hr;
    }

    // Lookup SID of process token.
    if (!GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                                 &lIgnore ))
        goto last_error;

    // Compute the length of the SID.
    lSidLen = GetLengthSid( pTokenUser->User.Sid );
    //Win4Assert( lSidLen <= SIZEOF_SID );

    // Allocate the security descriptor.
    *pSD = (SECURITY_DESCRIPTOR *) new unsigned char[
                  sizeof(SECURITY_DESCRIPTOR) + 3*lSidLen + SIZEOF_ACL ];
    if (*pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    pGroup = (SID *) (*pSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*pSD, SECURITY_DESCRIPTOR_REVISION))
        goto last_error;

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
        goto last_error;

    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              pTokenUser->User.Sid))
        goto last_error;

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &LOCAL_SYSTEM_SID ))
        goto last_error;

    // TEMPORARY TEMPORARY TEMPORARY
    // Allow Restricted access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &RESTRICTED_SID ))
        goto last_error;
    // TEMPORARY TEMPORARY TEMPORARY

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *pSD, TRUE, pAcl, FALSE ))
        goto last_error;

    // Set the group.
    memcpy( pGroup, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorGroup( *pSD, pGroup, FALSE ))
        goto last_error;

    // Set the owner.
    memcpy( pOwner, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorOwner( *pSD, pOwner, FALSE ))
        goto last_error;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pSD ))
    {
        //Win4Assert( !"COM Created invalid security descriptor." );
        goto last_error;
    }
#endif

    goto cleanup;
last_error:
    hr= MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

cleanup:
    if (hToken != NULL)
        CloseHandle( hToken );
    if (FAILED(hr))
    {
        delete  *pSD;
        *pSD = NULL;
    }
    return hr;
}

DWORD Hash(const BYTE *pbKey, DWORD cbKey)
{
    DWORD hash;

    hash = (DWORD) -1;

    while (cbKey--)
    {
        hash ^= (hash << 3) ^ *pbKey++;
    }

    return(hash);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\catalog\process.cxx ===
/* process.cxx */

#include <windows.h>
#include <comdef.h>
#include <string.h>
#include <winsafer.h>

#include "globals.hxx"

#include "catalog.h"
#include "partitions.h"
#include "process.hxx"
#include "noenum.hxx"
#include "services.hxx"

#include <debnot.h>
#include "catdbg.hxx"


const WCHAR g_wszRunAs[] = L"RunAs";
const WCHAR g_wszInteractive_User[] = L"Interactive User";
const WCHAR g_wszActivateAtStorage[] = L"ActivateAtStorage";
const WCHAR g_wszLaunchPermission[] = L"LaunchPermission";
const WCHAR g_wszAccessPermission[] = L"AccessPermission";
const WCHAR g_wszAuthenticationLevel[] = L"AuthenticationLevel";
const WCHAR g_wszHKLMOle[] = L"Software\\Microsoft\\OLE";
const WCHAR g_wszDefaultLaunchPermission[] = L"DefaultLaunchPermission";
const WCHAR g_wszDefaultAccessPermission[] = L"DefaultAccessPermission";
const WCHAR g_wszLegacyAuthenticationLevel[] = L"LegacyAuthenticationLevel";
const WCHAR g_wszLegacyImpersonationLevel[] = L"LegacyImpersonationLevel";
const WCHAR g_wszLocalService[] = L"LocalService";
const WCHAR g_wszServiceParameters[] = L"ServiceParameters";
const WCHAR g_wszDllSurrogate[] = L"DllSurrogate";
const WCHAR g_wszRemoteServerName[] = L"RemoteServerName";
const WCHAR g_wszSRPTrustLevel[] = L"SRPTrustLevel";

// The domain name to use if no domain name is specified in the RunAs key.
// We use . instead  of the local machine name because the local machine name
// does not work if we are on a Domain Controller, . works in all cases.

static WCHAR gpwszLocalMachineDomain[] = L".";


#define DELETE_PROCESS_STRING(p)                    \
    if (((p) != NULL) && ((p) != g_wszEmptyString)) \
    {                                               \
        delete [] (p);                                 \
    }


/*
 *  class CComProcessInfo
 */

CComProcessInfo::CComProcessInfo
(
    IUserToken *pUserToken,
    REFGUID rclsid,
    WCHAR *pwszAppidString,
    HKEY hKey
)
{
    HRESULT hr;
    LONG res;
    DWORD cbValue;
    DWORD cbService;
    DWORD cbParameters;
    DWORD cchValue;
    DWORD dwValueType;
    DWORD cchComputerName;
    WCHAR *pwch;
    WCHAR wszValue[256];
    WCHAR wszService[256];
    WCHAR wszParameters[256];
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    HKEY hKeyOle;
    DWORD dwValue;
    DWORD dwCapabilities=0;

    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_guidProcessId = rclsid;
    m_pwszProcessName = NULL;
    m_pwszServiceName = NULL;
    m_pwszServiceParameters = NULL;
    m_pwszRunAsUser = NULL;
    m_pwszSurrogatePath = NULL;
    m_pLaunchPermission = NULL;
    m_pAccessPermission = NULL;

    m_pDefaultLaunchPermission = NULL;
    m_pDefaultAccessPermission = NULL;

    m_pwszRemoteServerName = NULL;
    m_dwFlags = 0;

    m_dwSaferTrustLevel = 0xFFFFFFFF;

	CatalogDebugOut((DEB_PROCESSINFO, 
					 "CComProcessInfo Constructor: ProcID={%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n", 
                     (DWORD)rclsid.Data1,
                     (DWORD)rclsid.Data2,
                     (DWORD)rclsid.Data3,
                     (DWORD)rclsid.Data4[0],
                     (DWORD)rclsid.Data4[1],
                     (DWORD)rclsid.Data4[2],
                     (DWORD)rclsid.Data4[3],
                     (DWORD)rclsid.Data4[4],
                     (DWORD)rclsid.Data4[5],
                     (DWORD)rclsid.Data4[6],
                     (DWORD)rclsid.Data4[7]));
    CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: This=%p Token=%p Hkey=%p\n", this, pUserToken, hKey));

    /* get m_pwszProcessName from default value */

    GetRegistryStringValue(hKey, NULL, NULL, RQ_ALLOWQUOTEQUOTE, &m_pwszProcessName);

    /* check for local service */

    hr = GetRegistryStringValue(hKey, NULL, g_wszLocalService, RQ_ALLOWQUOTEQUOTE, &m_pwszServiceName);
    if ( SUCCEEDED(hr) && m_pwszServiceName && *m_pwszServiceName )
    {
        CatalogDebugOut((DEB_PROCESSINFO, "CComProcessInfo Constructor: Found local service! (%ws)\n", m_pwszServiceName));
        m_eProcessType = ProcessTypeService;

        GetRegistryStringValue(hKey, NULL, g_wszServiceParameters, RQ_ALLOWQUOTEQUOTE, &m_pwszServiceParameters);
    }
    else
    {
        if ( m_pwszServiceName )
        {
            DELETE_PROCESS_STRING(m_pwszServiceName);
            m_pwszServiceName=NULL;
        }
        
        /* check for DLL surrogate */        
        hr = GetRegistryStringValue(hKey, NULL, g_wszDllSurrogate, 0, &m_p