tificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) ,
	m_Object ( a_Object ) 
{
	m_Object->AddRef () ;
}

PutInstanceEventObject :: ~PutInstanceEventObject () 
{
// Get Status object

	delete [] m_Class ;

	m_Object->Release () ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void PutInstanceEventObject :: ProcessComplete () 
{
}

void PutInstanceEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = PutInstance ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

PutInstanceAsyncEventObject :: PutInstanceAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : PutInstanceEventObject ( a_Provider , a_Object , a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

PutInstanceAsyncEventObject :: ~PutInstanceAsyncEventObject () 
{
}

void PutInstanceAsyncEventObject :: ProcessComplete () 
{
	PutInstanceEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\tree.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <typeinfo.h>
#include "tree.h"

WmiTreeNode *WmiTreeNode :: Copy () 
{
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\classfac.h ===
// (C) 1999 Microsoft Corporation 

#ifndef _PropProvClassFactory_H
#define _PropProvClassFactory_H

class CFrameworkProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;


    CFrameworkProviderClassFactory () ;
    ~CFrameworkProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#endif // _PropProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framupcl.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL PutClassEventObject :: PutClass ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = FALSE ;

	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

PutClassEventObject :: PutClassEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) ,
	m_Object ( a_Object ) 
{
	m_Object->AddRef () ;
}

PutClassEventObject :: ~PutClassEventObject () 
{
// Get Status object

	delete [] m_Class ;

	m_Object->Release () ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void PutClassEventObject :: ProcessComplete () 
{
}

void PutClassEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = PutClass ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

PutClassAsyncEventObject :: PutClassAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : PutClassEventObject ( a_Provider , a_Object, a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

PutClassAsyncEventObject :: ~PutClassAsyncEventObject () 
{
}

void PutClassAsyncEventObject :: ProcessComplete () 
{
	PutClassEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <tchar.h>
#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <process.h>
#include <objbase.h>
#include <olectl.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include "classfac.h"
#include "framcomm.h"
#include "framprov.h"
#include "guids.h"

//OK we need this one
HINSTANCE g_hInst=NULL;

CRITICAL_SECTION s_CriticalSection ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection ( & s_CriticalSection ) ;

		status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		InitializeCriticalSection ( & s_CriticalSection ) ;
		DisableThreadLibraryCalls(g_hInst);			// 158024 

		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }

    return TRUE ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_CFrameworkProviderClassFactory ) 
	{
		CFrameworkProviderClassFactory *lpunk = new CFrameworkProviderClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	EnterCriticalSection ( & s_CriticalSection ) ;

	BOOL unload = ( 
					CFrameworkProviderClassFactory :: s_LocksInProgress || 
					CFrameworkProviderClassFactory :: s_ObjectsInProgress
				) ;
	unload = ! unload ;

	if ( unload )
	{
		if ( CImpFrameworkProv :: s_DefaultThreadObject )
		{
			delete CImpFrameworkProv  :: s_DefaultThreadObject ;
			CImpFrameworkProv :: s_DefaultThreadObject = NULL ;

			ProvThreadObject :: Closedown () ;
			ProvDebugLog :: Closedown () ;
		}
	}

	LeaveCriticalSection ( & s_CriticalSection ) ;
	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}


//Strings used during self registeration

#define REG_FORMAT_STR			__TEXT("%s\\%s")
#define NOT_INSERT_STR			__TEXT("NotInsertable")
#define INPROC32_STR			__TEXT("InprocServer32")
#define LOCALSERVER32_STR		__TEXT("LocalServer32")
#define PROGID_STR				__TEXT("ProgID")
#define THREADING_MODULE_STR	__TEXT("ThreadingModel")
#define APARTMENT_STR			__TEXT("Both")
#define CLSID_STR				__TEXT("CLSID\\")
#define APPID_STR				__TEXT("AppID\\")

#define PROVIDER_NAME_STR		__TEXT("Microsoft WBEM Provider")

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(TCHAR* pszKey, TCHAR* pszSubkey, TCHAR* pszValueName, TCHAR* pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

	_tcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_CLASSES_ROOT
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue, 
			(lstrlen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI RegisterServer( GUID a_ProviderClassId , TCHAR *a_ProviderName )
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst,(TCHAR*)szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szProviderClassID[128];
#ifdef UNICODE
	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);
#else
	WCHAR wszProviderClassID[128];
	int iRet = StringFromGUID2(a_ProviderClassId, wszProviderClassID, 128);
	WideCharToMultiByte(CP_ACP, 0, wszProviderClassID, -1, szProviderClassID, 128, NULL, NULL);

#endif


#ifdef LOCALSERVER
	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;
#endif

	TCHAR szProviderCLSIDClassID[128];
	_tcscpy(szProviderCLSIDClassID,CLSID_STR);
	_tcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

#ifdef LOCALSERVER

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;
#else
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

#endif



	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	TCHAR szTemp[128];

	TCHAR szProviderClassID[128];

#ifdef UNICODE
	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);
#else
	WCHAR wszProviderClassID[128];
	int iRet = StringFromGUID2(a_ProviderClassId, wszProviderClassID, 128);
	WideCharToMultiByte(CP_ACP, 0, wszProviderClassID, -1, szProviderClassID, 128, NULL, NULL);

#endif

	LONG t_Status = 0 ;

	TCHAR szProviderCLSIDClassID[128];
	_tcscpy(szProviderCLSIDClassID,CLSID_STR);
	_tcscat(szProviderCLSIDClassID,szProviderClassID);

#ifdef LOCALSERVER

	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	//Delete entries under APPID

	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#endif

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);


    return S_OK;
}

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_CFrameworkProviderClassFactory , PROVIDER_NAME_STR ) ;

	return t_Result ;
}

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_CFrameworkProviderClassFactory ) ;


	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\main.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define _WIN32_WINNT 0x0400
#include <windows.h>
#include <provstd.h>
#include <provmt.h>
#include <provtempl.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <instpath.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <guids.h>
#include <classfac.h>

DWORD g_Register = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"TemplateCode" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
	//ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;
	}
}

HRESULT UninitComServer ()
{
	CoRevokeClassObject ( g_Register );
	CoUninitialize () ;

	return S_OK ;
}

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_NONE, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	IUnknown *t_ClassFactory = new CFrameworkProviderClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	t_Result = CoRegisterClassObject (

		CLSID_CFrameworkProviderClassFactory, 
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_Register
	);

	if ( FAILED ( t_Result ) )
	{
		CoRevokeClassObject ( g_Register );
		CoUninitialize () ;
	}

	return t_Result  ;
}

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_ImpersonationLevel , t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WindowsDispatch () ;
		UninitComServer () ;
	}

	return t_Result ;
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	BOOL t_Exit = ParseCommandLine () ;
	if ( ! t_Exit ) 
	{
		HWND hWnd = WindowsStart ( hInstance ) ;

		ProvDebugLog :: Startup ();
		ProvThreadObject :: Startup () ;

		HRESULT t_Result = Process () ;

		ProvDebugLog :: Closedown () ;
		ProvThreadObject :: Closedown () ;

		WindowsStop ( hWnd ) ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\dnf.h ===
// (C) 1999 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

class WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

class WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;

} ;

class WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;

} ;

class WmiRangeNode ;

class WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiRangeNode *GetRange () = 0 ;
} ;

class WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () { return NULL ; }

	void Print () ;

} ;

class WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;

} ;

class WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = SQL_LEVEL_1_TOKEN :: IFUNC_NONE ,
		Function_Upper = SQL_LEVEL_1_TOKEN :: IFUNC_UPPER ,
		Function_Lower = SQL_LEVEL_1_TOKEN :: IFUNC_LOWER
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;

			if ( m_PropertyName == NULL )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

class WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
			return FALSE ;
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
			return FALSE ;
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;

} ;

class WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
			return FALSE ;
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
			return FALSE ;
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;

} ;

class WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = tolower ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = toupper ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else
			{
				m_String = SysAllocString ( a_String ) ;
			}

			if ( m_String == NULL )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
			m_String = NULL ;
	}

	~WmiStringNode ()
	{
		if ( m_String )
			SysFreeString ( m_String ) ;
	} ;

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( BSTR &a_String )
	{
		if ( wcscmp ( L"" , m_String ) == 0 )
			return FALSE ;
		else
		{
			ULONG t_StringLen = wcslen ( m_String ) ;
			wchar_t *t_String = NULL ;

			if ( m_String [ t_StringLen - 1 ] == 0x01 )
			{
				t_String = new wchar_t [ t_StringLen ] ;
				wcsncpy ( t_String , m_String , t_StringLen - 1 ) ;
				t_String [ t_StringLen ] = 0 ;
			}
			else
			{
				t_String = new wchar_t [ t_StringLen + 1 ] ;
				wcscpy ( t_String , m_String ) ;
				t_String [ t_StringLen - 1 ] = t_String [ t_StringLen - 1 ] - 1 ;
			}			
			
			a_String = SysAllocString ( t_String ) ;
			delete [] t_String ;

			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( BSTR &a_String )
	{
		ULONG t_StringLen = wcslen ( m_String ) ;
		wchar_t *t_String = new wchar_t [ t_StringLen + 2 ] ;
		wcscpy ( t_String , m_String ) ;
		t_String [ t_StringLen ] = 0x01 ;
		t_String [ t_StringLen ] = 0x00 ;

		a_String = SysAllocString ( t_String ) ;

		delete [] t_String ;

		return TRUE ;
	}

	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;

} ;

class WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;

} ;

class WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	WmiRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		else
			m_PropertyName = NULL ;
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }

} ;

class WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	WmiTreeNode *Copy () ;
	
	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;

	BOOL GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetNonIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Before ,
		WmiUnsignedIntegerRangeNode *&a_Intersection ,
		WmiUnsignedIntegerRangeNode *&a_After 
	) ;

} ;

class WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	WmiTreeNode *Copy () ;
	
	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;

	BOOL GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	BOOL GetNonIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Before ,
		WmiSignedIntegerRangeNode *&a_Intersection ,
		WmiSignedIntegerRangeNode *&a_After 
	) ;
} ;

class WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
			m_LowerBound = SysAllocString ( a_LowerBound ) ;
		else
			m_LowerBound = NULL ;

		if ( a_UpperBound )
			m_UpperBound = SysAllocString ( a_UpperBound ) ;
		else
			m_UpperBound = NULL ;
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
			SysFreeString ( m_LowerBound ) ;

		if ( m_UpperBound )
			SysFreeString ( m_UpperBound ) ;
	} ;

	WmiTreeNode *Copy () ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;

	BOOL GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	BOOL GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	BOOL GetNonIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Before ,
		WmiStringRangeNode *&a_Intersection ,
		WmiStringRangeNode *&a_After 
	) ;
} ;

class WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;

} ;

class Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount )
	{
		m_RangeContainer = new WmiRangeNode * [ a_RangeContainerCount ] ;
		for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
		{
			m_RangeContainer [ t_Index ] = NULL ;
		}
	}

	~Conjunctions () 
	{
		for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
		{
			delete m_RangeContainer [ t_Index ] ;
		}

		delete [] m_RangeContainer ;
	} ;	

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
			return NULL ;
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
				delete m_RangeContainer [ a_Index ] ;

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

class Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount )
	{
		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
		{
			Conjunctions *t_Disjunction = new Conjunctions ( a_ConjunctionCount ) ;
			m_Disjunction [ t_Index ] = t_Disjunction ;
		}
	}

	~Disjunctions () 
	{
		for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
		{
			Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
			delete t_Disjunction ;
		}
		
		delete [] m_Disjunction ;
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
			return NULL ;
	}
} ;

class PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;
		for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
		{
			delete m_NonOverlappingPartitions [ t_Index ] ;
		}

		delete [] m_NonOverlappingPartitions ;
	}

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }


	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	void CreatePartitions ( ULONG a_Count ) 
	{
		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
		{
			m_NonOverlappingPartitions [ t_Index ] = NULL ;
		}
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
	}

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
			return m_NonOverlappingPartitions [ a_Index ] ;
		else
			return NULL ;
	}

} ;

class QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	BOOL EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	BOOL EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	BOOL EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	BOOL RecursiveEvaluate ( 

		SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node , 
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	BOOL RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	QuadState RecursiveRemoveInvariants ( WmiTreeNode *&a_Root ) ;

	BOOL RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	BOOL InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	BOOL RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	BOOL SortConditionals ( WmiTreeNode *&a_Root ) ;
	BOOL RecursiveSort ( WmiTreeNode *&a_Root ) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	BOOL RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;
	void CreateDisjunctions ( 

		WmiTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	BOOL RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) = 0 ;

	virtual QuadState InvariantEvaluate ( 

		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		BSTR a_PropertyName 

	) = 0 ;

	virtual void GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container ) = 0 ;

protected:

	BOOL Evaluate ( SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , WmiTreeNode **a_Root ) ;
	void DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;
	QuadState RemoveInvariants ( WmiTreeNode *&a_Root ) ;
	BOOL Sort ( WmiTreeNode *&a_Root ) ;
	BOOL ConvertToRanges ( WmiTreeNode *&a_Root ) ;
	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;
	BOOL CreateDisjunctionContainer ( WmiTreeNode *a_Root , Disjunctions *&a_Disjunctions ) ;
	BOOL CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition ) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QuadState Preprocess ( SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , PartitionSet *&a_Partition ) ;
	virtual ~QueryPreprocessor() {}
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\fram.h ===
// (C) 1999 Microsoft Corporation 

#define WBEM_CLASS_EXTENDEDSTATUS	L"__ExtendedStatus" 

#define WBEM_TASKSTATE_START					0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT		0x100001

class WbemTaskObject : public ProvTaskObject
{
private:

	LONG m_ReferenceCount ;

protected:

	ULONG m_State ;
	WbemProviderErrorObject m_ErrorObject ;

	ULONG m_RequestHandle ;
	ULONG m_OperationFlag ;
	IWbemClassObject *m_ClassObject ;
	IWbemObjectSink *m_NotificationHandler ;
	IWbemContext *m_Ctx ;
	CImpFrameworkProv *m_Provider ;

protected:

	void SetRequestHandle ( ULONG a_RequestHandle ) ;
	BOOL GetRequestHandle () ;
	BOOL GetClassObject ( wchar_t *a_Class ) ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;

protected:

	virtual void ProcessComplete () = 0 ;

public:

	WbemTaskObject ( 

		CImpFrameworkProv *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag ,
		IWbemContext *a_Ctx
	) ;

	~WbemTaskObject () ;

	WbemProviderErrorObject &GetErrorObject () ;

    ULONG AddRef () ;
    ULONG Release () ;

} ;

class GetObjectEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

	void ProcessComplete () ;
	BOOL GetObject ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	GetObjectEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~GetObjectEventObject () ;

	void Process () ;
} ;

class GetObjectAsyncEventObject : public GetObjectEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	GetObjectAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~GetObjectAsyncEventObject () ;
} ;

class CreateInstanceEnumEventObject : public WbemTaskObject
{
private:

	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL CreateInstanceEnum ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	CreateInstanceEnumEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateInstanceEnumEventObject () ;

	void Process () ;
} ;

class CreateInstanceEnumAsyncEventObject : public CreateInstanceEnumEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	CreateInstanceEnumAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateInstanceEnumAsyncEventObject () ;
} ;

class ExecQueryEventObject : public WbemTaskObject
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	CTextLexSource m_QuerySource ;
	SQL1_Parser m_SqlParser ;
	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

protected:

	void ProcessComplete () ;
	BOOL ExecQuery ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	ExecQueryEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~ExecQueryEventObject () ;

	void Process () ;
} ;

class ExecQueryAsyncEventObject : public ExecQueryEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	ExecQueryAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~ExecQueryAsyncEventObject () ;
} ;

class PutInstanceEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_Object ;
	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL PutInstance ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	PutInstanceEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutInstanceEventObject () ;

	void Process () ;
} ;

class PutInstanceAsyncEventObject : public PutInstanceEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	PutInstanceAsyncEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutInstanceAsyncEventObject () ;
} ;

class PutClassEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_Object ;
	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL PutClass ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	PutClassEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutClassEventObject () ;

	void Process () ;
} ;

class PutClassAsyncEventObject : public PutClassEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	PutClassAsyncEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutClassAsyncEventObject () ;
} ;

class CreateClassEnumEventObject : public WbemTaskObject
{
private:

	wchar_t *m_SuperClass ;

protected:

	void ProcessComplete () ;
	BOOL CreateClassEnum ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	CreateClassEnumEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_SuperClass , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateClassEnumEventObject () ;

	void Process () ;
} ;

class CreateClassEnumAsyncEventObject : public CreateClassEnumEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	CreateClassEnumAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_SuperClass , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateClassEnumAsyncEventObject () ;
} ;

class DeleteInstanceEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

	void ProcessComplete () ;
	BOOL DeleteInstance ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	DeleteInstanceEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceEventObject () ;

	void Process () ;
} ;

class DeleteInstanceAsyncEventObject : public DeleteInstanceEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	DeleteInstanceAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceAsyncEventObject () ;
} ;

class DeleteClassEventObject : public WbemTaskObject
{
private:

	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL DeleteClass ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	DeleteClassEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~DeleteClassEventObject () ;

	void Process () ;
} ;

class DeleteClassAsyncEventObject : public DeleteClassEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	DeleteClassAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~DeleteClassAsyncEventObject () ;
} ;

class ExecMethodEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ; 
	wchar_t *m_MethodName ;

	IWbemClassObject *m_InParameters ;

	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	

protected:

	void ProcessComplete () ;
	BOOL ExecMethod ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	ExecMethodEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_ObjectPath,
		BSTR a_MethodName,
		ULONG a_OperationFlag,
		IWbemContext FAR *a_Ctx,
		IWbemClassObject FAR *a_InParameters,
		IWbemObjectSink FAR *a_NotificationHandler
	) ;

	~ExecMethodEventObject () ;

	void Process () ;
} ;

class ExecMethodAsyncEventObject : public ExecMethodEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	ExecMethodAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_ObjectPath,
		BSTR a_MethodName,
		ULONG a_OperationFlag,
		IWbemContext FAR *a_Ctx,
		IWbemClassObject FAR *a_InParameters,
		IWbemObjectSink FAR *a_NotificationHandler
	) ;

	~ExecMethodAsyncEventObject () ;
} ;

class EventAsyncEventObject : public WbemTaskObject
{
private:
protected:
protected:

	void ProcessComplete () ;
	void Process () ;
	BOOL ProcessEvent ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	EventAsyncEventObject ( 

		CImpFrameworkProv *a_Provider ,
		IWbemObjectSink* pSink, 
		long lFlags
	) ;

	~EventAsyncEventObject () ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\framcomm.h ===
// (C) 1999 Microsoft Corporation 

#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_PROVIDERSTATUSCODE   L"ProviderStatusCode"
#define WBEM_PROPERTY_PROVIDERSTATUSMESSAGE   L"Description"
#define WBEM_QUERY_LANGUAGE_WQL			L"WQL"

typedef 
enum tag_WBEMPROVIDERSTATUS
{
	WBEM_PROVIDER_NO_ERROR							= 0,
	WBEM_PROVIDER_S_NO_ERROR							= 0,
	WBEM_PROVIDER_S_NO_MORE_DATA						= 0x40001,
	WBEM_PROVIDER_S_ALREADY_EXISTS					= WBEM_PROVIDER_S_NO_MORE_DATA + 1,
	WBEM_PROVIDER_S_NOT_FOUND						= WBEM_PROVIDER_S_ALREADY_EXISTS + 1,
	WBEM_PROVIDER_S_RESET_TO_DEFAULT					= WBEM_PROVIDER_S_NOT_FOUND + 1,
	WBEM_PROVIDER_E_FAILED							= 0x80041001,
	WBEM_PROVIDER_E_NOT_FOUND						= WBEM_PROVIDER_E_FAILED + 1,
	WBEM_PROVIDER_E_ACCESS_DENIED					= WBEM_PROVIDER_E_NOT_FOUND + 1,
	WBEM_PROVIDER_E_PROVIDER_FAILURE					= WBEM_PROVIDER_E_ACCESS_DENIED + 1,
	WBEM_PROVIDER_E_TYPE_MISMATCH					= WBEM_PROVIDER_E_PROVIDER_FAILURE + 1,
	WBEM_PROVIDER_E_OUT_OF_MEMORY					= WBEM_PROVIDER_E_TYPE_MISMATCH + 1,
	WBEM_PROVIDER_E_INVALID_CONTEXT					= WBEM_PROVIDER_E_OUT_OF_MEMORY + 1,
	WBEM_PROVIDER_E_INVALID_PARAMETER				= WBEM_PROVIDER_E_INVALID_CONTEXT + 1,
	WBEM_PROVIDER_E_NOT_AVAILABLE					= WBEM_PROVIDER_E_INVALID_PARAMETER + 1,
	WBEM_PROVIDER_E_CRITICAL_ERROR					= WBEM_PROVIDER_E_NOT_AVAILABLE + 1,
	WBEM_PROVIDER_E_INVALID_STREAM					= WBEM_PROVIDER_E_CRITICAL_ERROR + 1,
	WBEM_PROVIDER_E_NOT_SUPPORTED					= WBEM_PROVIDER_E_INVALID_STREAM + 1,
	WBEM_PROVIDER_E_INVALID_SUPERCLASS				= WBEM_PROVIDER_E_NOT_SUPPORTED + 1,
	WBEM_PROVIDER_E_INVALID_NAMESPACE				= WBEM_PROVIDER_E_INVALID_SUPERCLASS + 1,
	WBEM_PROVIDER_E_INVALID_OBJECT					= WBEM_PROVIDER_E_INVALID_NAMESPACE + 1,
	WBEM_PROVIDER_E_INVALID_CLASS					= WBEM_PROVIDER_E_INVALID_OBJECT + 1,
	WBEM_PROVIDER_E_PROVIDER_NOT_FOUND				= WBEM_PROVIDER_E_INVALID_CLASS + 1,
	WBEM_PROVIDER_E_INVALID_PROVIDER_REGISTRATION	= WBEM_PROVIDER_E_PROVIDER_NOT_FOUND + 1,
	WBEM_PROVIDER_E_PROVIDER_LOAD_FAILURE			= WBEM_PROVIDER_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_PROVIDER_E_INITIALIZATION_FAILURE			= WBEM_PROVIDER_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_PROVIDER_E_TRANSPORT_FAILURE				= WBEM_PROVIDER_E_INITIALIZATION_FAILURE + 1,
	WBEM_PROVIDER_E_INVALID_OPERATION				= WBEM_PROVIDER_E_TRANSPORT_FAILURE + 1,
	WBEM_PROVIDER_E_INVALID_QUERY					= WBEM_PROVIDER_E_INVALID_OPERATION + 1,
	WBEM_PROVIDER_E_INVALID_QUERY_TYPE				= WBEM_PROVIDER_E_INVALID_QUERY + 1,
	WBEM_PROVIDER_E_ALREADY_EXISTS					= WBEM_PROVIDER_E_INVALID_QUERY_TYPE + 1,
	WBEM_PROVIDER_E_OVERRIDE_NOT_ALLOWED				= WBEM_PROVIDER_E_ALREADY_EXISTS + 1,
	WBEM_PROVIDER_E_PROPAGATED_QUALIFIER				= WBEM_PROVIDER_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_PROVIDER_E_UNEXPECTED						= WBEM_PROVIDER_E_PROPAGATED_QUALIFIER + 1,
	WBEM_PROVIDER_E_ILLEGAL_OPERATION				= WBEM_PROVIDER_E_UNEXPECTED + 1,
	WBEM_PROVIDER_E_CANNOT_BE_KEY					= WBEM_PROVIDER_E_ILLEGAL_OPERATION + 1,
	WBEM_PROVIDER_E_INCOMPLETE_CLASS					= WBEM_PROVIDER_E_CANNOT_BE_KEY + 1,
	WBEM_PROVIDER_E_INVALID_SYNTAX					= WBEM_PROVIDER_E_INCOMPLETE_CLASS + 1,
	WBEM_PROVIDER_E_NONDECORATED_OBJECT				= WBEM_PROVIDER_E_INVALID_SYNTAX + 1,
	WBEM_PROVIDER_E_READ_ONLY						= WBEM_PROVIDER_E_NONDECORATED_OBJECT + 1,
	WBEM_PROVIDER_E_PROVIDER_NOT_CAPABLE				= WBEM_PROVIDER_E_READ_ONLY + 1,
	WBEM_PROVIDER_E_CLASS_HAS_CHILDREN				= WBEM_PROVIDER_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_PROVIDER_E_CLASS_HAS_INSTANCES				= WBEM_PROVIDER_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_PROVIDER_E_INVALID_PROPERTY					= WBEM_PROVIDER_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_PROVIDER_E_INVALID_QUALIFIER				= WBEM_PROVIDER_E_INVALID_PROPERTY + 1 ,
	WBEM_PROVIDER_E_INVALID_PATH						= WBEM_PROVIDER_E_INVALID_QUALIFIER + 1 ,
	WBEM_PROVIDER_E_INVALID_PATHKEYPARAMETER			= WBEM_PROVIDER_E_INVALID_PATH + 1 ,
	WBEM_PROVIDER_E_MISSINGPATHKEYPARAMETER 			= WBEM_PROVIDER_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_PROVIDER_E_INVALID_KEYORDERING				= WBEM_PROVIDER_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_PROVIDER_E_DUPLICATEPATHKEYPARAMETER		= WBEM_PROVIDER_E_INVALID_KEYORDERING + 1 ,
	WBEM_PROVIDER_E_MISSINGKEY						= WBEM_PROVIDER_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_PROVIDER_E_INVALID_TRANSPORT				= WBEM_PROVIDER_E_MISSINGKEY + 1 ,
	WBEM_PROVIDER_E_INVALID_TRANSPORTCONTEXT			= WBEM_PROVIDER_E_INVALID_TRANSPORT + 1 ,
	WBEM_PROVIDER_E_TRANSPORT_ERROR					= WBEM_PROVIDER_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_PROVIDER_E_TRANSPORT_NO_RESPONSE			= WBEM_PROVIDER_E_TRANSPORT_ERROR + 1 ,
	WBEM_PROVIDER_E_NOWRITABLEPROPERTIES				= WBEM_PROVIDER_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_PROVIDER_E_NOREADABLEPROPERTIES				= WBEM_PROVIDER_E_NOWRITABLEPROPERTIES + 1 

} WBEMPROVIDERSTATUS;

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef PROVIDERINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString ) ;
DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString ) ;
DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;
DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;

class DllImportExport CBString
{
private:

    BSTR    m_pString;

public:

    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) 
		{
            SysFreeString(m_pString);
        }
        
		m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#if _MSC_VER >= 1100
template <> DllImportExport UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
DllImportExport UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * HmmHack_wchar_t ;
template<> DllImportExport BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const HmmHack_wchar_t *pElement1, const HmmHack_wchar_t *pElement2 ) ;
#else
DllImportExport BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

union ProviderLexiconValue
{
	LONG signedInteger ;
	ULONG unsignedInteger ;
	wchar_t *token ;
} ;

class ProviderAnalyser;
class DllImportExport ProviderLexicon
{
friend ProviderAnalyser ;
public:

enum LexiconToken {

	TOKEN_ID ,
	SIGNED_INTEGER_ID ,
	UNSIGNED_INTEGER_ID ,
	COLON_ID ,
	COMMA_ID ,
	OPEN_PAREN_ID ,
	CLOSE_PAREN_ID ,
	DOT_ID ,
	DOTDOT_ID ,
	PLUS_ID ,
	MINUS_ID ,
	EOF_ID,
	WHITESPACE_ID,
	INVALID_ID,
	USERDEFINED_ID
} ;

private:

	wchar_t *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	ProviderLexiconValue value ;

protected:
public:

	ProviderLexicon () ;
	~ProviderLexicon () ;

	void SetToken ( ProviderLexicon :: LexiconToken a_Token ) ;
	ProviderLexicon :: LexiconToken GetToken () ;
	ProviderLexiconValue *GetValue () ;
} ;

#define ANALYSER_ACCEPT_STATE 10000
#define ANALYSER_REJECT_STATE 10001

/* 
	User defined states should be greater than 20000
 */

class DllImportExport ProviderAnalyser
{
private:

	wchar_t *stream ;
	ULONG position ;
	BOOL status ;

	ProviderLexicon *GetToken (  BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

protected:

	virtual void Initialise () {} ;

	virtual ProviderLexicon *CreateLexicon () { return new ProviderLexicon ; }

	virtual BOOL Analyse ( 

		ProviderLexicon *lexicon , 
		ULONG &state , 
		const wchar_t token , 
		const wchar_t *tokenStream , 
		ULONG &position , 
		BOOL unSignedIntegersOnly , 
		BOOL leadingIntegerZeros , 
		BOOL eatSpace 
	) 
	{ return FALSE ; }

public:

	ProviderAnalyser ( const wchar_t *tokenStream = NULL ) ;
	virtual ~ProviderAnalyser () ;

	void Set ( const wchar_t *tokenStream ) ;

	ProviderLexicon *Get ( BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

	void PutBack ( const ProviderLexicon *token ) ;

	virtual operator void * () ;

	static BOOL IsEof ( wchar_t token ) ;
	static BOOL IsLeadingDecimal ( wchar_t token ) ;
	static BOOL IsDecimal ( wchar_t token ) ;
	static BOOL IsOctal ( wchar_t token ) ;
	static BOOL IsHex ( wchar_t token ) ;	
	static BOOL IsAlpha ( wchar_t token ) ;
	static BOOL IsAlphaNumeric ( wchar_t token ) ;
	static BOOL IsWhitespace ( wchar_t token ) ;

	static ULONG OctWCharToDecInteger ( wchar_t token ) ;
	static ULONG HexWCharToDecInteger ( wchar_t token ) ;
	static ULONG DecWCharToDecInteger ( wchar_t token ) ;
	static wchar_t DecIntegerToHexWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToDecWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToOctWChar ( UCHAR integer ) ;

	static ULONG OctCharToDecInteger ( char token ) ;
	static ULONG HexCharToDecInteger ( char token ) ;
	static ULONG DecCharToDecInteger ( char token ) ;
	static char DecIntegerToHexChar ( UCHAR integer ) ;
	static char DecIntegerToDecChar ( UCHAR integer ) ;
	static char DecIntegerToOctChar ( UCHAR integer ) ;

} ;

class __declspec ( dllexport ) WbemProviderErrorObject 
{
private:

	WCHAR *m_ProviderErrorMessage ;
	WBEMPROVIDERSTATUS m_ProviderErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemProviderErrorObject () : m_ProviderErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_ProviderErrorStatus ( WBEM_PROVIDER_NO_ERROR ) {} ;
	virtual ~WbemProviderErrorObject () { delete [] m_ProviderErrorMessage ; } ;

	void SetStatus ( WBEMPROVIDERSTATUS a_ProviderErrorStatus )
	{
		m_ProviderErrorStatus = a_ProviderErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_ProviderErrorMessage )
	{
#ifdef UNICODE

		DebugMacro1 ( 

			if ( a_ProviderErrorMessage )
			{
				ProvDebugLog :: s_ProvDebugLog->Write ( 

					_TEXT("\r\nWbemProviderErrorObject :: SetMessage ( (%s) )") , a_ProviderErrorMessage 
				) ; 
			}
		)
#else
		DebugMacro1 ( 

			if ( a_ProviderErrorMessage )
			{
				ProvDebugLog :: s_ProvDebugLog->Write ( 

					_TEXT("\r\nWbemProviderErrorObject :: SetMessage ( (%S) )") , a_ProviderErrorMessage 
				) ; 
			}
		)
#endif
		delete [] m_ProviderErrorMessage ;
		m_ProviderErrorMessage = UnicodeStringDuplicate ( a_ProviderErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_ProviderErrorMessage ; } ;
	WBEMPROVIDERSTATUS GetStatus () { return m_ProviderErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\framprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _PropertyProvider_H_
#define _PropertyProvider_H_

extern CRITICAL_SECTION s_CriticalSection ;

class DefaultThreadObject : public ProvThreadObject
{
private:
protected:
public:

	DefaultThreadObject ( const TCHAR *a_ThreadName = NULL ) : ProvThreadObject ( a_ThreadName ) {} ;
	~DefaultThreadObject () {} ;

	void Initialise () { CoInitialize ( NULL ) ; }
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpFrameworkProv : public IWbemServices , public IWbemEventProvider , public IWbemHiPerfProvider , public IWbemProviderInit
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_CriticalSection ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;

	wchar_t *m_localeId ;

	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

protected:
public:

	CImpFrameworkProv () ;
    ~CImpFrameworkProv () ;

	static DefaultThreadObject *s_DefaultThreadObject ;

	// Implementation

	IWbemServices *GetServer () ;
	void SetServer ( IWbemServices *a_Server ) ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateNotificationObject ( 

		WbemProviderErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL CreateExtendedNotificationObject ( 

		WbemProviderErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) ;
	IWbemClassObject *GetExtendedNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

    HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ const BSTR MethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ const BSTR MethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	STDMETHODIMP ProvideForNamespace (

		wchar_t *wszNamespaceName ,
		IWbemServices *pNamespace ,
		IWbemObjectSink *pSink, 
		wchar_t *wszLocale, 
		long lFlags
	) ;

    STDMETHODIMP ProvideEvents (

		IWbemObjectSink *pSink,
        LONG lFlags
    ) ;

    // IWbemHiPerfProvider methods.
    // ============================

    HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *pNamespace ,
        WCHAR *wszClass ,
        long lFlags ,
        IWbemContext *pCtx , 
        IWbemObjectSink* pSink
    ) ;

    HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *pNamespace ,
        long lFlags ,
        IWbemRefresher **ppRefresher
	) ;

    HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *pNamespace,
        IWbemObjectAccess *pTemplate,
        IWbemRefresher *pRefresher,
        long lFlags,
        IWbemContext *pContext,
        IWbemObjectAccess **ppRefreshable,
        long *plId
	) ;

    HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *pRefresher,
        long lId,
        long lFlags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

        IWbemServices *pNamespace,
        LPCWSTR wszClass,
        IWbemRefresher *pRefresher,
        long lFlags,
        IWbemContext *pContext,
        IWbemHiPerfEnum *pHiPerfEnum,
        long *plId
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

        IWbemServices *pNamespace,
		long lNumObjects,
		IWbemObjectAccess **apObj,
        long lFlags,
        IWbemContext *pContext
	) ;
            
/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (
		/* [in] */ LPWSTR pszUser,
		/* [in] */ LONG lFlags,
		/* [in] */ LPWSTR pszNamespace,
		/* [in] */ LPWSTR pszLocale,
		/* [in] */ IWbemServices *pCIMOM,         // For anybody
		/* [in] */ IWbemContext *pCtx,
		/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
	);
} ;

class CImpRefresher : public IWbemRefresher
{
private:

    LONG m_referenceCount;

public:

    CImpRefresher();
   ~CImpRefresher();

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);
};

class CImpHiPerfEnum : public IWbemHiPerfEnum 
{
private:

	LONG m_ReferenceCount ;         //Object reference count

public:

	CImpHiPerfEnum () ;

	~CImpHiPerfEnum () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE AddObjects (

		long lFlags ,
		ULONG uNumObjects ,
		long __RPC_FAR *apIds ,
		IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj

	) ;
        
    HRESULT STDMETHODCALLTYPE RemoveObjects (

		long lFlags ,
        ULONG uNumObjects ,
        long __RPC_FAR *apIds
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjects (

        long lFlags ,
        ULONG uNumObjects ,
        IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj ,
        ULONG __RPC_FAR *puReturned
	) ;
    
    HRESULT STDMETHODCALLTYPE RemoveAll ( 

        long lFlags
	) ;
} ;
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\resource.h ===
// (C) 1999 Microsoft Corporation 
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\tree.h ===
// (C) 1999 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef WMIINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

class DllImportExport WmiTreeNode 
{
protected:

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;

public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
	}

	WmiTreeNode ( 

		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) 
	{
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Left->SetParent ( this ) ;
	}

	virtual ~WmiTreeNode () {}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class DllImportExport WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\include\guids.h ===
// (C) 1999 Microsoft Corporation 
// {E507506B-DC59-11d0-82D7-00A0C9038B34}
DEFINE_GUID(CLSID_CFrameworkProviderClassFactory, 
0xe507506b, 0xdc59, 0x11d0, 0x82, 0xd7, 0x0, 0xa0, 0xc9, 0x3, 0x8b, 0x34);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\mtcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

CSyncObject::CSyncObject(LPCTSTR pstrName)
{
    m_hObject = NULL;
}

CSyncObject::~CSyncObject()
{
    if (m_hObject != NULL)
    {
        ::CloseHandle(m_hObject);
        m_hObject = NULL;
    }
}

BOOL CSyncObject::Lock(DWORD dwTimeout)
{
    if (::WaitForSingleObject(m_hObject, dwTimeout) == WAIT_OBJECT_0)
        return TRUE;
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\list_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

/////////////////////////////////////////////////////////////////////////////

CObList::CObList(int nBlockSize)
{
    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

void CObList::RemoveAll()
{
    // destroy elements

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

CObList::~CObList()
{
    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CObList::CNode*
CObList::NewNode(CObList::CNode* pPrev, CObList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }

    CObList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;

    pNode->data = 0; // start with zero

    return pNode;
}

void CObList::FreeNode(CObList::CNode* pNode)
{
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CObList::AddHead(CObject* newElement)
{
    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::AddTail(CObject* newElement)
{
    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::AddHead(CObList* pNewList)
{
    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

void CObList::AddTail(CObList* pNewList)
{
    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

CObject* CObList::RemoveHead()
{
    CNode* pOldNode = m_pNodeHead;
    CObject* returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

CObject* CObList::RemoveTail()
{
    CNode* pOldNode = m_pNodeTail;
    CObject* returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

POSITION CObList::InsertBefore(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::InsertAfter(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::RemoveAt(POSITION position)
{
    CNode* pOldNode = (CNode*) position;

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CObList::FindIndex(int nIndex) const
{
    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        pNode = pNode->pNext;
    }
    return (POSITION) pNode;
}

POSITION CObList::Find(CObject* searchValue, POSITION startAfter) const
{
    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (pNode->data == searchValue)
            return (POSITION) pNode;
    return NULL;
}


int CObList::GetCount() const
    { return m_nCount; }
BOOL CObList::IsEmpty() const
    { return m_nCount == 0; }
CObject*& CObList::GetHead()
    { return m_pNodeHead->data; }
CObject* CObList::GetHead() const
    { return m_pNodeHead->data; }
CObject*& CObList::GetTail()
    { return m_pNodeTail->data; }
CObject* CObList::GetTail() const
    { return m_pNodeTail->data; }
POSITION CObList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
POSITION CObList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject*& CObList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
CObject* CObList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
void CObList::SetAt(POSITION pos, CObject* newElement)
    { CNode* pNode = (CNode*) pos;
        pNode->data = newElement; }


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=provmfc
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_EXPT_INC); \
	$(FRAMEWORK_MFC_INC)

SOURCES= \
	..\PLEX.cpp \
	..\MTCORE.cpp \
	..\MTEX.cpp \
	..\Array_o.cpp \
	..\List_o.cpp \
	..\strex.cpp \
	..\strexa.cpp \
	..\strexw.cpp \
	..\strcore.cpp \
	..\strcorea.cpp \
	..\strcorew.cpp

C_DEFINES=$(C_DEFINES) 
USE_MSVCRT=1
USE_NATIVE_EH=ASYNC
USE_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\mtex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

CSemaphore::CSemaphore(LONG lInitialCount, LONG lMaxCount,
    LPCTSTR pstrName, LPSECURITY_ATTRIBUTES lpsaAttributes)
    :  CSyncObject(pstrName)
{
    m_hObject = ::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount,
        pstrName);
}

CSemaphore::~CSemaphore()
{
}

BOOL CSemaphore::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    return ::ReleaseSemaphore(m_hObject, lCount, lpPrevCount);
}

/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex(BOOL bInitiallyOwn, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute /* = NULL */)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateMutex(lpsaAttribute, bInitiallyOwn, pstrName);
}

CMutex::~CMutex()
{
}

BOOL CMutex::Unlock()
{
    return ::ReleaseMutex(m_hObject);
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(BOOL bInitiallyOwn, BOOL bManualReset, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateEvent(lpsaAttribute, bManualReset,
        bInitiallyOwn, pstrName);
}

CEvent::~CEvent()
{
}

BOOL CEvent::Unlock()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock(CSyncObject* pObject, BOOL bInitialLock)
{
    m_pObject = pObject;
    m_hObject = pObject->m_hObject;
    m_bAcquired = FALSE;

    if (bInitialLock)
        Lock();
}

BOOL CSingleLock::Lock(DWORD dwTimeOut /* = INFINITE */)
{
    m_bAcquired = m_pObject->Lock(dwTimeOut);
    return m_bAcquired;
}

BOOL CSingleLock::Unlock()
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock();

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

BOOL CSingleLock::Unlock(LONG lCount, LPLONG lpPrevCount /* = NULL */)
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock(lCount, lpPrevCount);

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

#define _countof(array) (sizeof(array)/sizeof(array[0]))

CMultiLock::CMultiLock(CSyncObject* pObjects[], DWORD dwCount,
                       BOOL bInitialLock) : m_pHandleArray ( NULL ) , m_bLockedArray ( NULL )
{
    m_ppObjectArray = pObjects;
    m_dwCount = dwCount;

    // as an optimization, skip alloacating array if
    // we can use a small, predeallocated bunch of handles

    if (m_dwCount > _countof(m_hPreallocated))
    {
        m_pHandleArray = new HANDLE[m_dwCount];
        m_bLockedArray = new BOOL[m_dwCount];
    }
    else
    {
        m_pHandleArray = m_hPreallocated;
        m_bLockedArray = m_bPreallocated;
    }

    // get list of handles from array of objects passed
    for (DWORD i = 0; i <m_dwCount; i++)
    {
        m_pHandleArray[i] = pObjects[i]->m_hObject;
        m_bLockedArray[i] = FALSE;
    }

    if (bInitialLock)
        Lock();
}

CMultiLock::~CMultiLock()
{
    Unlock();
    if (m_pHandleArray != m_hPreallocated)
    {
        delete[] m_bLockedArray;
        delete[] m_pHandleArray;
    }
}

DWORD CMultiLock::Lock(DWORD dwTimeOut /* = INFINITE */,
        BOOL bWaitForAll /* = TRUE */, DWORD dwWakeMask /* = 0 */)
{
    DWORD dwResult;
    if (dwWakeMask == 0)
        dwResult = ::WaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut);
    else
        dwResult = ::MsgWaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut, dwWakeMask);

    if (dwResult < (WAIT_OBJECT_0 + m_dwCount))
    {
        if (bWaitForAll)
        {
            for (DWORD i = 0; i < m_dwCount; i++)
                m_bLockedArray[i] = TRUE;
        }
        else
        {
            m_bLockedArray[dwResult - WAIT_OBJECT_0] = TRUE;
        }
    }
    return dwResult;
}

BOOL CMultiLock::Unlock()
{
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
            m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock();
    }
    return TRUE;
}

BOOL CMultiLock::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    BOOL bGotOne = FALSE;
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
        {
            CSemaphore* pSemaphore = ( CSemaphore *) m_ppObjectArray[i];
            if (pSemaphore != NULL)
            {
                bGotOne = TRUE;
                m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock(lCount, lpPrevCount);
            }
        }
    }

    return bGotOne;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\array_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

CObArray::CObArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CObArray::~CObArray()
{
    delete[] (BYTE*)m_pData;
}

void CObArray::SetSize(int nNewSize, int nGrowBy)
{
    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (CObject**) new BYTE[nNewSize * sizeof(CObject*)];

        memset(m_pData, 0, nNewSize * sizeof(CObject*));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        CObject** pNewData = (CObject**) new BYTE[nNewMax * sizeof(CObject*)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));

        // construct remaining elements
        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));


        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

int CObArray::Append(const CObArray& src)
{
    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);

    memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(CObject*));

    return nOldSize;
}

void CObArray::Copy(const CObArray& src)
{
    SetSize(src.m_nSize);

    memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(CObject*));
}

void CObArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
        CObject** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CObject**) new BYTE[m_nSize * sizeof(CObject*)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CObArray::SetAtGrow(int nIndex, CObject* newElement)
{
    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CObArray::InsertAt(int nIndex, CObject* newElement, int nCount)
{
    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CObject*));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(CObject*));

    }

    // insert new value in the gap
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CObArray::RemoveAt(int nIndex, int nCount)
{
    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CObject*));
    m_nSize -= nCount;
}

void CObArray::InsertAt(int nStartIndex, CObArray* pNewArray)
{
    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

int CObArray::GetSize() const
    { return m_nSize; }
int CObArray::GetUpperBound() const
    { return m_nSize-1; }
void CObArray::RemoveAll()
    { SetSize(0); }
CObject* CObArray::GetAt(int nIndex) const
    { return m_pData[nIndex]; }
void CObArray::SetAt(int nIndex, CObject* newElement)
    { m_pData[nIndex] = newElement; }
CObject*& CObArray::ElementAt(int nIndex)
    { return m_pData[nIndex]; }
const CObject** CObArray::GetData() const
    { return (const CObject**)m_pData; }
CObject** CObArray::GetData()
    { return (CObject**)m_pData; }
int CObArray::Add(CObject* newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
CObject* CObArray::operator[](int nIndex) const
    { return GetAt(nIndex); }
CObject*& CObArray::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <provcoll.h>
#include "provmt.h"
#include "plex.h"

CPlex* CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
            // may throw exception
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVPLEX_H__
#define __PROVPLEX_H__

struct CPlex    // warning variable length structure
{
	CPlex* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	void* data() { return this+1; }

	static CPlex* Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__PROVPLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\strex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(TCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
#ifdef _UNICODE
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
#else
        memset(m_pchData, ch, nLength);
#endif
    }
}

CString::CString(LPCTSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(TCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, TCHAR ch)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CString AFXAPI operator+(TCHAR ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CString CString::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CString CString::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
    // find last single character
    LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
    // find first matching substring
    LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
    #define TCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define TCHAR_ARG   TCHAR
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
        {
            nMaxLen += _tclen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _ttoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                ;
        }

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = _tcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = _tcsinc(lpsz);
            }
            else
            {
                nPrecision = _ttoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = _tcsinc(lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = _tcsinc(lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = _tcsinc(lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
        {
            LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = lstrlen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 'S':
        {
#ifndef _UNICODE
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#else
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#endif
            break;
        }

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    _vstprintf(m_pchData, lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CString::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPTSTR lpsz = m_pchData;
    LPTSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = _tcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCTSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
        lpsz = _tcsinc(lpsz);

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI ConstructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyString, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI DestructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CString();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount)
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}
/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
#else
UINT AFXAPI HashKey(LPCWSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key)
#else
UINT AFXAPI HashKey(LPCSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
*/
UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

UINT AFXAPI HashKeyLPCSTR(LPCSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\strcorew.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
WCHAR afxChNilW = L'\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringDataW* afxDataNilW = (CStringDataW*)&rgInitData;
static LPCWSTR afxPchNilW = (LPCWSTR)(((BYTE*)&rgInitData)+sizeof(CStringDataW));
// special function to make afxEmptyStringW work even during initialization
const CStringW& AFXAPI AfxGetEmptyStringW()
    { return *(CStringW*)&afxPchNilW; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStringW::CStringW()
{
    Init();
}

CStringW::CStringW(const CStringW& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CStringW::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringDataW* pData =
            (CStringDataW*)new BYTE[sizeof(CStringDataW) + (nLen+1)*sizeof(WCHAR)];
        pData->nRefs = 1;
        pData->data()[nLen] = L'\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CStringW::Release()
{
    if (GetData() != afxDataNilW)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CStringW::Release(CStringDataW* pData)
{
    if (pData != afxDataNilW)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CStringW::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNil;
}

void CStringW::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringDataW* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(WCHAR));
    }
}

void CStringW::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CStringW::~CStringW()
//  free any attached data
{
    if (GetData() != afxDataNilW)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CStringW::AllocCopy(CStringW& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringW::CStringW(LPCWSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////

CStringW::CStringW(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStringW&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStringW::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = L'\0';
}

const CStringW& CStringW::operator=(const CStringW& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNilW) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CStringW& CStringW::operator=(LPCWSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStringW& CStringW::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CStringW + CStringW
// and for ? = WCHAR, LPCWSTR
//          CStringW + ?
//          ? + CStringW

void CStringW::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
    int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CStringW object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
    }
}

CStringW AFXAPI operator+(const CStringW& string1, const CStringW& string2)
{
    CStringW s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CStringW AFXAPI operator+(const CStringW& string, LPCWSTR lpsz)
{
    CStringW s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CStringW::SafeStrlen(lpsz), lpsz);
    return s;
}

CStringW AFXAPI operator+(LPCWSTR lpsz, const CStringW& string)
{
    CStringW s;
    s.ConcatCopy(CStringW::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStringW::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringDataW* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CStringW::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = L'\0';
    }
}

const CStringW& CStringW::operator+=(LPCWSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStringW& CStringW::operator+=(WCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CStringW& CStringW::operator+=(const CStringW& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPWSTR CStringW::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringDataW* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(WCHAR));
        GetData()->nDataLength = nOldLen;
        CStringW::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CStringW::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = wcslen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = L'\0';
}

LPWSTR CStringW::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = L'\0';
    return m_pchData;
}

void CStringW::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringDataW* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(WCHAR));
        CStringW::Release(pOldData);
    }
}

LPWSTR CStringW::LockBuffer()
{
    LPWSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CStringW::UnlockBuffer()
{
    if (GetData() != afxDataNilW)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStringW::Find(WCHAR ch) const
{
    // find first single character
    LPWSTR lpsz = wcschr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStringW::FindOneOf(LPCWSTR lpszCharSet) const
{
    LPWSTR lpsz = wcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CStringW::MakeUpper()
{
    CopyBeforeWrite();
    _wcsupr(m_pchData);
}

void CStringW::MakeLower()
{
    CopyBeforeWrite();
    _wcslwr(m_pchData);
}

void CStringW::MakeReverse()
{
    CopyBeforeWrite();
    _wcsrev(m_pchData);
}

void CStringW::SetAt(int nIndex, WCHAR ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}




///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CStringW::AllocSysString() const
{
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;

    return bstr;
}

BSTR CStringW::SetSysString(BSTR* pbstr) const
{
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;

    return *pbstr;
}

// CStringW
CStringDataW* CStringW::GetData() const
    { return ((CStringDataW*)m_pchData)-1; }
void CStringW::Init()
    { m_pchData = afxEmptyStringW.m_pchData; }
CStringW::CStringW(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CStringW& CStringW::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
const CStringW& CStringW::operator+=(char ch)
    { *this += (WCHAR)ch; return *this; }
const CStringW& CStringW::operator=(char ch)
    { *this = (WCHAR)ch; return *this; }
CStringW AFXAPI operator+(const CStringW& string, char ch)
    { return string + (WCHAR)ch; }
CStringW AFXAPI operator+(char ch, const CStringW& string)
    { return (WCHAR)ch + string; }

int CStringW::GetLength() const
    { return GetData()->nDataLength; }
int CStringW::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CStringW::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CStringW::operator LPCWSTR() const
    { return m_pchData; }
int PASCAL CStringW::SafeStrlen(LPCWSTR lpsz)
    { return (lpsz == NULL) ? 0 : wcslen(lpsz); }

// CStringW support (windows specific)
int CStringW::Compare(LPCWSTR lpsz) const
    { return wcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CStringW::CompareNoCase(LPCWSTR lpsz) const
    { return _wcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStringW::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CStringW::Collate(LPCWSTR lpsz) const
    { return wcscoll(m_pchData, lpsz); }   // locale sensitive

WCHAR CStringW::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
WCHAR CStringW::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CStringW& s1, const CStringW& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CStringW& s1, LPCWSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCWSTR s1, const CStringW& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\strexa.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>
#include <mbstring.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringA::CStringA(char ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        memset(m_pchData, ch, nLength);
    }
}

CStringA::CStringA(LPCSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(char));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStringA& CStringA::operator=(char ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStringA AFXAPI operator+(const CStringA& string1, char ch)
{
    CStringA s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CStringA AFXAPI operator+(char ch, const CStringA& string)
{
    CStringA s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStringA CStringA::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CStringA CStringA::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CStringA dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CStringA CStringA::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringA dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CStringA CStringA::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringA dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CStringA CStringA::SpanIncluding(LPCSTR lpszCharSet) const
{
    return Left(strspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStringA CStringA::SpanExcluding(LPCSTR lpszCharSet) const
{
    return Left(strcspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStringA::ReverseFind(char ch) const
{
    // find last single character
    LPSTR lpsz = strrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStringA::Find(LPCSTR lpszSub) const
{
    // find first matching substring
    LPSTR lpsz = strstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CStringA formatting

#ifdef _MAC
    #define TCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define TCHAR_ARG   char
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CStringA::FormatV(LPCSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = (LPCSTR)(LPCSTR)_mbsinc((const unsigned char*)lpsz)) == '%')
        {
            nMaxLen += _mbclen((const unsigned char*)lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = atoi(lpsz);
            for (; *lpsz != '\0' && isdigit(*lpsz); lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
                ;
        }

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            }
            else
            {
                nPrecision = atoi(lpsz);
                for (; *lpsz != '\0' && isdigit(*lpsz); lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz))
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = strlen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 'S':
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    vsprintf(m_pchData, lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CStringA::Format(LPCSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CStringA::FormatMessage(LPCSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPSTR lpszTemp;

    if (::FormatMessageA(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CStringA::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPSTR lpsz = m_pchData;
    LPSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (isspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = (LPSTR)_mbsinc((const unsigned char*)lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CStringA::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCSTR lpsz = m_pchData;
    while (isspace(*lpsz))
        lpsz = (LPCSTR)_mbsinc((const unsigned char*)lpsz);

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(char));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CStringA support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringA> (CStringA* pElements, int nCount)
#else
void AFXAPI ConstructElements(CStringA* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyStringA, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringA> (CStringA* pElements, int nCount)
#else
void AFXAPI DestructElements(CStringA* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CStringA();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringA> (CStringA* pDest, const CStringA* pSrc, int nCount)
#else
void AFXAPI CopyElements(CStringA* pDest, const CStringA* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\strexw.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringW::CStringW(WCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
    }
}

CStringW::CStringW(LPCWSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStringW& CStringW::operator=(WCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStringW AFXAPI operator+(const CStringW& string1, WCHAR ch)
{
    CStringW s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CStringW AFXAPI operator+(WCHAR ch, const CStringW& string)
{
    CStringW s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStringW CStringW::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CStringW CStringW::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CStringW dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CStringW CStringW::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringW dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CStringW CStringW::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CStringW dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CStringW CStringW::SpanIncluding(LPCWSTR lpszCharSet) const
{
    return Left(wcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStringW CStringW::SpanExcluding(LPCWSTR lpszCharSet) const
{
    return Left(wcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStringW::ReverseFind(WCHAR ch) const
{
    // find last single character
    LPWSTR lpsz = wcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStringW::Find(LPCWSTR lpszSub) const
{
    // find first matching substring
    LPWSTR lpsz = wcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CStringW formatting

#ifdef _MAC
    #define WCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define WCHAR_ARG   WCHAR
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CStringW::FormatV(LPCWSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCWSTR lpsz = lpszFormat; *lpsz != L'\0'; lpsz++)
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != L'%' || *(lpsz++) == L'%')
        {
            //nMaxLen += _tclen(lpsz);
            nMaxLen++;
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != L'\0'; lpsz++)
        {
            // check for valid flags
            if (*lpsz == L'#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == L'*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == L'-' || *lpsz == L'+' || *lpsz == L'0' ||
                *lpsz == L' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _wtoi(lpsz);
            for (; *lpsz != L'\0' && iswdigit(*lpsz); lpsz++)
                ;
        }

        int nPrecision = 0;
        if (*lpsz == L'.')
        {
            // skip past '.' separator (width.precision)
            lpsz++;

            // get precision and skip it
            if (*lpsz == L'*')
            {
                nPrecision = va_arg(argList, int);
                lpsz++;
            }
            else
            {
                nPrecision = _wtoi(lpsz);
                for (; *lpsz != L'\0' && iswdigit(*lpsz); lpsz++)
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case L'h':
            nModifier = FORCE_ANSI;
            lpsz++;
            break;
        case L'l':
            nModifier = FORCE_UNICODE;
            lpsz++;
            break;

        // modifiers that do not affect size
        case L'F':
        case L'N':
        case L'L':
            lpsz++;
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case L'c':
        case L'C':
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;
        case L'c'|FORCE_ANSI:
        case L'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case L'c'|FORCE_UNICODE:
        case L'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case L's':
        {
            LPCWSTR pstrNextArg = va_arg(argList, LPCWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case L'S':
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case L's'|FORCE_ANSI:
        case L'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case L's'|FORCE_UNICODE:
        case L'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case L'd':
            case L'i':
            case L'u':
            case L'x':
            case L'X':
            case L'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case L'e':
            case L'f':
            case L'g':
            case L'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case L'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case L'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    vswprintf(m_pchData, lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CStringW::Format(LPCWSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CStringW::FormatMessage(LPCWSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPWSTR lpszTemp;

    if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPWSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CStringW::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;
    while (*lpsz != L'\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz++;
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = L'\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CStringW::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCWSTR lpsz = m_pchData;
    while (iswspace(*lpsz))
        lpsz++;

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CStringW support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringW> (CStringW* pElements, int nCount)
#else
void AFXAPI ConstructElements(CStringW* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyStringW, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringW> (CStringW* pElements, int nCount)
#else
void AFXAPI DestructElements(CStringW* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CStringW();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringW> (CStringW* pDest, const CStringW* pSrc, int nCount)
#else
void AFXAPI CopyElements(CStringW* pDest, const CStringW* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
    { return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
    Init();
}

CString::CString(const CString& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringData* pData =
            (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
        pData->nRefs = 1;
        pData->data()[nLen] = '\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CString::Release()
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CString::Release(CStringData* pData)
{
    if (pData != afxDataNil)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CString::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNil;
}

void CString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringData* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
    }
}

void CString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CString::~CString()
//  free any attached data
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
    int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
    }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
    CString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CString::SafeStrlen(lpsz), lpsz);
    return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
    CString s;
    s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringData* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringData* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
        GetData()->nDataLength = nOldLen;
        CString::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = lstrlen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CString::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringData* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
        CString::Release(pOldData);
    }
}

LPTSTR CString::LockBuffer()
{
    LPTSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CString::UnlockBuffer()
{
    if (GetData() != afxDataNil)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(TCHAR ch) const
{
    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
    LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CString::MakeUpper()
{
    CopyBeforeWrite();
    _tcsupr(m_pchData);
}

void CString::MakeLower()
{
    CopyBeforeWrite();
    _tcslwr(m_pchData);
}

void CString::MakeReverse()
{
    CopyBeforeWrite();
    _tcsrev(m_pchData);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
    CopyBeforeWrite();
    ::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
    CopyBeforeWrite();
    ::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
        return 0;

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
        mbstr, count, NULL, NULL);

    if (result > 0)
        mbstr[result-1] = 0;
    return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);

    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    if (lpa == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    if (lpw == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    BSTR bstr = ::SysAllocStringLen(NULL, nLen);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        bstr, nLen);
#endif

    return bstr;
}

BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    if (!::SysReAllocStringLen(pbstr, NULL, nLen))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        *pbstr, nLen);
#endif

    return *pbstr;
}

// CString
CStringData* CString::GetData() const
    { return ((CStringData*)m_pchData)-1; }
void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

int CString::GetLength() const
    { return GetData()->nDataLength; }
int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CString::operator LPCTSTR() const
    { return m_pchData; }
int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

TCHAR CString::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\strcorea.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provstd.h>
#include <provtempl.h>
#include <provstr.h>

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNilA is left for backward compatibility
char afxChNilA = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringDataA* afxDataNilA = (CStringDataA*)&rgInitData;
static LPCSTR afxPchNilA = (LPCSTR)(((BYTE*)&rgInitData)+sizeof(CStringDataA));
// special function to make afxEmptyStringA work even during initialization
const CStringA& AFXAPI AfxGetEmptyStringA()
    { return *(CStringA*)&afxPchNilA; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStringA::CStringA()
{
    Init();
}

CStringA::CStringA(const CStringA& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CStringA::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringDataA* pData =
            (CStringDataA*)new BYTE[sizeof(CStringDataA) + (nLen+1)*sizeof(char)];
        pData->nRefs = 1;
        pData->data()[nLen] = '\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CStringA::Release()
{
    if (GetData() != afxDataNilA)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CStringA::Release(CStringDataA* pData)
{
    if (pData != afxDataNilA)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CStringA::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNilA;
}

void CStringA::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringDataA* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(char));
    }
}

void CStringA::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CStringA::~CStringA()
//  free any attached data
{
    if (GetData() != afxDataNilA)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CStringA::AllocCopy(CStringA& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(char));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStringA::CStringA(LPCSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(char));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

CStringA::CStringA(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStringA&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStringA::AssignCopy(int nSrcLen, LPCSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(char));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CStringA& CStringA::operator=(const CStringA& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNilA) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CStringA& CStringA::operator=(LPCSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

const CStringA& CStringA::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CStringA + CStringA
// and for ? = char, LPCSTR
//          CStringA + ?
//          ? + CStringA

void CStringA::ConcatCopy(int nSrc1Len, LPCSTR lpszSrc1Data,
    int nSrc2Len, LPCSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CStringA object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(char));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(char));
    }
}

CStringA AFXAPI operator+(const CStringA& string1, const CStringA& string2)
{
    CStringA s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CStringA AFXAPI operator+(const CStringA& string, LPCSTR lpsz)
{
    CStringA s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CStringA::SafeStrlen(lpsz), lpsz);
    return s;
}

CStringA AFXAPI operator+(LPCSTR lpsz, const CStringA& string)
{
    CStringA s;
    s.ConcatCopy(CStringA::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStringA::ConcatInPlace(int nSrcLen, LPCSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringDataA* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CStringA::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(char));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CStringA& CStringA::operator+=(LPCSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CStringA& CStringA::operator+=(char ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CStringA& CStringA::operator+=(const CStringA& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPSTR CStringA::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringDataA* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(char));
        GetData()->nDataLength = nOldLen;
        CStringA::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CStringA::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = strlen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPSTR CStringA::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CStringA::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringDataA* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(char));
        CStringA::Release(pOldData);
    }
}

LPSTR CStringA::LockBuffer()
{
    LPSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CStringA::UnlockBuffer()
{
    if (GetData() != afxDataNilA)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStringA::Find(char ch) const
{
    // find first single character
    LPSTR lpsz = strchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStringA::FindOneOf(LPCSTR lpszCharSet) const
{
    LPSTR lpsz = strpbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CStringA::MakeUpper()
{
    CopyBeforeWrite();
    _strupr(m_pchData);
}

void CStringA::MakeLower()
{
    CopyBeforeWrite();
    _strlwr(m_pchData);
}

void CStringA::MakeReverse()
{
    CopyBeforeWrite();
    _strrev(m_pchData);
}

void CStringA::SetAt(int nIndex, char ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

void CStringA::AnsiToOem()
{
    CopyBeforeWrite();
    ::AnsiToOem(m_pchData, m_pchData);
}
void CStringA::OemToAnsi()
{
    CopyBeforeWrite();
    ::OemToAnsi(m_pchData, m_pchData);
}



///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CStringA::AllocSysString() const
{
#if defined(OLE2ANSI)
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    BSTR bstr = ::SysAllocStringLen(NULL, nLen);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        bstr, nLen);
#endif

    return bstr;
}

BSTR CStringA::SetSysString(BSTR* pbstr) const
{
#if defined(OLE2ANSI)
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    if (!::SysReAllocStringLen(pbstr, NULL, nLen))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        *pbstr, nLen);
#endif

    return *pbstr;
}

// CStringA
CStringDataA* CStringA::GetData() const
    { return ((CStringDataA*)m_pchData)-1; }
void CStringA::Init()
    { m_pchData = afxEmptyStringA.m_pchData; }
CStringA::CStringA(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CStringA& CStringA::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }

int CStringA::GetLength() const
    { return GetData()->nDataLength; }
int CStringA::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CStringA::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CStringA::operator LPCSTR() const
    { return m_pchData; }
int PASCAL CStringA::SafeStrlen(LPCSTR lpsz)
    { return (lpsz == NULL) ? 0 : strlen(lpsz); }

// CStringA support (windows specific)
int CStringA::Compare(LPCSTR lpsz) const
    { return strcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CStringA::CompareNoCase(LPCSTR lpsz) const
    { return _stricmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStringA::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CStringA::Collate(LPCSTR lpsz) const
    { return strcoll(m_pchData, lpsz); }   // locale sensitive

char CStringA::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
char CStringA::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CStringA& s1, const CStringA& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CStringA& s1, LPCSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCSTR s1, const CStringA& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\provstd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVSTD_H_
#define __PROVSTD_H_

#include <windows.h>
#include <winnls.h>
#include <stdio.h>
#include <provexpt.h>

struct __POSITION { };
typedef __POSITION* POSITION;
#define BEFORE_START_POSITION ((POSITION)-1L)

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

class CObject 
{
public:

	CObject () {} ;
	virtual ~CObject () {} ;
} ;

#define AFXAPI __stdcall 
#define AFX_CDECL __cdecl

#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#pragma warning(disable: 4114)

#include "provstr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\provcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVCOLL_H__
#define __PROVCOLL_H__

#include "provstd.h"

class CObArray : public CObject
{
public:

// Construction
	CObArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(int nIndex) const;
	void SetAt(int nIndex, CObject* newElement);
	CObject*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const CObject** GetData() const;
	CObject** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, CObject* newElement);
	int Add(CObject* newElement);
	int Append(const CObArray& src);
	void Copy(const CObArray& src);

	// overloaded operator helpers
	CObject* operator[](int nIndex) const;
	CObject*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CObArray();

protected:
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	CObList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	CObject* GetHead() const;
	CObject*& GetTail();
	CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);

	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

#endif //!__PROVCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <process.h>
#include <objbase.h>
#include <provcont.h>
#include "provevt.h"
#include "provthrd.h"
#include "provlog.h"

extern CRITICAL_SECTION g_ProvDebugLogMapCriticalSection ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	BOOL status = TRUE ;
	SetStructuredExceptionHandler seh;
	
	try
	{
		if ( DLL_PROCESS_DETACH == ulReason )
		{
			ProvThreadObject :: ProcessDetach ( TRUE ) ;
			DeleteCriticalSection ( &ProvDebugLog :: s_CriticalSection ) ;
			DeleteCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
		}
		else if ( DLL_PROCESS_ATTACH == ulReason )
		{
			InitializeCriticalSection ( &ProvDebugLog :: s_CriticalSection ) ;
			InitializeCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
			ProvThreadObject :: ProcessAttach () ;
			DisableThreadLibraryCalls(hInstance);			// 158024 
		}
		else if ( DLL_THREAD_DETACH == ulReason )
		{
		}
		else if ( DLL_THREAD_ATTACH == ulReason )
		{
		}
	}
	catch(Structured_Exception e_SE)
	{
		status = FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		status = FALSE;
	}
	catch(...)
	{
		status = FALSE;
	}
    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\provtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVTEMPL_H__
#define __PROVTEMPL_H__

#ifndef __PROVPLEX_H__
#include "plex.h"
#endif

//#include <new.h>
#include "provstd.h"
#include "provstr.h"

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return (UINT)((UINT_PTR)key) >> 4;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI ConstructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI DestructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount);
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringA> (CStringA* pElements, int nCount);
#else
void AFXAPI ConstructElements(CStringA* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringA> (CStringA* pElements, int nCount);
#else
void AFXAPI DestructElements(CStringA* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringA> (CStringA* pDest, const CStringA* pSrc, int nCount);
#else
void AFXAPI CopyElements(CStringA* pDest, const CStringA* pSrc, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CStringW> (CStringW* pElements, int nCount);
#else
void AFXAPI ConstructElements(CStringW* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CStringW> (CStringW* pElements, int nCount);
#else
void AFXAPI DestructElements(CStringW* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CStringW> (CStringW* pDest, const CStringW* pSrc, int nCount);
#else
void AFXAPI CopyElements(CStringW* pDest, const CStringW* pSrc, int nCount);
#endif

/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key);
#else
UINT AFXAPI HashKey(LPCWSTR key);
#endif
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key);
#else
UINT AFXAPI HashKey(LPCSTR key);
#endif
*/

UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key);
UINT AFXAPI HashKeyLPCSTR(LPCSTR key);

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray 
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements

		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap

	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList 
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;

	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	CNode* pOldNode = (CNode*) position;

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap 
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;

	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	CAssoc* pAssocRet = (CAssoc*)rNextPosition;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// find next association

	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(int nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(int nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	int Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	CTypedPtrList(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\provmt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVMT_H__
#define __PROVMT_H__

#ifdef UNICODE
#define LPCTSTR wchar_t *
#else
#define LPCTSTR char *
#endif

class CSyncObject;
class CSemaphore;
class CMutex;
class CEvent;
class CCriticalSection;
class CSingleLock;
class CMultiLock;

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

class CSyncObject
{
public:

	CSyncObject(LPCTSTR pstrName);

// Attributes
public:
	operator HANDLE() const;
	HANDLE  m_hObject;

// Operations
	virtual BOOL Lock(DWORD dwTimeout = INFINITE);
	virtual BOOL Unlock() = 0;
	virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */)
		{ return TRUE; }

// Implementation
public:
	virtual ~CSyncObject();
	friend class CSingleLock;
	friend class CMultiLock;
};

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

class CSemaphore : public CSyncObject
{
// Constructor
public:
	CSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,
		LPCTSTR pstrName=NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);

// Implementation
public:
	virtual ~CSemaphore();
	virtual BOOL Unlock();
	virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
// Constructor
public:
	CMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,
		LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Implementation
public:
	virtual ~CMutex();
	BOOL Unlock();
};

/////////////////////////////////////////////////////////////////////////////
// CEvent

class CEvent : public CSyncObject
{
// Constructor
public:
	CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,
		LPCTSTR lpszNAme = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Operations
public:
	BOOL SetEvent();
	BOOL PulseEvent();
	BOOL ResetEvent();
	BOOL Unlock();

// Implementation
public:
	virtual ~CEvent();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
// Constructor
public:
	CCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CCriticalSection();
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
// Constructors
public:
	CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);

// Operations
public:
	BOOL Lock(DWORD dwTimeOut = INFINITE);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked();

// Implementation
public:
	~CSingleLock();

protected:
	CSyncObject* m_pObject;
	HANDLE  m_hObject;
	BOOL    m_bAcquired;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

class CMultiLock
{
// Constructor
public:
	CMultiLock(CSyncObject* ppObjects[], DWORD dwCount, BOOL bInitialLock = FALSE);

// Operations
public:
	DWORD Lock(DWORD dwTimeOut = INFINITE, BOOL bWaitForAll = TRUE,
		DWORD dwWakeMask = 0);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked(DWORD dwItem);

// Implementation
public:
	~CMultiLock();

protected:
	HANDLE  m_hPreallocated[8];
	BOOL    m_bPreallocated[8];

	CSyncObject* const * m_ppObjectArray;
	HANDLE* m_pHandleArray;
	BOOL*   m_bLockedArray;
	DWORD   m_dwCount;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline CSyncObject::operator HANDLE() const
	{ return m_hObject;}

inline BOOL CSemaphore::Unlock()
	{ return Unlock(1, NULL); }

inline BOOL CEvent::SetEvent()
	{ return ::SetEvent(m_hObject); }
inline BOOL CEvent::PulseEvent()
	{ return ::PulseEvent(m_hObject); }
inline BOOL CEvent::ResetEvent()
	{ return ::ResetEvent(m_hObject); }

inline CSingleLock::~CSingleLock()
	{ Unlock(); }
inline BOOL CSingleLock::IsLocked()
	{ return m_bAcquired; }

inline BOOL CMultiLock::IsLocked(DWORD dwObject)
	{ return m_bLockedArray[dwObject]; }

inline CCriticalSection::CCriticalSection() : CSyncObject(NULL)
	{ ::InitializeCriticalSection(&m_sect); }
inline CCriticalSection::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*) &m_sect; }
inline CCriticalSection::~CCriticalSection()
	{ ::DeleteCriticalSection(&m_sect); }
inline BOOL CCriticalSection::Lock()
	{ ::EnterCriticalSection(&m_sect); return TRUE; }
inline BOOL CCriticalSection::Lock(DWORD /* dwTimeout */)
	{ return Lock(); }
inline BOOL CCriticalSection::Unlock()
	{ ::LeaveCriticalSection(&m_sect); return TRUE; }


#endif  // __AFXMT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\precomp.h ===
#include <objbase.h>
#include <initguid.h>

extern "C"
{
#include <windows.h>
#include <winnls.h>
#include <stdio.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\provcont.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PROVCONT_H
#define __PROVCONT_H

#include <provexpt.h>

template<class TYPE, class ARG_TYPE>
class ProvList 
{
private:

	CCriticalSection * criticalSection ;
	CList <TYPE, ARG_TYPE> clist ;

protected:
public:

	ProvList ( BOOL threadSafeArg = FALSE ) ;
	virtual ~ProvList () ;

	int GetCount() const;
	BOOL IsEmpty() const;

	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

	TYPE RemoveHead();
	TYPE RemoveTail();

	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	void AddHead(ProvList<TYPE,ARG_TYPE>* pNewList);
	void AddTail(ProvList<TYPE,ARG_TYPE>* pNewList);

	void RemoveAll();

	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); 
	TYPE GetNext(POSITION& rPosition) const; 
	TYPE& GetPrev(POSITION& rPosition); 
	TYPE GetPrev(POSITION& rPosition) const; 

	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
	POSITION FindIndex(int nIndex) const;
} ;

template<class TYPE, class ARG_TYPE>
ProvList <TYPE,ARG_TYPE>:: ProvList ( BOOL threadSafeArg ) : criticalSection ( NULL )
{
	if ( threadSafeArg )	
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
ProvList <TYPE,ARG_TYPE> :: ~ProvList () 
{
	if ( criticalSection ) 
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
int ProvList <TYPE,ARG_TYPE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		int count = clist.GetCount () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return clist.GetCount () ;
	}
}

template<class TYPE, class ARG_TYPE>
BOOL ProvList <TYPE,ARG_TYPE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL isEmpty = clist.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return clist.IsEmpty () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &ProvList <TYPE,ARG_TYPE> :: GetHead () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &head = clist.GetHead () ;
		criticalSection->Unlock () ;
		return head;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetHead () const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE head = clist.GetHead () ;
		criticalSection->Unlock () ;
		return head ;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &ProvList <TYPE,ARG_TYPE> :: GetTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &tail = clist.GetTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetTail() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE tail = clist.GetTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: RemoveHead()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE head = clist.RemoveHead () ;
		criticalSection->Unlock () ;
		return head ;
	}
	else
	{
		return clist.RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: RemoveTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE tail = clist.RemoveTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.RemoveTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: AddHead(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.AddHead ( newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.AddHead ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: AddTail(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.AddTail ( newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.AddTail ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: AddHead(ProvList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.AddHead ( pNewList->clist ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.AddHead ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: AddTail(ProvList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.AddTail ( pNewList->clist ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.AddTail ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: RemoveAll ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.RemoveAll () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: GetHeadPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.GetHeadPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.GetHeadPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: GetTailPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.GetTailPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.GetTailPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& ProvList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetNext ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetNext ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& ProvList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetPrev ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetPrev ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& ProvList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetAt ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetAt ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: SetAt(POSITION pos, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.SetAt ( pos , newElement ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.SetAt ( pos , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvList <TYPE,ARG_TYPE> :: RemoveAt(POSITION position)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.RemoveAt ( position ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.RemoveAt ( position ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.InsertBefore ( position , newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.InsertBefore ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.InsertAfter ( position , newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.InsertAfter ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: Find(ARG_TYPE searchValue, POSITION startAfter ) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.Find ( searchValue , startAfter ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.Find ( searchValue , startAfter ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION ProvList <TYPE,ARG_TYPE> :: FindIndex(int nIndex) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.Find ( nIndex ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.Find ( nIndex ) ;
	}
}

template<class TYPE, class ARG_TYPE>
class ProvStack : public ProvList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	ProvStack ( BOOL threadSafeArg = FALSE ) ;
	virtual ~ProvStack () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
} ;

template<class TYPE, class ARG_TYPE>
ProvStack <TYPE, ARG_TYPE> :: ProvStack ( BOOL threadSafeArg ) : ProvList<TYPE,ARG_TYPE> ( FALSE ) , criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
ProvStack <TYPE, ARG_TYPE> :: ~ProvStack () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void ProvStack <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		AddHead ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		AddHead ( type ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvStack <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = GetHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvStack <TYPE,ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = RemoveHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
class ProvQueue : public ProvList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	ProvQueue ( BOOL threadSafeArg = FALSE ) ;
	virtual ~ProvQueue () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
	void Rotate () ;

} ;

template<class TYPE, class ARG_TYPE>
ProvQueue <TYPE, ARG_TYPE> :: ProvQueue ( BOOL threadSafeArg ) : ProvList<TYPE,ARG_TYPE> ( FALSE ) ,  criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
ProvQueue <TYPE, ARG_TYPE> :: ~ProvQueue () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void ProvQueue <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		AddTail ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		AddTail ( type ) ;
	}
}


template<class TYPE, class ARG_TYPE>
TYPE ProvQueue <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = GetHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE ProvQueue <TYPE, ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = RemoveHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
void ProvQueue <TYPE, ARG_TYPE> :: Rotate ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = Delete () ;
		Add ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		TYPE type = Delete () ;
		Add ( type ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class ProvMap 
{
private:

	CCriticalSection * criticalSection ;
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> cmap ;

protected:
public:

	ProvMap ( BOOL threadSafe = FALSE ) ;
	virtual ~ProvMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ProvMap ( BOOL threadSafeArg ) : criticalSection ( NULL ) 
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = FALSE ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~ProvMap () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		int count = cmap.GetCount () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return cmap.GetCount () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL isEmpty = cmap.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL lookup = cmap.Lookup ( key , rValue ) ;
		criticalSection->Unlock () ;
		return lookup ;
	}
	else
	{
		return cmap.Lookup ( key , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		VALUE &value = cmap.operator [] ( key ) ;
		criticalSection->Unlock () ;
		return value ;
	}
	else
	{
		return cmap.operator [] ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.SetAt ( key , newValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.SetAt ( key , newValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL removeKey = cmap.RemoveKey ( key ) ;
		criticalSection->Unlock () ;
		return removeKey ;
	}
	else
	{
		return cmap.RemoveKey ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.RemoveAll () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = cmap.GetStartPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return cmap.GetStartPosition () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void ProvMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
}

#endif // __PROVCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provmfc\include\provstr.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _PROVSTR_H_
#define _PROVSTR_H_

#include "provstd.h"
#include <tchar.h>

//use TCHAR and depend on UNICODE definition
struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
#endif

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);


//regardless of UNICODE definition always use char
struct CStringDataA
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// char data[nAllocLength]

	char* data()
		{ return (char*)(this+1); }
};

class CStringA
{
public:
// Constructors
	CStringA();
	CStringA(const CStringA& stringSrc);
	CStringA(char ch, int nRepeat = 1);
	CStringA(LPCSTR lpsz);
	CStringA(LPCWSTR lpsz);
	CStringA(LPCSTR lpch, int nLength);
	CStringA(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;      // 0 based
	char operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, char ch);
	operator LPCSTR() const;           // as a C string

	// overloaded assignment
	const CStringA& operator=(const CStringA& stringSrc);
	const CStringA& operator=(char ch);
	const CStringA& operator=(LPCSTR lpsz);
	const CStringA& operator=(LPCWSTR lpsz);
	const CStringA& operator=(const unsigned char* psz);

	// string concatenation
	const CStringA& operator+=(const CStringA& string);
	const CStringA& operator+=(char ch);
	const CStringA& operator+=(LPCSTR lpsz);

	friend CStringA AFXAPI operator+(const CStringA& string1,
			const CStringA& string2);
	friend CStringA AFXAPI operator+(const CStringA& string, char ch);
	friend CStringA AFXAPI operator+(char ch, const CStringA& string);
	friend CStringA AFXAPI operator+(const CStringA& string, LPCSTR lpsz);
	friend CStringA AFXAPI operator+(LPCSTR lpsz, const CStringA& string);

	// string comparison
	int Compare(LPCSTR lpsz) const;         // straight character
	int CompareNoCase(LPCSTR lpsz) const;   // ignore case
	int Collate(LPCSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CStringA Mid(int nFirst, int nCount) const;
	CStringA Mid(int nFirst) const;
	CStringA Left(int nCount) const;
	CStringA Right(int nCount) const;

	CStringA SpanIncluding(LPCSTR lpszCharSet) const;
	CStringA SpanExcluding(LPCSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;               // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(LPCSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCSTR lpszFormat, ...);
#endif

	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CStringA();
	int GetAllocLength() const;

protected:
	LPSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringDataA* GetData() const;
	void Init();
	void AllocCopy(CStringA& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCSTR lpszSrc1Data, int nSrc2Len, LPCSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCSTR lpszSrcData);
	void FormatV(LPCSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringDataA* pData);
	static int PASCAL SafeStrlen(LPCSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator==(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator==(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator!=(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator!=(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator!=(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator<(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator<(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator<(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator>(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator>(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator>(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator<=(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator<=(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator<=(LPCSTR s1, const CStringA& s2);
bool AFXAPI operator>=(const CStringA& s1, const CStringA& s2);
bool AFXAPI operator>=(const CStringA& s1, LPCSTR s2);
bool AFXAPI operator>=(LPCSTR s1, const CStringA& s2);


//regardless of UNICODE definition always use wchar

struct CStringDataW
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// WCHAR data[nAllocLength]

	WCHAR* data()
		{ return (WCHAR*)(this+1); }
};

class CStringW
{
public:
// Constructors
	CStringW();
	CStringW(const CStringW& stringSrc);
	CStringW(WCHAR ch, int nRepeat = 1);
	CStringW(LPCSTR lpsz);
	CStringW(LPCWSTR lpsz);
	CStringW(LPCWSTR lpch, int nLength);
	CStringW(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	WCHAR GetAt(int nIndex) const;      // 0 based
	WCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, WCHAR ch);
	operator LPCWSTR() const;           // as a C string

	// overloaded assignment
	const CStringW& operator=(const CStringW& stringSrc);
	const CStringW& operator=(WCHAR ch);
	const CStringW& operator=(char ch);
	const CStringW& operator=(LPCSTR lpsz);
	const CStringW& operator=(LPCWSTR lpsz);
	const CStringW& operator=(const unsigned char* psz);

	// string concatenation
	const CStringW& operator+=(const CStringW& string);
	const CStringW& operator+=(WCHAR ch);
	const CStringW& operator+=(char ch);
	const CStringW& operator+=(LPCWSTR lpsz);

	friend CStringW AFXAPI operator+(const CStringW& string1,
			const CStringW& string2);
	friend CStringW AFXAPI operator+(const CStringW& string, WCHAR ch);
	friend CStringW AFXAPI operator+(WCHAR ch, const CStringW& string);
	friend CStringW AFXAPI operator+(const CStringW& string, char ch);
	friend CStringW AFXAPI operator+(char ch, const CStringW& string);
	friend CStringW AFXAPI operator+(const CStringW& string, LPCWSTR lpsz);
	friend CStringW AFXAPI operator+(LPCWSTR lpsz, const CStringW& string);

	// string comparison
	int Compare(LPCWSTR lpsz) const;         // straight character
	int CompareNoCase(LPCWSTR lpsz) const;   // ignore case
	int Collate(LPCWSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CStringW Mid(int nFirst, int nCount) const;
	CStringW Mid(int nFirst) const;
	CStringW Left(int nCount) const;
	CStringW Right(int nCount) const;

	CStringW SpanIncluding(LPCWSTR lpszCharSet) const;
	CStringW SpanExcluding(LPCWSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(WCHAR ch) const;               // like "C" strchr
	int ReverseFind(WCHAR ch) const;
	int FindOneOf(LPCWSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCWSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCWSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCWSTR lpszFormat, ...);
#endif

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPWSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPWSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPWSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CStringW();
	int GetAllocLength() const;

protected:
	LPWSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringDataW* GetData() const;
	void Init();
	void AllocCopy(CStringW& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
	void FormatV(LPCWSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringDataW* pData);
	static int PASCAL SafeStrlen(LPCWSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator==(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator==(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator!=(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator!=(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator!=(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator<(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator<(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator<(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator>(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator>(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator>(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator<=(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator<=(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator<=(LPCWSTR s1, const CStringW& s2);
bool AFXAPI operator>=(const CStringW& s1, const CStringW& s2);
bool AFXAPI operator>=(const CStringW& s1, LPCWSTR s2);
bool AFXAPI operator>=(LPCWSTR s1, const CStringW& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

extern char afxChNilA;
const CStringA& AFXAPI AfxGetEmptyStringA();
#define afxEmptyStringA AfxGetEmptyStringA()

extern WCHAR afxChNilW;
const CStringW& AFXAPI AfxGetEmptyStringW();
#define afxEmptyStringW AfxGetEmptyStringW()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provevt.cpp ===
//***************************************************************************

//

//  PROVEVT.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <provcont.h>
#include "provevt.h"
#include "provthrd.h"

ProvEventObject :: ProvEventObject ( const TCHAR *globalEventName ) : m_event ( NULL )
{
	m_event = CreateEvent (

		NULL ,
		FALSE ,
		FALSE ,
		globalEventName 
	) ;

	if ( m_event == NULL )
	{
		if ( GetLastError () == ERROR_ALREADY_EXISTS )
		{
			m_event = OpenEvent (

				EVENT_ALL_ACCESS ,
				FALSE , 
				globalEventName
			) ;
		}
	}
}

ProvEventObject :: ~ProvEventObject () 
{
	if ( m_event )
		CloseHandle ( m_event ) ;
}

HANDLE ProvEventObject :: GetHandle () 
{
	return m_event ;
}

void ProvEventObject :: Set () 
{
	SetEvent ( m_event ) ;
}

void ProvEventObject :: Clear () 
{
	ResetEvent ( m_event ) ;
}

void ProvEventObject :: Process () 
{
}

BOOL ProvEventObject :: Wait ()
{
	return WaitForSingleObject ( GetHandle () , INFINITE ) == WAIT_OBJECT_0 ;
}

void ProvEventObject :: Complete ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provtree.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <typeinfo.h>

#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <stdio.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provtree.h>

WmiTreeNode *WmiTreeNode :: Copy () 
{
	TypeId_TreeNode t_Type = m_Type ;
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_Type , t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provlog.cpp ===
//***************************************************************************

//

//  PROVLOG.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provstd.h>
#include <provmt.h>
#include <string.h>
#include <provlog.h>
#include <provevt.h>
#include <provthrd.h>
#include <Allocator.h>
#include <Algorithms.h>
#include <RedBlackTree.h>

#define LOG_KEY				    _T("Software\\Microsoft\\WBEM\\PROVIDERS\\Logging")
#define LOG_KEY_SLASH           _T("Software\\Microsoft\\WBEM\\PROVIDERS\\Logging\\")
#define LOGGING_ON				_T("Logging")
#define BACKSLASH_STRING		_T("\\")
#define DEFAULT_FILE_EXT		_T(".log")
#define LOGGING_DIR_VALUE		_T("Logging Directory")
#define LOGGING_DIR_KEY			_T("Software\\Microsoft\\WBEM\\CIMOM")
#define DEFAULT_PATH			_T("C:\\")
#define DEFAULT_FILE_SIZE		0x0FFFF
#define MIN_FILE_SIZE			1024
#define MAX_MESSAGE_SIZE		1024
#define HALF_MAX_MESSAGE_SIZE	512

#define LOG_FILE_NAME               _T("File")
#define LOG_LEVEL_NAME				_T("Level")
#define LOG_FILE_SIZE				_T("MaxFileSize")
#define LOG_TYPE_NAME               _T("Type")
#define LOG_TYPE_FILE_STRING		_T("File")
#define LOG_TYPE_DEBUG_STRING		_T("Debugger")

long ProvDebugLog :: s_ReferenceCount = 0 ;
CRITICAL_SECTION ProvDebugLog :: s_CriticalSection ;

typedef WmiRedBlackTree <ProvDebugLog *,ProvDebugLog *> LogContainer ;
typedef WmiRedBlackTree <ProvDebugLog *,ProvDebugLog *> :: Iterator LogContainerIterator ;

LogContainer g_LogContainer ( g_Allocator ) ; 

CRITICAL_SECTION g_ProvDebugLogMapCriticalSection ;

class ProvDebugTaskObject : public ProvTaskObject
{
private:

	HKEY m_LogKey ;

protected:
public:

	ProvDebugTaskObject () ;
	~ProvDebugTaskObject () ;

	void Process () ;

	void SetRegistryNotification () ;
} ;

ProvDebugTaskObject :: ProvDebugTaskObject () : m_LogKey ( NULL )
{
}

ProvDebugTaskObject :: ~ProvDebugTaskObject ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;
}

void ProvDebugTaskObject :: Process ()
{
	ProvDebugLog *t_ProvDebugLog = NULL ;

	EnterCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;

	LogContainerIterator t_Iterator = g_LogContainer.Begin () ;
	while ( ! t_Iterator.Null () )
	{
		t_Iterator.GetElement ()->LoadRegistry () ;
		t_Iterator.GetElement ()->SetRegistry () ;

		t_Iterator.Increment () ;
	}

	LeaveCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
	SetRegistryNotification () ;

	Complete () ;
}

typedef LONG ( *FuncRegNotifyChangeKeyValue ) (

	HKEY hKey,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter,
	HANDLE hEvent,
	BOOL fAsynchronous
) ;

void ProvDebugTaskObject :: SetRegistryNotification ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOG_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&m_LogKey, 
		NULL
	) ;

	if ( t_Status == ERROR_SUCCESS )
	{
		OSVERSIONINFO t_OS;
		t_OS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		if ( ! GetVersionEx ( & t_OS ) )
		{
			return ;
		}

		if ( ! ( t_OS.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && t_OS.dwMinorVersion == 0 ) )
		{
			HINSTANCE t_Library = LoadLibrary( _TEXT("ADVAPI32.DLL"));
			if ( t_Library )
			{
				FuncRegNotifyChangeKeyValue t_RegNotifyChangeKeyValue = ( FuncRegNotifyChangeKeyValue ) GetProcAddress ( t_Library , "RegNotifyChangeKeyValue" ) ;

				t_Status = t_RegNotifyChangeKeyValue ( 

					m_LogKey , 
					TRUE , 
					REG_NOTIFY_CHANGE_LAST_SET , 
					GetHandle () , 
					TRUE 
				) ; 

				if ( t_Status == ERROR_SUCCESS )
				{
				}

				FreeLibrary ( t_Library ) ;
			}
		}
	}
}

class ProvDebugThreadObject : public ProvThreadObject
{
private:

	ProvDebugTaskObject *m_ProvDebugTaskObject ;
	
protected:

	void Uninitialise () { delete this ; }

public:

	ProvDebugThreadObject ( const TCHAR *a_Thread ) ;
	~ProvDebugThreadObject () ;
	void ScheduleDebugTask () ;

	ProvDebugTaskObject *GetTaskObject () ;
} ;

ProvDebugThreadObject *g_ProvDebugLogThread = NULL ;

ProvDebugLog *ProvDebugLog :: s_ProvDebugLog = NULL ;
BOOL ProvDebugLog :: s_Initialised = FALSE ;

ProvDebugThreadObject :: ProvDebugThreadObject ( const TCHAR *a_Thread ) 
:	ProvThreadObject ( a_Thread ) ,
	m_ProvDebugTaskObject ( NULL )
{
}

ProvDebugThreadObject :: ~ProvDebugThreadObject ()
{
	delete ProvDebugLog :: s_ProvDebugLog ;
	ProvDebugLog :: s_ProvDebugLog = NULL ;

	if (m_ProvDebugTaskObject)
	{
		ReapTask ( *m_ProvDebugTaskObject ) ;
		delete m_ProvDebugTaskObject ;
	}
}

void ProvDebugThreadObject :: ScheduleDebugTask ()
{
	m_ProvDebugTaskObject = new ProvDebugTaskObject ;
	ProvDebugLog :: s_ProvDebugLog = new ProvDebugLog ( _T("WBEMSNMP") ) ;
	ScheduleTask ( *m_ProvDebugTaskObject ) ;
}

ProvDebugTaskObject *ProvDebugThreadObject :: GetTaskObject ()
{
	return m_ProvDebugTaskObject ;
}

ProvDebugLog :: ProvDebugLog ( 

	const TCHAR *a_DebugComponent 

) :	m_Logging ( FALSE ) ,
	m_DebugLevel ( 0 ) ,
	m_DebugFileSize ( DEFAULT_FILE_SIZE ),
	m_DebugContext ( ProvDebugContext :: FILE ) ,
	m_DebugFile ( NULL ) ,
    m_DebugFileUnexpandedName ( NULL) ,
	m_DebugFileHandle (  INVALID_HANDLE_VALUE ) ,
	m_DebugComponent ( NULL ) 
{
	EnterCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
	InitializeCriticalSection(&m_CriticalSection);
	EnterCriticalSection(&m_CriticalSection) ;

	LogContainerIterator t_Iterator ;
	WmiStatusCode t_StatusCode = g_LogContainer.Insert ( this , this , t_Iterator ) ;

	if ( a_DebugComponent )
	{
        m_DebugComponent = new TCHAR[_tcslen(a_DebugComponent) + 1];
        // new would have thrown if it failed... hence no check
        _tcscpy(m_DebugComponent, a_DebugComponent);
	}

	LoadRegistry () ;
	SetRegistry () ;

	LeaveCriticalSection(&m_CriticalSection) ;
	LeaveCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
}

ProvDebugLog :: ~ProvDebugLog ()
{
	EnterCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
	EnterCriticalSection(&m_CriticalSection) ;

	WmiStatusCode t_StatusCode = g_LogContainer.Delete ( this ) ;

	CloseOutput () ;

	if (m_DebugComponent)
	{
		delete  m_DebugComponent ;
        m_DebugComponent = NULL ;
	}

	if (m_DebugFile)
	{
		delete m_DebugFile ;
        m_DebugFile = NULL ;
	}

    if (m_DebugFileUnexpandedName)
    {
        delete m_DebugFileUnexpandedName ;
        m_DebugFileUnexpandedName = NULL ;
    }

	LeaveCriticalSection(&m_CriticalSection) ;
	DeleteCriticalSection(&m_CriticalSection);
	LeaveCriticalSection ( &g_ProvDebugLogMapCriticalSection ) ;
}

void ProvDebugLog :: SetDefaultFile ( )
{
	HKEY hkey;

	LONG result =  RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								LOGGING_DIR_KEY, 0, KEY_READ, &hkey);

	if (result == ERROR_SUCCESS)
	{
		TCHAR t_path [MAX_PATH + 1];
		DWORD t_ValueType = REG_SZ;
		DWORD t_ValueLength = MAX_PATH + 1;

		result = RegQueryValueEx( 
			hkey , 
			LOGGING_DIR_VALUE , 
			0, 
			&t_ValueType ,
			( LPBYTE ) t_path , 
			&t_ValueLength 
		) ;

		if ((result == ERROR_SUCCESS) && (t_ValueType == REG_SZ || t_ValueType == REG_EXPAND_SZ))
		{
			_tcscat(t_path, BACKSLASH_STRING);
			_tcscat(t_path, m_DebugComponent);
			_tcscat(t_path, DEFAULT_FILE_EXT);
			SetFile (t_path);
			SetExpandedFile(t_path);
		}

		RegCloseKey(hkey);
	}

	if (m_DebugFileUnexpandedName == NULL)
	{
		TCHAR path[MAX_PATH + 1];
		_stprintf(path, _T("%s%s%s"), DEFAULT_PATH, m_DebugComponent, DEFAULT_FILE_EXT);
		SetFile (path);
		SetExpandedFile(path);
	}
}

void ProvDebugLog :: SwapFileOver()
{
	Flush();
	CloseOutput();

	//prepend a character to the log file name
	TCHAR* buff = new TCHAR[_tcslen(m_DebugFile) + 2];

	//find the last occurrence of \ for dir
	TCHAR* tmp = _tcsrchr(m_DebugFile, '\\');

	if (tmp != NULL)
	{
		tmp++;
		_tcsncpy(buff, m_DebugFile, _tcslen(m_DebugFile) - _tcslen(tmp));
		buff[_tcslen(m_DebugFile) - _tcslen(tmp)] = _T('\0');
		_tcscat(buff, _T("~"));
		_tcscat(buff, tmp);
	}
	else
	{
		_tcscpy(buff, _T("~"));
		_tcscat(buff, m_DebugFile);
	}

	BOOL bOpen = MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);

	//move the file and reopen...
	if (!bOpen)
	{
#if 0
		DWORD x = GetLastError();
		wchar_t* buff2;

		if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
								NULL, x, 0, (LPWSTR) &buff2, 80, NULL))
		{
			DWORD dwErr = GetLastError();
		}
		else
		{
			LocalFree(buff2);
		}
#endif
		//try deleting the file and then moving it
		DeleteFile(buff);
		MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
		bOpen = DeleteFile(m_DebugFile);
	}

	if (bOpen)
	{
		//open file only if move file worked...
		OpenOutput();
	}

	delete [] buff;
}

void ProvDebugLog :: WriteOutput ( const TCHAR *a_OutputDebugString )
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
			{
				CloseOutput();
				OpenOutput();
			}

			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				DWORD dwToWrite = sizeof ( TCHAR ) * ( _tcslen ( a_OutputDebugString ) );
				LPCVOID thisWrite = ( LPCVOID ) a_OutputDebugString;
				BOOL t_Status = TRUE;

				while ((dwToWrite != 0) && (t_Status))
				{
					DWORD dwSize;
					dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END ); 

					//if the file is too big swap it...
#ifdef _UNICODE
					//only whole (2byte) characters written to file
					if ((m_DebugFileSize > 0) && (dwSize >= (m_DebugFileSize - 1)))
#else
					if ((m_DebugFileSize > 0) && (dwSize >= m_DebugFileSize))
#endif
					{
						SwapFileOver();

						if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
						{
							break;
						}

						if (m_DebugFileSize > 0)
						{
							dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END );  
						}
					}

					if (dwSize ==  0xFFFFFFFF)
					{
						break;
					}

					DWORD t_BytesWritten = 0 ;
					DWORD dwThisWrite;

					if ((m_DebugFileSize > 0) && (dwToWrite + dwSize > m_DebugFileSize))
					{
						dwThisWrite = m_DebugFileSize - dwSize;
#ifdef _UNICODE
						if ((dwThisWrite > 1) && (dwThisWrite%2))
						{
							dwThisWrite--;
						}
#endif
					}
					else
					{
						dwThisWrite = dwToWrite;
					}

					LockFile(m_DebugFileHandle, dwSize, 0, dwSize + dwThisWrite, 0); 
					t_Status = WriteFile ( 
			
						m_DebugFileHandle ,
						thisWrite ,
						dwThisWrite ,
						& t_BytesWritten ,
						NULL 
					) ;
					UnlockFile(m_DebugFileHandle, dwSize, 0, dwSize + dwThisWrite, 0);

					//get ready for next write...
					dwToWrite -= t_BytesWritten;
					thisWrite = (LPCVOID)((UCHAR*)thisWrite + t_BytesWritten);
				}
			}
		}
		break ;

		case DEBUG:
		{
			OutputDebugString ( a_OutputDebugString ) ;
		}
		break ;

		default:
		{
		}
		break ;
	}

}

void ProvDebugLog :: WriteOutputW ( const WCHAR *a_OutputDebugString )
{

#ifdef _UNICODE
	WriteOutput(a_OutputDebugString);
#else
	// Convert to MBCS, then call WriteOutput()
	char t_OutputString [MAX_MESSAGE_SIZE];
	WideCharToMultiByte(CP_ACP, 0, a_OutputDebugString, -1, t_OutputString, MAX_MESSAGE_SIZE, NULL, NULL);
	WriteOutput ( t_OutputString ) ;
#endif

}

void ProvDebugLog :: WriteOutputA ( const char *a_OutputDebugString )
{

#ifdef _UNICODE
	// Convert to WCS, then call WriteOutput()
	WCHAR t_OutputString [MAX_MESSAGE_SIZE];
	MultiByteToWideChar(  CP_ACP, 0, a_OutputDebugString, -1, t_OutputString, MAX_MESSAGE_SIZE);
	WriteOutput ( t_OutputString ) ;
#else
	WriteOutput(a_OutputDebugString);
#endif
}

void ProvDebugLog :: OpenFileForOutput ()
{
	if ( m_DebugFile )
	{
		m_DebugFileHandle = CreateFile (
			
			m_DebugFile ,
			GENERIC_WRITE ,
#ifdef _UNICODE 
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
#else
			FILE_SHARE_READ | FILE_SHARE_WRITE,
#endif
			NULL ,
			OPEN_EXISTING ,
			FILE_ATTRIBUTE_NORMAL ,
			NULL 
		) ;

		if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
		{
			m_DebugFileHandle = CreateFile (

				m_DebugFile ,
				GENERIC_WRITE ,
#ifdef _UNICODE 
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
#else
				FILE_SHARE_READ | FILE_SHARE_WRITE,
#endif
				NULL ,
				OPEN_ALWAYS ,
				FILE_ATTRIBUTE_NORMAL ,
				NULL 
			) ;

#ifdef _UNICODE 

			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				UCHAR t_UnicodeBytes [ 2 ] ;
				t_UnicodeBytes [ 0 ] = 0xFF ;
				t_UnicodeBytes [ 1 ] = 0xFE ;

				DWORD t_BytesWritten = 0 ;

				LockFile(m_DebugFileHandle, 0, 0, 2, 0); 

				WriteFile ( 
			
					m_DebugFileHandle ,
					( LPCVOID ) & t_UnicodeBytes ,
					sizeof ( t_UnicodeBytes ) ,
					& t_BytesWritten ,
					NULL 
				) ;

				UnlockFile(m_DebugFileHandle, 0, 0, 2, 0); 
			}
#endif

		}
	}
}

void ProvDebugLog :: OpenOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			OpenFileForOutput () ;
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

void ProvDebugLog :: FlushOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				FlushFileBuffers ( m_DebugFileHandle ) ;
			}
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

void ProvDebugLog :: CloseOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE ) 
			{
				CloseHandle ( m_DebugFileHandle ) ;
				m_DebugFileHandle =  INVALID_HANDLE_VALUE ;
			}
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}


void ProvDebugLog :: Write ( const TCHAR *a_DebugFormatString , ... )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if ( m_Logging )
	{
		TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
		va_list t_VarArgList ;

		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsntprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( TCHAR ) 0 ;
		va_end(t_VarArgList);

		WriteOutput ( t_OutputDebugString ) ;
	}

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: WriteW ( const WCHAR *a_DebugFormatString , ... )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if ( m_Logging )
	{
		WCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
		va_list t_VarArgList ;

		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsnwprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( WCHAR ) 0 ;
		va_end(t_VarArgList);

		WriteOutputW ( t_OutputDebugString ) ;
	}

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: WriteA ( const char *a_DebugFormatString , ... )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if ( m_Logging )
	{
		char t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
		va_list t_VarArgList ;

		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsnprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( char ) 0 ;
		va_end(t_VarArgList);

		WriteOutputA ( t_OutputDebugString ) ;
	}

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: WriteFileAndLine ( const TCHAR *a_File , const ULONG a_Line , const TCHAR *a_DebugFormatString , ... )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if ( m_Logging )
	{
#ifdef BUILD_WITH_FILE_AND_LINE

		TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

		_sntprintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , _TEXT("\r\n(%s):(%lu):") , a_File , a_Line ) ;
		WriteOutput ( t_OutputDebugString ) ;

		va_list t_VarArgList ;
		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsntprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( TCHAR ) 0 ;
		va_end(t_VarArgList);

		WriteOutput ( t_OutputDebugString ) ;

#else

		TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

		_sntprintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , _TEXT("\r\n") ) ;
		WriteOutput ( t_OutputDebugString ) ;

		va_list t_VarArgList ;
		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsntprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( TCHAR ) 0 ;
		va_end(t_VarArgList);

		WriteOutput ( t_OutputDebugString ) ;

#endif

	}

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: WriteFileAndLineW ( const WCHAR *a_File , const ULONG a_Line , const WCHAR *a_DebugFormatString , ... )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if ( m_Logging )
	{
#ifdef BUILD_WITH_FILE_AND_LINE

		WCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

		_snwprintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , L"\r\n(%s):(%lu):" , a_File , a_Line ) ;
		WriteOutputW ( t_OutputDebugString ) ;

		va_list t_VarArgList ;
		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsnwprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( WCHAR ) 0 ;
		va_end(t_VarArgList);

		WriteOutputW ( t_OutputDebugString ) ;

#else

		WCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

		_snwprintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , L"\r\n" ) ;
		WriteOutputW ( t_OutputDebugString ) ;

		va_list t_VarArgList ;
		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsnwprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = (WCHAR) 0 ;
		va_end(t_VarArgList);

		WriteOutputW ( t_OutputDebugString ) ;

#endif

	}

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: WriteFileAndLineA ( const char *a_File , const ULONG a_Line , const char *a_DebugFormatString , ... )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if ( m_Logging )
	{
#ifdef BUILD_WITH_FILE_AND_LINE

		char t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

		_snprintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , "\r\n(%s):(%lu):" , a_File , a_Line ) ;
		WriteOutputA ( t_OutputDebugString ) ;

		va_list t_VarArgList ;
		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsnprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( char ) 0 ;
		va_end(t_VarArgList);

		WriteOutputA ( t_OutputDebugString ) ;

#else

		char t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

		_snprintf ( t_OutputDebugString , HALF_MAX_MESSAGE_SIZE , "\r\n" ) ;
		WriteOutputA ( t_OutputDebugString ) ;

		va_list t_VarArgList ;
		va_start(t_VarArgList,a_DebugFormatString);
		int t_Length = _vsnprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
		t_OutputDebugString [ t_Length ] = ( char ) 0 ;
		va_end(t_VarArgList);

		WriteOutputA ( t_OutputDebugString ) ;

#endif

	}

	LeaveCriticalSection(&m_CriticalSection) ;
}


void ProvDebugLog :: Flush ()
{
	EnterCriticalSection(&m_CriticalSection) ;

	FlushOutput () ;

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: SetLogging ( BOOL a_Logging )
{
	EnterCriticalSection(&m_CriticalSection) ;

	m_Logging = a_Logging ;

	EnterCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: SetLevel ( const DWORD &a_DebugLevel ) 
{
	EnterCriticalSection(&m_CriticalSection) ;

	m_DebugLevel = a_DebugLevel ;

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: SetContext ( const enum ProvDebugContext &a_DebugContext ) 
{
	EnterCriticalSection(&m_CriticalSection) ;

	m_DebugContext = a_DebugContext ;

	LeaveCriticalSection(&m_CriticalSection) ;
}

enum ProvDebugLog :: ProvDebugContext ProvDebugLog :: GetContext () 
{
	EnterCriticalSection(&m_CriticalSection) ;

	ProvDebugContext t_Context = m_DebugContext ;

	LeaveCriticalSection(&m_CriticalSection) ;

	return t_Context ;
}

void ProvDebugLog ::CommitContext ()
{
	EnterCriticalSection(&m_CriticalSection) ;

	CloseOutput () ;
	OpenOutput () ;

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog ::SetFile ( const TCHAR *a_File )
{
	EnterCriticalSection(&m_CriticalSection) ;

	if (m_DebugFileUnexpandedName)
	{
		delete m_DebugFileUnexpandedName ;
        m_DebugFileUnexpandedName = NULL ;
	}

	m_DebugFileUnexpandedName = new TCHAR[_tcslen(a_File) + 1];
    // new would have thrown if it failed... hence no check
    _tcscpy ( m_DebugFileUnexpandedName, a_File ) ;

	LeaveCriticalSection(&m_CriticalSection) ;
}


void ProvDebugLog::SetExpandedFile( 
    const TCHAR *a_RawFileName)
{
    EnterCriticalSection(&m_CriticalSection) ;

    DWORD dwNumChars = ::ExpandEnvironmentStrings(
        a_RawFileName,
        NULL,
        0);
    
    if(dwNumChars > 0)
    {
        try
        {
            m_DebugFile = new TCHAR[dwNumChars + 1];
            if(m_DebugFile)
            {
                m_DebugFile[dwNumChars] = L'\0';

                if(!::ExpandEnvironmentStrings(
                    a_RawFileName,
                    m_DebugFile,
                    dwNumChars))
                {
                    delete m_DebugFile;
                    m_DebugFile = NULL;
                }
            }
        }
        catch(...)
        {
            LeaveCriticalSection(&m_CriticalSection) ;
            throw;
        }
    }

    LeaveCriticalSection(&m_CriticalSection) ;   
}

void ProvDebugLog :: LoadRegistry()
{
	EnterCriticalSection(&m_CriticalSection) ;

	LoadRegistry_Logging  () ;
	LoadRegistry_Level () ;
	LoadRegistry_File () ;
	LoadRegistry_Type () ;
	LoadRegistry_FileSize ();
	CommitContext () ;

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: LoadRegistry_Logging ()
{
	HKEY t_LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOG_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&t_LogKey, 
		NULL
	) ;

	if ( t_Status == ERROR_SUCCESS )
	{
		DWORD t_Logging ;
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_ValueLength = sizeof ( DWORD ) ;
		t_Status = RegQueryValueEx ( 

			t_LogKey , 
			LOGGING_ON , 
			0, 
			&t_ValueType ,
			( LPBYTE ) &t_Logging , 
			&t_ValueLength 
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			m_Logging = ( t_Logging == 1) ? TRUE : FALSE ;
		}

		RegCloseKey ( t_LogKey ) ;
	}
}

void ProvDebugLog :: LoadRegistry_FileSize ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Size ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_FILE_SIZE , 
				0, 
				&t_ValueType ,
				( LPBYTE ) &t_Size , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				m_DebugFileSize = t_Size ;

				if (m_DebugFileSize < MIN_FILE_SIZE)
				{
					m_DebugFileSize = MIN_FILE_SIZE ;
				}
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: LoadRegistry_Level ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_LEVEL_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) &t_Level , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				m_DebugLevel = t_Level ;
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: LoadRegistry_File ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			TCHAR *t_File = NULL ;
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = 0 ;

			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_FILE_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) t_File , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				t_File = new TCHAR [ t_ValueLength ] ;

				t_Status = RegQueryValueEx( 

					t_LogKey , 
					LOG_FILE_NAME , 
					0, 
					&t_ValueType ,
					( LPBYTE ) t_File , 
					&t_ValueLength 
				) ;

				if ( (t_Status == ERROR_SUCCESS) && t_File && (*t_File != _TEXT('\0') ) )
				{
					// Expand the name and store the expanded
                    // name in m_DebugFile.
                    SetExpandedFile(t_File);

                    // Set the unexpanded name in 
                    // m_tstrDebugFileUnexpandedName...
                    SetFile ( t_File ) ;
				}
				else
				{
					SetDefaultFile();
				}

				delete [] t_File ;
			}
			else
			{
				SetDefaultFile();
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: LoadRegistry_Type ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			TCHAR *t_Type = NULL ;
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = 0 ;

			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_TYPE_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) t_Type , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				t_Type = new TCHAR [ t_ValueLength ] ;

				t_Status = RegQueryValueEx( 

					t_LogKey , 
					LOG_TYPE_NAME , 
					0, 
					&t_ValueType ,
					( LPBYTE ) t_Type , 
					&t_ValueLength 
				) ;

				if ( t_Status == ERROR_SUCCESS )
				{
					if ( _tcscmp ( t_Type , _T("Debugger") ) == 0 )
					{
						SetContext ( DEBUG ) ;
					}
					else
					{
						SetContext ( FILE ) ;
					}
				}

				delete [] t_Type;
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: SetRegistry()
{
	EnterCriticalSection(&m_CriticalSection) ;

	SetRegistry_Logging  () ;
	SetRegistry_Level () ;
	SetRegistry_File () ;
	SetRegistry_FileSize () ;
	SetRegistry_Type () ;

	LeaveCriticalSection(&m_CriticalSection) ;
}

void ProvDebugLog :: SetRegistry_Logging ()
{
	HKEY t_LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOG_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&t_LogKey, 
		NULL
	) ;
			
	if ( t_Status == ERROR_SUCCESS )
	{
		DWORD t_Logging = m_Logging ;
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_ValueLength = sizeof ( DWORD ) ;

		t_Status = RegSetValueEx ( 

			t_LogKey , 
			LOGGING_ON , 
			0, 
			t_ValueType ,
			( LPBYTE ) &t_Logging , 
			t_ValueLength 
		) ;

		RegCloseKey ( t_LogKey ) ;
	}
}

void ProvDebugLog :: SetRegistry_FileSize ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}
		
		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level = m_DebugFileSize ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_FILE_SIZE , 
				0, 
				t_ValueType ,
				( LPBYTE ) &t_Level , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: SetRegistry_Level ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level = m_DebugLevel ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_LEVEL_NAME , 
				0, 
				t_ValueType ,
				( LPBYTE ) &t_Level , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: SetRegistry_File ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			if ( m_DebugFileUnexpandedName )
			{
				TCHAR *t_File = m_DebugFileUnexpandedName ;
				DWORD t_ValueType = REG_SZ ;
				DWORD t_ValueLength = ( _tcslen ( t_File ) + 1 ) * sizeof ( TCHAR ) ;

				t_Status = RegSetValueEx( 

					t_LogKey , 
					LOG_FILE_NAME , 
					0, 
					t_ValueType ,
					( LPBYTE ) t_File , 
					t_ValueLength 
				) ;
			}

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: SetRegistry_Type ()
{
	if ( m_DebugComponent )
	{
		TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

			( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
		) ;

		if (t_ComponentKeyString == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		_tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
		_tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

		HKEY t_LogKey = NULL ;

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&t_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			TCHAR *t_Debugger = _T("Debugger") ;
			TCHAR *t_File = _T("File") ;
			TCHAR *t_Type = ( m_DebugContext == DEBUG ) ? t_Debugger : t_File ; 
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = ( _tcslen ( t_Type ) + 1 ) * sizeof ( TCHAR ) ;

			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_TYPE_NAME , 
				0, 
				t_ValueType ,
				( LPBYTE ) t_Type , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

		free ( t_ComponentKeyString ) ;
	}
}

void ProvDebugLog :: SetEventNotification ()
{
	g_ProvDebugLogThread->GetTaskObject ()->SetRegistryNotification () ;
}

BOOL ProvDebugLog :: Startup ()
{
	EnterCriticalSection ( &s_CriticalSection ) ;
	s_ReferenceCount++;

	if ( ! s_Initialised )
	{
		ProvThreadObject::Startup();
		g_ProvDebugLogThread = new ProvDebugThreadObject ( _TEXT("ProvDebugLogThread") ) ;
		g_ProvDebugLogThread->BeginThread();
		g_ProvDebugLogThread->WaitForStartup () ;
		g_ProvDebugLogThread->ScheduleDebugTask();
		SetEventNotification () ;
		s_Initialised = TRUE ;
	}

	LeaveCriticalSection ( &s_CriticalSection ) ;
	return TRUE ;
}

void ProvDebugLog :: Closedown ()
{
	EnterCriticalSection ( &s_CriticalSection ) ;
	s_ReferenceCount--;

	if ( s_ReferenceCount == 0 ) 
	{
		g_ProvDebugLogThread->SignalThreadShutdown() ;
		s_Initialised = FALSE ;
		ProvThreadObject::Closedown();
	}

	LeaveCriticalSection ( &s_CriticalSection ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provdnf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <wbemint.h>
#include <typeinfo.h>
#include <process.h>
#include <stdio.h>

#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <genlex.h>
#include <sql_1.h>
#include <provtree.h>
#include <provdnf.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorIsANode :: ~WmiOperatorIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotIsANode :: ~WmiOperatorNotIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOrNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiAndNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{	
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOrNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" Or "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiAndNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" And "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNotNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Not"
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorIsANode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotIsANode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" Not IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLessOrEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLessOrEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
  		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLessOrEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) <= 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLess ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessOrEqualRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLessOrEqual ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Before ,
	WmiSignedIntegerRangeNode *&a_Intersection ,
	WmiSignedIntegerRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Before ,
	WmiUnsignedIntegerRangeNode *&a_Intersection ,
	WmiUnsignedIntegerRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}

				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetNonIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Before ,
	WmiStringRangeNode *&a_Intersection ,
	WmiStringRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiStringRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )


				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

   				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE ,
					    X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					    Y_E_CLOSED ,
					    Y_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE , 
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	void *a_Context ,
	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node , 
	int &a_Index 
)
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = FALSE ;

	SQL_LEVEL_1_TOKEN *propertyValue = & ( a_Expression.pArrayOfTokens [ a_Index ] ) ;
	a_Index -- ;

	switch ( propertyValue->nTokenType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EXPRESSION:
		{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Operation = OP_EXPESSION"
	) ;
)

			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			switch ( propertyValue->nOperator )
			{
				case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
				{
					t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
				{
					t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
				{
					t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN: 
				{
					t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
				{
					t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
				{
					t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LIKE:
				{
					t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
				}
				break ;

				default:
				{
				}
				break ;
			}

			if ( t_OperatorNode )
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;
			}

			WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

			switch ( propertyValue->dwPropertyFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;

			}
			
			WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;
			switch ( propertyValue->dwConstFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;
			}

			WmiTreeNode *t_ValueNode = AllocTypeNode ( 

				a_Context ,
				propertyValue->pPropertyName , 
				propertyValue->vConstValue , 
				t_PropertyFunction ,
				t_ConstantFunction ,
				t_ParentNode 
			) ;

			if ( t_ValueNode )
			{
				*t_Node = t_ValueNode ;

				t_Status = TRUE ;
			}
			else
			{				
				t_Status = FALSE ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			WmiTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			WmiTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  


		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;

			t_Status = RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: Evaluate ( 

	void *a_Context ,
	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;
	if ( a_Expression.nNumTokens )
	{
		int t_Count = a_Expression.nNumTokens - 1 ;
		t_Status = RecursiveEvaluate ( a_Context , a_Expression , NULL , a_Root , t_Count ) ;
	}
	else
	{
	}

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"PostEvaluation Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = "
	) ;

	if ( a_Root ) 
		a_Root->Print () ;

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"\n"
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
		if ( t_NewOrNodeLeft )
		{
			t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;
		if ( t_AndChildCopy )
		{
			WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;
			if ( t_NewOrNodeRight )
			{
				t_NewOrNode->SetRight ( t_NewOrNodeRight ) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_NewOrNode ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_NewOrNode ) ;
			}	
		}

		a_Node->SetLeft ( NULL ) ;
		a_Node->SetRight ( NULL ) ;
		a_Node->SetData ( NULL ) ;

		a_OrChild->SetLeft ( NULL ) ;
		a_OrChild->SetRight ( NULL ) ;
		a_OrChild->SetData ( NULL ) ;

		delete a_Node ; 
		a_Node = NULL ;

		delete a_OrChild ; 
		a_OrChild = NULL ;
	}

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
		a_Node = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	t_Leaf->SetParent ( t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	a_Node = t_Leaf ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
		if ( t_LeftNot )
		{
			t_NewOrNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;
		if ( t_RightNot )
		{
			t_NewOrNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewAndNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
		if ( t_LeftNot )
		{
			t_NewAndNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;
		if ( t_RightNot )
		{
			t_NewAndNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewAndNode ;
	}
	else
	{
		delete t_NewAndNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_Child , t_NewOrNode ) ;
		if ( t_LessNode )
		{
			t_NewOrNode->SetLeft ( t_LessNode ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_CopyGreaterChild = a_Child->Copy () ;
		if ( t_CopyGreaterChild )
		{
			WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( t_CopyGreaterChild , t_NewOrNode ) ;
			if ( t_GreatorNode )
			{
				t_NewOrNode->SetRight ( t_GreatorNode ) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiTreeNode *t_Range = t_OperatorNode->GetRange () ;
	if ( t_Range )
	{
		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_Range ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_Range ) ;
			}	
		}

		t_Range->SetParent ( t_Parent ) ;
	}

	delete a_Node ;

	a_Node = t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( t_Left->GetType () == TypeId_WmiAndNode ) 
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiNotNode ) 
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformNotOperatorIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformNotOperatorNotIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else
		{
			return WmiTriState :: State_False ; 
		}
	}

	return WmiTriState :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
	}

	if ( t_Right )
	{
		if ( t_Right->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
	}

	return WmiTriState :: State_False ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return WmiTriState :: State_False  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			if ( EvaluateAndExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			if ( EvaluateOrExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
			if ( EvaluateNotExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			if ( EvaluateNotEqualExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	QueryPreprocessor :: QuadState t_Status = RecursiveDisjunctiveNormalForm ( a_Root ) ;
	if ( t_Status == QuadState :: State_ReEvaluate )
	{
		t_Status = DisjunctiveNormalForm ( a_Root ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( 

	void *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context, a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants (

	void *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Context , a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Context , a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status != WmiTriState :: State_False )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status != WmiTriState :: State_False )
				{
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				if ( t_NewAndNode )
				{
					a_Node->SetParent ( t_NewAndNode ) ;
					a_Insertion->SetParent ( t_NewAndNode ) ;

					if ( t_Parent )
					{
						if ( t_Parent->GetLeft () == a_Node )
						{
							t_Parent->SetLeft ( t_NewAndNode ) ;
						}
						else
						{
							t_Parent->SetRight ( t_NewAndNode ) ;
						}
					}

					a_Node = t_NewAndNode ;

					t_Status = WmiTriState :: State_True ;
				}
				else
				{
					t_Status = WmiTriState :: State_Error ; 
				}
			}
			else
			{
				t_Status = WmiTriState :: State_False  ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;

		t_Status = WmiTriState :: State_True ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState  QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == WmiTriState :: State_False  )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		if ( t_NewAndNode )
		{
			a_NewRoot->SetParent ( t_NewAndNode ) ;
			a_Insertion->SetParent ( t_NewAndNode ) ;

			if ( t_Parent )
			{
				if ( t_Parent->GetLeft () == a_NewRoot )
				{
					t_Parent->SetLeft ( t_NewAndNode ) ;
				}
				else
				{
					t_Parent->SetRight ( t_NewAndNode ) ;
				}
			}

			a_NewRoot = t_NewAndNode ;
		}
		else
		{
			return WmiTriState :: State_Error ;
		}
	}

	return WmiTriState :: State_True ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;
		}		
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	WmiTriState t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

    if ( a_Root )
    {
	    WmiTreeNode *t_Parent = a_Root->GetParent () ;
	    if ( t_Parent ) 
	    {
		    if ( t_Parent->GetLeft () == a_Root )
		    {
			    t_Parent->SetLeft ( t_NewRoot ) ;
		    }
		    else
		    {
			    t_Parent->SetRight ( t_NewRoot ) ;
		    }
	    }

	    t_NewRoot->SetParent ( t_Parent ) ;

	    delete a_Root ;
    }

	a_Root = t_NewRoot ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				if ( t_Right  )
				{
					t_Status = RecursiveSort ( t_Right ) ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Single operand
			t_Status = WmiTriState :: State_True ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	WmiTriState t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	return RecursiveConvertToRanges ( a_Root ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}

		a_Intersection->SetParent ( t_CompareParent ) ;

		delete a_Compare ; 
		a_Compare = NULL ;
	}
	else
	{
// Should never happen
DebugBreak () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					a_Compare = NULL ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

                    a_Compare = NULL;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNullRangeNode ) 
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiNullRangeNode ) 
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiStringRangeNode ) 
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiStringRangeNode ) 
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break; 

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
// Should never happen, failure in DNF evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctions ( 

	void *a_Context , 
	WmiTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context , 
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

				for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
				{
					if ( t_Disjunction->GetRange ( t_Index ) == NULL )
					{
						WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

							a_Context ,
							a_PropertiesToPartition [ t_Index ] 
						) ;

						if ( t_RangeNode )
						{
							t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
						}
						else
						{
							t_Status = WmiTriState :: State_Error ;
							break ;
						}
					}
				}
			}

			a_DisjunctionIndex ++ ;

			if ( t_Status == WmiTriState :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context ,
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}

				if ( t_Status == WmiTriState :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

					for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								a_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ; 
							}
						}
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context ,
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context , 
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( _wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					WmiRangeNode *t_NodeCopy = ( WmiRangeNode * ) t_Node->Copy () ;
					if ( t_NodeCopy )
					{
						t_Disjunction->SetRange ( t_Index , t_NodeCopy ) ;
					}
					else
					{
						t_Status = WmiTriState :: State_Error ;
					}

					break ;
				}
			}			
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctionContainer ( 

	void *a_Context , 
	WmiTreeNode *a_Root , 
	ULONG a_Count , 
	BSTR *a_Container , 
	Disjunctions *&a_Disjunctions
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Count && a_Container )
	{
		ULONG t_PropertiesToPartitionCount = a_Count ;
		BSTR *t_PropertiesToPartition = a_Container ;

		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;
		if ( a_Disjunctions )
		{
			t_Status = a_Disjunctions->Initialize () ;
			if ( t_Status == WmiTriState :: State_True )
			{
				t_Count = 0 ; 
				t_Status = CreateDisjunctions ( 

					a_Context , 
					a_Root , 
					a_Disjunctions ,
					t_PropertiesToPartitionCount ,
					t_PropertiesToPartition ,
					t_Count
				) ;

				if ( t_Status == WmiTriState :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								t_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ;
								break ;
							}
						}
					}
				}
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintInit (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
   	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
        DebugMacro3( 

            ProvDebugLog :: s_ProvDebugLog->WriteW (  

	            L"    "
            ) ;
        )
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
        DebugMacro3( 

            ProvDebugLog :: s_ProvDebugLog->WriteW (  

	            L"%lu", a_DisjunctionSetToTest [ t_Index ] ? 1 : 0
            ) ;
        )
    }

    DebugMacro3( 

        ProvDebugLog :: s_ProvDebugLog->WriteW (  

	        L"\n"
        ) ;
    )

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
    	for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
        {
            DebugMacro3( 

                ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                L"    "
                ) ;
            )
        }

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
		if ( t_Disjunction )
		{
			t_Disjunction->GetRange ( a_KeyIndex )->Print () ;

			DebugMacro3( 

				ProvDebugLog :: s_ProvDebugLog->WriteW (  

					L"\n"
				) ;
			)
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintSortedRange (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
    ULONG *a_OriginToSorted ,
	ULONG a_KeyIndex ,
    WmiRangeNode **a_RangeTable
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
   		if ( a_RangeTable [ t_Index ] )
        {
    	    for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
            {
                DebugMacro3( 

                    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                    L"%lu    ", t_Index
                    ) ;
                )
            }

            if ( a_DisjunctionSetToTest [ a_OriginToSorted [ t_Index ] ] )
            {
                DebugMacro3( 

                    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                    L"In "
                    ) ;
				)
            }
            else
            {
                DebugMacro3( 

                    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                    L"Out "
                    ) ;
				)
            }

		    a_RangeTable [ t_Index ]->Print () ;

            DebugMacro3( 

                ProvDebugLog :: s_ProvDebugLog->WriteW (  

	                L"\n"
                ) ;
            )
        }
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintOverlap (

	ULONG a_DisjunctionSetToTestCount ,
   	ULONG *a_DisjunctionSetToTest ,
	ULONG *a_SortedDisjunctionSetToTest ,
    ULONG *a_OverlappingIndex ,
  	ULONG a_KeyIndex 
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
DebugMacro3( 

    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	    L"    "
    ) ;
)
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
DebugMacro3( 

    if ( a_DisjunctionSetToTest [ t_Index ] )
    {
        ProvDebugLog :: s_ProvDebugLog->WriteW (  

	        L"%lu ",  a_OverlappingIndex [ t_Index ]
        ) ;
    }
    else
    {
        ProvDebugLog :: s_ProvDebugLog->WriteW (  

	        L"X "
        ) ;
    }
)
    }

DebugMacro3( 

    ProvDebugLog :: s_ProvDebugLog->WriteW (  

	    L"\n"
    ) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: RecursiveQuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Lower , 
	ULONG a_Upper
)
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;

				ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
				a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ t_RightIndex ];
				a_UnsortedOrder [ t_RightIndex ] = t_Val ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare )
		{
			WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;

			ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
			a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ a_Lower - 1 ];
			a_UnsortedOrder [ a_Lower - 1 ] = t_Val ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_UnsortedOrder ,
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			a_UnsortedOrder ,
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: QuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Size
)
{
	RecursiveQuickSort ( a_Array , a_UnsortedOrder , 1 , a_Size - 1 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: SortRanges (

	ULONG t_DisjunctionCount ,
    ULONG *t_OriginToSorted ,
	WmiRangeNode **t_RangeTable 
)
{
	QuickSort (	t_RangeTable , t_OriginToSorted , t_DisjunctionCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RemoveOverlaps (

	ULONG *a_DisjunctionSetToTest ,
	ULONG a_DisjunctionCount ,
	ULONG *a_OverlappingIndex ,
    ULONG *a_OriginToSorted ,
	WmiRangeNode **a_RangeTable 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

/*
 *  Remove Overlaps
 */

	ULONG t_InnerIndex = 0 ;
	ULONG t_OuterIndex = 1 ;

	while ( ( t_Status != WmiTriState :: State_Error ) && ( t_OuterIndex < a_DisjunctionCount ) )
	{
		WmiRangeNode *t_LeftRange = a_RangeTable [ t_OuterIndex ] ;
		WmiRangeNode *t_RightRange = a_RangeTable [ t_InnerIndex ] ;

		if ( a_OverlappingIndex [ t_OuterIndex ] != a_OverlappingIndex [ t_InnerIndex ] )
		{
			if ( t_LeftRange && t_RightRange )
			{
				if ( ( t_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
				{
					WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
					WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;
    				WmiStringRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftString->GetOverlappingRange ( *t_RightString , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Overlap\n"
	) ;
)

						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;

						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
					}
					else
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
				{
					WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
					WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;
    				WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
				{
					WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
					WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;
    				WmiSignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else
				{
// Failure
					t_Status = WmiTriState :: State_Error ;  
				}
			}
		}

		t_InnerIndex ++ ;
		t_OuterIndex ++ ;
	}

	for ( LONG t_Index = a_DisjunctionCount - 1 ; t_Index >= 0 ; t_Index -- )
	{
		if ( t_Index < a_OverlappingIndex [ t_Index ] )
		{
			a_OverlappingIndex [ t_Index ] = a_OverlappingIndex [ a_OverlappingIndex [ t_Index ] ] ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_KeyIndex < a_Disjunctions->GetConjunctionCount () )
	{
		ULONG *t_OverlappingIndex = NULL ;
        ULONG *t_OriginToSorted = NULL ;
		WmiRangeNode **t_RangeTable = NULL ;

		try
		{
			t_OverlappingIndex = new ULONG [ a_DisjunctionSetToTestCount ] ;
			t_OriginToSorted = new ULONG [ a_DisjunctionSetToTestCount ] ;

			t_RangeTable = new WmiRangeNode * [ a_DisjunctionSetToTestCount ] ;
			memset ( t_RangeTable, 0, sizeof ( WmiRangeNode* ) * a_DisjunctionSetToTestCount );

			if ( t_OverlappingIndex && t_OriginToSorted && t_RangeTable )
			{
				for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionSetToTest [ t_Index ] ) ;
					t_RangeTable [ t_Index ] = ( WmiRangeNode * ) t_Disjunction->GetRange ( a_KeyIndex )->Copy () ;
					t_OverlappingIndex [ t_Index ] = t_Index ;
					t_OriginToSorted [ t_Index ] = t_Index ;
				}

				// Sort Partitions
				SortRanges (

					a_DisjunctionSetToTestCount ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;

				t_Status = RemoveOverlaps (

					a_DisjunctionSetToTest ,
					a_DisjunctionSetToTestCount ,
					t_OverlappingIndex ,
					t_OriginToSorted ,
					t_RangeTable 
				) ;

				if ( t_Status != WmiTriState :: State_Error )
				{
					ULONG t_PartitionCount = 0 ;
					for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
					{
						if ( t_RangeTable [ t_Index ] )
						{
							t_PartitionCount ++ ;
						}
					}

					t_Status = a_Partition->Initialize ( t_PartitionCount ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
						ULONG t_PartitionIndex = 0 ;
						for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount; t_Index ++ )
						{
							WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
							if ( t_Range )
							{
								PartitionSet *t_Partition = new PartitionSet ;
								if ( t_Partition )
								{
									a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

									WmiRangeNode *t_Copy = ( WmiRangeNode * ) t_Range->Copy () ;
									if ( t_Copy )
									{
										t_Partition->SetRange ( t_Copy ) ;
										t_Partition->SetKeyIndex ( a_KeyIndex ) ;
										t_PartitionIndex ++ ;
									}
									else
									{
										t_Status = WmiTriState :: State_Error ; 
										break ;
									}
								}
								else
								{
									t_Status = WmiTriState :: State_Error ; 
									break ;
								}
							}
						}
					}

					if ( t_Status == WmiTriState :: State_True )
					{
/*
 *  Outer Index is the range order
 */
						ULONG t_PartitionIndex = 0 ;

/*
 *	Array allocation has max defined by function arg.
 */

						ULONG *t_DisjunctionSetToTest = NULL ;

						try
						{
							t_DisjunctionSetToTest = new ULONG [ a_DisjunctionSetToTestCount ] ;
							if ( t_DisjunctionSetToTest )
							{
								ULONG t_OuterIndex = 0 ;
								while ( t_Status && ( t_OuterIndex < a_DisjunctionSetToTestCount ) )
								{
									BOOL t_Found = FALSE ;

									ULONG t_DisjunctionSetToTestCount = 0 ;

									if ( t_RangeTable [ t_OuterIndex ] )
									{
	/*
	 * Inner index matches the overlaps
	 */

										LONG t_InnerIndex = t_OuterIndex ;
										while ( t_InnerIndex >= 0 )
										{
											if ( t_OverlappingIndex [ t_OuterIndex ] == t_OverlappingIndex [ t_InnerIndex ] )
											{
												t_DisjunctionSetToTest [ t_DisjunctionSetToTestCount ] = a_DisjunctionSetToTest [ t_OriginToSorted [ t_InnerIndex ] ] ;
												t_DisjunctionSetToTestCount ++ ;
												t_Found = TRUE ;
											}
											else
											{
												break ;
											}

											t_InnerIndex -- ;
										}
									}

    								if ( t_Found )
									{
										PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
										if ( t_Partition )
										{
											t_Status = RecursivePartitionSet (

												a_Disjunctions ,
												t_Partition ,
												t_DisjunctionSetToTestCount ,
												t_DisjunctionSetToTest ,
												a_KeyIndex + 1
											) ;

											t_PartitionIndex ++ ;
										}
									}

									t_OuterIndex ++ ;
								}

								delete [] t_DisjunctionSetToTest ;
								t_DisjunctionSetToTest = NULL ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ; 
							}
						}
						catch ( ... )
						{
							if ( t_DisjunctionSetToTest )
							{
								delete [] t_DisjunctionSetToTest ;
								t_DisjunctionSetToTest = NULL ;
							}

							throw ;
						}
					}
				}
				else
				{
					t_Status = WmiTriState :: State_Error ; 
				}

				for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						delete t_RangeTable [ t_Index ] ;
						t_RangeTable [ t_Index ] = NULL ;
					}
				}
			}
			else
			{
				t_Status = WmiTriState :: State_Error ; 
			}
		}
		catch ( ... )
		{
			if ( t_RangeTable )
			{
				for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						delete t_RangeTable [ t_Index ] ;
						t_RangeTable [ t_Index ] = NULL ;
					}
				}

				delete [] t_RangeTable ;
				t_RangeTable = NULL;
			}

			if ( t_OverlappingIndex )
			{
				delete [] t_OverlappingIndex ;
			}

			if ( t_OriginToSorted )
			{
				delete [] t_OriginToSorted ;
			}

			throw;
		}

		delete [] t_RangeTable ;
		delete [] t_OverlappingIndex ;
		delete [] t_OriginToSorted ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	if ( t_DisjunctionSetToTest )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_DisjunctionSetToTest [ t_Index ] = t_Index ;
		}

		try
		{
			a_Partition = new PartitionSet ;
			if ( a_Partition )
			{
				t_Status = RecursivePartitionSet (

					a_Disjunctions ,
					a_Partition ,
					t_DisjunctionCount ,
					t_DisjunctionSetToTest ,
					0
				) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}

			delete [] t_DisjunctionSetToTest ;
			t_DisjunctionSetToTest = NULL ;
		}
		catch ( ... )
		{
			if ( t_DisjunctionSetToTest )
			{ 
				delete [] t_DisjunctionSetToTest ;
				t_DisjunctionSetToTest = NULL ;
			}

			if ( a_Partition )
			{
				delete a_Partition;
				a_Partition = NULL;
			}

			throw;
		}
	}
	else
	{
		t_Status = WmiTriState :: State_Error ;
	}

	return t_Status;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess ( 

	void *a_Context , 
	SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
	WmiTreeNode *a_Root ,
	ULONG a_Count , 
	BSTR *a_Container , 
	PartitionSet *&a_Partition
)
{
	QuadState t_State = State_True ;

    if ( a_Root != NULL )
    {
        WmiTreeNode *t_Root = a_Root->Copy () ;
		if ( t_Root )
		{
			t_State = RemoveInvariants ( a_Context , t_Root ) ;

			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{		
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = TRUE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_False:
				{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = FALSE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_Undefined:
				{
					PrintTree ( t_Root ) ;
						
					WmiTriState t_Status = Sort ( t_Root ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
						PrintTree ( t_Root ) ;

						t_Status = ConvertToRanges ( t_Root ) ;
					}

					if ( t_Status == WmiTriState :: State_True )
					{
						PrintTree ( t_Root ) ;

						switch ( t_State = RemoveNonOverlappingRanges ( t_Root ) )
						{
							case QueryPreprocessor :: QuadState :: State_True :
							{		
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = TRUE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_False:
							{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteW (  

		L"Expression = FALSE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_Undefined:
							{
								PrintTree ( t_Root ) ;

								t_State =  State_Error ;

								Disjunctions *t_Disjunctions = NULL ;

								try
								{
									t_Status = CreateDisjunctionContainer ( a_Context , t_Root , a_Count , a_Container , t_Disjunctions ) ;
									if ( t_Status == WmiTriState :: State_True )
									{
										PartitionSet *t_Partition = NULL ;

										try
										{
											t_Status = CreatePartitionSet ( t_Disjunctions , t_Partition ) ;
											if ( t_Status == WmiTriState :: State_True )
											{
												t_State =  State_Undefined ; 
												a_Partition = t_Partition ;
											}
											else
											{
												delete t_Partition ;
												t_Partition = NULL ;
											}

											delete t_Disjunctions ;
											t_Disjunctions = NULL;
										}
										catch ( ... )
										{
											if ( t_Partition )
											{
												delete t_Partition;
												t_Partition = NULL;

												a_Partition = NULL;
											}

											throw;
										}
									}
									else
									{
										t_State = QueryPreprocessor :: QuadState :: State_Error ;
									}
								}
								catch ( ... )
								{
									if ( t_Disjunctions )
									{
										delete t_Disjunctions ;
										t_Disjunctions = NULL ;
									}

									if ( t_Root )
									{
										delete t_Root;
									}

									throw;
								}
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_ReEvaluate:
							default:
							{
							}
							break ;
						}
					}
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_ReEvaluate:
				default:
				{
				}
				break ;
			}

			delete t_Root ;
		}
		else
		{
			t_State = State_Error ;
		}
    }

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess (

	void *a_Context ,																
	SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
	WmiTreeNode *&a_Root 
)
{
	QuadState t_State = State_Error ;

	BOOL t_Status = Evaluate ( a_Context , *a_RpnExpression , &a_Root ) ;
	if ( t_Status )
	{
		t_State = State_True ;

		PrintTree ( a_Root ) ;
        
		t_State = DisjunctiveNormalForm ( a_Root ) ;

		PrintTree ( a_Root ) ;
	}
	else
	{
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: Query ( 

	BSTR a_Query ,
	SQL_LEVEL_1_RPN_EXPRESSION *&a_RpnExpression
)
{
	QuadState t_State = State_Error ;

	CTextLexSource t_Source ( a_Query ) ;
	SQL1_Parser t_Parser ( & t_Source ) ;

	int t_Status = t_Parser.Parse ( & a_RpnExpression ) ;
	if ( t_Status == 0 )
	{
		t_State = State_True ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: ~QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_THIS				L"__THIS"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *QueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_THIS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
	}

	return t_Node ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provtype.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS Prov Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <typeinfo.h>
#include <provtempl.h>
#include <provmt.h>
#include <winsock.h>
#include <strstrea.h>
#include <provcont.h>
#include <provval.h>
#include <provtype.h>

#if _MSC_VER >= 1100
template <> UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key )
#else
UINT HashKey ( wchar_t *key )
#endif
{
	UCHAR *value = ( UCHAR * ) key ;
	ULONG length = wcslen ( key ) * sizeof ( wchar_t ) ;

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;

        for (ULONG i = length >> 1; i--;)
        {
            even += towlower (*value++) ;
            odd += towlower (*value++) ;
        }
        if (length & 1)
        {
            even += towlower (*value);
        }
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

	return hash ;
}

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 )
#else
BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 )
#endif
{
	return _wcsicmp ( *pElement1 , *pElement2 ) == 0 ;
}

CBString::CBString(int nSize) : m_pString ( NULL )
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString) : m_pString ( NULL )
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) 
	{
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString )
{
	size_t textLength = mbstowcs ( NULL , dbcsString , 0  ) ;
	wchar_t *unicodeString = new wchar_t [ textLength + 1 ] ;
	textLength = mbstowcs ( unicodeString , dbcsString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] unicodeString ;
		unicodeString = NULL ;
	}

	return unicodeString ;
}

DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString )
{
	size_t textLength = wcstombs ( NULL , unicodeString , 0 ) ;
	char *dbcsString = new char [ textLength + 1 ] ;
	textLength = wcstombs ( dbcsString , unicodeString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] dbcsString ;
		dbcsString = NULL ;
	}

	return dbcsString ;
}

DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
	if ( string )
	{
		int textLength = wcslen ( string ) ;

		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
		wcscpy ( textBuffer , string ) ;

		return textBuffer ;
	}
	else
	{
		return NULL ;
	}
}

DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
	int prefixTextLength = 0 ;
	if ( prefix )
	{
		prefixTextLength = wcslen ( prefix ) ;
	}

	int suffixTextLength = 0 ;
	if ( suffix )
	{
		suffixTextLength = wcslen ( suffix ) ;
	}

	if ( prefix || suffix )
	{
		int textLength = prefixTextLength + suffixTextLength ;
		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

		if ( prefix )
		{
			wcscpy ( textBuffer , prefix ) ;
		}

		if ( suffix )
		{
			wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
		}

		return textBuffer ;
	}	
	else
		return NULL ;
}

ProvLexicon :: ProvLexicon () : position ( 0 ) , tokenStream ( NULL ) , token ( INVALID_ID )
{
	value.token = NULL ;
}

ProvLexicon :: ~ProvLexicon ()
{
	switch ( token ) 
	{
		case TOKEN_ID:
		{
			delete [] value.token ;
		}
		break ;
	
		default:
		{
		} ;
	}
}

void ProvLexicon :: SetToken ( ProvLexicon :: LexiconToken a_Token )
{
	token = a_Token ;
}

ProvLexicon :: LexiconToken ProvLexicon :: GetToken ()
{
	return token ;
}

ProvLexiconValue *ProvLexicon :: GetValue ()
{
	return &value ;
}

ProvAnalyser :: ProvAnalyser ( const wchar_t *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
	if ( tokenStream )
	{
		stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
		wcscpy ( stream , tokenStream ) ;
	}
}

ProvAnalyser :: ~ProvAnalyser () 
{
	delete [] stream ;
}

void ProvAnalyser :: Set ( const wchar_t *tokenStream ) 
{
	status = 0 ;
	position = NULL ;

	delete [] stream ;
	stream = NULL ;
	stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
	wcscpy ( stream , tokenStream ) ;
}

void ProvAnalyser :: PutBack ( const ProvLexicon *token ) 
{
	position = token->position ;
}

ProvAnalyser :: operator void * () 
{
	return status ? this : NULL ;
}

ProvLexicon *ProvAnalyser :: Get ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace ) 
{
	ProvLexicon *lexicon = NULL ;

	if ( stream )
	{
		lexicon = GetToken ( unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) ;
	}
	else
	{
		lexicon = CreateLexicon () ;
		lexicon->position = position ;
		lexicon->token = ProvLexicon :: EOF_ID ;
	}

	return lexicon ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000
#define WHITESPACE_START 6000
#define ACCEPT_STATE ANALYSER_ACCEPT_STATE
#define REJECT_STATE ANALYSER_REJECT_STATE 

ProvLexicon *ProvAnalyser :: GetToken ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace )  
{
	ProvLexicon *lexicon = CreateLexicon () ;
	lexicon->position = position ;

	Initialise () ;

	ULONG state = 0 ;

/* 
 * Integer Definitions
 */

	BOOL negative = FALSE ;
	BOOL positive = FALSE ;

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	LONG negativeMagicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
	ULONG negativeMagicNegDigit = 8 ;
	ULONG negativeMagicPosDigit = 7 ;
	LONG negativeDatum = 0 ;	

/*
 * Token Definitions
 */

	ULONG token_start = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = stream [ position ] ;
		if ( Analyse ( lexicon , state , token , stream , position , unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) )
		{
		}
		else
		{
			switch ( state )
			{
				case 0:
				{
					if ( IsAlpha ( token ) )
					{
						state = TOKEN_START ;
						token_start = position ;
					}
					else if ( ProvAnalyser :: IsLeadingDecimal ( token ) )
					{
						state = DEC_INTEGER_START + 1  ;
						negativeDatum = ( token - 48 ) ;
					}
					else if ( token == L'+' )
					{
						if ( unSignedIntegersOnly ) 
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProvLexicon :: PLUS_ID ;
						}
						else
						{
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'-' ) 
					{
						if ( unSignedIntegersOnly )
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProvLexicon :: MINUS_ID ;
						}
						else
						{
							negative = TRUE ;
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'0' )
					{
						if ( ! leadingIntegerZeros ) 
						{
							state = 1 ;
						}
						else
						{
							negativeDatum = 0 ;
							state = DEC_INTEGER_START + 1 ;
						}
					}
					else if ( ProvAnalyser :: IsWhitespace ( token ) ) 
					{
						if ( eatSpace )
						{
							state = 0 ;
						}
						else
						{
							lexicon->token = ProvLexicon :: WHITESPACE_ID ;
							state = WHITESPACE_START ;
						}
					}
					else if ( token == L'(' )
					{
						lexicon->token = ProvLexicon :: OPEN_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L')' )
					{
						lexicon->token = ProvLexicon :: CLOSE_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L',' )
					{
						lexicon->token = ProvLexicon :: COMMA_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L':' )
					{
						lexicon->token = ProvLexicon :: COLON_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L'.' )
					{
						state = 2;
					}
					else if ( IsEof ( token ) )
					{
						lexicon->token = ProvLexicon :: EOF_ID ;
						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
				break ;

				case 1:
				{
					if ( token == L'x' || token == L'X' )
					{
						state = HEX_INTEGER_START ;				
					}
					else if ( ProvAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;
						positiveDatum = ( token - 48 ) ;
					}
					else
					{
						if ( unSignedIntegersOnly )
						{
							lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = 0 ;
						}
						else
						{
							lexicon->token = ProvLexicon :: SIGNED_INTEGER_ID ;
							lexicon->value.signedInteger = 0 ;
						}

						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break ;

				case 2:
				{
					if ( token == L'.' )
					{
						lexicon->token = ProvLexicon :: DOTDOT_ID ;
						state = ACCEPT_STATE ;
					}
					else
					{
						lexicon->token = ProvLexicon :: DOT_ID ;
						position -- ;
						state = ACCEPT_STATE  ;
					}
				}
				break ;

				case TOKEN_START:
				{
					if ( IsAlphaNumeric ( token ) ) 
					{
						state = TOKEN_START ;
					}
					else 
					{
						state = ACCEPT_STATE ;
						lexicon->token = ProvLexicon :: TOKEN_ID ;
						lexicon->value.token = new wchar_t [ position - token_start + 1 ] ;
						wcsncpy ( 

							lexicon->value.token , 
							& stream [ token_start ] , 
							position - token_start 
						) ;

						lexicon->value.token [ position - token_start ] = 0 ;

						position -- ;
					}
				}
				break ;

				case WHITESPACE_START:
				{
					if ( ProvAnalyser :: IsWhitespace ( token ) ) 
					{
						state = WHITESPACE_START ;
					}
					else
					{
						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break;

				case HEX_INTEGER_START:
				{
					if ( ProvAnalyser :: IsHex ( token ) )
					{
						positiveDatum = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
						state = HEX_INTEGER_START + 1 ;
					}
					else
					{
						state = REJECT_STATE ;
					}
				}
				break ;

				case HEX_INTEGER_START+1:
				{
					if ( ProvAnalyser :: IsHex ( token ) )
					{
						state = HEX_INTEGER_START + 1 ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProvAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case OCT_INTEGER_START:
				{
					if ( ProvAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProvAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 3 ) + ProvAnalyser :: OctWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case DEC_INTEGER_START:
				{
					if ( ProvAnalyser :: IsDecimal ( token ) )
					{
						negativeDatum = ( token - 48 ) ;
						state = DEC_INTEGER_START + 1 ;
					}
					else 
					if ( ProvAnalyser :: IsWhitespace ( token ) ) 
					{
						state = DEC_INTEGER_START ;
					}
					else state = REJECT_STATE ;
				}	
				break ;

				case DEC_INTEGER_START+1:
				{
					if ( ProvAnalyser :: IsDecimal ( token ) )
					{	
						state = DEC_INTEGER_START + 1 ;

						if ( positive )
						{
							if ( positiveDatum > positiveMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( positiveDatum == positiveMagicMult ) 
							{
								if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
								{
									state = REJECT_STATE ;
								}
							}
						}
						else
						{
							if ( negativeDatum > negativeMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( negativeDatum == negativeMagicMult ) 
							{
								if ( negative ) 
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicNegDigit ) 
									{
										state = REJECT_STATE ;
									}
								}
								else
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicPosDigit ) 
									{
										positiveDatum = negativeDatum ;
										positive = TRUE ;
									}
								}
							}
						}

						if ( positive )
						{
							positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
						}
						else
						{
							negativeDatum = negativeDatum * 10 + ( token - 48 ) ;
						}
					}
					else
					{
						if ( negative )
						{
							if ( ! unSignedIntegersOnly )
							{
								lexicon->token = ProvLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum * -1 ;
							}
							else
							{
								state = REJECT_STATE ;
							}
						}
						else if ( positive )
						{
							lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = positiveDatum ;
						}
						else
						{
							if ( unSignedIntegersOnly )
							{
								lexicon->token = ProvLexicon :: UNSIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
							else
							{
								lexicon->token = ProvLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
						}

						state = ACCEPT_STATE ;

						position -- ;
					}
				}	
				break ;

				case ACCEPT_STATE:
				case REJECT_STATE:
				default:
				{
					state = REJECT_STATE ;
				} ;
				break ;
			}
		}

		position ++ ;
	}

	status = ( state != REJECT_STATE ) ;

	return lexicon ;
}

BOOL ProvAnalyser :: IsLeadingDecimal ( wchar_t token )
{
	return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL ProvAnalyser :: IsDecimal ( wchar_t token )
{
	return iswdigit ( token ) ;
}

BOOL ProvAnalyser :: IsHex ( wchar_t token )
{
	return iswxdigit ( token ) ;
}
	
BOOL ProvAnalyser :: IsWhitespace ( wchar_t token )
{
	return iswspace ( token ) ;
}

BOOL ProvAnalyser :: IsOctal ( wchar_t token )
{
	return ( token >= L'0' && token <= L'7' ) ;
}

BOOL ProvAnalyser :: IsAlpha ( wchar_t token )
{
	return iswalpha ( token ) ;
}

BOOL ProvAnalyser :: IsAlphaNumeric ( wchar_t token )
{
	return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL ProvAnalyser :: IsEof ( wchar_t token )
{
	return token == 0 ;
}

ULONG ProvAnalyser :: OctWCharToDecInteger ( wchar_t token ) 
{
	return token - L'0' ;
}

ULONG ProvAnalyser :: HexWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else if ( token >= L'a' && token <= L'f' )
	{
		return token - L'a' + 10 ;
	}
	else if ( token >= L'A' && token <= L'F' )
	{
		return token - L'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProvAnalyser :: DecWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else
	{
		return 0 ;
	}
}

wchar_t ProvAnalyser :: DecIntegerToOctWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProvAnalyser :: DecIntegerToDecWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProvAnalyser :: DecIntegerToHexWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return L'a' + ( integer - 10 ) ;
	}
	else
	{
		return L'0' ;
	}
}

ULONG ProvAnalyser :: OctCharToDecInteger ( char token ) 
{
	return token - '0' ;
}

ULONG ProvAnalyser :: HexCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else if ( token >= 'a' && token <= 'f' )
	{
		return token - 'a' + 10 ;
	}
	else if ( token >= 'A' && token <= 'F' )
	{
		return token - 'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProvAnalyser :: DecCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else
	{
		return 0 ;
	}
}

char ProvAnalyser :: DecIntegerToOctChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProvAnalyser :: DecIntegerToDecChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProvAnalyser :: DecIntegerToHexChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return 'a' + ( integer - 10 ) ;
	}
	else
	{
		return '0' ;
	}
}

ProvNegativeRangedType :: ProvNegativeRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	if ( rangeValues ) 
	{
		status = Parse ( rangeValues ) ;
	}
}

ProvNegativeRangedType :: ProvNegativeRangedType ( const ProvNegativeRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.rangedValues.GetHeadPosition () ;
	while ( position )
	{
		ProvNegativeRangeType rangeType = copy.rangedValues.GetNext ( position ) ; 
		rangedValues.AddTail ( rangeType ) ;
	}
}

ProvNegativeRangedType :: ~ProvNegativeRangedType ()
{
	delete pushBack ;
	rangedValues.RemoveAll () ;
}


void ProvNegativeRangedType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvNegativeRangedType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get () ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvNegativeRangedType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	status = ( lexicon->GetToken () == tokenType ) ;
	return status ? lexicon : NULL ;
}

BOOL ProvNegativeRangedType :: Check ( const LONG &value )
{
	POSITION position = rangedValues.GetHeadPosition () ;
	if ( position )
	{
		while ( position )
		{
			ProvNegativeRangeType rangeType = rangedValues.GetNext ( position ) ;
			if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
			{
				return TRUE ;
			}
		}

		return FALSE ;
	}

	return TRUE ; 

}

BOOL ProvNegativeRangedType :: Parse ( const wchar_t *rangeValues )
{
	BOOL status = TRUE ;

	analyser.Set ( rangeValues ) ;

	return RangeDef () && RecursiveDef () ;
}

BOOL ProvNegativeRangedType :: RangeDef ()
{
	BOOL status = TRUE ;

	LONG lowerRange = 0 ;
	LONG upperRange = 0 ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: SIGNED_INTEGER_ID:
		{
			lowerRange = lookAhead->GetValue()->signedInteger ;

			ProvLexicon *lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case ProvLexicon :: DOTDOT_ID:
				{
					ProvLexicon *lookAhead = Get () ;
					switch ( lookAhead->GetToken () ) 
					{
						case ProvLexicon :: SIGNED_INTEGER_ID:
						{
							upperRange = lookAhead->GetValue()->signedInteger ;
							ProvNegativeRangeType rangeType ( lowerRange , upperRange ) ;
							rangedValues.AddTail ( rangeType ) ;
						}
						break ;

						default:
						{
							status = FALSE ;
						}
						break ;
					}
				}
				break ;

				case ProvLexicon :: EOF_ID:
				case ProvLexicon :: COMMA_ID:
				{
					lowerRange = lookAhead->GetValue()->signedInteger ;
					ProvNegativeRangeType rangeType ( lowerRange , lowerRange ) ;
					rangedValues.AddTail ( rangeType ) ;

					PushBack () ;
				} 
				break ;

				default:
				{
					status = FALSE ;
				}
				break ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvNegativeRangedType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			RangeDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

ProvPositiveRangedType :: ProvPositiveRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	if ( rangeValues ) 
	{
		status = Parse ( rangeValues ) ;
	}
}

ProvPositiveRangedType :: ProvPositiveRangedType ( const ProvPositiveRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.rangedValues.GetHeadPosition () ;
	while ( position )
	{
		ProvPositiveRangeType rangeType = copy.rangedValues.GetNext ( position ) ;
		rangedValues.AddTail ( rangeType ) ;
	}
}

ProvPositiveRangedType :: ~ProvPositiveRangedType ()
{
	delete pushBack ;
	rangedValues.RemoveAll () ;
}

void ProvPositiveRangedType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvPositiveRangedType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvPositiveRangedType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	status = ( lexicon->GetToken () == tokenType ) ;
	return status ? lexicon : NULL ;
}

BOOL ProvPositiveRangedType :: Check ( const ULONG &value )
{
	POSITION position = rangedValues.GetHeadPosition () ;
	if ( position )
	{
		while ( position )
		{
			ProvPositiveRangeType rangeType = rangedValues.GetNext ( position ) ;
			if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
			{
				return TRUE ;
			}
		}

		return FALSE ;
	}	

	return TRUE ;
}

BOOL ProvPositiveRangedType :: Parse ( const wchar_t *rangeValues )
{
	BOOL status = TRUE ;

	analyser.Set ( rangeValues ) ;

	return RangeDef () && RecursiveDef () ;
}

BOOL ProvPositiveRangedType :: RangeDef ()
{
	BOOL status = TRUE ;

	ULONG lowerRange = 0 ;
	ULONG upperRange = 0 ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			lowerRange = lookAhead->GetValue()->unsignedInteger ;

			ProvLexicon *lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case ProvLexicon :: DOTDOT_ID:
				{
					ProvLexicon *lookAhead = Get () ;
					switch ( lookAhead->GetToken () ) 
					{
						case ProvLexicon :: UNSIGNED_INTEGER_ID:
						{
							upperRange = lookAhead->GetValue()->unsignedInteger ;
							ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
							rangedValues.AddTail ( rangeType ) ;
						}
						break ;

						case ProvLexicon :: SIGNED_INTEGER_ID:
						{
							if ( lookAhead->GetValue()->signedInteger >= 0 )
							{
								upperRange = lookAhead->GetValue()->unsignedInteger ;
								ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
								rangedValues.AddTail ( rangeType ) ;
							}
							else
							{
								status = FALSE ;
							}
						}
						break ;

						default:
						{
							status = FALSE ;
						}
						break ;
					}
				}
				break ;

				case ProvLexicon :: EOF_ID:
				case ProvLexicon :: COMMA_ID:
				{
					ProvPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
					rangedValues.AddTail ( rangeType ) ;

					PushBack () ;
				} 
				break ;

				default:
				{
					status = FALSE ;
				}
				break ;
			}
		}
		break ;

		case ProvLexicon :: SIGNED_INTEGER_ID:
		{
			lowerRange = lookAhead->GetValue()->signedInteger ;
			if ( lowerRange > 0 )
			{
				ProvLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: DOTDOT_ID:
					{
						ProvLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case ProvLexicon :: UNSIGNED_INTEGER_ID:
							{
								upperRange = lookAhead->GetValue()->unsignedInteger ;
								ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
								rangedValues.AddTail ( rangeType ) ;
							}
							break ;

							case ProvLexicon :: SIGNED_INTEGER_ID:
							{
								if ( lookAhead->GetValue()->signedInteger >= 0 )
								{
									upperRange = lookAhead->GetValue()->signedInteger ;
									ProvPositiveRangeType rangeType ( lowerRange , upperRange ) ;
									rangedValues.AddTail ( rangeType ) ;
								}
								else
								{
									status = 0 ;
								}
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					case ProvLexicon :: EOF_ID:
					case ProvLexicon :: COMMA_ID:
					{
						ProvPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
						rangedValues.AddTail ( rangeType ) ;

						PushBack () ;
					} 
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			else
			{
				status = FALSE ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvPositiveRangedType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			RangeDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvInstanceType :: IsValid () const
{
	return status ;
}

BOOL ProvInstanceType :: IsNull () const
{
	return m_IsNull ;
}

ProvInstanceType :: operator void *() 
{ 
	return status ? this : NULL ; 
} 

ProvNullType :: ProvNullType ( const ProvNull &nullArg )
{
}

ProvNullType :: ProvNullType ( const ProvNullType &nullArg )
{
}

ProvNullType :: ProvNullType ()
{
}

ProvNullType :: ~ProvNullType ()
{
}

BOOL ProvNullType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = TRUE;
	}

	return bResult;
}


ProvInstanceType *ProvNullType :: Copy () const 
{
	return new ProvNullType ( *this ) ;
}

wchar_t *ProvNullType :: GetStringValue () const 
{
	wchar_t *returnValue = new wchar_t [ 1 ] ;
	returnValue [ 0 ] = 0L ;
	return returnValue ;
}

ProvIntegerType :: ProvIntegerType ( 

	const ProvIntegerType &integerArg 

) : ProvInstanceType ( integerArg ) , ProvNegativeRangedType ( integerArg ) , integer ( integerArg.integer ) 
{
}

ProvIntegerType :: ProvIntegerType ( 

	const ProvInteger &integerArg ,
	const wchar_t *rangeValues

) : ProvNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
	ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: IsValid () ) ;
}

ProvIntegerType :: ProvIntegerType ( 

	const wchar_t *integerArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvNegativeRangedType ( rangeValues ) , integer ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( integerArg ) && ProvNegativeRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: Check ( integer.GetValue () ) ) ;
	}
}

ProvIntegerType :: ProvIntegerType ( 

	const LONG integerArg ,
	const wchar_t *rangeValues 

) :  ProvNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
	ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: Check ( integer.GetValue () ) ) ;
	}
}

ProvIntegerType :: ProvIntegerType ( const wchar_t *rangeValues ) : ProvNegativeRangedType ( rangeValues ) , 
																	ProvInstanceType ( TRUE , TRUE ) , 
																	integer ( 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvNegativeRangedType :: IsValid () ) ;
}

ProvIntegerType :: ~ProvIntegerType () 
{
}

BOOL ProvIntegerType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = integer.GetValue() == ((const ProvIntegerType&)value).integer.GetValue();
	}

	return bResult;
}


ProvInstanceType *ProvIntegerType :: Copy () const 
{
	return new ProvIntegerType ( *this ) ;
}

BOOL ProvIntegerType :: Parse ( const wchar_t *integerArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( integerArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: SIGNED_INTEGER_ID:
		{
			integer.SetValue ( lookAhead->GetValue ()->signedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

wchar_t *ProvIntegerType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		wchar_t stringValue [ 40 ] ;
		_ltow ( integer.GetValue () , stringValue , 10 );
		returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
		wcscpy ( returnValue , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

LONG ProvIntegerType :: GetValue () const
{
	return integer.GetValue () ;
}

ProvGaugeType :: ProvGaugeType ( 

	const ProvGauge &gaugeArg ,
	const wchar_t *rangeValues
	
) : ProvPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
	}
}

ProvGaugeType :: ProvGaugeType ( 

	const ProvGaugeType &gaugeArg 

) :  ProvInstanceType ( gaugeArg ) , ProvPositiveRangedType ( gaugeArg ) , gauge ( gaugeArg.gauge ) 
{
}

ProvGaugeType :: ProvGaugeType ( 

	const wchar_t *gaugeArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvPositiveRangedType ( rangeValues ) , gauge ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( gaugeArg ) && ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
	}
}

ProvGaugeType :: ProvGaugeType ( 

	const ULONG gaugeArg ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
	}
}

ProvGaugeType :: ProvGaugeType ( const wchar_t *rangeValues ) : ProvPositiveRangedType ( rangeValues ) , 
																ProvInstanceType ( TRUE , TRUE ) , 
																gauge ( 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
}

ProvGaugeType :: ~ProvGaugeType () 
{
}

BOOL ProvGaugeType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = gauge.GetValue() == ((const ProvGaugeType&)value).gauge.GetValue();
	}

	return bResult;
}

ProvInstanceType *ProvGaugeType :: Copy () const 
{
	return new ProvGaugeType ( *this ) ;
}

BOOL ProvGaugeType :: Parse ( const wchar_t *gaugeArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( gaugeArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			gauge.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

wchar_t *ProvGaugeType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull ()  )
	{
		wchar_t stringValue [ 40 ] ;
		_ultow ( gauge.GetValue () , stringValue , 10 );
		returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
		wcscpy ( returnValue , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

ULONG ProvGaugeType :: GetValue () const
{
	return gauge.GetValue () ;
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const ProvTimeTicks &timeTicksArg 

) : timeTicks ( timeTicksArg ) 
{
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const ProvTimeTicksType &timeTicksArg 

) : ProvInstanceType ( timeTicksArg ) , timeTicks ( timeTicksArg.timeTicks ) 
{
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const wchar_t *timeTicksArg

) :	ProvInstanceType ( FALSE ) , timeTicks ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( timeTicksArg ) ) ;
}

ProvTimeTicksType :: ProvTimeTicksType ( 

	const ULONG timeTicksArg

) : timeTicks ( timeTicksArg ) 
{
}

ProvTimeTicksType :: ProvTimeTicksType () : ProvInstanceType ( TRUE , TRUE ) , 
											timeTicks ( 0 ) 
{
}

ProvTimeTicksType :: ~ProvTimeTicksType () 
{
}

BOOL ProvTimeTicksType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = timeTicks.GetValue() == ((const ProvTimeTicksType&)value).timeTicks.GetValue();
	}

	return bResult;
}

ProvInstanceType *ProvTimeTicksType :: Copy () const 
{
	return new ProvTimeTicksType ( *this ) ;
}

BOOL ProvTimeTicksType :: Parse ( const wchar_t *timeTicksArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( timeTicksArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			timeTicks.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

wchar_t *ProvTimeTicksType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull ()  )
	{
		wchar_t stringValue [ 40 ] ;
		_ultow ( timeTicks.GetValue () , stringValue , 10 );
		returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
		wcscpy ( returnValue , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

ULONG ProvTimeTicksType :: GetValue () const
{
	return timeTicks.GetValue () ;
}

ProvCounterType :: ProvCounterType ( const ProvCounter &counterArg ) : counter ( counterArg ) 
{
}

ProvCounterType :: ProvCounterType ( const ProvCounterType &counterArg ) : ProvInstanceType ( counterArg ) , counter ( counterArg.counter ) 
{
}

ProvInstanceType *ProvCounterType :: Copy () const 
{
	return new ProvCounterType ( *this ) ;
}

ProvCounterType :: ProvCounterType ( const wchar_t *counterArg ) :	ProvInstanceType ( FALSE ) , 
																counter ( 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL ProvCounterType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = counter.GetValue() == ((const ProvCounterType&)value).counter.GetValue();
	}

	return bResult;
}

BOOL ProvCounterType :: Parse ( const wchar_t *counterArg ) 
{
	BOOL status = TRUE ;

	ProvAnalyser analyser ;

	analyser.Set ( counterArg ) ;

	ProvLexicon *lookAhead = analyser.Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: UNSIGNED_INTEGER_ID:
		{
			counter.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
		}
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	delete lookAhead ;

	return status ;
}

ProvCounterType :: ProvCounterType ( const ULONG counterArg ) : counter ( counterArg ) 
{
}

ProvCounterType :: ProvCounterType () : ProvInstanceType ( TRUE , TRUE ) , 
										counter ( 0 ) 
{
}

ProvCounterType :: ~ProvCounterType () 
{
}

wchar_t *ProvCounterType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		wchar_t stringValue [ 40 ] ;
		_ultow ( counter.GetValue () , stringValue , 10 );
		returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
		wcscpy ( returnValue , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

ULONG ProvCounterType :: GetValue () const
{
	return counter.GetValue () ;
}

ProvCounter64Type :: ProvCounter64Type ( const ProvCounter64Type &counterArg ) : ProvInstanceType ( counterArg ) , high ( counterArg.high ) , low ( counterArg.low )
{
}

ProvInstanceType *ProvCounter64Type :: Copy () const 
{
	return new ProvCounter64Type ( *this ) ;
}

ProvCounter64Type :: ProvCounter64Type ( const wchar_t *counterArg ) :	ProvInstanceType ( FALSE ) , high ( 0 ) , low ( 0 )
{
	ProvInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL ProvCounter64Type :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = (low == ((const ProvCounter64Type&)value).low) &&
					(high == ((const ProvCounter64Type&)value).high);
	}

	return bResult;
}

BOOL ProvCounter64Type :: Parse ( const wchar_t *counterArg ) 
{
	BOOL status = TRUE ;

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000

	ULONG state = 0 ;

	ULONG position = 0 ;
/* 
 * Integer Definitions
 */

	BOOL negative = FALSE ;
	BOOL positive = FALSE ;

	DWORDLONG positiveMagicMult = ( DWORDLONG ) ( ( ( DWORDLONG ) -1 ) / 10L ) ; 
	DWORDLONG positiveMagicPosDigit = 5 ;
	DWORDLONG positiveDatum = 0 ;	
	DWORDLONG unsignedInteger = 0 ;
/*
 * Token Definitions
 */

	ULONG token_start = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = counterArg [ position ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsLeadingDecimal ( token ) )
				{
					state = DEC_INTEGER_START + 1  ;
					positiveDatum = ( token - 48 ) ;
				}
				else if ( token == L'+' )
				{
					state = DEC_INTEGER_START ;
				}
				else if ( token == L'-' ) 
				{
					state = DEC_INTEGER_START ;
				}
				else if ( token == L'0' )
				{
					state = 1 ;
				}
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) 
				{
					state = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( token == L'x' || token == L'X' )
				{
					state = HEX_INTEGER_START ;				
				}
				else if ( ProvAnalyser :: IsOctal ( token ) )
				{
					state = OCT_INTEGER_START ;
					positiveDatum = ( token - 48 ) ;
				}
				else
				{
					unsignedInteger = 0 ;

					state = ACCEPT_STATE ;
					position -- ;
				}
			}
			break ;

			case HEX_INTEGER_START:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					positiveDatum = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = HEX_INTEGER_START + 1 ;
				}
				else
				{
					state = REJECT_STATE ;
				}
			}
			break ;

			case HEX_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					state = HEX_INTEGER_START + 1 ;

					if ( positiveDatum > positiveMagicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( positiveDatum == positiveMagicMult ) 
					{
						if ( ProvAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					positiveDatum = ( positiveDatum << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
				}
				else
				{
					unsignedInteger = positiveDatum ;
					state = ACCEPT_STATE ;

					position -- ;
				}
			}
			break ;

			case OCT_INTEGER_START:
			{
				if ( ProvAnalyser :: IsOctal ( token ) )
				{
					state = OCT_INTEGER_START ;

					if ( positiveDatum > positiveMagicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( positiveDatum == positiveMagicMult ) 
					{
						if ( ProvAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					positiveDatum = ( positiveDatum << 3 ) + ProvAnalyser :: OctWCharToDecInteger ( token ) ;
				}
				else
				{
					unsignedInteger = positiveDatum ;
					state = ACCEPT_STATE ;

					position -- ;
				}
			}
			break ;

			case DEC_INTEGER_START:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					positiveDatum = ( token - 48 ) ;
					state = DEC_INTEGER_START + 1 ;
				}
				else 
				if ( ProvAnalyser :: IsWhitespace ( token ) ) 
				{
					state = DEC_INTEGER_START ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case DEC_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = DEC_INTEGER_START + 1 ;

					if ( positiveDatum > positiveMagicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( positiveDatum == positiveMagicMult ) 
					{
						if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
				}
				else
				{
					unsignedInteger = positiveDatum ;

					state = ACCEPT_STATE ;

					position -- ;
				}
			}	
			break ;

			case ACCEPT_STATE:
			case REJECT_STATE:
			default:
			{
				state = REJECT_STATE ;
			} ;
			break ;
		}

		position ++ ;
	}

	status = ( state != REJECT_STATE ) ;
	if ( status )
	{
		high = ( ULONG ) ( unsignedInteger & 0xFFFFFFFF ) ;
		low =( ULONG ) ( unsignedInteger >> 32 ) ;
	}

	return status ;
}

ProvCounter64Type :: ProvCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) : high ( counterHighArg ) , low ( counterLowArg ) 
{
}

ProvCounter64Type :: ProvCounter64Type ( const ProvCounter64 &counterArg ) : high ( counterArg.GetHighValue () ) , low ( counterArg.GetLowValue () ) 
{
}

ProvCounter64Type :: ProvCounter64Type () : ProvInstanceType ( TRUE , TRUE ) , high ( 0 ) , low ( 0 )
{
}

ProvCounter64Type :: ~ProvCounter64Type () 
{
}

wchar_t *ProvCounter64Type :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		wchar_t stringValue [ 40 ] ;
		DWORDLONG t_Integer = ( high >> 32 ) + low ;
		_ui64tow ( t_Integer , stringValue , 40 );
		returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
		wcscpy ( returnValue , stringValue ) ;
	}
	else 
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

void ProvCounter64Type :: GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const
{
	counterHighArg = high ;
	counterLowArg = low ;
}

ProvIpAddressType :: ProvIpAddressType ( const ProvIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvIpAddressType :: ProvIpAddressType ( const ProvIpAddressType &ipAddressArg ) : ProvInstanceType ( ipAddressArg ) , ipAddress ( ipAddressArg.ipAddress ) 
{
}

ProvInstanceType *ProvIpAddressType :: Copy () const 
{
	return new ProvIpAddressType ( *this ) ;
}

ProvIpAddressType :: ProvIpAddressType ( const wchar_t *ipAddressArg ) : ProvInstanceType ( FALSE ) , 
																			ipAddress ( ( ULONG ) 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( ipAddressArg ) ) ;
}

BOOL ProvIpAddressType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = ipAddress.GetValue() == ((const ProvIpAddressType&)value).ipAddress.GetValue();
	}

	return bResult;
}


BOOL ProvIpAddressType :: Parse ( const wchar_t *ipAddressArg ) 
{
	BOOL status = TRUE ;
/*
 *	Datum fields.
 */

	ULONG datumA = 0 ;
	ULONG datumB = 0 ;
	ULONG datumC = 0 ;
	ULONG datumD = 0 ;

/*
 *	Parse input for dotted decimal IP Address.
 */

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = ipAddressArg [ position ++ ] ;

		switch ( state ) 
		{
/*
 *	Parse first field 'A'.
 */

			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = ( token - 48 ) ;
					state = 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 2 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 3 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

/*
 *	Parse first field 'B'.
 */
            case 4:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                { 
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *	Parse first field 'C'.
 */
           	case 8:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *	Parse first field 'D'.
 */
            case 12:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
            }
            break ;
 
			default:
			{
				state = REJECT_STATE ;
			}
			break ;
		}
	}


/*
 *	Check boundaries for IP fields.
 */

	status = ( state != REJECT_STATE ) ;

	if ( state == ACCEPT_STATE )
	{
		status = status && (  ( datumA < 256 ) ? TRUE : FALSE ) ;
		status = status && (  ( datumB < 256 ) ? TRUE : FALSE ) ;
		status = status && (  ( datumC < 256 ) ? TRUE : FALSE ) ;
		status = status && (  ( datumD < 256 ) ? TRUE : FALSE ) ;
	}

	ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
	ipAddress.SetValue ( data ) ;

	return status ;	

}

ProvIpAddressType :: ProvIpAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvIpAddressType :: ProvIpAddressType () : ProvInstanceType ( TRUE , TRUE ) , 
											ipAddress ( ( ULONG ) 0 ) 
{
}

ProvIpAddressType :: ~ProvIpAddressType () 
{
}

wchar_t *ProvIpAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG ipAddressValue = ipAddress.GetValue () ;

		wchar_t stringAValue [ 40 ] ;
		_itow ( ipAddressValue >> 24 , stringAValue , 10 );

		wchar_t stringBValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

		wchar_t stringCValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

		wchar_t stringDValue [ 40 ] ;
		_itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

		ULONG totalLength = wcslen ( stringAValue ) +
							wcslen ( stringBValue ) +
							wcslen ( stringCValue ) +
							wcslen ( stringDValue ) ;

		returnValue = new wchar_t [ totalLength + 4 + 1 ] ;
		wcscpy ( returnValue , stringAValue ) ;
		wcscat ( returnValue , L"." ) ;
		wcscat ( returnValue , stringBValue ) ;
		wcscat ( returnValue , L"." ) ;
		wcscat ( returnValue , stringCValue ) ;
		wcscat ( returnValue , L"." ) ;
		wcscat ( returnValue , stringDValue ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"0.0.0.0" ) ;
	}

	return returnValue ;
}

ULONG ProvIpAddressType :: GetValue () const
{
	return ipAddress.GetValue () ;
}

ProvNetworkAddressType :: ProvNetworkAddressType ( const ProvIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvNetworkAddressType :: ProvNetworkAddressType ( const ProvNetworkAddressType &networkAddressArg ) : ProvInstanceType ( networkAddressArg ) , ipAddress ( networkAddressArg.ipAddress ) 
{
}

ProvInstanceType *ProvNetworkAddressType :: Copy () const 
{
	return new ProvNetworkAddressType ( *this ) ;
}

ProvNetworkAddressType :: ProvNetworkAddressType ( const wchar_t *networkAddressArg ) :	ProvInstanceType ( FALSE ) , 
																						ipAddress ( ( ULONG ) 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( networkAddressArg ) ) ;
}

BOOL ProvNetworkAddressType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = ipAddress.GetValue() == ((const ProvNetworkAddressType&)value).ipAddress.GetValue();
	}

	return bResult;
}

BOOL ProvNetworkAddressType :: Parse ( const wchar_t *networkAddressArg ) 
{
	BOOL status = TRUE ;

/*
 *	Datum fields.
 */

	ULONG datumA = 0 ;
	ULONG datumB = 0 ;
	ULONG datumC = 0 ;
	ULONG datumD = 0 ;

/*
 *	Parse input for dotted decimal IP Address.
 */

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = networkAddressArg [ position ++ ] ;

		switch ( state ) 
		{
/*
 *	Parse first field 'A'.
 */

			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = ( token - 48 ) ;
					state = 1 ;
				}
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 0 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 2 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 3 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

/*
 *	Parse first field 'B'.
 */
            case 4:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                { 
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *	Parse first field 'C'.
 */
           	case 8:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *	Parse first field 'D'.
 */
            case 12:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
				if ( ProvAnalyser :: IsWhitespace ( token ) ) state = 15 ; 
                else if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
            }
            break ;
 
			default:
			{
				state = REJECT_STATE ;
			}
			break ;
		}
	}


/*
 *	Check boundaries for IP fields.
 */

	status = ( state != REJECT_STATE ) ;

	if ( state == ACCEPT_STATE )
	{
		status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
	}

	ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
	ipAddress.SetValue ( data ) ;

	return status ;	
}


ProvNetworkAddressType :: ProvNetworkAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

ProvNetworkAddressType :: ProvNetworkAddressType () : ProvInstanceType ( TRUE , TRUE ) , 
														ipAddress ( ( ULONG ) 0 ) 
{
}

ProvNetworkAddressType :: ~ProvNetworkAddressType () 
{
}

wchar_t *ProvNetworkAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG ipAddressValue = ipAddress.GetValue () ;

		wchar_t stringAValue [ 40 ] ;
		_itow ( ipAddressValue >> 24 , stringAValue , 10 );

		wchar_t stringBValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

		wchar_t stringCValue [ 40 ] ;
		_itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

		wchar_t stringDValue [ 40 ] ;
		_itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

		ULONG totalLength = wcslen ( stringAValue ) +
							wcslen ( stringBValue ) +
							wcslen ( stringCValue ) +
							wcslen ( stringDValue ) ;

		returnValue = new wchar_t [ totalLength + 4 + 1 ] ;
		wcscpy ( returnValue , stringAValue ) ;
		wcscat ( returnValue , L"." ) ;
		wcscat ( returnValue , stringBValue ) ;
		wcscat ( returnValue , L"." ) ;
		wcscat ( returnValue , stringCValue ) ;
		wcscat ( returnValue , L"." ) ;
		wcscat ( returnValue , stringDValue ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"0.0.0.0" ) ;
	}

	return returnValue ;
}

ULONG ProvNetworkAddressType :: GetValue () const
{
	return ipAddress.GetValue () ;
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const ProvObjectIdentifier &objectIdentifierArg ) : objectIdentifier ( objectIdentifierArg ) 
{
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const ProvObjectIdentifierType &objectIdentifierArg ) : ProvInstanceType ( objectIdentifierArg ) , objectIdentifier ( objectIdentifierArg.objectIdentifier ) 
{
}

ProvInstanceType *ProvObjectIdentifierType :: Copy () const 
{
	return new ProvObjectIdentifierType ( *this ) ;
}

ProvObjectIdentifierType &ProvObjectIdentifierType :: operator=(const ProvObjectIdentifierType &to_copy )
{
	m_IsNull = to_copy.m_IsNull ;
	status = to_copy.status ;
	objectIdentifier = to_copy.objectIdentifier;

	return *this;
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const wchar_t *objectIdentifierArg ) :	ProvInstanceType ( FALSE ) , 
																objectIdentifier ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( objectIdentifierArg ) ) ;
}

BOOL ProvObjectIdentifierType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = objectIdentifier == ((const ProvObjectIdentifierType&)value).objectIdentifier;
	}

	return bResult;
}

BOOL ProvObjectIdentifierType :: Parse ( const wchar_t *objectIdentifierArg ) 
{
#define AVERAGE_OID_LENGTH 20

	BOOL status = TRUE ;

	ULONG reallocLength = AVERAGE_OID_LENGTH ;
	ULONG *reallocArray = ( ULONG * ) malloc ( sizeof ( ULONG ) * reallocLength ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}
	
	ULONG magicMult = ( ( ULONG ) - 1 ) / 10 ; 
	ULONG magicDigit = 5 ;
	ULONG datum = 0 ;	
	ULONG length = 0 ;

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = objectIdentifierArg [ position ++ ] ;

		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = 1 ;
					datum = ( token - 48 ) ;
				}
				else if ( ProvAnalyser :: IsWhitespace ( token ) ) 
				{
					state = 0 ;
				}
				else if ( token == 0 ) 
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = 1 ;

					if ( datum > magicMult )
					{
						state = REJECT_STATE ;
					}
					else if ( datum == magicMult ) 
					{
						if ( ( ULONG ) ( token - 48 ) > magicDigit ) 
						{
							state = REJECT_STATE ;
						}
					}

					datum = datum * 10 + ( token - 48 ) ;
				}
				else
				if ( token == L'.' ) 
				{
					reallocArray [ length ] = datum ;
					length ++ ;
					if ( length >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						reallocArray = ( ULONG * ) realloc ( reallocArray , reallocLength ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					state = 2 ;
				}
				else if ( token == 0 ) 
				{
					reallocArray [ length ] = datum ;

					length ++ ;
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = 1 ;
					datum = ( token - 48 ) ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	objectIdentifier.SetValue ( reallocArray , length ) ;

	free ( reallocArray ) ;

	if ( length < 2 ) 
	{
		status = FALSE ;
	}

	return status ;
}

ProvObjectIdentifierType :: ProvObjectIdentifierType ( const ULONG *value , const ULONG valueLength ) : objectIdentifier ( value , valueLength ) 
{
}

ProvObjectIdentifierType :: ProvObjectIdentifierType () : ProvInstanceType ( TRUE , TRUE ) , 
										objectIdentifier ( NULL , 0 ) 
{
}

ProvObjectIdentifierType :: ~ProvObjectIdentifierType () 
{
}

wchar_t *ProvObjectIdentifierType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OID_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG objectIdentifierLength = objectIdentifier.GetValueLength () ;		
		ULONG index = 0 ;
		while ( index < objectIdentifierLength ) 
		{
			wchar_t stringValue [ 40 ] ;
			_ultow ( objectIdentifier [ index ] , stringValue , 10 );
			ULONG stringLength = wcslen ( stringValue ) ;

			if ( ( totalLength + stringLength + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
				reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

				if (reallocArray == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}
			}

			wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
			totalLength = totalLength + stringLength ;

			index ++ ;
			if ( index < objectIdentifierLength )
			{
				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
	
					if (reallocArray == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}
				}

				wcscpy ( & reallocArray [ totalLength ] , L"." ) ;
				totalLength ++ ;
			}
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( objectIdentifierLength )
		{
			wcscpy ( returnValue , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"0.0" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"0.0" ) ;
	}

	return returnValue ;
}

ULONG *ProvObjectIdentifierType :: GetValue () const
{
	return objectIdentifier.GetValue () ;
}

ULONG ProvObjectIdentifierType :: GetValueLength () const
{
	return objectIdentifier.GetValueLength () ;
}

#define AVERAGE_OCTET_LENGTH 256 

ProvOpaqueType :: ProvOpaqueType ( 

	const ProvOpaque &opaqueArg ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , opaque ( opaqueArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
	}
}

ProvOpaqueType :: ProvOpaqueType ( 

	const ProvOpaqueType &opaqueArg 

) : ProvInstanceType ( opaqueArg ) , ProvPositiveRangedType ( opaqueArg ) , opaque ( opaqueArg.opaque ) 
{
}

ProvOpaqueType :: ProvOpaqueType ( 

	const wchar_t *opaqueArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvPositiveRangedType ( rangeValues ) , opaque ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( opaqueArg ) && ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
	}
}

ProvOpaqueType :: ProvOpaqueType ( 

	const UCHAR *value , 
	const ULONG valueLength ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , opaque ( value , valueLength ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
	}
}

ProvOpaqueType :: ProvOpaqueType ( const wchar_t *rangeValues ) :	ProvInstanceType ( TRUE , TRUE ) , 
																	ProvPositiveRangedType ( rangeValues ) ,
																	opaque ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
}

ProvOpaqueType :: ~ProvOpaqueType () 
{
}

BOOL ProvOpaqueType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = opaque.Equivalent( ((const ProvOpaqueType&)value).opaque );
	}

	return bResult;
}

ProvInstanceType *ProvOpaqueType :: Copy () const 
{
	return new ProvOpaqueType ( *this ) ;
}

BOOL ProvOpaqueType :: Parse ( const wchar_t *opaqueArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * Oqaque Definitions
 */

	BOOL even = FALSE ;
	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = opaqueArg [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 1 ;
					length ++ ;
					byte = 0 ;
					even = TRUE ;
				}
				else if ( token == 0 )
				{
					state = REJECT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length )
	{
		opaque.SetValue ( reallocArray , length ) ;
	}
	else
	{
		opaque.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

wchar_t *ProvOpaqueType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG opaqueLength = opaque.GetValueLength () ;		
		UCHAR *opaqueArray = opaque.GetValue () ;

		ULONG index = 0 ;
		while ( index < opaqueLength ) 
		{
			wchar_t hexValue [ 40 ] ;
			_ultow ( opaqueArray [ index ] , hexValue , 16 );
			ULONG hexLength = wcslen ( hexValue ) ;

			wchar_t stringValue [ 3 ] ;
			ULONG stringLength = 2 ;

			if ( hexLength == 1 )
			{
				stringValue [ 0 ] = L'0' ;
				stringValue [ 1 ] = hexValue [ 0 ] ;
				stringValue [ 2 ] = 0 ;
			}
			else
			{
				stringValue [ 0 ] = hexValue [ 0 ] ;
				stringValue [ 1 ] = hexValue [ 1 ] ;
				stringValue [ 2 ] = 0 ;
			}

			if ( ( totalLength + stringLength + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
				reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

				if (reallocArray == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}
			}

			wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
			totalLength = totalLength + stringLength ;

			index ++ ;
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( opaqueLength )
		{
			wcscpy ( returnValue , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

UCHAR *ProvOpaqueType :: GetValue () const
{
	return opaque.GetValue () ;
}

ULONG ProvOpaqueType :: GetValueLength () const
{
	return opaque.GetValueLength () ;
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ULONG &fixedLengthArg , 
	const ProvOpaque &opaqueArg 

) : ProvOpaqueType ( opaqueArg , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ProvFixedLengthOpaqueType &opaqueArg 

) : ProvOpaqueType ( opaqueArg ) ,
	ProvFixedType ( opaqueArg )
{
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvInstanceType *ProvFixedLengthOpaqueType :: Copy () const 
{
	return new ProvFixedLengthOpaqueType ( *this ) ;
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *opaqueArg 

) : ProvOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetStatus ( Parse ( opaqueArg ) ) ;
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType ( 

	const ULONG &fixedLengthArg ,
	const UCHAR *value , 
	const ULONG valueLength 

) : ProvOpaqueType ( value , valueLength , NULL ) ,
	ProvFixedType ( fixedLengthArg ) 
{
	if ( opaque.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOpaqueType :: ProvFixedLengthOpaqueType (

	const ULONG &fixedLengthArg

) : ProvOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvFixedLengthOpaqueType :: ~ProvFixedLengthOpaqueType () 
{
}

ProvOctetStringType :: ProvOctetStringType ( 

	const ProvOctetString &octetStringArg ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , octetString ( octetStringArg ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
	}
}

ProvOctetStringType :: ProvOctetStringType ( 

	const ProvOctetStringType &octetStringArg 

) : ProvInstanceType ( octetStringArg ) , ProvPositiveRangedType ( octetStringArg ) , octetString ( octetStringArg.octetString ) 
{
}

ProvOctetStringType :: ProvOctetStringType ( 

	const wchar_t *octetStringArg ,
	const wchar_t *rangeValues

) :	ProvInstanceType ( FALSE ) , ProvPositiveRangedType ( rangeValues ) , octetString ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( Parse ( octetStringArg ) && ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
	}
}

ProvOctetStringType :: ProvOctetStringType ( 

	const UCHAR *value , 
	const ULONG valueLength ,
	const wchar_t *rangeValues

) : ProvPositiveRangedType ( rangeValues ) , octetString ( value , valueLength ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
	if ( ProvInstanceType :: IsValid () )
	{
		ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
	}
}

ProvOctetStringType :: ProvOctetStringType ( const wchar_t *rangeValues ) : ProvPositiveRangedType ( rangeValues ) ,
																			ProvInstanceType ( TRUE , TRUE ) , 
																			octetString ( NULL , 0 ) 
{
	ProvInstanceType :: SetStatus ( ProvPositiveRangedType :: IsValid () ) ;
}

ProvOctetStringType :: ~ProvOctetStringType () 
{
}

BOOL ProvOctetStringType :: Equivalent (IN const ProvInstanceType &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = octetString.Equivalent( ((const ProvOctetStringType&)value).octetString );
	}

	return bResult;
}

ProvInstanceType *ProvOctetStringType :: Copy () const 
{
	return new ProvOctetStringType ( *this ) ;
}

BOOL ProvOctetStringType :: Parse ( const wchar_t *octetStringArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * OctetString Definitions
 */

	BOOL even = FALSE ;
	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = octetStringArg [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;

				even = FALSE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 1 ;
					length ++ ;
					byte = 0 ;
					even = TRUE ;
				}
				else if ( token == 0 )
				{
					state = REJECT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length )
	{
		octetString.SetValue ( reallocArray , length ) ;
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

wchar_t *ProvOctetStringType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		ULONG totalLength = 0 ;
		ULONG octetStringLength = octetString.GetValueLength () ;		
		UCHAR *octetStringArray = octetString.GetValue () ;

		returnValue = new wchar_t [ octetStringLength * 2 + 1 ] ;

		ULONG index = 0 ;
		while ( index < octetStringLength ) 
		{
			wchar_t stringValue [ 3 ] ;

			stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
			stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
			stringValue [ 2 ] = 0 ;

			wcscpy ( & returnValue [ totalLength ] , stringValue ) ;
			totalLength = totalLength + 2 ;

			index ++ ;
		}

		returnValue [ octetStringLength * 2 ] = 0 ;
	}
	else
	{
		ULONG returnValueLength = wcslen ( L"" ) + 1 ;
		returnValue = new wchar_t [ returnValueLength ] ;
		wcscpy ( returnValue , L"" ) ;
	}

	return returnValue ;
}

UCHAR *ProvOctetStringType :: GetValue () const
{
	return octetString.GetValue () ;
}

ULONG ProvOctetStringType :: GetValueLength () const
{
	return octetString.GetValueLength () ;
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ULONG &fixedLengthArg , 
	const ProvOctetString &octetStringArg 

) : ProvOctetStringType ( octetStringArg , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ProvFixedLengthOctetStringType &octetStringArg 

) : ProvOctetStringType ( octetStringArg ) ,
	ProvFixedType ( octetStringArg )
{
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvInstanceType *ProvFixedLengthOctetStringType :: Copy () const 
{
	return new ProvFixedLengthOctetStringType ( *this ) ;
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *octetStringArg 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetStatus ( Parse ( octetStringArg ) ) ;
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType ( 

	const ULONG &fixedLengthArg ,
	const UCHAR *value 

) : ProvOctetStringType ( value , fixedLengthArg , NULL ) ,
	ProvFixedType ( fixedLengthArg ) 
{
	if ( octetString.GetValueLength () != fixedLength )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthOctetStringType :: ProvFixedLengthOctetStringType (

	const ULONG &fixedLengthArg

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
	ProvFixedType ( fixedLengthArg )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvFixedLengthOctetStringType :: ~ProvFixedLengthOctetStringType () 
{
}

ProvMacAddressType :: ProvMacAddressType ( const ProvOctetString &macAddressArg ) : ProvFixedLengthOctetStringType ( 6 , macAddressArg ) 
{
}

ProvMacAddressType :: ProvMacAddressType ( const ProvMacAddressType &macAddressArg ) : ProvFixedLengthOctetStringType ( macAddressArg ) 
{
}

ProvInstanceType *ProvMacAddressType :: Copy () const 
{
	return new ProvMacAddressType ( *this ) ;
}

ProvMacAddressType :: ProvMacAddressType ( const wchar_t *macAddressArg ) : ProvFixedLengthOctetStringType ( 6 )  
{
	ProvInstanceType :: SetStatus ( Parse ( macAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvMacAddressType :: Parse ( const wchar_t *macAddressArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	UCHAR macAddress [ 6 ] ;

/* 
 * MacAddress Definitions
 */

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = macAddressArg [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( length >= 6 ) state = REJECT_STATE ;
				else if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					macAddress [ length ] = ( UCHAR ) byte ;
					state = 2 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( token == L':' ) state = 0 ;
				else if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( status )
	{
		octetString.SetValue ( macAddress , 6 ) ;
	}

	return status ;
}

ProvMacAddressType :: ProvMacAddressType ( const UCHAR *value ) : ProvFixedLengthOctetStringType ( 6 , value ) 
{
}

ProvMacAddressType :: ProvMacAddressType () : ProvFixedLengthOctetStringType ( 6 ) 
{
}

ProvMacAddressType :: ~ProvMacAddressType () 
{
}

wchar_t *ProvMacAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		if ( valueLength != 6 )
			throw ;

		returnValue = new wchar_t [ 18 ] ;

		returnValue [ 2 ] = L':' ;
		returnValue [ 5 ] = L':' ;
		returnValue [ 8 ] = L':' ;
		returnValue [ 11 ] = L':' ;
		returnValue [ 14 ] = L':' ;
		returnValue [ 17 ] = 0 ;

		returnValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 0 ] >> 4 ) ;
		returnValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 0 ] & 0xf ) ;

		returnValue [ 3 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 1 ] >> 4 ) ;
		returnValue [ 4 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 1 ] & 0xf ) ;

		returnValue [ 6 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 2 ] >> 4 ) ;
		returnValue [ 7 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 2 ] & 0xf ) ;

		returnValue [ 9 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 3 ] >> 4 ) ;
		returnValue [ 10 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 3 ] & 0xf ) ;

		returnValue [ 12 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 4 ] >> 4 ) ;
		returnValue [ 13 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 4 ] & 0xf ) ;

		returnValue [ 15 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 5 ] >> 4 ) ;
		returnValue [ 16 ] = ProvAnalyser :: DecIntegerToHexWChar ( value [ 5 ] & 0xf ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvPhysAddressType :: ProvPhysAddressType ( 

	const ProvOctetString &physAddressArg , 
	const wchar_t *rangedValues 

) : ProvOctetStringType ( physAddressArg , rangedValues ) 
{
}

ProvPhysAddressType :: ProvPhysAddressType ( 

	const ProvPhysAddressType &physAddressArg 

) : ProvOctetStringType ( physAddressArg ) 
{
}

ProvInstanceType *ProvPhysAddressType :: Copy () const 
{
	return new ProvPhysAddressType ( *this ) ;
}

ProvPhysAddressType :: ProvPhysAddressType ( 

	const wchar_t *physAddressArg ,
	const wchar_t *rangedValues

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )  
{
	ProvInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * PhyAddress Definitions
 */

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = physAddress [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 3 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L':' )
				{
					state = 1 ;
				}
				else if ( token == 0 )
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length )
	{
		octetString.SetValue ( reallocArray , length ) ;
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

ProvPhysAddressType :: ProvPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) : ProvOctetStringType ( value , valueLength , rangedValues ) 
{
}

ProvPhysAddressType :: ProvPhysAddressType (

	const wchar_t *rangedValues 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues ) 
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvPhysAddressType :: ~ProvPhysAddressType () 
{
}

wchar_t *ProvPhysAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG physAddressLength = octetString.GetValueLength () ;		
		UCHAR *physAddressArray = octetString.GetValue () ;

		ULONG index = 0 ;
		while ( index < physAddressLength ) 
		{
			wchar_t stringValue [ 3 ] ;

			stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
			stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
			stringValue [ 2 ] = 0 ;

			if ( ( totalLength + 2 + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
				reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

				if (reallocArray == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}
			}

			wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
			totalLength = totalLength + 2 ;

			index ++ ;
			if ( index < physAddressLength )
			{
				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

					if (reallocArray == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}
				}

				wcscpy ( & reallocArray [ totalLength ] , L":" ) ;
				totalLength ++ ;
			}
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( physAddressLength )
		{
			wcscpy ( returnValue , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType ( 

	const ULONG &fixedLengthArg ,
	const ProvOctetString &physAddressArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg , physAddressArg ) 
{
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType ( 

	const ProvFixedLengthPhysAddressType &physAddressArg 

) : ProvFixedLengthOctetStringType ( physAddressArg ) 
{
}

ProvInstanceType *ProvFixedLengthPhysAddressType :: Copy () const 
{
	return new ProvFixedLengthPhysAddressType ( *this ) ;
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *physAddressArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
	ProvInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvFixedLengthPhysAddressType :: ProvFixedLengthPhysAddressType (

	const ULONG &fixedLengthArg

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvFixedLengthPhysAddressType :: ~ProvFixedLengthPhysAddressType () 
{
}

BOOL ProvFixedLengthPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
	UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

	if (reallocArray == NULL)
	{
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

/* 
 * PhyAddress Definitions
 */

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = physAddress [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else if ( token == 0 ) state = ACCEPT_STATE ;
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					if ( reallocLength <= length ) 
					{
						reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
						reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					reallocArray [ length ] = ( UCHAR ) byte ;
					state = 3 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L':' )
				{
					state = 1 ;
				}
				else if ( token == 0 )
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( length == fixedLength )
	{
		octetString.SetValue ( reallocArray , length ) ;
	}
	else
	{
		status = FALSE ;
		octetString.SetValue ( NULL , 0 ) ;
	}

	free ( reallocArray ) ;

	return status ;
}

wchar_t *ProvFixedLengthPhysAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG totalLength = 0 ;
		ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
		wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
		
		if (reallocArray == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		ULONG physAddressLength = octetString.GetValueLength () ;		
		UCHAR *physAddressArray = octetString.GetValue () ;

		ULONG index = 0 ;
		while ( index < physAddressLength ) 
		{
			wchar_t stringValue [ 3 ] ;

			stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
			stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
			stringValue [ 2 ] = 0 ;

			if ( ( totalLength + 2 + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
				reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

				if (reallocArray == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}
			}

			wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
			totalLength = totalLength + 2 ;

			index ++ ;
			if ( index < physAddressLength )
			{
				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

					if (reallocArray == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}
				}

				wcscpy ( & reallocArray [ totalLength ] , L":" ) ;
				totalLength ++ ;
			}
		}

		returnValue = new wchar_t [ totalLength + 1 ] ;
		if ( physAddressLength )
		{
			wcscpy ( returnValue , reallocArray ) ;
		}
		else
		{
			returnValue [ 0 ] = 0 ;
		}

		free ( reallocArray ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvDisplayStringType :: ProvDisplayStringType ( 

	const ProvOctetString &displayStringArg ,
	const wchar_t *rangeValues

) : ProvOctetStringType ( displayStringArg , rangeValues ) 
{
}

ProvDisplayStringType :: ProvDisplayStringType ( 

	const ProvDisplayStringType &displayStringArg 

) : ProvOctetStringType ( displayStringArg ) 
{
}

ProvInstanceType *ProvDisplayStringType :: Copy () const 
{
	return new ProvDisplayStringType ( *this ) ;
}

ProvDisplayStringType :: ProvDisplayStringType ( 

	const wchar_t *displayStringArg ,
	const wchar_t *rangeValues

) : ProvOctetStringType ( NULL , 0 , rangeValues )
{
	char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
	if ( textBuffer )
	{
		ULONG textLength = strlen ( textBuffer ) ;

		octetString.SetValue ( ( UCHAR * ) textBuffer , textLength ) ;

		delete [] textBuffer ;

		ProvInstanceType :: SetStatus ( TRUE ) ;
		ProvInstanceType :: SetNull ( FALSE ) ;
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvDisplayStringType :: ProvDisplayStringType (

	const wchar_t *rangedValues 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )
{
	ProvInstanceType :: SetNull ( TRUE ) ;
}

ProvDisplayStringType :: ~ProvDisplayStringType () 
{
}

wchar_t *ProvDisplayStringType :: GetValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
			memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
			textBuffer [ octetString.GetValueLength () ] = 0 ;

			wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

			delete [] textBuffer ;

			return unicodeString ;
		}
		else
		{
			return ProvOctetStringType :: GetStringValue () ;
		}
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}
}

wchar_t *ProvDisplayStringType :: GetStringValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
			memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
			textBuffer [ octetString.GetValueLength () ] = 0 ;

			wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

			delete [] textBuffer ;

			return unicodeString ;
		}
		else
		{
			return ProvOctetStringType :: GetStringValue () ;
		}
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}

}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType ( 

	const ULONG &fixedLengthArg ,
	const ProvOctetString &displayStringArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg , displayStringArg ) 
{
}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType ( 

	const ProvFixedLengthDisplayStringType &displayStringArg 

) : ProvFixedLengthOctetStringType ( displayStringArg ) 
{
}

ProvInstanceType *ProvFixedLengthDisplayStringType :: Copy () const 
{
	return new ProvFixedLengthDisplayStringType ( *this ) ;
}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType ( 

	const ULONG &fixedLengthArg ,
	const wchar_t *displayStringArg 

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
	char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
	if ( textBuffer )
	{
		ULONG textLength = strlen ( textBuffer ) ;

		octetString.SetValue ( ( UCHAR * ) textBuffer , textLength + 1 ) ;

		delete [] textBuffer ;
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvFixedLengthDisplayStringType :: ProvFixedLengthDisplayStringType (

	const ULONG &fixedLengthArg

) : ProvFixedLengthOctetStringType ( fixedLengthArg )
{
}

ProvFixedLengthDisplayStringType :: ~ProvFixedLengthDisplayStringType () 
{
}

wchar_t *ProvFixedLengthDisplayStringType :: GetValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
		memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
		textBuffer [ octetString.GetValueLength () ] = 0 ;

		wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

		delete [] textBuffer ;

		return unicodeString ;
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}
}

wchar_t *ProvFixedLengthDisplayStringType :: GetStringValue () const 
{
	if ( ProvInstanceType :: IsValid () )
	{
		char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
		memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
		textBuffer [ octetString.GetValueLength () ] = 0 ;

		wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

		delete [] textBuffer ;

		return unicodeString ;
	}
	else
	{
		return ProvOctetStringType :: GetStringValue () ;
	}
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const wchar_t *enumeratedValues , 
	const LONG &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

	wchar_t *enumeratedStringValue ;
	if ( integerMap.Lookup ( ( LONG ) enumeratedValue , enumeratedStringValue ) )
	{
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}

	integer.SetValue ( enumeratedValue ) ;

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const wchar_t *enumeratedValues , 
	const ProvInteger &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

	wchar_t *enumeratedStringValue ;
	if ( integerMap.Lookup ( ( LONG ) enumeratedValue.GetValue () , enumeratedStringValue ) )
	{
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}

	integer.SetValue ( enumeratedValue.GetValue () ) ;

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const wchar_t *enumeratedValues , 
	const wchar_t *enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
	LONG enumeratedIntegerValue ;
	if ( stringMap.Lookup ( ( wchar_t * ) enumeratedValue , enumeratedIntegerValue ) )
	{
		integer.SetValue ( enumeratedIntegerValue ) ;
	}
	else
	{
		ProvAnalyser analyser ;
		analyser.Set ( enumeratedValue ) ;
		ProvLexicon *lookAhead = analyser.Get () ;
		switch ( lookAhead->GetToken () ) 
		{
			case ProvLexicon :: UNSIGNED_INTEGER_ID:
			{
				LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
				integer.SetValue ( enumerationInteger ) ;
			}	
			break ;

			default:
			{
				ProvInstanceType :: SetStatus ( FALSE ) ;
			}
			break ;
		}

		delete lookAhead ;
	}

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvEnumeratedType :: ProvEnumeratedType ( 

	const ProvEnumeratedType &copy

) : ProvIntegerType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.integerMap.GetStartPosition () ;
	while ( position )
	{
		LONG enumeratedIntegerValue ;
		wchar_t *enumeratedStringValue ;
		copy.integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

		wchar_t *stringCopy = new wchar_t [ wcslen ( enumeratedStringValue ) + 1 ] ;
		wcscpy ( stringCopy , enumeratedStringValue ) ;

		integerMap [ enumeratedIntegerValue ] = stringCopy ;
		stringMap [ stringCopy ] = enumeratedIntegerValue ;
	}
}

ProvEnumeratedType :: ProvEnumeratedType (

	const wchar_t *enumeratedValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
}

ProvEnumeratedType :: ~ProvEnumeratedType ()
{
	POSITION position = integerMap.GetStartPosition () ;
	while ( position )
	{
		LONG enumeratedIntegerValue ;
		wchar_t *enumeratedStringValue ;
		integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

		delete [] enumeratedStringValue ;
	}

	integerMap.RemoveAll () ;
	stringMap.RemoveAll () ;

	delete pushBack ;
}

wchar_t *ProvEnumeratedType :: GetStringValue () const
{
	wchar_t *stringValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			wchar_t *enumeratedValue ;
			if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
			{
				stringValue = new wchar_t [ wcslen ( enumeratedValue ) + 1 ] ;
				wcscpy ( stringValue , enumeratedValue ) ;
			}
			else
			{
				stringValue = ProvIntegerType :: GetStringValue () ;
			}
		}
		else
		{
			stringValue = ProvIntegerType :: GetStringValue () ;
		}
	}
	else
	{
		stringValue = ProvIntegerType :: GetStringValue () ;
	}

	return stringValue ;
}

wchar_t *ProvEnumeratedType :: GetValue () const
{
	wchar_t *stringValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		if ( ! ProvInstanceType :: IsNull () )
		{
			wchar_t *enumeratedValue ;
			if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
			{
				stringValue = new wchar_t [ wcslen ( enumeratedValue ) + 1 ] ;
				wcscpy ( stringValue , enumeratedValue ) ;
			}
			else
			{
				stringValue = ProvIntegerType :: GetStringValue () ;
			}
		}
		else
		{
			stringValue = ProvIntegerType :: GetStringValue () ;
		}
	}
	else
	{
		stringValue = ProvIntegerType :: GetStringValue () ;
	}

	return stringValue ;
}

ProvInstanceType *ProvEnumeratedType :: Copy () const
{
	return new ProvEnumeratedType ( *this ) ;
}

BOOL ProvEnumeratedType :: Parse ( const wchar_t *enumeratedValues )
{
	BOOL status = TRUE ;

	analyser.Set ( enumeratedValues ) ;

	return EnumerationDef () && RecursiveDef () ;
}

BOOL ProvEnumeratedType :: EnumerationDef ()
{
	BOOL status = TRUE ;

	wchar_t *enumerationString = NULL ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: TOKEN_ID:
		{
			wchar_t *tokenString = lookAhead->GetValue()->token ;
			enumerationString = new wchar_t [ wcslen ( tokenString ) + 1 ] ;

			try
			{
				wcscpy ( enumerationString , tokenString ) ;

				ProvLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: OPEN_PAREN_ID:
					{
						ProvLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case ProvLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ enumerationInteger ] = enumerationString ;
								stringMap [ enumerationString ] = enumerationInteger ;
								enumerationString = NULL ;

								Match ( ProvLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch(...)
			{
				if (enumerationString)
				{
					delete [] enumerationString ;
				}

				throw;
			}

			if (enumerationString)
			{
				delete [] enumerationString ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvEnumeratedType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			EnumerationDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

void ProvEnumeratedType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvEnumeratedType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvEnumeratedType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	ProvInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
	return ProvInstanceType :: IsValid () ? lexicon : NULL ;
}

ProvRowStatusType :: ProvRowStatusType ( 

	const LONG &rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( 

	const wchar_t *rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( 

	const ProvInteger &rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( 

	const ProvRowStatusEnum &rowStatusValue 

) : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , ( LONG ) rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType ( const ProvRowStatusType &rowStatusValue ) : ProvEnumeratedType ( rowStatusValue ) 
{
}

ProvRowStatusType :: ProvRowStatusType () : ProvEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" )
{
}

ProvRowStatusType :: ~ProvRowStatusType () 
{
}

wchar_t *ProvRowStatusType :: GetStringValue () const 
{
	return ProvEnumeratedType :: GetStringValue () ;
}

wchar_t *ProvRowStatusType :: GetValue () const 
{
	return ProvEnumeratedType :: GetValue () ;
}

ProvRowStatusType :: ProvRowStatusEnum ProvRowStatusType :: GetRowStatus () const 
{
	return ( ProvRowStatusType :: ProvRowStatusEnum ) integer.GetValue () ;
} ;

ProvInstanceType *ProvRowStatusType :: Copy () const
{
	return new ProvRowStatusType ( *this ) ;
}

ProvBitStringType :: ProvBitStringType ( 

	const wchar_t *bitStringValues , 
	const ProvOctetString &bitStringValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

	BOOL valueStatus = TRUE ;

	ULONG bitCounter = 0 ;
	UCHAR *value = bitStringValue.GetValue () ;
	ULONG valueLength = bitStringValue.GetValueLength () ;
	ULONG valueIndex = 0 ;

	while ( valueIndex < valueLength ) 
	{
		for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
		{
			ULONG bitValue = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
			bitValue = value [ valueIndex ] & bitValue ;
			if ( bitValue )					
			{
				bitValue = bit + ( valueIndex * 8 ) ;
				wchar_t *bitStringStringValue ;
				if ( integerMap.Lookup ( bitValue , bitStringStringValue ) )
				{
				}
				else
				{
					valueStatus = FALSE ;
				}
			}
		}

		valueIndex ++ ;
	}

	octetString.SetValue ( bitStringValue.GetValue () , bitStringValue.GetValueLength () ) ;

	ProvInstanceType :: SetStatus ( valueStatus ) ;

	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvBitStringType :: ProvBitStringType ( 

	const wchar_t *bitStringValues , 
	const wchar_t **bitStringValueArray , 
	const ULONG &bitStringValueLength 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

	BOOL valueStatus = TRUE ;

	if ( bitStringValueLength )
	{
		ULONG maximumValue = 0 ;
		for ( ULONG index = 0 ; index < bitStringValueLength ; index ++ )
		{
			ULONG bitStringIntegerValue ;
			const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
			if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
			{
				maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
			}
			else
			{
				ProvAnalyser analyser ;
				analyser.Set ( bitStringValue ) ;
				ProvLexicon *lookAhead = analyser.Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: UNSIGNED_INTEGER_ID:
					{
						ULONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
						maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
					}	
					break ;

					default:
					{
						valueStatus = FALSE ;
					}
					break ;
				}

				delete lookAhead ;
			}
		}

		if ( valueStatus )
		{
			ULONG valueLength = ( maximumValue >> 3 ) + 1 ;
			UCHAR *value = new UCHAR [ valueLength ] ;
			memset ( value , 0 , sizeof ( UCHAR ) ) ;
			
			for ( ULONG index = 0 ; ( index < bitStringValueLength ) && valueStatus ; index ++ )
			{
				ULONG bitStringIntegerValue ;
				const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
				if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
				{
					ULONG byte = bitStringIntegerValue >> 3 ;
					UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
					bit = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
					value [ byte ] = value [ byte ] | bit ;
				}
				else
				{
					ProvAnalyser analyser ;
					analyser.Set ( bitStringValue ) ;
					ProvLexicon *lookAhead = analyser.Get () ;
					switch ( lookAhead->GetToken () ) 
					{
						case ProvLexicon :: UNSIGNED_INTEGER_ID:
						{
							LONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
							ULONG byte = bitStringIntegerValue >> 3 ;
							UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
							bit = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
							value [ byte ] = value [ byte ] | bit ;

							value [ byte ] = value [ byte ] | bit ;
						}	
						break ;

						default:
						{
						}
						break ;
					}

					delete lookAhead ;

					valueStatus = FALSE ;
				}
			}

			octetString.SetValue ( value , valueLength ) ;
			delete [] value ;
		}
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	ProvInstanceType :: SetStatus ( valueStatus ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvBitStringType :: ProvBitStringType ( 

	const ProvBitStringType &copy

) : ProvOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	POSITION position = copy.integerMap.GetStartPosition () ;
	while ( position )
	{
		ULONG bitStringIntegerValue ;
		wchar_t *bitStringStringValue ;
		copy.integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

		wchar_t *stringCopy = new wchar_t [ wcslen ( bitStringStringValue ) + 1 ] ;
		wcscpy ( stringCopy , bitStringStringValue ) ;

		integerMap [ bitStringIntegerValue ] = stringCopy ;
		stringMap [ stringCopy ] = bitStringIntegerValue ;
	}
}

ProvBitStringType :: ProvBitStringType (

	const wchar_t *bitStringValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;
}

ProvBitStringType :: ~ProvBitStringType ()
{
	POSITION position = integerMap.GetStartPosition () ;
	while ( position )
	{
		ULONG bitStringIntegerValue ;
		wchar_t *bitStringStringValue ;
		integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

		delete [] bitStringStringValue ;
	}

	integerMap.RemoveAll () ;
	stringMap.RemoveAll () ;

	delete pushBack ;
}

ULONG ProvBitStringType :: GetValue ( wchar_t **&stringValue ) const
{
	ULONG stringValueLength = 0 ;
	stringValue = NULL ;

	if ( ! ProvInstanceType :: IsNull () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		ULONG valueIndex = 0 ;

		BOOL valueStatus = TRUE ;

		while ( ( valueIndex < valueLength ) && valueStatus )
		{
			for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
			{
				ULONG bitValue = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
				bitValue = value [ valueIndex ] & bitValue ;
				if ( bitValue )					
				{
					stringValueLength ++ ;
				}
			}

			valueIndex ++ ;
		}

		if ( stringValueLength )
		{
			stringValue = new wchar_t * [ stringValueLength ] ;

			ULONG stringValueIndex = 0 ;
			valueIndex = 0 ;
			while ( valueIndex < valueLength ) 
			{
				for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
				{
					ULONG bitValue = ( bit == 0 ) ? 1 : ( 1 << bit ) ;
					bitValue = value [ valueIndex ] & bitValue ;
					if ( bitValue )					
					{
						bitValue = bit + ( valueIndex << 3 ) ;
						wchar_t *bitStringStringValue ;
						if ( integerMap.Lookup ( ( LONG ) bitValue , bitStringStringValue ) )
						{
							stringValue [ stringValueIndex ++ ] = UnicodeStringDuplicate ( bitStringStringValue ) ;
						}
						else
						{
							wchar_t stringValueBuffer [ 40 ] ;
							_ultow ( bitValue , stringValueBuffer , 10 );
							wchar_t *returnValue = new wchar_t [ wcslen ( stringValueBuffer ) + 1 ] ;
							wcscpy ( returnValue , stringValueBuffer ) ;
							stringValue [ stringValueIndex ++ ] = returnValue ;

							valueStatus = FALSE ;
						}
					}
				}

				valueIndex ++ ;
			}
			
			delete [] value ;
		}
	}

	return stringValueLength ;
}

wchar_t *ProvBitStringType :: GetStringValue () const
{
	return ProvOctetStringType :: GetStringValue () ;
}

ProvInstanceType *ProvBitStringType :: Copy () const
{
	return new ProvBitStringType ( *this ) ;
}

BOOL ProvBitStringType :: Parse ( const wchar_t *bitStringValues )
{
	BOOL status = TRUE ;

	analyser.Set ( bitStringValues ) ;

	return BitStringDef () && RecursiveDef () ;
}

BOOL ProvBitStringType :: BitStringDef ()
{
	BOOL status = TRUE ;

	wchar_t *bitStringString = NULL ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: TOKEN_ID:
		{
			wchar_t *tokenString = lookAhead->GetValue()->token ;
			bitStringString = new wchar_t [ wcslen ( tokenString ) + 1 ] ;

			try
			{
				wcscpy ( bitStringString , tokenString ) ;

				ProvLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case ProvLexicon :: OPEN_PAREN_ID:
					{
						ProvLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case ProvLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG bitStringInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ bitStringInteger ] = bitStringString ;
								stringMap [ bitStringString ] = bitStringInteger ;
								bitStringString = NULL;

								Match ( ProvLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch (...)
			{
				if (bitStringString)
				{
					delete [] bitStringString ;
				}

				throw;
			}

			if (bitStringString)
			{
				delete [] bitStringString ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

BOOL ProvBitStringType :: RecursiveDef ()
{
	BOOL status = TRUE ;

	ProvLexicon *lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			PushBack () ;
			Match ( ProvLexicon :: COMMA_ID ) &&
			BitStringDef () &&
			RecursiveDef () ;
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
			PushBack () ;
		} 
		break ;

		default:
		{
			status = FALSE ;
		}
		break ;
	}

	return status ;
}

void ProvBitStringType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvBitStringType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvBitStringType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	ProvInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
	return ProvInstanceType :: IsValid () ? lexicon : NULL ;
}

ProvDateTimeType :: ProvDateTimeType ( 

	const ProvOctetString &dateTimeValue 

) : ProvOctetStringType ( dateTimeValue , NULL ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ULONG valueLength = dateTimeValue.GetValueLength () ;
	if ( valueLength != 8 && valueLength != 11 )
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvDateTimeType :: ProvDateTimeType ( 

	const wchar_t *dateTimeValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
	ProvInstanceType :: SetStatus ( Parse ( dateTimeValue ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

ProvDateTimeType :: ProvDateTimeType ( 

	const ProvDateTimeType &copy

) : ProvOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

ProvDateTimeType :: ProvDateTimeType () : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

ProvDateTimeType :: ~ProvDateTimeType ()
{
}

wchar_t *ProvDateTimeType :: GetValue () const
{
	wchar_t *stringValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG valueLength = octetString.GetValueLength () ;
		
		if (valueLength == 8 || valueLength == 11)
		{
			UCHAR *value = octetString.GetValue () ;

			USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
			UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
			UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
			UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
			UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
			UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
			UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

			char dateTime [ 80 ] ;
			ostrstream oStrStream(dateTime, 80) ;

			oStrStream << ( ULONG ) ( ntohs ( *yearPtr ) ) ;
			oStrStream << "-" ;
			oStrStream << ( ULONG ) ( *monthPtr ) ;
			oStrStream << "-" ;
			oStrStream << ( ULONG ) ( *dayPtr ) ;
			oStrStream << "," ;
			oStrStream << ( ULONG ) ( *hourPtr ) ;
			oStrStream << ":" ;
			oStrStream << ( ULONG ) ( *minutesPtr ) ;
			oStrStream << ":" ;
			oStrStream << ( ULONG ) ( *secondsPtr ) ;
			oStrStream << "." ;
 			oStrStream << ( ULONG ) ( *deciSecondsPtr ) ;

			if ( valueLength == 11 )
			{
				UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
				UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
				UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

				oStrStream << "," ;
		
				if ( *UTC_directionPtr == '+' )
				{
					oStrStream << "+" ;
				}
				else
				{
					oStrStream << "-" ;
				}

				oStrStream << ( ULONG ) ( *UTC_hoursPtr ) ;
				oStrStream << ":" ;
				oStrStream << ( ULONG ) ( *UTC_minutesPtr ) ;
			}

			oStrStream << ends ;

			stringValue = DbcsToUnicodeString ( dateTime ) ;
		}
	}

	if (!stringValue)
	{
		stringValue = ProvOctetStringType :: GetStringValue () ;
	}

	return stringValue ;
}

wchar_t *ProvDateTimeType :: GetStringValue () const
{
	wchar_t *stringValue = GetValue () ;
	return stringValue ;
}

ProvInstanceType *ProvDateTimeType :: Copy () const
{
	return new ProvDateTimeType ( *this ) ;
}

BOOL ProvDateTimeType :: Parse ( const wchar_t *dateTimeValues )
{
	BOOL status = TRUE ;

	analyser.Set ( dateTimeValues ) ;

	return DateTimeDef () ;
}

BOOL ProvDateTimeType :: DateTimeDef ()
{
	BOOL status = TRUE ;

	ULONG year = 0 ;
	ULONG month = 0 ;
	ULONG day = 0 ;
	ULONG hour = 0 ;
	ULONG minutes = 0 ;
	ULONG seconds = 0 ;
	ULONG deciSeconds = 0 ;
	ULONG UTC_present = FALSE ;
	ULONG UTC_direction = 0 ;
	ULONG UTC_hours = 0 ;
	ULONG UTC_minutes = 0 ;

	ProvLexicon *lookAhead = NULL ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	year = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: MINUS_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	month = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: MINUS_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	day = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: COMMA_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	hour = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	minutes = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	seconds = lookAhead->GetValue()->unsignedInteger ;

	if ( ! Match ( ProvLexicon :: DOT_ID ) ) return FALSE ;

	if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

	deciSeconds = lookAhead->GetValue()->unsignedInteger ;

	lookAhead = Get () ;
	switch ( lookAhead->GetToken () ) 
	{
		case ProvLexicon :: COMMA_ID:
		{
			lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case ProvLexicon :: PLUS_ID:
				{
					UTC_present = TRUE ;
					UTC_direction = '+' ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_hours = lookAhead->GetValue()->unsignedInteger ;

					if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

					if ( ( lookAhead = Match ( ProvLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
				}
				break ;

				case ProvLexicon :: MINUS_ID:
				{
					UTC_present = TRUE ;
					UTC_direction = '-' ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_hours = lookAhead->GetValue()->unsignedInteger ;

					if ( ! Match ( ProvLexicon :: COLON_ID ) ) return FALSE ;

					if ( ( lookAhead = Match ( ProvLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

					UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

					if ( ( lookAhead = Match ( ProvLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
				}
				break ;

				default:
				{
					status = FALSE ;
				}
				break ;
			}
		}
		break ;

		case ProvLexicon :: EOF_ID:
		{
		}
		break ;
	
		default:
		{
			status = FALSE ;
		}
		break ;	
	}

	if ( status ) 
	{
		status = FALSE ;

		if ( year <= 65535 )
		if ( month >= 1 && month <= 12 )
		if ( day >= 1 && day <= 31 )
		if ( hour <= 23 )
		if ( minutes <= 59 )
		if ( seconds <= 60 )
		if ( UTC_present )
		{
			if ( UTC_hours <= 11 )
			if ( UTC_minutes <= 59 )
			{
				status = TRUE ;
			}
		}
		else
		{
			status = TRUE ;
		}

		if ( status )
		{

// Encode here

			Encode ( 

				year ,
				month ,
				day ,
				hour ,
				minutes ,
				seconds ,
				deciSeconds ,
				UTC_present ,
				UTC_direction ,
				UTC_hours ,
				UTC_minutes
			) ;
		}
	}

	return status ;
}

void ProvDateTimeType :: Encode (

	const ULONG &year ,
	const ULONG &month ,
	const ULONG &day ,
	const ULONG &hour ,
	const ULONG &minutes ,
	const ULONG &seconds ,
	const ULONG &deciSeconds ,
	const ULONG &UTC_present ,
	const ULONG &UTC_direction ,
	const ULONG &UTC_hours ,
	const ULONG &UTC_minutes
) 
{
	UCHAR *value = NULL ;
	ULONG valueLength = 0 ;

	if ( UTC_present )
	{
		valueLength = 11 ;
	}
	else
	{	
		valueLength = 8 ;
	}

	value = new UCHAR [ valueLength ] ;

	USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
	UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
	UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
	UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
	UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
	UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
	UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

	*yearPtr = htons ( ( USHORT ) year ) ;
	*monthPtr = ( UCHAR ) month ;
	*dayPtr = ( UCHAR ) day ;
	*hourPtr = ( UCHAR ) hour ;
	*minutesPtr = ( UCHAR ) minutes ;
	*secondsPtr = ( UCHAR ) seconds ;
	*deciSecondsPtr = ( UCHAR ) deciSeconds ;

	if ( UTC_present )
	{
		UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
		UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
		UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

		*UTC_directionPtr = ( UCHAR ) UTC_direction ;
		*UTC_hoursPtr = ( UCHAR ) UTC_hours ;
		*UTC_minutesPtr = ( UCHAR ) UTC_minutes ;
	}

	octetString.SetValue ( value , valueLength ) ;

	delete [] value ;
}

void ProvDateTimeType  :: PushBack ()
{
	pushedBack = TRUE ;
}

ProvLexicon *ProvDateTimeType  :: Get ()
{
	if ( pushedBack )
	{
		pushedBack = FALSE ;
	}
	else
	{
		delete pushBack ;
		pushBack = NULL ;
		pushBack = analyser.Get ( TRUE , TRUE ) ;
	}

	return pushBack ;
}
	
ProvLexicon *ProvDateTimeType  :: Match ( ProvLexicon :: LexiconToken tokenType )
{
	ProvLexicon *lexicon = Get () ;
	ProvInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
	return ProvInstanceType :: IsValid () ? lexicon : NULL ;
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const ProvOctetString &osiAddressArg 

) : ProvOctetStringType ( osiAddressArg , NULL ) 
{
	if ( osiAddressArg.GetValueLength () > 1 )
	{
		UCHAR *value = osiAddressArg.GetValue () ;
		ULONG NSAPLength = value [ 0 ] ;

		if ( ! ( NSAPLength < osiAddressArg.GetValueLength () ) )
		{
			ProvInstanceType :: SetStatus ( FALSE ) ;
		}
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const ProvOSIAddressType &osiAddressArg 

) : ProvOctetStringType ( osiAddressArg ) 
{
}

ProvInstanceType *ProvOSIAddressType :: Copy () const 
{
	return new ProvOSIAddressType ( *this ) ;
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const wchar_t *osiAddressArg 

) : ProvOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL )  
{
	ProvInstanceType :: SetStatus ( Parse ( osiAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvOSIAddressType :: Parse ( const wchar_t *osiAddress ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;


/* 
 * OSIAddress Definitions
 */

/*
         -- for a ProvOSIAddress of length m:
          --
          -- octets   contents            encoding
          --    1     length of NSAP      "n" as an unsigned-integer
          --                                (either 0 or from 3 to 20)
          -- 2..(n+1) NSAP                concrete binary representation
          -- (n+2)..m TSEL                string of (up to 64) octets
          --
          ProvOSIAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "*1x:/1x:"
              STATUS       current
              DESCRIPTION
                      "Represents an OSI transport-address."
              SYNTAX       OCTET STRING (SIZE (1 | 4..85))
*/

	UCHAR *OSIValue = new UCHAR [ 1 + 20 + 64 ] ;

	UCHAR NSAPLength = 0 ;
	ULONG TSELLength = 0 ;

	ULONG byte = 0 ;	
	ULONG position = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = osiAddress [ position ++ ] ;
		switch ( state )
		{
			case 0:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else
				{
					if ( token == L'/' ) 
						state = 4 ;
					else 
						state = REJECT_STATE ;	
				}
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 2 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					OSIValue [ 1 + NSAPLength ] = ( UCHAR ) byte ;
					state = 3 ;
					NSAPLength ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L':' )
				{
					if ( NSAPLength < 20 ) 
					{
						state = 1 ;
					}
					else 
						state = REJECT_STATE ;
				}
				else 
				{
					if ( token == L'/' )
					{
						if ( NSAPLength >= 2 ) 
						{
							OSIValue [ 0 ] = NSAPLength ;
							state = 4 ;
						}
						else state = REJECT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}
			break ;

			case 4:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = 5 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 5:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					OSIValue [ 1 + NSAPLength + TSELLength ] = ( UCHAR ) byte ;
					state = 6 ;
					TSELLength ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 6:
			{
				if ( token == L':' )
				{
					if ( TSELLength < 64 ) 
					{
						state = 4 ;
					}
					else state = REJECT_STATE ;
				}
				else 
				{
					if ( token == 0 )
					{
						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( status )
	{
		octetString.SetValue ( OSIValue , 1 + NSAPLength + TSELLength ) ;
	}
	else
	{
		octetString.SetValue ( NULL , 0 ) ;
	}

	delete [] OSIValue ;

	return status ;
}

ProvOSIAddressType :: ProvOSIAddressType ( 

	const UCHAR *value , 
	const ULONG valueLength 

) : ProvOctetStringType ( value , valueLength , NULL ) 
{
	if ( valueLength > 1 )
	{
		ULONG NSAPLength = value [ 0 ] ;

		if ( ! ( NSAPLength < valueLength ) )
		{
			ProvInstanceType :: SetStatus ( FALSE ) ;
		}
	}
	else
	{
		ProvInstanceType :: SetStatus ( FALSE ) ;
	}
}

ProvOSIAddressType :: ProvOSIAddressType () : ProvOctetStringType ( NULL ) 
{
}

ProvOSIAddressType :: ~ProvOSIAddressType () 
{
}

wchar_t *ProvOSIAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		ULONG octetStringLength = octetString.GetValueLength () ;		
		UCHAR *octetStringArray = octetString.GetValue () ;

		if ( octetStringLength < 1 )
			throw ;

		ULONG NSAPLength = octetStringArray [ 0 ] ;

		if ( NSAPLength < octetStringLength )
		{
 			ULONG totalLength = 0 ;
			ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
			wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
	
			if (reallocArray == NULL)
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}

			ULONG index = 1 ;
			while ( index <= NSAPLength ) 
			{
				wchar_t stringValue [ 4 ] ;

				if ( index != NSAPLength )
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = L':' ;
					stringValue [ 3 ] = 0 ;

					if ( ( totalLength + 3 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
					totalLength = totalLength + 3 ;
				}
				else
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = 0 ;

					if ( ( totalLength + 2 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
					totalLength = totalLength + 2 ;
				}


				index ++ ;
			}

			wchar_t stringValue [ 2 ] ;

			stringValue [ 0 ] = L'/' ;
			stringValue [ 1 ] = 0 ;

			if ( ( totalLength + 1 + 1 ) >= reallocLength )
			{
				reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
				reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

				if (reallocArray == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}
			}

			wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
			totalLength = totalLength + 1 ;

			while ( index < octetStringLength )
			{
				wchar_t stringValue [ 4 ] ;

				if ( index != ( octetStringLength - 1 ) )
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = L':' ;
					stringValue [ 3 ] = 0 ;

					if ( ( totalLength + 3 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
					totalLength = totalLength + 3 ;
				}
				else
				{
					stringValue [ 0 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
					stringValue [ 1 ] = ProvAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
					stringValue [ 2 ] = 0 ;

					if ( ( totalLength + 2 + 1 ) >= reallocLength )
					{
						reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
						reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

						if (reallocArray == NULL)
						{
							throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
						}
					}

					wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
					totalLength = totalLength + 2 ;
				}


				index ++ ;
			}

			returnValue = new wchar_t [ totalLength + 1 ] ;
			wcscpy ( returnValue , reallocArray ) ;

			free ( reallocArray ) ;
		}
		else
			throw ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvUDPAddressType :: ProvUDPAddressType ( 

	const ProvOctetString &udpAddressArg 

) : ProvFixedLengthOctetStringType ( 6 , udpAddressArg ) 
{
}

ProvUDPAddressType :: ProvUDPAddressType ( 

	const ProvUDPAddressType &udpAddressArg 

) : ProvFixedLengthOctetStringType ( udpAddressArg ) 
{
}

ProvInstanceType *ProvUDPAddressType :: Copy () const 
{
	return new ProvUDPAddressType ( *this ) ;
}

ProvUDPAddressType :: ProvUDPAddressType ( 

	const wchar_t *udpAddressArg 

) : ProvFixedLengthOctetStringType ( 6 )  
{
	ProvInstanceType :: SetStatus ( Parse ( udpAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvUDPAddressType :: Parse ( const wchar_t *udpAddressArg ) 
{
	BOOL status = TRUE ;
/*
 *	Datum fields.
 */
	UCHAR udpAddress [ 6 ] ;

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	ULONG datumA = 0 ;
	ULONG datumB = 0 ;
	ULONG datumC = 0 ;
	ULONG datumD = 0 ;

/*
 *	Parse input for dotted decimal IP Address.
 */

	ULONG position = 0 ;
	ULONG state = 0 ;
	while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
	{
/*
 *	Get token from input stream.
 */
		wchar_t token = udpAddressArg [ position ++ ] ;

		switch ( state ) 
		{
/*
 *	Parse first field 'A'.
 */

			case 0:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = ( token - 48 ) ;
					state = 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case 1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 2 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 2:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) ) 
				{ 
					datumA = datumA * 10 + ( token - 48 ) ;
					state = 3 ;
				}
				else if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

			case 3:
			{
				if ( token == L'.' ) state = 4 ;
				else state = REJECT_STATE ;
			}
			break ;

/*
 *	Parse first field 'B'.
 */
            case 4:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                { 
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) ) 
                {
					datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *	Parse first field 'C'.
 */
           	case 8:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *	Parse first field 'D'.
 */
            case 12:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( ProvAnalyser :: IsDecimal ( token ) )
                {
					datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == L'/' ) state = 16 ;
				else state = REJECT_STATE ;
            }
            break ;

			case 16:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = 17 ;
					positiveDatum = ( token - 48 ) ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case 17:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = 17 ;

					if ( positiveDatum > 65535 ) state = REJECT_STATE ;
	
					positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
				}
				else if ( token == 0 )
				{
					state = ACCEPT_STATE ;
				}
				else state = REJECT_STATE ;
			}	
			break ;
 
			default:
			{
				state = REJECT_STATE ;
			}
			break ;
		}
	}


/*
 *	Check boundaries for IP fields.
 */

	status = ( state != REJECT_STATE ) ;

	if ( state == ACCEPT_STATE )
	{
		status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
		status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
	}

	udpAddress [ 0 ] = ( UCHAR ) datumA ;
	udpAddress [ 1 ] = ( UCHAR ) datumB ;
	udpAddress [ 2 ] = ( UCHAR ) datumC ;
	udpAddress [ 3 ] = ( UCHAR ) datumD ;

	USHORT *portPtr = ( USHORT * ) & udpAddress [ 4 ] ;
	*portPtr = htons ( ( USHORT ) positiveDatum ) ;

	octetString.SetValue ( udpAddress , 6 ) ;

	return status ;	
}

ProvUDPAddressType :: ProvUDPAddressType ( const UCHAR *value ) : ProvFixedLengthOctetStringType ( 6 , value ) 
{
}

ProvUDPAddressType :: ProvUDPAddressType () : ProvFixedLengthOctetStringType ( 6 ) 
{
}

ProvUDPAddressType :: ~ProvUDPAddressType () 
{
}

wchar_t *ProvUDPAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		if ( valueLength != 6 )
			throw ;

		char ipxAddress [ 40 ] ;
		ostrstream oStrStream ( ipxAddress , 40 ) ;

		oStrStream << ( ( ULONG ) value [ 0 ] ) ;
		oStrStream << "." ;
		oStrStream << ( ( ULONG ) value [ 1 ] ) ;
		oStrStream << "." ;
		oStrStream << ( ( ULONG ) value [ 2 ] ) ;
		oStrStream << "." ;
		oStrStream << ( ( ULONG ) value [ 3 ] ) ;

		oStrStream << "/" ;
	
		ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 4 ] ) ) ;

		oStrStream << portNumber ;

		oStrStream << ends ;

		returnValue = DbcsToUnicodeString ( ipxAddress ) ;

	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}

ProvIPXAddressType :: ProvIPXAddressType ( const ProvOctetString &ipxAddressArg ) : ProvFixedLengthOctetStringType ( 12 , ipxAddressArg ) 
{
}

ProvIPXAddressType :: ProvIPXAddressType ( const ProvIPXAddressType &ipxAddressArg ) : ProvFixedLengthOctetStringType ( ipxAddressArg ) 
{
}

ProvInstanceType *ProvIPXAddressType :: Copy () const 
{
	return new ProvIPXAddressType ( *this ) ;
}

ProvIPXAddressType :: ProvIPXAddressType ( const wchar_t *ipxAddressArg ) : ProvFixedLengthOctetStringType ( 12 )  
{
	ProvInstanceType :: SetStatus ( Parse ( ipxAddressArg ) ) ;
	ProvInstanceType :: SetNull ( FALSE ) ;
}

BOOL ProvIPXAddressType :: Parse ( const wchar_t *ipxAddressArg ) 
{
	BOOL status = TRUE ;

	ULONG state = 0 ;

	UCHAR ipxAddress [ 12 ] ;

/*
          ProvIPXAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "4x.1x:1x:1x:1x:1x:1x.2d"
              STATUS       current
              DESCRIPTION
                      "Represents an IPX address."
              SYNTAX       OCTET STRING (SIZE (12))
 */

/* 
 * IPXAddress Definitions
 */

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	ULONG length = 0 ;
	ULONG byte = 0 ;	
	ULONG position = 0 ;

#define NETWORK_HEX_INTEGER_START 0
#define STATION_HEX_INTEGER_START 100
#define PORT_DEC_INTEGER_START 200

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = ipxAddressArg [ position ++ ] ;
		switch ( state )
		{
			case NETWORK_HEX_INTEGER_START:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = NETWORK_HEX_INTEGER_START + 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case NETWORK_HEX_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					ipxAddress [ length ] = ( UCHAR ) byte ;
					state = NETWORK_HEX_INTEGER_START + 2 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case NETWORK_HEX_INTEGER_START+2:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = NETWORK_HEX_INTEGER_START + 1 ;
				}
				else
				{
					if ( token == L'.' ) 
					{
						if ( length ==4 )
						{
							state = STATION_HEX_INTEGER_START ;
						}
						else
							state = REJECT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}
			break ;

			case STATION_HEX_INTEGER_START:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					state = STATION_HEX_INTEGER_START + 1 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case STATION_HEX_INTEGER_START + 1:
			{
				if ( ProvAnalyser :: IsHex ( token ) )
				{
					byte = ( byte << 4 ) + ProvAnalyser :: HexWCharToDecInteger ( token ) ;
					ipxAddress [ length ] = ( UCHAR ) byte ;
					state = STATION_HEX_INTEGER_START + 2 ;
					length ++ ;
					byte = 0 ;
				}
				else state = REJECT_STATE ;
			}
			break ;

			case STATION_HEX_INTEGER_START + 2 :
			{
				if ( token == L':' )
				{
					state = STATION_HEX_INTEGER_START ;
				}
				else 
				{
					if ( token == L'.' )
					{
						if ( length == 10 ) 
						{
							state = PORT_DEC_INTEGER_START ;
						}
						else state = REJECT_STATE ;
					}
					else state = REJECT_STATE ;
	 			}
			}
			break ;

			case PORT_DEC_INTEGER_START:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{
					state = PORT_DEC_INTEGER_START + 1 ;
					positiveDatum = ( token - 48 ) ;
				}
				else state = REJECT_STATE ;
			}	
			break ;

			case PORT_DEC_INTEGER_START+1:
			{
				if ( ProvAnalyser :: IsDecimal ( token ) )
				{	
					state = PORT_DEC_INTEGER_START + 1 ;

					if ( positiveDatum > 65535 ) state = REJECT_STATE ;
	
					positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
				}
				else 
				{
					if ( token == 0 )
					{
						USHORT *portPtr = ( USHORT * ) & ipxAddress [ 10 ] ;
						*portPtr = htons ( ( USHORT ) positiveDatum ) ;

						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
			}	
			break ;

			default:
			{
				state = REJECT_STATE ; 
			}
			break ;
		}
	}

	status = ( state != REJECT_STATE ) ;

	if ( status )
	{
		octetString.SetValue ( ipxAddress , 12 ) ;
	}

	return status ;
}

ProvIPXAddressType :: ProvIPXAddressType ( const UCHAR *value ) : ProvFixedLengthOctetStringType ( 12 , value ) 
{
}

ProvIPXAddressType :: ProvIPXAddressType () : ProvFixedLengthOctetStringType ( 12 ) 
{
}

ProvIPXAddressType :: ~ProvIPXAddressType () 
{
}

wchar_t *ProvIPXAddressType :: GetStringValue () const 
{
	wchar_t *returnValue = NULL ;

	if ( ProvInstanceType :: IsValid () )
	{
		UCHAR *value = octetString.GetValue () ;
		ULONG valueLength = octetString.GetValueLength () ;
		if ( valueLength != 12 )
			throw ;

		char ipxAddress [ 80 ] ;
		ostrstream oStrStream ( ipxAddress , 80) ;

		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 0 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 0 ] & 0xf ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 1 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 1 ] & 0xf ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 2 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 2 ] & 0xf ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 3 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 3 ] & 0xf ) ;

		oStrStream << "." ;
	
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 4 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 4 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 5 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 5 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 6 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 6 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 7 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 7 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 8 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 8 ] & 0xf ) ;
		oStrStream << ":" ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 9 ] >> 4 ) ;
		oStrStream << ProvAnalyser :: DecIntegerToHexChar ( value [ 9 ] & 0xf ) ;

		oStrStream << "." ;

		ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 10 ] ) ) ;

		oStrStream << portNumber ;

		oStrStream << ends ;

		returnValue = DbcsToUnicodeString ( ipxAddress ) ;
	}
	else
	{
		returnValue = ProvOctetStringType :: GetStringValue () ;
	}

	return returnValue ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provthrd.cpp ===
//***************************************************************************

//

//  PROVTHRD.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <provcont.h>
#include "provevt.h"
#include "provthrd.h"
#include "provlog.h"

#include <Allocator.cpp>
#include <Algorithms.h>

CCriticalSection ProvThreadObject :: s_Lock ;
LONG ProvThreadObject :: s_ReferenceCount = 0 ;
WmiAllocator g_Allocator ;
ThreadContainer ProvThreadObject :: s_ThreadContainer ( g_Allocator ) ;

class ProvShutdownTaskObject : public ProvTaskObject
{
private:

	ProvThreadObject *m_ThreadToShutdown ;

protected:
public:

	ProvShutdownTaskObject (ProvThreadObject *threadToShutdown) ;

	void Process () ;

} ;

ProvShutdownTaskObject :: ProvShutdownTaskObject (

	ProvThreadObject *threadToShutdown

) : m_ThreadToShutdown ( threadToShutdown )
{
}

void ProvShutdownTaskObject ::Process()
{
	if ( m_ThreadToShutdown )
	{
		m_ThreadToShutdown->SignalThreadShutdown ();
	}

	Complete();
}


BOOL ProvThreadObject :: Startup ()
{
	InterlockedIncrement ( & s_ReferenceCount ) ;

	return TRUE ;
}

void ProvThreadObject :: Closedown()
{
	if ( InterlockedDecrement ( & s_ReferenceCount ) <= 0 )
		ProcessDetach () ;
}

void ProvThreadObject :: ProcessAttach () 
{ 
}

void ProvThreadObject :: ProcessDetach ( BOOL a_ProcessDetaching )
{

// delete all known thread objects 

	s_Lock.Lock () ;

	ThreadContainerIterator t_Iterator = s_ThreadContainer.Begin () ;

	while ( ! t_Iterator.Null () )
	{
		s_Lock.Unlock () ;

		t_Iterator.GetElement ()->SignalThreadShutdown () ;

		s_Lock.Lock () ;

		t_Iterator = s_ThreadContainer.Begin () ;
	}

	s_ThreadContainer.UnInitialize () ;

	s_Lock.Unlock () ;
}

void ProvThreadObject :: ThreadExecutionProcedure ( void *a_ThreadParameter )
{
	SetStructuredExceptionHandler seh;

	try
	{
		ProvThreadObject *t_ThreadObject = ( ProvThreadObject * ) a_ThreadParameter ;

		if ( t_ThreadObject->RegisterThread () )
		{
			t_ThreadObject->Initialise () ;

			SetEvent ( t_ThreadObject->m_ThreadInitialization ) ;

DebugMacro8(

		ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread beginning dispatch") ) ;
)

			if ( t_ThreadObject->Wait () )
			{
			}
			else 
			{
			}

DebugMacro8(

		ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread completed dispatch") ) ;
)

			t_ThreadObject->Uninitialise () ;

DebugMacro8(

		ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread terminating") ) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		return;
	}
	catch(Heap_Exception e_HE)
	{
		return;
	}
	catch(...)
	{
		return;
	}
}

void ProvThreadObject :: TerminateThread () 
{
	:: TerminateThread (m_ThreadHandle,0) ;
}

ProvThreadObject :: ProvThreadObject (

	const TCHAR *a_ThreadName,
	DWORD a_timeout
	
) :	m_EventContainer ( NULL ) , 
	m_EventContainerLength ( 0 ) , 
	m_ThreadId ( 0 ) , 
	m_ThreadHandle ( 0 ) ,
	m_ThreadName ( NULL ) ,
	m_timeout ( a_timeout ),
	m_pShutdownTask ( NULL ) ,
	m_ScheduleReapContainer ( g_Allocator ) ,
	m_TaskQueue ( g_Allocator ) ,
	m_ThreadInitialization ( NULL )
{
	if ( a_ThreadName )
	{
		m_ThreadName = _tcsdup ( a_ThreadName ) ;
	}

	m_ThreadInitialization = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;

	ConstructEventContainer () ;
}

void  ProvThreadObject :: BeginThread()
{
	DWORD t_PseudoHandle = _beginthread ( 

		ProvThreadObject :: ThreadExecutionProcedure , 
		0 , 
		( void * ) this
	 ) ;
}

void ProvThreadObject :: WaitForStartup ()
{
	WaitForSingleObject ( m_ThreadInitialization , INFINITE ) ;
}

ProvThreadObject :: ~ProvThreadObject ()
{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Enter Thread destructor") ) ;
)

	if ( ( m_ThreadId != GetCurrentThreadId () ) && ( m_ThreadId != 0 ))
	{
		SignalThreadShutdown () ;
	}

	free ( m_ThreadName ) ;

	ProvAbstractTaskObject *t_TaskObject = NULL ;

	WmiStatusCode t_StatusCode ;
	while ( ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success )
	{
		m_TaskQueue.DeQueue () ;

		t_TaskObject->DetachTaskFromThread ( *this ) ;
	}

	m_TaskQueue.UnInitialize () ;

	free ( m_EventContainer ) ;

	if ( m_ThreadHandle )
		CloseHandle ( m_ThreadHandle ) ;

	s_Lock.Lock () ;
	s_ThreadContainer.Delete ( m_ThreadId ) ;
	s_Lock.Unlock () ;

	if ( m_ThreadInitialization )
	{
		CloseHandle ( m_ThreadInitialization ) ;
	}

	if (m_pShutdownTask != NULL)
	{
		delete m_pShutdownTask;
	}

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Exit Thread destructor") ) ;
)

}

void ProvThreadObject :: PostSignalThreadShutdown ()
{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Posting thread shutdown") ) ;
)

	if (m_pShutdownTask != NULL)
	{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread shutdown previously posted") ) ;
)
	}
	else
	{
		m_pShutdownTask = new ProvShutdownTaskObject(this);
		ScheduleTask(*m_pShutdownTask);
		m_pShutdownTask->Exec();
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread shutdown posted") ) ;
)
	}
}


void ProvThreadObject :: SignalThreadShutdown ()
{
	s_Lock.Lock () ;
	WmiStatusCode t_StatusCode = s_ThreadContainer.Delete ( m_ThreadId ) ;
	s_Lock.Unlock () ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_ThreadId == GetCurrentThreadId () )
		{
			m_ThreadTerminateEvent.Set () ;
		}
		else
		{
			HANDLE t_ProcessHandle = GetCurrentProcess ();
			HANDLE t_Handle = NULL ;

			BOOL t_Status = DuplicateHandle ( 

				t_ProcessHandle ,
				m_ThreadHandle ,
				t_ProcessHandle ,
				& t_Handle ,
				0 ,
				FALSE ,
				DUPLICATE_SAME_ACCESS
			) ;

			if ( t_Status ) 
			{
				m_ThreadTerminateEvent.Set () ;

				DWORD t_Event = WaitForSingleObject (

					t_Handle ,
					INFINITE 
				) ;

				CloseHandle ( t_Handle ) ;
			}
		}
	}
}

void ProvThreadObject :: ConstructEventContainer ()
{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Constructing Container") , m_ThreadName ) ;
)

	s_Lock.Lock () ;

	if ( ( m_TaskQueue.Size () + 2 ) <  MAXIMUM_WAIT_OBJECTS )
	{
		m_EventContainerLength = m_TaskQueue.Size () + 2;
	}
	else
	{
		m_EventContainerLength = MAXIMUM_WAIT_OBJECTS - 1;
	}

	m_EventContainer = ( HANDLE * ) realloc ( m_EventContainer , sizeof ( HANDLE ) * m_EventContainerLength ) ;
	if ( m_EventContainer == NULL)
	{
		s_Lock.Unlock () ;
		throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	m_EventContainer [ 0 ] = GetHandle () ;
	m_EventContainer [ 1 ] = m_ThreadTerminateEvent.GetHandle () ;

	ULONG t_EventIndex = 2 ;

	WmiStatusCode t_StatusCode ;
	ProvAbstractTaskObject *t_TaskObject = NULL ;

	while ( ( t_EventIndex < m_EventContainerLength ) && ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success )
	{
		t_StatusCode = m_TaskQueue.DeQueue () ;
		t_StatusCode = m_TaskQueue.EnQueue ( t_TaskObject ) ;

		m_EventContainer [ t_EventIndex ] = t_TaskObject->GetHandle () ;
		t_EventIndex ++ ;
	}

	s_Lock.Unlock () ;
}

ProvThreadObject *ProvThreadObject :: GetThreadObject () 
{
	s_Lock.Lock () ;

	DWORD t_CurrentThreadId = GetCurrentThreadId () ;

	ProvThreadObject *t_ThreadObject ;

	ThreadContainerIterator t_Iterator ;

	if ( s_ThreadContainer.Find ( GetCurrentThreadId () , t_Iterator ) == e_StatusCode_Success )
	{
		t_ThreadObject = t_Iterator.GetElement () ;
	}
	else
	{
		t_ThreadObject = NULL ;
	}

	s_Lock.Unlock () ;

	return t_ThreadObject ;
}

ProvAbstractTaskObject *ProvThreadObject :: GetTaskObject ( HANDLE &a_Handle )
{
	ProvAbstractTaskObject *t_TaskObject = NULL ;

	s_Lock.Lock () ;

	ULONG t_QueueSize = m_TaskQueue.Size () ;

	WmiStatusCode t_StatusCode ;
	while ( t_QueueSize && ( ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success ) )
	{
		m_TaskQueue.DeQueue () ;
		m_TaskQueue.EnQueue ( t_TaskObject ) ;

		if ( t_TaskObject->GetHandle () == a_Handle ) 
		{
			break ;
		}

		t_QueueSize -- ;
	}

	s_Lock.Unlock () ;

	return t_TaskObject ;
}

BOOL ProvThreadObject :: RegisterThread () 
{
	s_Lock.Lock () ;

	BOOL t_Status = FALSE ;

	m_ThreadId = GetCurrentThreadId () ;

	ThreadContainerIterator t_Iterator ;
	if ( s_ThreadContainer.Insert ( m_ThreadId , this , t_Iterator ) == e_StatusCode_Success )
	{
		t_Status = DuplicateHandle ( 

			GetCurrentProcess () ,
			GetCurrentThread ()  ,
			GetCurrentProcess () ,
			GetThreadHandleReference () ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;
	}

	s_Lock.Unlock () ;

DebugMacro8(

	TCHAR buffer [ 1025 ] ;
	_stprintf ( buffer , _TEXT("\nThread [%S] = %lx, with thread id = %lx") , m_ThreadName , (UINT_PTR)this , m_ThreadId ) ;
	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__, buffer ) ;
)
	return t_Status ;
}

void ProvThreadObject :: Process () 
{
	s_Lock.Lock () ;

	ScheduleReapContainerIterator t_Iterator = m_ScheduleReapContainer.Begin () ;

	while ( ! t_Iterator.Null () )
	{


DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Thread Process [%lx]") , m_ThreadName , t_Iterator.GetKey () );
)
		t_Iterator.GetElement ()->Set () ;

		t_Iterator.Increment () ;
	}

	s_Lock.Unlock () ;
}

BOOL ProvThreadObject :: WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated )
{
	BOOL t_Status = TRUE ;

	HANDLE t_Handle = m_EventContainer [ t_HandleIndex ] ;
	if ( t_Handle == GetHandle () )
	{
// Task has been scheduled so we must update arrays

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Thread Wait: Refreshing handles") , m_ThreadName );
)

		Process () ;
		ConstructEventContainer () ;
	}
	else if ( t_Handle == m_ThreadTerminateEvent.GetHandle () )
	{
// thread has been told to close down

		a_Terminated = TRUE ;
		m_ThreadTerminateEvent.Process () ;

DebugMacro8(

		ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Someone t_Terminated") , m_ThreadName )  ;
)
	}
	else
	{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Thread Wait: Processing Task") , m_ThreadName );
)

		ProvAbstractTaskObject *t_TaskObject = GetTaskObject ( t_Handle ) ;
		if ( t_TaskObject )
		{
			ConstructEventContainer () ;
			t_TaskObject->Process () ;
		}
		else
		{
DebugMacro8(

			ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Couldn't Find Task Object") , m_ThreadName ) ;
)
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

BOOL ProvThreadObject :: Wait ()
{
	BOOL t_Status = TRUE ;
	BOOL t_Terminated = FALSE ;

	while ( t_Status && ! t_Terminated )
	{
		DWORD t_Event = MsgWaitForMultipleObjects (

			m_EventContainerLength ,
			m_EventContainer ,
			FALSE ,
			m_timeout ,
			QS_ALLINPUT
		) ;

		ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

		if ( t_Event == 0xFFFFFFFF )
		{
			DWORD t_Error = GetLastError () ;

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Handle problem") , m_ThreadName ) ;
)

			t_Status = FALSE ;
		}
		else if ( t_Event == WAIT_TIMEOUT)
		{
			TimedOut();
		}
		else if ( t_HandleIndex <= m_EventContainerLength )
		{
// Go into dispatch loop

			if ( t_HandleIndex == m_EventContainerLength )
			{
				BOOL t_DispatchStatus ;
				MSG t_Msg ;

				while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					int t_Result = 0;
					t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

					if ( t_Result != 0 && t_Result != -1 )
					{
						TranslateMessage ( & t_Msg ) ;
						DispatchMessage ( & t_Msg ) ;
					}

					BOOL t_Timeout = FALSE ;

					while ( ! t_Timeout & t_Status & ! t_Terminated )
					{
						t_Event = WaitForMultipleObjects (

							m_EventContainerLength ,
							m_EventContainer ,
							FALSE ,
							0
						) ;

						t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

						if ( t_Event == 0xFFFFFFFF )
						{
							DWORD t_Error = GetLastError () ;
	
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Handle problem") , m_ThreadName ) ;
)
							t_Status = FALSE ;
						}
						else if ( t_Event == WAIT_TIMEOUT)
						{
							t_Timeout = TRUE ;
						}
						else if ( t_HandleIndex < m_EventContainerLength )
						{
							t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
						}
						else
						{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Unknown handle index") , m_ThreadName ) ;
)
							t_Status = FALSE ;
						}
					}
				}
			}
			else if ( t_HandleIndex < m_EventContainerLength )
			{
				t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
			}
			else
			{

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Unknown handle index") , m_ThreadName ) ;
)
				t_Status = FALSE ;
			}
		}
	}

	return t_Status ;
}

ULONG ProvThreadObject :: GetEventHandlesSize ()
{
	return m_EventContainerLength ;
}

HANDLE *ProvThreadObject :: GetEventHandles ()
{
	return m_EventContainer ;
}

BOOL ProvThreadObject :: ScheduleTask ( ProvAbstractTaskObject &a_TaskObject ) 
{
	BOOL t_Result = TRUE ;

	s_Lock.Lock () ;

/*
 * Add Synchronous object to worker thread container
 */
	a_TaskObject.m_ScheduledHandle = a_TaskObject.GetHandle ();
	WmiStatusCode t_StatusCode = m_TaskQueue.EnQueue ( &a_TaskObject ) ; 

	s_Lock.Unlock () ;

	a_TaskObject.AttachTaskToThread ( *this ) ;

	if ( GetCurrentThreadId () != m_ThreadId ) 
	{
		Set () ;
	}
	else
	{
		ConstructEventContainer () ;
	}

	return t_Result ;
}

BOOL ProvThreadObject :: ReapTask ( ProvAbstractTaskObject &a_TaskObject ) 
{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Entering ReapTask [%lx]") , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

	BOOL t_Result = TRUE ;

	s_Lock.Lock () ;

/*
 *	Remove worker object from worker thread container
 */

	ProvAbstractTaskObject *t_TaskObject = NULL ;

	ULONG t_QueueSize = m_TaskQueue.Size () ;

	WmiStatusCode t_StatusCode ;
	while ( t_QueueSize && ( ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success ) )
	{
		m_TaskQueue.DeQueue () ;

		if ( a_TaskObject.m_ScheduledHandle == t_TaskObject->m_ScheduledHandle )
		{
			break ;
		}

		m_TaskQueue.EnQueue ( t_TaskObject ) ;

		t_QueueSize -- ;
	}

	s_Lock.Unlock () ;

/*
 * Inform worker thread,thread container has been updated.
 */

	if ( GetCurrentThreadId () != m_ThreadId ) 
	{
		ProvEventObject t_ReapedEventObject ;

		s_Lock.Lock () ;

		ScheduleReapContainerIterator t_Iterator ;
		WmiStatusCode t_StatusCode = m_ScheduleReapContainer.Insert ( t_ReapedEventObject.GetHandle () , &t_ReapedEventObject , t_Iterator ) ;

		s_Lock.Unlock () ;

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] ReapTask: Setting update") , m_ThreadName );
)
		Set () ;

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] ReapTask: Beginning Wait on [%lx]") , m_ThreadName , t_ReapedEventObject.GetHandle () );
)

		if ( t_ReapedEventObject.Wait () )
		{
		}
		else
		{
			t_Result = FALSE ;
		}

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] ReapTask: Ended Wait") , m_ThreadName );
)

		s_Lock.Lock () ;

		t_StatusCode = m_ScheduleReapContainer.Delete ( t_ReapedEventObject.GetHandle () ) ;

		s_Lock.Unlock () ;

	}
	else
	{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] ReapTask: ConstructEventContainer") , m_ThreadName );
)
		ConstructEventContainer () ;
	}

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%S] Returning from ReapTask [%lx]") , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

	a_TaskObject.DetachTaskFromThread ( *this ) ;

	return t_Result ;
}

ProvAbstractTaskObject :: ProvAbstractTaskObject ( 

	const TCHAR *a_GlobalTaskNameComplete,
	const TCHAR *a_GlobalTaskNameAcknowledgement,
	DWORD a_timeout

) : m_CompletionEvent ( a_GlobalTaskNameComplete ) , 
	m_AcknowledgementEvent ( a_GlobalTaskNameAcknowledgement ) , 
	m_timeout ( a_timeout ), 
	m_ScheduledHandle (NULL),
	m_ThreadContainer (g_Allocator)
{
} 

ProvAbstractTaskObject :: ~ProvAbstractTaskObject () 
{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: ~ProvAbstractTaskObject () [%lx]") , m_ScheduledHandle ) ;
)

	m_Lock.Lock () ;

	if (NULL != m_ScheduledHandle)
	{
		ThreadContainerIterator t_Iterator = m_ThreadContainer.Begin () ;

		while ( ! t_Iterator.Null () )
		{
			ProvThreadObject *t_Task = t_Iterator.GetElement () ;

			t_Task->ReapTask ( *this ) ;

			t_Iterator = m_ThreadContainer.Begin () ;
		}
	}

	m_ThreadContainer.UnInitialize () ;	

	m_Lock.Unlock () ;
}

void ProvAbstractTaskObject :: DetachTaskFromThread ( ProvThreadObject &a_ThreadObject )
{
	m_Lock.Lock () ;
	WmiStatusCode t_StatusCode = m_ThreadContainer.Delete ( a_ThreadObject.GetThreadId () ) ;
	m_Lock.Unlock () ;
}

void ProvAbstractTaskObject :: AttachTaskToThread ( ProvThreadObject &a_ThreadObject )
{
	m_Lock.Lock () ;

	ThreadContainerIterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_ThreadContainer.Insert ( a_ThreadObject.GetThreadId () , &a_ThreadObject , t_Iterator ) ;

	m_Lock.Unlock () ;
}

BOOL ProvAbstractTaskObject :: Wait ( BOOL a_Dispatch )
{
	BOOL t_Status = TRUE ;
	BOOL t_Processed = FALSE ;

	while ( t_Status && ! t_Processed )
	{
		ProvThreadObject *t_ThreadObject = ProvThreadObject :: GetThreadObject () ;
		ULONG t_TaskEventArrayLength = 0 ;
		HANDLE *t_TaskEventArray = NULL ;

		if ( t_ThreadObject && a_Dispatch )
		{
			ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
			t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

			if ( t_TaskArrayLength )
			{
				memcpy ( 
 
					& ( t_TaskEventArray [ 1 ] ) , 
					t_ThreadObject->GetEventHandles () ,
					t_TaskArrayLength * sizeof ( HANDLE ) 
				) ;		
			}

			t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;			
		}
		else
		{
			t_TaskEventArrayLength = 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
			t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;
		}

		DWORD t_Event ;

		if ( a_Dispatch ) 
		{
			t_Event = MsgWaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout ,
				QS_ALLINPUT
			) ;
		}
		else
		{
			t_Event = WaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout 
			) ;
		}

		ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

		if ( t_Event == 0xFFFFFFFF )
		{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

			DWORD t_Error = GetLastError () ;
			t_Status = FALSE ;
		}
		else if ( t_Event == WAIT_TIMEOUT)
		{
			TimedOut();
		}
		else if ( t_HandleIndex == t_TaskEventArrayLength )
		{
			BOOL t_DispatchStatus ;
			MSG t_Msg ;

			while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
			{
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
				{
					TranslateMessage ( & t_Msg ) ;
					DispatchMessage ( & t_Msg ) ;
				}

				BOOL t_Timeout = FALSE ;

				while ( ! t_Timeout & t_Status & ! t_Processed )
				{
					t_Event = WaitForMultipleObjects (

						t_TaskEventArrayLength ,
						t_TaskEventArray ,
						FALSE ,
						0
					) ;

					t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

					if ( t_Event == 0xFFFFFFFF )
					{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

						DWORD t_Error = GetLastError () ;
						t_Status = FALSE ;
					}
					else if ( t_Event == WAIT_TIMEOUT)
					{
						t_Timeout = TRUE ;
					}
					else if ( t_HandleIndex < t_TaskEventArrayLength )
					{
						HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
						t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
					}
					else
					{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)
						t_Status = FALSE ;
					}
				}
			}
		}
		else if ( t_HandleIndex < t_TaskEventArrayLength )
		{
			HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
			t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
		}
		else
		{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)

			t_Status = FALSE ;
		}

		delete [] t_TaskEventArray ;
	}

	return t_Status ;
}

BOOL ProvAbstractTaskObject :: WaitDispatch ( ProvThreadObject *a_ThreadObject, HANDLE a_Handle , BOOL &a_Processed )
{
	BOOL t_Status = TRUE ;

	if ( a_Handle == m_CompletionEvent.GetHandle () )
	{

DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nWait: Completed") );
)


		m_CompletionEvent.Process () ;
		a_Processed = TRUE ;
	}
	else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
	{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nTask Wait: Refreshing handles") );
)
		a_ThreadObject->Process () ;
		a_ThreadObject->ConstructEventContainer () ;
	}
	else
	{
		ProvAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
		if ( t_TaskObject )
		{
			a_ThreadObject->ConstructEventContainer () ;
			t_TaskObject->Process () ;
		}
		else
		{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Task") ) ;
)
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

BOOL ProvAbstractTaskObject :: WaitAcknowledgement ( BOOL a_Dispatch )
{
	BOOL t_Status = TRUE ;
	BOOL t_Processed = FALSE ;

	while ( t_Status && ! t_Processed )
	{
		ProvThreadObject *t_ThreadObject = ProvThreadObject :: GetThreadObject () ;
		ULONG t_TaskEventArrayLength = 0 ;
		HANDLE *t_TaskEventArray = NULL ;

		if ( t_ThreadObject && a_Dispatch )
		{
			ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
			t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

			if ( t_TaskArrayLength )
			{
				memcpy ( 
 
					& ( t_TaskEventArray [ 1 ] ) , 
					t_ThreadObject->GetEventHandles () ,
					t_TaskArrayLength * sizeof ( HANDLE ) 
				) ;		
			}

			t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;			
		}
		else
		{
			t_TaskEventArrayLength = 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
			t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;
		}

		DWORD t_Event ;

		if ( a_Dispatch ) 
		{
			t_Event = MsgWaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout ,
				QS_ALLINPUT
			) ;
		}
		else
		{
			t_Event = WaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout 
			) ;
		}

		ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

		if ( t_Event == 0xFFFFFFFF )
		{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

			DWORD t_Error = GetLastError () ;
			t_Status = FALSE ;
		}
		else if ( t_Event == WAIT_TIMEOUT)
		{
			TimedOut();
		}
		if ( t_HandleIndex == t_TaskEventArrayLength )
		{
			BOOL t_DispatchStatus ;
			MSG t_Msg ;

			while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
			{
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
				{
					TranslateMessage ( & t_Msg ) ;
					DispatchMessage ( & t_Msg ) ;
				}

				BOOL t_Timeout = FALSE ;

				while ( ! t_Timeout & t_Status & ! t_Processed )
				{
					t_Event = WaitForMultipleObjects (

						t_TaskEventArrayLength ,
						t_TaskEventArray ,
						FALSE ,
						0
					) ;

					ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

					if ( t_Event == 0xFFFFFFFF )
					{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

						DWORD t_Error = GetLastError () ;
						t_Status = FALSE ;
					}
					else if ( t_Event == WAIT_TIMEOUT)
					{
						t_Timeout = TRUE ;
					}
					else if ( t_HandleIndex < t_TaskEventArrayLength )
					{
						HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
						t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
					}
					else
					{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)
						t_Status = FALSE ;
					}
				}
			}
		}
		else if ( t_HandleIndex < t_TaskEventArrayLength )
		{
			HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
			t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
		}
		else
		{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)

			t_Status = FALSE ;
		}

		delete [] t_TaskEventArray ;
	}

	return t_Status ;
}

BOOL ProvAbstractTaskObject :: WaitAcknowledgementDispatch ( ProvThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed )
{
	BOOL t_Status = TRUE ;

	if ( a_Handle == m_AcknowledgementEvent.GetHandle () )
	{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nWait: Completed") );
)

		m_AcknowledgementEvent.Process () ;
		a_Processed = TRUE ;
	}
	else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
	{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nTask Wait: Refreshing handles") );
)
		a_ThreadObject->Process () ;
		a_ThreadObject->ConstructEventContainer () ;
	}
	else
	{
		ProvAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
		if ( t_TaskObject )
		{
			a_ThreadObject->ConstructEventContainer () ;
			t_TaskObject->Process () ;
		}
		else
		{
DebugMacro8(

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Task") ) ;
)
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

ProvTaskObject::ProvTaskObject ( 
	const TCHAR *a_GlobalTaskNameStart, 
	const TCHAR *a_GlobalTaskNameComplete ,
	const TCHAR *a_GlobalTaskNameAcknowledge,
	DWORD a_timeout

): ProvAbstractTaskObject(a_GlobalTaskNameComplete, a_GlobalTaskNameAcknowledge,a_timeout), m_Event(a_GlobalTaskNameStart)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=provthrd
TARGETPATH=obj
TARGETTYPE=DYNLINK

LINKLIBS= \
	$(FRAMEWORK_MFC_LIB)
TARGETLIBS= \
	$(FRAMEWORK_EXPT_LIB) \
	$(STDLIBRARY_LIB) \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\wsock32.lib 

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(FRAMEWORK_MFC_INC); \
	$(FRAMEWORK_PARSER_INC); \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC)

SOURCES= \
	..\provlog.cpp \
	..\provthrd.cpp \
	..\provevt.cpp \
	..\maindll.cpp \
	..\provtype.cpp \
	..\provval.cpp \
	..\provdnf.cpp \
	..\provtree.cpp \
	..\provthrd.rc 

# Add the following to add DB verbose logging: '/DREP_VERBOSE_LOGGING'
C_DEFINES=$(C_DEFINES) /DPROVDEBUG_INIT /DPROVTHRD_INIT /DPROVIMEX_INIT
USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\provthrd.def
USE_IOSTREAM=1
USE_NATIVE_EH=ASYNC
USE_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\provval.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: value.cpp
Written By:	B.Rajeev
----------------------------------------------------------*/

#include <precomp.h>
#include <typeinfo.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>

#include <provimex.h>
#include <provexpt.h>
#include <provval.h>

BOOL ProvNull :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = TRUE;
	}

	return bResult;
}


// Copy constructor
ProvInteger::ProvInteger ( IN const ProvInteger &value )
{
	val = value.GetValue();
}

BOOL ProvInteger :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvInteger &)value);
	}

	return bResult;
}

LONG ProvInteger::GetValue () const
{ 
	return val; 
}

void ProvInteger::SetValue ( IN const LONG value ) 
{ 
	val = value; 
}

ProvValue *ProvInteger::Copy () const 
{ 
	return new ProvInteger(val);
}

// Copy constructor
ProvGauge::ProvGauge ( IN const ProvGauge &value )
{
	val = value.GetValue();
}

BOOL ProvGauge :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvGauge &)value);
	}

	return bResult;
}

ULONG ProvGauge::GetValue () const
{ 
	return val; 
}

void ProvGauge::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvGauge::Copy () const 
{ 
	return new ProvGauge(val);
}

// Copy constructor
ProvCounter::ProvCounter ( IN const ProvCounter &value )
{
	val = value.GetValue();
}

BOOL ProvCounter :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvCounter &)value);
	}

	return bResult;
}

ULONG ProvCounter::GetValue () const
{ 
	return val; 
}

void ProvCounter::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvCounter::Copy () const 
{ 
	return new ProvCounter(val);
}

// Copy constructor
ProvTimeTicks::ProvTimeTicks ( IN const ProvTimeTicks &value )
{
	val = value.GetValue();
}

BOOL ProvTimeTicks :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvTimeTicks &)value);
	}

	return bResult;
}

ULONG ProvTimeTicks::GetValue () const
{ 
	return val; 
}

void ProvTimeTicks::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvTimeTicks::Copy () const 
{ 
	return new ProvTimeTicks(val);
}

void ProvOctetString::OverWrite(IN const UCHAR *value)
{
	if ( value && length )
	{
		memcpy(val, value, sizeof(UCHAR)*length);
	}
}

void ProvOctetString::Initialize(IN const UCHAR *value, IN const ULONG valueLength)
{
	is_valid = FALSE;

	if ( (value == NULL) && (valueLength != 0) )
		return;

	length = valueLength;
	val = Replicate(value, valueLength);
	is_valid = TRUE;
}


void ProvOctetString::UnReplicate(UCHAR *value)
{
	if ( is_valid == TRUE )
		delete[] val;
}

ProvOctetString::ProvOctetString ( IN const UCHAR *value , IN const ULONG valueLength ) : is_valid ( FALSE )
{		
	Initialize(value, valueLength);
}

ProvOctetString::ProvOctetString ( IN const ProvOctetString &value ) : is_valid ( FALSE )
{
	Initialize(value.GetValue(), value.GetValueLength());
}

ProvOctetString::~ProvOctetString ()
{
	UnReplicate(val);
}


ULONG ProvOctetString::GetValueLength () const 
{ 
	return length; 
}

UCHAR *ProvOctetString::GetValue () const 
{ 
	return val; 
}

ProvValue *ProvOctetString::Copy () const 
{
	return new ProvOctetString(val, length);
}
	
UCHAR *ProvOctetString::Replicate(IN const UCHAR *value, IN const ULONG valueLength)
{
	if ( value )
	{
		UCHAR *temp = new UCHAR[valueLength];

		memcpy(temp, value, sizeof(UCHAR)*valueLength);

		return temp;
	}
	else
	{
		return NULL ;
	}
}

void ProvOctetString::SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
{
	if (length != valueLength)
	{
		UnReplicate(val);
		Initialize(value, valueLength);
	}
	else
		OverWrite(value);
}

BOOL ProvOctetString :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvOctetString &)value);
	}

	return bResult;
}

BOOL ProvOctetString::Equivalent(IN const ProvOctetString &Prov_octet_string) const
{
	if ( is_valid && Prov_octet_string() )
	{
		if ( length != Prov_octet_string.GetValueLength() )
			return FALSE;

		UCHAR *octet_values = Prov_octet_string.GetValue();

		for( UINT i=0; i < length; i++)
		{
			if ( val[i] != octet_values[i] )
				return FALSE;
		}

		return TRUE;
	}
	else
		return FALSE;
}

void ProvObjectIdentifier::OverWrite(IN const ULONG *value)
{
	if ( value )
	{
		memcpy(val, value, sizeof(ULONG)*length);
	}
}

void ProvObjectIdentifier::Initialize(IN const ULONG *value, IN const ULONG valueLength)
{	
	if ( ( (value == NULL) && (valueLength != 0) ) || ( valueLength == 0 ) )
	{
		length = 0 ;
		val = NULL ;
		return;
	}

	length = valueLength;

	if ( length <= DEFAULT_OBJECTIDENTIFIER_LENGTH )
	{
		val = m_value ;
		memcpy(val , value, sizeof(ULONG)*length);
		is_valid = TRUE;

	}
	else
	{
		val = new ULONG[length];
		memcpy(val , value, sizeof(ULONG)*length);
		is_valid = TRUE;
	}
}

void ProvObjectIdentifier::UnReplicate(ULONG *value)
{
	if ( ( is_valid == TRUE ) & ( length > DEFAULT_OBJECTIDENTIFIER_LENGTH ) )
	{
		delete[] val;
	}
}

ProvObjectIdentifier::ProvObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{	
	Initialize(value, valueLength);
}

ProvObjectIdentifier::ProvObjectIdentifier ( IN const ProvObjectIdentifier &value ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{
	Initialize(value.GetValue(), value.GetValueLength());
}

ProvObjectIdentifier::~ProvObjectIdentifier ()
{
	UnReplicate(val);
}

ULONG ProvObjectIdentifier::GetValueLength () const 
{ 
	return length; 
}

ULONG *ProvObjectIdentifier::GetValue () const 
{ 
	return val; 
}

ProvValue *ProvObjectIdentifier::Copy () const 
{
	return new ProvObjectIdentifier(val, length);
}

		
ULONG *ProvObjectIdentifier::Replicate(IN const ULONG *value, IN const ULONG valueLength) const
{
	if ( value )
	{
		ULONG *temp = new ULONG[valueLength];
		memcpy(temp, value, sizeof(ULONG)*valueLength);
		return temp;
	}
	else
	{
		return NULL ;
	}
}

		
ULONG *ProvObjectIdentifier::Replicate(IN const ULONG *first_value, 
									   IN const ULONG first_length,
									   IN const ULONG *second_value,
									   IN const ULONG second_length) const
{
	if ( first_value && second_value )
	{
		ULONG new_length = first_length + second_length;
		ULONG *temp = new ULONG[new_length];
			
		int first_value_size = sizeof(ULONG)*first_length;

		memcpy(temp, first_value, first_value_size);
		memcpy(temp + first_length, second_value, 
					sizeof(ULONG)*second_length);
		return temp;
	}
	else if ( first_value )
	{
		ULONG *temp = new ULONG [ first_length];
		memcpy(temp, first_value, sizeof(ULONG)*first_length);
		return temp;
	}
	else if ( second_value )
	{
		ULONG *temp = new ULONG [ second_length];
		memcpy(temp, second_value, sizeof(ULONG)*second_length);
		return temp;

	}
	else
	{
		return NULL ;
	}
}


ProvObjectIdentifier::Comparison ProvObjectIdentifier::Compare(IN const ProvObjectIdentifier &first, 
															   IN const ProvObjectIdentifier &second) const
{
	ULONG *first_string = first.GetValue();
	ULONG *second_string = second.GetValue();
	int first_length = first.GetValueLength();
	int second_length = second.GetValueLength();
	int min_length = MIN(first_length,second_length);

	for(int i=0; i < min_length; i++)
	{
		if ( first_string[i] < second_string[i] )
			return LESS_THAN;
		else if ( first_string[i] > second_string[i] )
			return GREATER_THAN;
		else
			continue;
	}

	if ( first_length < second_length )
		return LESS_THAN;
	else if ( first_length > second_length )
			return GREATER_THAN;
	else
		return EQUAL_TO;
}

void ProvObjectIdentifier::SetValue ( IN const ULONG *value , IN const ULONG valueLength )
{
	if (valueLength)
	{
		if ( length != valueLength)
		{
			UnReplicate(val);
			Initialize(value, valueLength);
		}
		else
		{
			OverWrite(value);
		}
	}
	else
	{
		UnReplicate(val);
		val = NULL ;
		length = 0 ;
	}
}

// A null terminated dot-separated string representing the 
// object identifer value is passed and the private fields
// and length are set from it
ProvObjectIdentifier::ProvObjectIdentifier(IN const char *value)
{
	is_valid = FALSE;

	UINT str_len = strlen(value);
	if ( str_len <= 0 )
		return;

	ULONG temp_field[MAX_FIELDS];

	// create an input stream from the string
	istrstream input_stream((char *)value);

	// consecutive fields must be separated by a
	// FIELD_SEPARATOR
	char separator;

	input_stream >> temp_field[0];

  	if ( input_stream.bad() || input_stream.fail() )
		return;

	// while the stream still has something,
	// read (FIELD_SEPARATOR, ULONG) pairs from the input stream
	// and set the temp_fields
	// check if the read was bad or failed after the event
	for( int i = 1 ; (i < MAX_FIELDS) && (!input_stream.eof()); i++)
	{
		input_stream >> separator;

  		if ( input_stream.bad() || input_stream.fail() )
			return;

		if ( separator != FIELD_SEPARATOR )
			return;

		input_stream >> temp_field[i];
 
		if ( input_stream.bad() || input_stream.fail() )
			return;
	}

	is_valid = TRUE;

	// set the length
	length = i;
	val = NULL ;

	// create memory for the fields and copy temp_fields into it
	Initialize(temp_field, length);
}


BOOL ProvObjectIdentifier::Equivalent(IN const ProvObjectIdentifier &value,
									   IN ULONG max_length) const
{
	if ( (!is_valid) || (!value()) )
		return FALSE;

	if ( (length < max_length) || (value.GetValueLength() < max_length) )
		return FALSE;

	ULONG *value_string = value.GetValue();

	for( UINT i=0; i < max_length; i++ )
		if ( val[i] != value_string[i] )
			return FALSE;

	return TRUE;
}

BOOL ProvObjectIdentifier::Equivalent(IN const ProvObjectIdentifier &value) const
{
	if ( (!is_valid) || (!value()) )
		return FALSE;

	ULONG *value_string = value.GetValue();

	for( UINT i=length; i ; i-- )
	{
		if ( val[i-1] != value_string[i-1] )
			return FALSE;
	}

	return TRUE;
}

BOOL ProvObjectIdentifier :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvObjectIdentifier &)value);
	}

	return bResult;
}

ProvObjectIdentifier ProvObjectIdentifier::operator+ ( IN const ProvObjectIdentifier &value ) const
{	
	ULONG *temp_plus_array = Replicate(val, length, value.GetValue(), value.GetValueLength());

	ProvObjectIdentifier local_identifier(temp_plus_array, length+value.GetValueLength());
	delete[] temp_plus_array;

	return ProvObjectIdentifier(local_identifier);
}

// Determines the fields (starting from left), common to the
// two object identifiers and returns a new object identifier
// with only these fields. If nothing is shared, NULL is returned
ProvObjectIdentifier *ProvObjectIdentifier::Cut( ProvObjectIdentifier &value ) const
{
	// determine the smaller of the two lengths
	int min_length = MIN(length, value.GetValueLength());
	ULONG *other_field = value.GetValue();

	// compare the fields
	for(int index=0; index < min_length; index++)
		if ( val[index] != other_field[index] )
			break;

	// if nothing in common - return NULL
	if ( index == 0 )
		return NULL;

	// they must have the fields in the range [0..(index-1)] common
	// therefore, a common length of "index"
	return new ProvObjectIdentifier(other_field, index);
}


ULONG &ProvObjectIdentifier::operator [] ( IN const ULONG index ) const
{
	if ( index < length )
		return val[index];

	// should never reach here if the user checks the
	// index value before
	return val[0];
}

//returns an allocated char* representation of the OID.
//The return value  must be freed by the caller i.e. delete []
char *ProvObjectIdentifier::GetAllocatedString() const
{
	char * retVal = NULL ;

	if (length)
	{
		retVal = new char [ length * 18 ] ;
		ostrstream s ( retVal , length * 18 ) ;
		s << val[0];
		UINT i = 1;
		char dot = '.';

		while (i < length)
		{
			s << dot << val[i++] ;
		}
		
		s << ends ;
	}

	return retVal;
}
		

ProvIpAddress::ProvIpAddress ( IN const char *value )
{
	// create a stream to read the fields from
	istrstream address_stream((char *)value);

	// store the values [0..255] separated by FIELD_SEPARATORs
	// in the value string
	UCHAR field[PROV_IP_ADDR_LEN];

	// contains the maximum value for a UCHAR. used
	// for comparison with the field values read
	const UCHAR max_uchar = -1;

	// consecutive fields must be separated by a
	// FIELD_SEPARATOR
	char separator;

	// a field is first read into this for comparison
	// with max_uchar
	ULONG temp_field;

	is_valid = FALSE;

	// read the first three (UCHAR,FIELD_SEPARATOR) pairs
	// check if the stream is good before each read
	for(int i=0; i < (PROV_IP_ADDR_LEN-1); i++)
	{
		if ( !address_stream.good() )
			return;

		address_stream >> temp_field;
		if ( temp_field	> max_uchar )
			return;

		field[i] = (UCHAR)temp_field;

		if ( !address_stream.good() )
			return;

		address_stream >> separator;
		if ( separator != FIELD_SEPARATOR )
			return;
	}

	if ( !address_stream.good() )
		return;

	address_stream >> temp_field;
	if (temp_field > max_uchar)
		return;

	field[PROV_IP_ADDR_LEN-1] = (UCHAR)temp_field;

	// make sure that there are is nothing more left in the
	// stream
	if ( !address_stream.eof() )
		return;

	ULONG byteA = field [ 0 ] ;
	ULONG byteB = field [ 1 ] ;
	ULONG byteC = field [ 2 ] ;
	ULONG byteD = field [ 3 ] ;

	val = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

	is_valid = TRUE;
}


// Copy constructor
ProvIpAddress::ProvIpAddress ( IN const ProvIpAddress &value )
{
	if ( value() )
	{
		val = value.GetValue();
		is_valid = TRUE;
	}
	else
		is_valid = FALSE;
}

BOOL ProvIpAddress :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvIpAddress &)value);
	}

	return bResult;
}


ULONG ProvIpAddress::GetValue () const
{ 
	return val; 
}

void ProvIpAddress::SetValue ( IN const ULONG value ) 
{ 
	val = value;
	is_valid = TRUE;
}

ProvValue *ProvIpAddress::Copy () const 
{ 
	return new ProvIpAddress(val);
}

// Copy constructor
ProvUInteger32::ProvUInteger32 ( IN const ProvUInteger32 &value )
{
	val = value.GetValue();
}

ULONG ProvUInteger32::GetValue () const
{ 
	return val; 
}

void ProvUInteger32::SetValue ( IN const ULONG value ) 
{ 
	val = value; 
}

ProvValue *ProvUInteger32::Copy () const 
{ 
	return new ProvUInteger32(val);
}

BOOL ProvUInteger32 :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvUInteger32 &)value);
	}

	return bResult;
}

// Copy constructor
ProvCounter64::ProvCounter64( IN const ProvCounter64 &value )
{
	lval = value.GetLowValue();
	hval = value.GetHighValue();
}

ULONG ProvCounter64::GetLowValue () const
{ 
	return lval; 
}

ULONG ProvCounter64::GetHighValue () const
{ 
	return hval; 
}

void ProvCounter64::SetValue ( IN const ULONG lvalue , IN const ULONG hvalue ) 
{ 
	lval = lvalue; 
	hval = hvalue ;
}

ProvValue *ProvCounter64::Copy () const 
{ 
	return new ProvCounter64(lval,hval);
}

BOOL ProvCounter64 :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvCounter64 &)value);
	}

	return bResult;
}

BOOL ProvOpaque :: Equivalent (IN const ProvValue &value) const
{
	BOOL bResult = FALSE;

	if (typeid(*this) == typeid(value))
	{
		bResult = Equivalent((const ProvOpaque &)value);
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provevt.h ===
//***************************************************************************

//

//  PROVEVT.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVEVT_H__
#define __PROVEVT_H__

#ifdef PROVIMEX_INIT
class __declspec ( dllexport ) ProvEventObject
#else
class __declspec ( dllimport ) ProvEventObject
#endif
{
private:

	HANDLE m_event ;

protected:
public:

	ProvEventObject ( const TCHAR *globalEventName = NULL ) ;
	virtual ~ProvEventObject () ;

	HANDLE GetHandle () ;
	void Set () ;
	void Clear () ;

	virtual void Process () ;
	virtual BOOL Wait () ;
	virtual void Complete () ;
} ;

#endif //__PROVEVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provdnf.h ===
// (C) 1999-2001 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <stdio.h>
#include <wmiutils.h>

#include "ProvTree.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiTriState
{
	State_False		= 0 ,
	State_True		= 1 ,
	State_Error		= 0xFFFFFFFF
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TypeId_WmiOrNode						1
#define TypeId_WmiAndNode						2
#define TypeId_WmiNotNode						3
#define TypeId_WmiOperatorNode					4
#define TypeId_WmiOperatorEqualNode				5
#define TypeId_WmiOperatorNotEqualNode			6
#define TypeId_WmiOperatorEqualOrGreaterNode	7
#define TypeId_WmiOperatorEqualOrLessNode		8
#define TypeId_WmiOperatorGreaterNode			9
#define TypeId_WmiOperatorLessNode				10
#define TypeId_WmiOperatorLikeNode				11
#define TypeId_WmiOperatorNotLikeNode			12
#define TypeId_WmiOperatorIsANode				13
#define TypeId_WmiOperatorNotIsANode			14
#define TypeId_WmiValueNode						15
#define TypeId_WmiSignedIntegerNode				16	
#define TypeId_WmiUnsignedIntegerNode			17
#define TypeId_WmiStringNode					18
#define TypeId_WmiNullNode						19
#define TypeId_WmiRangeNode						20
#define TypeId_WmiUnsignedIntegerRangeNode		21
#define TypeId_WmiSignedIntegerRangeNode		22
#define TypeId_WmiStringRangeNode				23
#define TypeId_WmiNullRangeNode					24

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiOrNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiAndNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiNotNode , NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiRangeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		TypeId_TreeNode a_Type , 
		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiRangeNode *GetRange () = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () { return NULL ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrLessNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLessNode , a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class DllImportExport WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorIsANode , a_Node , a_Parent ) {}

	~WmiOperatorIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiOperatorNotIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotIsANode , a_Node , a_Parent ) {}

	~WmiOperatorNotIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = 0 ,
		Function_Upper = 1 ,
		Function_Lower = 2
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;

			if ( m_PropertyName == NULL )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiSignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiUnsignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiStringNode ,
			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = towlower ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = towupper ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else
			{
				m_String = SysAllocString ( a_String ) ;
			}

			if ( m_String == NULL )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_String = NULL ;
		}
	}

	~WmiStringNode ()
	{
		if ( m_String )
		{
			SysFreeString ( m_String ) ;
		}
	} ;

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( BSTR &a_String )
	{
		if ( wcscmp ( L"" , m_String ) == 0 )
		{
			return FALSE ;
		}
		else
		{
			ULONG t_StringLen = wcslen ( m_String ) ;
			wchar_t *t_String = NULL ;

			if ( m_String [ t_StringLen - 1 ] == 0x01 )
			{
				t_String = new wchar_t [ t_StringLen ] ;
				wcsncpy ( t_String , m_String , t_StringLen - 1 ) ;
				t_String [ t_StringLen ] = 0 ;
			}
			else
			{
				t_String = new wchar_t [ t_StringLen + 1 ] ;
				wcscpy ( t_String , m_String ) ;
				t_String [ t_StringLen - 1 ] = t_String [ t_StringLen - 1 ] - 1 ;
			}			
			
			a_String = SysAllocString ( t_String ) ;
			delete [] t_String ;

			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( BSTR &a_String )
	{
		ULONG t_StringLen = wcslen ( m_String ) ;
		wchar_t *t_String = new wchar_t [ t_StringLen + 2 ] ;
		wcscpy ( t_String , m_String ) ;
		t_String [ t_StringLen ] = 0x01 ;
		t_String [ t_StringLen ] = 0x00 ;

		a_String = SysAllocString ( t_String ) ;

		delete [] t_String ;

		return TRUE ;
	}

	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiNullNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

public:

	WmiRangeNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( a_Type , NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;

			if ( NULL == m_PropertyName )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_PropertyName = NULL ;
		}
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
		{
			SysFreeString ( m_PropertyName ) ;
		}
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;
	
	WmiTriState GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Before ,
		WmiUnsignedIntegerRangeNode *&a_Intersection ,
		WmiUnsignedIntegerRangeNode *&a_After 
	) ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiUnsignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Before ,
		WmiSignedIntegerRangeNode *&a_Intersection ,
		WmiSignedIntegerRangeNode *&a_After 
	) ;

public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiSignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class DllImportExport WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Before ,
		WmiStringRangeNode *&a_Intersection ,
		WmiStringRangeNode *&a_After 
	) ;

public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiStringRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
		{
			m_LowerBound = SysAllocString ( a_LowerBound ) ;

			if ( NULL == m_LowerBound )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_LowerBound = NULL ;
		}

		if ( a_UpperBound )
		{
			m_UpperBound = SysAllocString ( a_UpperBound ) ;

			if ( NULL == m_UpperBound )
			{
				throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
			}
		}
		else
		{
			m_UpperBound = NULL ;
		}
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
		{
			SysFreeString ( m_LowerBound ) ;
		}

		if ( m_UpperBound )
		{
			SysFreeString ( m_UpperBound ) ;
		}
	} ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiNullRangeNode ,
			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount ) ,
		m_RangeContainer ( NULL )
	{
	}

	~Conjunctions () 
	{
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				delete m_RangeContainer [ t_Index ] ;
			}

			delete [] m_RangeContainer ;
		}
	} ;	

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_RangeContainer = new WmiRangeNode * [ m_RangeContainerCount ] ;
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				m_RangeContainer [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ; 
		}

		return t_Status ;
	}

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
			{
				delete m_RangeContainer [ a_Index ] ;
			}

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount ) ,
		m_Disjunction ( NULL )
	{
	}

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				m_Disjunction [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = new Conjunctions ( m_ConjunctionCount ) ;
				if ( t_Disjunction )
				{
					t_Status = t_Disjunction->Initialize () ;
					if ( t_Status != State_True )
					{
						break ;
					}
				}
				else
				{
					t_Status = State_Error ;
					break ;
				}

				m_Disjunction [ t_Index ] = t_Disjunction ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}

	~Disjunctions () 
	{
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
				delete t_Disjunction ;
			}
			
			delete [] m_Disjunction ;
		}
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;

		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
			{
				delete m_NonOverlappingPartitions [ t_Index ] ;
			}

			delete [] m_NonOverlappingPartitions ;
		}
	}

public:

	WmiTriState Initialize ( ULONG a_Count ) 
	{
		WmiTriState t_Status = State_True ;

		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
			{
				m_NonOverlappingPartitions [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
		}
	}

public:

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }

	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			return m_NonOverlappingPartitions [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL RecursiveEvaluate ( 

		void *a_Context ,
		SQL_LEVEL_1_RPN_EXPRESSION & a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node ,
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;

	WmiTriState EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveRemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	WmiTriState InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	WmiTriState RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	WmiTriState SortConditionals ( WmiTreeNode *&a_Root ) ;
	WmiTriState RecursiveSort ( WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;

	WmiTriState CreateDisjunctions ( 

		void *a_Context ,
		WmiTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	WmiTriState RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) ;

	virtual QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 

	) { return NULL ; }

protected:

	BOOL Evaluate (

		void *a_Context ,
		SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
		WmiTreeNode **a_Root
	) ;

	QuadState DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;

	void RecursiveQuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Lower , 
		ULONG a_Upper
	) ;

	void QuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Size
	) ;

	void SortRanges (

		ULONG a_DisjunctionCount ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	WmiTriState RemoveOverlaps (

		ULONG *a_DisjunctionSetToTest ,
		ULONG a_DisjunctionCount ,
		ULONG *a_OverlappingIndex ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	QuadState RemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState Sort ( WmiTreeNode *&a_Root ) ;

	WmiTriState ConvertToRanges ( WmiTreeNode *&a_Root ) ;

	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;

	WmiTriState CreateDisjunctionContainer (

		void *a_Context , 
		WmiTreeNode *a_Root , 
		ULONG a_Count , 
		BSTR *a_Container , 
		Disjunctions *&a_Disjunctions
	) ;

	WmiTriState CreatePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition
	) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QueryPreprocessor () ;
	virtual ~QueryPreprocessor () ;

	QuadState PreProcess (

		void *a_Context , 
		SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
		WmiTreeNode *&a_Root
	) ;

	QuadState PreProcess ( 

		void *a_Context ,
		SQL_LEVEL_1_RPN_EXPRESSION *a_RpnExpression , 
		WmiTreeNode *a_Root ,
		ULONG a_Count , 
		BSTR *a_Container , 
		PartitionSet *&a_Partition
	) ;

	QuadState Query ( 

		BSTR a_Query ,
		SQL_LEVEL_1_RPN_EXPRESSION *&a_RpnExpression
	) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provtree.h ===
// (C) 1999-2001 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef DWORD TypeId_TreeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DllImportExport WmiTreeNode 
{
protected:

	TypeId_TreeNode m_Type ;

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;
	
public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Type = a_Node->m_Type ;
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
	}

	WmiTreeNode ( 

		TypeId_TreeNode a_Type = 0 ,
		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) 
	{
		m_Type = a_Type ;
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Right->SetParent ( this ) ;
	}

	virtual ~WmiTreeNode () {}

	TypeId_TreeNode GetType ()
	{
		return m_Type ;
	}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void SetType ( TypeId_TreeNode a_Type )
	{
		m_Type = a_Type ;
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class DllImportExport WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provimex.h ===
//***************************************************************************

//

//  PROVIMEX.H

//

//  Module: 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef __PROVIMEX_H__
#define __PROVIMEX_H__

#define DllImport __declspec ( dllimport )
#define DllExport __declspec ( dllexport )

#ifdef PROVIMEX_INIT
#define DllImportExport __declspec ( dllexport )
#else
#define DllImportExport __declspec ( dllimport )
#endif

#endif //__PROVIMEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provlog.h ===
//***************************************************************************

//

//  PROVLOG.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVLOG_H
#define __PROVLOG_H

#ifdef PROVDEBUG_INIT
class __declspec ( dllexport ) ProvDebugLog
#else
class __declspec ( dllimport ) ProvDebugLog
#endif
{
public:

	enum ProvDebugContext
	{
		FILE = 0 ,
		DEBUG = 1 
	} ;

private:

	CRITICAL_SECTION m_CriticalSection ;

	static long s_ReferenceCount ;
	enum ProvDebugContext m_DebugContext ;
	BOOL m_Logging ;
	DWORD m_DebugLevel ;
	DWORD m_DebugFileSize;
	TCHAR *m_DebugComponent ;
	TCHAR *m_DebugFile ;
    TCHAR *m_DebugFileUnexpandedName;
	HANDLE m_DebugFileHandle ;
	static BOOL s_Initialised ;

	static void SetEventNotification () ;

	void LoadRegistry_Logging  () ;
	void LoadRegistry_Level () ;
	void LoadRegistry_File () ;
	void LoadRegistry_FileSize () ;
	void LoadRegistry_Type () ;

	void SetRegistry_Logging  () ;
	void SetRegistry_Level () ;
	void SetRegistry_File () ;
	void SetRegistry_FileSize () ;
	void SetRegistry_Type () ;
	void SetDefaultFile () ;

	void OpenFileForOutput () ;
	void OpenOutput () ;
	void CloseOutput () ;
	void FlushOutput () ;
	void SwapFileOver () ;
	void WriteOutput ( const TCHAR *a_DebugOutput ) ;
	void WriteOutputW ( const WCHAR *a_DebugOutput ) ;
	void WriteOutputA ( const char *a_DebugOutput ) ;

protected:
public:

	ProvDebugLog ( const TCHAR *a_DebugComponent ) ;
	virtual ~ProvDebugLog () ;

	/*************************************************************************
	* There are 3 functions to write to a log file, which may be used in accordance with the following rules:
	*
	*	1. The user always knows whether he is writing to an ANSI file or a Unicode file, and he
	*		has to make sure this holds good in the rules 2, 3 and 4 below. This will be changed later to
	*		make it more flowxible to the user.
	*	2. Write() takes TCHAR arguments and the function will write and ANSI or Unicode string
	*		to the log file depending on what TCHAR maps to, in the compilation.
	*	3. WriteW() takes WCHAR arguments only, and expects that the file being written to is a Unicode file.
	*	4. WriteA() takes char arguments only, and expects that the file being written to is an ANSI file.
	*
	****************************************************************/
	void Write ( const TCHAR *a_DebugFormatString , ... ) ;
	void WriteFileAndLine ( const TCHAR *a_File , const ULONG a_Line , const TCHAR *a_DebugFormatString , ... ) ;
	void WriteW ( const WCHAR *a_DebugFormatString , ... ) ;
	void WriteFileAndLineW ( const WCHAR *a_File , const ULONG a_Line , const WCHAR *a_DebugFormatString , ... ) ;
	void WriteA ( const char *a_DebugFormatString , ... ) ;
	void WriteFileAndLineA ( const char *a_File , const ULONG a_Line , const char *a_DebugFormatString , ... ) ;
	void Flush () ;

	void LoadRegistry () ;
	void SetRegistry () ;

	void SetLevel ( const DWORD &a_DebugLevel ) ;
	DWORD GetLevel () ;

	void SetContext ( const enum ProvDebugContext &a_DebugContext ) ;
	enum ProvDebugContext GetContext () ;

	void SetFile ( const TCHAR *a_File ) ;
    void ProvDebugLog::SetExpandedFile( 
        const TCHAR *a_RawFileName);
	TCHAR *GetFile () ;

	void SetLogging ( BOOL a_Logging = TRUE ) ;
	BOOL GetLogging () ;

	void CommitContext () ;

	static ProvDebugLog *s_ProvDebugLog ;

	static BOOL Startup () ;
	static void Closedown () ;

public:

	static CRITICAL_SECTION s_CriticalSection ;
} ;

inline DWORD ProvDebugLog :: GetLevel ()
{
	EnterCriticalSection(&m_CriticalSection) ;
	DWORD t_Level = m_DebugLevel ;
	LeaveCriticalSection(&m_CriticalSection) ;
	return t_Level ;
}

inline TCHAR *ProvDebugLog :: GetFile ()
{
	EnterCriticalSection(&m_CriticalSection) ;
	TCHAR *t_File = m_DebugFile ;
	LeaveCriticalSection(&m_CriticalSection) ;

	return t_File ;
}

inline BOOL ProvDebugLog :: GetLogging () 
{
	return m_Logging ;
}

#define DebugMacro(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro0(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 1 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro1(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 2 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro2(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 4 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro3(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 8 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro4(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 16 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro5(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 32 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro6(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ProvDebugLog :: s_ProvDebugLog->GetLogging () && ( ProvDebugLog :: s_ProvDebugLog->GetLevel () & 64 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro7(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 128 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro8(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 256 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro9(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 512 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro10(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 1024 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro11(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 2048 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro12(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 4096 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro13(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 8192 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro14(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 16384 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro15(a) { \
\
	if ( ProvDebugLog :: s_ProvDebugLog && ( ProvDebugLog :: s_ProvDebugLog->GetLogging () ) && ( ( ProvDebugLog :: s_ProvDebugLog->GetLevel () ) & 32768 ) ) \
	{ \
		{a ; } \
	} \
} 

#endif __PROVLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provthrd.h ===
//***************************************************************************

//

//  PROVTHRD.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVTHREAD_PROVTHRD_H__
#define __PROVTHREAD_PROVTHRD_H__

#include <Allocator.h>
#include <Queue.h>
#include <RedBlackTree.h>

extern WmiAllocator g_Allocator ;

class ProvThreadObject ;
class ProvAbstractTaskObject ;
class ProvTaskObject ;

typedef WmiRedBlackTree <HANDLE,ProvEventObject *> ScheduleReapContainer ;
typedef WmiRedBlackTree <HANDLE,ProvEventObject *> :: Iterator ScheduleReapContainerIterator ;

typedef WmiRedBlackTree <DWORD,ProvThreadObject *> ThreadContainer ;
typedef WmiRedBlackTree <DWORD,ProvThreadObject *> :: Iterator ThreadContainerIterator ;

typedef WmiQueue <ProvAbstractTaskObject *,8> TaskQueue ;

#ifdef PROVTHRD_INIT
class __declspec ( dllexport ) ProvThreadObject : private ProvEventObject
#else
class __declspec ( dllimport ) ProvThreadObject : private ProvEventObject
#endif
{
friend ProvAbstractTaskObject ;
friend BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
) ;

private:

	static LONG s_ReferenceCount ;

// Mutual exclusion mechanism

	static CCriticalSection s_Lock ;

	ScheduleReapContainer m_ScheduleReapContainer ;

// Thread Name

	TCHAR *m_ThreadName ;

// Terminate thread event

	ProvEventObject m_ThreadTerminateEvent ;

// TaskObject created if a PostSignalThreadShutdown is called

	ProvAbstractTaskObject *m_pShutdownTask ;

// Thread Initialization Event

	HANDLE m_ThreadInitialization ;

// thread information

	ULONG m_ThreadId ;
	HANDLE m_ThreadHandle ;
	DWORD m_timeout;

// list of task objects associated with thread object

	TaskQueue m_TaskQueue ;

// Evict thread from process

	void TerminateThread () ;

// Attach thread to global list of threads

	BOOL RegisterThread () ;

private:

// global list of thread objects keyed on thread identifier

	static ThreadContainer s_ThreadContainer ;

	HANDLE *m_EventContainer ;
	ULONG m_EventContainerLength ;

	HANDLE *GetEventHandles () ;
	ULONG GetEventHandlesSize () ;

	void ConstructEventContainer () ;

	void Process () ;
	BOOL Wait () ;

	ProvAbstractTaskObject *GetTaskObject ( HANDLE &eventHandle ) ;

	BOOL WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated ) ;

private:

// Thread entry point

	static void _cdecl ThreadExecutionProcedure ( void *threadParameter ) ;

// Attach Process

	static void ProcessAttach () ;

// Detach Process

	static void ProcessDetach ( BOOL a_ProcessDetaching = FALSE ) ;

	HANDLE *GetThreadHandleReference () { return &m_ThreadHandle ; }

protected:
public:

	ProvThreadObject ( const TCHAR *a_ThreadName = NULL, DWORD a_timeout = INFINITE ) ;

	void BeginThread();

	virtual ~ProvThreadObject () ;

	void WaitForStartup () ;

	void SignalThreadShutdown () ;
	void PostSignalThreadShutdown () ;

// Get thread information

	ULONG GetThreadId () { return m_ThreadId ; }
	HANDLE GetThreadHandle () { return m_ThreadHandle ; }

	BOOL ScheduleTask ( ProvAbstractTaskObject &a_TaskObject ) ;
	BOOL ReapTask ( ProvAbstractTaskObject &a_TaskObject ) ;

	virtual void Initialise () {} ;
	virtual void Uninitialise () {} ;
	virtual void TimedOut() {} ;

// Get Thread object associated with current thread

	static ProvThreadObject *GetThreadObject () ;

	static BOOL Startup () ;
	static void Closedown() ;

} ;

#ifdef PROVTHRD_INIT
class __declspec ( dllexport ) ProvAbstractTaskObject 
#else
class __declspec ( dllimport ) ProvAbstractTaskObject 
#endif
{
friend ProvThreadObject ;
private:

// list of thread objects keyed on thread identifier

	ThreadContainer m_ThreadContainer ;

	CCriticalSection m_Lock ;

	ProvEventObject m_CompletionEvent ;
	ProvEventObject m_AcknowledgementEvent ;
	HANDLE m_ScheduledHandle;
	DWORD m_timeout;

	BOOL WaitDispatch ( ProvThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;
	BOOL WaitAcknowledgementDispatch ( ProvThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;

	void AttachTaskToThread ( ProvThreadObject &a_ThreadObject ) ;
	void DetachTaskFromThread ( ProvThreadObject &a_ThreadObject ) ;

protected:

	ProvAbstractTaskObject ( 

		const TCHAR *a_GlobalTaskNameComplete = NULL, 
		const TCHAR *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	virtual HANDLE GetHandle() = 0;

public:

	virtual ~ProvAbstractTaskObject () ;

	virtual void Process () { Complete () ; }
	virtual void Exec () {} ;
	virtual void Complete () { m_CompletionEvent.Set () ; }
	virtual BOOL Wait ( BOOL a_Dispatch = FALSE ) ;
	virtual void Acknowledge () { m_AcknowledgementEvent.Set () ; } 
	virtual BOOL WaitAcknowledgement ( BOOL a_Dispatch = FALSE ) ;
	virtual void TimedOut() {} ;
} ;

#ifdef PROVTHRD_INIT
class __declspec ( dllexport ) ProvTaskObject : public ProvAbstractTaskObject 
#else
class __declspec ( dllimport ) ProvTaskObject : public ProvAbstractTaskObject 
#endif
{
private:
	ProvEventObject m_Event;
protected:
public:

	ProvTaskObject ( 

		const TCHAR *a_GlobalTaskNameStart = NULL , 
		const TCHAR *a_GlobalTaskNameComplete = NULL,
		const TCHAR *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	~ProvTaskObject () {} ;
	void Exec () { m_Event.Set(); }
	HANDLE GetHandle () { return m_Event.GetHandle() ; }
} ;

#endif //__PROVTHREAD_PROVTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provtype.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include <provexpt.h>

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString ) ;
DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString ) ;
DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;
DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;

class DllImportExport CBString
{
private:

    BSTR    m_pString;

public:

    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) 
		{
            SysFreeString(m_pString);
        }
        
		m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#if _MSC_VER >= 1100
template <> DllImportExport UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
DllImportExport UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * HmmHack_wchar_t ;
template<> DllImportExport BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const HmmHack_wchar_t *pElement1, const HmmHack_wchar_t *pElement2 ) ;
#else
DllImportExport BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

union ProvLexiconValue
{
	LONG signedInteger ;
	ULONG unsignedInteger ;
	wchar_t *token ;
} ;

class ProvAnalyser;
class DllImportExport ProvLexicon
{
friend ProvAnalyser ;
public:

enum LexiconToken {

	TOKEN_ID ,
	SIGNED_INTEGER_ID ,
	UNSIGNED_INTEGER_ID ,
	COLON_ID ,
	COMMA_ID ,
	OPEN_PAREN_ID ,
	CLOSE_PAREN_ID ,
	DOT_ID ,
	DOTDOT_ID ,
	PLUS_ID ,
	MINUS_ID ,
	EOF_ID,
	WHITESPACE_ID,
	INVALID_ID,
	USERDEFINED_ID
} ;

private:

	wchar_t *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	ProvLexiconValue value ;

protected:
public:

	ProvLexicon () ;
	~ProvLexicon () ;

	void SetToken ( ProvLexicon :: LexiconToken a_Token ) ;
	ProvLexicon :: LexiconToken GetToken () ;
	ProvLexiconValue *GetValue () ;
} ;

#define ANALYSER_ACCEPT_STATE 10000
#define ANALYSER_REJECT_STATE 10001

/* 
	User defined states should be greater than 20000
 */

class DllImportExport ProvAnalyser
{
private:

	wchar_t *stream ;
	ULONG position ;
	BOOL status ;

	ProvLexicon *GetToken (  BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

protected:

	virtual void Initialise () {} ;

	virtual ProvLexicon *CreateLexicon () { return new ProvLexicon ; }

	virtual BOOL Analyse ( 

		ProvLexicon *lexicon , 
		ULONG &state , 
		const wchar_t token , 
		const wchar_t *tokenStream , 
		ULONG &position , 
		BOOL unSignedIntegersOnly , 
		BOOL leadingIntegerZeros , 
		BOOL eatSpace 
	) 
	{ return FALSE ; }

public:

	ProvAnalyser ( const wchar_t *tokenStream = NULL ) ;
	virtual ~ProvAnalyser () ;

	void Set ( const wchar_t *tokenStream ) ;

	ProvLexicon *Get ( BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

	void PutBack ( const ProvLexicon *token ) ;

	virtual operator void * () ;

	static BOOL IsEof ( wchar_t token ) ;
	static BOOL IsLeadingDecimal ( wchar_t token ) ;
	static BOOL IsDecimal ( wchar_t token ) ;
	static BOOL IsOctal ( wchar_t token ) ;
	static BOOL IsHex ( wchar_t token ) ;	
	static BOOL IsAlpha ( wchar_t token ) ;
	static BOOL IsAlphaNumeric ( wchar_t token ) ;
	static BOOL IsWhitespace ( wchar_t token ) ;

	static ULONG OctWCharToDecInteger ( wchar_t token ) ;
	static ULONG HexWCharToDecInteger ( wchar_t token ) ;
	static ULONG DecWCharToDecInteger ( wchar_t token ) ;
	static wchar_t DecIntegerToHexWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToDecWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToOctWChar ( UCHAR integer ) ;

	static ULONG OctCharToDecInteger ( char token ) ;
	static ULONG HexCharToDecInteger ( char token ) ;
	static ULONG DecCharToDecInteger ( char token ) ;
	static char DecIntegerToHexChar ( UCHAR integer ) ;
	static char DecIntegerToDecChar ( UCHAR integer ) ;
	static char DecIntegerToOctChar ( UCHAR integer ) ;

} ;

class DllImportExport ProvNegativeRangeType
{
private:
protected:

	LONG lowerBound ;
	LONG upperBound ;

public:

	ProvNegativeRangeType ( const ProvNegativeRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	ProvNegativeRangeType ( LONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	ProvNegativeRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~ProvNegativeRangeType () {}


	LONG GetLowerBound () { return lowerBound ; }
	LONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const LONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const LONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual ProvNegativeRangeType *Copy () { return new ProvNegativeRangeType ( *this ) ; }
} ;

class ProvNegativeRangedType
{
private:
protected:

	BOOL status ;

	ProvList <ProvNegativeRangeType,ProvNegativeRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	ProvNegativeRangedType ( const ProvNegativeRangedType &rangedValues ) ;
	ProvNegativeRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~ProvNegativeRangedType () ;

	BOOL IsValid () { return status ; }

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL Check ( const LONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; } 

} ;

class DllImportExport ProvPositiveRangeType
{
private:
protected:

	ULONG lowerBound ;
	ULONG upperBound ;

public:

	ProvPositiveRangeType ( const ProvPositiveRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	ProvPositiveRangeType ( ULONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	ProvPositiveRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~ProvPositiveRangeType () {}


	ULONG GetLowerBound () { return lowerBound ; }
	ULONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const ULONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const ULONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual ProvPositiveRangeType *Copy () { return new ProvPositiveRangeType ( *this ) ; }
} ;

class DllImportExport ProvPositiveRangedType
{
private:
protected:

	BOOL status ;

	ProvList <ProvPositiveRangeType,ProvPositiveRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	ProvPositiveRangedType ( const ProvPositiveRangedType &rangedValues ) ;
	ProvPositiveRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~ProvPositiveRangedType () ;

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL IsValid () { return status ; }

	BOOL Check ( const ULONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; }
} ;

class DllImportExport ProvFixedType
{
private:
protected:

	ULONG fixedLength ;

public:

	ProvFixedType ( const ProvFixedType &fixedLengthArg ) { fixedLength = fixedLengthArg.fixedLength ; }
	ProvFixedType ( const ULONG fixedLengthArg ) { fixedLength = fixedLengthArg ; }
	virtual ~ProvFixedType () {} ;
} ;

class DllImportExport ProvInstanceType 
{
private:
protected:

	BOOL m_IsNull ;
	BOOL status ;

	ProvInstanceType ( const ProvInstanceType &copy ) { status = copy.status ; m_IsNull = copy.m_IsNull ; }
	ProvInstanceType ( BOOL statusArg = TRUE , BOOL nullArg = FALSE ) { status = statusArg ; m_IsNull = nullArg ; } ;
	virtual BOOL Equivalent (IN const ProvInstanceType &value) const = 0;

public:

	virtual ~ProvInstanceType () {} ;

	virtual wchar_t *GetStringValue () const = 0 ;

	virtual ProvInstanceType *Copy () const = 0 ;

	virtual operator void *() ;

	void SetStatus ( BOOL statusArg ) { status = statusArg ; }
	void SetNull ( BOOL nullArg ) { m_IsNull = nullArg ; }

	virtual BOOL IsValid () const ;
	virtual BOOL IsNull () const ;
	virtual BOOL IsProvV1Type () const { return TRUE ; }
	virtual BOOL IsProvV2CType () const { return TRUE ; }

	BOOL operator==(IN const ProvInstanceType &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const ProvInstanceType &value) const
	{
		return !((*this) == value) ;
	}

} ;

class DllImportExport ProvNullType : public ProvInstanceType
{
private:

	ProvNull null ;

protected:

	BOOL Equivalent (IN const ProvInstanceType &value) const;

public:

	ProvNullType ( const ProvNullType &nullArg ) ;
	ProvNullType ( const ProvNull &nullArg ) ;
	ProvNullType () ;
	~ProvNullType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;

	BOOL IsProvV2CType () const { return FALSE ; }
} ;

class DllImportExport ProvIntegerType : public ProvInstanceType , protected ProvNegativeRangedType
{
private:
protected:

	ProvInteger integer ;
	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *integerArg ) ;

public:

	ProvIntegerType ( const ProvIntegerType &integerArg ) ;
	ProvIntegerType ( const ProvInteger &integerArg , const wchar_t *rangeValues ) ;
	ProvIntegerType ( const wchar_t *integerArg , const wchar_t *rangeValues ) ;
	ProvIntegerType ( const LONG integerArg , const wchar_t *rangeValues ) ;
	ProvIntegerType ( const wchar_t *rangeValues = NULL ) ;
	~ProvIntegerType () ;

	wchar_t *GetStringValue () const ;
	LONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvGaugeType : public ProvInstanceType , protected ProvPositiveRangedType
{
private:
protected:

	ProvGauge gauge ;

	BOOL Parse ( const wchar_t *gaugeArg )  ;
	BOOL Equivalent (IN const ProvInstanceType &value) const ;

public:

	ProvGaugeType ( const ProvGaugeType &gaugeArg ) ;
	ProvGaugeType ( const ProvGauge &gaugeArg , const wchar_t *rangeValues ) ;
	ProvGaugeType ( const wchar_t *gaugeArg , const wchar_t *rangeValues ) ;
	ProvGaugeType ( const ULONG gaugeArg , const wchar_t *rangeValues ) ;
	ProvGaugeType ( const wchar_t *rangeValues = NULL ) ;
	~ProvGaugeType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvTimeTicksType : public ProvInstanceType
{
private:
protected:

	ProvTimeTicks timeTicks ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *timeTicksArg )  ;

public:

	ProvTimeTicksType ( const ProvTimeTicks &timeTicksArg ) ;
	ProvTimeTicksType ( const ProvTimeTicksType &timeTicksArg ) ;
	ProvTimeTicksType ( const wchar_t *timeTicksArg ) ;
	ProvTimeTicksType ( const ULONG timeTicksArg ) ;
	ProvTimeTicksType () ;
	~ProvTimeTicksType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvCounterType : public ProvInstanceType 
{
private:
protected:

	ProvCounter counter ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	ProvCounterType ( const ProvCounter &counterArg ) ;
	ProvCounterType ( const ProvCounterType &counterArg ) ;
	ProvCounterType ( const wchar_t *counterArg ) ;
	ProvCounterType ( const ULONG counterArg ) ;
	ProvCounterType () ;
	~ProvCounterType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;
	
	ProvInstanceType *Copy () const ;

} ;

class DllImportExport  ProvCounter64Type : public ProvInstanceType 
{
private:
protected:

	ULONG high ;
	ULONG low ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	ProvCounter64Type ( const ProvCounter64Type &counterArg ) ;
	ProvCounter64Type ( const ProvCounter64 &counterArg ) ;
	ProvCounter64Type ( const wchar_t *counterArg ) ;
	ProvCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) ;
	ProvCounter64Type () ;
	~ProvCounter64Type () ;

	wchar_t *GetStringValue () const ;
	void GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const ;

	BOOL IsProvV1Type () const { return FALSE ; } 
	
	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvIpAddressType : public ProvInstanceType
{
private:
protected:

	ProvIpAddress ipAddress ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *ipAddressArg )  ;

public:

	ProvIpAddressType ( const ProvIpAddress &ipAddressArg ) ;
	ProvIpAddressType ( const ProvIpAddressType &ipAddressArg ) ;
	ProvIpAddressType ( const wchar_t *ipAddressArg ) ;
	ProvIpAddressType ( const ULONG ipAddressArg ) ;
	ProvIpAddressType () ;
	~ProvIpAddressType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvNetworkAddressType : public ProvInstanceType
{
private:
protected:

	ProvIpAddress ipAddress ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *gaugeArg )  ;

public:

	ProvNetworkAddressType ( const ProvIpAddress &ipAddressArg ) ;
	ProvNetworkAddressType ( const ProvNetworkAddressType &ipAddressArg ) ;
	ProvNetworkAddressType ( const wchar_t *networkAddressArg ) ;
	ProvNetworkAddressType ( const ULONG ipAddressArg ) ;
	ProvNetworkAddressType () ;
	~ProvNetworkAddressType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvObjectIdentifierType : public ProvInstanceType
{
private:
protected:

	ProvObjectIdentifier objectIdentifier ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *objectIdentifierArg )  ;

public:

	ProvObjectIdentifierType ( const ProvObjectIdentifier &objectIdentifierArg ) ;
	ProvObjectIdentifierType ( const ProvObjectIdentifierType &objectIdentifierArg ) ;
	ProvObjectIdentifierType ( const wchar_t *objectIdentifierArg ) ;
	ProvObjectIdentifierType ( IN const ULONG *value , IN const ULONG valueLength ) ;
	ProvObjectIdentifierType () ;
	~ProvObjectIdentifierType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	ULONG *GetValue () const ;

	ProvInstanceType *Copy () const ;

	ProvObjectIdentifierType &operator=(const ProvObjectIdentifierType &to_copy ) ;
} ;

class DllImportExport  ProvOpaqueType : public ProvInstanceType , protected ProvPositiveRangedType
{
private:
protected:

	ProvOpaque opaque ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *opaqueArg )  ;

public:

	ProvOpaqueType ( const ProvOpaque &opaqueArg , const wchar_t *rangedValues ) ;
	ProvOpaqueType ( const ProvOpaqueType &opaqueArg ) ;
	ProvOpaqueType ( const wchar_t *opaqueArg , const wchar_t *rangedValues ) ;
	ProvOpaqueType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	ProvOpaqueType ( const wchar_t *rangedValues = NULL ) ;
	~ProvOpaqueType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthOpaqueType : public ProvOpaqueType , protected ProvFixedType
{
private:
protected:
public:

	ProvFixedLengthOpaqueType ( const ULONG &fixedLength , const ProvOpaque &opaqueArg ) ;
	ProvFixedLengthOpaqueType ( const ProvFixedLengthOpaqueType &opaqueArg ) ;
	ProvFixedLengthOpaqueType ( const ULONG &fixedLength , const wchar_t *opaqueArg ) ;
	ProvFixedLengthOpaqueType ( const ULONG &fixedLengthArg , const UCHAR *value , const ULONG valueLength ) ;
	ProvFixedLengthOpaqueType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthOpaqueType () ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvOctetStringType : public ProvInstanceType , protected ProvPositiveRangedType
{
private:
protected:

	ProvOctetString octetString ;

	BOOL Equivalent (IN const ProvInstanceType &value) const ;
	BOOL Parse ( const wchar_t *octetStringArg )  ;

public:

	ProvOctetStringType ( const ProvOctetString &octetStringArg , const wchar_t *rangedValues ) ;
	ProvOctetStringType ( const ProvOctetStringType &octetStringArg ) ;
	ProvOctetStringType ( const wchar_t *octetStringArg , const wchar_t *rangedValues ) ;
	ProvOctetStringType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	ProvOctetStringType ( const wchar_t *rangedValues = NULL ) ;
	~ProvOctetStringType () ;

	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthOctetStringType : public ProvOctetStringType , protected ProvFixedType
{
private:
protected:
public:

	ProvFixedLengthOctetStringType ( const ULONG &fixedLength , const ProvOctetString &octetStringArg ) ;
	ProvFixedLengthOctetStringType ( const ProvFixedLengthOctetStringType &octetStringArg ) ;
	ProvFixedLengthOctetStringType ( const ULONG &fixedLength , const wchar_t *octetStringArg ) ;
	ProvFixedLengthOctetStringType ( const ULONG &fixedLength , const UCHAR *value ) ;
	ProvFixedLengthOctetStringType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthOctetStringType () ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvMacAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *macAddressArg )  ;

public:

	ProvMacAddressType ( const ProvOctetString &macAddressArg ) ;
	ProvMacAddressType ( const ProvMacAddressType &macAddressArg ) ;
	ProvMacAddressType ( const wchar_t *macAddressArg ) ;
	ProvMacAddressType ( const UCHAR *macAddressArg ) ;
	ProvMacAddressType () ;
	~ProvMacAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvPhysAddressType : public ProvOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	ProvPhysAddressType ( const ProvOctetString &physAddressArg , const wchar_t *rangedValues  ) ;
	ProvPhysAddressType ( const ProvPhysAddressType &physAddressArg ) ;
	ProvPhysAddressType ( const wchar_t *physAddressArg , const wchar_t *rangedValues ) ;
	ProvPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	ProvPhysAddressType ( const wchar_t *rangedValues = NULL ) ;
	~ProvPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthPhysAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength , const ProvOctetString &physAddressArg ) ;
	ProvFixedLengthPhysAddressType ( const ProvFixedLengthPhysAddressType &physAddressArg ) ;
	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength , const wchar_t *physAddressArg ) ;
	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength , const UCHAR *value , const ULONG valueLength ) ;
	ProvFixedLengthPhysAddressType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvDisplayStringType : public ProvOctetStringType
{
private:
protected:
public:

	ProvDisplayStringType ( const ProvOctetString &displayStringArg , const wchar_t *rangedValues ) ;
	ProvDisplayStringType ( const ProvDisplayStringType &displayStringArg ) ;
	ProvDisplayStringType ( const wchar_t *displayStringArg , const wchar_t *rangedValues ) ;
	ProvDisplayStringType ( const wchar_t *rangedValues = NULL ) ;
	~ProvDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvFixedLengthDisplayStringType : public ProvFixedLengthOctetStringType 
{
private:
protected:
public:

	ProvFixedLengthDisplayStringType ( const ULONG &fixedLength , const ProvOctetString &displayStringArg ) ;
	ProvFixedLengthDisplayStringType ( const ProvFixedLengthDisplayStringType &displayStringArg ) ;
	ProvFixedLengthDisplayStringType ( const ULONG &fixedLength , const wchar_t *displayStringArg ) ;
	ProvFixedLengthDisplayStringType ( const ULONG &fixedLength ) ;
	~ProvFixedLengthDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvEnumeratedType : public ProvIntegerType
{
private:

	ProvMap <LONG, const LONG,wchar_t *,wchar_t *> integerMap ;
	ProvMap <wchar_t *,wchar_t *,LONG,LONG> stringMap ;

	BOOL Parse ( const wchar_t *enumeratedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL EnumerationDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	ProvEnumeratedType ( const wchar_t *enumeratedValues , const LONG &enumeratedValue ) ;
	ProvEnumeratedType ( const wchar_t *enumeratedValues , const wchar_t *enumeratedValue ) ;
	ProvEnumeratedType ( const wchar_t *enumeratedValues , const ProvInteger &enumeratedValue ) ;
	ProvEnumeratedType ( const ProvEnumeratedType &enumerateValues ) ;
	ProvEnumeratedType ( const wchar_t *enumeratedValues ) ;
	~ProvEnumeratedType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvRowStatusType : public ProvEnumeratedType
{
private:
protected:
public:

	enum ProvRowStatusEnum
	{
		active = 1 ,
		notInService = 2 ,
		notReady = 3 ,
		createAndGo = 4 ,
		createAndWait = 5,
		destroy = 6
	} ;

	ProvRowStatusType ( const LONG &rowStatusValue ) ;
	ProvRowStatusType ( const wchar_t *rowStatusValue ) ;
	ProvRowStatusType ( const ProvInteger &rowStatusValue ) ;
	ProvRowStatusType ( const ProvRowStatusType &rowStatusValue ) ;
	ProvRowStatusType ( const ProvRowStatusEnum &rowStatusValue ) ;
	ProvRowStatusType () ;
	~ProvRowStatusType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;
	ProvRowStatusEnum GetRowStatus () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvBitStringType : public ProvOctetStringType
{
private:

	ProvMap <ULONG, const ULONG,wchar_t *,wchar_t *> integerMap ;
	ProvMap <wchar_t *,wchar_t *,ULONG,ULONG> stringMap ;

	BOOL Parse ( const wchar_t *bitStringValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

	BOOL BitStringDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	ProvBitStringType ( const wchar_t *bitStringValues , const ProvOctetString &bitStringValue ) ;
	ProvBitStringType ( const wchar_t *bitStringValues , const wchar_t **bitStringValue , const ULONG &bitStringValueLength ) ;
	ProvBitStringType ( const ProvBitStringType &bitStringValues ) ;
	ProvBitStringType ( const wchar_t *bitStringValues ) ;
	~ProvBitStringType () ;

	wchar_t *GetStringValue () const ;
	ULONG ProvBitStringType :: GetValue ( wchar_t **&stringValue ) const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport ProvDateTimeType : public ProvOctetStringType
{
private:

	BOOL Parse ( const wchar_t *dateTimeValue ) ;
	void Encode (

		const ULONG &year ,
		const ULONG &month ,
		const ULONG &day ,
		const ULONG &hour ,
		const ULONG &minutes ,
		const ULONG &seconds ,
		const ULONG &deciSeconds ,
		const ULONG &UTC_present ,
		const ULONG &UTC_direction ,
		const ULONG &UTC_hours ,
		const ULONG &UTC_minutes
	) ;

	BOOL DateTimeDef () ;
//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	ProvAnalyser analyser ;
	ProvLexicon *pushBack ;

	void PushBack () ;
	ProvLexicon *Get () ;
	ProvLexicon *Match ( ProvLexicon :: LexiconToken tokenType ) ;

protected:
public:

	ProvDateTimeType ( const wchar_t *dateTimeValue ) ;
	ProvDateTimeType ( const ProvDateTimeType &dateTimeValue ) ;
	ProvDateTimeType ( const ProvOctetString &dateTimeValue ) ;
	ProvDateTimeType () ;
	~ProvDateTimeType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport ProvOSIAddressType : public ProvOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *osiAddressArg )  ;

public:

	ProvOSIAddressType ( const ProvOctetString &osiAddressArg ) ;
	ProvOSIAddressType ( const ProvOSIAddressType &osiAddressArg ) ;
	ProvOSIAddressType ( const wchar_t *osiAddressArg ) ;
	ProvOSIAddressType ( const UCHAR *value , const ULONG valueLength ) ;
	ProvOSIAddressType () ;
	~ProvOSIAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvUDPAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *udpAddressArg )  ;

public:

	ProvUDPAddressType ( const ProvOctetString &udpAddressArg ) ;
	ProvUDPAddressType ( const ProvUDPAddressType &udpAddressArg ) ;
	ProvUDPAddressType ( const wchar_t *udpAddressArg ) ;
	ProvUDPAddressType ( const UCHAR *udpAddressArg ) ;
	ProvUDPAddressType () ;
	~ProvUDPAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;

class DllImportExport  ProvIPXAddressType : public ProvFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *ipxAddressArg )  ;

public:

	ProvIPXAddressType ( const ProvOctetString &ipxAddressArg ) ;
	ProvIPXAddressType ( const ProvIPXAddressType &ipxAddressArg ) ;
	ProvIPXAddressType ( const wchar_t *ipxAddressArg ) ;
	ProvIPXAddressType ( const UCHAR *ipxAddressArg ) ;
	ProvIPXAddressType () ;
	~ProvIPXAddressType () ;

	wchar_t *GetStringValue () const ;

	ProvInstanceType *Copy () const ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\ciprouteevent.h ===
//=================================================================

//

// PowerManagement.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   03/31/99	a-peterc        Created
//
//=================================================================

#ifndef _WBEM_POWER_EVENT_PROVIDER_H
#define _WBEM_POWER_EVENT_PROVIDER_H

#define IPROUTE_EVENT_CLASS L"Win32_IP4RouteTableEvent"

class SmartCloseNtHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseNtHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseNtHandle(HANDLE h):m_h(h){}
   ~SmartCloseNtHandle(){if (m_h!=INVALID_HANDLE_VALUE) NtClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) NtClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	operator HANDLE&() {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) NtClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

//
class CIPRouteEventProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

    CIPRouteEventProviderClassFactory () ;
    ~CIPRouteEventProviderClassFactory () ;
	
	static BOOL DllCanUnloadNow();

	//IUnknown members
	STDMETHODIMP QueryInterface( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef() ;
    STDMETHODIMP_( ULONG ) Release() ;
	
	//IClassFactory members
	STDMETHODIMP CreateInstance( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer( BOOL ) ;
};

//
class CIPRouteEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
private:

	long m_ReferenceCount ;

	SmartCloseNtHandle m_TerminationEventHandle ;

	CRITICAL_SECTION m_csEvent ;		
			
	static DWORD WINAPI dwThreadProc ( LPVOID lpParameter );

	void SendEvent () ;
	NTSTATUS OpenQuerySource ( 

		HANDLE &a_StackHandle , 
		HANDLE &a_CompleteEventHandle
	) ;


protected:

	IWbemObjectSink *m_pHandler ;
	IWbemClassObject *m_pClass ;
	SmartCloseHandle m_hThreadHandle ;
	DWORD m_dwThreadID ;

public:

	CIPRouteEventProvider() ;
	~CIPRouteEventProvider() ;

	void SetHandler ( IWbemObjectSink __RPC_FAR *a_pHandler ) ;
	void SetClass ( IWbemClassObject __RPC_FAR *a_pClass ) ;

    STDMETHOD ( QueryInterface ) ( 

		REFIID a_riid, 
		void **a_ppv
	) ;

    STDMETHOD_( ULONG, AddRef ) () ;
    STDMETHOD_( ULONG, Release ) () ;

    STDMETHOD ( ProvideEvents ) (

		IWbemObjectSink *a_pSink,
		long a_lFlags
	) ;
	
	STDMETHOD ( Initialize ) (

		LPWSTR a_wszUser , 
		long a_lFlags , 
		LPWSTR a_wszNamespace ,
		LPWSTR a_wszLocale ,
		IWbemServices *a_pNamespace ,  
		IWbemContext *a_pCtx ,
		IWbemProviderInitSink *a_pSink
	) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\precomp.h ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntstatus.h>
}


#include <objbase.h>
#include <initguid.h>
#include <fwcommon.h>
#include <provider.h>
#include <instance.h>
#include <smartptr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\cippersistedrtble.cpp ===
/******************************************************************
   CIPPersistedRTble.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine

   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib &
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description:



******************************************************************/

#include "precomp.h"
#include <winsock2.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <cregcls.h>
#include "CIPPersistedRTble.h"

extern const WCHAR *RouteDestination ;
extern const WCHAR *RouteInformation ;
extern const WCHAR *RouteMask ;
extern const WCHAR *RouteMetric1 ;
extern const WCHAR *RouteNextHop ;
extern const WCHAR *RouteName ;
extern const WCHAR *RouteCaption ;
extern const WCHAR *RouteDescription ;



#define TCIP_PERSISTENT_REG         L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\PersistentRoutes"
#define MAX_METRIC1					9999
#define PERSITENT_ROUTE_SEP			L','

CIPPersistedRouteTable MyCIPPersistedRouteTableSet (

	PROVIDER_NAME_CIPPERSISTEDROUTETABLE ,
	L"root\\cimv2"
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CIPPersistedRouteTable::CIPPersistedRouteTable
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CIPPersistedRouteTable :: CIPPersistedRouteTable (

	LPCWSTR lpwszName,
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CIPPersistedRouteTable::~CIPPersistedRouteTable
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CIPPersistedRouteTable :: ~CIPPersistedRouteTable ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must
*                       be filled in.  If there are no instances, return
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
    CRegistry t_Reg;

	if (t_Reg.Open(
        HKEY_LOCAL_MACHINE,
		TCIP_PERSISTENT_REG,
        KEY_READ) == ERROR_SUCCESS)
	{
		WCHAR *pValueName = NULL ;
		BYTE *pValueData = NULL ;

        try
		{
			for(DWORD i = 0 ; i < t_Reg.GetValueCount() && SUCCEEDED(hRes); i++)
			{
				DWORD dwRetCode = t_Reg.EnumerateAndGetValues(i, pValueName, pValueData) ;

				if(dwRetCode == ERROR_SUCCESS)
				{
					CHString t_Dest ;
					CHString t_Mask ;
					CHString t_NextHop ;
					long t_Metric ;

					if ( Parse (	pValueName , t_Dest , t_Mask , t_NextHop , t_Metric ) )
					{
						CInstance *pInstance = CreateNewInstance ( pMethodContext ) ;

						if (pInstance != NULL )
						{
						/*
						 *	Initialize the instance
						 */
							pInstance->SetCHString( RouteDestination, t_Dest ) ;
							pInstance->SetCHString( RouteMask, t_Mask ) ;
							pInstance->SetCHString( RouteNextHop, t_NextHop ) ;
							pInstance->SetDWORD ( RouteMetric1, t_Metric ) ;

							//set the inherited properties that are sensible
							SetInheritedProperties (
								t_Dest ,
								t_NextHop ,
								t_Mask ,
								t_Metric ,
								*pInstance
							) ;

						/*
						 *	Forward the instance onto the core wmi service
						 */

							hRes = Commit ( pInstance ) ;
						}
					}
				}

				if ( pValueName )
				{
					delete [] pValueName ;
					pValueName = NULL ;
				}

				if ( pValueData )
				{
					delete [] pValueData ;
					pValueData = NULL ;
				}
			}

			t_Reg.Close() ;
		}
		catch ( ... )
		{
			if ( pValueName )
			{
				delete [] pValueName ;
				pValueName = NULL ;
			}

			if ( pValueData )
			{
				delete [] pValueData ;
				pValueData = NULL ;
			}

			throw ;
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_FAILURE ;
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::GetObjectAsync.
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error
*                   occurred.
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: GetObject (

	CInstance *pInstance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString t_Dest ;
    CHString t_Mask ;
    CHString t_NextHop ;
    long t_Metric1 = 1;

    pInstance->GetCHString ( RouteDestination , t_Dest ) ;
    pInstance->GetCHString ( RouteMask , t_Mask ) ;
    pInstance->GetCHString ( RouteNextHop , t_NextHop ) ;
    pInstance->GetDWORD ( RouteMetric1 , (DWORD&)t_Metric1 ) ;

    CRegistry t_Reg;

	if (t_Reg.Open(
        HKEY_LOCAL_MACHINE,
		TCIP_PERSISTENT_REG,
        KEY_READ) == ERROR_SUCCESS)
	{
		WCHAR buff [ 20 ];
		buff [ 0 ] = L'\0' ;
		_ultow( t_Metric1, buff , 10 ) ;
		CHString t_ValName = t_Dest + PERSITENT_ROUTE_SEP + t_Mask + PERSITENT_ROUTE_SEP + t_NextHop + PERSITENT_ROUTE_SEP + buff ;

		if ( RegQueryValueEx ( t_Reg.GethKey(), t_ValName , NULL , NULL , NULL , NULL ) == ERROR_SUCCESS )
		{
			hr = S_OK ;

			/*
			 *	Initialize the instance
			 */

			//set the inherited properties that are sensible
			SetInheritedProperties (
				t_Dest ,
				t_NextHop ,
				t_Mask ,
				t_Metric1,
				*pInstance
			) ;
		}

		t_Reg.Close();
	}

    return hr ;
}


/*****************************************************************************
*
*  FUNCTION    : CIPPersistedRouteTable::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can
*                   write instance information back to the hardware or
*                   software.  For example: Win32_Environment will allow a
*                   PutInstance to create or update an environment variable.
*                   However, a class like MotherboardDevice will not allow
*                   editing of the number of slots, since it is difficult for
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::PutInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider,
*                       or are creating a 'method only' provider, remove this
*                       method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: PutInstance  (

	const CInstance &Instance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_FAILED ;

    switch ( lFlags & (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY) )
	{
        case WBEM_FLAG_CREATE_OR_UPDATE:
        case WBEM_FLAG_CREATE_ONLY:
		{
			CHString t_ValName ;
			hr = CheckParameters ( Instance , t_ValName ) ;

			if ( SUCCEEDED ( hr ) )
			{
				CRegistry t_Reg;

				if (t_Reg.Open(
					HKEY_LOCAL_MACHINE,
					TCIP_PERSISTENT_REG,
					KEY_ALL_ACCESS) == ERROR_SUCCESS)
				{
					CHString t_temp;

					if ( ERROR_SUCCESS != t_Reg.SetCurrentKeyValue( t_ValName, t_temp ) )
					{
						hr = S_OK ;
					}

					t_Reg.Close () ;
				}
				else
				{
					hr = WBEM_E_PROVIDER_FAILURE ;
				}
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER ;
			}
		}
		break ;

		default:
		{
			hr = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
		break ;
	}

    return hr ;
}

HRESULT CIPPersistedRouteTable :: CheckParameters (

	const CInstance &a_Instance ,
	CHString &a_ValueName
)
{
	bool t_Exists ;
	VARTYPE t_Type ;
	long t_mask  = 0 ;
	long t_dest  = 0 ;
	long t_nexthop = 0 ;

	CHString t_RouteDestinationString ;

	if ( a_Instance.GetStatus ( RouteDestination , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteDestination , t_RouteDestinationString ) && ! t_RouteDestinationString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationString ) ;

				if ( t_Address.IsValid () )
				{
					t_dest = htonl ( t_Address.GetValue () ) ;

					if ( t_dest == -1 )
					{
						return WBEM_E_INVALID_PARAMETER ;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CHString t_RouteDestinationMaskString ;

	if ( a_Instance.GetStatus ( RouteMask , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteMask , t_RouteDestinationMaskString ) && ! t_RouteDestinationMaskString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationMaskString ) ;

				if ( t_Address.IsValid () )
				{
					t_mask = htonl ( t_Address.GetValue () ) ;

					if ( ( t_dest & t_mask ) != t_dest )
					{
						return WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CHString t_RouteNextHopString ;

	if ( a_Instance.GetStatus ( RouteNextHop, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteNextHop , t_RouteNextHopString ) && ! t_RouteNextHopString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteNextHopString ) ;

				if ( t_Address.IsValid () )
				{
					t_nexthop = htonl ( t_Address.GetValue () ) ;

					if ( t_nexthop == -1 )
					{
						return WBEM_E_INVALID_PARAMETER ;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_Metric = 0 ;

	if ( a_Instance.GetStatus ( RouteMetric1 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			if ( !a_Instance.GetDWORD ( RouteMetric1 , t_Metric ) || ( t_Metric < 1) || ( t_Metric > MAX_METRIC1) )
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	WCHAR buff [ 20 ] ;
	buff [ 0 ] = L'\0' ;
	_ultow ( t_Metric , buff , 10 ) ;
	a_ValueName = t_RouteDestinationString + PERSITENT_ROUTE_SEP
					+ t_RouteDestinationMaskString + PERSITENT_ROUTE_SEP
					+ t_RouteNextHopString  + PERSITENT_ROUTE_SEP
					+ buff;
	return S_OK ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices,
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::DeleteInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: DeleteInstance (

	const CInstance &Instance,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED ;

    CHString t_Dest ;
    CHString t_Mask ;
    CHString t_NextHop ;
    long t_Metric1 = 1;

    Instance.GetCHString ( RouteDestination , t_Dest ) ;
    Instance.GetCHString ( RouteMask , t_Mask ) ;
    Instance.GetCHString ( RouteNextHop , t_NextHop ) ;
    Instance.GetDWORD ( RouteMetric1 , (DWORD&)t_Metric1 ) ;

    CRegistry t_Reg;

	if (t_Reg.Open(
        HKEY_LOCAL_MACHINE,
		TCIP_PERSISTENT_REG,
        KEY_ALL_ACCESS) == ERROR_SUCCESS)
	{
		WCHAR buff [ 20 ];
		buff[0] = L'\0' ;
		_ultow( t_Metric1 , buff , 10 ) ;
		CHString t_ValName = t_Dest + PERSITENT_ROUTE_SEP + t_Mask + PERSITENT_ROUTE_SEP + t_NextHop + PERSITENT_ROUTE_SEP + buff ;

		if ( t_Reg.DeleteCurrentKeyValue(t_ValName) == ERROR_SUCCESS )
		{
			hr = S_OK ;
		}

		t_Reg.Close();
	}

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPPersistedRouteTable::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.
*                   A method is an entry point for the user of your provider
*                   to request your class perform some function above and
*                   beyond a change of state.  (A change of state should be
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/

HRESULT CIPPersistedRouteTable :: ExecMethod (

	const CInstance &Instance,
	const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
    // For non-static methods, use the CInstance Get functions (for example,
    // call GetCHString(L"Name", sTemp)) against Instance to see the key
    // values the client requested.

    return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

BOOL CIPPersistedRouteTable :: Parse (

	LPWSTR a_InStr ,
	CHString &a_Dest ,
	CHString &a_Mask ,
	CHString &a_NextHop ,
	long &a_Metric
)
{
	BOOL t_RetVal = FALSE ;

	if ( a_InStr && ( wcslen ( a_InStr ) > 0 ) )
	{
		LPWSTR t_Str = a_InStr ;
		LPWSTR t_Addr = t_Str ;
		a_Metric = 1 ;

		DWORD t_count = 0;

		while ( *t_Str != L'\0' )
		{
			if ( *t_Str != PERSITENT_ROUTE_SEP )
			{
				t_Str++ ;
			}
			else
			{
				*t_Str = L'\0';
				ProvIpAddressType t_Address ( t_Addr ) ;
				
				if ( t_Address.IsValid () )
				{
					t_count++ ;
					t_RetVal = TRUE ;

					switch ( t_count )
					{
						case 1 :
						{
							a_Dest = t_Addr ;
						}
						break ;

						case 2 :
						{
							a_Mask = t_Addr ;
						}
						break ;

						case 3 :
						{
							a_NextHop = t_Addr ;
						}
						break ;

						default :
						{
							t_RetVal = FALSE ;
						}

					}
					
					if ( t_RetVal )
					{
						*t_Str = PERSITENT_ROUTE_SEP ;
						t_Str++ ;
						t_Addr = t_Str ;
					}
					else
					{
						break ;
					}
				}
				else
				{
					t_RetVal = FALSE ;
					break ;
				}
			}
		}

		if ( ( t_count == 3 ) && t_RetVal )
		{
			//get the metric
			if (t_Addr != t_Str)
			{
				a_Metric = _wtoi ( t_Addr ) ;

				if ( a_Metric < 1 )
				{
					t_RetVal = FALSE ;
				}
			}
		}
		else
		{
			t_RetVal = FALSE ;
		}
	}

	return t_RetVal;
}

void CIPPersistedRouteTable :: SetInheritedProperties (

	LPCWSTR a_dest ,
	LPCWSTR a_gateway ,
	LPCWSTR a_mask ,
	long a_metric ,
	CInstance &a_Instance
)
{
	CHString t_temp( a_dest ) ;
	a_Instance.SetCHString ( RouteName, t_temp ) ;
	a_Instance.SetCHString ( RouteCaption, t_temp ) ;
	WCHAR t_buff [ 20 ] ;
	t_buff[0] = L'\0' ;
	_ultow( a_metric , t_buff , 10 ) ;
	t_temp = t_temp + PERSITENT_ROUTE_SEP + a_mask + PERSITENT_ROUTE_SEP + a_gateway + PERSITENT_ROUTE_SEP + t_buff ;
	a_Instance.SetCHString ( RouteDescription, t_temp ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\ciproutetable.cpp ===
/******************************************************************
   CIPRouteTable.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine

   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib &
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description:



******************************************************************/

#include "precomp.h"
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include "CIPRouteTable.h"
#include "CIpRouteEvent.h"

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================

CIPRouteTable MyCIPRouteTableSet (

	PROVIDER_NAME_CIPROUTETABLE ,
	L"root\\cimv2"
) ;

// Property names
//===============
const WCHAR *RouteAge				= L"Age" ;
const WCHAR *RouteDestination		= L"Destination" ;
const WCHAR *RouteInterfaceIndex	= L"InterfaceIndex" ;
const WCHAR *RouteInformation		= L"Information" ;
const WCHAR *RouteMask				= L"Mask" ;
const WCHAR *RouteMetric1			= L"Metric1" ;
const WCHAR *RouteMetric2			= L"Metric2" ;
const WCHAR *RouteMetric3			= L"Metric3" ;
const WCHAR *RouteMetric4			= L"Metric4" ;
const WCHAR *RouteMetric5			= L"Metric5" ;
const WCHAR *RouteNextHop			= L"NextHop" ;
const WCHAR *RouteProtocol			= L"Protocol" ;
const WCHAR *RouteType				= L"Type" ;

// Inherited properties populated
//===============================
const WCHAR *RouteName				= L"Name" ;
const WCHAR *RouteCaption			= L"Caption" ;
const WCHAR *RouteDescription		= L"Description" ;

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define ROUTE_DESCRIPTION_SEP				L" - "

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

class CDeleteString
{
private:

	wchar_t * m_ptr;
	CDeleteString ( const CDeleteString& p ) ;
	CDeleteString & operator= ( const CDeleteString & p ) ;

public:

	CDeleteString ( wchar_t *ptr = NULL ) : m_ptr( ptr )
	{
	}

	~CDeleteString ( )
	{
		if ( m_ptr )
		{
			delete [] m_ptr ;
			m_ptr = NULL ;
		}
	}

	operator LPCWSTR ( ) const { return ( (LPCWSTR) m_ptr ) ; }
};


/*****************************************************************************
 *
 *  FUNCTION    :   CIPRouteTable::CIPRouteTable
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CIPRouteTable :: CIPRouteTable (

	LPCWSTR lpwszName,
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace ), m_ClassCInst( NULL )
{
	InitializeCriticalSection( &m_CS ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CIPRouteTable::~CIPRouteTable
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CIPRouteTable :: ~CIPRouteTable ()
{
	DeleteCriticalSection( &m_CS ) ;

	if ( m_ClassCInst != NULL )
	{
		m_ClassCInst->Release();
	}
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must
*                       be filled in.  If there are no instances, return
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: RangeQuery (

	MethodContext *pMethodContext,
	PartitionSet &a_PartitionSet ,
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	SmartCloseNtHandle t_StackHandle ;
	SmartCloseNtHandle t_CompleteEventHandle ;

	NTSTATUS t_NtStatus = OpenQuerySource (

		t_StackHandle ,
		t_CompleteEventHandle
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		ulong t_RouteTableSize = 0 ;
		IPRouteEntry *t_InformationBlock = NULL ;

		t_NtStatus = QueryInformation_IpRouteInfo (

			t_StackHandle ,
			t_CompleteEventHandle ,
			t_RouteTableSize ,
			t_InformationBlock
		) ;

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
			try
			{
				ULONG t_PartitionCount = a_PartitionSet.GetPartitionCount () ;

				for ( ulong t_RouteIndex = 0 ; t_RouteIndex < t_RouteTableSize ; t_RouteIndex ++ )
				{
					IPRouteEntry &t_Entry = t_InformationBlock [ t_RouteIndex ] ;

					ProvIpAddressType t_DestinationIpAddress ( ntohl ( t_Entry.ire_dest ) ) ;
					CDeleteString t_DestinationIpAddressString(t_DestinationIpAddress.GetStringValue ());

					BOOL t_Create = FALSE ;

					for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
					{
						PartitionSet *t_PropertyPartition = a_PartitionSet.GetPartition ( t_Partition ) ;

						WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange () ;

						if ( t_Node->InfiniteLowerBound () )
						{
							if ( t_Node->InfiniteUpperBound () )
							{
								t_Create = TRUE ;
							}
							else
							{
								int t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->UpperBound () ) ;
								if ( t_Node->ClosedUpperBound () )
								{
									if ( t_Compare <= 0 )
									{
										t_Create = TRUE ;
									}
								}
								else
								{
									if ( t_Compare < 0 )
									{
										t_Create = TRUE ;
									}
								}
							}
						}
						else
						{
							int t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->LowerBound () ) ;
							if ( t_Node->ClosedLowerBound () )
							{
								if ( t_Compare >= 0 )
								{
									if ( t_Node->InfiniteUpperBound () )
									{
										t_Create = TRUE ;
									}
									else
									{
										t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->UpperBound () ) ;
										if ( t_Node->ClosedUpperBound () )
										{
											if ( t_Compare <= 0 )
											{
												t_Create = TRUE ;
											}
										}
										else
										{
											if ( t_Compare < 0 )
											{
												t_Create = TRUE ;
											}
										}
									}
								}
							}
							else
							{
								if ( t_Compare > 0 )
								{
									if ( t_Node->InfiniteUpperBound () )
									{
										t_Create = TRUE ;
									}
									else
									{
										t_Compare = wcscmp ( t_DestinationIpAddressString , t_Node->UpperBound () ) ;
										if ( t_Node->ClosedUpperBound () )
										{
											if ( t_Compare <= 0 )
											{
												t_Create = TRUE ;
											}
										}
										else
										{
											if ( t_Compare < 0 )
											{
												t_Create = TRUE ;
											}
										}
									}
								}
							}
						}
					}

					if( t_Create )
					{

					/*
					 *	Create a new instance based on the passed-in MethodContext.
					 *	Note that CreateNewInstance may throw, but will never return NULL.
					 */

						CInstance *pInstance = CreateNewInstance ( pMethodContext ) ;

					/*
					 *	Set the keys for the instance
					 */

						pInstance->SetCHString ( RouteDestination, t_DestinationIpAddressString ) ;

						ProvIpAddressType t_NextHopIpAddress ( ntohl ( t_Entry.ire_nexthop ) ) ;
						CDeleteString t_NextHopIpAddressString (t_NextHopIpAddress.GetStringValue () ) ;
						pInstance->SetCHString( RouteNextHop, t_NextHopIpAddressString ) ;

					/*
					 *	Initialize the instance
					 */

						ProvIpAddressType t_DestinationMaskIpAddress ( ntohl ( t_Entry.ire_mask ) ) ;
						CDeleteString t_DestinationMaskIpAddressString (t_DestinationMaskIpAddress.GetStringValue () ) ;
						pInstance->SetCHString( RouteMask, t_DestinationMaskIpAddressString ) ;

						pInstance->SetDWORD ( RouteAge, t_Entry.ire_age ) ;
						pInstance->SetDWORD ( RouteInterfaceIndex, t_Entry.ire_index ) ;
						pInstance->SetCHString ( RouteInformation, "0.0" ) ;
						pInstance->SetDWORD ( RouteProtocol, t_Entry.ire_proto ) ;
						pInstance->SetDWORD ( RouteType, t_Entry.ire_type ) ;
						pInstance->SetDWORD ( RouteMetric1, t_Entry.ire_metric1 ) ;
						pInstance->SetDWORD ( RouteMetric2, t_Entry.ire_metric2 ) ;
						pInstance->SetDWORD ( RouteMetric3, t_Entry.ire_metric3 ) ;
						pInstance->SetDWORD ( RouteMetric4, t_Entry.ire_metric4 ) ;
						pInstance->SetDWORD ( RouteMetric5, t_Entry.ire_metric5 ) ;

						//set the inherited properties that are sensible
						SetInheritedProperties (
							t_DestinationIpAddressString ,
							t_NextHopIpAddressString ,
							t_DestinationMaskIpAddressString ,
							*pInstance
						) ;


					/*
					 *	Forward the instance onto the core wmi service
					 */

						hRes = Commit ( pInstance ) ;
					}
				}
			}
			catch(...)
			{
				HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
				throw ;
			}

			HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;

		}
		else
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_FAILURE ;
	}

    return hRes ;
}

HRESULT CIPRouteTable :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	SmartCloseNtHandle t_StackHandle ;
	SmartCloseNtHandle t_CompleteEventHandle ;

	NTSTATUS t_NtStatus = OpenQuerySource (

		t_StackHandle ,
		t_CompleteEventHandle
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		ulong t_RouteTableSize = 0 ;
		IPRouteEntry *t_InformationBlock = NULL ;

		t_NtStatus = QueryInformation_IpRouteInfo (

			t_StackHandle ,
			t_CompleteEventHandle ,
			t_RouteTableSize ,
			t_InformationBlock
		) ;

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
			try
			{
				for ( ulong t_RouteIndex = 0 ; t_RouteIndex < t_RouteTableSize ; t_RouteIndex ++ )
				{
					IPRouteEntry &t_Entry = t_InformationBlock [ t_RouteIndex ] ;

				/*
				 *	Create a new instance based on the passed-in MethodContext.
				 *	Note that CreateNewInstance may throw, but will never return NULL.
				 */

					CInstance *pInstance = CreateNewInstance ( pMethodContext ) ;

				/*
				 *	Set the keys for the instance
				 */

					ProvIpAddressType t_DestinationIpAddress ( ntohl ( t_Entry.ire_dest ) ) ;
					CDeleteString t_DestinationIpAddressString(t_DestinationIpAddress.GetStringValue ());
					pInstance->SetCHString ( RouteDestination, t_DestinationIpAddressString ) ;

					ProvIpAddressType t_NextHopIpAddress ( ntohl ( t_Entry.ire_nexthop ) ) ;
					CDeleteString t_NextHopIpAddressString (t_NextHopIpAddress.GetStringValue () ) ;
					pInstance->SetCHString( RouteNextHop, t_NextHopIpAddressString ) ;

				/*
				 *	Initialize the instance
				 */

					ProvIpAddressType t_DestinationMaskIpAddress ( ntohl ( t_Entry.ire_mask ) ) ;
					CDeleteString t_DestinationMaskIpAddressString (t_DestinationMaskIpAddress.GetStringValue () ) ;
					pInstance->SetCHString( RouteMask, t_DestinationMaskIpAddressString ) ;

					pInstance->SetDWORD ( RouteAge, t_Entry.ire_age ) ;
					pInstance->SetDWORD ( RouteInterfaceIndex, t_Entry.ire_index ) ;
					pInstance->SetCHString ( RouteInformation, "0.0" ) ;
					pInstance->SetDWORD ( RouteProtocol, t_Entry.ire_proto ) ;
					pInstance->SetDWORD ( RouteType, t_Entry.ire_type ) ;
					pInstance->SetDWORD ( RouteMetric1, t_Entry.ire_metric1 ) ;
					pInstance->SetDWORD ( RouteMetric2, t_Entry.ire_metric2 ) ;
					pInstance->SetDWORD ( RouteMetric3, t_Entry.ire_metric3 ) ;
					pInstance->SetDWORD ( RouteMetric4, t_Entry.ire_metric4 ) ;
					pInstance->SetDWORD ( RouteMetric5, t_Entry.ire_metric5 ) ;

					//set the inherited properties that are sensible
					SetInheritedProperties (
						t_DestinationIpAddressString ,
						t_NextHopIpAddressString ,
						t_DestinationMaskIpAddressString ,
						*pInstance
					) ;

				/*
				 *	Forward the instance onto the core wmi service
				 */

					hRes = Commit ( pInstance ) ;
				}
			}
			catch ( ... )
			{
				HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
				throw ;
			}

			HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
		}
		else
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_FAILURE ;
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::GetObjectAsync.
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error
*                   occurred.
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: GetObject (

	CInstance *pInstance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString t_KeyDest ;
    pInstance->GetCHString ( RouteDestination , t_KeyDest ) ;
	ProvIpAddressType t_IpAddress ( t_KeyDest ) ;

    CHString t_KeyHop ;
    pInstance->GetCHString ( RouteNextHop , t_KeyHop ) ;
	ProvIpAddressType t_NextHop ( t_KeyHop ) ;

	if ( t_IpAddress.IsValid () && t_NextHop.IsValid () )
	{
		IPRouteEntry t_RouteEntry ;

		hr = QueryInformation_GetRouteEntry (

			t_IpAddress ,
			t_NextHop ,
			t_RouteEntry
		) ;

		if ( SUCCEEDED ( hr ) )
		{
			/*
			 *	Initialize the instance
			 */

			ProvIpAddressType t_DestinationMaskIpAddress ( ntohl ( t_RouteEntry.ire_mask ) ) ;
			CDeleteString t_DestinationMaskIpAddressString (t_DestinationMaskIpAddress.GetStringValue () ) ;
			pInstance->SetCHString( RouteMask, t_DestinationMaskIpAddressString ) ;

			pInstance->SetDWORD ( RouteAge, t_RouteEntry.ire_age ) ;
			pInstance->SetDWORD ( RouteInterfaceIndex, t_RouteEntry.ire_index ) ;
			pInstance->SetCHString ( RouteInformation, "0.0" ) ;
			pInstance->SetDWORD ( RouteProtocol, t_RouteEntry.ire_proto ) ;
			pInstance->SetDWORD ( RouteType, t_RouteEntry.ire_type ) ;
			pInstance->SetDWORD ( RouteMetric1, t_RouteEntry.ire_metric1 ) ;
			pInstance->SetDWORD ( RouteMetric2, t_RouteEntry.ire_metric2 ) ;
			pInstance->SetDWORD ( RouteMetric3, t_RouteEntry.ire_metric3 ) ;
			pInstance->SetDWORD ( RouteMetric4, t_RouteEntry.ire_metric4 ) ;
			pInstance->SetDWORD ( RouteMetric5, t_RouteEntry.ire_metric5 ) ;

			//set the inherited properties that are sensible
			SetInheritedProperties (
				t_KeyDest , 
				t_KeyHop ,
				t_DestinationMaskIpAddressString ,
				*pInstance
			) ;
		}
	}

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of
*                   instances that satisfy the query, and a CFrameworkQuery
*                   which describes the query.  Create and populate all
*                   instances which satisfy the query.  You may return more
*                   instances or more properties than are requested and WinMgmt
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt
*                       will call your enumerate function to get all the instances and perform the
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/

HRESULT CIPRouteTable :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &Query,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	ProvThreadObject :: Startup () ;
	ProvDebugLog :: Startup () ;

	CHString t_QueryString ;
	t_QueryString = Query.GetQuery () ;

	SQL_LEVEL_1_RPN_EXPRESSION *t_RpnExpression = NULL ;
	QueryPreprocessor :: QuadState t_State = CIPRouteTable :: Query (

		t_QueryString.GetBuffer ( 0 ) ,
		t_RpnExpression
	) ;

	if ( t_State == QueryPreprocessor :: QuadState :: State_True )
	{
		WmiTreeNode *t_Root = NULL ;

		try
		{
			t_State = PreProcess (

				pMethodContext ,
				t_RpnExpression ,
				t_Root
			) ;

			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{
					PartitionSet *t_Partition = NULL ;

					BSTR t_PropertyContainer [ 1 ] ;
					t_PropertyContainer [ 0 ] = SysAllocString ( RouteDestination ) ;

					if ( NULL == t_PropertyContainer [ 0 ] )
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}

					try
					{
						t_State = PreProcess (

							pMethodContext ,
							t_RpnExpression ,
							t_Root ,
							1 ,
							t_PropertyContainer ,
							t_Partition
						) ;
					}
					catch(...)
					{
						if ( t_Partition )
						{
							delete t_Partition;
							t_Partition = NULL;
						}

						if ( t_PropertyContainer [ 0 ] )
						{
							SysFreeString ( t_PropertyContainer [ 0 ] ) ;
							t_PropertyContainer [ 0 ] = NULL;
						}

						throw;
					}

					SysFreeString ( t_PropertyContainer [ 0 ] ) ;

					switch ( t_State )
					{
						case QueryPreprocessor :: QuadState :: State_True :
						{
							t_Result = EnumerateInstances ( pMethodContext , lFlags ) ;
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_False :
						{
	/*
	 * Empty set
	 */
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_Undefined :
						{
							t_Result = RangeQuery ( pMethodContext , *t_Partition , lFlags ) ;

							delete t_Partition ;
							t_Partition = NULL ;
						}
						break ;

						default:
						{
							//couldn't understand this query
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
						break ;
					}

					//this is allocated on PreProcess(pctx, rpn, root) success
					delete t_Root ;
					t_Root = NULL ;
				}
				break ;

				default:
				{
					//couldn't understand this query
					t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
				}
				break ;
			}

			delete t_RpnExpression ;
			t_RpnExpression = NULL ;
		}
		catch ( ... )
		{
			if ( t_Root )
			{
				delete t_Root;
				t_Root = NULL;
			}

			if ( t_RpnExpression )
			{
				delete t_RpnExpression;
				t_RpnExpression = NULL;
			}

			ProvThreadObject :: Closedown () ;
			ProvDebugLog :: Closedown () ;

			throw;
		}
	}
	else
	{
		//couldn't understand this query
		t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
	}

	ProvThreadObject :: Closedown () ;
	ProvDebugLog :: Closedown () ;

	return t_Result ;
}

/*****************************************************************************
*
*  FUNCTION    : CIPRouteTable::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can
*                   write instance information back to the hardware or
*                   software.  For example: Win32_Environment will allow a
*                   PutInstance to create or update an environment variable.
*                   However, a class like MotherboardDevice will not allow
*                   editing of the number of slots, since it is difficult for
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::PutInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider,
*                       or are creating a 'method only' provider, remove this
*                       method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: PutInstance  (

	const CInstance &Instance,
	long lFlags
)
{
    HRESULT hr = WBEM_E_FAILED ;

    switch ( lFlags & (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY) )
	{
        case WBEM_FLAG_CREATE_OR_UPDATE:
        case WBEM_FLAG_UPDATE_ONLY:
        case WBEM_FLAG_CREATE_ONLY:
		{
			CHString t_KeyDest ;
			Instance.GetCHString ( RouteDestination , t_KeyDest ) ;
			ProvIpAddressType t_IpAddress ( t_KeyDest ) ;

			CHString t_KeyHop ;
			Instance.GetCHString ( RouteNextHop , t_KeyHop ) ;
			ProvIpAddressType t_NextHop ( t_KeyHop ) ;

			if ( t_IpAddress.IsValid () && t_NextHop.IsValid () )
			{
				IPRouteEntry t_RouteEntry ;

				hr = QueryInformation_GetRouteEntry (

					t_IpAddress ,
					t_NextHop ,
					t_RouteEntry
				) ;

				switch ( lFlags & (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY) )
				{
					case WBEM_FLAG_CREATE_OR_UPDATE:
					{
						hr = ( hr == WBEM_E_NOT_FOUND || hr == WBEM_S_NO_ERROR ) ? WBEM_S_NO_ERROR : hr ;
					}
					break;

					case WBEM_FLAG_UPDATE_ONLY:
					{
					}
					break;

					case WBEM_FLAG_CREATE_ONLY:
					{
						if ( hr == WBEM_S_NO_ERROR )
						{
							hr = WBEM_E_ALREADY_EXISTS ;
						}
						else if ( hr == WBEM_E_NOT_FOUND )
						{
							hr = WBEM_S_NO_ERROR ;
						}
					}
					break;
				}

				if ( SUCCEEDED ( hr ) )
				{
					hr = CheckParameters (

						Instance ,
						t_RouteEntry
					) ;
				}

				if ( SUCCEEDED ( hr ) )
				{
					//reset to an error which will be cleared on success...
					hr = WBEM_E_FAILED;

					SmartCloseNtHandle t_StackHandle;
					SmartCloseNtHandle t_CompleteEventHandle;

					NTSTATUS t_NtStatus = OpenSetSource (

						t_StackHandle ,
						t_CompleteEventHandle
					) ;

					if ( NT_SUCCESS ( t_NtStatus ) )
					{
						t_NtStatus = SetInformation_IpRouteInfo (

							t_StackHandle ,
							t_CompleteEventHandle ,
							t_RouteEntry
						) ;

						if ( NT_SUCCESS ( t_NtStatus ) )
						{
							hr = WBEM_S_NO_ERROR ;
						}
					}
				}
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER ;
			}
		}
		break ;

		default:
		{
			hr = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
		break ;
	}

    return hr ;
}

HRESULT CIPRouteTable :: CheckParameters (

	const CInstance &a_Instance ,
	IPRouteEntry &a_RouteEntry
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;

	ZeroMemory ( & a_RouteEntry , sizeof ( a_RouteEntry ) ) ;

	a_RouteEntry.ire_metric2 = -1 ;
	a_RouteEntry.ire_metric3 = -1 ;
	a_RouteEntry.ire_metric4 = -1 ;
	a_RouteEntry.ire_metric5 = -1 ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_RouteDestinationString ;
	if ( a_Instance.GetStatus ( RouteDestination , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteDestination , t_RouteDestinationString ) && ! t_RouteDestinationString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationString ) ;
				if ( t_Address.IsValid () )
				{
					a_RouteEntry.ire_dest = htonl ( t_Address.GetValue () ) ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CHString t_RouteDestinationMaskString ;
	if ( a_Instance.GetStatus ( RouteMask , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteMask , t_RouteDestinationMaskString ) && ! t_RouteDestinationMaskString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteDestinationMaskString ) ;
				if ( t_Address.IsValid () )
				{
					a_RouteEntry.ire_mask = htonl ( t_Address.GetValue () ) ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CHString t_RouteNextHopString ;
	if ( a_Instance.GetStatus ( RouteNextHop, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( RouteNextHop , t_RouteNextHopString ) && ! t_RouteNextHopString.IsEmpty () )
			{
				ProvIpAddressType t_Address ( t_RouteNextHopString ) ;
				if ( t_Address.IsValid () )
				{
					a_RouteEntry.ire_nexthop = htonl ( t_Address.GetValue () ) ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
// Zero Length string

				return WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	if ( a_Instance.GetStatus ( RouteInterfaceIndex , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_InterfaceIndex = 0 ;
			if ( a_Instance.GetDWORD ( RouteInterfaceIndex , t_InterfaceIndex ) )
			{
				a_RouteEntry.ire_index = t_InterfaceIndex ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	if ( a_Instance.GetStatus ( RouteProtocol , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Protocol = 0 ;
			if ( a_Instance.GetDWORD ( RouteProtocol , t_Protocol ) )
			{
				a_RouteEntry.ire_proto = t_Protocol ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}


	if ( a_Instance.GetStatus ( RouteType , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Type = 0 ;
			if ( a_Instance.GetDWORD ( RouteType , t_Type ) )
			{
				a_RouteEntry.ire_type = t_Type ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

#if 0
	if ( a_Instance.GetStatus ( RouteAge , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Age = 0 ;
			if ( a_Instance.GetDWORD ( RouteAge , t_Age ) )
			{
				a_RouteEntry.ire_age = t_Age ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

#endif

	if ( a_Instance.GetStatus ( RouteMetric1 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Metric = 0 ;
			if ( a_Instance.GetDWORD ( RouteMetric1 , t_Metric ) )
			{
				a_RouteEntry.ire_metric1 = t_Metric ;
			}
			else
			{
				return WBEM_E_INVALID_PARAMETER  ;
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	if ( a_Instance.GetStatus ( RouteMetric2 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric2 , t_Metric ) )
				{
					a_RouteEntry.ire_metric2 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	if ( a_Instance.GetStatus ( RouteMetric3 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric3 , t_Metric ) )
				{
					a_RouteEntry.ire_metric3 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	if ( a_Instance.GetStatus ( RouteMetric5 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric5 , t_Metric ) )
				{
					a_RouteEntry.ire_metric5 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	if ( a_Instance.GetStatus ( RouteMetric4 , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				DWORD t_Metric = 0 ;
				if ( a_Instance.GetDWORD ( RouteMetric4 , t_Metric ) )
				{
					a_RouteEntry.ire_metric4 = t_Metric ;
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER  ;
				}
			}
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER  ;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_FAILURE ;
	}

	return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices,
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties.
*                   A long that contains the flags described in
*                   IWbemServices::DeleteInstanceAsync.
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: DeleteInstance (

	const CInstance &Instance,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED ;

    CHString t_KeyDest ;
    Instance.GetCHString ( RouteDestination , t_KeyDest ) ;
	ProvIpAddressType t_IpAddress ( t_KeyDest ) ;

    CHString t_KeyHop ;
    Instance.GetCHString ( RouteNextHop , t_KeyHop ) ;
	ProvIpAddressType t_NextHop ( t_KeyHop ) ;

	if ( t_IpAddress.IsValid () && t_NextHop.IsValid () )
	{
		IPRouteEntry t_RouteEntry ;

		hr = QueryInformation_GetRouteEntry (

			t_IpAddress ,
			t_NextHop ,
			t_RouteEntry
		) ;

		if ( SUCCEEDED ( hr ) )
		{
			SmartCloseNtHandle t_StackHandle ;
			SmartCloseNtHandle t_CompleteEventHandle ;

			NTSTATUS t_NtStatus = OpenSetSource (

				t_StackHandle ,
				t_CompleteEventHandle
			) ;

			if ( NT_SUCCESS ( t_NtStatus ) )
			{
				t_NtStatus = DeleteInformation_IpRouteInfo (

					t_StackHandle ,
					t_CompleteEventHandle ,
					t_RouteEntry
				) ;

				if ( NT_SUCCESS ( t_NtStatus ) )
				{
					hr = WBEM_S_NO_ERROR ;
				}
			}
		}
	}

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CIPRouteTable::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.
*                   A method is an entry point for the user of your provider
*                   to request your class perform some function above and
*                   beyond a change of state.  (A change of state should be
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/

HRESULT CIPRouteTable :: ExecMethod (

	const CInstance &Instance,
	const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
    // For non-static methods, use the CInstance Get functions (for example,
    // call GetCHString(L"Name", sTemp)) against Instance to see the key
    // values the client requested.

    return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

NTSTATUS CIPRouteTable :: OpenQuerySource (

	HANDLE &a_StackHandle ,
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_TCP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_EXECUTE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
			a_StackHandle = INVALID_HANDLE_VALUE ;
		}
	}

	return t_NtStatus ;
}

HRESULT CIPRouteTable :: QueryInformation_GetRouteEntry (

	const ProvIpAddressType &a_DestinationIpAddress ,
	const ProvIpAddressType &a_NextHopIpAddress ,
	IPRouteEntry &a_RouteEntry
)
{
	HRESULT hRes = WBEM_E_NOT_FOUND ;

	SmartCloseNtHandle t_StackHandle ;
	SmartCloseNtHandle t_CompleteEventHandle ;

	NTSTATUS t_NtStatus = OpenQuerySource (

		t_StackHandle ,
		t_CompleteEventHandle
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		ulong t_RouteTableSize = 0 ;
		IPRouteEntry *t_InformationBlock = NULL ;

		t_NtStatus = QueryInformation_IpRouteInfo (

			t_StackHandle ,
			t_CompleteEventHandle ,
			t_RouteTableSize ,
			t_InformationBlock
		) ;

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
			try
			{
				for ( ulong t_RouteIndex = 0 ; t_RouteIndex < t_RouteTableSize ; t_RouteIndex ++ )
				{
					IPRouteEntry &t_Entry = t_InformationBlock [ t_RouteIndex ] ;

					ProvIpAddressType t_DestinationIpAddress ( ntohl ( t_Entry.ire_dest ) ) ;
					ProvIpAddressType t_NextHopIpAddress ( ntohl ( t_Entry.ire_nexthop ) ) ;

					if ( ( t_DestinationIpAddress == a_DestinationIpAddress ) &&
						( t_NextHopIpAddress == a_NextHopIpAddress ) )
					{
						a_RouteEntry = t_InformationBlock [ t_RouteIndex ] ;

						hRes = WBEM_S_NO_ERROR ;
						break ;
					}
				}
			}
			catch ( ... )
			{
				HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
				throw ;
			}

			HeapFree ( GetProcessHeap () , 0, t_InformationBlock ) ;
		}
		else
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

	return hRes ;
}

NTSTATUS CIPRouteTable :: QueryInformation_IpRouteInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	ulong &a_RouteTableSize ,
	IPRouteEntry *&a_InformationBlock
)
{
	IPSNMPInfo a_Information ;
	NTSTATUS t_NtStatus = QueryInformation_IpSnmpInfo (

		a_StackHandle ,
		a_CompleteEventHandle ,
		a_Information
	) ;

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
		TCP_REQUEST_QUERY_INFORMATION_EX InBuf;
		ulong InBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );

		ulong OutBufLen = ( a_Information.ipsi_numroutes + 16 ) * sizeof ( IPRouteEntry ) ;
		a_InformationBlock = ( IPRouteEntry * ) HeapAlloc ( GetProcessHeap (), 0, OutBufLen ) ;
		if ( a_InformationBlock )
		{
			TDIObjectID *ID = & ( InBuf.ID ) ;

			ID = &(InBuf.ID);
			ID->toi_entity.tei_entity = CL_NL_ENTITY;
			ID->toi_entity.tei_instance = 0;
			ID->toi_class = INFO_CLASS_PROTOCOL;
			ID->toi_type = INFO_TYPE_PROVIDER;
			ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;

			uchar *Context = ( uchar * ) & ( InBuf.Context [ 0 ] ) ;

			ZeroMemory ( Context, CONTEXT_SIZE ) ;

			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				a_StackHandle ,
				a_CompleteEventHandle ,
				NULL ,
				NULL ,
				&t_IoStatusBlock ,
				IOCTL_TCP_QUERY_INFORMATION_EX,
				( void * ) & InBuf,
				InBufLen,
				( void * ) ( a_InformationBlock ) ,
				OutBufLen
			);

			if ( t_NtStatus == STATUS_PENDING )
			{
				t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
			}

			if ( SUCCEEDED ( t_NtStatus ) )
			{
			    a_RouteTableSize = ( t_IoStatusBlock.Information / sizeof ( IPRouteEntry ) ) ;
			}
		}
		else
		{
			return ERROR_NOT_ENOUGH_MEMORY ;
		}
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: QueryInformation_IpSnmpInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	IPSNMPInfo &a_Information
)
{
    TCP_REQUEST_QUERY_INFORMATION_EX InBuf;
    ulong InBufLen = sizeof( TCP_REQUEST_QUERY_INFORMATION_EX );
    ulong OutBufLen = sizeof ( IPSNMPInfo ) ;

    TDIObjectID *ID = & ( InBuf.ID ) ;

    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_STATS_ID;

    uchar *Context = ( uchar * ) & ( InBuf.Context [ 0 ] ) ;

    ZeroMemory ( Context, CONTEXT_SIZE ) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtDeviceIoControlFile (

		a_StackHandle ,
        a_CompleteEventHandle ,
        NULL ,
        NULL ,
        &t_IoStatusBlock ,
        IOCTL_TCP_QUERY_INFORMATION_EX,
        ( void * ) & InBuf,
        InBufLen,
        ( void * ) ( & a_Information ) ,
        OutBufLen
	);

	if ( t_NtStatus == STATUS_PENDING )
	{
		t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
	}

	if ( SUCCEEDED ( t_NtStatus ) )
	{
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: OpenSetSource (

	HANDLE &a_StackHandle ,
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_TCP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_WRITE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
			a_StackHandle = INVALID_HANDLE_VALUE ;
		}
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: SetInformation_IpRouteInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	IPRouteEntry &a_RouteEntry
)
{
	NTSTATUS t_NtStatus = STATUS_SUCCESS ;

    ulong InBufLen = sizeof ( TCP_REQUEST_SET_INFORMATION_EX ) + sizeof ( IPSNMPInfo ) - 1 ;
    TCP_REQUEST_SET_INFORMATION_EX  *InBuf = ( TCP_REQUEST_SET_INFORMATION_EX  * ) HeapAlloc ( GetProcessHeap(), 0, InBufLen ) ;
    if ( InBuf )
    {
		try
		{
			IPRouteEntry *t_Entry = ( IPRouteEntry * ) &(InBuf->Buffer[0]) ;
			*t_Entry = a_RouteEntry ;

			TDIObjectID *ID = &(InBuf->ID);
			ID->toi_entity.tei_entity = CL_NL_ENTITY;
			ID->toi_entity.tei_instance = 0;
			ID->toi_class = INFO_CLASS_PROTOCOL;
			ID->toi_type = INFO_TYPE_PROVIDER;
			ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;

			InBuf->BufferSize = sizeof ( IPRouteEntry );

			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				a_StackHandle ,
				a_CompleteEventHandle ,
				NULL ,
				NULL ,
				&t_IoStatusBlock ,
				IOCTL_TCP_SET_INFORMATION_EX ,
				( void * ) InBuf,
				InBufLen,
				NULL ,
				0
			);

			if ( t_NtStatus == STATUS_PENDING )
			{
				t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
			}
		}
		catch ( ... )
		{
			HeapFree ( GetProcessHeap () , 0, InBuf ) ;
			throw ;
		}

		HeapFree ( GetProcessHeap () , 0, InBuf ) ;
	}
	else
	{
		t_NtStatus = ERROR_NOT_ENOUGH_MEMORY ;
	}

	return t_NtStatus ;
}

NTSTATUS CIPRouteTable :: DeleteInformation_IpRouteInfo (

	HANDLE a_StackHandle ,
	HANDLE a_CompleteEventHandle ,
	IPRouteEntry &a_RouteEntry
)
{
	NTSTATUS t_NtStatus = STATUS_SUCCESS ;

    ulong InBufLen = sizeof ( TCP_REQUEST_SET_INFORMATION_EX ) + sizeof ( IPSNMPInfo ) - 1 ;
    TCP_REQUEST_SET_INFORMATION_EX  *InBuf = ( TCP_REQUEST_SET_INFORMATION_EX  * ) HeapAlloc ( GetProcessHeap(), 0, InBufLen ) ;
    if ( InBuf )
    {
		try
		{
			IPRouteEntry *t_Entry = ( IPRouteEntry * ) &(InBuf->Buffer[0]) ;
			*t_Entry = a_RouteEntry ;

/*
 *	Invalidate the route
 */

			t_Entry->ire_type = 2 ;

			TDIObjectID *ID = &(InBuf->ID);
			ID->toi_entity.tei_entity = CL_NL_ENTITY;
			ID->toi_entity.tei_instance = 0;
			ID->toi_class = INFO_CLASS_PROTOCOL;
			ID->toi_type = INFO_TYPE_PROVIDER;
			ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;

			InBuf->BufferSize = sizeof ( IPRouteEntry );

			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				a_StackHandle ,
				a_CompleteEventHandle ,
				NULL ,
				NULL ,
				&t_IoStatusBlock ,
				IOCTL_TCP_SET_INFORMATION_EX ,
				( void * ) InBuf,
				InBufLen,
				NULL ,
				0
			);

			if ( t_NtStatus == STATUS_PENDING )
			{
				t_NtStatus = NtWaitForSingleObject ( a_CompleteEventHandle , FALSE, NULL ) ;
			}
		}
		catch ( ... )
		{
			HeapFree ( GetProcessHeap () , 0, InBuf ) ;
			throw ;
		}

		HeapFree ( GetProcessHeap () , 0, InBuf ) ;
	}
	else
	{
		t_NtStatus = ERROR_NOT_ENOUGH_MEMORY ;
	}

	return t_NtStatus ;
}

DWORD CIPRouteTable :: GetPriority ( BSTR a_PropertyName )
{
	return 0xFFFFFFFF ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: Compare (

	LONG a_Operand1 ,
	LONG a_Operand2 ,
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: Compare (

	wchar_t *a_Operand1 ,
	wchar_t *a_Operand2 ,
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	CHString a_Operand1AfterFunc ;
	CHString a_Operand2AfterFunc ;

	switch ( a_Operand1Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			a_Operand1AfterFunc = a_Operand1 ;
			a_Operand1AfterFunc.MakeUpper () ;
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			a_Operand1AfterFunc = a_Operand1 ;
			a_Operand1AfterFunc.MakeLower () ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func )
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			a_Operand2AfterFunc = a_Operand2 ;
			a_Operand2AfterFunc.MakeUpper () ;
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			a_Operand2AfterFunc = a_Operand2 ;
			a_Operand2AfterFunc.MakeLower () ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc.IsEmpty () ? a_Operand1 : (LPCWSTR)a_Operand1AfterFunc ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc.IsEmpty () ? a_Operand2 : (LPCWSTR)a_Operand2AfterFunc ;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: CompareString (

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare (

			t_StringNode->GetValue () ,
			t_Variant.bstrVal ,
			t_StringNode->GetPropertyFunction () ,
			t_StringNode->GetConstantFunction () ,
			*a_Operator
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: CompareInteger (

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare (

			t_IntegerNode->GetValue () ,
			t_Variant.lVal ,
			t_IntegerNode->GetPropertyFunction () ,
			t_IntegerNode->GetConstantFunction () ,
			*a_Operator
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

WmiTreeNode *CIPRouteTable :: AllocTypeNode (

	void *a_Context ,
	BSTR a_PropertyName ,
	VARIANT &a_Variant ,
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode (

				a_PropertyName ,
				a_Variant.lVal,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode (

				a_PropertyName ,
				a_Variant.lVal ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode (

				a_PropertyName ,
				a_Variant.bstrVal ,
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		CInstance *t_ClassObject = NULL ;
		HRESULT t_Result = GetClassObject ( t_ClassObject, (MethodContext *)a_Context ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObjectPtr t_pClas ( t_ClassObject->GetClassObjectInterface () , false ) ;

			if ( t_pClas != NULL )
			{
				CIMTYPE t_VarType ;
				long t_Flavour ;
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;


				HRESULT t_Result = t_pClas->Get (

					a_PropertyName ,
					0 ,
					& t_Variant ,
					& t_VarType ,
					& t_Flavour
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_VarType & CIM_FLAG_ARRAY )
					{
					}
					else
					{
						switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
						{
							case CIM_BOOLEAN:
							{
								if(V_VT(&a_Variant) == VT_I4)
								{
									t_Node = new WmiSignedIntegerNode ( 

										a_PropertyName , 
										a_Variant.lVal , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if (V_VT(&a_Variant) == VT_BOOL)
								{
									t_Node = new WmiSignedIntegerNode ( 

										a_PropertyName , 
										(a_Variant.lVal == VARIANT_FALSE) ? 0 : 1, 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_SINT8:
							case CIM_SINT16:
							case CIM_CHAR16:
							case CIM_SINT32:
							{
								if(V_VT(&a_Variant) == VT_I4)
								{
									t_Node = new WmiSignedIntegerNode (

										a_PropertyName ,
										a_Variant.lVal ,
										GetPriority ( a_PropertyName ) ,
										a_Parent
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_UINT8:
							case CIM_UINT16:
							case CIM_UINT32:
							{
								if(V_VT(&a_Variant) == VT_I4)
								{
									t_Node = new WmiUnsignedIntegerNode (

										a_PropertyName ,
										a_Variant.lVal ,
										GetPriority ( a_PropertyName ) ,
										a_Parent
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_SINT64:
							case CIM_UINT64:
							{
								if(V_VT(&a_Variant) == VT_BSTR)
								{
									t_Node = new WmiStringNode ( 

										a_PropertyName , 
										a_Variant.bstrVal , 
										a_PropertyFunction ,
										a_ConstantFunction ,
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if(V_VT(&a_Variant) == VT_I4)
								{
									_variant_t t_uintBuff (&a_Variant);

									t_Node = new WmiStringNode ( 

										a_PropertyName , 
										(BSTR)((_bstr_t) t_uintBuff), 
										a_PropertyFunction ,
										a_ConstantFunction ,
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_STRING:
							case CIM_DATETIME:
							case CIM_REFERENCE:
							{
								if(V_VT(&a_Variant) == VT_BSTR)
								{
									t_Node = new WmiStringNode (

										a_PropertyName ,
										a_Variant.bstrVal ,
										a_PropertyFunction ,
										a_ConstantFunction ,
										GetPriority ( a_PropertyName ) ,
										a_Parent
									) ;
								}
								else if (V_VT(&a_Variant) == VT_NULL)
								{
									t_Node = new WmiNullNode (

										a_PropertyName , 
										GetPriority ( a_PropertyName ) ,
										a_Parent 
									);
								}
							}
							break ;

							case CIM_REAL32:
							case CIM_REAL64:
							{
							}
							break ;

							case CIM_OBJECT:
							case CIM_EMPTY:
							{
							}
							break ;

							default:
							{
							}
							break ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;
			}

			t_ClassObject->Release () ;
		}
	}

	return t_Node ;
}

QueryPreprocessor :: QuadState CIPRouteTable :: InvariantEvaluate (

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Error ;

	CInstance *t_ClassObject = NULL ;
	HRESULT t_Result = GetClassObject ( t_ClassObject, (MethodContext *)a_Context ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObjectPtr t_pClas(t_ClassObject->GetClassObjectInterface (), false );

		if (t_pClas != NULL)
		{
			WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;

			if ( t_PropertyName != NULL )
			{
				if ( *t_PropertyName == L'_' )
				{
					// System property, must check values
					if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_CLASS ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_SUPERCLASS ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
					{
						t_State = CompareInteger (

							t_pClas ,
							SYSTEM_PROPERTY_GENUS ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_SERVER ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_NAMESPACE ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
					{
						t_State = CompareInteger (

							t_pClas ,
							SYSTEM_PROPERTY_PROPERTY_COUNT ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_DYNASTY ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_RELPATH ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
					{
						t_State = CompareString (

							t_pClas ,
							SYSTEM_PROPERTY_PATH ,
							a_Operator ,
							a_Operand
						) ;
					}
					else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
				}
				else
				{
					if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
	#if 0
					else if ( typeid ( *a_Operand ) == typeid ( WmiStringNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operand ) == typeid ( WmiUnsignedIntegerNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operand ) == typeid ( WmiSignedIntegerNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}

					if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLikeNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
					else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotLikeNode ) )
					{
						t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
					}
	#endif
				}
			}
			else
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
			}
		}

		t_ClassObject->Release();
	}

	return t_State ;
}

WmiRangeNode *CIPRouteTable :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName
)
{
	WmiRangeNode *t_RangeNode = NULL ;
	CInstance *t_ClassObject = NULL ;
	HRESULT t_Result = GetClassObject ( t_ClassObject, (MethodContext *)a_Context ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObjectPtr t_pClas ( t_ClassObject->GetClassObjectInterface () , false ) ;

		if ( t_pClas != NULL )
		{
			CIMTYPE t_VarType ;
			long t_Flavour ;
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			HRESULT t_Result = t_pClas->Get (

				a_PropertyName ,
				0 ,
				& t_Variant ,
				& t_VarType ,
				& t_Flavour
			);

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_VarType & CIM_FLAG_ARRAY )
				{
				}
				else
				{
					switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
					{
						case CIM_BOOLEAN:
						case CIM_SINT8:
						case CIM_SINT16:
						case CIM_CHAR16:
						case CIM_SINT32:
						{
							t_RangeNode = new WmiSignedIntegerRangeNode (

								a_PropertyName ,
								0xFFFFFFFF ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								0 ,
								0 ,
								NULL ,
								NULL
							) ;
						}
						break ;

						case CIM_UINT8:
						case CIM_UINT16:
						case CIM_UINT32:
						{
							t_RangeNode = new WmiUnsignedIntegerRangeNode (

								a_PropertyName ,
								0xFFFFFFFF ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								0 ,
								0 ,
								NULL ,
								NULL
							) ;
						}
						break ;

						case CIM_SINT64:
						case CIM_UINT64:
						case CIM_STRING:
						case CIM_DATETIME:
						case CIM_REFERENCE:
						{
							t_RangeNode = new WmiStringRangeNode (

								a_PropertyName ,
								0x0 ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								NULL ,
								NULL ,
								NULL ,
								NULL
							) ;
						}
						break ;

						case CIM_REAL32:
						case CIM_REAL64:
						{
						}
						break ;

						case CIM_OBJECT:
						case CIM_EMPTY:
						{
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
			}

			VariantClear ( & t_Variant ) ;
		}

		t_ClassObject->Release () ;
	}

	return t_RangeNode ;
}

HRESULT CIPRouteTable :: GetClassObject ( CInstance *&a_ClassObject, MethodContext *a_Context )
{
	HRESULT t_Result = S_OK ;
	EnterCriticalSection( &m_CS ) ;

	try
	{
		if ( m_ClassCInst == NULL )
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	catch(...)
	{
		LeaveCriticalSection( &m_CS );
		throw;
	}

	LeaveCriticalSection( &m_CS );

	if (t_Result == WBEM_E_FAILED)
	{	
		CHString t_Namespace ( GetNamespace () ) ;
		CHString t_ComputerName ( GetLocalComputerName () ) ;
		CHString t_ClassName ( GetProviderName () ) ;
		CHString t_AbsPath = L"\\\\" + t_ComputerName + L"\\" + t_Namespace + L":" + t_ClassName ;

		t_Result = CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath.GetBuffer ( 0 ) , & a_ClassObject, a_Context ) ;

		if ( SUCCEEDED (t_Result) )
		{
			EnterCriticalSection( &m_CS ) ;

			try
			{
				if ( m_ClassCInst == NULL )
				{
					m_ClassCInst = a_ClassObject ;
					m_ClassCInst->AddRef();
				}
			}
			catch(...)
			{
				LeaveCriticalSection( &m_CS );
				throw;
			}

			LeaveCriticalSection( &m_CS );
		}
	}
	else
	{
		a_ClassObject = m_ClassCInst;
		a_ClassObject->AddRef();
	}

	return t_Result ;
}

void CIPRouteTable :: SetInheritedProperties (

	LPCWSTR a_dest ,
	LPCWSTR a_gateway ,
	LPCWSTR a_mask ,
	CInstance &a_Instance
)
{
	CHString t_temp( a_dest ) ;
	a_Instance.SetCHString ( RouteName, t_temp ) ;
	a_Instance.SetCHString ( RouteCaption, t_temp ) ;

	t_temp = t_temp + ROUTE_DESCRIPTION_SEP + a_mask + ROUTE_DESCRIPTION_SEP + a_gateway;
	a_Instance.SetCHString ( RouteDescription, t_temp ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <Binding.h>

CBinding MyActiveRoute(
    L"Win32_ActiveRoute",
    L"root\\cimv2",
    L"Win32_IP4RouteTable",
    L"Win32_IP4PersistedRouteTable",
    L"SystemElement",
    L"SameElement",
	L"Destination",
	L"Destination"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\ciprouteevent.cpp ===
//=================================================================
//
// PowerManagement.cpp --
//
// Copyright 1999 Microsoft Corporation
//
// Revisions:   03/31/99	a-peterc        Created
//
//=================================================================

#include "precomp.h"
#include <ntddip.h>
#include <ntddtcp.h>
#include "CIpRouteEvent.h"

LONG CIPRouteEventProviderClassFactory::s_ObjectsInProgress = 0 ;
LONG CIPRouteEventProviderClassFactory::s_LocksInProgress = 0 ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Class:			CIPRouteEventProviderClassFactory

 Description:	Provides class factory support for power management events

 Derivations:	public IClassFactory
 Caveats:
 Raid:
 History:		a-peterc  31-Mar-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

//
CIPRouteEventProviderClassFactory :: CIPRouteEventProviderClassFactory () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( &s_ObjectsInProgress ) ;
}

//
CIPRouteEventProviderClassFactory::~CIPRouteEventProviderClassFactory ()
{
	InterlockedDecrement ( &s_ObjectsInProgress ) ;
}

//
STDMETHODIMP_( ULONG ) CIPRouteEventProviderClassFactory::AddRef()
{
	return InterlockedIncrement ( &m_ReferenceCount ) ;
}

//
STDMETHODIMP_(ULONG) CIPRouteEventProviderClassFactory::Release()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement( &m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//
BOOL CIPRouteEventProviderClassFactory::DllCanUnloadNow()
{
	return ( !(s_ObjectsInProgress || s_LocksInProgress) ) ;
}

//***************************************************************************
//
// CBaseClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CIPRouteEventProviderClassFactory::LockServer ( BOOL a_fLock )
{
	if ( a_fLock )
	{
		InterlockedIncrement ( &s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( &s_LocksInProgress ) ;
	}

	return S_OK	;
}

//
STDMETHODIMP CIPRouteEventProviderClassFactory::QueryInterface (

	REFIID a_riid,
	PPVOID a_ppv
)
{
    *a_ppv = NULL ;

    if ( IID_IUnknown == a_riid || IID_IClassFactory == a_riid )
	{
        *a_ppv = this ;
    }

    if ( NULL != *a_ppv )
    {
        AddRef() ;
        return NOERROR ;
    }

    return ResultFromScode( E_NOINTERFACE ) ;
}

//***************************************************************************
//
// CIPRouteEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Event Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CIPRouteEventProviderClassFactory :: CreateInstance (

	LPUNKNOWN a_pUnkOuter ,
	REFIID a_riid ,
	LPVOID FAR *a_ppvObject
)
{
	HRESULT t_status = S_OK ;

	if ( a_pUnkOuter )
	{
		t_status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemProviderInit *t_lpunk = ( IWbemProviderInit * ) new CIPRouteEventProvider ;
		if ( t_lpunk == NULL )
		{
			t_status = E_OUTOFMEMORY ;
		}
		else
		{
			t_status = t_lpunk->QueryInterface ( a_riid , a_ppvObject ) ;
			if ( FAILED ( t_status ) )
			{
				delete t_lpunk ;
			}
		}
	}
	return t_status ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Class:			CIPRouteEventProvider

 Description:	Provider support for power management events

 Derivations:	public CIPRouteEventProvider,
				public IWbemEventProvider,
				public IWbemProviderInit
 Caveats:
 Raid:
 History:		a-peterc  31-Mar-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Event provider object

CIPRouteEventProvider :: CIPRouteEventProvider () : m_ReferenceCount( 0 ) ,
													m_pHandler(NULL),
													m_pClass(NULL),
													m_dwThreadID(NULL)

{
	InterlockedIncrement ( &CIPRouteEventProviderClassFactory::s_ObjectsInProgress ) ;

	InitializeCriticalSection ( &m_csEvent ) ;

	// Create a thread that will spin off an event loop

	NTSTATUS t_NtStatus = NtCreateEvent (

		&m_TerminationEventHandle,
        EVENT_ALL_ACCESS,
        NULL,
        SynchronizationEvent,
        FALSE
	) ;

	if (NT_SUCCESS(t_NtStatus))
	{
		m_hThreadHandle = CreateThread (

			NULL,						// pointer to security attributes
			0L,							// initial thread stack size
			dwThreadProc,				// pointer to thread function
			this,						// argument for new thread
			0L,							// creation flags
			&m_dwThreadID
		) ;
	}
}

//
CIPRouteEventProvider :: ~CIPRouteEventProvider ()
{
	LONG t_PreviousState = 0 ;

	if ( (m_hThreadHandle != INVALID_HANDLE_VALUE) && (m_TerminationEventHandle != INVALID_HANDLE_VALUE) )
	{
		//the worker thread should exit...
		NTSTATUS t_NtStatus = NtSetEvent (

			m_TerminationEventHandle ,
			& t_PreviousState
		) ;

		if (!NT_SUCCESS(t_NtStatus))
		{
			//fallback - next wait will fail and the thread should exit.
			m_TerminationEventHandle = INVALID_HANDLE_VALUE;
		}

		t_NtStatus = NtWaitForSingleObject ( m_hThreadHandle , FALSE, NULL ) ;
	}

   	DeleteCriticalSection ( &m_csEvent ) ;

	if ( m_pHandler )
	{
        m_pHandler->Release () ;
        m_pHandler = NULL ;
    }

	if ( m_pClass )
	{
        m_pClass->Release () ;
        m_pClass = NULL ;
    }

	InterlockedDecrement ( & CIPRouteEventProviderClassFactory::s_ObjectsInProgress ) ;
}

//
STDMETHODIMP_( ULONG ) CIPRouteEventProvider :: AddRef ()
{
	return InterlockedIncrement ( &m_ReferenceCount ) ;
}

//
STDMETHODIMP_(ULONG) CIPRouteEventProvider :: Release ()
{
	LONG t_ref ;
	if ( ( t_ref = InterlockedDecrement ( &m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ref ;
	}
}

//
STDMETHODIMP CIPRouteEventProvider :: QueryInterface (

	REFIID a_riid,
	void **a_ppv
)
{
	if ( NULL == a_ppv )
	{
		return E_INVALIDARG ;
	}
	else
	{
		*a_ppv = NULL ;
	}

    if( a_riid == IID_IWbemEventProvider )
    {
        *a_ppv = (IWbemEventProvider *)this ;
    }
	else if ( a_riid == IID_IWbemProviderInit )
	{
        *a_ppv = (IWbemProviderInit *) this ;
    }
	else if ( a_riid == IID_IUnknown )
	{
        *a_ppv = (IWbemProviderInit *) this ;
    }

	if (*a_ppv != NULL)
	{
		AddRef() ;
        return S_OK ;
	}
    else
	{
		return E_NOINTERFACE ;
	}
}

//
STDMETHODIMP CIPRouteEventProvider::Initialize (

	LPWSTR a_wszUser,
	long a_lFlags,
	LPWSTR a_wszNamespace,
	LPWSTR a_wszLocale,
	IWbemServices *a_pNamespace,
	IWbemContext *a_pCtx,
	IWbemProviderInitSink *a_pSink
)
{
	HRESULT t_hRes = WBEM_E_OUT_OF_MEMORY;

	if ( (m_hThreadHandle != INVALID_HANDLE_VALUE) && (m_TerminationEventHandle != INVALID_HANDLE_VALUE) )
	{
		IWbemClassObject *t_pEventClass = NULL;
		BSTR t_bstrClass = SysAllocString (IPROUTE_EVENT_CLASS);

		if (t_bstrClass)
		{
			t_hRes = a_pNamespace->GetObject (

				t_bstrClass,
				0,
				a_pCtx,
				&t_pEventClass,
				NULL
			) ;

			// ptr initialization routines
			if (SUCCEEDED(t_hRes))
			{
				SetClass ( t_pEventClass ) ;
			}

			SysFreeString ( t_bstrClass ) ;
		}
	}
	else
	{
		t_hRes = WBEM_E_FAILED;
	}

	a_pSink->SetStatus( t_hRes, 0 ) ;

    return t_hRes ;
}

//
STDMETHODIMP CIPRouteEventProvider::ProvideEvents (

	IWbemObjectSink *a_pSink,
	long a_lFlags
)
{
  	SetHandler( a_pSink ) ;

	return S_OK ;
}


void CIPRouteEventProvider::SetHandler( IWbemObjectSink __RPC_FAR *a_pHandler )
{
    EnterCriticalSection( &m_csEvent ) ;

    if ( m_pHandler )
	{
        m_pHandler->Release() ;
    }

	m_pHandler = a_pHandler ;
	if ( m_pHandler )
	{
		m_pHandler->AddRef() ;
	}

    LeaveCriticalSection( &m_csEvent ) ;
}

//
void CIPRouteEventProvider::SetClass ( IWbemClassObject *a_pClass )
{
    EnterCriticalSection( &m_csEvent ) ;

    if ( m_pClass )
	{
        m_pClass->Release() ;
    }

	m_pClass = a_pClass ;
	if ( m_pClass )
	{
		m_pClass->AddRef() ;
	}

    LeaveCriticalSection( &m_csEvent ) ;
}

// worker thread pump
DWORD WINAPI CIPRouteEventProvider :: dwThreadProc ( LPVOID a_lpParameter )
{
	CIPRouteEventProvider *t_pThis = ( CIPRouteEventProvider * ) a_lpParameter ;

	if ( t_pThis )
	{
		SmartCloseNtHandle t_StackHandle ;
		SmartCloseNtHandle t_CompleteEventHandle ;

		NTSTATUS t_NtStatus = t_pThis->OpenQuerySource (

			t_StackHandle ,
			t_CompleteEventHandle
		) ;

		BOOL t_Continue = TRUE ;

		while ( t_Continue && NT_SUCCESS ( t_NtStatus ) )
		{
			IO_STATUS_BLOCK t_IoStatusBlock ;

			t_NtStatus = NtDeviceIoControlFile (

				t_StackHandle,
				(HANDLE) t_CompleteEventHandle ,
				(PIO_APC_ROUTINE) NULL,
				(PVOID) NULL,
				&t_IoStatusBlock,
				IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
				NULL, // input buffer
				0,
				NULL ,    // output buffer
				0
			) ;

			if ( t_NtStatus == STATUS_PENDING )
			{
				HANDLE t_WaitArray [ 2 ] ;
				t_WaitArray [ 0 ] = (HANDLE)t_CompleteEventHandle ;
				t_WaitArray [ 1 ] = (HANDLE)t_pThis->m_TerminationEventHandle ;

				t_NtStatus = NtWaitForMultipleObjects (

					2 ,
					t_WaitArray ,
					WaitAny,
					FALSE ,
					NULL
				);

				switch ( t_NtStatus )
				{
					case STATUS_WAIT_0:
					{
					}
					break ;

					case STATUS_WAIT_1:
					{
						t_Continue = FALSE ;
					}
					break ;

					default:
					{
						t_Continue = FALSE ;
					}
					break ;
				}
			}
			else if ( t_NtStatus != STATUS_SUCCESS )
			{
			}
			else if ( t_IoStatusBlock.Status != STATUS_SUCCESS )
			{
			}

			if ( NT_SUCCESS ( t_NtStatus ) )
			{
				t_pThis->SendEvent () ;
			}
		}
	}

	return 0 ;
}

void CIPRouteEventProvider::SendEvent ()
{
	if( m_pClass && m_pHandler)
	{
		IWbemClassObject *t_pInst = NULL ;

		if( SUCCEEDED( m_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		{
			m_pHandler->Indicate ( 1, &t_pInst ) ;
		}

		t_pInst->Release() ;
	}
}

NTSTATUS CIPRouteEventProvider::OpenQuerySource (

	HANDLE &a_StackHandle ,
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_IP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_EXECUTE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) )
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
			a_StackHandle = INVALID_HANDLE_VALUE ;
		}
	}

	return t_NtStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <CIpRouteEvent.h>
#include <brodcast.h>

HMODULE ghModule ;

// {23b77e99-5c2d-482d-a795-62ca3ae5b673}
DEFINE_GUID(CLSID_CIPROUTETABLE,
0x23b77e99, 0x5c2d, 0x482d, 0xa7, 0x95, 0x62, 0xca, 0x3a, 0xe5, 0xb6, 0x73);


// {6D7A4B0E-66D5-4ac3-A7ED-0189E8CF5E77}
DEFINE_GUID(CLSID_CIPROUTETABLEEVENT,
0x6d7a4b0e, 0x66d5, 0x4ac3, 0xa7, 0xed, 0x1, 0x89, 0xe8, 0xcf, 0x5e, 0x77);

#define PROVIDER_NAME L"CIPROUTETABLE"

//Count number of objects and number of locks.
long g_cLock = 0 ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_CIPROUTETABLE == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else if( CLSID_CIPROUTETABLEEVENT == rclsid )
        {
            CIPRouteEventProviderClassFactory *lpunk = new CIPRouteEventProviderClassFactory ;
            if ( lpunk == NULL )
            {
                hr = E_OUTOFMEMORY ;
            }
            else
            {
                hr = lpunk->QueryInterface ( riid , ppv ) ;
                if ( FAILED ( hr ) )
                {
                    delete lpunk ;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    SCODE sc = S_FALSE;

    try
    {
        if (CIPRouteEventProviderClassFactory::DllCanUnloadNow())
        {
            sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM IP Route Provider"), CLSID_CIPROUTETABLE ) ;
        if( NOERROR == t_status )
        {
            t_status = RegisterServer( _T("WBEM IP Route Event Provider"), CLSID_CIPROUTETABLEEVENT ) ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CIPROUTETABLE ) ;
        if( NOERROR == t_status )
        {
            t_status = UnregisterServer( CLSID_CIPROUTETABLEEVENT ) ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;
    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet ;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\thrdlog\include\provval.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-----------------------------------------------------------------
Filename: value.hpp
Purpose	: To specify the classes of various Prov values and instance
		  identifiers. These classes represent the different types of 
		  values for variables that may populate a MIB. 
Written By:	B.Rajeev
-----------------------------------------------------------------*/


#ifndef __VALUE__
#define __VALUE__

/*-----------------------------------------------------------------
General Overview:
	A variable instance refers to a MIB object, e.g. 
	1.3.6.1.2.1.1.1.0 or 1.3.6.1.2.1.2.1.2.1. The instance is 
	encoded as an Prov object identifier and is represented by the 
	class ProvObjectIdentifier. 

  The classes derived from ProvValue represent the encoding of the 
  information stored within the MIB object. The value is encoded 
  as an implementation of the abstract class ProvValue. The Prov 
  class library implements the following derivations of ProvValue 
  which refer to Prov BER encoded types.

		ProvNull
		ProvInteger
		ProvCounter32
		ProvCounter64
		ProvGauge
		ProvTimeTicks
		ProvIPAddress
		ProvNetworkAddress
		ProvBitString
		ProvOctetString
		ProvOpaque
		ProvObjectIdentifier

  All the implemented classes provide (in addition to others) -
  1. Constructors to initialize using relevant values or another
	instance of the same class.

  2. GetValue, SetValue methods for obtaining and setting
	relevant values.

  3. "=" operator to over-ride the default assignment operator and
	 an Equivalent method to check for equivalence between two instances
	 of the same (derived) class

  4. Copy methods for obtaining a copy of a specified instance of
	the class.


  note of caution:
  ----------------
		Some of the GetValue functions return pointers
  to dynamically allocated data. Users of the class must make copies
  of the returned values and must not rely on the integrity of this
  pointer or values obtained through it in future (because of 
  SetValue methods, or destruction of corresponding ProvValue class) 
-----------------------------------------------------------------*/

#include <provimex.h>
#include <provexpt.h>

// Abstract class at the root of all Prov Values

// maximum length of decimal dot notation addresses
#define MAX_ADDRESS_LEN			100

// end of string character
#define EOS '\0'

#define MIN(a,b) ((a<=b)?a:b)

#define BETWEEN(i, min, max) ( ((i>=min)&&(i<max))?TRUE:FALSE )

#define MAX_FIELDS 100
#define FIELD_SEPARATOR '.'
#define PROV_IP_ADDR_LEN 4

class DllImportExport ProvValue 
{
	// the "=" operator and the copy constructor have been
	// made private to prevent copies of the ProvValue instance
	// from being made
	ProvValue &operator=(IN const ProvValue &) 
	{
		return *this;
	}

	ProvValue(IN const ProvValue &Prov_value) {}

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const = 0;
	ProvValue() {}

public:

	virtual ProvValue *Copy () const = 0 ;

	BOOL operator==(IN const ProvValue &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const ProvValue &value) const
	{
		return !((*this) == value) ;
	}

	virtual ~ProvValue() {}
} ;


// Enables null values for required variables. Its a concrete class
// with dummy constructor and destructors to enable specification of
// null values
class DllImportExport ProvNull : public ProvValue
{
protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	// dummy constructor and destructor
	ProvNull() {}

	~ProvNull() {}

	ProvValue &operator=(IN const ProvNull &to_copy) 
	{
		return *this;
	}

	ProvValue *Copy() const { return new ProvNull; }
};


// Allows integer values to be specified
class DllImportExport ProvInteger : public ProvValue 
{
private:

	LONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvInteger ( IN const LONG value ) : val(value) {}
	ProvInteger ( IN const ProvInteger &value );

	~ProvInteger () {}

	LONG GetValue () const;

	void SetValue ( IN const LONG value );

	ProvValue &operator=(IN const ProvInteger &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvInteger &Prov_integer)	const
	{
		if ( val == Prov_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

	ProvValue *Copy () const;
} ;

// Encapsulates gauge value
class DllImportExport ProvGauge : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvGauge ( IN const LONG value ) : val(value) {}
	ProvGauge ( IN const ProvGauge &value );
	~ProvGauge () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvGauge &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvGauge &Prov_gauge)	const
	{
		if ( val == Prov_gauge.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Counter values
class DllImportExport ProvCounter : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvCounter ( IN const ULONG value ) : val(value) {}
	ProvCounter ( IN const ProvCounter &value );

	~ProvCounter () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvCounter &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvCounter &Prov_counter)	const
	{
		if ( val == Prov_counter.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Time Ticks (since an earlier event)
class DllImportExport ProvTimeTicks : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvTimeTicks ( IN const ULONG value ) : val(value) {}
	ProvTimeTicks ( IN const ProvTimeTicks &value );

	~ProvTimeTicks () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvTimeTicks &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvTimeTicks &Prov_time_ticks) const
	{
		if ( val == Prov_time_ticks.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates octet strings that do not have any terminator.
// The octet string is specified by the pair (val,length) where
// 'val' is a pointer to heap data and 'length' provides the number
// of octets in the data string.
class DllImportExport ProvOctetString : public ProvValue
{
private:

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const UCHAR *value);

protected:

	BOOL is_valid;
	UCHAR *val;
	ULONG length;

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;
	virtual void Initialize(IN const UCHAR *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual UCHAR *Replicate(IN const UCHAR *value, IN const ULONG valueLength);

	virtual void UnReplicate(UCHAR *value);

public:

	ProvOctetString ( IN const UCHAR *value , IN const ULONG valueLength );

	ProvOctetString ( IN const ProvOctetString &value );

	~ProvOctetString ();

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	UCHAR *GetValue () const;

	ProvValue *Copy () const;


	ProvValue &operator=(IN const ProvOctetString &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const ProvOctetString &Prov_octet_string) const;
} ;

// OpaqueValue class encapsulates octet strings
class DllImportExport ProvOpaque : public ProvValue
{
private:
	ProvOctetString *octet_string;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvOpaque ( IN const UCHAR *value , IN const ULONG valueLength ) : octet_string ( NULL )
	{
		octet_string = new ProvOctetString(value, valueLength);
	}

	ProvOpaque ( IN const ProvOpaque &value ) : octet_string ( NULL )
	{
		octet_string = new ProvOctetString(value.GetValue(), value.GetValueLength());
	}
	
	~ProvOpaque()
	{
		delete octet_string;
	}

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
	{
		octet_string->SetValue(value, valueLength);
	}

	ULONG GetValueLength () const
	{
		return octet_string->GetValueLength();
	}

	UCHAR *GetValue () const
	{
		return octet_string->GetValue();
	}


	ProvValue &operator=(IN const ProvOpaque &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	ProvValue *Copy () const
	{
		return new ProvOpaque(octet_string->GetValue(),
							  octet_string->GetValueLength());
	}

	void * operator()(void) const
	{
		return (*octet_string)();
	}


	BOOL Equivalent(IN const ProvOpaque &Prov_opaque) const
	{
		return octet_string->Equivalent(*(Prov_opaque.octet_string));
	}
};

#define DEFAULT_OBJECTIDENTIFIER_LENGTH 32

// Encapsulates the object identifier. An object identifier 
// identifies a MIB object instance
class DllImportExport ProvObjectIdentifier : public ProvValue
{
	
	// describes the legal values for a comparison
	enum Comparison {LESS_THAN, EQUAL_TO, GREATER_THAN};

private:

	BOOL is_valid;
	ULONG m_value[DEFAULT_OBJECTIDENTIFIER_LENGTH];
	ULONG *val;
	ULONG length;

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const ULONG *value);

protected:
	
	virtual BOOL Equivalent(IN const ProvValue &value)	const ;
	virtual void Initialize(IN const ULONG *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual ULONG *Replicate(IN const ULONG *value, IN const ULONG valueLength) const;

	// Allocates enough memory to copy the first value followed by
	// the second value to be copied, thus, appending the two values
	virtual ULONG *Replicate(IN const ULONG *first_value, IN const ULONG first_length,
							 IN const ULONG *second_value, IN const ULONG second_length) const;

	virtual void UnReplicate(ULONG *value);

	// This single function
	Comparison Compare(IN const ProvObjectIdentifier &first, 
					   IN const ProvObjectIdentifier &second) const;

	BOOL Equivalent(IN const ProvObjectIdentifier &value) const;

public:

	ProvObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength );

	ProvObjectIdentifier ( IN const char *value );

	ProvObjectIdentifier ( IN const ProvObjectIdentifier &value );

	~ProvObjectIdentifier ();

	void SetValue ( IN const ULONG *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	ULONG *GetValue () const;

	ProvValue *Copy () const;

	BOOL Equivalent(IN const ProvObjectIdentifier &value,
					 IN ULONG max_length) const;
	
	BOOL operator<(IN const ProvObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == LESS_THAN)?TRUE:FALSE;

	}

	BOOL operator>(IN const ProvObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == GREATER_THAN)?TRUE:FALSE;
	}

	BOOL operator<=(IN const ProvObjectIdentifier &value) const
	{
		return !(*this > value);
	}

	BOOL operator>=(IN const ProvObjectIdentifier &value) const
	{
		return !(*this < value);
	}

	BOOL operator==(IN const ProvObjectIdentifier &value) const
	{
		if ( this->GetValueLength() == value.GetValueLength() )
			return Equivalent(value) ;
		else
			return FALSE;
	}

	BOOL operator!=(IN const ProvObjectIdentifier &value) const
	{
		return !(*this == value);
	}
	
	ProvObjectIdentifier operator+ ( IN const ProvObjectIdentifier &value ) const;

	BOOL Prefix( IN ULONG index, ProvObjectIdentifier &prefix ) const
	{
		if ( index >= length )
			return FALSE;
		
		prefix.UnReplicate (val) ;
		prefix.Initialize (val, index+1) ;
		return TRUE ;
	}

	BOOL Suffix ( IN ULONG index , ProvObjectIdentifier &suffix ) const
	{
		if ( index >= length )
			return FALSE;

		suffix.UnReplicate (val) ;
		suffix.Initialize ( val+index, length-index ) ;
		return TRUE ;
	}

	ProvObjectIdentifier *Cut (ProvObjectIdentifier &value) const;


	ULONG &operator [] ( IN const ULONG index ) const;


	ProvValue &operator=(IN const ProvObjectIdentifier &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	char *GetAllocatedString() const;
} ;


// encapsulates an ip address. represents the 32 bit value in a ULONG
class DllImportExport ProvIpAddress : public ProvValue 
{
private:

	// if the dotted decimal representation passed to the constructor
	// is ill-formed, the instance may be invalid
	BOOL is_valid;
	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvIpAddress ( IN const ULONG value )
		:val(value), is_valid(TRUE)
	{}

	// a dotted decimal representation is parsed to obtain the 32 bit value
	ProvIpAddress ( IN const char *value ) ;

	ProvIpAddress ( IN const ProvIpAddress &value );

	~ProvIpAddress () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvIpAddress &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const ProvIpAddress &Prov_ip_address) const
	{
		if ( is_valid && Prov_ip_address() )
			return ( val == Prov_ip_address.GetValue() );
		else
			return FALSE;
	}

} ;

// Encapsulates UInteger32 value
class DllImportExport ProvUInteger32 : public ProvValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvUInteger32 ( IN const LONG value ) : val(value) {}
	ProvUInteger32 ( IN const ProvUInteger32 &value );
	~ProvUInteger32 () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvUInteger32 &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvUInteger32 &Prov_integer)	const
	{
		if ( val == Prov_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}
} ;


// Encapsulates Counter64 values
class DllImportExport ProvCounter64 : public ProvValue 
{
private:

	ULONG lval;
	ULONG hval;

protected:

	virtual BOOL Equivalent(IN const ProvValue &value)	const ;

public:

	ProvCounter64 ( IN const ULONG lvalue , IN const ULONG hvalue ) : lval(lvalue),hval(hvalue) {}
	ProvCounter64 ( IN const ProvCounter64 &value );

	~ProvCounter64 () {}

	ULONG GetLowValue () const;
	ULONG GetHighValue () const;

	void SetValue ( IN const ULONG lvalue , IN const ULONG hvalue );

	ProvValue *Copy () const;

	ProvValue &operator=(IN const ProvCounter64 &to_copy) 
	{
		SetValue(to_copy.GetLowValue(),to_copy.GetHighValue());
		return *this;
	}

	BOOL Equivalent(IN const ProvCounter64 &Prov_counter )	const
	{
		if ( ( lval == Prov_counter.GetLowValue() ) && ( hval == Prov_counter.GetHighValue() ) )
			return TRUE;
		else
			return FALSE;
	}

} ;



#endif // __VALUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjioactgprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjIOActgProps.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************
#define IDS_Win32_JobObjectIOAccountingInfo L"Win32_NamedJobObjectActgInfo"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_JOIOActgID                             0x00000001
#define PROP_TotalUserTime                          0x00000002
#define PROP_TotalKernelTime                        0x00000004
#define PROP_ThisPeriodTotalUserTime                0x00000008
#define PROP_ThisPeriodTotalKernelTime              0x00000010
#define PROP_TotalPageFaultCount                    0x00000020
#define PROP_TotalProcesses                         0x00000040
#define PROP_ActiveProcesses                        0x00000080
#define PROP_TotalTerminatedProcesses               0x00000100
#define PROP_ReadOperationCount                     0x00000200
#define PROP_WriteOperationCount                    0x00000400
#define PROP_OtherOperationCount                    0x00000800
#define PROP_ReadTransferCount                      0x00001000
#define PROP_WriteTransferCount                     0x00002000
#define PROP_OtherTransferCount                     0x00004000
#define PROP_PeakProcessMemoryUsed                  0x00010000
#define PROP_PeakJobMemoryUsed                      0x00020000



// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_IOACTG_PROPS
{
    JOIOACTGPROP_ID = 0,
    JOIOACTGPROP_TotalUserTime,
    JOIOACTGPROP_TotalKernelTime,
    JOIOACTGPROP_ThisPeriodTotalUserTime,    
    JOIOACTGPROP_ThisPeriodTotalKernelTime,  
    JOIOACTGPROP_TotalPageFaultCount,        
    JOIOACTGPROP_TotalProcesses,             
    JOIOACTGPROP_ActiveProcesses,            
    JOIOACTGPROP_TotalTerminatedProcesses,   
    JOIOACTGPROP_ReadOperationCount,         
    JOIOACTGPROP_WriteOperationCount,        
    JOIOACTGPROP_OtherOperationCount,        
    JOIOACTGPROP_ReadTransferCount,          
    JOIOACTGPROP_WriteTransferCount,         
    JOIOACTGPROP_OtherTransferCount,
    JOIOACTGPROP_PeakProcessMemoryUsed,          
    JOIOACTGPROP_PeakJobMemoryUsed,         
         

    // used to keep track of how many props we have:
    JOIOACTGPROP_JobObjIOActgPropertyCount  

} JOB_OBJ_IOACTG_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjIOActgPropNames[];
//*****************************************************************************
// END: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************



class CJobObjIOActgProps : public CObjProps
{
public:
    CJobObjIOActgProps() { m_hJob = NULL; }
    CJobObjIOActgProps(CHString& chstrNamespace);
    CJobObjIOActgProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjIOActgProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

private:
    HANDLE m_hJob;

    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjioactgprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjIOActgProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjIOActgProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjIOActgInfo class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjIOActgPropNames[] = 
{
    { L"Name" },
    { L"TotalUserTime" },             
    { L"TotalKernelTime" },           
    { L"ThisPeriodTotalUserTime" },   
    { L"ThisPeriodTotalKernelTime" }, 
    { L"TotalPageFaultCount" },       
    { L"TotalProcesses" },            
    { L"ActiveProcesses" },           
    { L"TotalTerminatedProcesses" },  
    { L"ReadOperationCount" },        
    { L"WriteOperationCount" },       
    { L"OtherOperationCount" },       
    { L"ReadTransferCount" },         
    { L"WriteTransferCount" },        
    { L"OtherTransferCount" },
    { L"PeakProcessMemoryUsed" },        
    { L"PeakJobMemoryUsed" }        
        
};
//*****************************************************************************
// END: Declaration of Win32_JobObjIOActgInfo class properties.
//*****************************************************************************



CJobObjIOActgProps::CJobObjIOActgProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace)
{
}


CJobObjIOActgProps::CJobObjIOActgProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob)
{
}

CJobObjIOActgProps::~CJobObjIOActgProps()
{
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjIOActgProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjIOActgProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID])) 
        dwReqProps |= PROP_JOIOActgID;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalUserTime])) 
        dwReqProps |= PROP_TotalUserTime;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalKernelTime])) 
        dwReqProps |= PROP_TotalKernelTime;
    
    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ThisPeriodTotalUserTime])) 
        dwReqProps |= PROP_ThisPeriodTotalUserTime;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ThisPeriodTotalKernelTime])) 
        dwReqProps |= PROP_ThisPeriodTotalKernelTime;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalPageFaultCount])) 
        dwReqProps |= PROP_TotalPageFaultCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalProcesses])) 
        dwReqProps |= PROP_TotalProcesses;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ActiveProcesses])) 
        dwReqProps |= PROP_ActiveProcesses;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_TotalTerminatedProcesses])) 
        dwReqProps |= PROP_TotalTerminatedProcesses;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ReadOperationCount])) 
        dwReqProps |= PROP_ReadOperationCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_WriteOperationCount])) 
        dwReqProps |= PROP_WriteOperationCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_OtherOperationCount])) 
        dwReqProps |= PROP_OtherOperationCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ReadTransferCount])) 
        dwReqProps |= PROP_ReadTransferCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_WriteTransferCount])) 
        dwReqProps |= PROP_WriteTransferCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_OtherTransferCount])) 
        dwReqProps |= PROP_OtherTransferCount;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_PeakProcessMemoryUsed])) 
        dwReqProps |= PROP_PeakProcessMemoryUsed;

    if (Query.IsPropertyRequired(g_rgJobObjIOActgPropNames[JOIOACTGPROP_PeakJobMemoryUsed])) 
        dwReqProps |= PROP_PeakJobMemoryUsed;


    return dwReqProps;
}


void CJobObjIOActgProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjIOActgProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjIOActgProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JOIOACTGPROP_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_JobObjectIOAccountingInfo,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjIOActgProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JOIOACTGPROP_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjIOActgProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();
    _ASSERT(m_hJob);
    if(!m_hJob) return WBEM_E_INVALID_PARAMETER;

    // Because all the properties of this class
    // come from the same underlying win32 job
    // object structure, we only need to get that
    // structure one time.  We only need to get
    // it at all if at least one non-key property
    // was requested.
    if(dwReqProps != PROP_NONE_REQUIRED)
    {
        // Get the value from the underlying JO:
        JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION  jobaioai;
        JOBOBJECT_EXTENDED_LIMIT_INFORMATION joeli;

        BOOL fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectBasicAndIoAccountingInformation,
                         &jobaioai,
                         sizeof(JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
                         NULL);

        if(fQIJO)
        {
            fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectExtendedLimitInformation,
                         &joeli,
                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                         NULL);
        }

        if(!fQIJO)
        {
            _ASSERT(0);
            hr = WBEM_E_FAILED;
        }
        else
        {                                                           
            try // CVARIANT can throw
            {
                // Get all the requested values...
                if(dwReqProps & PROP_TotalUserTime)
                {
                    ULONGLONG llTotalUserTime = (ULONGLONG)jobaioai.BasicInfo.TotalUserTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalUserTime, 
                                     new CVARIANT(llTotalUserTime)));
                }                      

                if(dwReqProps & PROP_TotalKernelTime)
                {
                    ULONGLONG llTotalKernelTime = (ULONGLONG)jobaioai.BasicInfo.TotalKernelTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalKernelTime, 
                                     new CVARIANT(llTotalKernelTime)));
                }

                if(dwReqProps & PROP_ThisPeriodTotalUserTime)
                {
                    ULONGLONG llThisPeriodTotalUserTime = (ULONGLONG)jobaioai.BasicInfo.ThisPeriodTotalUserTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ThisPeriodTotalUserTime, 
                                     new CVARIANT(llThisPeriodTotalUserTime)));
                }

                if(dwReqProps & PROP_ThisPeriodTotalKernelTime)
                {
                    ULONGLONG llThisPeriodTotalKernelTime = (ULONGLONG)jobaioai.BasicInfo.ThisPeriodTotalKernelTime.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ThisPeriodTotalKernelTime, 
                                     new CVARIANT(llThisPeriodTotalKernelTime)));
                }

                if(dwReqProps & PROP_TotalPageFaultCount)
                {
                    DWORD dwTotalPageFaultCount = jobaioai.BasicInfo.TotalPageFaultCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalPageFaultCount, 
                                     new CVARIANT(dwTotalPageFaultCount)));
                }

                if(dwReqProps & PROP_TotalProcesses)
                {
                    DWORD dwTotalProcesses = jobaioai.BasicInfo.TotalProcesses;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalProcesses, 
                                     new CVARIANT(dwTotalProcesses)));
                }

                if(dwReqProps & PROP_ActiveProcesses)
                {
                    DWORD dwActiveProcesses = jobaioai.BasicInfo.ActiveProcesses;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ActiveProcesses, 
                                     new CVARIANT(dwActiveProcesses)));
                }

                if(dwReqProps & PROP_TotalTerminatedProcesses)
                {
                    DWORD dwTotalTerminatedProcesses = jobaioai.BasicInfo.TotalTerminatedProcesses;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_TotalTerminatedProcesses, 
                                     new CVARIANT(dwTotalTerminatedProcesses)));
                }

                if(dwReqProps & PROP_ReadOperationCount)
                {
                    ULONGLONG ullReadOperationCount = jobaioai.IoInfo.ReadOperationCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ReadOperationCount, 
                                     new CVARIANT(ullReadOperationCount)));
                }

                if(dwReqProps & PROP_WriteOperationCount)
                {
                    ULONGLONG ullWriteOperationCount = jobaioai.IoInfo.WriteOperationCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_WriteOperationCount, 
                                     new CVARIANT(ullWriteOperationCount)));
                }

                if(dwReqProps & PROP_OtherOperationCount)
                {
                    ULONGLONG ullOtherOperationCount = jobaioai.IoInfo.OtherOperationCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_OtherOperationCount, 
                                     new CVARIANT(ullOtherOperationCount)));
                }

                if(dwReqProps & PROP_ReadTransferCount)
                {
                    ULONGLONG ullReadTransferCount = jobaioai.IoInfo.ReadTransferCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_ReadTransferCount, 
                                     new CVARIANT(ullReadTransferCount)));
                }

                if(dwReqProps & PROP_WriteTransferCount)
                {
                    ULONGLONG ullWriteTransferCount = jobaioai.IoInfo.WriteTransferCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_WriteTransferCount, 
                                     new CVARIANT(ullWriteTransferCount)));
                }

                if(dwReqProps & PROP_OtherTransferCount)
                {
                    ULONGLONG ullOtherTransferCount = jobaioai.IoInfo.OtherTransferCount;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_OtherTransferCount, 
                                     new CVARIANT(ullOtherTransferCount)));
                }

                if(dwReqProps & PROP_PeakProcessMemoryUsed)
                {
                    DWORD dwPeakProcessMemoryUsed = joeli.PeakProcessMemoryUsed;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_PeakProcessMemoryUsed, 
                                     new CVARIANT(dwPeakProcessMemoryUsed)));
                }

                if(dwReqProps & PROP_PeakJobMemoryUsed)
                {
                    DWORD dwPeakJobMemoryUsed = joeli.PeakJobMemoryUsed;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOIOACTGPROP_PeakJobMemoryUsed, 
                                     new CVARIANT(dwPeakJobMemoryUsed)));
                }
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }                                            
    }
    
    return hr;
}



HRESULT CJobObjIOActgProps::LoadPropertyValues(
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjIOActgPropNames,
             pIWCO);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\inc\cippersistedrtble.h ===
/******************************************************************

   CIPPersistedRTble.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _CIPPersistedRTble_H_
#define _CIPPersistedRTble_H_

#define PROVIDER_NAME_CIPPERSISTEDROUTETABLE L"Win32_IP4PersistedRouteTable"

class CIPPersistedRouteTable : public Provider
{
private:

protected:

		HRESULT ExecMethod (

			const CInstance &Instance,
			const BSTR bstrMethodName,
			CInstance *pInParams,
			CInstance *pOutParams,
			long lFlags
		);

        // Writing Functions
        //============================

		HRESULT DeleteInstance (

			const CInstance &Instance,
			long lFlags
		);

		HRESULT CIPPersistedRouteTable :: PutInstance  (

			const CInstance &Instance,
			long lFlags
		);

        // Reading Functions
        //============================

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags = 0L
		) ;


        // Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================
		HRESULT CheckParameters (

			const CInstance &a_Instance ,
			CHString &a_ValueName
		);

		BOOL CIPPersistedRouteTable :: Parse (

			LPWSTR a_InStr ,
			CHString &a_Dest ,
			CHString &a_Mask ,
			CHString &a_NextHop ,
			long &a_Metric
		);

		void SetInheritedProperties (

			LPCWSTR a_dest ,
			LPCWSTR a_gateway ,
			LPCWSTR a_mask ,
			long a_metric ,
			CInstance &a_Instance
		) ;

public:

        // Constructor/destructor
        //=======================

        CIPPersistedRouteTable (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CIPPersistedRouteTable () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\inc\ciproutetable.h ===
/******************************************************************

   CIPRouteTable.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _CIPRouteTable_H_
#define _CIPRouteTable_H_

#define PROVIDER_NAME_CIPROUTETABLE L"Win32_IP4RouteTable"


class CIPRouteTable : public Provider , public QueryPreprocessor 
{
private:
        // All data members for CIPRouteTable should be included here.
	CInstance *m_ClassCInst;
	CRITICAL_SECTION m_CS;

	NTSTATUS DeleteInformation_IpRouteInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		IPRouteEntry &a_RouteEntry 
	) ;

	NTSTATUS SetInformation_IpRouteInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		IPRouteEntry &a_RouteEntry 
	) ;

	HRESULT CheckParameters ( 

		const CInstance &a_Instance ,
		IPRouteEntry &a_RouteEntry 
	) ;

	HRESULT QueryInformation_GetRouteEntry ( 

		const ProvIpAddressType &a_DestinationIpAddress ,
		const ProvIpAddressType &a_NextHopIpAddress ,
		IPRouteEntry &a_RouteEntry 
	) ;

	NTSTATUS QueryInformation_IpRouteInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		ulong &a_RouteTableSize ,
		IPRouteEntry *&a_InformationBlock 
	) ;
 
	HRESULT QueryInformation_IpSnmpInfo ( 

		HANDLE a_StackHandle , 
		HANDLE a_CompleteEventHandle ,
		IPSNMPInfo &a_Information 
	) ;

	NTSTATUS OpenQuerySource ( 

		HANDLE &a_StackHandle , 
		HANDLE &a_CompleteEventHandle
	) ;

	NTSTATUS OpenSetSource ( 

		HANDLE &a_StackHandle , 
		HANDLE &a_CompleteEventHandle
	) ;

	void SetInheritedProperties (

		LPCWSTR a_dest ,
		LPCWSTR a_gateway ,
		LPCWSTR a_mask ,
		CInstance &a_Instance
	) ;

private:


	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

protected:

        // Reading Functions
        //============================

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags = 0L
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0L
		) ;

        HRESULT RangeQuery ( 

			MethodContext *pMethodContext, 
			PartitionSet &a_PartitionSet ,
			long lFlags = 0L
		) ;

        // Writing Functions
        //============================

        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

        HRESULT DeleteInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

        // Method Function

        HRESULT ExecMethod ( 

			const CInstance& Instance,
            const BSTR bstrMethodName,
            CInstance *pInParams,
            CInstance *pOutParams,
            long lFlags = 0L
		) ;

		WmiTreeNode *AllocTypeNode ( 

			void *a_Context ,
			BSTR a_PropertyName , 
			VARIANT &a_Variant , 
			WmiValueNode :: WmiValueFunction a_PropertyFunction ,
			WmiValueNode :: WmiValueFunction a_ConstantFunction ,
			WmiTreeNode *a_Parent 
		) ;

		QuadState InvariantEvaluate ( 

			void *a_Context ,
			WmiTreeNode *a_Operator ,
			WmiTreeNode *a_Operand 
		) ;

		WmiRangeNode *AllocInfiniteRangeNode (

			void *a_Context ,
			BSTR a_PropertyName 
		) ;

		HRESULT GetClassObject ( CInstance *&a_ClassObject, MethodContext *pContext ) ;

		virtual DWORD GetPriority ( BSTR a_PropertyName ) ;

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

public:

        // Constructor/destructor
        //=======================

        CIPRouteTable (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CIPRouteTable () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjlimitinfoprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjLimitInfoProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjLimitInfoProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjLimitInfoPropNames[] = 
{
    { L"SettingID" },
    { L"PerProcessUserTimeLimit" },             
    { L"PerJobUserTimeLimit" },           
    { L"LimitFlags" },   
    { L"MinimumWorkingSetSize" }, 
    { L"MaximumWorkingSetSize" },       
    { L"ActiveProcessLimit" },            
    { L"Affinity" },           
    { L"PriorityClass" },  
    { L"SchedulingClass" },        
    { L"ProcessMemoryLimit" },       
    { L"JobMemoryLimit" }       
};
//*****************************************************************************
// END: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************



CJobObjLimitInfoProps::CJobObjLimitInfoProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace)
{
}


CJobObjLimitInfoProps::CJobObjLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob)
{
}

CJobObjLimitInfoProps::~CJobObjLimitInfoProps()
{
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjLimitInfoProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjLimitInfoProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID])) 
        dwReqProps |= PROP_JOLimitInfoID;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerProcessUserTimeLimit])) 
        dwReqProps |= PROP_PerProcessUserTimeLimit;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerJobUserTimeLimit])) 
        dwReqProps |= PROP_PerJobUserTimeLimit;
    
    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_LimitFlags])) 
        dwReqProps |= PROP_LimitFlags;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_MinimumWorkingSetSize])) 
        dwReqProps |= PROP_MinimumWorkingSetSize;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_MaximumWorkingSetSize])) 
        dwReqProps |= PROP_MaximumWorkingSetSize;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ActiveProcessLimit])) 
        dwReqProps |= PROP_ActiveProcessLimit;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_Affinity])) 
        dwReqProps |= PROP_Affinity;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_PriorityClass])) 
        dwReqProps |= PROP_PriorityClass;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_SchedulingClass])) 
        dwReqProps |= PROP_SchedulingClass;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ProcessMemoryLimit])) 
        dwReqProps |= PROP_ProcessMemoryLimit;

    if (Query.IsPropertyRequired(g_rgJobObjLimitInfoPropNames[JOLMTPROP_JobMemoryLimit])) 
        dwReqProps |= PROP_JobMemoryLimit;


    return dwReqProps;
}


void CJobObjLimitInfoProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjLimitInfoProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjLimitInfoProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JOLMTPROP_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_NamedJobObjectLimitSetting,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjLimitInfoProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JOLMTPROP_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjLimitInfoProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();
    _ASSERT(m_hJob);
    if(!m_hJob) return WBEM_E_INVALID_PARAMETER;

    // Because all the properties of this class
    // come from the same underlying win32 job
    // object structure, we only need to get that
    // structure one time.  We only need to get
    // it at all if at least one non-key property
    // was requested.
    if(dwReqProps != PROP_NONE_REQUIRED)
    {
        // Get the value from the underlying JO:
        JOBOBJECT_EXTENDED_LIMIT_INFORMATION joeli;

        BOOL fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectExtendedLimitInformation,
                         &joeli,
                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                         NULL);

        if(!fQIJO)
        {
            _ASSERT(0);
            hr = WBEM_E_FAILED;
        }
        else
        {                                                           
            try // CVARIANT can throw
            {
                // Get all the reequested values...
                if(dwReqProps & PROP_PerProcessUserTimeLimit)             
                {
                    ULONGLONG llPerProcessUserTimeLimit = (ULONGLONG)joeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_PerProcessUserTimeLimit, 
                                     new CVARIANT(llPerProcessUserTimeLimit)));
                }                      

                if(dwReqProps & PROP_PerJobUserTimeLimit)
                {
                    ULONGLONG llPerJobUserTimeLimit = (ULONGLONG)joeli.BasicLimitInformation.PerJobUserTimeLimit.QuadPart;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_PerJobUserTimeLimit, 
                                     new CVARIANT(llPerJobUserTimeLimit)));
                }

                if(dwReqProps & PROP_LimitFlags)
                {
                    DWORD dwLimitFlags = joeli.BasicLimitInformation.LimitFlags;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_LimitFlags, 
                                     new CVARIANT(dwLimitFlags)));
                }

                if(dwReqProps & PROP_MinimumWorkingSetSize)
                {
                    DWORD dwMinimumWorkingSetSize = joeli.BasicLimitInformation.MinimumWorkingSetSize;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_MinimumWorkingSetSize, 
                                     new CVARIANT(dwMinimumWorkingSetSize)));
                }

                if(dwReqProps & PROP_MaximumWorkingSetSize)
                {
                    DWORD dwMaximumWorkingSetSize = joeli.BasicLimitInformation.MaximumWorkingSetSize;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_MaximumWorkingSetSize, 
                                     new CVARIANT(dwMaximumWorkingSetSize)));
                }

                if(dwReqProps & PROP_ActiveProcessLimit)
                {
                    DWORD dwActiveProcessLimit = joeli.BasicLimitInformation.ActiveProcessLimit;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_ActiveProcessLimit, 
                                     new CVARIANT(dwActiveProcessLimit)));
                }

                if(dwReqProps & PROP_Affinity)
                {
                    DWORD dwAffinity = joeli.BasicLimitInformation.Affinity;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_Affinity, 
                                     new CVARIANT(dwAffinity)));
                }

                if(dwReqProps & PROP_PriorityClass)
                {
                    DWORD dwPriorityClass = joeli.BasicLimitInformation.PriorityClass;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_PriorityClass, 
                                     new CVARIANT(dwPriorityClass)));
                }

                if(dwReqProps & PROP_SchedulingClass)
                {
                    DWORD dwSchedulingClass = joeli.BasicLimitInformation.SchedulingClass;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_SchedulingClass, 
                                     new CVARIANT(dwSchedulingClass)));
                }

                if(dwReqProps & PROP_ProcessMemoryLimit)
                {
                    DWORD dwProcessMemoryLimit = joeli.ProcessMemoryLimit ;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_ProcessMemoryLimit, 
                                     new CVARIANT(dwProcessMemoryLimit)));
                }

                if(dwReqProps & PROP_JobMemoryLimit)
                {
                    DWORD dwJobMemoryLimit = joeli.JobMemoryLimit ;
                    m_PropMap.insert(SHORT2PVARIANT::value_type(
                                     JOLMTPROP_JobMemoryLimit, 
                                     new CVARIANT(dwJobMemoryLimit)));
                }
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }                                            
    }
    
    return hr;
}


// Used by PutInstance to write out properties.
HRESULT CJobObjLimitInfoProps::SetWin32JOLimitInfoProps(
        IWbemClassObject __RPC_FAR *pInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _ASSERT(pInst);
    if(!pInst) return WBEM_E_INVALID_PARAMETER;

    // Go through the instance and extract all
    // specified values into the win32 structure.
    // If a value was not specified, set it to zero.
    CVARIANT v;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION joeli;
    ::ZeroMemory(&joeli, sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));

    hr = pInst->Get(
             g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerProcessUserTimeLimit],
             0,
             &v,
             NULL, 
             NULL);

    if(SUCCEEDED(hr))
    {
        (V_VT(&v) == VT_BSTR) ? 
            joeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = _wtoi64(V_BSTR(&v)) :
            joeli.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = 0;
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_PerJobUserTimeLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_BSTR) ? 
                joeli.BasicLimitInformation.PerJobUserTimeLimit.QuadPart = _wtoi64(V_BSTR(&v)) :
                joeli.BasicLimitInformation.PerJobUserTimeLimit.QuadPart = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_LimitFlags],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.LimitFlags = V_I4(&v) :
                joeli.BasicLimitInformation.LimitFlags = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_MinimumWorkingSetSize],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.MinimumWorkingSetSize = V_I4(&v) :
                joeli.BasicLimitInformation.MinimumWorkingSetSize = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_MaximumWorkingSetSize],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.MaximumWorkingSetSize = V_I4(&v) :
                joeli.BasicLimitInformation.MaximumWorkingSetSize = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_ActiveProcessLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.ActiveProcessLimit = V_I4(&v) :
                joeli.BasicLimitInformation.ActiveProcessLimit = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_Affinity],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.Affinity = V_I4(&v) :
                joeli.BasicLimitInformation.Affinity = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_PriorityClass],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.PriorityClass = V_I4(&v) :
                joeli.BasicLimitInformation.PriorityClass = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_SchedulingClass],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.BasicLimitInformation.SchedulingClass = V_I4(&v) :
                joeli.BasicLimitInformation.SchedulingClass = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_ProcessMemoryLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.ProcessMemoryLimit = V_I4(&v) :
                joeli.ProcessMemoryLimit = 0;
        }
    }

    v.Clear();
    if(SUCCEEDED(hr))
    {
        hr = pInst->Get(
                 g_rgJobObjLimitInfoPropNames[JOLMTPROP_JobMemoryLimit],
                 0,
                 &v,
                 NULL, 
                 NULL);

        if(SUCCEEDED(hr))
        {
            (V_VT(&v) == VT_I4) ? 
                joeli.JobMemoryLimit = V_I4(&v) :
                joeli.JobMemoryLimit = 0;
        }
    }
    
    // Now write the info out...
    if(SUCCEEDED(hr))
    {
        if(!::SetInformationJobObject(
            m_hJob,
            JobObjectExtendedLimitInformation,
            &joeli,
            sizeof(joeli)))
        {
            hr = WinErrorToWBEMhResult(::GetLastError());
        }
    }

    return hr;
}




HRESULT CJobObjLimitInfoProps::LoadPropertyValues(
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjLimitInfoPropNames,
             pIWCO);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjlimitinfoprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjLimitInfoProps.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************
#define IDS_Win32_NamedJobObjectLimitSetting L"Win32_NamedJobObjectLimitSetting"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_JOLimitInfoID                          0x00000001
#define PROP_PerProcessUserTimeLimit                0x00000002
#define PROP_PerJobUserTimeLimit                    0x00000004
#define PROP_LimitFlags                             0x00000008
#define PROP_MinimumWorkingSetSize                  0x00000010
#define PROP_MaximumWorkingSetSize                  0x00000020
#define PROP_ActiveProcessLimit                     0x00000040
#define PROP_Affinity                               0x00000080
#define PROP_PriorityClass                          0x00000100
#define PROP_SchedulingClass                        0x00000200
#define PROP_ProcessMemoryLimit                     0x00000400
#define PROP_JobMemoryLimit                         0x00000800


// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_LIMIT_INFO_PROPS
{
    JOLMTPROP_ID = 0,
    JOLMTPROP_PerProcessUserTimeLimit,
    JOLMTPROP_PerJobUserTimeLimit,
    JOLMTPROP_LimitFlags,    
    JOLMTPROP_MinimumWorkingSetSize,  
    JOLMTPROP_MaximumWorkingSetSize,        
    JOLMTPROP_ActiveProcessLimit,             
    JOLMTPROP_Affinity,            
    JOLMTPROP_PriorityClass,   
    JOLMTPROP_SchedulingClass,         
    JOLMTPROP_ProcessMemoryLimit,        
    JOLMTPROP_JobMemoryLimit,        

    // used to keep track of how many props we have:
    JOIOACTGPROP_JobObjLimitInfoPropertyCount  

} JOB_OBJ_LIMIT_INFO_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjLimitInfoPropNames[];
//*****************************************************************************
// END: Declaration of Win32_JobObjectLimitInfo class properties.
//*****************************************************************************



class CJobObjLimitInfoProps : public CObjProps
{
public:
    CJobObjLimitInfoProps() { m_hJob = NULL; }
    CJobObjLimitInfoProps(CHString& chstrNamespace);
    CJobObjLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjLimitInfoProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

    HRESULT SetWin32JOLimitInfoProps(
        IWbemClassObject __RPC_FAR *pInst);


private:
    HANDLE m_hJob;

    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\iproute\test\testsample.cpp ===
#include <ntos.h>
#include <ntddip.h>
#include <ntddtcp.h>
#include <malloc.h>

#define CANCEL


BOOLEAN test1();

NTSTATUS OpenQuerySource ( 

	HANDLE &a_StackHandle , 
	HANDLE &a_CompleteEventHandle
)
{
	UNICODE_STRING t_Stack ;
	RtlInitUnicodeString ( & t_Stack , DD_IP_DEVICE_NAME ) ;

	OBJECT_ATTRIBUTES t_Attributes;
	InitializeObjectAttributes (

		&t_Attributes,
		&t_Stack ,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	) ;

	IO_STATUS_BLOCK t_IoStatusBlock ;

	NTSTATUS t_NtStatus = NtOpenFile (

		&a_StackHandle,
		GENERIC_EXECUTE,
		&t_Attributes,
		&t_IoStatusBlock,
		FILE_SHARE_READ,
		0
	);

	if ( NT_SUCCESS ( t_NtStatus ) ) 
	{
        t_NtStatus = NtCreateEvent (

			&a_CompleteEventHandle,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE
		) ;

		if ( ! NT_SUCCESS ( t_NtStatus ) )
		{
			NtClose ( a_StackHandle ) ;
		}
	}

	return t_NtStatus ;
}

VOID SampleApc (

    PVOID SampleApcContext,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
)
{
    if (IoStatus->Status != STATUS_CANCELLED) 
	{
        DbgPrint( "test1 APC: Expected CANCELLED, got I/O Status value %lX - sample set\n",IoStatus->Status);
    }
	else
	{
        DbgPrint("test1 APC: Request CANCELLED.\n");
    }
}

BOOLEAN test1 ()
{
	HANDLE t_StackHandle ;
	HANDLE t_CompleteEventHandle ;

    DbgPrint( "test 1: opening sample\n");

	NTSTATUS t_NtStatus = OpenQuerySource ( 

		t_StackHandle , 
		t_CompleteEventHandle
	) ;

	while ( NT_SUCCESS ( t_NtStatus )  )
	{
		IO_STATUS_BLOCK t_IoStatusBlock ;

		t_NtStatus = NtDeviceIoControlFile (
			
			t_StackHandle,
			(HANDLE) t_CompleteEventHandle ,
			(PIO_APC_ROUTINE) NULL,
			(PVOID) NULL,
			&t_IoStatusBlock,
			IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
			NULL, // input buffer
			0,
			NULL ,    // output buffer
			0
		);

		if ( t_NtStatus == STATUS_PENDING )
		{
			t_NtStatus = NtWaitForSingleObject ( t_CompleteEventHandle , FALSE, NULL ) ;
		}
		else if ( t_NtStatus != STATUS_SUCCESS )  
		{
			DbgPrint( "test 1: Wrong return value %lX - sample set\n",t_NtStatus);
		}
		else if ( t_IoStatusBlock.Status != STATUS_SUCCESS ) 
		{
			DbgPrint( "test 1: Wrong I/O Status value %lX - sample set\n",t_IoStatusBlock.Status);
		}

		if ( NT_SUCCESS ( t_NtStatus ) )
		{
		}
	}

    //
    // Now close the sample device
    //

    DbgPrint("test 1:  closing sample device\n");

    t_NtStatus = NtClose ( t_StackHandle );
	t_NtStatus = NtClose ( t_CompleteEventHandle );

    if (t_NtStatus != STATUS_SUCCESS) 
	{
        DbgPrint( "test 1: Wrong return value %lX - sample close \n",t_NtStatus);
        return FALSE;
    }

    return TRUE;
}

int _cdecl main (

	int argc,
    char *argv[]
)
{
    UCHAR error = FALSE;

    DbgPrint( "Test1...\n" );
    if (!test1()) {
        DbgPrint("Error:  Test 1 failed\n");
        error = TRUE;
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjPropNames[] = 
{
    { L"CollectionID" },
    { L"BasicUIRestrictions" }
};
//*****************************************************************************
// END: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************



CJobObjProps::CJobObjProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace)
{
}


CJobObjProps::CJobObjProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob)
{
}

CJobObjProps::~CJobObjProps()
{
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjPropNames[JO_ID])) 
        dwReqProps |= PROP_ID;
    if (Query.IsPropertyRequired(g_rgJobObjPropNames[JO_JobObjectBasicUIRestrictions])) 
        dwReqProps |= PROP_JobObjectBasicUIRestrictions;

    return dwReqProps;
}


void CJobObjProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjPropNames[JO_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JO_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_NamedJobObject,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JO_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();

    if(dwReqProps & PROP_JobObjectBasicUIRestrictions)
    {
        // Get the value from the underlying JO:
        JOBOBJECT_BASIC_UI_RESTRICTIONS jouir;
        BOOL fQIJO = ::QueryInformationJobObject(
                         m_hJob,
                         JobObjectBasicUIRestrictions,
                         &jouir,
                         sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS),
                         NULL);

        if(!fQIJO)
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
            try // CVARIANT can throw...
            {
                // Store the value...
                m_PropMap.insert(SHORT2PVARIANT::value_type(
                                    JO_JobObjectBasicUIRestrictions, 
                                    new CVARIANT(jouir.UIRestrictionsClass)));
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }                                            
    }
    
    return hr;
}



HRESULT CJobObjProps::LoadPropertyValues(
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjPropNames,
             pIWCO);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cobjprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h

#pragma once


typedef std::map<short, CVARIANT* > SHORT2PVARIANT;

typedef DWORD (*PFN_CHECK_PROPS)(CFrameworkQuery&);




class CObjProps
{
public:
    CObjProps() {}
    CObjProps(CHString& chstrNamespace);
    virtual ~CObjProps();
    
    
    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx,
        LPCWSTR wstrClassName,
        CHStringArray& rgKeyNameArray,
        short sKeyNum[]);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys,
        short sKeyNum[]);

    void SetReqProps(DWORD dwProps);
    DWORD GetReqProps();

    void ClearProps();

protected:
    SHORT2PVARIANT m_PropMap;

    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq,
        PFN_CHECK_PROPS pfnChk);

    HRESULT LoadPropertyValues(
        LPCWSTR rgwstrPropNames[],
        IWbemClassObject* pIWCO);


private:
    DWORD m_dwReqProps;
    CHString m_chstrNamespace;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjseclimitinfoprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjSecLimitInfoProps.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************
#define IDS_Win32_NamedJobObjectSecLimitSetting L"Win32_NamedJobObjectSecLimitSetting"
#define IDS_GroupCount                     L"GroupCount"
#define IDS_Groups                         L"Groups"
#define IDS_Privileges                     L"Privileges"
#define IDS_PrivilegeCount                 L"PrivilegeCount"
#define IDS_SID                            L"SID"
#define IDS_AccountName                    L"AccountName"
#define IDS_ReferencedDomainName           L"ReferencedDomainName"
#define IDS_Attributes                     L"Attributes"
#define IDS_LUID                           L"LUID"
#define IDS_Win32_TokenGroups              L"Win32_TokenGroups"
#define IDS_Win32_TokenPrivileges          L"Win32_TokenPrivileges"
#define IDS_Win32_SidAndAttributes         L"Win32_SidAndAttributes"
#define IDS_Win32_LUIDAndAttributes        L"Win32_LUIDAndAttributes"
#define IDS_Win32_Sid                      L"Win32_Sid"
#define IDS_Win32_LUID                     L"Win32_LUID"
#define IDS_HighPart                       L"HighPart"
#define IDS_LowPart                        L"LowPart"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_JOSecLimitInfoID                       0x00000001
#define PROP_SecurityLimitFlags                     0x00000002
#define PROP_SidsToDisable                          0x00000004
#define PROP_PrivilagesToDelete                     0x00000008
#define PROP_RestrictedSids                         0x00000010


// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_SEC_LIMIT_INFO_PROPS
{
    JOSECLMTPROP_ID = 0,
    JOSECLMTPROP_SecurityLimitFlags,
    JOSECLMTPROP_SidsToDisable,    
    JOSECLMTPROP_PrivilegesToDelete,  
    JOSECLMTPROP_RestrictedSids,        

    // used to keep track of how many props we have:
    JOIOACTGPROP_JobObjSecLimitInfoPropertyCount  

} JOB_OBJ_SEC_LIMIT_INFO_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjSecLimitInfoPropNames[];
//*****************************************************************************
// END: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************






class CJobObjSecLimitInfoProps : public CObjProps
{
public:
    CJobObjSecLimitInfoProps();

    CJobObjSecLimitInfoProps(CHString& chstrNamespace);
    CJobObjSecLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjSecLimitInfoProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

    HRESULT SetWin32JOSecLimitInfoProps(
        IWbemClassObject __RPC_FAR *pInst);


private:

    HANDLE m_hJob;
    
    // Because many of the security limit info
    // properties can't be directly represented
    // as a variant type, we don't use our
    // m_PropMap and other mechanisms for this
    // class.  Instead, we store the properties
    // in this member variable.
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION  m_pjosli;


    // Helpers to set an outgoing instance...
    HRESULT SetInstanceFromJOSLI(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);    

    HRESULT SetInstanceSidsToDisable(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstancePrivilegesToDelete(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstanceRestrictedSids(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstanceTokenGroups(
        IWbemClassObject* pWin32TokenGroups,
        PTOKEN_GROUPS ptg,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);

    HRESULT SetInstanceTokenPrivileges(
        IWbemClassObject* pWin32TokenPrivileges,
        PTOKEN_PRIVILEGES ptp,
        IWbemContext* pCtx,
        IWbemServices* pNamespace);



    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cunknown.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CUnknown.cpp
#include "precomp.h"
#include <objidl.h>
#include <cominit.h>

#include <objbase.h>
#include <comdef.h>

#include "CUnknown.h"

#include "factory.h"


extern const char g_szTypeLibName[];

long CUnknown::s_cActiveComponents = 0L;

/*****************************************************************************/
// Constructor
/*****************************************************************************/
CUnknown::CUnknown() 
  : m_cRef(1),
    m_hEventThread(NULL),
    m_eStatus(Pending)
{ 
	InterlockedIncrement(&s_cActiveComponents); 
}

/*****************************************************************************/
// Destructor
/*****************************************************************************/
CUnknown::~CUnknown() 
{ 
	InterlockedDecrement(&s_cActiveComponents); 
    if(m_hEventThread)
    {
        ::CloseHandle(m_hEventThread);
    }
}

/*****************************************************************************/
// FinalRelease - called by Release before it deletes the component
/*****************************************************************************/
void CUnknown::FinalRelease()
{
	// If we have an event thread...
    if(m_eStatus != Pending)
    {
        // Let the event thread know that it can stop...
        m_eStatus = PendingStop;
        // Hold here until the event thread has stopped...
        DWORD dwWait = ::WaitForSingleObject(
            m_hEventThread,
            1000 * 60 * 20);  

        if(dwWait == WAIT_TIMEOUT)
        {
            // Something is most likely wrong....
            // If it takes 20 minutes, we will terminate
            // the thread, even though it is understood
            // that TerminateThread will leak some 
            // resources, as that is better than
            // leaving the thread running infinitely.
            ::TerminateThread(
                m_hEventThread,
                -1L);
        }
    }    
}

/*****************************************************************************/
// CUnknown default initialization
/*****************************************************************************/
STDMETHODIMP CUnknown::Init()
{    
	HRESULT hr = S_OK;


	return S_OK ;
}

/*****************************************************************************/
// IUnknown implementation
/*****************************************************************************/
STDMETHODIMP CUnknown::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IUnknown)
	{
		*ppv = static_cast<IUnknown*>(this); 
	}
	else
	{
		*ppv = NULL;
		hr = E_NOINTERFACE;
	}
	if(SUCCEEDED(hr))
    {
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

	return hr;
}

STDMETHODIMP_(ULONG) CUnknown::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CUnknown::Release() 
{
    ULONG ulRet = 0L;
    InterlockedDecrement(&m_cRef);
    if (m_cRef == 0)
	{
		FinalRelease();
        delete this;
	}
    else
    {
        ulRet = m_cRef;
    }
	return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cobjprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h


#include "precomp.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "helpers.h"
#include "globals.h"
#include <map>
#include <vector>
#include "CVARIANT.h"
#include "CObjProps.h"
#include <crtdbg.h>

#ifndef PROP_NONE_REQUIRED
#define PROP_NONE_REQUIRED  0x00000000
#endif

CObjProps::CObjProps(CHString& chstrNamespace)
{
    m_chstrNamespace = chstrNamespace;
}



CObjProps::~CObjProps()
{
    // Clean the property map.
    ClearProps();
}


void CObjProps::ClearProps()
{
    // Clean the property map.
    SHORT2PVARIANT::iterator theIterator;

    for(theIterator = m_PropMap.begin();
        theIterator != m_PropMap.end();
        theIterator++)
    {
        if(theIterator->second != NULL)
        {
            delete theIterator->second;
        }
    }
    m_PropMap.clear();
}



// Accessors to the requested properties member.
void CObjProps::SetReqProps(DWORD dwProps)
{
    m_dwReqProps = dwProps;
}

DWORD CObjProps::GetReqProps()
{
    return m_dwReqProps;
}



//***************************************************************************
//
//  Function:   SetKeysFromPath
//
//  called by the DeleteInstance and GetObject in order to load a
//  IWbemClassObject* with the key values in an object path.
//
//  Inputs:     IWbemClassObject*       pInstance - Instance to store
//                                      key values in.
//              ParsedObjectPath*       pParsedObjectPath - All the news
//                                      thats fit to print. 
//              rgKeyNameArray          An array of CHStrings containing
//                                      the names of the key properties.
//              sKeyNum                 An array of the key property 
//                                      reference numbers.
//
//  Outputs:    
//
//  Return:     HRESULT                 Success/Failure
//
//  Comments:  The number of elements in rgKeyNameArray and sKeyNum must be
//             the same.
//
//***************************************************************************
HRESULT CObjProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx,
    LPCWSTR wstrClassName,
    CHStringArray& rgKeyNameArray,
    short sKeyNum[])
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _ASSERT(sKeyNum);

    CObjectPathParser objpathParser;
    ParsedObjectPath* pParsedPath = NULL;

    try
    {
        int iParseResult = objpathParser.Parse(
                 ObjectPath,  
                 &pParsedPath);

        if(CObjectPathParser::NoError == iParseResult)
        {
            CFrameworkQueryEx cfwqe;
            cfwqe.Init(
                    (ParsedObjectPath*) pParsedPath, 
                    (IWbemContext*) pCtx, 
                    wstrClassName, 
                    (CHString&) m_chstrNamespace);

            if(rgKeyNameArray.GetSize() == pParsedPath->m_dwNumKeys)
            {
                // populate key props...
                for (DWORD i = 0; 
                     SUCCEEDED(hr) && i < (pParsedPath->m_dwNumKeys); 
                     i++)
                {
                    if (pParsedPath->m_paKeys[i])
                    {
                        // If a name was specified in the form class.keyname=value
                        if (pParsedPath->m_paKeys[i]->m_pName != NULL) 
                        {
                            if(_wcsicmp(pParsedPath->m_paKeys[i]->m_pName, 
                                      rgKeyNameArray[i]) == 0)
                            {
                                // Store the value...
                                m_PropMap.insert(SHORT2PVARIANT::value_type(
                                    sKeyNum[i], 
                                    new CVARIANT(pParsedPath->m_paKeys[i]->m_vValue)));
                            }
                        } 
                        else 
                        {
                            // There is a special case that you can say class=value
                            // only one key allowed in the format.  Check the names 
                            // on the path
                            if (pParsedPath->m_dwNumKeys == 1) 
                            {
                                // Store the value...
                                m_PropMap.insert(SHORT2PVARIANT::value_type(
                                    sKeyNum[i], 
                                    new CVARIANT(pParsedPath->m_paKeys[i]->m_vValue)));
                            }
                            else
                            {
                                hr = WBEM_E_INVALID_OBJECT_PATH;
                                _ASSERT(0);  // somebody lied about the number 
                                                  // of keys or the datatype was wrong
                            }    
                        }
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OBJECT_PATH;
                        _ASSERT(0); // somebody lied about the number of keys!
                    }
                }
            }
            else
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
                _ASSERT(0); // somebody lied about the number of keys!
            }
        }
        else
        {
            hr = WBEM_E_INVALID_OBJECT_PATH;
            _ASSERT(0); 
        }

        if (pParsedPath)
        {
            objpathParser.Free( pParsedPath );
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
        if (pParsedPath)
        {
            objpathParser.Free( pParsedPath );
        }
    }
    catch(...)
    {
        if (pParsedPath)
        {
            objpathParser.Free( pParsedPath );
        }
        throw;
    }    

    return hr;
}


// Allows direct setting of key properties.
// Key property values are stored in vecvKeys.
// sKeyNum is an array of the key property
// positions in m_PropMap.  The elements of
// these two arrays map to each other (e.g., 
// the first element in vecvKeys should be
// associated with the first element in sKeyNum, 
// and so on).
HRESULT CObjProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys,
    short sKeyNum[])
{
    HRESULT hr = S_OK;
    UINT uiCount = vecvKeys.size();

    try // CVARIANT can throw and I want the error...
    {
        for (UINT u = 0; u < uiCount; u++)
        {
            // Store the value...
            m_PropMap.insert(SHORT2PVARIANT::value_type(
                                sKeyNum[u], 
                                new CVARIANT(vecvKeys[u])));
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}




HRESULT CObjProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq,
    PFN_CHECK_PROPS pfnChk)
{
    // Get the requested properties for this
    // specific object via derived class fn...
    m_dwReqProps = pfnChk(cfwq);
    return WBEM_S_NO_ERROR;
}



// Loads all properties stored in this
// object into a new IWbemClassObject instance.
HRESULT CObjProps::LoadPropertyValues(
        LPCWSTR rgwstrPropNames[],
        IWbemClassObject* pIWCO)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    SHORT2PVARIANT::iterator theIterator;

    // Our map will only contain entries for properties
    // that were set via SetNonKeyReqProps, which only 
    // set properties that were requested.
    try // CVARIANT can throw and I want the error...
    {
        for(theIterator = m_PropMap.begin();
            theIterator != m_PropMap.end() && SUCCEEDED(hr);
            theIterator++)
        {
            // Because DWORDS and ULONGLONGs are not
            // automation compatible types (although
            // they are valid CIM types!), we need
            // to handle those two differently.  Same
            // with the other types special cased below.
            LPCWSTR wstrFoo = rgwstrPropNames[theIterator->first];
            CVARIANT* pvFoo = theIterator->second;

            if(theIterator->second->GetType() == VT_UI4)
            {
                WCHAR wstrTmp[256] = { '\0' };
                _ultow(theIterator->second->GetDWORD(), wstrTmp, 10);
                CVARIANT vTmp(wstrTmp);
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         &vTmp,
                         NULL);
            }
            else if(theIterator->second->GetType() == VT_UI8)
            {
                WCHAR wstrTmp[256] = { '\0' };
                _ui64tow(theIterator->second->GetULONGLONG(), wstrTmp, 10);
                CVARIANT vTmp(wstrTmp);
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         &vTmp,
                         NULL);
            }
            else if(theIterator->second->GetType() == VT_I8)
            {
                WCHAR wstrTmp[256] = { '\0' };
                _i64tow(theIterator->second->GetLONGLONG(), wstrTmp, 10);
                CVARIANT vTmp(wstrTmp);
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         &vTmp,
                         NULL);
            }
            else
            {  
                hr = pIWCO->Put(
                         rgwstrPropNames[theIterator->first], 
                         0, 
                         *(theIterator->second),
                         NULL);
            }   
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cunknown.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CUnknown.h

#pragma once


/*****************************************************************************/
// Component 
/*****************************************************************************/

class CUnknown : public IUnknown
{
public:
    // Constructor
	CUnknown();

	// Destructor
	virtual ~CUnknown();

	// IDispatch declarartion
    STDMETHOD(QueryInterface)(const IID& iid, void** ppv);                     
	STDMETHOD_(ULONG,AddRef)();                                                
	STDMETHOD_(ULONG,Release)();                                               
                                                                                   
    // Initialization
 	STDMETHOD(Init)();

    // Count of currently active components
	static long ActiveComponents() 
		{ return s_cActiveComponents ;}

    // Notification to derived classes that we are releasing
	STDMETHOD_(void,FinalRelease)() ;


protected:
    // Event thread status
    enum { Pending, Running, PendingStop, Stopped };
    int m_eStatus;
    HANDLE m_hEventThread;



private:
	// Reference count
	LONG m_cRef;

    // Count of all active instances
	static long s_cActiveComponents ;
};


/*****************************************************************************/
// Macro for easy declaration of IUnknown.  Derived classes using this must
// still implement QueryInterface (specifying their own interfaces).  
/*****************************************************************************/
#define DECLARE_IUNKNOWN									                   \
    STDMETHOD(QueryInterface)(const IID& iid, void** ppv);                     \
	STDMETHOD_(ULONG,AddRef)()                                                 \
    {                                                                          \
        return CUnknown::AddRef();                                             \
    }                                                                          \
	STDMETHOD_(ULONG,Release)()                                                \
    {                                                                          \
        return CUnknown::Release();                                            \
    }                                                                          \
                                                                               \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjprops.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h

#pragma once


//*****************************************************************************
// BEGIN: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************
#define IDS_Win32_NamedJobObject L"Win32_NamedJobObject"
#define IDS_EventClass L"Win32_JobObjectEvent"
#define IDS_ExitCode L"ExitCode"
// Win32_NamedJobObjectEvent class properties:
#define IDS_Type L"Type"
#define IDS_JobObjectID L"JobObjectID"
#define IDS_PID L"PID"

#define PROP_ALL_REQUIRED                           0xFFFFFFFF
#define PROP_NONE_REQUIRED                          0x00000000
#define PROP_ID                                     0x00000001
#define PROP_JobObjectBasicUIRestrictions           0x00000002

// The following enum is used to reference
// into the array that follows it.  Hence,
// they must be kept in synch.
typedef enum tag_JOB_OBJ_PROPS
{
    JO_ID = 0,
    JO_JobObjectBasicUIRestrictions,
    // used to keep track of how many props we have:
    JO_JobObjectPropertyCount  

} JOB_OBJ_PROPS;

// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE ENUMERATION DECLARED ABOVE!!!
extern LPCWSTR g_rgJobObjPropNames[];
//*****************************************************************************
// END: Declaration of Win32_NamedJobObject class properties.
//*****************************************************************************



class CJobObjProps : public CObjProps
{
public:
    CJobObjProps() { m_hJob = NULL; }
    CJobObjProps(CHString& chstrNamespace);
    CJobObjProps(
        HANDLE hJob,
        CHString& chstrNamespace);


    virtual ~CJobObjProps();

    HRESULT SetKeysFromPath(
        const BSTR ObjectPath, 
        IWbemContext __RPC_FAR *pCtx);

    HRESULT SetKeysDirect(
        std::vector<CVARIANT>& vecvKeys);

    
    HRESULT GetWhichPropsReq(
        CFrameworkQuery& cfwq);

    HRESULT SetNonKeyReqProps();

    HRESULT LoadPropertyValues(
        IWbemClassObject* pIWCO);

    void SetHandle(const HANDLE hJob);
    HANDLE& GetHandle();

private:
    HANDLE m_hJob;

    // Member meant to only be called
    // by base class.
    static DWORD CheckProps(
        CFrameworkQuery& Query);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cvariant.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CVARIANT.h

#pragma once


class CVARIANT;
class CVARIANTError;


class CVARIANTError
{
public:
    inline CVARIANTError()
      : m_hr(E_FAIL)
    {}

    inline CVARIANTError(HRESULT hr)
      : m_hr(hr)
    {}

    inline virtual ~CVARIANTError() {}

    inline HRESULT GetError()
    {
        return m_hr;
    }

    inline HRESULT GetWBEMError()
    {
        HRESULT hrOut = WBEM_S_NO_ERROR;
        switch(m_hr)
        {
            case DISP_E_ARRAYISLOCKED:
            {
                hrOut = WBEM_E_FAILED;
                break;
            }
            case DISP_E_BADVARTYPE:
            {
                hrOut = WBEM_E_INVALID_PARAMETER;
                break;
            }
            case E_OUTOFMEMORY:
            {
                hrOut = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            case E_INVALIDARG:
            {
                hrOut = WBEM_E_INVALID_PARAMETER;
                break;
            }
        }

        return hrOut;    
    }

private:
    HRESULT m_hr;
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }

    CVARIANT(const CVARIANT& vIn) throw(CVARIANTError)
    {
        HRESULT hr = S_OK;
        VariantInit(&v);
        hr = ::VariantCopy(&v, const_cast<VARIANT*>(&(vIn.v)));
        if(FAILED(hr))
        {
            throw CVARIANTError(hr);
        }  
    }

    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }
    CVARIANT& operator=(const CVARIANT& rv) 
    { 
        HRESULT hr = S_OK;
        hr = ::VariantCopy(&v, const_cast<VARIANT*>(&(rv.v)));
        if(FAILED(hr))
        {
            throw CVARIANTError(hr);
        }
         
        return *this; 
    }

    CVARIANT(LPCWSTR pSrc)      { ::VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)         { ::VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(DWORD dwSrc)       { ::VariantInit(&v); SetDWORD(dwSrc); }
    CVARIANT(LONGLONG llSrc)    { ::VariantInit(&v); SetLONGLONG(llSrc); }
    CVARIANT(ULONGLONG ullSrc)  { ::VariantInit(&v); SetULONGLONG(ullSrc); }
    CVARIANT(BOOL b)            { ::VariantInit(&v); SetBool(b); }
    CVARIANT(short i)           { ::VariantInit(&v); SetShort(i); }
    CVARIANT(double d)          { ::VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)            { ::VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { ::VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }
    CVARIANT(VARIANT& vIn)       
    { 
        HRESULT hr = S_OK;
        ::VariantInit(&v); 
        hr = ::VariantCopy(&v, &vIn); 
        if(FAILED(hr))
        {
            throw CVARIANTError(hr);
        }
    }
    
    // Can't have a DATE override, since DATA and double are defined
    // the same. Hence, to set a date, construct a CVARIANT using the
    // default constructor, then call SetDate.
    //CVARIANT(DATE dtDate)       { ::VariantInit(&v); SetDATE(dtDate); }

    void   SetStr(LPCWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDWORD(DWORD dwSrc) { Clear(); V_VT(&v) = VT_UI4; V_UI4(&v) = dwSrc; }
    LONG GetDWORD() { return V_UI4(&v); }
    operator DWORD() { return V_UI4(&v);  }

    void SetLONGLONG(LONGLONG llSrc) { Clear(); V_VT(&v) = VT_I8; V_I8(&v) = llSrc; }
    LONGLONG GetLONGLONG() { return V_I8(&v); }
    operator LONGLONG() { return V_I8(&v);  }

    void SetULONGLONG(ULONGLONG ullSrc) { Clear(); V_VT(&v) = VT_UI8; V_UI8(&v) = ullSrc; }
    ULONGLONG GetULONGLONG() { return V_UI8(&v); }
    operator ULONGLONG() { return V_UI8(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetDate(DATE dtDate) { Clear(); V_VT(&v) = VT_DATE; V_DATE(&v) = dtDate; }
    double GetDate() { return V_DATE(&v); }
    // operator DATE won't work since we have operator double.  You must call
    // GetDate() instead.
    //operator DATE() { return V_DATE(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; if(pDisp) pDisp->AddRef(); }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk;  if(pUnk) pUnk->AddRef(); }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    // Should only be used for artificially
    // setting the type to something other 
    // than what it really is!
    void SetType(VARTYPE vt) { V_VT(&v) = vt; }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { ::VariantInit(&v); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\cjobobjseclimitinfoprops.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// CJobObjSecLimitInfoProps.cpp

//#define _WIN32_WINNT 0x0500 



#include "precomp.h"

#pragma warning( disable: 4154 )

#include <wbemprov.h>
#include "FRQueryEx.h"
#include <vector>
#include "helpers.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjSecLimitInfoProps.h"
#include <crtdbg.h>


//*****************************************************************************
// BEGIN: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************
// WARNING!! MUST KEEP MEMBERS OF THE FOLLOWING ARRAY 
// IN SYNCH WITH THE JOB_OBJ_PROPS ENUMERATION DECLARED
// IN CJobObjProps.h !!!
LPCWSTR g_rgJobObjSecLimitInfoPropNames[] = 
{
    { L"SettingID" },
    { L"SecurityLimitFlags" },             
    { L"SidsToDisable" },   
    { L"PrivilegesToDelete" }, 
    { L"RestrictedSids" }       
};
//*****************************************************************************
// END: Declaration of Win32_JobObjectSecLimitInfo class properties.
//*****************************************************************************

CJobObjSecLimitInfoProps::CJobObjSecLimitInfoProps() 
  : m_hJob(NULL),
    m_pjosli(NULL)
{
}

CJobObjSecLimitInfoProps::CJobObjSecLimitInfoProps(CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(NULL),
    m_pjosli(NULL)
{
}


CJobObjSecLimitInfoProps::CJobObjSecLimitInfoProps(
        HANDLE hJob,
        CHString& chstrNamespace)
  : CObjProps(chstrNamespace),
    m_hJob(hJob),
    m_pjosli(NULL)
{
}

CJobObjSecLimitInfoProps::~CJobObjSecLimitInfoProps()
{
    if(m_pjosli)
    {
        delete m_pjosli;
        m_pjosli = NULL;
    }
}


// Clients call this to establish which properties
// were requested.  This function calls a base class
// helper, which calls our CheckProps function.  
// The base class helper finally stores the result
// in the base class member m_dwReqProps.
HRESULT CJobObjSecLimitInfoProps::GetWhichPropsReq(
    CFrameworkQuery& cfwq)
{
    HRESULT hr = S_OK;

    // Call base class version for help.
    // Base class version will call our
    // CheckProps function.
    hr = CObjProps::GetWhichPropsReq(
             cfwq,
             CheckProps);

    return hr;
}


DWORD CJobObjSecLimitInfoProps::CheckProps(
    CFrameworkQuery& Query)
{
    DWORD  dwReqProps = PROP_NONE_REQUIRED;
    // Get the requested properties for this
    // specific object...
    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID])) 
        dwReqProps |= PROP_JOSecLimitInfoID;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SecurityLimitFlags])) 
        dwReqProps |= PROP_SecurityLimitFlags;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SidsToDisable])) 
        dwReqProps |= PROP_SidsToDisable;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_PrivilegesToDelete])) 
        dwReqProps |= PROP_PrivilagesToDelete;

    if (Query.IsPropertyRequired(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_RestrictedSids])) 
        dwReqProps |= PROP_RestrictedSids;

    return dwReqProps;
}


void CJobObjSecLimitInfoProps::SetHandle(
    const HANDLE hJob)
{
    m_hJob = hJob;
}

HANDLE& CJobObjSecLimitInfoProps::GetHandle()
{
    _ASSERT(m_hJob);
    return m_hJob;
}

// Sets the key properties from the ObjectPath.
HRESULT CJobObjSecLimitInfoProps::SetKeysFromPath(
    const BSTR ObjectPath, 
    IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This array contains the key field names
    CHStringArray rgchstrKeys;
    rgchstrKeys.Add(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID]);
    
    // This array contains the index numbers 
    // in m_PropMap corresponding to the keys.
    short sKeyNum[1];
    sKeyNum[0] = JOSECLMTPROP_ID;

    hr = CObjProps::SetKeysFromPath(
             ObjectPath,                                       
             pCtx,
             IDS_Win32_NamedJobObjectSecLimitSetting,
             rgchstrKeys,
             sKeyNum);

    return hr;
}


// Sets the key property from in supplied
// parameter.
HRESULT CJobObjSecLimitInfoProps::SetKeysDirect(
    std::vector<CVARIANT>& vecvKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(vecvKeys.size() == 1)
    {
        short sKeyNum[1];
        sKeyNum[0] = JOSECLMTPROP_ID;

        hr = CObjProps::SetKeysDirect(
                 vecvKeys,
                 sKeyNum);
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


// Sets the non-key properties.  Only those
// properties requested are set (as determined
// by base class member m_dwReqProps).
HRESULT CJobObjSecLimitInfoProps::SetNonKeyReqProps()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwReqProps = GetReqProps();
    _ASSERT(m_hJob);
    if(!m_hJob) return WBEM_E_INVALID_PARAMETER;

    // Because all the properties of this class
    // come from the same underlying win32 job
    // object structure, we only need to get that
    // structure one time.  We only need to get
    // it at all if at least one non-key property
    // was requested.
    if(dwReqProps != PROP_NONE_REQUIRED)
    {
        // Get the value from the underlying JO:
        // This is a really flakey API when used
        // with a JobObjectSecurityLimitInformation,
        // as there is no way to get the size of
        // the buffer beforehand.  So we have to
        // allocate, see if it was enough, and if
        // not, reallocate!  We'll do this 10 times
        // at most, and if still not enough then bail.
        // Remember: new's throw on allocation
        // failure, hence not checking their allocation
        // below.
        PBYTE pbBuff = NULL;
        DWORD dwSize = 128L;
        BOOL fQIJO = FALSE;

        try
        {
            for(short s = 0;
                s < 10 && !fQIJO;
                s++)
            {
                pbBuff = new BYTE[dwSize];
                ZeroMemory(pbBuff, dwSize);

                fQIJO = ::QueryInformationJobObject(
                            m_hJob,
                            JobObjectSecurityLimitInformation,
                            pbBuff,
                            dwSize,
                            NULL);

                // Want to assign newly allocated
                // buffer to a place from which it
                // will be guarenteed to be cleaned 
                // up while we are inside this try
                // block.
                if(fQIJO)
                {
                    m_pjosli = (PJOBOBJECT_SECURITY_LIMIT_INFORMATION) pbBuff;
                }
                else
                {
                    delete pbBuff;
                    pbBuff = NULL;
                }

                dwSize = dwSize << 1;
            }
        }
        catch(...)
        {
            if(pbBuff)
            {
                delete pbBuff;
                pbBuff = NULL;
            }
            throw;
        }

        if(!fQIJO)
        {
            _ASSERT(0);
            hr = WBEM_E_FAILED;
        }
    }
    
    return hr;
}





HRESULT CJobObjSecLimitInfoProps::LoadPropertyValues(
        IWbemClassObject* pIWCO,
        IWbemContext* pCtx,
        IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(!pIWCO) return E_POINTER;

    // Load properties from the map...
    hr = CObjProps::LoadPropertyValues(
             g_rgJobObjSecLimitInfoPropNames,
             pIWCO);

    // Uses member josli and dwReqProps to
    // load properties to the instance.
    hr = SetInstanceFromJOSLI(
             pIWCO,
             pCtx,
             pNamespace);

    return hr;
}



//*****************************************************************************
//
// The following are a family of functions used to set information in a
// Win32_NamedJobObjectSecLimitSetting instance from a 
// JOBOBJECT_SECURITY_LIMIT_INFORMATION structure. Called by LoadPropertyValues.
//
//*****************************************************************************

HRESULT CJobObjSecLimitInfoProps::SetInstanceFromJOSLI(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    // We expect, when this function is called,
    // that at least the member m_pjosli has been
    // set (via a call to SetNonKeyReqProps).
    // That function will have set the other
    // member variables (such as m_ptgSidsToDisable)
    // based on which properties were requested.
    //
    // Our job in this function is to populate
    // only those properties of the IWbemClassObject
    // (which will be handed back to CIMOM) that
    // the user requested.  We encapsulate this
    // work into helper fuctions for those properties
    // that are embedded objects.
    DWORD dwReqProps = GetReqProps();
    CVARIANT v;

    try // CVARIANT can throw and I want the error...
    {
        if(dwReqProps & PROP_SecurityLimitFlags)             
        {
            v.SetLONG((LONG)m_pjosli->SecurityLimitFlags);
            hr = pIWCO->Put(
                     g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SecurityLimitFlags], 
                     0, 
                     &v,
                     NULL);
        }                      
    
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & PROP_SidsToDisable)
            {
                hr = SetInstanceSidsToDisable(
                         pIWCO,
                         pCtx,
                         pNamespace);
            }
        }

        if(SUCCEEDED(hr))
        {
            if(dwReqProps & PROP_PrivilagesToDelete)
            {
                hr = SetInstancePrivilegesToDelete(
                         pIWCO,
                         pCtx,
                         pNamespace);
            }
        }

        if(SUCCEEDED(hr))
        {
            if(dwReqProps & PROP_RestrictedSids)
            {
                hr = SetInstanceRestrictedSids(
                         pIWCO,
                         pCtx,
                         pNamespace);
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstanceSidsToDisable(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If m_ptgSidsToDisable is not null,
    // Create a Win32_TokenGroups instance
    // and call a function to populate it.
    if(m_pjosli->SidsToDisable)
    {
        IWbemClassObjectPtr pWin32TokenGroups;
        hr = CreateInst(
                 pNamespace,
                 &pWin32TokenGroups,
                 _bstr_t(IDS_Win32_TokenGroups),
                 pCtx);
        
        if(SUCCEEDED(hr))
        {
            hr = SetInstanceTokenGroups(
                     pWin32TokenGroups,
                     m_pjosli->SidsToDisable,
                     pCtx,
                     pNamespace);
        }

        if(SUCCEEDED(hr))
        {
            try
            {
                CVARIANT v;
                v.SetUnknown(pWin32TokenGroups);
                hr = pIWCO->Put(
                         g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_SidsToDisable], 
                         0, 
                         &v,
                         NULL);
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }
    }     

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstancePrivilegesToDelete(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If m_ptpPrivilegesToDelete is not null,
    // Create a Win32_TokenPrivileges instance
    // and call a function to populate it.
    if(m_pjosli->PrivilegesToDelete)
    {
        IWbemClassObjectPtr pWin32TokenPrivileges;
        hr = CreateInst(
                 pNamespace,
                 &pWin32TokenPrivileges,
                 _bstr_t(IDS_Win32_TokenPrivileges),
                 pCtx);
        
        if(SUCCEEDED(hr))
        {
            hr = SetInstanceTokenPrivileges(
                     pWin32TokenPrivileges,
                     m_pjosli->PrivilegesToDelete,
                     pCtx,
                     pNamespace);
        }

        if(SUCCEEDED(hr))
        {
            try
            {
                CVARIANT v;
                v.SetUnknown(pWin32TokenPrivileges);
                hr = pIWCO->Put(
                         g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_PrivilegesToDelete], 
                         0, 
                         &v,
                         NULL);
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }
    }     

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstanceRestrictedSids(
    IWbemClassObject* pIWCO,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If m_ptgRestrictedSids is not null,
    // Create a Win32_TokenGroups instance
    // and call a function to populate it.
    if(m_pjosli->RestrictedSids)
    {
        IWbemClassObjectPtr pWin32TokenGroups;
        hr = CreateInst(
                 pNamespace,
                 &pWin32TokenGroups,
                 _bstr_t(IDS_Win32_TokenGroups),
                 pCtx);
        
        if(SUCCEEDED(hr))
        {
            hr = SetInstanceTokenGroups(
                     pWin32TokenGroups,
                     m_pjosli->RestrictedSids,
                     pCtx,
                     pNamespace);
        }

        if(SUCCEEDED(hr))
        {
            try
            {
                CVARIANT v;
                v.SetUnknown(pWin32TokenGroups);
                hr = pIWCO->Put(
                         g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_RestrictedSids], 
                         0, 
                         &v,
                         NULL);
            }
            catch(CVARIANTError& cve)
            {
                hr = cve.GetWBEMError();
            }
        }
    }     

    return hr;
}



HRESULT CJobObjSecLimitInfoProps::SetInstanceTokenGroups(
    IWbemClassObject* pWin32TokenGroups,
    PTOKEN_GROUPS ptg,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _ASSERT(ptg);
    if(!ptg) return hr = WBEM_E_INVALID_PARAMETER;

    // We need to populate the two properties of
    // Win32_TokenGroups (passed in as pWin32TokenGroups:
    // GroupCount, and Groups.  If GroupCount is
    // zero, on the other hand, don't bother with
    // the Groups property.
    try // CVARIANT  can throw and I want the error...
    {
        CVARIANT vGroupCount;
        LONG lSize = (LONG)ptg->GroupCount;

        vGroupCount.SetLONG(lSize);
        hr = pWin32TokenGroups->Put(
                 IDS_GroupCount, 
                 0, 
                 &vGroupCount,
                 NULL);

        if(SUCCEEDED(hr) && 
           lSize > 0)
        {
            // Need to create an array for the
            // Win32_SidAndAttributes instances...
            SAFEARRAY* saSidAndAttr;
	        SAFEARRAYBOUND rgsabound[1];
		    long ix[1];

            rgsabound[0].cElements = lSize;
		    rgsabound[0].lLbound = 0;
		    saSidAndAttr = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

            for(long m = 0; m < lSize && SUCCEEDED(hr); m++)
            {
                IWbemClassObjectPtr pWin32SidAndAttributes;
                IWbemClassObjectPtr pWin32Sid;

                hr = CreateInst(
                         pNamespace,
                         &pWin32SidAndAttributes,
                         _bstr_t(IDS_Win32_SidAndAttributes),
                         pCtx);
            
                if(SUCCEEDED(hr))
                {
                    // Set the attrubutes...
                    CVARIANT vAttributes;
                    vAttributes.SetLONG((LONG)ptg->Groups[m].Attributes);
                    hr = pWin32SidAndAttributes->Put(
                             IDS_Attributes, 
                             0, 
                             &vAttributes,
                             NULL);
                }

                if(SUCCEEDED(hr))
                {
                    // Set the sid...
                    hr = CreateInst(
                             pNamespace,
                             &pWin32Sid,
                             _bstr_t(IDS_Win32_Sid),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        _bstr_t bstrtSid;

                        StringFromSid(
                            ptg->Groups[m].Sid,
                            bstrtSid);
                    
                        // Set the SID property of the Win32_SID...
                        CVARIANT vSID;
                        vSID.SetStr(bstrtSid);
                        hr = pWin32Sid->Put(
                                 IDS_SID, 
                                 0, 
                                 &vSID,
                                 NULL);

                        // As a courtesy, set the domain and
                        // account name props of win32_sid;
                        // don't care about failures.
                        {
                            CHString chstrName;
                            CHString chstrDom;

                            GetNameAndDomainFromPSID(
                                ptg->Groups[m].Sid,
                                chstrName,
                                chstrDom);
                            
                            vSID.SetStr(chstrName);
                            pWin32Sid->Put(
                                     IDS_AccountName, 
                                     0, 
                                     &vSID,
                                     NULL);

                            vSID.SetStr(chstrDom);
                            pWin32Sid->Put(
                                     IDS_ReferencedDomainName, 
                                     0, 
                                     &vSID,
                                     NULL);
                        }
                    }

                    // Set the SID property of the 
                    // Win32_SidAndAttributes...
                    if(SUCCEEDED(hr))
                    {
                        CVARIANT vSAndASid;
                        vSAndASid.SetUnknown(pWin32Sid);
                        hr = pWin32SidAndAttributes->Put(
                                 IDS_SID,
                                 0,
                                 &vSAndASid,
                                 NULL);
                    }    
                }
            
                // Now we need to add the Win32_SidAndAttributes
                // instance to the safearray.  We need to make
                // sure that the instances we add to the safearray
                // don't go away as soon as pWin32SidAndAttributes
                // and pWin32Sid go out of scope (being smart
                // pointers, they will Release when they do), so
                // we must addref both interfaces...
                if(SUCCEEDED(hr))
                {
                    pWin32Sid.AddRef();
                    pWin32SidAndAttributes.AddRef();

                    SafeArrayPutElement(
                        saSidAndAttr, 
                        ix, 
                        pWin32SidAndAttributes);
                }

                ix[0]++;
            }

            // We now have a populated safe array.
            // Now we must set the Groups property
            // of the pWin32TokenGroups that was 
            // passed into this function...
            if(SUCCEEDED(hr))
            {
                CVARIANT vGroups;
                vGroups.SetArray(
                    saSidAndAttr,
                    VT_UNKNOWN | VT_ARRAY);

                hr = pWin32TokenGroups->Put(
                         IDS_Groups, 
                         0, 
                         &vGroups,
                         NULL);
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}


HRESULT CJobObjSecLimitInfoProps::SetInstanceTokenPrivileges(
    IWbemClassObject* pWin32TokenPrivileges,
    PTOKEN_PRIVILEGES ptp,
    IWbemContext* pCtx,
    IWbemServices* pNamespace)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _ASSERT(ptp);
    if(!ptp) return hr = WBEM_E_INVALID_PARAMETER;

    // We need to populate the two properties of
    // Win32_TokenGroups (passed in as pWin32TokenGroups:
    // GroupCount, and Groups.  If GroupCount is
    // zero, on the other hand, don't bother with
    // the Groups property.
    
    try // CVARIANT can throw and I want the error...
    {
        CVARIANT vPrivilegeCount;
        LONG lSize = (LONG)ptp->PrivilegeCount;
        vPrivilegeCount.SetLONG(lSize);
        hr = pWin32TokenPrivileges->Put(
                 IDS_PrivilegeCount, 
                 0, 
                 &vPrivilegeCount,
                 NULL);

        if(SUCCEEDED(hr) && 
           lSize > 0)
        {
            // Need to create an array for the
            // Win32_LUIDAndAttributes instances...
            SAFEARRAY* saLUIDAndAttr;
	        SAFEARRAYBOUND rgsabound[1];
		    long ix[1];

            rgsabound[0].cElements = lSize;
		    rgsabound[0].lLbound = 0;
		    saLUIDAndAttr = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

            for(long m = 0; m < lSize && SUCCEEDED(hr); m++)
            {
                IWbemClassObjectPtr pWin32LUIDAndAttributes;
                IWbemClassObjectPtr pWin32LUID;
                hr = CreateInst(
                         pNamespace,
                         &pWin32LUIDAndAttributes,
                         _bstr_t(IDS_Win32_LUIDAndAttributes),
                         pCtx);
            
                if(SUCCEEDED(hr))
                {
                    // Set the attrubutes...
                    CVARIANT vAttributes;
                    vAttributes.SetLONG((LONG)ptp->Privileges[m].Attributes);
                    hr = pWin32LUIDAndAttributes->Put(
                             IDS_Attributes, 
                             0, 
                             &vAttributes,
                             NULL);
                }

                if(SUCCEEDED(hr))
                {
                    // Set the luid...
                    hr = CreateInst(
                             pNamespace,
                             &pWin32LUID,
                             _bstr_t(IDS_Win32_LUID),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        // Set the HighPart and LowPart properties
                        // of the Win32_LUID...
                        CVARIANT vHighPart;
                        vHighPart.SetLONG(ptp->Privileges[m].Luid.HighPart);
                        hr = pWin32LUID->Put(
                                 IDS_HighPart, 
                                 0, 
                                 &vHighPart,
                                 NULL);

                        if(SUCCEEDED(hr))
                        {
                            CVARIANT vLowPart;
                            vLowPart.SetLONG((LONG)ptp->Privileges[m].Luid.LowPart);
                            hr = pWin32LUID->Put(
                                     IDS_LowPart, 
                                     0, 
                                     &vLowPart,
                                     NULL);
                        }    
                    }

                    // Set the LUID property of the 
                    // Win32_LUIDAndAttributes...
                    if(SUCCEEDED(hr))
                    {
                        CVARIANT vLAndALUID;
                        vLAndALUID.SetUnknown(pWin32LUID);
                        hr = pWin32LUIDAndAttributes->Put(
                                 IDS_LUID,
                                 0,
                                 &vLAndALUID,
                                 NULL);
                    }    
                }
            
                // Now we need to add the Win32_LUIDAndAttributes
                // instance to the safearray.  We need to make
                // sure that the instances we add to the safearray
                // don't go away as soon as pWin32SidAndAttributes
                // goes out of scope (being a smart
                // pointer, it will Release when it does), so
                // we must addref the interface...
                if(SUCCEEDED(hr))
                {
                    pWin32LUIDAndAttributes.AddRef();
                    pWin32LUID.AddRef();

                    SafeArrayPutElement(
                        saLUIDAndAttr, 
                        ix, 
                        pWin32LUIDAndAttributes);
                }

                ix[0]++;
            }

            // We now have a populated safe array.
            // Now we must set the Privileges property
            // of the pWin32TokenPrivileges that was 
            // passed into this function...
            if(SUCCEEDED(hr))
            {
                CVARIANT vPrivileges;
                vPrivileges.SetArray(
                    saLUIDAndAttr,
                    VT_UNKNOWN | VT_ARRAY);

                hr = pWin32TokenPrivileges->Put(
                         IDS_Privileges, 
                         0, 
                         &vPrivileges,
                         NULL);
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\helpers.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Helpers.cpp:  Helper functions for the SecUtil component

//#include "FWCommon.h"
//#include <windows.h>

//#ifndef _X86_
//#define _X86_
//#endif

//#ifndef _IA64_
//#define _IA64_
//#endif
                                      
//#include <winnt.h>

/*
#ifndef USE_POLARITY
// For most users, this is the correct setting for POLARITY.
#define USE_POLARITY
#endif
*/


#include "precomp.h"

#include <cominit.h>
#include <vector>
#include "Helpers.h"
#include "AssertBreak.h"
#include "CVARIANT.H"
#include <crtdbg.h>





#define IDS_NTDLLDOTDLL                L"NTDLL.DLL"
#define IDS_NTOPENDIRECTORYOBJECT      "NtOpenDirectoryObject"
#define IDS_NTQUERYDIRECTORYOBJECT     "NtQueryDirectoryObject"
#define IDS_RTLINITUNICODESTRING       "RtlInitUnicodeString"
#define IDS_WHACKWHACKBASENAMEDOBJECTS L"\\BaseNamedObjects"
#define IDS_NTQUERYINFORMATIONPROCESS  "NtQueryInformationProcess"
#define IDS_NTOPENPROCESS              "NtOpenProcess"

#define IDS_WIN32_ERROR_CODE L"Win32ErrorCode"
#define IDS_ADDITIONAL_DESCRIPTION L"AdditionalDescription"
#define IDS_OPERATION L"Operation"


typedef NTSTATUS (NTAPI *PFN_NT_OPEN_DIRECTORY_OBJECT)
(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_DIRECTORY_OBJECT)
(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
);

typedef VOID (WINAPI *PFN_NTDLL_RTL_INIT_UNICODE_STRING)
(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
);

typedef NTSTATUS (NTAPI *PFN_NTDLL_NT_QUERY_INFORMATION_PROCESS)
(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_OPEN_PROCESS)
(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
);




//***************************************************************************
//
// CreateInst
//
// Purpose: Creates a new instance.
//
// Return:   S_OK if all is well, otherwise an error code is returned
//
//***************************************************************************
HRESULT CreateInst(
    IWbemServices *pNamespace, 
    IWbemClassObject **pNewInst,
    BSTR bstrClassName,
    IWbemContext *pCtx)
{   
    HRESULT hr = S_OK;
    IWbemClassObjectPtr pClass;
    hr = pNamespace->GetObject(
                         bstrClassName, 
                         0, 
                         pCtx, 
                         &pClass, 
                         NULL);
    
    if(SUCCEEDED(hr))
    {
        hr = pClass->SpawnInstance(
                         0, 
                         pNewInst);
    }
    
    return hr;
}


//***************************************************************************
//
// GetObjInstKeyVal
//
// Purpose: Obtains an object's instance key from an object path.
//
// Return:  true if the key was obtained.
//
//***************************************************************************
HRESULT GetObjInstKeyVal(
    const BSTR ObjectPath,
    LPCWSTR wstrClassName,
    LPCWSTR wstrKeyPropName, 
    LPWSTR wstrObjInstKeyVal, 
    long lBufLen)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR* pwcEqualSign = NULL;
    WCHAR* pwcTmp = NULL;

    if(!ObjectPath)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if((pwcEqualSign = wcschr(ObjectPath, L'=')) != NULL)
    {
        pwcEqualSign++;
        long lLen = wcslen(pwcEqualSign) * sizeof(WCHAR);
        if(*pwcEqualSign &&
           lLen > 0 &&
           lLen < (long)(lBufLen - sizeof(WCHAR)))
        {
            wcscpy(wstrObjInstKeyVal, pwcEqualSign);

            // Remove any quotation marks that might
            // be there...
            RemoveQuotes(wstrObjInstKeyVal);

            // Also need to check that the class name
            // matches the name specified...
            WCHAR wstrClass[_MAX_PATH];
            wcscpy(wstrClass, ObjectPath);
            pwcTmp = wcschr(wstrClass, L'=');
            if(pwcTmp)
            {
                *pwcTmp = '\0';
                // Either the key property was specified or
                // it wasn't...
                pwcTmp = NULL;
                pwcTmp = wcschr(wstrClass, L'.');
                if(pwcTmp)
                {
                    // Key property specified, so check that
                    // both it and the class name are correct...
                    *pwcTmp = '\0';
                    if(_wcsicmp(wstrClassName, wstrClass) == 0)
                    {
                        if(_wcsicmp(wstrKeyPropName, ++pwcTmp) != 0)
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
                else
                {
                    // No key prop specified, so only need
                    // to check that the class name is correct...
                    if(_wcsicmp(wstrClassName, wstrClass) != 0)
                    {            
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}


HRESULT GetJobObjectList(
    std::vector<_bstr_t>& rgbstrtJOs)
{
    HRESULT hr = S_OK;
    HINSTANCE hinst = NULL;
    SmartCloseHANDLE hDir;
    PBYTE pbBuff = NULL;

    try
    {
        if((hinst = ::LoadLibrary(IDS_NTDLLDOTDLL)) != NULL)
        {
            PFN_NT_OPEN_DIRECTORY_OBJECT pfnNtOpenDirectoryObject = NULL; 
            PFN_NT_QUERY_DIRECTORY_OBJECT pfnNtQueryDirectoryObject = NULL; 
            PFN_NTDLL_RTL_INIT_UNICODE_STRING pfnRtlInitUnicodeString = NULL;

            pfnNtOpenDirectoryObject = (PFN_NT_OPEN_DIRECTORY_OBJECT) 
                                            ::GetProcAddress(hinst, IDS_NTOPENDIRECTORYOBJECT);

            pfnNtQueryDirectoryObject = (PFN_NT_QUERY_DIRECTORY_OBJECT) 
                                            ::GetProcAddress(hinst, IDS_NTQUERYDIRECTORYOBJECT);

            pfnRtlInitUnicodeString = (PFN_NTDLL_RTL_INIT_UNICODE_STRING) 
                                            ::GetProcAddress(hinst, IDS_RTLINITUNICODESTRING);


            if(pfnNtOpenDirectoryObject != NULL &&
               pfnNtQueryDirectoryObject != NULL &&
               pfnRtlInitUnicodeString != NULL)
            {
                OBJECT_ATTRIBUTES oaAttributes;
                UNICODE_STRING ustrNtFileName;
                NTSTATUS ntstat = -1L;

                pfnRtlInitUnicodeString(&ustrNtFileName, 
                                        IDS_WHACKWHACKBASENAMEDOBJECTS);

                InitializeObjectAttributes(&oaAttributes,
					                       &ustrNtFileName,
					                       OBJ_CASE_INSENSITIVE,
					                       NULL,
					                       NULL);

    
	            ntstat = pfnNtOpenDirectoryObject(&hDir,
	           	                                  FILE_READ_DATA,
                                                  &oaAttributes);
                                      
                if(NT_SUCCESS(ntstat))
                {
                    ULONG ulContext = -1L;
                    ntstat = STATUS_SUCCESS;
                    ULONG ulBufLen = 0L;
                    ULONG ulNewBufLen = 0L;

                    // First query to get buffer size to allocate...
                    ntstat = pfnNtQueryDirectoryObject(hDir,          // IN HANDLE DirectoryHandle,
                                                       NULL,          // OUT PVOID Buffer,
                                                       0L,            // IN ULONG Length,
                                                       FALSE,         // IN BOOLEAN ReturnSingleEntry,
                                                       TRUE,          // IN BOOLEAN RestartScan,
                                                       &ulContext,    // IN OUT PULONG Context,
                                                       &ulBufLen);    // OUT PULONG ReturnLength OPTIONAL
                
                    pbBuff = new BYTE[ulBufLen];
                    if(pbBuff)
                    {
                        // then loop through all the entries...
                        for(; ntstat != STATUS_NO_MORE_ENTRIES && pbBuff != NULL;)
                        {
                            ntstat = pfnNtQueryDirectoryObject(hDir,          // IN HANDLE DirectoryHandle,
                                                               pbBuff,        // OUT PVOID Buffer,
                                                               ulBufLen,      // IN ULONG Length,
                                                               TRUE,          // IN BOOLEAN ReturnSingleEntry,
                                                               FALSE,         // IN BOOLEAN RestartScan,
                                                               &ulContext,    // IN OUT PULONG Context,
                                                               &ulNewBufLen); // OUT PULONG ReturnLength OPTIONAL

                            if(ntstat == STATUS_BUFFER_TOO_SMALL)
                            {
                                // Deallocate buffer and reallocate...
                                if(pbBuff != NULL)
                                {
                                    delete pbBuff;
                                    pbBuff = NULL;
                                }
                                pbBuff = new BYTE[ulNewBufLen];
                                ulBufLen = ulNewBufLen;
                            }
                            else if(NT_SUCCESS(ntstat))
                            {
                                // All went well, should have data...
                                if(pbBuff != NULL)
                                {
                                    POBJECT_DIRECTORY_INFORMATION podi = (POBJECT_DIRECTORY_INFORMATION) pbBuff;
                                    LPWSTR wstrName = (LPWSTR)podi->Name.Buffer;
                                    LPWSTR wstrType = (LPWSTR)podi->TypeName.Buffer;
                    
                                    // do something...
                                    // offset to string name is in four bytes...
                                    if(wstrName != NULL && 
                                       wstrType != NULL &&
                                       wcslen(wstrType) == 3)
                                    {
                                        WCHAR wstrTmp[4]; wstrTmp[3] = '\0';
                                        wcsncpy(wstrTmp, wstrType, 3);
                                        if(_wcsicmp(wstrTmp, L"job") == 0)
                                        {
                                            rgbstrtJOs.push_back(_bstr_t(wstrName));    
                                        }
                                    }
                                }
                            }
                            else if(ntstat == STATUS_NO_MORE_ENTRIES)
                            {
                                // we will break
                            }
                            else
                            {
                                // Something we weren't expecting happened, so bail out...
                                hr = E_FAIL;
                            }
                        }  // while we still have entries

                        delete pbBuff;
                        pbBuff = NULL;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                
                } // NtOpenDirectoryObject succeeded
                else
                {
                    hr = E_FAIL;
                }
            } // Got the fn ptrs
            else
            {
                hr = E_FAIL;
            }
            ::FreeLibrary(hinst);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch(...)
    {
        if(pbBuff != NULL)
        {
            delete pbBuff; pbBuff = NULL;
        }
        if(hinst != NULL)
        {
            ::FreeLibrary(hinst); hinst = NULL;
        }
        throw;
    }

    return hr;
}



// a string representation of a SID is assumed to be:
// S-#-####-####-####-####-####-####
// we will enforce only the S ourselves, 
// The version is not checked
// everything else will be handed off to the OS
// caller must free the SID returned
PSID WINAPI StrToSID(LPCWSTR wstrIncommingSid)
{
	WCHAR wstrSid[_MAX_PATH];
    wcscpy(wstrSid, wstrIncommingSid);
    PSID pSid = NULL; 

	if (wcslen(wstrSid) > 0 && ((wstrSid[0] == 'S')||(wstrSid[0] == 's')) && (wstrSid[1] == '-'))
	{
		// get a local copy we can play with
		// we'll parse this puppy the easy way
		// by slicing off each token as we find it
		// slow but sure
		// start by slicing off the "S-"
		WCHAR wstrTmp[_MAX_PATH];
        wcscpy(wstrTmp, wstrSid+2);
        WCHAR wstrToken[_MAX_PATH];
		
		SID_IDENTIFIER_AUTHORITY identifierAuthority = {0,0,0,0,0,0};
		BYTE nSubAuthorityCount =0;  // count of subauthorities
		DWORD dwSubAuthority[8]   = {0,0,0,0,0,0,0,0};    // subauthorities
		
		// skip version
		WhackToken(wstrTmp, wstrToken);
		// Grab Authority
		if (WhackToken(wstrTmp, wstrToken))
		{
            DWORD duhWord;
			WCHAR* p = NULL;
			bool bDoIt = false;

			if (StrToIdentifierAuthority(wstrToken, identifierAuthority))
			// conversion succeeded
			{
				bDoIt = true;

				// now fill up the subauthorities
				while (bDoIt && WhackToken(wstrTmp, wstrToken))
				{
					p = NULL;
					duhWord = wcstoul(wstrToken, &p, 10);
					
					if (p != wstrToken)
					{
						dwSubAuthority[nSubAuthorityCount] = duhWord;
						bDoIt = (++nSubAuthorityCount <= 8);
					}
					else
						bDoIt = false;
				} // end while WhackToken

				if(bDoIt)
                {
					AllocateAndInitializeSid(&identifierAuthority,
					   						  nSubAuthorityCount,
											  dwSubAuthority[0],									
											  dwSubAuthority[1],									
											  dwSubAuthority[2],									
											  dwSubAuthority[3],									
											  dwSubAuthority[4],									
											  dwSubAuthority[5],									
											  dwSubAuthority[6],									
											  dwSubAuthority[7],
											  &pSid);
                }
			}
		}
	}
	return pSid;
}



// helper for StrToSID
// takes a string, converts to a SID_IDENTIFIER_AUTHORITY
// returns false if not a valid SID_IDENTIFIER_AUTHORITY
// contents of identifierAuthority are unrelieable on failure
bool WINAPI StrToIdentifierAuthority(LPCWSTR str, SID_IDENTIFIER_AUTHORITY& identifierAuthority)
{
    bool bRet = false;
    memset(&identifierAuthority, '\0', sizeof(SID_IDENTIFIER_AUTHORITY));

    DWORD duhWord;
    WCHAR* p = NULL;
    WCHAR wstrLocal[_MAX_PATH];
    wcscpy(wstrLocal, str);

    // per KB article Q13132, if identifier authority is greater than 2**32, it's in hex
    if ((wstrLocal[0] == '0') && ((wstrLocal[1] == 'x') || (wstrLocal[1] == 'X')))
    // if it looks hexidecimalish...
    {
        // going to parse this out backwards, chpping two chars off the end at a time
        // first, whack off the 0x
        WCHAR wstrTmp[_MAX_PATH];
        wcscpy(wstrTmp, wstrLocal+2);
        wcscpy(wstrLocal, wstrTmp);
        
        WCHAR wstrToken[_MAX_PATH];
        int nValue =5;
        
        bRet = true;
        while (bRet && (wcslen(wstrLocal) > 0) && (nValue > 0))
        {
            wcscpy(wstrToken, wstrLocal+2);
            wcscpy(wstrTmp, wstrLocal);
            wstrTmp[wcslen(wstrLocal) - 2] = NULL;
            wcscpy(wstrLocal, wstrTmp);
            duhWord = wcstoul(wstrToken, &p, 16);

            // if strtoul succeeds, the pointer is moved
            if (p != wstrToken)
                identifierAuthority.Value[nValue--] = (BYTE)duhWord;
            else
                bRet = false;
        }
    }
    else
    // it looks decimalish
    {    
        duhWord = wcstoul(wstrLocal, &p, 10);

        if (p != wstrLocal)
        // conversion succeeded
        {
            bRet = true;
            identifierAuthority.Value[5] = LOBYTE(LOWORD(duhWord));
            identifierAuthority.Value[4] = HIBYTE(LOWORD(duhWord));
            identifierAuthority.Value[3] = LOBYTE(HIWORD(duhWord));
            identifierAuthority.Value[2] = HIBYTE(HIWORD(duhWord));
        }
    }
        
    return bRet;
}

// for input of the form AAA-BBB-CCC
// will return AAA in token
// and BBB-CCC in str
bool WINAPI WhackToken(LPWSTR str, LPWSTR token)
{
	bool bRet = false;
	if (wcslen(str) > 0)
	{
		//int index;
		//index = str.Find('-');
	    WCHAR* pwc = NULL;
        pwc = wcschr(str, L'-');
		if (pwc == NULL)
		{
			// all that's left is the token, we're done
			wcscpy(token, str);
		    *str = NULL;
		}
		else
		{
            *pwc = NULL;
            wcscpy(token, str);
            wcscpy(str, pwc+1);
		}
        bRet = true;
	}
	return bRet;
}


void StringFromSid(PSID psid, _bstr_t& strSID)
{
	// Initialize m_strSid - human readable form of our SID
	SID_IDENTIFIER_AUTHORITY *psia = NULL;
    psia = ::GetSidIdentifierAuthority(psid);
	WCHAR wstrTmp[_MAX_PATH];

	// We assume that only last byte is used 
    // (authorities between 0 and 15).
	// Correct this if needed.
	ASSERT( psia->Value[0] == 
            psia->Value[1] == 
            psia->Value[2] == 
            psia->Value[3] == 
            psia->Value[4] == 0 );

	DWORD dwTopAuthority = psia->Value[5];

	wsprintf(wstrTmp, L"S-1-%u", dwTopAuthority);

	WCHAR wstrSubAuthority[_MAX_PATH];

	int iSubAuthorityCount = *(GetSidSubAuthorityCount(psid));

	for ( int i = 0; i < iSubAuthorityCount; i++ ) {

		DWORD dwSubAuthority = *(GetSidSubAuthority(psid, i));
		wsprintf(wstrSubAuthority, L"%u", dwSubAuthority);
		wcscat(wstrTmp, L"-");
        wcscat(wstrTmp, wstrSubAuthority);
	}

    strSID = wstrTmp;
}

void RemoveQuotes(LPWSTR wstrObjInstKeyVal)
{
    WCHAR wstrTmp[MAX_PATH] = { L'\0' };
    WCHAR* pwchr = NULL;

    // Get rid of the first quote...
    if((pwchr = wcschr(wstrObjInstKeyVal, L'"')) != NULL)
    {
        wcscpy(wstrTmp, pwchr+1);
    }

    // now the last...
    if((pwchr = wcsrchr(wstrTmp, L'"')) != NULL)
    {
        *pwchr = L'\0';
    }

    wcscpy(wstrObjInstKeyVal, wstrTmp);
}


HRESULT CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;
    OSVERSIONINFOW OsVersionInfoW;

    OsVersionInfoW.dwOSVersionInfoSize = sizeof (OSVERSIONINFOW);
    GetVersionExW(&OsVersionInfoW);

    if (OsVersionInfoW.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        HRESULT hRes = WbemCoImpersonateClient();
        if (SUCCEEDED(hRes)) // From cominit.cpp - needed for nt3.51
        {
            // Now, let's check the impersonation level.  First, get the thread token
            SmartCloseHANDLE hThreadTok;
            DWORD dwImp, dwBytesReturned;

            if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hThreadTok
                ))
            {
                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN)
                {
                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    // If we failed to get the thread token for any other reason, an error.
                    hr = WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // We really do have a thread token, so let's retrieve its level

                if (GetTokenInformation(
                    hThreadTok,
                    TokenImpersonationLevel,
                    &dwImp,
                    sizeof(DWORD),
                    &dwBytesReturned
                    ))
                {
                    // Is the impersonation level Impersonate?
                    if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation))
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                    }
                }
                else
                {
                    hr = WBEM_E_FAILED;
                }
            }

			if (FAILED(hr))
			{
				WbemCoRevertToSelf();
			}
        }
        else if (hRes == E_NOTIMPL)
        {
            // On 3.51 or vanilla 95, this call is not implemented, we should work anyway
            hr = WBEM_S_NO_ERROR;
        }
    }
    else
    {
        // let win9X in...
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}


HRESULT SetStatusObject(
    IWbemContext* pCtx,
    IWbemServices* pSvcs,
    DWORD dwError,
    LPCWSTR wstrErrorDescription,
    LPCWSTR wstrOperation,
    LPCWSTR wstrNamespace,
    IWbemClassObject** ppStatusObjOut)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pStatusObj = NULL;

    ASSERT_BREAK(pCtx != NULL);
    ASSERT_BREAK(pSvcs != NULL);

    if(pSvcs && ppStatusObjOut && pCtx)
    {
        pStatusObj = GetStatusObject(
            pCtx,
            pSvcs);
    
        if(pStatusObj != NULL)
        {
            CVARIANT v;

            // Set the error code:
            v.SetLONG(dwError);
            pStatusObj->Put(
                IDS_WIN32_ERROR_CODE, 
                0, 
                &v, 
                NULL);
            v.Clear();

            // Set the error description
            if(wstrErrorDescription != NULL &&
               *wstrErrorDescription != L'\0')
            {
                v.SetStr(wstrErrorDescription);
                pStatusObj->Put(
                    IDS_ADDITIONAL_DESCRIPTION,
                    0,
                    &v,
                    NULL);
                v.Clear();
            }

            if(wstrOperation != NULL &&
               *wstrOperation != L'\0')
            {
                v.SetStr(wstrOperation);
                pStatusObj->Put(
                    IDS_OPERATION,
                    0,
                    &v,
                    NULL);
                v.Clear();
            }
        }

        if(pStatusObj)
        {
            if(*ppStatusObjOut != NULL)
            {
                (*ppStatusObjOut)->Release();
                *ppStatusObjOut = NULL;
            }
            *ppStatusObjOut = pStatusObj;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}


IWbemClassObject* GetStatusObject(
    IWbemContext* pContext,
    IWbemServices* pSrvc)
{
    ASSERT_BREAK(pContext != NULL);
    ASSERT_BREAK(pSrvc != NULL);
    IWbemClassObjectPtr pStatusObjClass;
    IWbemClassObject* pStatusObjectInstance = NULL;

    if(pContext && pSrvc)
    {
        if(pSrvc)
        {
            // not checking return code, error object should be NULL on error
            pSrvc->GetObject( 
                _bstr_t(JOB_OBJECT_STATUS_OBJECT), 
                0, 
                pContext, 
                &pStatusObjClass, 
                NULL);

            if(pStatusObjClass)
            {
                pStatusObjClass->SpawnInstance(
                    0,
                    &pStatusObjectInstance);
            }   
        }
    }

    ASSERT_BREAK(pStatusObjectInstance);
    return pStatusObjectInstance;
}



void UndecorateNamesInNamedJONameList(
    std::vector<_bstr_t>& rgNamedJOs)
{
    std::vector<_bstr_t> rgUndecoratedNames;
    CHString chstrTemp;

    for(long m = 0L;
        m < rgNamedJOs.size();
        m++)
    {
        UndecorateJOName(
            rgNamedJOs[m],
            chstrTemp);
  
        _bstr_t bstrtTemp((LPCWSTR)chstrTemp);    
        rgUndecoratedNames.push_back(
            bstrtTemp);       
    }

    // Wipe out the original vector...
    rgNamedJOs.clear();

    // Push in new vector's contents...
    for(m = 0L;
        m < rgUndecoratedNames.size();
        m++)
    {
        rgNamedJOs.push_back(
            rgUndecoratedNames[m]);
    }
}



// Takes a decorated job object name and
// undecorates it.  Decorated job object names
// have a backslash preceeding any character
// that should be uppercase once undecorated.
// 
// Due to the way CIMOM handles backslashes,
// we will get capital letters preceeded by
// two, not just one, backslashes.  Hence, we
// must strip them both.
//
// According to the decoration scheme, the
// following are both lower case: 'A' and 'a',
// while the following are both upper case:
// '\a' and '\A'.
//
void UndecorateJOName(
    LPCWSTR wstrDecoratedName,
    CHString& chstrUndecoratedJOName)
{
    if(wstrDecoratedName != NULL &&
        *wstrDecoratedName != L'\0')
    {
        LPWSTR wstrDecoratedNameLower = NULL;

        try
        {
            wstrDecoratedNameLower = new WCHAR[wcslen(wstrDecoratedName)+1];

            if(wstrDecoratedNameLower)
            {
                wcscpy(wstrDecoratedNameLower, wstrDecoratedName);
                _wcslwr(wstrDecoratedNameLower);

                WCHAR* p3 = chstrUndecoratedJOName.GetBuffer(
                    wcslen(wstrDecoratedNameLower) + 1);

                const WCHAR* p1 = wstrDecoratedNameLower;
                const WCHAR* p2 = p1 + 1;

                while(*p1 != L'\0')
                {
                    if(*p1 == L'\\')
                    {
                        if(*p2 != NULL)
                        {
                            // Might have any number of
                            // backslashes back to back,
                            // which we will treat as
                            // being the same as one
                            // backslash - i.e., we will
                            // skip over the backslash(s)
                            // and copy over the following
                            // letter.
                            while(*p2 == L'\\')
                            {
                                p2++;
                            };
                    
                            *p3 = towupper(*p2);
                            p3++;

                            p1 = p2 + 1;
                            if(*p1 != L'\0')
                            {
                                p2 = p1 + 1;
                            }
                        }
                        else
                        {
                            p1++;
                        }
                    }
                    else
                    {
                        *p3 = *p1;
                        p3++;

                        p1 = p2;
                        if(*p1 != L'\0')
                        {
                            p2 = p1 + 1;
                        }
                    }
                }
        
                *p3 = NULL;

                chstrUndecoratedJOName.ReleaseBuffer();

                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
        }
        catch(...)
        {
            if(wstrDecoratedNameLower)
            {
                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
            throw;
        }
    }
}


// Does the inverse of the above function.
// However, here, we only need to put in one
// backslash before each uppercase letter.
// CIMOM will add the second backslash.
void DecorateJOName(
    LPCWSTR wstrUndecoratedName,
    CHString& chstrDecoratedJOName)
{
    if(wstrUndecoratedName != NULL &&
        *wstrUndecoratedName != L'\0')
    {
        // Worst case is that we will have
        // a decorated string twice as long
        // as the undecorated string (happens
        // is every character in the undecorated
        // string is a capital letter).
        WCHAR* p3 = chstrDecoratedJOName.GetBuffer(
            2 * (wcslen(wstrUndecoratedName) + 1));

        const WCHAR* p1 = wstrUndecoratedName;

        while(*p1 != L'\0')
        {
            if(iswupper(*p1))
            {
                // Add in a backslash...
                *p3 = L'\\';
                p3++;

                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
            else
            {
                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
        }

        *p3 = NULL;
        
        chstrDecoratedJOName.ReleaseBuffer();

        // What if we had a job called Job,
        // and someone specified it in the
        // object path as "Job" instead of
        // "\Job"?  We DON'T want to find it
        // in such a case, because this would
        // appear to not be adhering to our
        // own convention.  Hence, we 
        // lowercase the incoming string.
        chstrDecoratedJOName.MakeLower();
    }
}


// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;

	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PRINTER_NAME:
		case ERROR_BAD_USERNAME:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}


// Copied from sid.h
bool GetNameAndDomainFromPSID(
    PSID pSid,
    CHString& chstrName,
    CHString& chstrDomain)
{
	bool fRet = false;
    // pSid should be valid...
	_ASSERT( (pSid != NULL) && ::IsValidSid( pSid ) );

	if ( (pSid != NULL) && ::IsValidSid( pSid ) )
	{
		// Initialize account name and domain name
		LPTSTR pszAccountName = NULL;
		LPTSTR pszDomainName = NULL;
		DWORD dwAccountNameSize = 0;
		DWORD dwDomainNameSize = 0;
        DWORD dwLastError = ERROR_SUCCESS;
        BOOL bResult = TRUE;

		try
        {
			// This call should fail
            SID_NAME_USE	snuAccountType;
			bResult = ::LookupAccountSid(   NULL,
											pSid,
											pszAccountName,
											&dwAccountNameSize,
											pszDomainName,
											&dwDomainNameSize,
											&snuAccountType );
			dwLastError = ::GetLastError();

		    if ( ERROR_INSUFFICIENT_BUFFER == dwLastError )
		    {

			    // Allocate buffers
			    if ( dwAccountNameSize != 0 )
                {
				    pszAccountName = (LPTSTR) new TCHAR[ dwAccountNameSize * sizeof(TCHAR) ];
                }

			    if ( dwDomainNameSize != 0 )
                {
				    pszDomainName = (LPTSTR) new TCHAR[ dwDomainNameSize * sizeof(TCHAR) ];
                }

				// Make second call
				bResult = ::LookupAccountSid(   NULL,
												pSid,
												pszAccountName,
												&dwAccountNameSize,
												pszDomainName,
												&dwDomainNameSize,
												&snuAccountType );


			    if ( bResult == TRUE )
			    {
				    chstrName = pszAccountName;
				    chstrDomain = pszDomainName;
			    }
			    else
			    {

				    // There are some accounts that do not have names, such as Logon Ids,
				    // for example S-1-5-X-Y. So this is still legal
				    chstrName = _T("Unknown Account");
				    chstrDomain = _T("Unknown Domain");
			    }

			    if ( NULL != pszAccountName )
			    {
				    delete pszAccountName;
                    pszAccountName = NULL;
			    }

			    if ( NULL != pszDomainName )
			    {
				    delete pszDomainName;
                    pszDomainName = NULL;
			    }

                fRet = true;

		    }	// If ERROR_INSUFFICIENT_BUFFER
        } // try
        catch(...)
        {
            if ( NULL != pszAccountName )
			{
				delete pszAccountName;
                pszAccountName = NULL;
			}

			if ( NULL != pszDomainName )
			{
				delete pszDomainName;
                pszDomainName = NULL;
			}
            throw;
        }
	}	// IF IsValidSid

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\globals.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Globals.cpp


#include "precomp.h"
//#include <windows.h>
//#include <objbase.h>
//#include <comdef.h>
#include "CUnknown.h"
#include "factory.h"
#include "Registry.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjProps.h"
#include "JobObjectProv.h"
#include "CJobObjIOActgProps.h"
#include "JobObjIOActgInfoProv.h"
#include "CJobObjLimitInfoProps.h"
#include "JobObjLimitInfoProv.h"
#include "CJobObjSecLimitInfoProps.h"
#include "JobObjSecLimitInfoProv.h"
#include <initguid.h>
#include "Globals.h"



/*****************************************************************************/
// Globals
/*****************************************************************************/



//
// This file contains the component server code.
// The FactoryDataArray contains the components that 
// can be served.
//

// Each component derived from Unknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(CUnknown** ppNewComponent) ;
// This function is used to create the component.
//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
	{   
        &CLSID_JobObjectProvComp,                           // Component class id
        CJobObjectProv::CreateInstance,                     // Name of the component's creation function
		L"Win32_JobObject Provider Component",              // Friendly name
		L"JobObjectProv.JobObjectProv.1",                   // ProgID
		L"JobObjectProv.JobObjectProv"                      // Version-independent ProgID
    },
    {
        &CLSID_JobObjIOActgInfoComp,                        // Component class id
        CJobObjIOActgInfoProv::CreateInstance,              // Name of the component's creation function
		L"Win32_JobObjectIOAccountingInfo Component",       // Friendly name
		L"JobObjIOActgInfoProv.JobObjIOActgInfoProv.1",     // ProgID
		L"JobObjIOActgInfoProv.JobObjIOActgInfoProv"        // Version-independent ProgID
    },
    {
        &CLSID_JobObjLimitInfoComp,                         // Component class id
        CJobObjLimitInfoProv::CreateInstance,               // Name of the component's creation function
		L"Win32_JobObjectLimitInfo Component",              // Friendly name
		L"JobObjLimitInfoProv.JobObjLimitInfoProv.1",       // ProgID
		L"JobObjLimitInfoProv.JobObjLimitInfoProv"          // Version-independent ProgID
    },
    {
        &CLSID_JobObjSecLimitInfoComp,                      // Component class id
        CJobObjSecLimitInfoProv::CreateInstance,            // Name of the component's creation function
		L"Win32_JobObjectSecLimitInfo Component",           // Friendly name
		L"JobObjSecLimitInfoProv.JobObjSecLimitInfoProv.1", // ProgID
		L"JobObjSecLimitInfoProv.JobObjSecLimitInfoProv"    // Version-independent ProgID
    }

} ;

int g_cFactoryDataEntries = 
    sizeof(g_FactoryDataArray)/sizeof(CFactoryData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\helpers.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Helpers.h:  Prototypes for helper functions for JobObjectProv component.


#pragma once



_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));


#define JOB_OBJECT_STATUS_OBJECT L"Win32_JobObjectStatus"
#define JOB_OBJECT_NAMESPACE L"root\\cimv2"


class SmartCloseHANDLE
{

private:
	HANDLE m_h;

public:
	SmartCloseHANDLE():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHANDLE(HANDLE h):m_h(h){}
   ~SmartCloseHANDLE(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};





HRESULT CreateInst(
    IWbemServices *pNamespace, 
    IWbemClassObject **pNewInst,
    BSTR bstrClassName,
    IWbemContext *pCtx);


HRESULT GetObjInstKeyVal(
    const BSTR ObjectPath,
    LPCWSTR wstrClassName,
    LPCWSTR wstrKeyPropName, 
    LPWSTR wstrObjInstKeyVal, 
    long lBufLen);



HRESULT GetJobObjectList(
    std::vector<_bstr_t>& rgbstrtJOList);



bool WINAPI WhackToken(
    LPWSTR str, 
    LPWSTR token);

bool WINAPI StrToIdentifierAuthority(
    LPCWSTR str, 
    SID_IDENTIFIER_AUTHORITY& identifierAuthority);

PSID WINAPI StrToSID(LPCWSTR wstrIncommingSid);

void StringFromSid(PSID psid, _bstr_t& strSID);

void RemoveQuotes(LPWSTR wstrObjInstKeyVal);

HRESULT CheckImpersonationLevel();

HRESULT SetStatusObject(
    IWbemContext* pContext,
    IWbemServices* pSvcs,
    DWORD dwError,
    LPCWSTR wstrErrorDescription,
    LPCWSTR wstrOperation,
    LPCWSTR wstrNamespace,
    IWbemClassObject** ppStatusObjOut);

IWbemClassObject* GetStatusObject(
    IWbemContext* pContext,
    IWbemServices* pSvcs);

void UndecorateJOName(
    LPCWSTR wstrDecoratedName,
    CHString& chstrUndecoratedJOName);

void DecorateJOName(
    LPCWSTR wstrUndecoratedName,
    CHString& chstrDecoratedJOName);

void UndecorateNamesInNamedJONameList(
    std::vector<_bstr_t>& rgNamedJOs);

HRESULT WinErrorToWBEMhResult(LONG error);

bool GetNameAndDomainFromPSID(
    PSID psid,
    CHString& chstrName,
    CHString& chstrDomain);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\globals.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Globals.h


// {7FB1D98A-F895-4761-8DC2-774969C84D10}
DEFINE_GUID(CLSID_JobObjectProvComp, 
0x7fb1d98a, 0xf895, 0x4761, 0x8d, 0xc2, 0x77, 0x49, 0x69, 0xc8, 0x4d, 0x10);


// {C0AA9D93-2EF5-47fb-960C-F90FC644B48E}
DEFINE_GUID(CLSID_JobObjIOActgInfoComp, 
0xc0aa9d93, 0x2ef5, 0x47fb, 0x96, 0xc, 0xf9, 0xf, 0xc6, 0x44, 0xb4, 0x8e);


// {6515834D-6125-4878-A3A3-6B0A73B809A2}
DEFINE_GUID(CLSID_JobObjLimitInfoComp, 
0x6515834d, 0x6125, 0x4878, 0xa3, 0xa3, 0x6b, 0xa, 0x73, 0xb8, 0x9, 0xa2);

// {AB40A5C1-804B-40bd-9DFE-A640691C6956}
DEFINE_GUID(CLSID_JobObjSecLimitInfoComp, 
0xab40a5c1, 0x804b, 0x40bd, 0x9d, 0xfe, 0xa6, 0x40, 0x69, 0x1c, 0x69, 0x56);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\factory.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Factory.cpp
#include "precomp.h"
#include <iostream.h>
#include <objbase.h>
#include "CUnknown.h"
#include "factory.h"
#include "Registry.h"


// Set static members
LONG CFactory::s_cServerLocks = 0L ;   // Count of locks
HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

extern CFactoryData g_FactoryDataArray[];


/*****************************************************************************/
// Class factory constructor
/*****************************************************************************/
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
	m_pFactoryData = pFactoryData ;
    LockServer(TRUE);
}

/*****************************************************************************/
// Class factory IUnknown implementation
/*****************************************************************************/

STDMETHODIMP CFactory::QueryInterface(const IID& iid, void** ppv)
{    
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this) ; 
	}
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
	return S_OK ;
}

STDMETHODIMP_(ULONG) CFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG) CFactory::Release() 
{
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}

/*****************************************************************************/
// IClassFactory implementation
/*****************************************************************************/

STDMETHODIMP CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                      const IID& iid,
                                      void** ppv) 
{
	HRESULT hr = S_OK;
    // Cannot aggregate.
	if (pUnknownOuter != NULL)
	{
		hr = CLASS_E_NOAGGREGATION;
	}

    if(SUCCEEDED(hr))
    {
	    // Create component using the specific component's version of CreateInstance.
        CUnknown* pNewComponent ;
	    hr = m_pFactoryData->CreateInstance(&pNewComponent) ;
    
        if(SUCCEEDED(hr))
        {
	        // Initialize the component
            hr = pNewComponent->Init();
            if(SUCCEEDED(hr))
            {
                // Get the requested interface.
	            hr = pNewComponent->QueryInterface(iid, ppv);
            }
            // Release the IUnknown pointer (the new AND the QI incremented the refcount on SUC.
	        // (If QueryInterface failed, component will delete itself.)
	        pNewComponent->Release();
        }
    }
	return hr ;
}

/*****************************************************************************/
// Lock server
/*****************************************************************************/
STDMETHODIMP CFactory::LockServer(BOOL bLock) 
{
	if (bLock)
	{
		InterlockedIncrement(&s_cServerLocks) ; 
	}
	else
	{
		InterlockedDecrement(&s_cServerLocks) ;
	}
	return S_OK ;
}

/*****************************************************************************/
// GetClassObject - Create a class factory based on a CLSID.
/*****************************************************************************/
HRESULT CFactory::GetClassObject(const CLSID& clsid,
                                 const IID& iid,
                                 void** ppv)
{
	HRESULT hr = S_OK;

    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
	{
		hr = E_NOINTERFACE ;
	}

    if(SUCCEEDED(hr))
    {
	    // Traverse the array of data looking for this class ID.
	    for (int i = 0; i < g_cFactoryDataEntries; i++)
	    {
		    if(g_FactoryDataArray[i].IsClassID(clsid))
		    {
			    // Found the ClassID in the array of components we can
			    // create.  So create a class factory for this component.
			    // Pass the CFactoryData structure to the class factory
			    // so that it knows what kind of components to create.
                const CFactoryData* pData = &g_FactoryDataArray[i] ;
			    CFactory* pFactory = new CFactory(pData);
			    if (pFactory == NULL)
			    {
				    hr = E_OUTOFMEMORY ;
			    }
                else
                {
                    // Get requested interface.
	                HRESULT hr = pFactory->QueryInterface(iid, ppv);
	                pFactory->Release();
                }
			    break;
		    }
	    }
        if(i == g_cFactoryDataEntries)
        {
            hr = CLASS_E_CLASSNOTAVAILABLE;
        }
    }
	return hr;
}

/*****************************************************************************/
// Register all components.
/*****************************************************************************/
HRESULT CFactory::RegisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
	{
		RegisterServer(s_hModule,
		               *(g_FactoryDataArray[i].m_pCLSID),
		               g_FactoryDataArray[i].m_RegistryName,
		               g_FactoryDataArray[i].m_szVerIndProgID,
		               g_FactoryDataArray[i].m_szProgID) ;
	}
	return S_OK ;
}

/*****************************************************************************/
// Un-register all components
/*****************************************************************************/
HRESULT CFactory::UnregisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
	{
		UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
		                 g_FactoryDataArray[i].m_szVerIndProgID,
		                 g_FactoryDataArray[i].m_szProgID) ;

	}
	return S_OK ;
}

/*****************************************************************************/
// Determine if the component can be unloaded.
/*****************************************************************************/
HRESULT CFactory::CanUnloadNow()
{
	if (CUnknown::ActiveComponents() || IsLocked())
	{
		return S_FALSE ;
	}
	else
	{
		return S_OK ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobase.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JOBase.cpp


#include "precomp.h"
//#include <windows.h>
//#include <cominit.h>
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"
#include "CVARIANT.h"
#include "CObjProps.h"
#include "JOBase.h"
#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include "AssertBreak.h"






HRESULT CJOBase::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace) pNamespace->AddRef();
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;

    //Let CIMOM know you are initialized
    pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);

    return WBEM_S_NO_ERROR;
}



HRESULT CJOBase::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    CObjProps& objprops,
    PFN_CHECK_PROPS pfnChk,
    LPWSTR wstrClassName,
    LPCWSTR wstrKeyProp)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // We need the name of the instance they requested...
    WCHAR wstrObjInstKeyVal[MAX_PATH];
    hr = GetObjInstKeyVal(
           ObjectPath,
           wstrClassName,
           wstrKeyProp, 
           wstrObjInstKeyVal, 
           sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
    if(SUCCEEDED(hr))
    {
        // wstrObjInstKeyVal now contains the name of the object.  See if
        // it exists...
        SmartHandle hJob;
        hJob = ::OpenJobObject(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   wstrObjInstKeyVal);

        if(hJob)
        {
            // We seem to have found one matching the specified name,
            // so create a return instance...
            objprops.SetJobHandle(hJob);
            IWbemClassObjectPtr pIWCO = NULL;

            hr = CreateInst(
                     m_pNamespace,
                     &pIWCO,
                     _bstr_t(wstrClassName),
                     pCtx);

            if(SUCCEEDED(hr))
            {
                // see what properties are requested...
                hr = objprops.GetWhichPropsReq(
                         ObjectPath,
                         pCtx,
                         wstrClassName,
                         pfnChk);
            }
                
            if(SUCCEEDED(hr))
            {
                // set the key properties...
                hr = objprops.SetKeysFromPath(
                       ObjectPath,
                       pCtx);
            }

            if(SUCCEEDED(hr))
            {
                // set the non-key requested properties...
                hr = objprops.SetNonKeyReqProps();
            }

            if(SUCCEEDED(hr))
            {
                // Load requested non-key properties 
                // to the instance...
                hr = objprops.LoadPropertyValues(
                         pIWCO);

                // Commit the instance...
                if(SUCCEEDED(hr))
                {
                    hr = pResponseHandler->Indicate(
                             1,
                             &pIWCO);
                }
            }
        }
    }

    // Set Status
    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    return hr;
}




HRESULT CJOBase::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    CObjProps& objprops,
    LPCWSTR wstrClassName,
    LPCWSTR wstrKeyProp)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We will optimize for those cases in which
    // a particular set of named job objects
    // (e.g., 1 or more).  Enumerate also
    // optimizes for the properties that were
    // requested.
    CFrameworkQuery cfwq;
    hr = cfwq.Init(
             QueryLanguage,
             Query,
             lFlags,
             m_chstrNamespace);

    std::vector<_bstr_t> rgNamedJOs;
    if(SUCCEEDED(hr))
    {
        hr = cfwq.GetValuesForProp(
                 _bstr_t(wstrKeyProp), 
                 rgNamedJOs);
    }

    if(SUCCEEDED(hr))
    {
        hr = Enumerate(
                 pCtx,
                 pResponseHandler,
                 rgNamedJOs,
                 objprops,
                 wstrClassName);
    }

    return hr;
}




HRESULT CJOBase::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    CObjProps& objprops,
    LPCWSTR wstrClassName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(wcsicmp(
           Class, 
           wstrClassName) != NULL)
    {
        hr = WBEM_E_INVALID_CLASS;
    }

    // For every job object, return all accounting
    // info properties...
    if(SUCCEEDED(hr))
    {
        // Get a list of named jobs...
        std::vector<_bstr_t> rgNamedJOs;
        hr = GetJobObjectList(rgNamedJOs);

        if(SUCCEEDED(hr))
        {
            hr = Enumerate(
                     pCtx,
                     pResponseHandler,
                     rgNamedJOs,
                     objprops,
                     wstrClassName);
        }
    }
    return hr;
}




HRESULT CJOBase::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CObjProps& objprops,
    LPCWSTR wstrClassName)
{
    HRESULT hr = S_OK;

    long lNumJobs = rgNamedJOs.size();

    try // CVARIANT can throw and I want the error...
    {
        if(lNumJobs > 0)
        {
            // Create an object path...
            _bstr_t bstrtObjPath;
            bstrtObjPath = wstrClassName;

            // Get which props requested...
            hr = objprops.GetWhichPropsReq(
                     bstrtObjPath,
                     pCtx);

            if(SUCCEEDED(hr))
            {
                SmartHandle hJob;

                for(long m = 0L; m < lNumJobs; m++)
                {
                    // We have the name of a JO; need to open it up
                    // and get its properties...
                    hJob = ::OpenJobObject(
                       MAXIMUM_ALLOWED,
                       FALSE,
                       (LPCWSTR)(rgNamedJOs[m]));
                    // (NOTE: hJob smarthandle class automatically
                    // closes its handle on destruction and on
                    // reassignment.)
                    if(hJob)
                    {
                        // Set the handle...
                        objprops.SetJobHandle(hJob);

                        // Set the key properties directly...
                        std::vector<CVARIANT> vecvKeys;
                        CVARIANT vID(rgNamedJOs[m]);
                        vecvKeys.push_back(vID);
                        hr = objprops.SetKeysDirect(vecvKeys);

                        if(SUCCEEDED(hr))
                        {
                            // set the non-key requested 
                            // properties...
                            hr = objprops.SetNonKeyReqProps();
                        }

                        // Create a new outgoing instance...
                        IWbemClassObjectPtr pIWCO = NULL;
                        if(SUCCEEDED(hr))
                        {
                            hr = CreateInst(
                                     m_pNamespace,
                                     &pIWCO,
                                     _bstr_t(wstrClassName),
                                     pCtx);
                        }

                        // Load the properties of the 
                        // new outgoing instance...
                        if(SUCCEEDED(hr))
                        {
                            hr = objprops.LoadPropertyValues(pIWCO);
                        }

                        // And send it out...
                        if(SUCCEEDED(hr))
                        {
                            hr = pResponseHandler->Indicate(
                                     1, 
                                     &pIWCO);
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);
                    }
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobase.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JOBase.h

#pragma once


_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));



class CJOBase
{
public:

    CJOBase() {}
    virtual ~CJOBase() {}

    HRESULT Initialize(
         LPWSTR pszUser,
         LONG lFlags,
         LPWSTR pszNamespace,
         LPWSTR pszLocale,
         IWbemServices *pNamespace,
         IWbemContext *pCtx,
         IWbemProviderInitSink *pInitSink);

    HRESULT GetObjectAsync( 
        const BSTR ObjectPath,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        CObjProps& objprops,
        PFN_CHECK_PROPS pfnChk,
        LPWSTR wstrClassName,
        LPCWSTR wstrKeyProp);

    HRESULT ExecQueryAsync( 
        const BSTR QueryLanguage,
        const BSTR Query,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        CObjProps& objprops,
        LPCWSTR wstrClassName,
        LPCWSTR wstrKeyProp);

    HRESULT CreateInstanceEnumAsync( 
        const BSTR Class,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        CObjProps& objprops,
        LPCWSTR wstrClassName);

    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CObjProps& objprops,
        LPCWSTR wstrClassName);


protected:

    IWbemServicesPtr m_pNamespace;
    CHString m_chstrNamespace;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\factory.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// Factory.h
#pragma once

class CFactoryData;
class CFactory;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

typedef HRESULT (*FPCREATEINSTANCE)(CUnknown**) ;



///////////////////////////////////////////////////////////
//
// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
//
class CFactoryData
{
public:

    // The class ID for the component
	const CLSID* m_pCLSID ;

	// Pointer to the function that creates it
	FPCREATEINSTANCE CreateInstance ;

	// Name of the component to register in the registry
	LPCWSTR m_RegistryName ;

	// ProgID
	LPCWSTR m_szProgID ;

	// Version-independent ProgID
	LPCWSTR m_szVerIndProgID ;

	// Helper function for finding the class ID
	BOOL IsClassID(const CLSID& clsid) const
		{ return (*m_pCLSID == clsid) ;}
};




class CFactory : public IClassFactory
{
public:
	// IUnknown
	STDMETHOD(QueryInterface) (const IID& iid, void** ppv);
	STDMETHOD_(ULONG,AddRef) ();
	STDMETHOD_(ULONG,Release)();

	// IClassFactory
	STDMETHOD(CreateInstance) (IUnknown* pUnknownOuter,
	                           const IID& iid,
	                           void** ppv);

	STDMETHOD(LockServer) (BOOL bLock); 

    // Constructor - Pass pointer to data of component to create.
	CFactory(const CFactoryData* pFactoryData) ;

	// Destructor
	~CFactory() { LockServer(FALSE); }


    //
	// Static FactoryData support functions
	//

	// DllGetClassObject support
	static HRESULT GetClassObject(const CLSID& clsid,
	                              const IID& iid, 
	                              void** ppv) ;

	// Helper function for DllCanUnloadNow 
	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
	static HRESULT RegisterAll() ;
	static HRESULT UnregisterAll() ;

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;


public:
    // Reference count
    long m_cRef ;

	// Pointer to information about class this factory creates
	const CFactoryData* m_pFactoryData ;
      
	// Count of locks
	static LONG s_cServerLocks ;

	// Module handle
	static HMODULE s_hModule ;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjioactginfoprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjIOActgInfoProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjIOActgProps.h"
#include "JobObjIOActgInfoProv.h"





/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjIOActgInfoProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjIOActgInfoProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjIOActgInfoProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjIOActgInfoProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;
    //Let CIMOM know you are initialized
    //==================================
    
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjIOActgInfoProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_JobObjectIOAccountingInfo,
                   g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjIOActgProps cjoioap(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_JobObjectIOAccountingInfo),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjoioap.SetReqProps(PROP_ALL_REQUIRED);;
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjoioap.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjoioap.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjoioap.LoadPropertyValues(
                                 pIWCO);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjIOActgInfoProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjIOActgPropNames[JOIOACTGPROP_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }

            // Find out what propeties were requested...
            CJobObjIOActgProps cjoioap(m_chstrNamespace);
            cjoioap.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjoioap,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjIOActgInfoProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(
                   Class, 
                   IDS_Win32_JobObjectIOAccountingInfo) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all accounting
            // info properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjIOActgProps cjoioap(m_chstrNamespace);
                    cjoioap.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjoioap,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}







/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjIOActgInfoProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjIOActgProps& cjoaip,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    long lNumJobs = rgNamedJOs.size();

    try // CVARIANT can throw and I want the error...
    {
        if(lNumJobs > 0)
        {
            SmartHandle hJob;

            for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
            {
                cjoaip.ClearProps();

                // We have the name of a JO; need to open it up
                // and get its properties...
                hJob = ::OpenJobObjectW(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   rgNamedJOs[m]);

                // (NOTE: hJob smarthandle class automatically
                // closes its handle on destruction and on
                // reassignment.)
                if(hJob)
                {
                    // Set the handle...
                    cjoaip.SetHandle(hJob);

                    // Set the key properties directly...
                    CHString chstrDecoratedJOName;
                    DecorateJOName(
                        rgNamedJOs[m],
                        chstrDecoratedJOName);

                    std::vector<CVARIANT> vecvKeys;
                    CVARIANT vID(chstrDecoratedJOName);
                    vecvKeys.push_back(vID);
                    hr = cjoaip.SetKeysDirect(vecvKeys);

                    if(FAILED(hr))
                    {
                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"CJobObjIOActgProps::SetKeysDirect",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested 
                        // properties...
                        hr = cjoaip.SetNonKeyReqProps();
                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjIOActgProps::SetNonKeyReqProps",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Create a new outgoing instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    if(SUCCEEDED(hr))
                    {
                        hr = CreateInst(
                                 m_pNamespace,
                                 &pIWCO,
                                 _bstr_t(IDS_Win32_JobObjectIOAccountingInfo),
                                 pCtx);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjIOActgInfoProv::CreateInst",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Load the properties of the 
                    // new outgoing instance...
                    if(SUCCEEDED(hr))
                    {
                        hr = cjoaip.LoadPropertyValues(pIWCO);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjIOActgInfoProv::LoadPropertyValues",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // And send it out...
                    if(SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                        hr = pResponseHandler->Indicate(
                                 1, 
                                 &pTmp);
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        ppStatusObject);
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjectprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.h

#pragma once



#define JOB_OBJECT_PROVIDER L"NamedJobObjectProv"




_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

/*****************************************************************************/
// Component 
/*****************************************************************************/

class CJobObjectProv;

class CJobObjectProv : public CUnknown,
                       public IWbemServices,
                       public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjectProv();

	// Destructor
	virtual ~CJobObjectProv();
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);

    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}



private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjProps& cjop,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjlimitinfoprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjLimitInfoProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjLimitInfoProps.h"
#include "JobObjLimitInfoProv.h"





/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjLimitInfoProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjLimitInfoProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjLimitInfoProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjLimitInfoProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;
    //Let CIMOM know you are initialized
    //==================================
    
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjLimitInfoProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_NamedJobObjectLimitSetting,
                   g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjLimitInfoProps cjolip(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_NamedJobObjectLimitSetting),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjolip.SetReqProps(PROP_ALL_REQUIRED);;
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjolip.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjolip.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjolip.LoadPropertyValues(
                                 pIWCO);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjLimitInfoProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;
    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjLimitInfoPropNames[JOLMTPROP_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }

            // Find out what propeties were requested...
            CJobObjLimitInfoProps cjolip(m_chstrNamespace);
            cjolip.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjolip,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjLimitInfoProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(
                   Class, 
                   IDS_Win32_NamedJobObjectLimitSetting) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all accounting
            // info properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjLimitInfoProps cjolip(m_chstrNamespace);
                    cjolip.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjolip,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}







/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjLimitInfoProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjLimitInfoProps& cjolip,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    long lNumJobs = rgNamedJOs.size();

    try // CVARIANT can throw and I want the error...
    {
        if(lNumJobs > 0)
        {
            SmartHandle hJob;

            for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
            {
                cjolip.ClearProps();

                // We have the name of a JO; need to open it up
                // and get its properties...
                hJob = ::OpenJobObjectW(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   rgNamedJOs[m]);

                // (NOTE: hJob smarthandle class automatically
                // closes its handle on destruction and on
                // reassignment.)
                if(hJob)
                {
                    // Set the handle...
                    cjolip.SetHandle(hJob);

                    // Set the key properties directly...
                    CHString chstrDecoratedJOName;
                    DecorateJOName(
                        rgNamedJOs[m],
                        chstrDecoratedJOName);

                    std::vector<CVARIANT> vecvKeys;
                    CVARIANT vID(chstrDecoratedJOName);
                    vecvKeys.push_back(vID);
                    hr = cjolip.SetKeysDirect(vecvKeys);

                    if(FAILED(hr))
                    {
                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"CJobObjLimitInfoProps::SetKeysDirect",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested 
                        // properties...
                        hr = cjolip.SetNonKeyReqProps();

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjLimitInfoProps::SetNonKeyReqProps",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Create a new outgoing instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    if(SUCCEEDED(hr))
                    {
                        hr = CreateInst(
                                 m_pNamespace,
                                 &pIWCO,
                                 _bstr_t(IDS_Win32_NamedJobObjectLimitSetting),
                                 pCtx);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjLimitInfoProv::CreateInst",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Load the properties of the 
                    // new outgoing instance...
                    if(SUCCEEDED(hr))
                    {
                        hr = cjolip.LoadPropertyValues(pIWCO);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjLimitInfoProps::LoadPropertyValues",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // And send it out...
                    if(SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                        hr = pResponseHandler->Indicate(
                                 1, 
                                 &pTmp);
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        ppStatusObject);
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjioactginfoprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjIOActgProv.h

#pragma once





_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

/*****************************************************************************/
// Component 
/*****************************************************************************/


class CJobObjIOActgInfoProv : public CUnknown,
                              public IWbemServices, 
                              public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjIOActgInfoProv(){}

	// Destructor
	virtual ~CJobObjIOActgInfoProv(){}
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);
	
    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjIOActgProps& cjoioap,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;
        
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjectprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjectProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>
#include <objidl.h>
#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjProps.h"
#include "JobObjectProv.h"
#include "Helpers.h"



CJobObjectProv::CJobObjectProv()
{
}


CJobObjectProv::~CJobObjectProv()
{
}

/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjectProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjectProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjectProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjectProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(pNamespace) 
    {   // smartptr does the addref
        m_pNamespace = pNamespace;
    }
    m_chstrNamespace = pszNamespace;

    //Let CIMOM know I am initialized...
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjectProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_NamedJobObject,
                   g_rgJobObjPropNames[JO_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjProps cjop(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_NamedJobObject),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjop.SetReqProps(PROP_ALL_REQUIRED);
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjop.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjop.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjop.LoadPropertyValues(
                                 pIWCO);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjectProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();
        IWbemClassObjectPtr pStatusObject;

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjPropNames[JO_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }

            // Find out what propeties were requested...
            CJobObjProps cjop(m_chstrNamespace);
            cjop.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjop,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"Helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    hr = pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
    return hr;
}


STDMETHODIMP CJobObjectProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();
    
        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(Class, IDS_Win32_NamedJobObject) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjProps cjop(m_chstrNamespace);
                    cjop.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjop,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"Helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}





/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjectProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjProps& cjop,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    try // CVARIANT can throw and I want the error...
    {
        long lNumJobs = rgNamedJOs.size();

        if(lNumJobs > 0)
        {
            SmartHandle hJob;

            for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
            {
                cjop.ClearProps();

                // We have the name of a JO; need to open it up
                // and get its properties...
                hJob = ::OpenJobObjectW(
                   MAXIMUM_ALLOWED,
                   FALSE,
                   rgNamedJOs[m]);

                // (NOTE: hJob smarthandle class automatically
                // closes its handle on destruction and on
                // reassignment.)
                if(hJob)
                {
                    // Set the handle...
                    cjop.SetHandle(hJob);

                    // Set the key properties directly...
                    CHString chstrDecoratedJOName;
                    DecorateJOName(
                        rgNamedJOs[m],
                        chstrDecoratedJOName);

                    std::vector<CVARIANT> vecvKeys;
                    CVARIANT vID(chstrDecoratedJOName);
                    vecvKeys.push_back(vID);
                    hr = cjop.SetKeysDirect(vecvKeys);

                    if(FAILED(hr))
                    {
                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"CJobObjProps::SetKeysDirect",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested 
                        // properties...
                        hr = cjop.SetNonKeyReqProps();

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjProps::SetNonKeyReqProps",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Create a new outgoing instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    if(SUCCEEDED(hr))
                    {
                        hr = CreateInst(
                                 m_pNamespace,
                                 &pIWCO,
                                 _bstr_t(IDS_Win32_NamedJobObject),
                                 pCtx);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjectProv::CreateInst",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // Load the properties of the 
                    // new outgoing instance...
                    if(SUCCEEDED(hr))
                    {
                        hr = cjop.LoadPropertyValues(pIWCO);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjProps::LoadPropertyValues",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }
                    }

                    // And send it out...
                    if(SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                        hr = pResponseHandler->Indicate(
                                 1, 
                                 &pTmp);
                    }
                }
                else
                {
                    _ASSERT(0);

                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"CJobObjectProv::Enumerate",
                        JOB_OBJECT_NAMESPACE,
                        ppStatusObject);
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjlimitinfoprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjLimitInfoProv.h

#pragma once





_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

/*****************************************************************************/
// Component 
/*****************************************************************************/


class CJobObjLimitInfoProv : public CUnknown,
                             public IWbemServices, 
                             public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjLimitInfoProv(){}

	// Destructor
	virtual ~CJobObjLimitInfoProv(){}
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);
	
    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjLimitInfoProps& cjolip,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;
        
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjseclimitinfoprov.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjSecLimitInfoProv.cpp

//#define _WIN32_WINNT 0x0500 

#include "precomp.h"
//#include <windows.h>
#include "cominit.h"
//#include <objbase.h>
//#include <comdef.h>

#include "CUnknown.h"
#include <wbemprov.h>
#include "FRQueryEx.h"
#include "globals.h"

#include "Factory.h"
#include "helpers.h"
#include <map>
#include <vector>
#include "SmartHandle.h"
#include <crtdbg.h>
#include "CVARIANT.h"
#include "CObjProps.h"
#include "CJobObjSecLimitInfoProps.h"
#include "JobObjSecLimitInfoProv.h"





/*****************************************************************************/
// QueryInterface override to allow for this component's interface(s)
/*****************************************************************************/
STDMETHODIMP CJobObjSecLimitInfoProv::QueryInterface(const IID& iid, void** ppv)
{    
	HRESULT hr = S_OK;

    if(iid == IID_IWbemServices)
    {
        *ppv = static_cast<IWbemServices*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else if(iid == IID_IWbemProviderInit)
    {
        *ppv = static_cast<IWbemProviderInit*>(this);
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }
    else
    {
        hr = CUnknown::QueryInterface(iid, ppv);
    }

	return hr;
}



/*****************************************************************************/
// Creation function used by CFactory
/*****************************************************************************/
HRESULT CJobObjSecLimitInfoProv::CreateInstance(CUnknown** ppNewComponent)
{
	HRESULT hr = S_OK;
    CUnknown* pUnk = NULL;
    pUnk = new CJobObjSecLimitInfoProv;
    if(pUnk != NULL)
    {
        *ppNewComponent = pUnk;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
	return hr ;
}

/*****************************************************************************/
// IWbemProviderInit implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjSecLimitInfoProv::Initialize(
    LPWSTR pszUser, 
    LONG lFlags,
    LPWSTR pszNamespace, 
    LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    m_pNamespace = pNamespace;
    m_chstrNamespace = pszNamespace;
    //Let CIMOM know you are initialized
    //==================================
    
    return pInitSink->SetStatus(
        WBEM_S_INITIALIZED,
        0);
}


/*****************************************************************************/
// IWbemServices implementation
/*****************************************************************************/             
STDMETHODIMP CJobObjSecLimitInfoProv::GetObjectAsync( 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We need the name of the instance they requested...
            WCHAR wstrObjInstKeyVal[MAX_PATH];
            hr = GetObjInstKeyVal(
                   ObjectPath,
                   IDS_Win32_NamedJobObjectSecLimitSetting,
                   g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID], 
                   wstrObjInstKeyVal, 
                   sizeof(wstrObjInstKeyVal) - sizeof(WCHAR));
    
            if(SUCCEEDED(hr))
            {
                // wstrObjInstKeyVal now contains the name of the object.  See if
                // it exists...
                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    wstrObjInstKeyVal,
                    chstrUndecoratedJOName);

                SmartHandle hJob;
                hJob = ::OpenJobObjectW(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);

                if(hJob)
                {
                    // We seem to have found one matching the specified name,
                    // so create a return instance...
                    IWbemClassObjectPtr pIWCO = NULL;
                    CJobObjSecLimitInfoProps cjoslip(hJob, m_chstrNamespace);

                    hr = CreateInst(
                             m_pNamespace,
                             &pIWCO,
                             _bstr_t(IDS_Win32_NamedJobObjectSecLimitSetting),
                             pCtx);

                    if(SUCCEEDED(hr))
                    {
                        cjoslip.SetReqProps(PROP_ALL_REQUIRED);
                    }
                
                    if(SUCCEEDED(hr))
                    {
                        // set the key properties...
                        hr = cjoslip.SetKeysFromPath(
                               ObjectPath,
                               pCtx);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // set the non-key requested properties...
                        hr = cjoslip.SetNonKeyReqProps();
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load requested non-key properties 
                        // to the instance...
                        hr = cjoslip.LoadPropertyValues(
                                 pIWCO,
                                 pCtx,
                                 m_pNamespace);

                        // Commit the instance...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1,
                                     &pTmp);
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_NOT_FOUND;

                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        ::GetLastError(),
                        NULL,
                        L"::OpenJobObject",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjSecLimitInfoProv::ExecQueryAsync( 
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            // We will optimize for those cases in which
            // a particular set of named job objects
            // (e.g., 1 or more).  Enumerate also
            // optimizes for the properties that were
            // requested.
            CFrameworkQuery cfwq;
            hr = cfwq.Init(
                     QueryLanguage,
                     Query,
                     lFlags,
                     m_chstrNamespace);

            std::vector<_bstr_t> rgNamedJOs;
            if(SUCCEEDED(hr))
            {
                hr = cfwq.GetValuesForProp(
                         _bstr_t(g_rgJobObjSecLimitInfoPropNames[JOSECLMTPROP_ID]), 
                         rgNamedJOs);
            }

            // If none were specifically requested, they
            // want them all...
            if(rgNamedJOs.size() == 0)
            {
                hr = GetJobObjectList(rgNamedJOs);
            }
            else
            {
                // Object paths were specified.  Before
                // passing them along, we need to un-
                // decorate them.
                UndecorateNamesInNamedJONameList(rgNamedJOs);
            }
    
            // Find out what propeties were requested...
            CJobObjSecLimitInfoProps cjoslip(m_chstrNamespace);
            cjoslip.GetWhichPropsReq(cfwq);

            if(SUCCEEDED(hr))
            {
                hr = Enumerate(
                         pCtx,
                         pResponseHandler,
                         rgNamedJOs,
                         cjoslip,
                         &pStatusObject);
            }
            else
            {
                SetStatusObject(
                    pCtx,
                    m_pNamespace,
                    -1L,
                    NULL,
                    L"Helpers.cpp::GetJobObjectList",
                    JOB_OBJECT_NAMESPACE,
                    &pStatusObject);
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}


STDMETHODIMP CJobObjSecLimitInfoProv::CreateInstanceEnumAsync( 
    const BSTR Class,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObjectPtr pStatusObject;

    try
    {
        HRESULT hrImp = CheckImpersonationLevel();

        if(SUCCEEDED(hrImp))
        {
            if(_wcsicmp(
                   Class, 
                   IDS_Win32_NamedJobObjectSecLimitSetting) != NULL)
            {
                hr = WBEM_E_INVALID_CLASS;
            }

            // For every job object, return all accounting
            // info properties...
            if(SUCCEEDED(hr))
            {
                // Get a list of named jobs...
                std::vector<_bstr_t> rgNamedJOs;
                hr = GetJobObjectList(rgNamedJOs);

                if(SUCCEEDED(hr))
                {
                    CJobObjSecLimitInfoProps cjoslip(m_chstrNamespace);
                    cjoslip.SetReqProps(PROP_ALL_REQUIRED);
                    hr = Enumerate(
                             pCtx,
                             pResponseHandler,
                             rgNamedJOs,
                             cjoslip,
                             &pStatusObject);
                }
                else
                {
                    SetStatusObject(
                        pCtx,
                        m_pNamespace,
                        -1L,
                        NULL,
                        L"Helpers.cpp::GetJobObjectList",
                        JOB_OBJECT_NAMESPACE,
                        &pStatusObject);
                }
            }
        }
        else
        {
            hr = hrImp;
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }
    catch(...)
    {
        hr = WBEM_E_PROVIDER_FAILURE;
    }

    // Set Status
    return pResponseHandler->SetStatus(0, hr, NULL, pStatusObject);
}






/*****************************************************************************/
// Private member function implementations
/*****************************************************************************/             
HRESULT CJobObjSecLimitInfoProv::Enumerate(
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
    std::vector<_bstr_t>& rgNamedJOs,
    CJobObjSecLimitInfoProps& cjoslip,
    IWbemClassObject** ppStatusObject)
{
    HRESULT hr = S_OK;

    hr = CheckImpersonationLevel();

    try // CVARIANT can throw and I want the error...
    {
        if(SUCCEEDED(hr))
        {
            long lNumJobs = rgNamedJOs.size();

            if(lNumJobs > 0)
            {
                SmartHandle hJob;

                for(long m = 0L; m < lNumJobs && SUCCEEDED(hr); m++)
                {
                    cjoslip.ClearProps();

                    // We have the name of a JO; need to open it up
                    // and get its properties...
                    hJob = ::OpenJobObjectW(
                       MAXIMUM_ALLOWED,
                       FALSE,
                       rgNamedJOs[m]);
                    // (NOTE: hJob smarthandle class automatically
                    // closes its handle on destruction and on
                    // reassignment.)
                    if(hJob)
                    {
                        // Set the handle...
                        cjoslip.SetHandle(hJob);

                        // Set the key properties directly...
                        CHString chstrDecoratedJOName;
                        DecorateJOName(
                            rgNamedJOs[m],
                            chstrDecoratedJOName);

                        std::vector<CVARIANT> vecvKeys;
                        CVARIANT vID(chstrDecoratedJOName);
                        vecvKeys.push_back(vID);
                        hr = cjoslip.SetKeysDirect(vecvKeys);

                        if(FAILED(hr))
                        {
                            SetStatusObject(
                                pCtx,
                                m_pNamespace,
                                ::GetLastError(),
                                NULL,
                                L"CJobObjSecLimitInfoProps::SetKeysDirect",
                                JOB_OBJECT_NAMESPACE,
                                ppStatusObject);
                        }

                        if(SUCCEEDED(hr))
                        {
                            // set the non-key requested 
                            // properties...
                            hr = cjoslip.SetNonKeyReqProps();

                            if(FAILED(hr))
                            {
                                SetStatusObject(
                                    pCtx,
                                    m_pNamespace,
                                    ::GetLastError(),
                                    NULL,
                                    L"CJobObjSecLimitInfoProps::SetNonKeyReqProps",
                                    JOB_OBJECT_NAMESPACE,
                                    ppStatusObject);
                            }
                        }

                        // Create a new outgoing instance...
                        IWbemClassObjectPtr pIWCO = NULL;
                        if(SUCCEEDED(hr))
                        {
                            hr = CreateInst(
                                     m_pNamespace,
                                     &pIWCO,
                                     _bstr_t(IDS_Win32_NamedJobObjectSecLimitSetting),
                                     pCtx);

                            if(FAILED(hr))
                            {
                                SetStatusObject(
                                    pCtx,
                                    m_pNamespace,
                                    ::GetLastError(),
                                    NULL,
                                    L"CJobObjSecLimitInfoProv::CreateInst",
                                    JOB_OBJECT_NAMESPACE,
                                    ppStatusObject);
                            }
                        }

                        // Load the properties of the 
                        // new outgoing instance...
                        if(SUCCEEDED(hr))
                        {
                            hr = cjoslip.LoadPropertyValues(
                                     pIWCO,
                                     pCtx,
                                     m_pNamespace);

                            if(FAILED(hr))
                            {
                                SetStatusObject(
                                    pCtx,
                                    m_pNamespace,
                                    ::GetLastError(),
                                    NULL,
                                    L"CJobObjSecLimitInfoProps::LoadPropertyValues",
                                    JOB_OBJECT_NAMESPACE,
                                    ppStatusObject);
                            }
                        }

                        // And send it out...
                        if(SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTmp = (IWbemClassObject*) pIWCO;
                            hr = pResponseHandler->Indicate(
                                     1, 
                                     &pTmp);
                        }
                    }
                    else
                    {
                        _ASSERT(0);

                        hr = WBEM_E_NOT_FOUND;

                        SetStatusObject(
                            pCtx,
                            m_pNamespace,
                            ::GetLastError(),
                            NULL,
                            L"::OpenJobObject",
                            JOB_OBJECT_NAMESPACE,
                            ppStatusObject);
                    }
                }
            }
        }
    }
    catch(CVARIANTError& cve)
    {
        hr = cve.GetWBEMError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\jobobjseclimitinfoprov.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// JobObjSecLimitInfoProv.h

#pragma once





_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));

/*****************************************************************************/
// Component 
/*****************************************************************************/


class CJobObjSecLimitInfoProv : public CUnknown,
                                public IWbemServices, 
                                public IWbemProviderInit   
{
public:	
	// IDispatch declaration and implementation
    DECLARE_IUNKNOWN

    // Constructor
	CJobObjSecLimitInfoProv(){}

	// Destructor
	virtual ~CJobObjSecLimitInfoProv(){}
    
    // Creation
	static HRESULT CreateInstance(CUnknown** ppNewComponent);
	
    // Interface IWbemProviderInit
    STDMETHOD(Initialize)(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    // Interface IWbemServices  
	  STDMETHOD(OpenNamespace)( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CancelAsyncCall)( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;}
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObject)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(GetObjectAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(PutClass)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutClassAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClass)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteClassAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnum)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateClassEnumAsync)( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstance)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(PutInstanceAsync)( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstance)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(DeleteInstanceAsync)( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnum)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(CreateInstanceEnumAsync)( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;}
    
    STDMETHOD(ExecMethod)( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    STDMETHOD(ExecMethodAsync)( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

private:
    
    HRESULT Enumerate(
        IWbemContext __RPC_FAR *pCtx,
        IWbemObjectSink __RPC_FAR *pResponseHandler,
        std::vector<_bstr_t>& rgNamedJOs,
        CJobObjSecLimitInfoProps& cjoslip,
        IWbemClassObject** ppStatusObject);

    IWbemServicesPtr m_pNamespace;

    CHString m_chstrNamespace;
        
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\precomp.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#pragma message("Precompiling header...")

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <fwcommon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\maindll.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// MainDll.cpp

#include "precomp.h"
#include <iostream.h>
#include <objbase.h>
#include "CUnknown.h"
#include "factory.h"




/*****************************************************************************/
// Exported functions
/*****************************************************************************/

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow() ;
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

//
// Server registration
//
STDAPI DllRegisterServer()
{
    return CFactory::RegisterAll() ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return CFactory::UnregisterAll() ;
}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        CFactory::s_hModule = static_cast<HMODULE>(hModule) ;
		DisableThreadLibraryCalls(CFactory::s_hModule);			// 158024 
	}
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\makefile.inc ===
$(O)\maindll.obj : maindll.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\maindll.cpp
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\registry.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Registry.cpp
//

#include "precomp.h"
#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(LPCWSTR pszPath,
                    LPCWSTR szSubkey,
                    LPCWSTR szValue) ;

// Convert a CLSID into a char string.
void CLSIDtoWCHAR(const CLSID& clsid, 
                  LPWSTR szCLSID,
                  int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, LPCWSTR szKeyChild) ;

BOOL setEntryAndValue(LPCWSTR szKey,
                      LPCWSTR szSubkey,
                      LPCWSTR szValue);


////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,        // DLL module handle
                       const CLSID& clsid,     // Class ID
                       LPCWSTR szFriendlyName, // Friendly Name
                       LPCWSTR szVerIndProgID, // Programmatic
                       LPCWSTR szProgID)       // typelib id
{
	// Get server location.
	WCHAR szModule[512] ;
	DWORD dwResult =
		::GetModuleFileNameW(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(WCHAR)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	WCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtoWCHAR(clsid, szCLSID, sizeof(szCLSID)/sizeof(WCHAR)) ;

	// Build the key CLSID\\{...}
	WCHAR szKey[64] ;
	wcscpy(szKey, L"CLSID\\") ;
	wcscat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, L"InprocServer32", szModule) ;

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, L"ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, L"VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, L"CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, L"CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, L"CLSID", szCLSID) ;

    // Specify the threading model as Free...
    wcscat(szKey, L"\\");
    wcscat(szKey, L"InprocServer32");
    setEntryAndValue(szKey, L"ThreadingModel", L"Free");

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,     // Class ID
                      LPCWSTR szVerIndProgID, // Programmatic
                      LPCWSTR szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	WCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtoWCHAR(clsid, szCLSID, sizeof(szCLSID)/sizeof(WCHAR)) ;

	// Build the key CLSID\\{...}
	WCHAR szKey[64] ;
	wcscpy(szKey, L"CLSID\\") ;
	wcscat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtoWCHAR(const CLSID& clsid,
                  LPWSTR szCLSID,
                  int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

    if(SUCCEEDED(hr) && wszCLSID)
    {
	    wcsncpy(szCLSID, wszCLSID, length) ;
    }

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,       // Parent of key to delete
                        LPCWSTR lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyExW(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	WCHAR szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyExW(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKeyW(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(LPCWSTR szKey,
                    LPCWSTR szSubkey,
                    LPCWSTR szValue)
{
	HKEY hKey;
	WCHAR szKeyBuf[1024] ;

	// Copy keyname into buffer.
	wcscpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		wcscat(szKeyBuf, L"\\") ;
		wcscat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyExW(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExW(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              (wcslen(szValue)+1) * sizeof(WCHAR)) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}

//
// Create a value within an existing key and set its data.
//
BOOL setEntryAndValue(LPCWSTR szKey,
                      LPCWSTR szValue,
                      LPCWSTR szData)
{
	HKEY hKey;
	WCHAR szKeyBuf[1024] ;

	// Copy keyname into buffer.
	wcscpy(szKeyBuf, szKey) ;

	// Create and open key and subkey.
	long lResult = RegOpenKeyExW(HKEY_CLASSES_ROOT ,
	                            szKeyBuf, 
	                            0, 
	                            KEY_ALL_ACCESS,
                                &hKey) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExW(hKey, szValue, 0, REG_SZ, 
		              (BYTE *)szData, 
		              (wcslen(szData)+1) * sizeof(WCHAR)) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\registry.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __REGISTRY_H__
#define __REGISTRY_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       LPCWSTR szFriendlyName,
                       LPCWSTR szVerIndProgID,
                       LPCWSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         LPCWSTR szVerIndProgID,
                         LPCWSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\mofs\makefile.inc ===
$(O)\cimwin32.mof $(O)\cimwin32.mfl: win32_cim.mof win32_wmi.mof win32_system.mof win32_application.mof win32_storage.mof win32_userdevice.mof win32_power.mof win32_devices.mof win32_printer.mof win32_network.mof win32_ports.mof win32_memory.mof win32_com.mof win32_user.mof
    copy /b win32_cim.mof+win32_wmi.mof+win32_system.mof+win32_application.mof+win32_storage.mof+win32_userdevice.mof+win32_power.mof+win32_devices.mof+win32_printer.mof+win32_network.mof+win32_ports.mof+win32_memory.mof+win32_com.mof+win32_user.mof $(O)\cimwin32_v2_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\cimwin32Tmp.mof -MFL:$(O)\cimwin32Tmp.mfl $(O)\cimwin32_v2_desc.mof
    copy copyright.mof+$(O)\cimwin32Tmp.mof+$(O)\cimwin32Tmp.mfl $(O)\cimwin32.mof
    copy copyright.mof+$(O)\cimwin32Tmp.mfl $(O)\cimwin32.mfl

$(O)\msi.mof $(O)\msi.mfl: msi.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\msiTmp.mof -MFL:$(O)\msiTmp.mfl msi.mof
    copy copyright.mof+$(O)\msiTmp.mof+$(O)\msiTmp.mfl $(O)\msi.mof
    copy copyright.mof+$(O)\msiTmp.mfl $(O)\msi.mfl

$(O)\ntevt.mof $(O)\ntevt.mfl: ntevt.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\ntevtTmp.mof -MFL:$(O)\ntevtTmp.mfl ntevt.mof
    copy copyright.mof+$(O)\ntevtTmp.mof+$(O)\ntevtTmp.mfl $(O)\ntevt.mof
    copy copyright.mof+$(O)\ntevtTmp.mfl $(O)\ntevt.mfl

!IF $(IA64)
$(O)\wmi.mof $(O)\wmi.mfl: wmi.mof $(BASE_INC_PATH)\mcaia64.mof
    copy wmi.mof+$(BASE_INC_PATH)\mcaia64.mof $(O)\wmiia64.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmiTmp.mof -MFL:$(O)\wmiTmp.mfl $(O)\wmiia64.mof
    copy copyright.mof+$(O)\wmiTmp.mof+$(O)\wmiTmp.mfl $(O)\wmi.mof
    copy copyright.mof+$(O)\wmiTmp.mfl $(O)\wmi.mfl
!ELSE
$(O)\wmi.mof $(O)\wmi.mfl: wmi.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmiTmp.mof -MFL:$(O)\wmiTmp.mfl wmi.mof
    copy copyright.mof+$(O)\wmiTmp.mof+$(O)\wmiTmp.mfl $(O)\wmi.mof
    copy copyright.mof+$(O)\wmiTmp.mfl $(O)\wmi.mfl
!ENDIF

$(O)\secrcw32.mof $(O)\secrcw32.mfl: secrcw32_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\secrcw32Tmp.mof -MFL:$(O)\secrcw32Tmp.mfl secrcw32_desc.mof
    copy copyright.mof+$(O)\secrcw32Tmp.mof+$(O)\secrcw32Tmp.mfl $(O)\secrcw32.mof
    copy copyright.mof+$(O)\secrcw32Tmp.mfl $(O)\secrcw32.mfl

$(O)\wmipdfs.mof $(O)\wmipdfs.mfl: dfs_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipdfsTmp.mof -MFL:$(O)\wmipdfsTmp.mfl dfs_desc.mof
    copy copyright.mof+$(O)\wmipdfsTmp.mof+$(O)\wmipdfsTmp.mfl $(O)\wmipdfs.mof
    copy copyright.mof+$(O)\wmipdfsTmp.mfl $(O)\wmipdfs.mfl

$(O)\wmipdskq.mof $(O)\wmipdskq.mfl: dskquota_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipdskqTmp.mof -MFL:$(O)\wmipdskqTmp.mfl dskquota_desc.mof
    copy copyright.mof+$(O)\wmipdskqTmp.mof+$(O)\wmipdskqTmp.mfl $(O)\wmipdskq.mof
    copy copyright.mof+$(O)\wmipdskqTmp.mfl $(O)\wmipdskq.mfl

$(O)\wmipjobj.mof $(O)\wmipjobj.mfl: jobobj_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipjobjTmp.mof -MFL:$(O)\wmipjobjTmp.mfl jobobj_desc.mof
    copy copyright.mof+$(O)\wmipjobjTmp.mof+$(O)\wmipjobjTmp.mfl $(O)\wmipjobj.mof
    copy copyright.mof+$(O)\wmipjobjTmp.mfl $(O)\wmipjobj.mfl

$(O)\wmipicmp.mof $(O)\wmipicmp.mfl: ping_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipicmpTmp.mof -MFL:$(O)\wmipicmpTmp.mfl ping_desc.mof
    copy copyright.mof+$(O)\wmipicmpTmp.mof+$(O)\wmipicmpTmp.mfl $(O)\wmipicmp.mof
    copy copyright.mof+$(O)\wmipicmpTmp.mfl $(O)\wmipicmp.mfl

$(O)\wmipiprt.mof $(O)\wmipiprt.mfl: route_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipiprtTmp.mof -MFL:$(O)\wmipiprtTmp.mfl route_desc.mof
    copy copyright.mof+$(O)\wmipiprtTmp.mof+$(O)\wmipiprtTmp.mfl $(O)\wmipiprt.mof
    copy copyright.mof+$(O)\wmipiprtTmp.mfl $(O)\wmipiprt.mfl

$(O)\wmipsess.mof $(O)\wmipsess.mfl: session_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipsessTmp.mof -MFL:$(O)\wmipsessTmp.mfl session_desc.mof
    copy copyright.mof+$(O)\wmipsessTmp.mof+$(O)\wmipsessTmp.mfl $(O)\wmipsess.mof
    copy copyright.mof+$(O)\wmipsessTmp.mfl $(O)\wmipsess.mfl

$(O)\krnlprov.mof $(O)\krnlprov.mfl: win32_systemtrace.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\krnlprovTmp.mof -MFL:$(O)\krnlprovTmp.mfl win32_systemtrace.mof
    copy copyright.mof+$(O)\krnlprovTmp.mof+$(O)\krnlprovTmp.mfl $(O)\krnlprov.mof
    copy copyright.mof+$(O)\krnlprovTmp.mfl $(O)\krnlprov.mfl

$(O)\wmipcima.mof $(O)\wmipcima.mfl: cimwin32a_v2_desc.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmipcimaTmp.mof -MFL:$(O)\wmipcimaTmp.mfl cimwin32a_V2_desc.mof
    copy copyright.mof+$(O)\wmipcimaTmp.mof+$(O)\wmipcimaTmp.mfl $(O)\wmipcima.mof
    copy copyright.mof+$(O)\wmipcimaTmp.mfl $(O)\wmipcima.mfl

$(O)\regevent.mof $(O)\regevent.mfl: regevent.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\regeventTmp.mof -MFL:$(O)\regeventTmp.mfl regevent.mof
    copy copyright.mof+$(O)\regeventTmp.mof+$(O)\regeventTmp.mfl $(O)\regevent.mof
    copy copyright.mof+$(O)\regeventTmp.mfl $(O)\regevent.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\jobobjectprov\smarthandle.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// SmartHandle.h


class SmartHandle
{
public:
    SmartHandle() : m_h(NULL) {}
    ~SmartHandle()
    { 
        if(m_h)
        {
            ::CloseHandle(m_h); 
        }
    }

    SmartHandle& operator=(const HANDLE h)
    {
        if(m_h)
        {
            ::CloseHandle(m_h); m_h = NULL;
        }
        m_h = h;
        return *this;
    }

    operator bool() const
    {
        if(m_h) return true;
        else return false;
    }

    operator HANDLE() const { return m_h; }

private:
    HANDLE m_h;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\actioncheck.cpp ===
// ActionCheck.cpp: implementation of the CActionCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ActionCheck.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionCheck::CActionCheck(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CActionCheck::~CActionCheck()
{

}

HRESULT CActionCheck::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pActionRObj = NULL;
    CRequestObject *pCheckRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
            int i;

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"ACTION") == 0){

                    pActionRObj = new CRequestObject();
                    if(!pActionRObj) throw he;

                    pActionRObj->Initialize(m_pNamespace);

                    pActionRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"CHECK") == 0){

                    pCheckRObj = new CRequestObject();
                    if(!pCheckRObj) throw he;

                    pCheckRObj->Initialize(m_pNamespace);

                    pCheckRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }
        }

        if(atAction == ACTIONTYPE_ENUM || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_CreateFolderAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = CreateFolderDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if(atAction == ACTIONTYPE_ENUM || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_DuplicateFileAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))))
            if(FAILED(hr = FileDuplicateFile(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        
        if(atAction == ACTIONTYPE_ENUM || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_FontInfoAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))))
            if(FAILED(hr = FontInfoFile(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ClassInfoAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ProgIDSpecification") == 0)))))
            if(FAILED(hr = ProgIDSpecificationClass(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RemoveIniAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = RemoveIniDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_SelfRegModuleAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))))
            if(FAILED(hr = SelfRegModuleFile(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ShortcutAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = ShortcutDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || ((pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_TypeLibraryInfoAction") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = TypeLibraryDirectory(pHandler, atAction, pActionRObj, pCheckRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                return hr;
            }

        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }

    }catch(...){
            
        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
    }

    return hr;
}

HRESULT CActionCheck::TypeLibraryDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];
    WCHAR wcLibID[BUFF_SIZE];

    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcLibID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
        
        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						//we have a componentized directory... do a little more work
						if ((wcCheck[wcslen(wcCheck) - 1] == L'}') &&
							(wcCheck[wcslen(wcCheck) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcCheck, wcCheck);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `LibID`, `Language`, `Directory_`, `Component_` from TypeLib" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `LibID`=\'", wcLibID, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Directory_`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Directory_`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

	        //Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcDir, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcDir, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------

                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                                            
                                            if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
											{
                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                                                if(wcscmp(wcBuf, L"") != 0)
												{
													// safe operation
                                                    wcProp.Copy(L"Win32_TypeLibraryInfoAction.ActionID=\"");
                                                    wcProp.Append(1, wcBuf);

                                                    dwBufSize = BUFF_SIZE;
													CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

													wcProp.Append (3, wcBuf, wcProductCode, L"\"");
													PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                                                    dwBufSize = BUFF_SIZE;
                                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                                                    if(wcscmp(wcDir, L"") != 0)
													{
														// safe operation
														wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append (4, wcDir, wcCompID, wcProductCode, L"\"");
														}
														else
														{
															wcProp.Append (3, wcDir, wcProductCode, L"\"");
														}

														PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    }
                                                }
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

										uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CActionCheck::ShortcutDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];

    WCHAR wcShortcut[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcShortcut);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						//we have a componentized directory... do a little more work
						if ((wcCheck[wcslen(wcCheck) - 1] == L'}') &&
							(wcCheck[wcslen(wcCheck) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcCheck, wcCheck);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
			}
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_`, `Directory_` from Shortcut" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Directory_`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Directory_`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

	        //Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcDir, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcDir, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------

                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                                            if(wcscmp(wcBuf, L"") != 0)
											{
												// safe operation
												wcProp.Copy(L"Win32_ShortcutAction.ActionID=\"");
												wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
												PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                                if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
												{
                                                    dwBufSize = BUFF_SIZE;
                                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                                                    if(wcscmp(wcDir, L"") != 0)
													{
														// safe operation
														wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append (4, wcDir, wcCompID, wcProductCode, L"\"");
														}
														else
														{
															wcProp.Append (3, wcDir, wcProductCode, L"\"");
														}

														PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    }
                                                }
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CActionCheck::SelfRegModuleFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFile);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_` from SelfReg" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcFile, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"SelfReg", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
							wcProp.Copy(L"Win32_SelfRegModuleAction.ActionID=\"");
							wcProp.Append (3, wcBuf, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

							// safe operation
							wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
							wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                        //=====================================================

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CActionCheck::RemoveIniDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];

    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcIniFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						//we have a componentized directory... do a little more work
						if ((wcCheck[wcslen(wcCheck) - 1] == L'}') &&
							(wcCheck[wcslen(wcCheck) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcCheck, wcCheck);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
			}
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `RemoveIniFile`, `Component_`, `DirProperty` from RemoveIniFile" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `RemoveIniFile`=\'", wcIniFile, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `DirProperty`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `DirProperty`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveIniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcDir, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcDir, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase(), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------

                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                                            if(wcscmp(wcBuf, L"") != 0)
											{
												// safe operation
												wcProp.Copy(L"Win32_RemoveIniAction.ActionID=\"");
												wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
												PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                                if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
												{
                                                    if(wcscmp(wcDir, L"") != 0)
													{
														// safe operation
														wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append (4, wcDir, wcCompID, wcProductCode, L"\"");
														}
														else
														{
															wcProp.Append (3, wcDir, wcProductCode, L"\"");
														}

														PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if(!(atAction == ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    }
                                                }
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CActionCheck::ProgIDSpecificationClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hCView	= NULL;
	MSIHANDLE hCRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcProgID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcProgID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ProgId`, `Class_` from ProgId" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Class_`=\'", wcProgID, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `ProgId`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `ProgId`=\'", wcCheck, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `Context`, `Component_` from Class where `CLSID`=\'" );

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try{

                if ( GetView ( &hView, wcProductCode, wcQuery, L"ProgId", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
							wcProp.Copy(L"Win32_ProgIDSpecification.CheckID=\"");
							wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

                            wcProp.Copy(L"Win32_ClassInfoAction.ActionID=\"");

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcProp.Append ( 1, wcBuf );

								// make query on fly
								wcQuery1.Append ( 2, wcBuf, L"\'" );

                                CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase(), wcQuery1, &hCView));
                                CheckMSI(g_fpMsiViewExecute(hCView, 0));

                                try{

                                    uiStatus = g_fpMsiViewFetch(hCView, &hCRecord);

                                    if(uiStatus != ERROR_NO_MORE_ITEMS){

                                        dwBufSize = BUFF_SIZE;
                                        CheckMSI(g_fpMsiRecordGetStringW(hCRecord, 1, wcBuf, &dwBufSize));

										wcProp.Append (3, wcBuf, wcProductCode, L"\"");

                                        dwBufSize = BUFF_SIZE;
                                        CheckMSI(g_fpMsiRecordGetStringW(hCRecord, 2, wcBuf, &dwBufSize));
                                        
                                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
										{
                                            PutKeyProperty(m_pObj, pAction, wcProp, &bAttribute, m_pRequest);

                                        //----------------------------------------------------

                                            if(bDriver && bAttribute) bMatch = true;

                                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                                hr = pHandler->Indicate(1, &m_pObj);
                                            }
                                        }
                                        
                                    }else throw WBEM_E_FAILED;

                                }catch(...){

                                    g_fpMsiCloseHandle(hCRecord);
                                    g_fpMsiViewClose(hCView);
                                    g_fpMsiCloseHandle(hCView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hCRecord);
                                g_fpMsiViewClose(hCView);
                                g_fpMsiCloseHandle(hCView);

                            }else bMatch = false;
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CActionCheck::FontInfoFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFile);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;


    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_` from Font" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcFile, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Font", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
							wcProp.Copy(L"Win32_FontInfoAction.ActionID=\"");
							wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

							// safe operation
							wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
							wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }
            
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CActionCheck::FileDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];

    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcCheck[BUFF_SIZE];
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcCheck);

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `File_` from DuplicateFile" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotCheck )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `File_`=\'", wcCheck, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `File_`=\'", wcCheck, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"DuplicateFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
							wcProp.Copy(L"Win32_DuplicateFileAction.ActionID=\"");
							wcProp.Append (3, wcBuf, wcProductCode, L"\"");
							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
							{
                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
									wcProp.Append (3, wcBuf, wcProductCode, L"\"");
									PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                //=====================================================

                                //----------------------------------------------------

                                    if(bDriver && bAttribute) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);

                                    }
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}


HRESULT CActionCheck::CreateFolderDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                            CRequestObject *pActionData, CRequestObject *pCheckData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];

    WCHAR wcFolder[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    bool bGotCheck = false;
    bool bGotAction = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFolder);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFolder);

						//we have a componentized directory... do a little more work
						if ((wcFolder[wcslen(wcFolder) - 1] == L'}') &&
							(wcFolder[wcslen(wcFolder) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcFolder, wcFolder);
						}

						bTestCode = true;
						bGotCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Directory_`, `Component_` from CreateFolder" );

    //optimize for GetObject
    if ( bGotCheck || bGotAction )
	{
		wcQuery.Append ( 3, L" where `Directory_`=\'", wcFolder, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );
    
	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"CreateFolder", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);
                        bDoneFirst = false;

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcDir, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcDir, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase(), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------
                                            
                                            if(wcscmp(wcDir, L"") != 0)
											{
												// safe operation
												wcProp.Copy(L"Win32_CreateFolderAction.ActionID=\"");
												wcProp.Append (3, wcDir, wcProductCode, L"\"");
												PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

												// safe operation
                                                wcProp.Copy(L"Win32_DirectorySpecification.CheckID=\"");

												if(uiStatus == ERROR_SUCCESS)
												{
													wcProp.Append (4, wcDir, wcCompID, wcProductCode, L"\"");
												}
												else
												{
													wcProp.Append (3, wcDir, wcProductCode, L"\"");
												}

												PutKeyProperty(m_pObj, pCheck, wcProp, &bAttribute, m_pRequest);

                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                                if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
												{
                                                    if(bDriver && bAttribute) bMatch = true;

                                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

														hr = pHandler->Indicate(1, &m_pObj);

	                                                   }
                                                }
                                            }

                                            m_pObj->Release();
                                            m_pObj = NULL;

                                            if(!bDoneFirst) bDoneFirst = true;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\actioncheck.h ===
// ActionCheck.h: interface for the CActionCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONCHECK_H__B0A7DBE0_D706_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_ACTIONCHECK_H__B0A7DBE0_D706_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CActionCheck : public CGenericClass  
{
public:
	CActionCheck(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CActionCheck();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT CreateFolderDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT FileDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT FontInfoFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
						 CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT ProgIDSpecificationClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT RemoveIniDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							   CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT SelfRegModuleFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT ShortcutDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							  CRequestObject *pActionData, CRequestObject *pCheckData);
	HRESULT TypeLibraryDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								 CRequestObject *pActionData, CRequestObject *pCheckData);

};

#endif // !defined(AFX_ACTIONCHECK_H__B0A7DBE0_D706_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationcommandline.cpp ===
// ApplicationCommandLine.cpp: implementation of the CApplicationCommandLine class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ApplicationCommandLine.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApplicationCommandLine::CApplicationCommandLine(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CApplicationCommandLine::~CApplicationCommandLine()
{

}

HRESULT CApplicationCommandLine::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcCommand[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    WCHAR wcElement[BUFF_SIZE];
    bool bElement = false;
    CRequestObject *pAntData = NULL;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int j;
        //GetObject optimizations
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        for(j = 0; j < m_pRequest->m_iPropCount; j++){

            if(_wcsicmp(m_pRequest->m_Property[j], L"Antecedent") == 0){

                pAntData = new CRequestObject();
                if(!pAntData) throw he;

                pAntData->Initialize(m_pNamespace);

                pAntData->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pAntData){

            for(j = 0; j < pAntData->m_iPropCount; j++){

                if(_wcsicmp(pAntData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen ( pAntData->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcElement, pAntData->m_Value[j]);

						bElement = true;
						break;
					}
                }
            }

            pAntData->Cleanup();
            delete pAntData;
            pAntData = NULL;
        }

    }

    //These will change from class to class
    bool bAntec, bDepend;
    INSTALLSTATE piInstalled;

    CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_` from Shortcut" );

    //optimize for GetObject
    if ( bElement )
	{
		wcQuery.Append ( 3, L" where `Shortcut`=\'", wcElement, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]
        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try{

            if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                    if(wcscmp(wcBuf, L"") != 0)
					{
                        wcProp.Copy ( L"Win32_ApplicationService.Name=\"" );
						wcProp.Append ( 2, wcBuf, L"\"");

						PutKeyProperty(m_pObj, pAntecedent, wcProp, &bAntec, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcBuf, L"\'" );

                        CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hSEView));
                        CheckMSI(g_fpMsiViewExecute(hSEView, 0));

                        try{

                            uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                            if(uiStatus != ERROR_NO_MORE_ITEMS){
                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hSERecord, 1, wcBuf, &dwBufSize));

                                if(ValidateComponentID(wcBuf, wcProductCode)){
                                    dwBufSize = BUFF_SIZE;
                                    piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf,
                                        wcCommand, &dwBufSize);

                                    if((wcscmp(wcCommand, L"") != 0) && (piInstalled != INSTALLSTATE_UNKNOWN)
                                        && (piInstalled != INSTALLSTATE_ABSENT)){

                                        dwBufSize = BUFF_SIZE;
                                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                        if ( ValidateComponentName	(	msidata.GetDatabase (),
																		wcProductCode,
																		wcBuf
																	)
										   )
										{
					                        wcProp.Copy ( L"Win32_CommandLineAccess.Name=\"" );
											wcProp.Append ( 2, EscapeStringW(wcCommand, wcBuf), L"\"" );

											PutKeyProperty(m_pObj, pDependent, wcProp, &bDepend, m_pRequest);

										//----------------------------------------------------

                                            if(bAntec && bDepend) bMatch = true;

                                            if((atAction != ACTIONTYPE_GET) || bMatch){

                                                hr = pHandler->Indicate(1, &m_pObj);
                                            }
                                        }
                                    }
                                }
                            }

                        }catch(...){
                        
                            g_fpMsiViewClose(hSEView);
                            g_fpMsiCloseHandle(hSEView);
                            g_fpMsiCloseHandle(hSERecord);
                            throw;
                        }

                        g_fpMsiViewClose(hSEView);
                        g_fpMsiCloseHandle(hSEView);
                        g_fpMsiCloseHandle(hSERecord);
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\binary.h ===
// Binary.h: interface for the CBinary class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BINARY_H__CB597B75_1CE5_11D2_BF8D_00A0C9954921__INCLUDED_)
#define AFX_BINARY_H__CB597B75_1CE5_11D2_BF8D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CBinary : public CGenericClass  
{
public:
	CBinary(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CBinary();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_BINARY_H__CB597B75_1CE5_11D2_BF8D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationcommandline.h ===
// ApplicationCommandLine.h: interface for the CApplicationCommandLine class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APPLICATIONCOMMANDLINE_H__3586F540_D0EE_11D2_B22A_00A0C9954921__INCLUDED_)
#define AFX_APPLICATIONCOMMANDLINE_H__3586F540_D0EE_11D2_B22A_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CApplicationCommandLine : public CGenericClass  
{
public:
	CApplicationCommandLine(CRequestObject *pObj, IWbemServices *pNamespace,
		IWbemContext *pCtx = NULL);
	virtual ~CApplicationCommandLine();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler,
		IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_APPLICATIONCOMMANDLINE_H__3586F540_D0EE_11D2_B22A_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\binary.cpp ===
// Binary.cpp: implementation of the CBinary class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Binary.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBinary::CBinary(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CBinary::~CBinary()
{

}

HRESULT CBinary::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bName, bCode;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}
			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"Name" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Name` from Binary" );

    if( bGotName )
	{
		wcQuery.Append ( 3, L" where `Name`=\'", wcName, L"\'" );
    }

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Binary", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pName, wcBuf, &bName, m_pRequest);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bCode, m_pRequest);

                    //----------------------------------------------------

                        if(bName && bCode) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationservice.cpp ===
// ApplicationService.cpp: implementation of the CApplicationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <tchar.h>
#include "ApplicationService.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApplicationService::CApplicationService(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CApplicationService::~CApplicationService()
{

}

HRESULT CApplicationService::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bName;
    INSTALLSTATE piInstalled, piAction;

    if(m_pRequest->m_iValCount > m_pRequest->m_iPropCount){

        m_pRequest->m_Property[m_pRequest->m_iPropCount] = SysAllocString(L"Name");

        if(!m_pRequest->m_Property[(m_pRequest->m_iPropCount)++])
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    bool bGotID = false;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_` from Shortcut" );

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"Name" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				bGotID = true;
				wcQuery.Append ( 3, L" where `Shortcut`=\'", m_pRequest->m_Value[iPos], L"\'" );
			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", FALSE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pName, wcBuf, &bName, m_pRequest);
                    PutProperty(m_pObj, pCaption, wcBuf);
                    PutProperty(m_pObj, pDescription, wcBuf);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                    if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
					{
                        uiStatus = g_fpMsiGetComponentStateW( msidata.GetProduct (), wcBuf, &piInstalled, &piAction );

                        if(uiStatus == ERROR_SUCCESS){

                            if((piInstalled == INSTALLSTATE_ADVERTISED) ||
                                (piInstalled == INSTALLSTATE_LOCAL) ||
                                (piInstalled == INSTALLSTATE_SOURCE) ||
                                (piInstalled == INSTALLSTATE_DEFAULT))
                                wcscpy(wcBuf, L"OK");
                            else if((piInstalled == INSTALLSTATE_BADCONFIG) ||
                                (piInstalled == INSTALLSTATE_MOREDATA) ||
                                (piInstalled == INSTALLSTATE_INVALIDARG))
                                wcscpy(wcBuf, L"Error");
                            else if((piInstalled == INSTALLSTATE_INCOMPLETE) ||
                                (piInstalled == INSTALLSTATE_SOURCEABSENT) ||
                                (piInstalled == INSTALLSTATE_BROKEN) ||
                                (piInstalled == INSTALLSTATE_NOTUSED) ||
                                (piInstalled == INSTALLSTATE_REMOVED) ||
                                (piInstalled == INSTALLSTATE_ABSENT))
                                wcscpy(wcBuf, L"Degraded");
                            else
                                wcscpy(wcBuf, L"Unknown");
                        }else
                            wcscpy(wcBuf, L"Unknown");

                        PutProperty(m_pObj, pStatus, wcBuf);

                        PutProperty(m_pObj, pCreationClassName, L"Win32_ApplicationService");

                        PutProperty(m_pObj, pSystemCreationClassName, L"Win32_ComputerSystem");

                        TCHAR cBuf[MAX_COMPUTERNAME_LENGTH + 1] = { _T('\0') };
                        dwBufSize = ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof ( TCHAR );

                        if(!GetComputerName(cBuf, &dwBufSize)) throw WBEM_E_FAILED;

						#ifndef	UNICODE
                        WCHAR wcComputer[MAX_COMPUTERNAME_LENGTH + 1];
                        mbstowcs(wcComputer, cBuf, MAX_COMPUTERNAME_LENGTH + 1);

                        PutProperty(m_pObj, pSystemName, wcComputer);
						#else	UNICODE
                        PutProperty(m_pObj, pSystemName, cBuf);
						#endif	UNICODE

                    //====================================================

                        PutProperty(m_pObj, pStartMode, L"Manual");

                    //----------------------------------------------------

                        if(bName) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
			msidata.CloseProduct ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
		msidata.CloseProduct ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\applicationservice.h ===
// ApplicationService.h: interface for the CApplicationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APPLICATIONSERVICE_H__DB614F23_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_APPLICATIONSERVICE_H__DB614F23_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CApplicationService : public CGenericClass  
{
public:
	CApplicationService(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CApplicationService();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_APPLICATIONSERVICE_H__DB614F23_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\bindimage.h ===
// BindImage.h: interface for the CBindImage class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BINDIMAGE_H__75F6BA2A_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_BINDIMAGE_H__75F6BA2A_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CBindImage : public CGenericClass  
{
public:
	CBindImage(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CBindImage();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_BINDIMAGE_H__75F6BA2A_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\bindimage.cpp ===
// BindImage.cpp: implementation of the CBindImage class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "BindImage.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBindImage::CBindImage(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CBindImage::~CBindImage()
{

}

HRESULT CBindImage::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;

    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Path` from BindImage" );

    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcAction, L"\'" );
    }

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"BindImage", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pFile, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

						CStringExt prop ( wcslen ( wcBuf ) + wcslen ( wcProductCode ) + 1 );
						prop.Append ( 2, wcBuf, wcProductCode );

						PutKeyProperty(m_pObj, pActionID, prop, &bActionID, m_pRequest);

					//====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pPath, wcBuf);

                    //----------------------------------------------------

                        if(bActionID) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\checkcheck.cpp ===
// CheckCheck.cpp: implementation of the CCheckCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CheckCheck.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCheckCheck::CCheckCheck(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCheckCheck::~CCheckCheck()
{

}

HRESULT CCheckCheck::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pCheckRObj = NULL;
    CRequestObject *pLocationRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
            int i;

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"Location") == 0){

                    pLocationRObj = new CRequestObject();
                    if(!pLocationRObj) throw he;

                    pLocationRObj->Initialize(m_pNamespace);

                    pLocationRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"CHECK") == 0){

                    pCheckRObj = new CRequestObject();
                    if(!pCheckRObj) throw he;

                    pCheckRObj->Initialize(m_pNamespace);

                    pCheckRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || ((pLocationRObj && pLocationRObj->m_bstrClass && (_wcsicmp(pLocationRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_IniFileSpecification") == 0)))))
            if(FAILED(hr = IniFileDirectory(pHandler, atAction, pCheckRObj, pLocationRObj))){

                    if(pLocationRObj){

                        pLocationRObj->Cleanup();
                        delete pLocationRObj;
                        pLocationRObj = NULL;
                    }

                    if(pCheckRObj){

                        pCheckRObj->Cleanup();
                        delete pCheckRObj;
                        pCheckRObj = NULL;
                    }
                    return hr;
                }

        if((atAction == ACTIONTYPE_ENUM) || ((pLocationRObj && pLocationRObj->m_bstrClass && (_wcsicmp(pLocationRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0) &&
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_DirectorySpecification") == 0)))))
            if(FAILED(hr = DirectoryParent(pHandler, atAction, pCheckRObj, pLocationRObj))){

                    if(pLocationRObj){

                        pLocationRObj->Cleanup();
                        delete pLocationRObj;
                        pLocationRObj = NULL;
                    }

                    if(pCheckRObj){

                        pCheckRObj->Cleanup();
                        delete pCheckRObj;
                        pCheckRObj = NULL;
                    }
                    return hr;
                }

            if(pLocationRObj){

                pLocationRObj->Cleanup();
                delete pLocationRObj;
                pLocationRObj = NULL;
            }

            if(pCheckRObj){

                pCheckRObj->Cleanup();
                delete pCheckRObj;
                pCheckRObj = NULL;
            }

    }catch(...){
            
        if(pLocationRObj){

            pLocationRObj->Cleanup();
            delete pLocationRObj;
            pLocationRObj = NULL;
        }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
    }

    return hr;
}

HRESULT CCheckCheck::DirectoryParent(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                             CRequestObject *pCheckRObj, CRequestObject *pLocationRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;
	MSIHANDLE hPView	= NULL;
	MSIHANDLE hPRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcParent[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcParentCompID[39];
    WCHAR wcTestCode[39];
    WCHAR wcFolder[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcLocation[BUFF_SIZE];
    bool bCheck = false;
    bool bLocation = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckRObj){

            for(int i = 0; i < pCheckRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckRObj->m_Value[i], wcFolder);

						//we have a componentized directory... do a little more work
						if ((wcFolder[wcslen(wcFolder) - 1] == L'}') &&
							(wcFolder[wcslen(wcFolder) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcFolder, wcFolder);
						}

						bTestCode = true;
						bCheck = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pLocationRObj){

            for(int i = 0; i < pLocationRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pLocationRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pLocationRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pLocationRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pLocationRObj->m_Value[i], wcLocation);

						//we have a componentized directory... do a little more work
						if ((wcLocation[wcslen(wcLocation) - 1] == L'}') &&
							(wcLocation[wcslen(wcLocation) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcLocation, wcLocation);
						}

						bTestCode = true;
						bLocation = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated, bParent, bDir;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Directory`, `Directory_Parent` from Directory" );

    //optimize for GetObject
    if ( bCheck || bLocation )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `Directory`=\'", wcFolder, L"\'" );
		}

		if ( bLocation )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Directory_Parent`=\'", wcLocation, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Directory_Parent`=\'", wcLocation, L"\'" );
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );
	QueryExt wcQuery2 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Directory", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcDir, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcDir, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;
                                        bDir = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                            bDir = true;
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcParent, &dwBufSize));

											// make query on fly
											wcQuery2.Append ( 2, wcParent, L"\'" );

                                            if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery2, &hPView)) == ERROR_SUCCESS)
                                                || !bDoneFirst){

                                                if((g_fpMsiViewExecute(hPView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                                    try{

                                                        uiStatus = g_fpMsiViewFetch(hPView, &hPRecord);

                                                        while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                                            
                                                            bValidated = false;
                                                            bParent = false;

                                                            if(uiStatus == ERROR_SUCCESS){

                                                                dwBufSize = 39;
                                                                CheckMSI(g_fpMsiRecordGetStringW(hPRecord, 1, wcParentCompID, &dwBufSize));
                                                                bValidated = ValidateComponentID(wcParentCompID, wcProductCode);
                                                                bParent = true;
                                                            }

                                                            if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                                                if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                                                //----------------------------------------------------
                                                                dwBufSize = BUFF_SIZE;
                                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                                                                if(wcscmp(wcDir, L"") != 0)
																{
																	// safe operation
																	wcProp.Copy ( L"Win32_DirectorySpecification.CheckID=\"" );

																	if(bDir)
																	{
																		wcProp.Append ( 4, wcDir, wcCompID, wcProductCode, L"\"" );
																	}
																	else
																	{
																		wcProp.Append ( 3, wcDir, wcProductCode, L"\"" );
																	}

																	PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

                                                                    dwBufSize = BUFF_SIZE;
                                                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                                                    if(wcscmp(wcParent, L"") != 0)
																	{
																		// safe operation
																		wcProp.Copy ( L"Win32_DirectorySpecification.CheckID=\"" );

																		if(bParent)
																		{
																			wcProp.Append ( 4, wcParent, wcParentCompID, wcProductCode, L"\"" );
																		}
																		else
																		{
																			wcProp.Append ( 3, wcParent, wcProductCode, L"\"" );
																		}

																		PutKeyProperty(m_pObj, pLocation, wcProp, &bAttribute, m_pRequest);

                                                                    //----------------------------------------------------

                                                                        if(bDriver && bAttribute) bMatch = true;

                                                                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                                        }
                                                                    }
                                                                }

                                                                m_pObj->Release();
                                                                m_pObj = NULL;

                                                                if(!bDoneFirst) bDoneFirst = true;
                                                            }

                                                            g_fpMsiCloseHandle(hPRecord);

																uiStatus = g_fpMsiViewFetch(hPView, &hPRecord);
                                                        }

                                                    }catch(...){

                                                        g_fpMsiCloseHandle(hPRecord);
                                                        g_fpMsiViewClose(hPView);
                                                        g_fpMsiCloseHandle(hPView);
                                                        throw;
                                                    }

                                                    g_fpMsiCloseHandle(hPRecord);
                                                    g_fpMsiViewClose(hPView);
                                                    g_fpMsiCloseHandle(hPView);
                                                }
                                            }
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CCheckCheck::IniFileDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                             CRequestObject *pCheckRObj, CRequestObject *pLocationRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcDir[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCompID[39];
    WCHAR wcTestCode[39];
    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcLocation[BUFF_SIZE];
    bool bCheck = false;
    bool bLocation = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckRObj){

            for(int i = 0; i < pCheckRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pCheckRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckRObj->m_Value[i], wcIniFile);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pLocationRObj){

            for(int i = 0; i < pLocationRObj->m_iPropCount; i++){
                
				if(_wcsicmp(pLocationRObj->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pLocationRObj->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pLocationRObj->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pLocationRObj->m_Value[i], wcLocation);

						//we have a componentized directory... do a little more work
						if ((wcLocation[wcslen(wcLocation) - 1] == L'}') &&
							(wcLocation[wcslen(wcLocation) - 38] == L'{')
						   )
						{
							RemoveFinalGUID(wcLocation, wcLocation);
						}

						bTestCode = true;
						bLocation = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bDriver, bAttribute, bDoneFirst, bValidated;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `IniFile`, `Component_`, `DirProperty` from IniFile" );

    if(atAction != ACTIONTYPE_ENUM){

		//optimize for GetObject
		if ( bCheck || bLocation )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" where `IniFile`=\'", wcIniFile, L"\'" );
			}

			if ( bLocation )
			{
				if ( bCheck )
				{
					wcQuery.Append ( 3, L" or `DirProperty`=\'", wcLocation, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `DirProperty`=\'", wcLocation, L"\'" );
				}
			}
		}
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Directory_`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"IniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        bDoneFirst = false;
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcDir, &dwBufSize));

						// make query on fly
						wcQuery1.Append ( 2, wcDir, L"\'" );

                        if(((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hDView)) == ERROR_SUCCESS)
                            || !bDoneFirst){

                            if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

                                    while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                        
                                        bValidated = false;

                                        if(uiStatus == ERROR_SUCCESS){

                                            dwBufSize = 39;
                                            CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
                                            bValidated = ValidateComponentID(wcCompID, wcProductCode);
                                        }

                                        if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

                                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                                            //----------------------------------------------------
                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                                            if(wcscmp(wcBuf, L"") != 0)
											{
												// safe operation
												wcProp.Copy ( L"Win32_IniFileSpecification.CheckID=\"" );
												wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
												PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                                if ( ValidateComponentName	(	msidata.GetDatabase (),
																				wcProductCode,
																				wcBuf
																			)
												   )
												{
                                                    dwBufSize = BUFF_SIZE;
                                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                                                    if(wcscmp(wcDir, L"") != 0)
													{
														// safe operation
														wcProp.Copy ( L"Win32_DirectorySpecification.CheckID=\"" );

														if(uiStatus == ERROR_SUCCESS)
														{
															wcProp.Append ( 4, wcDir, wcCompID, wcProductCode, L"\"" );
														}
														else
														{
															wcProp.Append ( 3, wcDir, wcProductCode, L"\"" );
														}

														PutKeyProperty(m_pObj, pLocation, wcProp, &bAttribute, m_pRequest);

                                                    //=====================================================

                                                    //----------------------------------------------------

                                                        if(bDriver && bAttribute) bMatch = true;

                                                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                                                            hr = pHandler->Indicate(1, &m_pObj);
                                                        }
                                                    
                                                    }
                                                }
                                            }

                                            if(!bDoneFirst) bDoneFirst = true;

                                            m_pObj->Release();
                                            m_pObj = NULL;
                                        }

                                        g_fpMsiCloseHandle(hDRecord);

                                        uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
                                    }

                                }catch(...){

                                    g_fpMsiCloseHandle(hDRecord);
                                    g_fpMsiViewClose(hDView);
                                    g_fpMsiCloseHandle(hDView);
                                    throw;
                                }

                                g_fpMsiCloseHandle(hDRecord);
                                g_fpMsiViewClose(hDView);
                                g_fpMsiCloseHandle(hDView);
                            }
                        }

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\classinfoaction.h ===
// ClassInfoAction.h: interface for the CClassInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CLASSINFOACTION_H__75F6BA22_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_CLASSINFOACTION_H__75F6BA22_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CClassInfoAction : public CGenericClass  
{
public:
	CClassInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CClassInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_CLASSINFOACTION_H__75F6BA22_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\classfac.h ===
//***************************************************************************

//

//  ClassFac.h

//

//  Module: WBEM Instance provider sample code

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _ClassFactory_H_
#define _ClassFactory_H_

#define _WIN32_DCOM

// This class is the class factory for CMSIProv objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\classinfoaction.cpp ===
// ClassInfoAction.cpp: implementation of the CClassInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ClassInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CClassInfoAction::CClassInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CClassInfoAction::~CClassInfoAction()
{

}

HRESULT CClassInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSView	= NULL;
	MSIHANDLE hSRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery1[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcCLSID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					GetFirstGUID(m_pRequest->m_Value[iPos], wcAction);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `CLSID`, `Context`, `ProgId_Default`, `Description`, `AppId_`, `FileTypeMask`, `DefInprocHandler`, `Argument` from Class" );

    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `CLSID`=\'", wcAction, L"\'" );
    }

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Class", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = 39;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcCLSID, &dwBufSize));
                            PutProperty(m_pObj, pCLSID, wcCLSID);
                            PutProperty(m_pObj, pName, wcCLSID);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pContext, wcBuf);

							wcProp.Append ( 3, wcCLSID, wcBuf, wcProductCode );
							PutKeyProperty(m_pObj, pActionID, wcProp, &bCheck, m_pRequest);
							wcProp.Clear ( );

                    //====================================================
                        
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pProgID, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDescription, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pAppID, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 7, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pFileTypeMask, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 8, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDefInprocHandler, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 9, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pArgument, wcBuf);

							// safe operation
							// lenght of wcCLSID is 39 and lenght of wcQuery1 is BUFF_SIZE ( 512 )

                            wcscpy(wcQuery1, L"select `RemoteName`, `Insertable` from Class where `CLSID`=\'");
                            wcscat(wcQuery1, wcCLSID);
                            wcscat(wcQuery1, L"\'");

                            if((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hSView)) !=
                                ERROR_BAD_QUERY_SYNTAX){

                                CheckMSI(uiStatus);

                                CheckMSI(g_fpMsiViewExecute(hSView, 0));

                                try{

                                    uiStatus = g_fpMsiViewFetch(hSView, &hSRecord);

                                    if(uiStatus != ERROR_NO_MORE_ITEMS){

                                        CheckMSI(uiStatus);

                                        dwBufSize = BUFF_SIZE;
                                        CheckMSI(g_fpMsiRecordGetStringW(hSRecord, 1, wcBuf, &dwBufSize));
                                        PutProperty(m_pObj, pRemoteName, wcBuf);

                                        PutProperty(m_pObj, pInsertable, g_fpMsiRecordGetInteger(hSRecord, 2));
                                    }

                                }catch(...){

                                    g_fpMsiViewClose(hSView);
                                    g_fpMsiCloseHandle(hSView);
                                    g_fpMsiCloseHandle(hSRecord);
                                    throw;
                                }

                                g_fpMsiViewClose(hSView);
                                g_fpMsiCloseHandle(hSView);
                                g_fpMsiCloseHandle(hSRecord);

                            }

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\checkcheck.h ===
// CheckCheck.h: interface for the CCheckCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHECKCHECK_H__6F0256C0_D708_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_CHECKCHECK_H__6F0256C0_D708_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CCheckCheck : public CGenericClass  
{
public:
	CCheckCheck(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCheckCheck();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT IniFileDirectory(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							 CRequestObject *pCheckRObj, CRequestObject *pLocationRObj);
	HRESULT DirectoryParent(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
							CRequestObject *pCheckRObj, CRequestObject *pLocationRObj);
};

#endif // !defined(AFX_CHECKCHECK_H__6F0256C0_D708_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WBEM Instance provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <objbase.h>
#include "classfac.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , LPVOID * ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid) *ppv=this;

    if (NULL!=*ppv){
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount) delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, LPVOID * ppvObj)
{
    CMSIProv *pObj;
    HRESULT hr = WBEM_S_NO_ERROR;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if(NULL!=pUnkOuter) return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    pObj=new CMSIProv();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if(FAILED(hr)) delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\commandlineaccess.h ===
// CommandLineAccess.h: interface for the CCommandLineAccess class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COMMANDLINEACCESS_H__DB614F25_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_COMMANDLINEACCESS_H__DB614F25_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CCommandLineAccess : public CGenericClass  
{
public:
	CCommandLineAccess(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCommandLineAccess();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	void Cleanup(WCHAR * wcList[]);
	void Initialize(WCHAR * wcList[]);
};

#endif // !defined(AFX_COMMANDLINEACCESS_H__DB614F25_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\commandlineaccess.cpp ===
// CommandLineAccess.cpp: implementation of the CCommandLineAccess class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <tchar.h>
#include "CommandLineAccess.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCommandLineAccess::CCommandLineAccess(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCommandLineAccess::~CCommandLineAccess()
{

}

HRESULT CCommandLineAccess::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord = NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery1[BUFF_SIZE];
    WCHAR wcCommand[BUFF_SIZE];
    WCHAR *wcDone[MSI_MAX_APPLICATIONS];
    WCHAR wcProductCode[39];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    TCHAR cBuf[MAX_COMPUTERNAME_LENGTH + 1];

    //These will change from class to class
    bool bName, bRepeat;
    INSTALLSTATE piInstalled;

    if ( atAction != ACTIONTYPE_ENUM )
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;
	}

    Initialize(wcDone);

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery1, L"select distinct `Shortcut`, `Component_`, `Arguments` from Shortcut");

	QueryExt wcQuery ( L"select distinct `ComponentId` from Component where `Component`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery1, L"Shortcut", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);
                    bRepeat = false;

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------

                    PutProperty(m_pObj, pCreationClassName, L"Win32_CommandLineAccess");
                    PutProperty(m_pObj, pSystemCreationClassName, L"Win32_ComputerSystem");

                    dwBufSize = (MAX_COMPUTERNAME_LENGTH+1) * sizeof ( TCHAR );
                    if(!GetComputerName(cBuf, &dwBufSize)) throw WBEM_E_FAILED;

					#ifndef	UNICODE
                    WCHAR wcComputer[MAX_COMPUTERNAME_LENGTH + 1];
                    mbstowcs(wcComputer, cBuf, MAX_COMPUTERNAME_LENGTH + 1);

                    PutProperty(m_pObj, pSystemName, wcComputer);
					#else	UNICODE
                    PutProperty(m_pObj, pSystemName, cBuf);
					#endif	UNICODE

                //====================================================

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

					// make query on fly
					wcQuery.Append ( 2, wcBuf, L"\'" );

                    CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery, &hSEView));
                    CheckMSI(g_fpMsiViewExecute(hSEView, 0));

                    try{

                        uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                        if(uiStatus != ERROR_NO_MORE_ITEMS){

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hSERecord, 1, wcBuf, &dwBufSize));

                            if(ValidateComponentID(wcBuf, wcProductCode)){

                                dwBufSize = BUFF_SIZE;
                                piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf,
                                    wcCommand, &dwBufSize);

                                if ( (wcscmp(wcCommand, L"") != 0) &&
									 (piInstalled != INSTALLSTATE_UNKNOWN) &&
									 (piInstalled != INSTALLSTATE_ABSENT) )
								{
									if ( wcCommand [ dwBufSize-1 ] == L'\\' )
									{
										wcCommand [ dwBufSize-1 ] = L'\0';
									}

                                    int i = 0;
                                    while(wcDone[i]){

                                        if(wcscmp(wcDone[i], wcCommand) == 0){

                                            bRepeat = true;
                                            break;
                                        }
                                        i++;
                                    }

                                    if(!bRepeat){

                                        if ( ( wcDone[i] = new WCHAR [ wcslen ( wcCommand ) + 1 ] ) == NULL )
										{
                                            Cleanup(wcDone);
                                            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                        }

                                        wcscpy(wcDone[i], wcCommand);
                                    }

                                    PutKeyProperty(m_pObj, pName, wcCommand, &bName, m_pRequest);
                                    PutProperty(m_pObj, pCaption, wcCommand);
                                    PutProperty(m_pObj, pDescription, wcCommand);
                                
                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                                    if(wcscmp(wcBuf, L"") != 0)
									{
										PutProperty ( m_pObj, pCommandLine, wcCommand, 2, L" ", wcBuf );
                                    }
									else
									{
	                                    PutProperty(m_pObj, pCommandLine, wcCommand);
									}
                                //----------------------------------------------------

                                    if(bName) bMatch = true;

                                    if(((atAction != ACTIONTYPE_GET) || bMatch) && !bRepeat){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
                        }

                    }catch(...){

                        g_fpMsiCloseHandle(hSERecord);
                        g_fpMsiViewClose(hSEView);
                        g_fpMsiCloseHandle(hSEView);
                        throw;
                    }

                    if(m_pObj){

                        m_pObj->Release();
                        m_pObj = NULL;
                    }

                    g_fpMsiCloseHandle(hSERecord);
                    g_fpMsiViewClose(hSEView);
                    g_fpMsiCloseHandle(hSEView);

                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

            if(m_pObj){
                
                m_pObj->Release();
                m_pObj = NULL;
            }

            Cleanup(wcDone);

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    Cleanup(wcDone);
    return hr;
}

void CCommandLineAccess::Cleanup(WCHAR * wcList[])
{
    int i = 0;

    while(wcList[i]) delete wcList[i++];
}

void CCommandLineAccess::Initialize(WCHAR * wcList[])
{
    for(int i = 0; i < MSI_MAX_APPLICATIONS; i++) wcList[i] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\condition.h ===
// Condition.h: interface for the CCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONDITION_H__75F6BA21_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_CONDITION_H__75F6BA21_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CCondition : public CGenericClass  
{
public:
	CCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_CONDITION_H__75F6BA21_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\createfolder.h ===
// CreateFolder.h: interface for the CCreateFolder class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CREATEFOLDER_H__DB614F2F_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_CREATEFOLDER_H__DB614F2F_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CCreateFolder : public CGenericClass  
{
public:
	CCreateFolder(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCreateFolder();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_CREATEFOLDER_H__DB614F2F_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\condition.cpp ===
// Condition.cpp: implementation of the CCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Condition.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCondition::CCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCondition::~CCondition()
{

}

HRESULT CCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bCheck;

    if ( atAction != ACTIONTYPE_ENUM )
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;
	}

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Feature_`, `Level`, `Condition` from Condition");

    SetSinglePropertyPath(L"CheckID");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Condition", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcProp, &dwBufSize));
                    PutProperty(m_pObj, pName, wcProp);
                    PutProperty(m_pObj, pFeature, wcProp);

                    PutProperty(m_pObj, pCaption, wcProp);
                    PutProperty(m_pObj, pDescription, wcProp);

                    if(ValidateFeatureName(wcProp, wcProductCode)){
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

						PutKeyProperty ( m_pObj, pCheckID, wcProp, &bCheck, m_pRequest, 2, wcBuf, wcProductCode);

					//====================================================

                        PutProperty(m_pObj, pLevel, g_fpMsiRecordGetInteger(hRecord, 2));

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pCondition, wcBuf);

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;
                
                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\directoryspecification.h ===
// DirectorySpecification.h: interface for the CDirectorySpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIRECTORYSPECIFICATION_H__DB614F27_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_DIRECTORYSPECIFICATION_H__DB614F27_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CDirectorySpecification : public CGenericClass  
{
public:
	CDirectorySpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CDirectorySpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:

	DWORD CreateDirectoryPath	(	MSIHANDLE hProduct,
									MSIHANDLE hDatabase,
									WCHAR *wcDir,
									WCHAR *wcPath,
									DWORD *dwPath
								);

	WCHAR * ParseDefDir(WCHAR *wcDefaultDir);
};

#endif // !defined(AFX_DIRECTORYSPECIFICATION_H__DB614F27_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\duplicatefile.h ===
// DuplicateFile.h: interface for the CDuplicateFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DUPLICATEFILE_H__DB614F30_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_DUPLICATEFILE_H__DB614F30_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CDuplicateFile : public CGenericClass  
{
public:
	CDuplicateFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CDuplicateFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_DUPLICATEFILE_H__DB614F30_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\duplicatefile.cpp ===
// DuplicateFile.cpp: implementation of the CDuplicateFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "DuplicateFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDuplicateFile::CDuplicateFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CDuplicateFile::~CDuplicateFile()
{

}

HRESULT CDuplicateFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `File_`, `DestName` from DuplicateFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `FileKey`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"DuplicateFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pFileKey, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSource, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDestination, wcBuf);

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\createfolder.cpp ===
// CreateFolder.cpp: implementation of the CCreateFolder class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CreateFolder.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCreateFolder::CCreateFolder(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCreateFolder::~CCreateFolder()
{

}

HRESULT CCreateFolder::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR * wcBuf = NULL;
	WCHAR * wcProductCode = NULL;

    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;

	try
	{
		if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcProductCode = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		SetSinglePropertyPath(L"ActionID");
    
		//improve getobject performance by optimizing the query
		if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

			BSTR bstrCompare;

			int iPos = -1;
			bstrCompare = SysAllocString ( L"ActionID" );

			if ( bstrCompare )
			{
				if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							SysFreeString ( bstrCompare );
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

						bGotID = true;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

				}

				SysFreeString ( bstrCompare );
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

		Query wcQuery;
		wcQuery.Append ( 1, L"select distinct `Component_`, `Directory_` from CreateFolder" );

		if( bGotID )
		{
			wcQuery.Append ( 3, L" where `Directory_`=\'", wcAction, L"\'" );
		}

		while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
		{
			// safe operation:
			// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

			wcscpy(wcProductCode, m_pRequest->Package(i));

			if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

				//Open our database

				try
				{
					if ( GetView ( &hView, wcProductCode, wcQuery, L"CreateFolder", TRUE, FALSE ) )
					{
						uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
							CheckMSI(uiStatus);

							if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

							//----------------------------------------------------
							dwBufSize = BUFF_SIZE;
							CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

							if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
							{
								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
								PutProperty(m_pObj, pDirectoryName, wcBuf);
								PutProperty(m_pObj, pCaption, wcBuf);
								PutProperty(m_pObj, pDescription, wcBuf);

								PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

							//====================================================

								if(bActionID) bMatch = true;

								if((atAction != ACTIONTYPE_GET)  || bMatch){

									hr = pHandler->Indicate(1, &m_pObj);
								}
							}

							m_pObj->Release();
							m_pObj = NULL;

							g_fpMsiCloseHandle(hRecord);

							uiStatus = g_fpMsiViewFetch(hView, &hRecord);
						}
					}
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
			}
		}
	}
	catch ( ... )
	{
		if ( wcBuf )
		{
			delete [] wcBuf;
			wcBuf = NULL;
		}

		if ( wcProductCode )
		{
			delete [] wcProductCode;
			wcProductCode = NULL;
		}

		throw;
	}

	if ( wcBuf )
	{
		delete [] wcBuf;
		wcBuf = NULL;
	}

	if ( wcProductCode )
	{
		delete [] wcProductCode;
		wcProductCode = NULL;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\directoryspecification.cpp ===
// DirectorySpecification.cpp: implementation of the CDirectorySpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "DirectorySpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDirectorySpecification::CDirectorySpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CDirectorySpecification::~CDirectorySpecification()
{

}

HRESULT CDirectorySpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR * wcBuf = NULL;
    WCHAR * wcDir = NULL;
    WCHAR * wcPath = NULL;
    WCHAR * wcProductCode = NULL;
    WCHAR * wcCompID = NULL;
    WCHAR * wcDirectory = NULL;
    WCHAR * wcTestCode = NULL;

    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    bool bDoneFirst = false;

	try
	{
		if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcDir = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcPath = new WCHAR [ BUFF_SIZE * 4 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcProductCode = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( (  wcCompID = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcDirectory = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcTestCode = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}


		//These will change from class to class
		bool bCheck, bValidated;
		INSTALLSTATE piInstalled;
		int iState;

		SetSinglePropertyPath(L"CheckID");

		//improve getobject performance by optimizing the query
		if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

			BSTR bstrCompare;

			int iPos = -1;
			bstrCompare = SysAllocString ( L"CheckID" );

			if ( bstrCompare )
			{
				if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							SysFreeString ( bstrCompare );
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(m_pRequest->m_Value[iPos], wcDirectory);

						// safe because lenght is going to be at least 39
						//we have a componentized directory... do a little more work
						if	(	(wcDirectory[wcslen(wcDirectory) - 1] == L'}') &&
								(wcDirectory[wcslen(wcDirectory) - 38] == L'{')
							)
						{
							RemoveFinalGUID(wcDirectory, wcDirectory);
						}

						bGotID = true;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

				}

				SysFreeString ( bstrCompare );
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

		CStringExt wcID;

		Query wcQuery;
		wcQuery.Append ( 1, L"select distinct `Directory`, `DefaultDir` from Directory" );

		//optimize for GetObject
		if ( bGotID )
		{
			wcQuery.Append ( 3, L" where `Directory`=\'", wcDirectory, L"\'" );
		}

		QueryExt wcQuery1 ( L"select distinct `ComponentId`, `Component` from Component where `Directory_`=\'" );

		while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
		{
			// safe operation:
			// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

			wcscpy(wcProductCode, m_pRequest->Package(i));

			if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

				//Open our database

				try
				{
					if ( GetView ( &hView, wcProductCode, wcQuery, L"Directory", FALSE, FALSE ) )
					{
						uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
							CheckMSI(uiStatus);
							bDoneFirst = false;

							//create different instances for each software element
							dwBufSize = BUFF_SIZE;
							CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcDir, &dwBufSize));

							// make query on fly
							wcQuery1.Append ( 2, wcDir, L"\'" );

							if ( ( ( uiStatus = g_fpMsiDatabaseOpenViewW (	msidata.GetDatabase (),
																			wcQuery1,
																			&hDView
																		 )
								   ) == ERROR_SUCCESS 
								 )

								|| !bDoneFirst
							   )
							{
								if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

									try{

										uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

										while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                    
											bValidated = false;

											if(uiStatus == ERROR_SUCCESS){

												dwBufSize = 39;
												CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
												bValidated = ValidateComponentID(wcCompID, wcProductCode);
											}

											if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

												if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

											//----------------------------------------------------
												PutProperty(m_pObj, pDirectory, wcDir);

												wcID.Copy ( wcDir );

												DWORD dwCompID = 0L;
												LPWSTR wszTemp = NULL;

												if(uiStatus == ERROR_SUCCESS)
												{
													dwCompID = wcslen ( wcCompID );

													try
													{
														if ( ( wszTemp = new WCHAR [ dwCompID + 1 ] ) == NULL )
														{
															throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
														}
													}
													catch ( ... )
													{
														if ( wszTemp )
														{
															delete [] wszTemp;
															wszTemp = NULL;
														}

														throw;
													}

													wcscpy(wszTemp, wcCompID);
													PutProperty(m_pObj, pSoftwareElementID, wcCompID);
												}

												if ( dwCompID )
												{
													wcID.Append ( 1, wszTemp );

													if ( wszTemp )
													{
														delete [] wszTemp;
														wszTemp = NULL;
													}
												}

												wcID.Append ( 1, wcProductCode );
												PutKeyProperty(m_pObj, pCheckID, wcID, &bCheck, m_pRequest);

											//====================================================

												dwBufSize = BUFF_SIZE * 4;

												BOOL	bContinue = TRUE;
												DWORD	dwContinue= 2;

												DWORD dwStatus = ERROR_SUCCESS;

												do
												{
													if ( ( dwStatus = CreateDirectoryPath (	msidata.GetProduct (),
																							msidata.GetDatabase (),
																							wcDir,
																							wcPath,
																							&dwBufSize
																						  )
														 ) == ERROR_MORE_DATA
													   )
													{
														delete [] wcPath;
														wcPath = NULL;

														if ( ( wcPath = new WCHAR [ dwBufSize + 1 ] ) == NULL )
														{
															throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
														}
													}
													else
													{
														bContinue = FALSE;
													}
												}
												while ( bContinue && dwContinue-- );

												if ( dwStatus == ERROR_SUCCESS )
												{
													PutProperty(m_pObj, pDirectoryPath, wcPath);
												}

												dwBufSize = BUFF_SIZE;
												CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
												PutProperty(m_pObj, pDefaultDir, wcBuf);
												PutProperty(m_pObj, pCaption, wcBuf);
												PutProperty(m_pObj, pDescription, wcBuf);

												if(uiStatus == ERROR_SUCCESS){
        
													dwBufSize = BUFF_SIZE;
													CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 2, wcBuf, &dwBufSize));
													PutProperty(m_pObj, pName, wcBuf);
                                            
													dwBufSize = BUFF_SIZE;
													piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcCompID, wcBuf, &dwBufSize);
													SoftwareElementState(piInstalled, &iState);
													PutProperty(m_pObj, pSoftwareElementState, iState);

													PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

													dwBufSize = BUFF_SIZE;
													CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
													PutProperty(m_pObj, pVersion, wcBuf);
												}

											//----------------------------------------------------

												if(bCheck) bMatch = true;

												if((atAction != ACTIONTYPE_GET) || bMatch){

													hr = pHandler->Indicate(1, &m_pObj);
												}

												m_pObj->Release();
												m_pObj = NULL;

												if(!bDoneFirst) bDoneFirst = true;
											}

											g_fpMsiCloseHandle(hDRecord);

											uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
										}

									}catch(...){

										g_fpMsiCloseHandle(hDRecord);
										g_fpMsiViewClose(hDView);
										g_fpMsiCloseHandle(hDView);
										throw;
									}


									g_fpMsiCloseHandle(hDRecord);
									g_fpMsiViewClose(hDView);
									g_fpMsiCloseHandle(hDView);
								}
							}

							g_fpMsiCloseHandle(hRecord);

							uiStatus = g_fpMsiViewFetch(hView, &hRecord);
						}
					}
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();
					msidata.CloseProduct ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
				msidata.CloseProduct ();
			}
		}
	}
	catch ( ... )
	{
		if (wcBuf)
		{
			delete [] wcBuf;
			wcBuf = NULL;
		}

		if (wcDir)
		{
			delete [] wcDir;
			wcDir = NULL;
		}

		if (wcPath)
		{
			delete [] wcPath;
			wcPath = NULL;
		}

		if (wcProductCode)
		{
			delete [] wcProductCode;
			wcProductCode = NULL;
		}

		if (wcCompID)
		{
			delete [] wcCompID;
			wcCompID = NULL;
		}

		if (wcDirectory)
		{
			delete [] wcDirectory;
			wcDirectory = NULL;
		}

		if (wcTestCode)
		{
			delete [] wcTestCode;
			wcTestCode = NULL;
		}

		throw;
	}

	if (wcBuf)
	{
		delete [] wcBuf;
		wcBuf = NULL;
	}

	if (wcDir)
	{
		delete [] wcDir;
		wcDir = NULL;
	}

	if (wcPath)
	{
		delete [] wcPath;
		wcPath = NULL;
	}

	if (wcProductCode)
	{
		delete [] wcProductCode;
		wcProductCode = NULL;
	}

	if (wcCompID)
	{
		delete [] wcCompID;
		wcCompID = NULL;
	}

	if (wcDirectory)
	{
		delete [] wcDirectory;
		wcDirectory = NULL;
	}

	if (wcTestCode)
	{
		delete [] wcTestCode;
		wcTestCode = NULL;
	}

    return hr;
}

DWORD CDirectorySpecification::CreateDirectoryPath	(	MSIHANDLE hProduct,
														MSIHANDLE hDatabase,
														WCHAR *wcDir,
														WCHAR *wcPath,
														DWORD *dwPath
													)
{
	DWORD dwResult = static_cast < DWORD > ( E_INVALIDARG );

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

	LPWSTR	wcQuery = NULL;
	LPWSTR	wcBuf	= NULL;

	if ( wcDir )
	{
		DWORD	dwQuery	= 0L;
		LPWSTR	wszQuery= L"select distinct `Directory_Parent`, `DefaultDir` from Directory where `Directory`=\'";

		dwQuery = lstrlenW ( wszQuery ) + lstrlenW ( wcDir ) + 1 + 1;

		try
		{
			if ( ( wcQuery = new WCHAR [ dwQuery ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}

			wcscpy(wcQuery, wszQuery);
			wcscat(wcQuery, wcDir);
			wcscat(wcQuery, L"\'");
		}
		catch ( ... )
		{
			if ( wcQuery )
			{
				delete [] wcQuery;
				wcQuery = NULL;
			}

			throw;
		}

		try
		{
			if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch ( ... )
		{
			if ( wcQuery )
			{
				delete [] wcQuery;
				wcQuery = NULL;
			}

			if ( wcBuf )
			{
				delete [] wcBuf;
				wcBuf = NULL;
			}

			throw;
		}

		DWORD dwPathSize = 0;
		dwPathSize = * dwPath;

		DWORD dwUsed	= 1; // last null
		DWORD dwBufSize	= BUFF_SIZE;

		//Do all this to open a view on the directory we want
		if ( ( dwResult = g_fpMsiDatabaseOpenViewW ( hDatabase, wcQuery, &hView ) ) == ERROR_SUCCESS )
		{
			delete [] wcQuery;
			wcQuery = NULL;

			if(g_fpMsiViewExecute(hView, 0) == ERROR_SUCCESS)
			{
				if ( ( dwResult = g_fpMsiViewFetch ( hView, &hRecord ) ) == ERROR_SUCCESS )
				{
					BOOL	bContinue = TRUE;
					DWORD	dwContinue= 2;

					dwBufSize = BUFF_SIZE;

					do
					{
						if ( ( dwResult = g_fpMsiRecordGetStringW ( hRecord, 1, wcBuf, &dwBufSize ) ) == ERROR_MORE_DATA )
						{
							delete [] wcBuf;
							wcBuf = NULL;

							try
							{
								if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) == NULL )
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							catch ( ... )
							{
								if ( wcBuf )
								{
									delete [] wcBuf;
									wcBuf = NULL;
								}

								throw;
							}

							dwBufSize++;
						}
						else
						{
							if ( dwContinue == 2 )
							{
								dwBufSize = BUFF_SIZE;
							}

							bContinue = FALSE;
						}
					}
					while ( bContinue && dwContinue-- );

					if( dwResult == ERROR_SUCCESS )
					{
						//For TARGETDIR
						if(wcscmp(L"TARGETDIR", wcBuf) == 0)
						{
							bContinue = TRUE;
							dwContinue= 2;

							DWORD dwBufSizeOld = dwBufSize;

							do 
							{
								if ( ( dwResult = g_fpMsiGetProductPropertyW (
																				hProduct,
																				L"TARGETDIR",
																				wcBuf,
																				&dwBufSize
																			 )
									 ) == ERROR_MORE_DATA
								   )
								{
									delete [] wcBuf;
									wcBuf = NULL;

									try
									{
										if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize ++;
									}
									catch ( ... )
									{
										if ( wcBuf )
										{
											delete [] wcBuf;
											wcBuf = NULL;
										}

										throw;
									}
								}
								else
								{
									if ( dwContinue == 2 )
									{
										dwBufSize = dwBufSizeOld;
									}

									bContinue = FALSE;
								}
							}
							while ( bContinue && dwContinue-- );

							if ( dwResult == ERROR_SUCCESS )
							{
								dwUsed =	dwUsed +
											lstrlenW ( wcBuf );

								if ( dwUsed > dwPathSize )
								{
									( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
									dwResult = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, wcBuf);
								}
							}
						}
						//For WindowsFolder
						else if(wcscmp(L"WindowsFolder", wcBuf) == 0)
						{
							DWORD dwSize = 0;

							bContinue = TRUE;
							dwContinue= 2;

							do
							{
								dwSize = GetEnvironmentVariableW ( L"WINDIR", wcBuf, dwBufSize );

								if ( dwSize == 0 )
								{
									dwResult = static_cast < DWORD > ( E_FAIL );
									bContinue = FALSE;
								}
								else if ( dwSize > dwBufSize )
								{
									delete [] wcBuf;
									wcBuf = NULL;

									try
									{
										if ( ( wcBuf = new WCHAR [ dwSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize = dwSize + 1;
									}
									catch ( ... )
									{
										if ( wcBuf )
										{
											delete [] wcBuf;
											wcBuf = NULL;
										}

										throw;
									}
								}
								else
								{
									bContinue = FALSE;
									dwResult = ERROR_SUCCESS;
								}
							}
							while ( bContinue && dwContinue-- );

							if ( dwResult == ERROR_SUCCESS )
							{
								dwUsed =	dwUsed +
											lstrlenW ( wcBuf );

								if ( dwUsed > dwPathSize )
								{
									( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
									dwResult = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, wcBuf);
								}
							}
						}
						//For DesktopFolder
						else if(wcscmp(L"DesktopFolder", wcBuf) == 0)
						{
							WCHAR wcVar[15];

							if(AreWeOnNT())
							{
								wcscpy(wcVar, L"USERPROFILE");
							}
							else
							{
								wcscpy(wcVar, L"WINDIR");
							}

							DWORD dwSize = 0;

							bContinue = TRUE;
							dwContinue= 2;

							do
							{
								dwSize = GetEnvironmentVariableW ( wcVar, wcBuf, dwBufSize );

								if ( dwSize == 0 )
								{
									dwResult = static_cast < DWORD > ( E_FAIL );
									bContinue = FALSE;
								}
								else if ( dwSize > dwBufSize )
								{
									delete [] wcBuf;
									wcBuf = NULL;

									try
									{
										if ( ( wcBuf = new WCHAR [ dwSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize = dwSize + 1;
									}
									catch ( ... )
									{
										if ( wcBuf )
										{
											delete [] wcBuf;
											wcBuf = NULL;
										}

										throw;
									}
								}
								else
								{
									bContinue = FALSE;
									dwResult = ERROR_SUCCESS;
								}
							}
							while ( bContinue && dwContinue-- );

							if ( dwResult == ERROR_SUCCESS )
							{
								dwUsed =	dwUsed +
											lstrlenW ( wcBuf ) +
											lstrlenW ( L"\\Desktop" );

								if ( dwUsed > dwPathSize )
								{
									( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
									dwResult = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, wcBuf);
									wcscat(wcPath, L"\\Desktop");
								}
							}
						}
						//For same parent/directory
						else if(wcscmp(wcDir, wcBuf) == 0)
						{
							dwResult = ERROR_SUCCESS;
						}
						//Continue recursion
						else
						{
							dwResult = CreateDirectoryPath ( hProduct, hDatabase, wcBuf, wcPath, dwPath );

							if ( dwResult == ERROR_MORE_DATA )
							{
								dwUsed = dwUsed + ( * dwPath );
							}
						}
					}

					if ( dwResult == ERROR_SUCCESS  || dwResult == ERROR_MORE_DATA )
					{
						bContinue = TRUE;
						dwContinue= 2;

						DWORD dwResultHelp = ERROR_SUCCESS;

						do 
						{
							if ( ( dwResultHelp = g_fpMsiRecordGetStringW (	hRecord,
																			2,
																			wcBuf,
																			&dwBufSize
																		  )
								 ) == ERROR_MORE_DATA
							   )
							{
								delete [] wcBuf;
								wcBuf = NULL;

								try
								{
									if ( ( wcBuf = new WCHAR [ dwBufSize ] ) == NULL )
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcBuf )
									{
										delete [] wcBuf;
										wcBuf = NULL;
									}

									throw;
								}
							}
							else
							{
								bContinue = FALSE;
							}
						}
						while ( bContinue && dwContinue-- );

						if ( dwResultHelp == ERROR_MORE_DATA )
						{
							dwResult = static_cast < DWORD > ( E_FAIL );
						}

						if ( dwResult == ERROR_SUCCESS || dwResult == ERROR_MORE_DATA )
						{
							LPWSTR wcBufHelp = NULL;
							try
							{
								wcBufHelp = ParseDefDir ( wcBuf );
							}
							catch ( ... )
							{
								delete [] wcBuf;
								wcBuf = NULL;

								throw;
							}

							dwUsed =	dwUsed +
										lstrlenW ( wcBufHelp );

							if ( dwUsed > dwPathSize )
							{
								( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
								dwResult = ERROR_MORE_DATA;
							}
							else
							{
								wcscat(wcPath, wcBufHelp);
							}
						}
					}

					g_fpMsiCloseHandle(hRecord);

				}
				else if ( dwResult == E_OUTOFMEMORY )
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					delete [] wcBuf;
					wcBuf = NULL;

					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}

			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			delete [] wcBuf;
			wcBuf = NULL;
		}
		else
		{
			delete [] wcBuf;
			wcBuf = NULL;

			delete [] wcQuery;
			wcQuery = NULL;

			if(dwResult == E_OUTOFMEMORY)
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
	}

	if ( dwResult == ERROR_MORE_DATA )
	{
		wcPath [ 0 ] = 0;
	}

	return dwResult;
}

WCHAR * CDirectorySpecification::ParseDefDir(WCHAR *wcDefaultDir)
{
    WCHAR * wcTmp;
    WCHAR * wcBuf = NULL;
	
	if ( ( wcBuf = (WCHAR *)malloc( ( wcslen ( wcDefaultDir ) + 1 + 1 ) * sizeof(WCHAR)) ) != NULL )
	{
		wcscpy(wcBuf, L"\\");
		wcscat(wcBuf, wcDefaultDir);

		for(wcTmp = wcBuf; *wcTmp; wcTmp++) if(*wcTmp == L':') *wcTmp = NULL;
		for(wcTmp = wcBuf; *wcTmp; wcTmp++) if(*wcTmp == L'.') wcscpy(wcBuf, L"");

		wcscpy(wcDefaultDir, wcBuf);

		free((void *)wcBuf);
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    return wcDefaultDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\environment.h ===
// Environment.h: interface for the CEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENVIRONMENT_H__EAA368A2_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_ENVIRONMENT_H__EAA368A2_DEA4_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CEnvironment : public CGenericClass  
{
public:
	CEnvironment(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CEnvironment();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ENVIRONMENT_H__EAA368A2_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\extendstring.h ===
// ExtendString.h: interface of the CStringExt class.
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#ifndef	___EXTEND_STRING___
#define	___EXTEND_STRING___

#if		_MSC_VER >= 1000
#pragma once
#endif	_MSC_VER >= 1000

#ifndef	_INC_TCHAR
#include <tchar.h>
#endif	_INC_TCHAR

#define BUFF_SIZE_EXT 256

class CStringExt
{
	public:

	// constructor
	CStringExt ( DWORD dwSize = BUFF_SIZE_EXT );
	CStringExt ( LPCTSTR wsz );

	// destructor
	virtual ~CStringExt ();

	// string manipulation
	HRESULT Append ( DWORD dwCount, ... );

	HRESULT Copy ( LPCTSTR wsz );
	HRESULT Clear ( );

	// LPTSTR
	inline operator LPTSTR() const
	{
		return m_wszString;
	}

	// append strings into string
	HRESULT AppendList		( DWORD dwConstantSize, LPCWSTR wszConstant, DWORD dwCount, va_list & argList );

	protected:

	DWORD	m_dwSize;
	LPTSTR	m_wszString;
};

#endif	___EXTEND_STRING___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\extendquery.cpp ===
// Query.cpp: implementation of the CQuery class.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ExtendQuery.h"

/////////////////////////////////////////////////////////////////////////////////////////
// query implementation
/////////////////////////////////////////////////////////////////////////////////////////

Query::Query ( DWORD dwSize ) : CStringExt ( dwSize )
{
}

Query::Query ( LPCTSTR wsz ) : CStringExt ( wsz )
{
}

Query::~Query ()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
// query extend implementation
/////////////////////////////////////////////////////////////////////////////////////////

QueryExt::QueryExt ( LPCTSTR wsz, DWORD dwSize ) : CStringExt ( dwSize ),

m_dwSizeConstant ( 0 ),
m_wszStringConstant ( NULL )

{
	if ( wsz )
	{
		try
		{
			DWORD dw = 0L;
			dw = lstrlen ( wsz );

			if SUCCEEDED ( Append ( 1, wsz ) )
			{
				m_dwSizeConstant = dw;
				m_wszStringConstant = wsz;
			}
			else
			{
				throw  CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch ( ... )
		{
			m_dwSizeConstant = 0L;
			m_wszStringConstant = NULL;

			throw;
		}
	}
}

QueryExt::~QueryExt ()
{
	m_dwSizeConstant = 0L;
	m_wszStringConstant = NULL;
}

HRESULT QueryExt::Append ( DWORD dwCount, ... )
{
	HRESULT hr = E_FAIL;

	if ( dwCount )
	{
		va_list argList;
		va_start ( argList, dwCount );
		hr = AppendList ( m_dwSizeConstant, m_wszStringConstant, dwCount, argList );
		va_end ( argList );
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\extendquery.h ===
// Query.h: interface of the CQuery class.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#ifndef	___EXTEND_QUERY___
#define	___EXTEND_QUERY___

#if		_MSC_VER >= 1000
#pragma once
#endif	_MSC_VER >= 1000

#include "ExtendString.h"

// query 
class Query : public CStringExt
{
	public:

	Query ( DWORD dwSize = BUFF_SIZE_EXT );
	Query ( LPCTSTR wsz );
	~Query ( );
};

class QueryExt : public CStringExt
{
	public:

	QueryExt ( LPCTSTR wsz, DWORD dwSize = BUFF_SIZE_EXT );
	~QueryExt ( );

	// string manipulation
	HRESULT Append ( DWORD dwCount, ... );

	private:

	DWORD	m_dwSizeConstant;
	LPCTSTR	m_wszStringConstant;
};

#endif	___EXTEND_QUERY___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\environment.cpp ===
// Environment.cpp: implementation of the CEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Environment.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnvironment::CEnvironment(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CEnvironment::~CEnvironment()
{

}

HRESULT CEnvironment::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hDatabase, hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcEnvironment[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcEnvironment);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Environment`, `Component_`, `Name`, `Value` from Environment" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Environment`=\'", wcEnvironment, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Environment", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pEnvironment, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pName, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);
                            PutProperty(m_pObj, pDescription, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pValue, wcBuf);
                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\extendstring.cpp ===
// ExtendString.cpp: implementation of the CStringExt class.
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ExtendString.h"

CStringExt::CStringExt ( DWORD dwSize ) :

m_dwSize ( 0 ),
m_wszString ( NULL )

{
	if ( !dwSize )
	{
		dwSize = BUFF_SIZE_EXT;
	}

	try
	{
		if ( ( m_wszString = new TCHAR [ dwSize ] ) != NULL )
		{
			* m_wszString = 0;
			m_dwSize = dwSize;
		}
		else
		{
			throw  CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( m_wszString )
		{
			delete [] m_wszString;
			m_wszString = NULL;
		}

		m_dwSize = 0L;

		throw;
	}
}

CStringExt::CStringExt ( LPCTSTR wsz ) :

m_dwSize ( 0 ),
m_wszString ( NULL )

{
	try
	{
		DWORD dwSize = 0L;

		if ( wsz )
		{
			dwSize = lstrlen ( wsz ) + 1;

			if (dwSize < BUFF_SIZE_EXT)
			{
				dwSize = BUFF_SIZE_EXT;
			}
		}
		else
		{
			dwSize = BUFF_SIZE_EXT;
		}

		if ( ( m_wszString = new TCHAR [ dwSize ] ) != NULL )
		{
			if ( wsz )
			{
				lstrcpy ( m_wszString, wsz );
			}
			else
			{
				* m_wszString = 0;
			}

			m_dwSize = dwSize;
		}
		else
		{
			throw  CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( m_wszString )
		{
			delete [] m_wszString;
			m_wszString = NULL;
		}

		m_dwSize = 0L;

		throw;
	}
}

CStringExt::~CStringExt ()
{
	if ( m_wszString )
	{
		delete [] m_wszString;
		m_wszString = NULL;
	}

	m_dwSize = 0L;
}

HRESULT	CStringExt::Clear ()
{
	HRESULT hr = S_FALSE;

	if ( m_wszString )
	{
		*m_wszString = 0;
		hr = S_OK;
	}

	return hr;
}

HRESULT CStringExt::Copy ( LPCTSTR wsz )
{
	HRESULT hr = E_FAIL;

	if ( wsz )
	{
		Clear ();

		hr = Append ( 1, wsz );
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}

HRESULT CStringExt::Append ( DWORD dwCount, ... )
{
	HRESULT hr = E_FAIL;

	if ( dwCount )
	{
		va_list argList;
		va_start ( argList, dwCount );
		hr = AppendList ( 0, NULL, dwCount, argList );
		va_end ( argList );
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}

HRESULT CStringExt::AppendList ( DWORD dwConstantSize, LPCWSTR wszConstant, DWORD dwCount, va_list & argList )
{
	HRESULT hr = S_OK;
	DWORD	dwsz = 0L;

	va_list argListSave = argList;

	try
	{
		LPCTSTR wszc = NULL;

		for ( DWORD dw = 0; dw < dwCount; dw++ )
		{
			if ( ( wszc = va_arg ( argList, LPCTSTR ) ) != NULL )
			{
				dwsz += lstrlen ( wszc );
			}
		}

		//reuse dw for offset into buffer for start
		if ( dwConstantSize && wszConstant )
		{
			dw = dwConstantSize;
		}
		else
		{
			dw = _tcslen ( m_wszString );
		}

		if ( dw + dwsz + 1 < m_dwSize )
		{
			LPTSTR wsz = NULL;
			//reuse dw for start of append
			dw = 0L;

			if ( dwConstantSize && wszConstant )
			{
				wsz = & ( m_wszString [ dwConstantSize ] );
				wszc = va_arg ( argListSave, LPCTSTR );

				_tcscpy ( wsz, wszc );
				dw = 1;
			}
			else
			{
				wsz = m_wszString;
			}

			for ( DWORD dwLoop = dw; dwLoop < dwCount; dwLoop++ )
			{
				if ( ( wszc = va_arg ( argListSave, LPCTSTR ) ) != NULL )
				{
					_tcscat ( wsz, wszc );
				}
			}
		}
		else
		{
			LPTSTR wszHelp = NULL;

			try
			{
				if ( ( wszHelp = new TCHAR [ dw + dwsz + 1 ] ) != NULL )
				{
					if ( dwConstantSize && wszConstant )
					{
						_tcscpy ( wszHelp, wszConstant );
					}
					else
					{
						_tcscpy ( wszHelp, m_wszString );
					}

					for ( dw = 0; dw < dwCount; dw++ )
					{
						LPCTSTR wszc = NULL;
						wszc = va_arg ( argListSave, LPCTSTR );

						if ( wszc )
						{
							_tcscat ( wszHelp, wszc );
						}
					}
				}
				else
				{
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
			catch ( ... )
			{
				if ( wszHelp )
				{
					delete [] wszHelp;
					wszHelp = NULL;
				}

				throw;
			}

			if ( m_wszString )
			{
				delete [] m_wszString;
				m_wszString = NULL;
			}

			m_wszString = wszHelp;
			m_dwSize = dw + dwsz + 1;

		}
	}
	catch ( ... )
	{
		throw;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\extensioninfoaction.cpp ===
// ExtensionInfoAction.cpp: implementation of the CExtensionInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ExtensionInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExtensionInfoAction::CExtensionInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CExtensionInfoAction::~CExtensionInfoAction()
{

}

HRESULT CExtensionInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE	hView	= NULL;
	MSIHANDLE	hVView	= NULL;
	MSIHANDLE	hSView	= NULL;
	MSIHANDLE	hMView	= NULL;
	MSIHANDLE	hRecord	= NULL;
	MSIHANDLE	hVRecord= NULL;
	MSIHANDLE	hSRecord= NULL;
	MSIHANDLE	hMRecord= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcExtension[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;

    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Extension`, `Component_`, `ProgId_` from Extension" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Extension`=\'", wcAction, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `Verb`, `Command`, `Argument` from Verb where `Extension_`=\'" );
	QueryExt wcQuery2 ( L"select `ShellNew`, `ShellNewValue` from Extension where `Extension`=\'" );
	QueryExt wcQuery3 ( L"select `MIME_` from Extension where `Extension`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView (  &hView, wcProductCode, wcQuery, L"Extension", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcExtension, &dwBufSize));
                        PutProperty(m_pObj, pExtension, wcExtension);

						// make query on fly
						wcQuery1.Append ( 2, wcExtension, L"\'" );

						PutKeyProperty ( m_pObj, pActionID, wcExtension, &bActionID, m_pRequest, 1, wcProductCode );
                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName	(	msidata.GetDatabase (),
														wcProductCode,
														wcBuf
													)
						   )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pProgID, wcBuf);
                            PutProperty(m_pObj, pName, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);
                            PutProperty(m_pObj, pDescription, wcBuf);

                            CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hVView));
                            CheckMSI(g_fpMsiViewExecute(hVView, 0));

                            try{

                                uiStatus = g_fpMsiViewFetch(hVView, &hVRecord);

                                if(uiStatus != ERROR_NO_MORE_ITEMS){
                                    CheckMSI(uiStatus);

                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hVRecord, 1, wcBuf, &dwBufSize));
                                    PutProperty(m_pObj, pVerb, wcBuf);

                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hVRecord, 2, wcBuf, &dwBufSize));
                                    PutProperty(m_pObj, pCommand, wcBuf);

                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hVRecord, 3, wcBuf, &dwBufSize));
                                    PutProperty(m_pObj, pArgument, wcBuf);
                                }

								// make query on fly
								wcQuery2.Append ( 2, wcExtension, L"\'" );

                                if((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery2, &hSView)) !=
                                    ERROR_BAD_QUERY_SYNTAX){
                                    CheckMSI(uiStatus);

                                    CheckMSI(g_fpMsiViewExecute(hSView, 0));

                                    try{

                                        uiStatus = g_fpMsiViewFetch(hSView, &hSRecord);

                                        if(uiStatus != ERROR_NO_MORE_ITEMS){
                                            CheckMSI(uiStatus);

                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hSRecord, 1, wcBuf, &dwBufSize));
                                            PutProperty(m_pObj, pShellNew, wcBuf);

                                            dwBufSize = BUFF_SIZE;
                                            CheckMSI(g_fpMsiRecordGetStringW(hSRecord, 2, wcBuf, &dwBufSize));
                                            PutProperty(m_pObj, pShellNewValue, wcBuf);
                                        }

                                    }catch(...){

                                        g_fpMsiViewClose(hSView);
                                        g_fpMsiCloseHandle(hSView);
                                        g_fpMsiCloseHandle(hSRecord);
                                        throw;
                                    }

                                    g_fpMsiViewClose(hSView);
                                    g_fpMsiCloseHandle(hSView);
                                    g_fpMsiCloseHandle(hSRecord);
                                }
								else
								{
									// make query on fly
									wcQuery3.Append ( 2, wcExtension, L"\'" );

                                    if((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery3, &hMView)) !=
                                        ERROR_BAD_QUERY_SYNTAX){
                                        CheckMSI(uiStatus);

                                        CheckMSI(g_fpMsiViewExecute(hMView, 0));

                                        try{

                                            uiStatus = g_fpMsiViewFetch(hMView, &hMRecord);

                                            
                                            if(uiStatus != ERROR_NO_MORE_ITEMS){
                                                CheckMSI(uiStatus);

                                                dwBufSize = BUFF_SIZE;
                                                CheckMSI(g_fpMsiRecordGetStringW(hMRecord, 1, wcBuf, &dwBufSize));
                                                PutProperty(m_pObj, pMIME, wcBuf);
                                            }

                                        }catch(...){

                                            g_fpMsiViewClose(hMView);
                                            g_fpMsiCloseHandle(hMView);
                                            g_fpMsiCloseHandle(hMRecord);
                                            throw;
                                        }

                                        g_fpMsiViewClose(hMView);
                                        g_fpMsiCloseHandle(hMView);
                                        g_fpMsiCloseHandle(hMRecord);

                                    }
                                }

                            }catch(...){

                                g_fpMsiViewClose(hVView);
                                g_fpMsiCloseHandle(hVView);
                                g_fpMsiCloseHandle(hVRecord);
                                throw;
                            }

                            g_fpMsiViewClose(hVView);
                            g_fpMsiCloseHandle(hVView);
                            g_fpMsiCloseHandle(hVRecord);

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\extensioninfoaction.h ===
// ExtensionInfoAction.h: interface for the CExtensionInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EXTENSIONINFOACTION_H__75F6BA2C_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_EXTENSIONINFOACTION_H__75F6BA2C_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CExtensionInfoAction : public CGenericClass  
{
public:
	CExtensionInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CExtensionInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst,
		IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_EXTENSIONINFOACTION_H__75F6BA2C_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\filespecification.cpp ===
// FileSpecification.cpp: implementation of the CFileSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "FileSpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileSpecification::CFileSpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CFileSpecification::~CFileSpecification()
{

}

HRESULT CFileSpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcID[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcFile[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    INSTALLSTATE piInstalled;
    int iState;

    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcFile);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}
			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File`, `Component_`, `FileName`, `FileSize`, `Version`, `Language`, `Attributes`, `Sequence` from File" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File`=\'", wcFile, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"File", FALSE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutProperty(m_pObj, pFileSize, g_fpMsiRecordGetInteger(hRecord, 4));

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pVersion, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pLanguage, wcBuf);

                        PutProperty(m_pObj, pAttributes, g_fpMsiRecordGetInteger(hRecord, 7));

                        PutProperty(m_pObj, pSequence, g_fpMsiRecordGetInteger(hRecord, 8));

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pName, wcBuf);

						// make query on fly
						wcQuery1.Append ( 2, wcBuf, L"\'" );

                        if(ERROR_SUCCESS == g_fpMsiDatabaseOpenViewW( msidata.GetDatabase (), wcQuery1, &hSEView)){

                            if(ERROR_SUCCESS == g_fpMsiViewExecute(hSEView, 0)){

                                try{
										if ( ERROR_SUCCESS == g_fpMsiViewFetch(hSEView, &hSERecord)){

											dwBufSize = BUFF_SIZE;
											CheckMSI(g_fpMsiRecordGetStringW(hSERecord, 1, wcID, &dwBufSize));

											if(ValidateComponentID(wcID, wcProductCode)){

												PutProperty(m_pObj, pSoftwareElementID, wcID);

												dwBufSize = BUFF_SIZE;
												wcscpy(wcBuf, L"");
												piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcID, wcBuf, &dwBufSize);
												SoftwareElementState(piInstalled, &iState);
												PutProperty(m_pObj, pSoftwareElementState, iState);

												PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

												dwBufSize = BUFF_SIZE;
												CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct (), L"ProductVersion", wcBuf,
													&dwBufSize));
												PutProperty(m_pObj, pVersion, wcBuf);
											//----------------------------------------------------

												if(bCheck) bMatch = true;

												if((atAction != ACTIONTYPE_GET)  || bMatch){

													hr = pHandler->Indicate(1, &m_pObj);
												}
											}
										}

                                }catch(...){
                                
                                    g_fpMsiViewClose(hSEView);
                                    g_fpMsiCloseHandle(hSEView);
                                    g_fpMsiCloseHandle(hSERecord);
                                    throw;
                                }

                                g_fpMsiViewClose(hSEView);
                                g_fpMsiCloseHandle(hSEView);
                                g_fpMsiCloseHandle(hSERecord);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
				msidata.CloseProduct ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
			msidata.CloseProduct ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\filespecification.h ===
// FileSpecification.h: interface for the CFileSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILESPECIFICATION_H__DB614F28_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_FILESPECIFICATION_H__DB614F28_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CFileSpecification : public CGenericClass  
{
public:
	CFileSpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CFileSpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_FILESPECIFICATION_H__DB614F28_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\fontinfoaction.h ===
// FontInfoAction.h: interface for the CFontInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FONTINFOACTION_H__75F6BA24_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_FONTINFOACTION_H__75F6BA24_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CFontInfoAction : public CGenericClass  
{
public:
	CFontInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CFontInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_FONTINFOACTION_H__75F6BA24_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\genericclass.cpp ===
// GenericClass.cpp: implementation of the CGenericClass class.
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "GenericClass.h"
#include <wininet.h>

#define   READ_HANDLE 0
#define   WRITE_HANDLE 1

#include "ExtendString.h"
#include "ExtendQuery.h"

CRITICAL_SECTION CGenericClass::m_cs;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGenericClass::CGenericClass(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx)
{
    m_pRequest = pObj;
    m_pNamespace = pNamespace;
    m_pCtx = pCtx;
    m_pObj = NULL;
    m_pClassForSpawning = NULL;
}

CGenericClass::~CGenericClass()
{
}

void CGenericClass::CleanUp()
{
    if(m_pClassForSpawning){
    
        m_pClassForSpawning->Release();
        m_pClassForSpawning = NULL;
    }
}

void CGenericClass::CheckMSI(UINT uiStatus)
{
    if(uiStatus == E_OUTOFMEMORY){
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }else if(uiStatus != ERROR_SUCCESS){
        throw ConvertError(uiStatus);
    }
}

HRESULT CGenericClass::CheckOpen(UINT uiStatus)
{
    switch(uiStatus){
    case ERROR_SUCCESS:
        return WBEM_S_NO_ERROR;
    case ERROR_ACCESS_DENIED:
        return WBEM_E_PRIVILEGE_NOT_HELD;
    default:
        return WBEM_E_FAILED;
    }
}

HRESULT CGenericClass::SetSinglePropertyPath(WCHAR wcProperty[])
{
    if(m_pRequest->m_iValCount > m_pRequest->m_iPropCount){

        m_pRequest->m_Property[m_pRequest->m_iPropCount] = SysAllocString(wcProperty);

        if(!m_pRequest->m_Property[(m_pRequest->m_iPropCount)++])
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    return S_OK;
}

WCHAR * CGenericClass::GetFirstGUID(WCHAR wcIn[], WCHAR wcOut[])
{
	// safe operation
	// tested outside of that call
    wcscpy(wcOut, wcIn);
    wcOut[38] = NULL;

    return wcOut;
}

WCHAR * CGenericClass::RemoveFinalGUID(WCHAR wcIn[], WCHAR wcOut[])
{
	// safe operation
	// tested outside of that call
    wcscpy(wcOut, wcIn);
    wcOut[wcslen(wcOut) - 38] = NULL;

    return wcOut;
}

HRESULT CGenericClass::SpawnAnInstance(IWbemServices *pNamespace, IWbemContext *pCtx,
                        IWbemClassObject **pObj, BSTR bstrName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if(!m_pClassForSpawning){

        //Get ourselves an instance
        if(FAILED(hr = m_pNamespace->GetObject(bstrName, 0, m_pCtx, &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return hr;
        }
    }

    hr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return hr;
}

HRESULT CGenericClass::SpawnAnInstance(IWbemClassObject **pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if(!m_pClassForSpawning){

        //Get ourselves an instance
        if(FAILED(hr = m_pNamespace->GetObject(m_pRequest->m_bstrClass, 0, m_pCtx,
            &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return hr;
        }
    }

    hr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp)
        throw he;

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw he;

    VARIANT vp;
    VariantInit(&vp);
    V_VT(&vp) = VT_BSTR;
    V_BSTR(&vp) = SysAllocString(wcValue);
    if(!V_BSTR(&vp)){

        SysFreeString(bstrName);
        throw he;
    }

    if((wcValue == NULL) || (0 != _wcsicmp(wcValue, L""))){

        hr = pObj->Put(bstrName, 0, &vp, NULL);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            VariantClear(&vp);
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(&vp);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, int iValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    if(iValue != MSI_NULL_INTEGER){

	    VARIANT pv;
        VariantInit(&pv);
        V_VT(&pv) = VT_I4;
        V_I4(&pv) = iValue;

        hr = pObj->Put(bstrName, 0, &pv, NULL);

        VariantClear(&pv);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, float dValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    VariantInit(&pv);
    V_VT(&pv) = VT_R4;
    V_R4(&pv) = dValue;

    hr = pObj->Put(bstrName, 0, &pv, NULL);

    SysFreeString(bstrName);
    VariantClear(&pv);

    if(FAILED(hr))
        throw hr;

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, bool bValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    VariantInit(&pv);
    V_VT(&pv) = VT_BOOL;
    if(bValue) V_BOOL(&pv) = VARIANT_TRUE;
    else V_BOOL(&pv) = VARIANT_FALSE;

    hr = pObj->Put(bstrName, 0, &pv, NULL);

    SysFreeString(bstrName);
    VariantClear(&pv);

    if(FAILED(hr))
        throw hr;

    return hr;
}

HRESULT CGenericClass::PutKeyProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue,
                                      bool *bKey, CRequestObject *pRequest)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    VariantInit(&pv);
    V_VT(&pv) = VT_BSTR;
#ifdef _STRIP_ESCAPED_CHARS
    V_BSTR(&pv) = SysAllocString(ConvertToASCII(wcValue));
#else
    V_BSTR(&pv) = SysAllocString(wcValue);
#endif //_STRIP_ESCAPED_CHARS

    if(!V_BSTR(&pv))
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    if((wcValue == NULL) || (0 != wcscmp(wcValue, L""))){

        hr = pObj->Put(bstrName, 0, &pv, NULL);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            VariantClear(&pv);
            throw hr;
        }

        // Find the keys
        *bKey = false;
        int iPos = -1;
        if(FindIn(pRequest->m_Property, bstrName, &iPos) &&
            FindIn(pRequest->m_Value, V_BSTR(&pv), &iPos)) *bKey = true;

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(&pv);

    return hr;
}

HRESULT CGenericClass::PutKeyProperty(IWbemClassObject *pObj, const char *wcProperty, int iValue,
                                      bool *bKey, CRequestObject *pRequest)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    WCHAR wcBuf[BUFF_SIZE];

    if(iValue != MSI_NULL_INTEGER){

        VariantInit(&pv);
        V_VT(&pv) = VT_I4;
        V_I4(&pv) = iValue;

        hr = pObj->Put(bstrName, 0, &pv, NULL);

        VariantClear(&pv);

        if(FAILED(hr))
		{
            SysFreeString(bstrName);
            throw hr;
        }

        // Find the keys
        _itow(iValue, wcBuf, 10);
        BSTR bstrValue = SysAllocString(wcBuf);
        if(!bstrValue)
		{
            SysFreeString(bstrName);
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        *bKey = false;
        int iPos = -1;
        if(FindIn(pRequest->m_Property, bstrName, &iPos) &&
            FindIn(pRequest->m_Value, bstrValue, &iPos)) *bKey = true;

        SysFreeString(bstrValue);

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);

    return hr;
}

bool CGenericClass::FindIn(BSTR bstrProp[], BSTR bstrSearch, int *iPos)
{
    int i = 0;

    if(*iPos == (-1))
	{
        while(bstrProp[i] != NULL)
		{
            if(0 == _wcsicmp(bstrProp[i], bstrSearch))
			{
                *iPos = i;
                return true;
            }

            i++;
        }
    }
	else
	{
        if(0 == _wcsicmp(bstrProp[*iPos], bstrSearch))
		{
			return true;
		}
    }

    return false;
}

bool CGenericClass::GetView (	MSIHANDLE *phProduct,
								WCHAR *wcPackage,
								WCHAR *wcQuery,
								WCHAR *wcTable,
								BOOL bCloseProduct,
								BOOL bCloseDatabase
							)
{
    return msidata.GetView ( phProduct, wcPackage, wcQuery, wcTable, bCloseProduct, bCloseDatabase );
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, WCHAR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(V_VT(&v) == VT_BSTR) wcscpy(wcValue, V_BSTR(&v));
        else wcscpy(wcValue, L"");
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, BSTR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(wcslen(V_BSTR(&v)) > INTERNET_MAX_PATH_LENGTH) return WBEM_E_INVALID_METHOD_PARAMETERS;

        if(V_VT(&v) == VT_BSTR) *wcValue = SysAllocString(V_BSTR(&v));
        else *wcValue = SysAllocString(L"");

        if(!wcValue)
            throw he;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, int *piValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(V_VT(&v) == VT_I4) *piValue = V_I4(&v);
        else *piValue = 0;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, bool *pbValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if((V_VT(&v) == VT_BOOL) & V_BOOL(&v)) *pbValue = true;
        else *pbValue = false;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

/****************************************************************************
 *
 *      CGenericClass::LaunchProcess()
 *
 *      In:
 *          wcCommandLine - the commandline to pass to msimeth
 *
 *      Out:
 *          uiStatus - The variable that will recieve the return value
 *                     from the method call
 *
 *
 *      this method will handle method execution on NT4, where security
 *      restrictions prevent calling another DCOM server with an impersonating
 *      thread token.  This method will launch another process to handle the
 *      opperation after setting up a pipe for passing status messages from the
 *      external process back to the provider.
 *
 *****************************************************************************/
HRESULT CGenericClass::LaunchProcess(WCHAR *wcAction, WCHAR *wcCommandLine, UINT *uiStatus) 
{
    HRESULT hr = WBEM_E_FAILED;

    //check to see if server already running
    HANDLE hMutex = CreateMutex(NULL, TRUE, TEXT("MSIPROV_METHODS_SERVER"));

    if(hMutex){

        IWbemClassObject *pObj = NULL;
        BSTR bstrProcess = SysAllocString(L"Win32_Process");

        SetFileApisToOEM();

        HANDLE hPipe = CreateNamedPipe(L"\\\\.\\pipe\\msimeth_pipe", PIPE_ACCESS_INBOUND,
            (PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT), PIPE_UNLIMITED_INSTANCES,
            10000, 10000, 50000, NULL);

        if(SUCCEEDED(hr = m_pNamespace->GetObject(bstrProcess, 0, m_pCtx, &pObj, NULL))){
        
            IWbemClassObject *pInParam = NULL;
            IWbemClassObject *pOutParam = NULL;
            BSTR bstrCreate = SysAllocString(L"Create");

            // get the method paramater objects
            if(SUCCEEDED(hr = pObj->GetMethod(bstrCreate, 0, &pInParam, &pOutParam))){
            
                VARIANT v;
                BSTR bstrCommandLine = SysAllocString(L"CommandLine");
                IWbemClassObject *pStartup = NULL;

                VariantInit(&v);
                V_VT(&v) = VT_BSTR;
 
                WCHAR wcCommand[BUFF_SIZE];
                WCHAR wcTmp[10];
                UINT uiSize = BUFF_SIZE;
                GetSystemDirectoryW(wcCommand, uiSize);
                wcscat(wcCommand, L"\\wbem\\msimeth.exe ");
                wcscat(wcCommand, wcAction);
                wcscat(wcCommand, L" ");
                wcscat(wcCommand, _itow(m_pRequest->m_iThreadID, wcTmp, 10));
                wcscat(wcCommand, L" ");
                wcscat(wcCommand, wcCommandLine);

                V_BSTR(&v) = SysAllocString(wcCommand);

                // populate the in parameters
                if(SUCCEEDED(hr = pInParam->Put(bstrCommandLine, 0, &v, NULL))){

                    VariantClear(&v);

                    BSTR bstrProcessStartup = SysAllocString(L"Win32_ProcessStartup");
                    IWbemClassObject *pStartupObj = NULL;

                    if(SUCCEEDED(hr = m_pNamespace->GetObject(bstrProcessStartup, 0, m_pCtx,
                        &pStartupObj, NULL))){

                        IWbemClassObject *pStartupInst = NULL;

                        if(SUCCEEDED(hr = pStartupObj->SpawnInstance(0, &pStartupInst))){

                            LPVOID pEnv = GetEnvironmentStrings();
                            WCHAR *pwcVar = (WCHAR *)pEnv;

                            SAFEARRAYBOUND sbArrayBounds ;

                            long lCount = GetVarCount(pEnv);
                            sbArrayBounds.cElements = lCount;
                            sbArrayBounds.lLbound = 0;

                            if(V_ARRAY(&v) = SafeArrayCreate(VT_BSTR, 1, &sbArrayBounds)){

                                V_VT(&v) = VT_BSTR | VT_ARRAY ; 

                                BSTR bstrVal;

                                //get the environment variables into a VARIANT
                                for(long j = 0; j < lCount; j++){

                                    bstrVal = SysAllocString(pwcVar);
                                    SafeArrayPutElement(V_ARRAY(&v), &j, bstrVal);
                                    SysFreeString(bstrVal);

                                    pwcVar = GetNextVar(pwcVar);
                                }
                                
                                BSTR bstrEnvironmentVariables = SysAllocString(L"EnvironmentVariables");

                                if(SUCCEEDED(hr = pStartupInst->Put(bstrEnvironmentVariables, 0,
                                    &v, NULL))){

                                    VariantClear(&v);

                                    V_VT(&v) = VT_UNKNOWN;
                                    V_UNKNOWN(&v) = (IDispatch *)pStartupInst;
                                    pStartupInst->AddRef();

                                    BSTR bstrProcessStartupInformation = SysAllocString(L"ProcessStartupInformation");

                                    hr = pInParam->Put(bstrProcessStartupInformation, 0, &v, NULL);

                                    SysFreeString(bstrProcessStartupInformation);
                                }

                                SysFreeString(bstrEnvironmentVariables);
                            }

                            FreeEnvironmentStrings((LPWSTR)pEnv);

                            pStartupInst->Release();
                        }
                    
                        pStartupObj->Release();
                    }

                    SysFreeString(bstrProcessStartup);
                            
                    //we've no created our input object, so let's make the call
                    if(SUCCEEDED(hr = m_pNamespace->ExecMethod(bstrProcess, bstrCreate, 0,
                        m_pCtx, pInParam, &pOutParam, NULL))){
                        
                        VariantClear(&v);
                        BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                        if(SUCCEEDED(hr = pOutParam->Get(bstrReturnValue, 0, &v, NULL, NULL))){
                            
                            hr = V_I4(&v);
                            VariantClear(&v);

                            if(hr == 0){

                                BSTR bstrProcessID = SysAllocString(L"ProcessID");

                                if(SUCCEEDED(hr = pOutParam->Get(bstrProcessID, 0, &v, NULL, NULL))){
                                    
                                    //open process handle to check for exit
                                    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                                        (DWORD)V_I4(&v));

                                    ReleaseMutex(hMutex);
                                    
                                    if(hProcess){

                                        BOOL bRead = FALSE;
                                        DWORD dwRead = 0;
                                        WCHAR wcBuf[BUFF_SIZE];
                                        int nExitCode = STILL_ACTIVE;

                                        if(!GetExitCodeProcess(hProcess, (unsigned long*)&nExitCode)){

                                            hr = GetLastError();
                                        }

                                        /////////////////////////////////////////////////
                                        // Handle status messages as they are recieved

                                        while(nExitCode == STILL_ACTIVE){

                                            //synchronized pipe access
    //                                      WaitForSingleObject(hMutex, INFINITE);

                                            bRead = ReadFile(hPipe, wcBuf, BUFF_SIZE, &dwRead, NULL);

    //                                      ReleaseMutex(hMutex);

                                            if(!bRead){

                                                switch(GetLastError()){
                                                case ERROR_MORE_DATA:
                                                    //deal with unable to read whole message
                                                    break;
                                                case ERROR_HANDLE_EOF:
                                                    break;
                                                }
                                                
                                            }

                                            if(bRead && dwRead){

                                                //do some parsing, then...
                                                int iContext = _wtoi(wcstok(wcBuf, L"~"));
                                                UINT uiMessageType = _wtoi(wcstok(NULL, L"~"));
                                                LPWSTR lpwMessage = wcstok(NULL, L"\n");

                                                //process the message
                                                MyEventHandler(m_pRequest, uiMessageType, lpwMessage);
                                            }

                                            if(!GetExitCodeProcess(hProcess, (unsigned long*)&nExitCode)){

                                                hr = GetLastError();
                                                break;
                                            }
                                         
                                        }

                                        *uiStatus = nExitCode;

                                        CloseHandle(hPipe);
                                    }

                                }

                                SysFreeString(bstrProcessID);
                            
                            }else{

                                hr = WBEM_E_FAILED;
                            }
                        }

                        SysFreeString(bstrReturnValue);
                    }

                }

                pInParam->Release();
                pOutParam->Release();
                VariantClear(&v);
            }

            SysFreeString(bstrCreate);
            pObj->Release();
        }

        SysFreeString(bstrProcess);
    }

    if(hMutex){

        CloseHandle(hMutex);
        hMutex = NULL;
    }

    return hr;
}

INSTALLUI_HANDLER CGenericClass::SetupExternalUI()
{
	g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

	INSTALLUI_HANDLER ui = NULL;
	ui = g_fpMsiSetExternalUIW	(	MyEventHandler,
									(
										INSTALLLOGMODE_PROGRESS |
										INSTALLLOGMODE_ACTIONDATA |
										INSTALLLOGMODE_INFO |
										INSTALLLOGMODE_WARNING |
										INSTALLLOGMODE_ACTIONSTART
									),
									m_pRequest
								);

	g_fpMsiEnableLogW	(
							(	INSTALLLOGMODE_ACTIONDATA |
								INSTALLLOGMODE_INFO |
								INSTALLLOGMODE_FATALEXIT |
								INSTALLLOGMODE_ERROR |
								INSTALLLOGMODE_WARNING |
								INSTALLLOGMODE_USER |
								INSTALLLOGMODE_VERBOSE |
								INSTALLLOGMODE_RESOLVESOURCE |
								INSTALLLOGMODE_OUTOFDISKSPACE |
								INSTALLLOGMODE_COMMONDATA |
								INSTALLLOGMODE_PROPERTYDUMP |
								INSTALLLOGMODE_ACTIONSTART
							),
							g_wcpLoggingDir,
							INSTALLLOGATTRIBUTES_APPEND
						);

    return ui;
}

void CGenericClass::RestoreExternalUI( INSTALLUI_HANDLER ui )
{
	g_fpMsiSetExternalUIW	(	ui, 0, NULL );
}

WCHAR * CGenericClass::GetNextVar(WCHAR *pwcStart)
{

    WCHAR *pwc = pwcStart;

    //get to end of variable
    while(*pwc){ pwc++; }

    return ++pwc;
}

long CGenericClass::GetVarCount(void * pEnv)
{

    long lRetVal = 0;
    WCHAR *pwc = (WCHAR *)pEnv;

    //count the variables
    while(*pwc){

        //get to end of variable
        while(*pwc){ pwc++; }

        pwc++;
        lRetVal++;
    }

    return lRetVal;
}

//Special Property Methods
HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue, DWORD dwCount, ... )
{
	if ( dwCount )
	{
		HRESULT hr = E_FAIL;

		CStringExt prop ( wcValue );

		va_list argList;
		va_start ( argList, dwCount );
		hr = prop.AppendList ( 0, NULL, dwCount, argList );
		va_end ( argList );

		if SUCCEEDED ( hr )
		{
			hr = PutProperty ( pObj, wcProperty, prop );
		}

		return hr;
	}
	else
	{
		return PutProperty ( pObj, wcProperty,  wcValue );
	}
}

//Special Key Property Methods
HRESULT CGenericClass::PutKeyProperty	(	IWbemClassObject *pObj,
											const char *wcProperty,
											WCHAR *wcValue,
											bool *bKey,
											CRequestObject *pRequest,
											DWORD dwCount,
											...
										)
{
	if ( dwCount )
	{
		HRESULT hr = E_FAIL;

		CStringExt prop ( wcValue );

		va_list argList;
		va_start ( argList, dwCount );
		hr = prop.AppendList ( 0, NULL, dwCount, argList );
		va_end ( argList );

		if SUCCEEDED ( hr )
		{
			hr = PutKeyProperty ( pObj, wcProperty,prop, bKey, pRequest );
		}

		return hr;
	}
	else
	{
		return PutKeyProperty ( pObj, wcProperty, wcValue, bKey, pRequest );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\fontinfoaction.cpp ===
// FontInfoAction.cpp: implementation of the CFontInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "FontInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFontInfoAction::CFontInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CFontInfoAction::~CFontInfoAction()
{

}

HRESULT CFontInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `FontTitle` from Font" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Font", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pFile, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pFontTitle, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                    //----------------------------------------------------

                        if(bActionID) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\inifile.h ===
// IniFile.h: interface for the CIniFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_INIFILE_H__02FF6C8C_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_INIFILE_H__02FF6C8C_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CIniFile : public CGenericClass  
{
public:
	CIniFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CIniFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_INIFILE_H__02FF6C8C_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\installedsoftwareelement.cpp ===
// InstalledSoftwareElement.cpp: implementation of the CInstalledSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <tchar.h>
#include "InstalledSoftwareElement.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CInstalledSoftwareElement::CInstalledSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CInstalledSoftwareElement::~CInstalledSoftwareElement()
{

}

HRESULT CInstalledSoftwareElement::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcSoftware[BUFF_SIZE];
    WCHAR wcSysName[BUFF_SIZE];
    WCHAR wcComponentID[BUFF_SIZE];
    WCHAR wcElmName[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    CRequestObject *pSysRObj = NULL;
    CRequestObject *pElmRObj = NULL;
    bool bGotID = false;
    bool bGotName = false;
    bool bSysName = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int j;
        //GetObject optimizations
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        for(j = 0; j < m_pRequest->m_iPropCount; j++){
            
            if(_wcsicmp(m_pRequest->m_Property[j], L"System") == 0){

                pSysRObj = new CRequestObject();
                if(!pSysRObj) throw he;

                pSysRObj->Initialize(m_pNamespace);

                pSysRObj->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pSysRObj){

            for(j = 0; j < pSysRObj->m_iPropCount; j++){

                if(_wcsicmp(pSysRObj->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen ( pSysRObj->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcSysName, pSysRObj->m_Value[j]);
						bSysName = true;
						break;
					}
                }
            }

            pSysRObj->Cleanup();
            delete pSysRObj;
            pSysRObj = NULL;
        }

        for(j = 0; j < m_pRequest->m_iPropCount; j++){
            
            if(_wcsicmp(m_pRequest->m_Property[j], L"Element") == 0){

                pElmRObj = new CRequestObject();
                if(!pElmRObj) throw he;

                pElmRObj->Initialize(m_pNamespace);

                pElmRObj->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pElmRObj){

            for(j = 0; j < pElmRObj->m_iPropCount; j++){
            
                if(_wcsicmp(pElmRObj->m_Property[j], L"SoftwareElementID") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen ( pElmRObj->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcComponentID, pElmRObj->m_Value[j]);
						bGotID = true;
					}
                }

                if(_wcsicmp(pElmRObj->m_Property[j], L"Name") == 0){

                    //Get the name we're looking for
					if ( ::SysStringLen ( pElmRObj->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcElmName, pElmRObj->m_Value[j]);
						bGotName = true;
					}
                }
            }

            pElmRObj->Cleanup();
            delete pElmRObj;
            pElmRObj = NULL;
        }
    }

    //These will change from class to class
    bool bSoftware, bSystem;

    CStringExt wcComputer;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component` from Component" );

    //optimize for GetObject
    if ( bGotID || bGotName )
	{
		if ( bGotName )
		{
			wcQuery.Append ( 3, L" where `Component`=\'", wcElmName, L"\'" );
		}

		if ( bGotID )
		{
			if ( bGotName )
			{
				wcQuery.Append ( 3, L" or `ComponentId`=\'", wcComponentID, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `ComponentId`=\'", wcComponentID, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Component", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

					dwBufSize = BUFF_SIZE;
					uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																wcBuf,
																wcProductCode,
																wcSoftware,
																&dwBufSize
														   );

                    if( uiStatus == ERROR_SUCCESS )
					{
                        PutKeyProperty(m_pObj, pSoftware, wcSoftware, &bSoftware, m_pRequest);

                        TCHAR cBuf[MAX_COMPUTERNAME_LENGTH + 1];
                        dwBufSize = (MAX_COMPUTERNAME_LENGTH+1) * sizeof ( TCHAR );

                        if(!GetComputerName(cBuf, &dwBufSize)) throw WBEM_E_FAILED;

						// safe operation
                        wcComputer.Copy ( L"Win32_ComputerSystem.Name=\"" );

						#ifndef	UNICODE
                        WCHAR wcTmp[MAX_COMPUTERNAME_LENGTH + 1];
                        mbstowcs(wcTmp, cBuf, MAX_COMPUTERNAME_LENGTH + 1);

                        wcComputer.Append ( 2, wcTmp, L"\"" );
						#else	UNICODE
                        wcComputer.Append ( 2, cBuf, L"\"" );
						#endif	UNICODE

                        PutKeyProperty(m_pObj, pSystem, wcComputer, &bSystem, m_pRequest);

                        if(bSoftware && bSystem) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\launchcondition.h ===
// LaunchCondition.h: interface for the CLaunchCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LAUNCHCONDITION_H__75F6BA1D_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_LAUNCHCONDITION_H__75F6BA1D_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CLaunchCondition : public CGenericClass  
{
public:
	CLaunchCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CLaunchCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_LAUNCHCONDITION_H__75F6BA1D_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\installedsoftwareelement.h ===
// InstalledSoftwareElement.h: interface for the CInstalledSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_INSTALLEDSOFTWAREELEMENT_H__EAA368A5_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_INSTALLEDSOFTWAREELEMENT_H__EAA368A5_DEA4_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CInstalledSoftwareElement : public CGenericClass  
{
public:
	CInstalledSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CInstalledSoftwareElement();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_INSTALLEDSOFTWAREELEMENT_H__EAA368A5_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\launchcondition.cpp ===
// LaunchCondition.cpp: implementation of the CLaunchCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "LaunchCondition.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLaunchCondition::CLaunchCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CLaunchCondition::~CLaunchCondition()
{

}

HRESULT CLaunchCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcCondition[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;

    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcCondition);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Condition`, `Description` from LaunchCondition" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Condition`=\'", wcCondition, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"LaunchCondition", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pCondition, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pDescription, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\inifile.cpp ===
// IniFile.cpp: implementation of the CIniFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "IniFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIniFile::CIniFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CIniFile::~CIniFile()
{

}

HRESULT CIniFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcFile[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcFile);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `IniFile`, `Component_`, `Section`, `Key`, `Value`, `Action` from IniFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `IniFile`=\'", wcFile, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"IniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pIniFile, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSection, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pKey, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pValue, wcBuf);

                            PutProperty(m_pObj, pAction, g_fpMsiRecordGetInteger(hRecord, 6));

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\genericclass.h ===
// GenericClass.h: interface for the CGenericClass class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_

#include "requestobject.h"
#include "MSIDataLock.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGenericClass  
{
	friend BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID );

public:
    CGenericClass(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
    virtual ~CGenericClass();

    //The instance write class which can optionally be implemented
    virtual HRESULT PutInst	(	CRequestObject *pObj,
								IWbemClassObject *pInst,
								IWbemObjectSink *pHandler,
								IWbemContext *pCtx
							)	= 0;

    IWbemClassObject *m_pObj;

    //The instance creation class which must be implemented
    virtual HRESULT CreateObject	(	IWbemObjectSink *pHandler,
										ACTIONTYPE atAction
									)	= 0;

    void CleanUp();

    CRequestObject *m_pRequest;

protected:

    //Property Methods
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, int iValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, float dValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, bool bValue);

	//Special Property Methods
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue, DWORD dwCount, ... );

    //Key Property Methods
    HRESULT PutKeyProperty	(	IWbemClassObject *pObj,
								const char *wcProperty,
								WCHAR *wcValue,
								bool *bKey,
								CRequestObject *pRequest
							);

    HRESULT PutKeyProperty	(	IWbemClassObject *pObj,
								const char *wcProperty,
								int iValue,
								bool *bKey,
								CRequestObject *pRequest
							);

    //Special Key Property Methods
    HRESULT PutKeyProperty	(	IWbemClassObject *pObj,
								const char *wcProperty,
								WCHAR *wcValue,
								bool *bKey,
								CRequestObject *pRequest,
								DWORD dwCount,
								...
							);

    //This handles initialization of views
    bool GetView	(	
						MSIHANDLE *phView,
						WCHAR *wcPackage,
						WCHAR *wcQuery,
						WCHAR *wcTable,
						BOOL bCloseProduct,
						BOOL bCloseDatabase
					);

    //Utility Methods
    void CheckMSI(UINT uiStatus);
    HRESULT CheckOpen(UINT uiStatus);
    bool FindIn(BSTR bstrProp[], BSTR bstrSearch, int *iPos);
    HRESULT SetSinglePropertyPath(WCHAR wcProperty[]);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, WCHAR *wcValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, BSTR *wcValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, int *piValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, bool *pbValue);

    WCHAR * GetFirstGUID(WCHAR wcIn[], WCHAR wcOut[]);
    WCHAR * RemoveFinalGUID(WCHAR wcIn[], WCHAR wcOut[]);

    HRESULT SpawnAnInstance	(	IWbemServices *pNamespace,
								IWbemContext *pCtx,
								IWbemClassObject **pObj,
								BSTR bstrName
							);

    HRESULT SpawnAnInstance	(	IWbemClassObject **pObj	);

    INSTALLUI_HANDLER	SetupExternalUI		();								//Requires a current CRequestObject
	void				RestoreExternalUI	( INSTALLUI_HANDLER ui );		//Restore UI handle

	MSIDataLock msidata;

    IWbemServices *m_pNamespace;
    IWbemClassObject *m_pClassForSpawning;
    IWbemContext *m_pCtx;

    //functions/members for NT4 install fix
    HRESULT LaunchProcess(WCHAR *wcAction, WCHAR *wcCommandLine, UINT *uiStatus);
    WCHAR * GetNextVar(WCHAR *pwcStart);
    long GetVarCount(void * pEnv);

    static CRITICAL_SECTION m_cs;
};

#endif // !defined(AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\main.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#define _WIN32_WINNT 0x0400
#include <objbase.h>
#include <locale.h>
#include "classfac.h"
#include <stdio.h>
#include <tchar.h>

extern BOOL APIENTRY DllMain (
                              
    HINSTANCE hinstDLL,
    DWORD fdwReason, 
    LPVOID lpReserved
) ;

DEFINE_GUID(CLSID_MSIprov,0xbe0a9830, 0x2b8b, 0x11d1, 0xa9, 0x49, 0x0, 0x60, 0x18, 0x1e, 0xbb, 0xad);
// {BE0A9830-2B8B-11D1-A949-0060181EBBAD}

DWORD g_InstanceRegister = 0 ;
DWORD g_EventRegister = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

BOOL s_Exiting = FALSE ;

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
    long t_rc = 0 ;

    switch ( a_message )
    {
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

        case WM_DESTROY:
        {
            PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
        }
        break ;

        default:
        {       
            t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
        }
        break ;
    }

    return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
    static wchar_t *t_TemplateCode = L"TemplateCode" ;

    WNDCLASS  t_wc ;
 
    t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
    t_wc.lpfnWndProc      = WindowsMainProc ;
    t_wc.cbClsExtra       = 0 ;
    t_wc.cbWndExtra       = 0 ;
    t_wc.hInstance        = a_HInstance ;
    t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
    t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
    t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
    t_wc.lpszMenuName     = NULL ;
    t_wc.lpszClassName    = t_TemplateCode ;
 
    ATOM t_winClass = RegisterClass ( &t_wc ) ;

    HWND t_HWnd = CreateWindow (

        t_TemplateCode ,              // see RegisterClass() call
        t_TemplateCode ,                      // text for window title bar
        WS_OVERLAPPEDWINDOW ,               // window style
        CW_USEDEFAULT ,                     // default horizontal position
        CW_USEDEFAULT ,                     // default vertical position
        CW_USEDEFAULT ,                     // default width
        CW_USEDEFAULT ,                     // default height
        NULL ,                              // overlapped windows have no parent
        NULL ,                              // use the window class menu
        a_HInstance ,
        NULL                                // pointer not needed
    ) ;

    ShowWindow ( t_HWnd, SW_SHOW ) ;
//  ShowWindow ( t_HWnd, SW_HIDE ) ;

    return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
    CoUninitialize () ;
    DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
    HWND t_HWnd = NULL ;
    if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
    {
    }

    return t_HWnd ;
}

void WindowsDispatch ()
{
    BOOL t_GetMessage ;
    MSG t_lpMsg ;

    while ( ( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
    {
        TranslateMessage ( & t_lpMsg ) ;
        DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting ) 
            return ;
    }
}

HRESULT UninitComServer ()
{
    if ( g_InstanceRegister )
        CoRevokeClassObject ( g_InstanceRegister );

    CoUninitialize () ;

    return S_OK ;
}

HRESULT InitInstanceProvider ()
{
    IUnknown *t_ClassFactory = new CProvFactory ;

    DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
    DWORD t_Flags = REGCLS_MULTIPLEUSE ;

    HRESULT t_Result = CoRegisterClassObject (

        CLSID_MSIprov ,
        t_ClassFactory,
        t_ClassContext, 
        t_Flags, 
        &g_InstanceRegister
    );

    return t_Result ;
}
/*
HRESULT InitEventProvider ()
{
    IUnknown *t_ClassFactory = new CPowerEventProviderClassFactory ;

    DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
    DWORD t_Flags = REGCLS_MULTIPLEUSE ;

    HRESULT t_Result = CoRegisterClassObject (

        CLSID_PowerEventProvider ,
        t_ClassFactory,
        t_ClassContext, 
        t_Flags, 
        &g_EventRegister
    );

    return t_Result ;
}
*/
HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
    HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

        0, 
        COINIT_MULTITHREADED
    );

    if ( SUCCEEDED ( t_Result ) ) 
    {
        t_Result = CoInitializeSecurity (

            NULL, 
            -1, 
            NULL, 
            NULL,
            a_AuthenticationLevel,
            a_ImpersonationLevel, 
            NULL, 
            EOAC_NONE, 
            0
        );

        if ( FAILED ( t_Result ) ) 
        {
            CoUninitialize () ;
            return t_Result ;
        }

    }

    if ( SUCCEEDED ( t_Result ) )
        t_Result = InitInstanceProvider () ;

//  if ( SUCCEEDED ( t_Result ) )
//      t_Result = InitEventProvider () ;

    if ( FAILED ( t_Result ) )
    {
        UninitComServer () ;
    }

    return t_Result  ;
}

HRESULT Process ()
{
#if 1
    DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
    DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
    DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
    DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

    HRESULT t_Result = InitComServer ( t_ImpersonationLevel , t_AuthenticationLevel ) ;
    if ( SUCCEEDED ( t_Result ) )
    {
        WindowsDispatch () ;
        UninitComServer () ;
    }

    return t_Result ;
}

BOOL ParseCommandLine () 
{
    BOOL t_Exit = FALSE ;

    LPTSTR t_CommandLine = GetCommandLine () ;
    if ( t_CommandLine )
    {
        TCHAR *t_Arg = NULL ;
        TCHAR *t_ApplicationArg = NULL ;
        t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
        t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
        if ( t_Arg ) 
        {
            if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
            {
                t_Exit = TRUE ;
                DllRegisterServer () ;
            }
            else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
            {
                t_Exit = TRUE ;
                DllUnregisterServer () ;
            }
        }
    }

    return t_Exit ;
}

int WINAPI WinMain (
  
    HINSTANCE hInstance,        // handle to current instance
    HINSTANCE hPrevInstance,    // handle to previous instance
    LPSTR lpCmdLine,            // pointer to command line
    int nShowCmd                // show state of window
)
{
    BOOL t_Status = DllMain (

        hInstance, 
        DLL_PROCESS_ATTACH , 
        NULL
    ) ;

    BOOL t_Exit = ParseCommandLine () ;
    if ( ! t_Exit ) 
    {
        HWND hWnd = WindowsStart ( hInstance ) ;

        HRESULT t_Result = Process () ;

        WindowsStop ( hWnd ) ;
    }

    t_Status = DllMain (

        hInstance, 
        DLL_PROCESS_DETACH , 
        NULL
    ) ;

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WBEM Instance provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <tchar.h>
#include <objbase.h>
#include <initguid.h>
#include "classfac.h"

#include "genericclass.h"
#include "requestobject.h"

HMODULE ghModule;

DEFINE_GUID(CLSID_MSIprov,0xbe0a9830, 0x2b8b, 0x11d1, 0xa9, 0x49, 0x0, 0x60, 0x18, 0x1e, 0xbb, 0xad);
// {BE0A9830-2B8B-11D1-A949-0060181EBBAD}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
	BOOL retVal = TRUE;
    if(DLL_PROCESS_DETACH == ulReason){
        
        DeleteCriticalSection(&g_msi_prov_cs);
	    DeleteCriticalSection(&(CRequestObject::m_cs));
		DeleteCriticalSection(&(CGenericClass::m_cs));
    
    }else if(DLL_PROCESS_ATTACH == ulReason){
        
		InitializeCriticalSection(&(CRequestObject::m_cs));
		InitializeCriticalSection(&(CGenericClass::m_cs));
		DisableThreadLibraryCalls(hInstance);			// 158024 

		try
		{
			//for this one we can't afford to throw on lock failure.
			retVal = InitializeCriticalSectionAndSpinCount(&g_msi_prov_cs, 0x80000000);
		}
		catch(...)
		{
			retVal = FALSE;
		}
    }

    return retVal;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
    HRESULT hr = 0;
    CProvFactory *pObj;

    if(CLSID_MSIprov!=rclsid) return E_FAIL;

    pObj = new CProvFactory();

    if(NULL == pObj) return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppv);

    if(FAILED(hr)) delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = (0L == g_cObj && 0L == g_cLock) ? S_OK : S_FALSE;
    return sc;
}

BOOL IsLessThan4()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion < 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
	#ifndef	UNICODE
    TCHAR       szID[265];
	#else	UNICODE
	TCHAR*		szID = NULL;
	#endif	UNICODE

    WCHAR       wcID[265];
    TCHAR       szCLSID[265];
    TCHAR       szModule[MAX_PATH];
    TCHAR * pName = _T("WMI MSI Provider");
    TCHAR * pModel;
    HKEY hKey1, hKey2;

    ghModule = GetModuleHandle(_T("MSIPROV"));

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(IsLessThan4()) pModel = _T("Apartment");
    else pModel = _T("Both");

    // Create the path.

    StringFromGUID2(CLSID_MSIprov, wcID, 128);

	#ifndef	UNICODE
    WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);
	#else	UNICODE
	szID = wcID;
	#endif	UNICODE

    _tcscpy(szCLSID, _T("Software\\classes\\CLSID\\"));
    _tcscat(szCLSID, szID);

#ifdef LOCALSERVER

    HKEY hKey;

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID, _T("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID, szID);

    RegCreateKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID, &hKey);
    RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)pName, (_tcslen(pName)+1) * sizeof ( TCHAR ));

    CloseHandle(hKey);

#endif

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (_tcslen(pName)+1) * sizeof ( TCHAR ));

    // Create entries under CLSID

#ifdef LOCALSERVER
    RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
#else
    RegCreateKey(hKey1, _T("InprocServer32"), &hKey2);
#endif

    GetModuleFileName(ghModule, szModule, MAX_PATH/*length in TCHARS*/);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, (_tcslen(szModule)+1) * sizeof ( TCHAR ));
    RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ, (BYTE *)pModel, (_tcslen(pModel)+1) * sizeof ( TCHAR ));

    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR wcID[256];

	#ifndef	UNICODE
    TCHAR       szID[265];
	#else	UNICODE
	TCHAR*		szID = NULL;
	#endif	UNICODE

    TCHAR wcCLSID[256];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_MSIprov, wcID, 128);

	#ifndef	UNICODE
    WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);
	#else	UNICODE
	szID = wcID;
	#endif	UNICODE

    _tcscpy(wcCLSID, _T("Software\\classes\\CLSID\\"));
    _tcscat(wcCLSID, szID);

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID, _T("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID,wcCLSID);

    //Delete entries under APPID

    RegDeleteKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

    TCHAR szTemp[128];
    _tcscpy(szTemp, wcCLSID);
    _tcscat(szTemp,_T("\\"));
    _tcscat(szTemp,_T("LocalServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#endif

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, wcCLSID, &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKey(hKey, _T("InprocServer32"));
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, _T("Software\\classes\\CLSID"), &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\movefile.h ===
// MoveFile.h: interface for the CMoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MOVEFILE_H__72CDD5D5_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_MOVEFILE_H__72CDD5D5_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CMoveFile : public CGenericClass  
{
public:
	CMoveFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CMoveFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_MOVEFILE_H__72CDD5D5_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\movefile.cpp ===
// MoveFile.cpp: implementation of the CMoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "MoveFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMoveFile::CMoveFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CMoveFile::~CMoveFile()
{

}

HRESULT CMoveFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `SourceName`, `SourceFolder`, `DestName`, `DestFolder`, `Options` from MoveFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `FileKey`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"MoveFile", TRUE , FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pFileKey, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSourceName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSourceFolder, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDestName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDestFolder, wcBuf);

                            PutProperty(m_pObj, pOptions, g_fpMsiRecordGetInteger(hRecord, 7));

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\mimeinfoaction.h ===
// MIMEInfoAction.h: interface for the CMIMEInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MIMEINFOACTION_H__75F6BA23_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_MIMEINFOACTION_H__75F6BA23_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CMIMEInfoAction : public CGenericClass  
{
public:
	CMIMEInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CMIMEInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_MIMEINFOACTION_H__75F6BA23_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\msidatalock.h ===
////////////////////////////////////////////////////////////////////////////////////

//
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  All rights reserved.
//
//	Module Name:
//
//					MSIDataLock.h
//
//	Abstract:
//
//					declaration of lock for msi handles
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MSIDATALOCK_H__
#define	__MSIDATALOCK_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//would need msi
#ifndef	_MSI_H_
#include <msi.h>
#endif	_MSI_H_

////////////////////////////////////////////////////////////////////////////////////
// base class for lock
////////////////////////////////////////////////////////////////////////////////////
class MSIDataLockBase
{
protected:
	static HANDLE		m_hOwn;			// event to mark owner

	static LPWSTR		m_wszProduct;

	static MSIHANDLE	m_hProduct;		// msi handle to product
	static LONG			m_lRefProduct;	// msi handle to product ref count
	static BOOL			m_bProductOwn;	// msi handle to product own ?

	static MSIHANDLE	m_hDatabase;	// msi handle to database
	static LONG			m_lRefDatabase;	// msi handle to database ref count
	static BOOL			m_bDatabaseOwn;	// msi handle to database own ?

	static DWORD		m_ThreadID;		// id of thread that has locked/unlocked

	static LONG			m_lRef;			// reference count

public:

	MSIDataLockBase ();
	virtual ~MSIDataLockBase ();

	BOOL	Lock ( void );
	void	Unlock ( void );

private:

	BOOL	Initialize ();
	void	Uninitialize ();
};

////////////////////////////////////////////////////////////////////////////////////
// class for lock
////////////////////////////////////////////////////////////////////////////////////
class MSIDataLock : public MSIDataLockBase
{
	public:

	MSIDataLock()
	{
	}

	~MSIDataLock()
	{
	}

	#ifdef	__SUPPORT_STATIC

	static const MSIHANDLE GetProduct ()
	{
		return static_cast < MSIHANDLE > ( m_hProduct );
	}

	static const MSIHANDLE GetDatabase ()
	{
		return static_cast < MSIHANDLE > ( m_hDatabase );
	}

	#else	__SUPPORT_STATIC

	const MSIHANDLE GetProduct ()
	{
		return static_cast < MSIHANDLE > ( m_hProduct );
	}

	const MSIHANDLE GetDatabase ()
	{
		return static_cast < MSIHANDLE > ( m_hDatabase );
	}

	#endif	__SUPPORT_STATIC

	bool GetView (	MSIHANDLE *phView,
					WCHAR *wcPackage,
					WCHAR *wcQuery,
					WCHAR *wcTable,
					BOOL bCloseProduct,
					BOOL bCloseDatabase
				 );

	HRESULT	CloseProduct	( void );
	HRESULT	CloseDatabase	( void );

	private:

	HRESULT	OpenProduct		( LPCWSTR wszProduct );
	HRESULT	OpenDatabase	( );
	HRESULT	OpenDatabase	( LPCWSTR wszProduct );

	HRESULT	Query			( MSIHANDLE* pView, LPCWSTR wszQuery, LPCWSTR wszTable = NULL );

	HRESULT	OpenProductAlloc		( LPCWSTR wszProduct );
	HRESULT	OpenProductInternal		( LPCWSTR wszProduct );
};

#endif	__MSIDATALOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\mimeinfoaction.cpp ===
// MIMEInfoAction.cpp: implementation of the CMIMEInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "MIMEInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMIMEInfoAction::CMIMEInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CMIMEInfoAction::~CMIMEInfoAction()
{

}

HRESULT CMIMEInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ContentType`, `Extension_`, `CLSID` from MIME" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ContentType`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"MIME", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pContentType, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pExtension, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pCLSID, wcBuf);

                    //----------------------------------------------------

                        if(bActionID) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\msidatalock.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  All rights reserved.
//
//	Module Name:
//
//					MSIDataLock.cpp
//
//	Abstract:
//
//					definitions of lock for msi handles
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "MSIDataLock.h"

////////////////////////////////////////////////////////////////////////////////////
// extern variables
////////////////////////////////////////////////////////////////////////////////////
extern CRITICAL_SECTION g_msi_prov_cs;

MSIHANDLE MSIDataLockBase::m_hProduct = NULL;
MSIHANDLE MSIDataLockBase::m_hDatabase = NULL;
HANDLE MSIDataLockBase::m_hOwn	= NULL;
LPWSTR	MSIDataLockBase::m_wszProduct = NULL;
DWORD	MSIDataLockBase::m_ThreadID = 0L;
LONG	MSIDataLockBase::m_lRefProduct	= 0L;
LONG	MSIDataLockBase::m_lRefDatabase	= 0L;
BOOL	MSIDataLockBase::m_bProductOwn	= FALSE;
BOOL	MSIDataLockBase::m_bDatabaseOwn	= FALSE;
LONG	MSIDataLockBase::m_lRef = 0L;

////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////////

MSIDataLockBase::MSIDataLockBase ()
{
	Initialize ();
}

MSIDataLockBase::~MSIDataLockBase ()
{
	Uninitialize ();
}

BOOL	MSIDataLockBase::Initialize ()
{
	BOOL	bResult	= TRUE;

	::EnterCriticalSection ( &g_msi_prov_cs );

	if ( ! m_hOwn && ( m_hOwn = ::CreateEvent ( NULL, TRUE, TRUE, NULL ) ) == NULL )
	{
		bResult = FALSE;
	}

	if ( bResult )
	{
		m_lRef++;
	}

	::LeaveCriticalSection ( &g_msi_prov_cs );

	return bResult;
}

void	MSIDataLockBase::Uninitialize ()
{
	::EnterCriticalSection ( &g_msi_prov_cs );

	if ( m_lRef && ( --m_lRef == 0 ) )
	{
		if ( m_hOwn )
		{
			::CloseHandle ( m_hOwn );
			m_hOwn = NULL;
		}
	}

	::LeaveCriticalSection ( &g_msi_prov_cs );

	return;
}

BOOL	MSIDataLockBase::Lock ( void )
{
	BOOL	bResult	= FALSE;
	BOOL	bWork	= TRUE;
	BOOL	bSect	= TRUE;

	while ( bWork )
	{
		::EnterCriticalSection ( &g_msi_prov_cs );

		// we have obtained critsec now
		bSect = TRUE;

		// are handles already allocated ?
		if ( m_hProduct != NULL || m_hDatabase != NULL )
		{
			if ( ::GetCurrentThreadId () != m_ThreadID )
			{
				DWORD dwWaitResult = 0L;

				// we have left crit sec
				::LeaveCriticalSection ( &g_msi_prov_cs );
				bSect = FALSE;

				// wait till resource gets free again
				dwWaitResult = ::WaitForSingleObject ( m_hOwn, INFINITE );

				if ( dwWaitResult == WAIT_OBJECT_0 )
				{
					bWork	= TRUE;
					bResult	= FALSE;
				}
				else
				{
					bWork	= FALSE;
					bResult	= FALSE;
				}
			}
			else
			{
				bWork	= FALSE;
				bResult = TRUE;
			}
		}
		else
		{
			m_ThreadID = ::GetCurrentThreadId ( );

			bWork	= FALSE;
			bResult = TRUE;
		}
	}

	if ( bSect && ! bResult )
	{
		::LeaveCriticalSection ( &g_msi_prov_cs );
	}

	return bResult;
}

void	MSIDataLockBase::Unlock ( void )
{
	try
	{
		if ( !m_bProductOwn && !m_bDatabaseOwn )
		{
			m_ThreadID = 0;
			::SetEvent ( m_hOwn );
		}
	}
	catch (...)
	{
		::LeaveCriticalSection ( &g_msi_prov_cs );
		throw ;
	}

	::LeaveCriticalSection ( &g_msi_prov_cs );
}

HRESULT	MSIDataLock::OpenProductAlloc ( LPCWSTR wszProduct )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( ( m_wszProduct = new WCHAR [ lstrlenW ( wszProduct ) + 1 ] ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
		}

		lstrcpyW ( m_wszProduct, wszProduct );
	}
	catch ( ... )
	{
		if ( m_wszProduct )
		{
			delete [] m_wszProduct;
			m_wszProduct = NULL;
		}

		throw;
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenProductInternal ( LPCWSTR wszProduct )
{
	HRESULT hRes	 = E_FAIL;
	UINT	uiStatus = ERROR_SUCCESS;

	BOOL	bAlloc	 = FALSE;

	try
	{
		if ( ( uiStatus = g_fpMsiOpenProductW ( wszProduct, &m_hProduct ) ) != ERROR_SUCCESS )
		{
			if ( uiStatus == static_cast < UINT > ( E_OUTOFMEMORY ) )
			{
				throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
			}
		}
	}
	catch ( ... )
	{
		if ( m_hProduct )
		{
			g_fpMsiCloseHandle ( m_hProduct );
			m_hProduct = NULL;
		}

		throw;
	}

	if ( uiStatus != ERROR_SUCCESS )
	{
		//and if that didn't work, yet another way
		WCHAR * wcBuf		= NULL;
		DWORD	dwBufsize	= BUFF_SIZE;

		if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
		}

		try
		{
			if ( ( uiStatus = g_fpMsiGetProductInfoW ( wszProduct, INSTALLPROPERTY_LOCALPACKAGE, wcBuf, &dwBufsize ) ) == ERROR_SUCCESS )
			{
				if ( dwBufsize > 0 )
				{
					uiStatus = g_fpMsiOpenPackageW ( wcBuf, &m_hProduct );
				}
			}
		}
		catch ( ... )
		{
			delete [] wcBuf;
			throw ;
		}

		delete [] wcBuf;

		if ( uiStatus == ERROR_SUCCESS && m_hProduct )
		{
			bAlloc = TRUE;
		}
	}
	else
	{
		if ( m_hProduct )
		{
			bAlloc = TRUE;
		}
	}

	if ( bAlloc )
	{
		try
		{
			hRes = OpenProductAlloc ( wszProduct );
		}
		catch ( ... )
		{
			if ( m_hProduct )
			{
				g_fpMsiCloseHandle ( m_hProduct );
				m_hProduct = NULL;
			}

			throw;
		}
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenProduct ( LPCWSTR wszProduct )
{
	HRESULT hRes = E_FAIL;

	if ( ! wszProduct )
	{
		hRes = E_INVALIDARG;
	}
	else
	{
		if ( Lock ( ) )
		{
			try
			{
				if ( ! m_hProduct && ! m_wszProduct )
				{
					hRes = OpenProductInternal ( wszProduct );

					if FAILED ( hRes )
					{
						if ( m_wszProduct )
						{
							delete [] m_wszProduct;
							m_wszProduct = NULL;
						}

						if ( m_hProduct )
						{
							g_fpMsiCloseHandle ( m_hProduct );
							m_hProduct = NULL;
						}
					}
				}
				else
				{
					if ( m_hProduct && m_wszProduct && lstrcmpW ( wszProduct, m_wszProduct ) == 0 )
					{
						hRes = S_OK;
					}
				}

				if SUCCEEDED ( hRes )
				{
					if ( m_lRefProduct == 0 )
					{
						m_bProductOwn	= TRUE;
						::ResetEvent ( m_hOwn );
					}

					m_lRefProduct++;
				}
			}
			catch ( ... )
			{
				Unlock ( );
				throw;
			}

			Unlock ( );
		}
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenDatabase ( )
{
	HRESULT hRes = E_FAIL;

	if ( Lock ( ) )
	{
		try
		{
			if ( m_hProduct )
			{
				if ( ! m_hDatabase )
				{
					m_hDatabase = g_fpMsiGetActiveDatabase ( m_hProduct );

					if ( m_hDatabase != NULL )
					{
						hRes = S_OK;
					}
				}
				else
				{
					MSIHANDLE hDatabase = NULL;
					hDatabase = g_fpMsiGetActiveDatabase ( m_hProduct );

					if ( hDatabase != NULL )
					{
						if ( hDatabase == m_hDatabase )
						{
							g_fpMsiCloseHandle ( hDatabase );
							hDatabase = NULL;

							hRes = S_OK;
						}
					}
				}

				if SUCCEEDED ( hRes )
				{
					if ( m_lRefDatabase == 0 )
					{
						m_bDatabaseOwn	= TRUE;
						::ResetEvent ( m_hOwn );
					}

					m_lRefDatabase++;
				}
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenDatabase ( LPCWSTR wszProduct )
{
	HRESULT	hRes	= E_FAIL;

	if ( Lock ( ) )
	{
		try
		{
			if SUCCEEDED ( hRes = OpenProduct ( wszProduct ) )
			{
				hRes = OpenDatabase ();

				if FAILED ( hRes )
				{
					// we have to close product
					CloseProduct ();
				}
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::CloseProduct ()
{
	HRESULT	hRes	= S_FALSE;

	if ( Lock ( ) )
	{
		try
		{
			if ( m_hProduct && m_lRefProduct && ( --m_lRefProduct == 0 ) )
			{
				delete [] m_wszProduct;
				m_wszProduct = NULL;

				g_fpMsiCloseHandle ( m_hProduct );
				m_hProduct		= NULL;
				m_bProductOwn	= FALSE;
				hRes = S_OK;
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::CloseDatabase ( )
{
	HRESULT	hRes	= E_FAIL;

	if ( Lock ( ) )
	{
		try
		{
			if ( m_hDatabase && m_lRefDatabase && ( --m_lRefDatabase == 0 ) )
			{
				g_fpMsiCloseHandle ( m_hDatabase );
				m_hDatabase = NULL;
				m_bDatabaseOwn	= FALSE;
				hRes = S_OK;
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::Query ( MSIHANDLE* pView, LPCWSTR wszQuery, LPCWSTR wszTable )
{
	HRESULT	hRes	= S_OK;
	UINT	uiStatus= ERROR_SUCCESS;

	if ( ! pView )
	{
		hRes = E_POINTER;
	}
	else
	{
		( * pView ) = NULL;

		if ( ! wszQuery )
		{
			hRes = E_INVALIDARG;
		}
		else
		{
			if ( Lock ( ) )
			{
				if ( m_hDatabase )
				{
					try
					{
						if ( wszTable )
						{
							if ( g_fpMsiDatabaseIsTablePersistentW ( m_hDatabase, wszTable ) != MSICONDITION_TRUE )
							{
								hRes = E_FAIL;
							}
						}

						if SUCCEEDED ( hRes )
						{
							if ( ( uiStatus = g_fpMsiDatabaseOpenViewW ( m_hDatabase, wszQuery, pView ) ) == ERROR_SUCCESS )
							{
								if ( g_fpMsiViewExecute ( *pView, 0 ) != ERROR_SUCCESS )
								{
									if ( *pView )
									{
										g_fpMsiCloseHandle ( *pView );
										( * pView ) = NULL;
									}

									hRes = E_FAIL;
								}
							}
							else
							{
								if ( uiStatus == static_cast < UINT > ( E_OUTOFMEMORY ) )
								{
									throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
								}

								// what is the failure here ?
								hRes = HRESULT_FROM_WIN32 ( uiStatus );
							}
						}
					}
					catch ( ... )
					{
						Unlock ( );
						throw;
					}
				}
				else
				{
					hRes = E_UNEXPECTED;
				}

				Unlock ( );
			}
		}
	}

	return hRes;
}

bool MSIDataLock::GetView	(	MSIHANDLE *phView,
								WCHAR *wcPackage,
								WCHAR *wcQuery,
								WCHAR *wcTable,
								BOOL bCloseProduct,
								BOOL bCloseDatabase
							)
{
    bool bResult	= false;

	if ( wcPackage )
	{
		if ( Lock () )
		{
			try
			{
				if SUCCEEDED ( OpenDatabase ( wcPackage ) )
				{
					if ( phView && wcQuery )
					{
						if SUCCEEDED ( Query ( phView, wcQuery, wcTable ) )
						{
							bResult = true;
						}
					}
					else
					{
						bResult = true;
					}

					if ( bCloseDatabase )
					{
						CloseDatabase ();
					}
				}

				if ( bCloseProduct )
				{
					CloseProduct ();
				}
			}
			catch ( ... )
			{
				CloseProduct ();
				CloseDatabase ();

				Unlock ();

				throw;
			}

			Unlock ();
		}
	}

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\msiprov.cpp ===
//***************************************************************************

//

//  MSIProv.CPP

//

//  Module: WBEM Instance provider for MSI

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <wbemcli_i.c>
#include <wbemprov_i.c>
#include "requestobject.h"
//#define _MT
#include <process.h>
#include <Polarity.h>
#include <createmutexasprocess.h>

#include <tchar.h>

CRITICAL_SECTION g_msi_prov_cs;

WCHAR *g_wcpLoggingDir = NULL;

bool g_bMsiPresent = true;
bool g_bMsiLoaded = false;

CHeap_Exception CMSIProv::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

LPFNMSIVIEWFETCH                    g_fpMsiViewFetch = NULL;
LPFNMSIRECORDGETSTRINGW             g_fpMsiRecordGetStringW = NULL;
LPFNMSICLOSEHANDLE                  g_fpMsiCloseHandle = NULL;
LPFNMSIDATABASEOPENVIEWW            g_fpMsiDatabaseOpenViewW = NULL;
LPFNMSIVIEWEXECUTE                  g_fpMsiViewExecute = NULL;
LPFNMSIGETACTIVEDATABASE            g_fpMsiGetActiveDatabase = NULL;
LPFNMSIGETCOMPONENTPATHW            g_fpMsiGetComponentPathW = NULL;
LPFNMSIGETCOMPONENTSTATEW           g_fpMsiGetComponentStateW = NULL;
LPFNMSIOPENPRODUCTW                 g_fpMsiOpenProductW = NULL;
LPFNMSIOPENPACKAGEW                 g_fpMsiOpenPackageW = NULL;
LPFNMSIDATABASEISTABLEPERSITENTW    g_fpMsiDatabaseIsTablePersistentW = NULL;
LPFNMSISETINTERNALUI                g_fpMsiSetInternalUI = NULL;
LPFNMSISETEXTERNALUIW               g_fpMsiSetExternalUIW = NULL;
LPFNMSIENABLELOGW                   g_fpMsiEnableLogW = NULL;
LPFNMSIGETPRODUCTPROPERTYW          g_fpMsiGetProductPropertyW = NULL;
LPFNMSIQUERYPRODUCTSTATEW           g_fpMsiQueryProductStateW = NULL;
LPFNMSIINSTALLPRODUCTW              g_fpMsiInstallProductW = NULL;
LPFNMSICONFIGUREPRODUCTW            g_fpMsiConfigureProductW = NULL;
LPFNMSIREINSTALLPRODUCTW            g_fpMsiReinstallProductW = NULL;
LPFNMSIAPPLYPATCHW                  g_fpMsiApplyPatchW = NULL;
LPFNMSIRECORDGETINTEGER             g_fpMsiRecordGetInteger = NULL;
LPFNMSIENUMFEATURESW                g_fpMsiEnumFeaturesW = NULL;
LPFNMSIGETPRODUCTINFOW              g_fpMsiGetProductInfoW = NULL;
LPFNMSIQUERYFEATURESTATEW           g_fpMsiQueryFeatureStateW = NULL;
LPFNMSIGETFEATUREUSAGEW             g_fpMsiGetFeatureUsageW = NULL;
LPFNMSIGETFEATUREINFOW              g_fpMsiGetFeatureInfoW = NULL;
LPFNMSICONFIGUREFEATUREW            g_fpMsiConfigureFeatureW = NULL;
LPFNMSIREINSTALLFEATUREW            g_fpMsiReinstallFeatureW = NULL;
LPFNMSIENUMPRODUCTSW                g_fpMsiEnumProductsW = NULL;
LPFNMSIGETDATABASESTATE             g_fpMsiGetDatabaseState = NULL;
LPFNMSIRECORDSETSTRINGW             g_fpMsiRecordSetStringW = NULL;
LPFNMSIDATABASECOMMIT               g_fpMsiDatabaseCommit = NULL;
LPFNMSIENUMCOMPONENTSW              g_fpMsiEnumComponentsW = NULL;
LPFNMSIVIEWCLOSE                    g_fpMsiViewClose = NULL;

//***************************************************************************
//
// CMSIProv::CMSIProv
// CMSIProv::~CMSIProv
//
//***************************************************************************

CMSIProv::CMSIProv(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef = 0;

    InterlockedIncrement(&g_cObj);
    
    return;
}

CMSIProv::~CMSIProv(void)
{
    if(m_pNamespace) m_pNamespace->Release();

    if(0 == InterlockedDecrement(&g_cObj))
    {
        UnloadMsiDll();

		if ( g_wcpLoggingDir )
		{
			delete [] g_wcpLoggingDir;
			g_wcpLoggingDir = NULL;
		}
    }

    return;
}

//***************************************************************************
//
// CMSIProv::QueryInterface
// CMSIProv::AddRef
// CMSIProv::Release
//
// Purpose: IUnknown members for CMSIProv object.
//***************************************************************************


STDMETHODIMP CMSIProv::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid == IID_IWbemServices)
       *ppv = (IWbemServices*)this;

    if(IID_IUnknown == riid || riid == IID_IWbemProviderInit)
       *ppv = (IWbemProviderInit*)this;
    

    if(NULL!=*ppv){

        AddRef();
        return NOERROR;
    }

    else return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CMSIProv::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMSIProv::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

    if(0L == nNewCount){

        delete this;
    }

    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CMSIProv::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CMSIProv::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    try{

        if(pNamespace){
            m_pNamespace = pNamespace;
            m_pNamespace->AddRef();
        }

        CheckForMsiDll();

#ifdef _PRIVATE_DEBUG

        //get the working directory for the log file
        HKEY hkeyLocalMachine;
        LONG lResult;

        if((lResult = RegConnectRegistryW(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine)) == ERROR_SUCCESS)
		{
            HKEY hkeyHmomCwd;

            if(	(lResult = RegOpenKeyExW	(	hkeyLocalMachine,
												L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
												0, 
												KEY_READ | KEY_QUERY_VALUE, 
												&hkeyHmomCwd
											)
				) == ERROR_SUCCESS)
			{

                unsigned long lcbValue = 0L;
                unsigned long lType = 0L;

                lResult = RegQueryValueExW	(	hkeyHmomCwd,
												L"Logging Directory",
												NULL,
												&lType,
												NULL,
												&lcbValue
											);

				if ( lResult == ERROR_MORE_DATA )
				{
					try
					{
						if ( ( g_wcpLoggingDir = new WCHAR [ lcbValue/sizeof ( WCHAR ) + wcslen ( L"\\msiprov.log" ) + 1 ] ) != NULL )
						{
							lResult = RegQueryValueExW	(	hkeyHmomCwd,
															L"Logging Directory",
															NULL,
															&lType,
															g_wcpLoggingDir,
															&lcbValue
														);

							if ( lResult == ERROR_SUCCESS )
							{
								wcscat(g_wcpLoggingDir, L"\\msiprov.log");
							}
							else
							{
								if ( g_wcpLoggingDir );
								{
									delete [] g_wcpLoggingDir;
									g_wcpLoggingDir = NULL;
								}
							}
						}
						else
						{
							throw m_he;
						}
					}
					catch ( ... )
					{
						if ( g_wcpLoggingDir );
						{
							delete [] g_wcpLoggingDir;
							g_wcpLoggingDir = NULL;
						}

						RegCloseKey(hkeyHmomCwd);
						RegCloseKey(hkeyLocalMachine);

						throw;
					}

					RegCloseKey(hkeyHmomCwd);
					RegCloseKey(hkeyLocalMachine);
				}
            }
			else
			{
                RegCloseKey(hkeyLocalMachine);
            }
        }

#endif

        //Register usage information with MSI
/*      WCHAR wcProduct[39];
        WCHAR wcFeature[BUFF_SIZE];
        WCHAR wcParent[BUFF_SIZE];
        int iPass = -1;

        MsiGetProductCodeW(L"{E705C42D-35ED-11D2-BFB7-00A0C9954921}", wcProduct);

        while(MsiEnumFeaturesW(wcProduct, ++iPass, wcFeature, wcParent) != ERROR_NO_MORE_ITEMS){

            if(wcscmp(wcFeature, L"Provider") == 0){

                MsiUseFeatureW(wcProduct, wcFeature);
                break;
            }
        }
*/

    }catch(...){

        //Let CIMOM know there was problem
        pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
        return WBEM_E_FAILED;
    }

    //Let CIMOM know you are initialized
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CMSIProv::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************
SCODE CMSIProv::CreateInstanceEnumAsync(const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(pHandler == NULL || m_pNamespace == NULL)
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
				{
					throw m_he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Get the requested object(s)
						hr = pRObj->CreateObjectEnum(RefStr, pHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        }

        // Set status
        pHandler->SetStatus(0, hr, NULL, NULL);

    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
		pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{

            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}


//***************************************************************************
//
// CMSIProv::GetObjectAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************
SCODE CMSIProv::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
				{
					throw m_he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Get the requested object
						hr = pRObj->CreateObject(ObjectPath, pHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        }

        // Set Status
        pHandler->SetStatus(0, hr , NULL, NULL);

    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pHandler->SetStatus(0, hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
        pHandler->SetStatus(0, hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}

//***************************************************************************
//
// CMSIProv::PutInstanceAsync
//
// Purpose: Writes an instance to the WBEM Repsoitory.
//
//***************************************************************************
SCODE CMSIProv::PutInstanceAsync(IWbemClassObject FAR *pInst, long lFlags, IWbemContext  *pCtx,
                                 IWbemObjectSink FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(pInst == NULL || pResponseHandler == NULL)
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
                {
					throw m_he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Put the object
						hr = pRObj->PutObject(pInst, pResponseHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        
        }
		else
		{
			hr = WBEM_E_NOT_AVAILABLE;
        }

        // Set Status
        pResponseHandler->SetStatus(0 ,hr , NULL, NULL);
    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}

//***************************************************************************
//
// CMSIProv::ExecMethodAsync
//
// Purpose: Executes a method on an MSI class or instance.
//
//***************************************************************************
SCODE CMSIProv::ExecMethodAsync(const BSTR ObjectPath, const BSTR Method, long lFlags,
                                IWbemContext *pCtx, IWbemClassObject *pInParams,
                                IWbemObjectSink *pResponse)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{

        if(CheckForMsiDll()){

            // Do a check of arguments and make sure we have pointer to Namespace
            if(ObjectPath == NULL || Method == NULL || pResponse == NULL)
                return WBEM_E_INVALID_PARAMETER;

            if(SUCCEEDED(hr = CheckImpersonationLevel())){

                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
                
                //Create the RequestObject
                pRObj = new CRequestObject();
                if(!pRObj) throw m_he;

                pRObj->Initialize(m_pNamespace);

                //Don't get package list
                if(SUCCEEDED(hr = pRObj->InitializeList(false))){

                    //Execute the method
                    hr = pRObj->ExecMethod(ObjectPath, Method, pInParams, pResponse, pCtx);
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        
        }else{
        
            hr = WBEM_E_NOT_AVAILABLE;
        }

        // Set Status
        pResponse->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){

        hr = WBEM_E_OUT_OF_MEMORY;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){

        hr = WBEM_E_CRITICAL_ERROR;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}

SCODE CMSIProv::DeleteInstanceAsync(const BSTR ObjectPath, long lFlags, IWbemContext *pCtx,
                                    IWbemObjectSink *pResponse)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{
        if(CheckForMsiDll()){

            // Do a check of arguments and make sure we have pointer to Namespace
            if(ObjectPath == NULL || pResponse == NULL) return WBEM_E_INVALID_PARAMETER;

            if(SUCCEEDED(hr = CheckImpersonationLevel())){

                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                pRObj = new CRequestObject();
                if(!pRObj) throw m_he;

                pRObj->Initialize(m_pNamespace);

                //Don't get package list
                if(SUCCEEDED(hr = pRObj->InitializeList(false))){

                    //Delete the requested object
                    hr = pRObj->DeleteObject(ObjectPath, pResponse, pCtx);
                }

                pRObj->Cleanup();
                delete pRObj;
            }

        }else{
        
            hr = WBEM_E_NOT_AVAILABLE;
        }

        // Set Status
        pResponse->SetStatus(0 ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){
        hr = WBEM_E_OUT_OF_MEMORY;

        pResponse->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pResponse->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){
        hr = WBEM_E_CRITICAL_ERROR;

        pResponse->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}


HRESULT CMSIProv::ExecQueryAsync(const BSTR QueryLanguage, const BSTR Query, long lFlags,
                                 IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef _EXEC_QUERY_SUPPORT
    CRequestObject *pRObj = NULL;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(0 != _wcsicmp(QueryLanguage, L"WQL") || Query == NULL || pResponseHandler == NULL)
			{
				return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
				{
					throw he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Get the requested object(s)
						hr = pRObj->ExecQuery(Query, pResponseHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        }

        // Set Status
        pResponseHandler->SetStatus(0 ,hr , NULL, NULL);

    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#else //_EXEC_QUERY_SUPPORT
    hr = WBEM_E_NOT_SUPPORTED;
#endif

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif //_PRIVATE_DEBUG

    return hr;
}


//Ensure msi.dll and functions are loaded if present on system
bool CMSIProv::CheckForMsiDll()
{
    EnterCriticalSection(&g_msi_prov_cs);

    if(!g_bMsiLoaded){

        HINSTANCE hiMsiDll = LoadLibraryW(L"msi.dll");

        if(!hiMsiDll){

            hiMsiDll = LoadLibrary(_T("msi.dll"));

            if(!hiMsiDll){

                TCHAR cBuf[MAX_PATH + 1];

                if (0 != GetSystemDirectory(cBuf, MAX_PATH/*Number of TCHARs*/)){
				
					_tcscat(cBuf, _T("\\msi.dll"));
					hiMsiDll = LoadLibrary(cBuf);
				}
            }
        }

        if(hiMsiDll){

            //Load the function pointers
            g_fpMsiViewFetch = (LPFNMSIVIEWFETCH)GetProcAddress(hiMsiDll, "MsiViewFetch");
            g_fpMsiRecordGetStringW = (LPFNMSIRECORDGETSTRINGW)GetProcAddress(hiMsiDll, "MsiRecordGetStringW");
            g_fpMsiCloseHandle = (LPFNMSICLOSEHANDLE)GetProcAddress(hiMsiDll, "MsiCloseHandle");
            g_fpMsiDatabaseOpenViewW = (LPFNMSIDATABASEOPENVIEWW)GetProcAddress(hiMsiDll, "MsiDatabaseOpenViewW");
            g_fpMsiViewExecute = (LPFNMSIVIEWEXECUTE)GetProcAddress(hiMsiDll, "MsiViewExecute");
            g_fpMsiGetActiveDatabase = (LPFNMSIGETACTIVEDATABASE)GetProcAddress(hiMsiDll, "MsiGetActiveDatabase");
            g_fpMsiGetComponentPathW = (LPFNMSIGETCOMPONENTPATHW)GetProcAddress(hiMsiDll, "MsiGetComponentPathW");
            g_fpMsiGetComponentStateW = (LPFNMSIGETCOMPONENTSTATEW)GetProcAddress(hiMsiDll, "MsiGetComponentStateW");
            g_fpMsiOpenProductW = (LPFNMSIOPENPRODUCTW)GetProcAddress(hiMsiDll, "MsiOpenProductW");
            g_fpMsiOpenPackageW = (LPFNMSIOPENPACKAGEW)GetProcAddress(hiMsiDll, "MsiOpenPackageW");
            g_fpMsiDatabaseIsTablePersistentW = (LPFNMSIDATABASEISTABLEPERSITENTW)GetProcAddress(hiMsiDll, "MsiDatabaseIsTablePersistentW");
            g_fpMsiSetInternalUI = (LPFNMSISETINTERNALUI)GetProcAddress(hiMsiDll, "MsiSetInternalUI");
            g_fpMsiSetExternalUIW = (LPFNMSISETEXTERNALUIW)GetProcAddress(hiMsiDll, "MsiSetExternalUIW");
            g_fpMsiEnableLogW = (LPFNMSIENABLELOGW)GetProcAddress(hiMsiDll, "MsiEnableLogW");
            g_fpMsiGetProductPropertyW = (LPFNMSIGETPRODUCTPROPERTYW)GetProcAddress(hiMsiDll, "MsiGetProductPropertyW");
            g_fpMsiQueryProductStateW = (LPFNMSIQUERYPRODUCTSTATEW)GetProcAddress(hiMsiDll, "MsiQueryProductStateW");
            g_fpMsiInstallProductW = (LPFNMSIINSTALLPRODUCTW)GetProcAddress(hiMsiDll, "MsiInstallProductW");
            g_fpMsiConfigureProductW = (LPFNMSICONFIGUREPRODUCTW)GetProcAddress(hiMsiDll, "MsiConfigureProductW");
            g_fpMsiReinstallProductW = (LPFNMSIREINSTALLPRODUCTW)GetProcAddress(hiMsiDll, "MsiReinstallProductW");
            g_fpMsiApplyPatchW = (LPFNMSIAPPLYPATCHW)GetProcAddress(hiMsiDll, "MsiApplyPatchW");
            g_fpMsiRecordGetInteger = (LPFNMSIRECORDGETINTEGER)GetProcAddress(hiMsiDll, "MsiRecordGetInteger");
            g_fpMsiEnumFeaturesW = (LPFNMSIENUMFEATURESW)GetProcAddress(hiMsiDll, "MsiEnumFeaturesW");
            g_fpMsiGetProductInfoW = (LPFNMSIGETPRODUCTINFOW)GetProcAddress(hiMsiDll, "MsiGetProductInfoW");
            g_fpMsiQueryFeatureStateW = (LPFNMSIQUERYFEATURESTATEW)GetProcAddress(hiMsiDll, "MsiQueryFeatureStateW");
            g_fpMsiGetFeatureUsageW = (LPFNMSIGETFEATUREUSAGEW)GetProcAddress(hiMsiDll, "MsiGetFeatureUsageW");
            g_fpMsiGetFeatureInfoW = (LPFNMSIGETFEATUREINFOW)GetProcAddress(hiMsiDll, "MsiGetFeatureInfoW");
            g_fpMsiConfigureFeatureW = (LPFNMSICONFIGUREFEATUREW)GetProcAddress(hiMsiDll, "MsiConfigureFeatureW");
            g_fpMsiReinstallFeatureW = (LPFNMSIREINSTALLFEATUREW)GetProcAddress(hiMsiDll, "MsiReinstallFeatureW");
            g_fpMsiEnumProductsW = (LPFNMSIENUMPRODUCTSW)GetProcAddress(hiMsiDll, "MsiEnumProductsW");
            g_fpMsiGetDatabaseState = (LPFNMSIGETDATABASESTATE)GetProcAddress(hiMsiDll, "MsiGetDatabaseState");
            g_fpMsiRecordSetStringW = (LPFNMSIRECORDSETSTRINGW)GetProcAddress(hiMsiDll, "MsiRecordSetStringW");
            g_fpMsiDatabaseCommit = (LPFNMSIDATABASECOMMIT)GetProcAddress(hiMsiDll, "MsiDatabaseCommit");
            g_fpMsiEnumComponentsW = (LPFNMSIENUMCOMPONENTSW)GetProcAddress(hiMsiDll, "MsiEnumComponentsW");
            g_fpMsiViewClose = (LPFNMSIVIEWCLOSE)GetProcAddress(hiMsiDll, "MsiViewClose");

            // Did we get all the pointers we need?
            if(g_fpMsiViewFetch && g_fpMsiRecordGetStringW && g_fpMsiCloseHandle &&
                g_fpMsiDatabaseOpenViewW && g_fpMsiViewExecute && g_fpMsiGetActiveDatabase &&
                g_fpMsiGetComponentPathW && g_fpMsiGetComponentStateW && g_fpMsiOpenProductW &&
                g_fpMsiOpenPackageW && g_fpMsiDatabaseIsTablePersistentW && g_fpMsiSetInternalUI &&
                g_fpMsiSetExternalUIW && g_fpMsiEnableLogW && g_fpMsiGetProductPropertyW &&
                g_fpMsiQueryProductStateW && g_fpMsiInstallProductW && g_fpMsiConfigureProductW &&
                g_fpMsiReinstallProductW && g_fpMsiApplyPatchW && g_fpMsiRecordGetInteger &&
                g_fpMsiEnumFeaturesW && g_fpMsiGetProductInfoW && g_fpMsiQueryFeatureStateW &&
                g_fpMsiGetFeatureUsageW && g_fpMsiGetFeatureInfoW && g_fpMsiConfigureFeatureW &&
                g_fpMsiReinstallFeatureW && g_fpMsiEnumProductsW && g_fpMsiGetDatabaseState &&
                g_fpMsiRecordSetStringW && g_fpMsiDatabaseCommit && g_fpMsiEnumComponentsW &&
                g_fpMsiViewClose){

                g_bMsiLoaded = true;
            
            }
        
        }else{

            g_bMsiPresent = false;
        }
    }

    LeaveCriticalSection(&g_msi_prov_cs);

    return g_bMsiLoaded;
}

bool CMSIProv::UnloadMsiDll()
{
    bool bRetVal = true;

    EnterCriticalSection(&g_msi_prov_cs);

    if(g_bMsiLoaded){

        if(FreeLibrary(GetModuleHandle(L"msi.dll"))){

            g_bMsiLoaded = false;
            bRetVal = true;

        }else bRetVal = false;

    }

    LeaveCriticalSection(&g_msi_prov_cs);

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcattribute.cpp ===
// ODBCAttribute.cpp: implementation of the CODBCAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCAttribute.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCAttribute::CODBCAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                            IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCAttribute::~CODBCAttribute()
{

}

HRESULT CODBCAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bDriver, bAttribute;
    wcscpy(wcQuery, L"select distinct `Driver_`, `Attribute`, `Value` from ODBCAttribute");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED)){

		//Open our database

        try
		{
            if ( GetView ( &hView, m_pRequest->Package(i), wcQuery, L"ODBCAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pDriver, wcBuf, &bDriver, m_pRequest);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pAttribute, wcBuf, &bAttribute, m_pRequest);
                    PutProperty(m_pObj, pCaption, wcBuf);
                    PutProperty(m_pObj, pDescription, wcBuf);

                //=====================================================

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pValue, wcBuf);

                //----------------------------------------------------

                    if(bDriver && bAttribute) bMatch = true;

                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                        hr = pHandler->Indicate(1, &m_pObj);
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcattribute.h ===
// ODBCAttribute.h: interface for the CODBCAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCATTRIBUTE_H__DB614F26_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_ODBCATTRIBUTE_H__DB614F26_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCAttribute : public CGenericClass  
{
public:
	CODBCAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCATTRIBUTE_H__DB614F26_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasource.cpp ===
// ODBCDataSource.cpp: implementation of the CODBCDataSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDataSource.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDataSource::CODBCDataSource(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDataSource::~CODBCDataSource()
{

}

HRESULT CODBCDataSource::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcDataSource[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcDataSource);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `DataSource`, `Component_`, `Description`, `DriverDescription`, `Registration` from ODBCDataSource" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDataSource", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pDataSource, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //=====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDescription, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDriverDescription, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pRegistration, wcBuf);

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\msiprov.h ===
//***************************************************************************

//

//  MSIProv.h

//

//  Module: WBEM MSI instance provider code.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _MSIProv_H_
#define _MSIProv_H_

#define _WIN32_DCOM

#include <wbemidl.h>
#include <ProvExce.h>

#include <msi.h>
#include <msiQuery.h>
#include <objbase.h>

//#include "msimeth.h"

#define BUFF_SIZE 512
#define QUERY_SIZE 128
#define MSI_PACKAGE_LIST_SIZE 100
#define MSI_MAX_APPLICATIONS 1500
#define MSI_KEY_LIST_SIZE 10

typedef enum tagACTIONTYPE
{
	ACTIONTYPE_ENUM =	0,
	ACTIONTYPE_GET =	1,
	ACTIONTYPE_QUERY =	2

} ACTIONTYPE;

// The provider string is always in WCHAR format

#define DELIMETER L'|'

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CMSIProv : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG m_cRef;         //Object reference count
     public:
		 IWbemServices *m_pNamespace;

        CMSIProv(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CMSIProv(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink);
        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync(const BSTR ObjectPath, const BSTR Method,
												  long lFlags,
												  IWbemContext *pCtx,
												  IWbemClassObject *pInParams,
												  IWbemObjectSink *pResponse);

private:

	bool CheckForMsiDll();
	bool UnloadMsiDll();
	static CHeap_Exception m_he;
};

typedef CMSIProv *PCMSIProv;

// Some utility functions

char * WcharToTchar(WCHAR * wcPtr, char *wcTmp);
WCHAR * TcharToWchar(char * tcPtr, WCHAR *wcTmp);
WCHAR * TcharToWchar(const char * tcPtr, WCHAR *wcTmp);
HRESULT ConvertError(UINT uiStatus);
WCHAR * EscapeStringW(WCHAR * wcIn, WCHAR * wcOut);
bool SafeLeaveCriticalSection(CRITICAL_SECTION *pcs);

void SoftwareElementState(INSTALLSTATE piInstalled, int *iState);
bool CreateProductString(WCHAR *cProductCode, WCHAR *cProductPath);

DWORD CreateSoftwareElementString	(	MSIHANDLE hDatabase,
										WCHAR *wcComponent,
										WCHAR *wcProductCode,
										WCHAR *wcPath,
										DWORD * dwPath
									);

bool CreateSoftwareFeatureString(WCHAR *wcName, WCHAR *wcProductCode, WCHAR * wcString, bool bValidate);

int GetOS();
bool IsNT4();
bool IsNT5();
BOOL IsLessThan4();
bool AreWeOnNT();
HRESULT CheckImpersonationLevel();
bool ValidateComponentID(WCHAR *wcID, WCHAR *wcProductCode);
bool ValidateComponentName(MSIHANDLE hDatabase, WCHAR *wcProductCode, WCHAR *wcName);
bool ValidateFeatureName(WCHAR *wcName, WCHAR *wcProduct);

// These variables keep track of when the module can be unloaded
extern long       g_cObj;
extern long       g_cLock;

// These variables keep track of acces to the MSI databases
extern CRITICAL_SECTION g_msi_prov_cs;

extern WCHAR *g_wcpLoggingDir;

//These are the valiables used to track MSI.dll and it's exported functions
typedef UINT (CALLBACK* LPFNMSIVIEWFETCH)(MSIHANDLE, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIRECORDGETSTRINGW)(MSIHANDLE, unsigned int, LPWSTR, DWORD*);
typedef UINT (CALLBACK* LPFNMSICLOSEHANDLE)(MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIDATABASEOPENVIEWW)(MSIHANDLE, LPCWSTR, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIVIEWEXECUTE)(MSIHANDLE, MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIGETACTIVEDATABASE)(MSIHANDLE);
typedef INSTALLSTATE (CALLBACK* LPFNMSIGETCOMPONENTPATHW)(LPCWSTR, LPCWSTR, LPWSTR, DWORD*);
typedef UINT (CALLBACK* LPFNMSIGETCOMPONENTSTATEW)(MSIHANDLE, LPCWSTR, INSTALLSTATE*, INSTALLSTATE*);
typedef UINT (CALLBACK* LPFNMSIOPENPRODUCTW)(LPCWSTR, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIOPENPACKAGEW)(LPCWSTR, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIDATABASEISTABLEPERSITENTW)(MSIHANDLE, LPCWSTR);
typedef INSTALLUILEVEL (CALLBACK* LPFNMSISETINTERNALUI)(INSTALLUILEVEL, HWND);
typedef INSTALLUI_HANDLER (CALLBACK* LPFNMSISETEXTERNALUIW)(INSTALLUI_HANDLER, DWORD, LPVOID);
typedef UINT (CALLBACK* LPFNMSIENABLELOGW)(DWORD, LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIGETPRODUCTPROPERTYW)(MSIHANDLE, LPCWSTR, LPWSTR, DWORD*);
typedef INSTALLSTATE (CALLBACK* LPFNMSIQUERYPRODUCTSTATEW)(LPCWSTR);
typedef UINT (CALLBACK* LPFNMSIINSTALLPRODUCTW)(LPCWSTR, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSICONFIGUREPRODUCTW)(LPCWSTR, int, INSTALLSTATE);
typedef UINT (CALLBACK* LPFNMSIREINSTALLPRODUCTW)(LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIAPPLYPATCHW)(LPCWSTR, LPCWSTR, INSTALLTYPE, LPCWSTR);
typedef int (CALLBACK* LPFNMSIRECORDGETINTEGER)(MSIHANDLE, unsigned int);
typedef UINT (CALLBACK* LPFNMSIENUMFEATURESW)(LPCWSTR, DWORD, LPWSTR, LPWSTR);
typedef UINT (CALLBACK* LPFNMSIGETPRODUCTINFOW)(LPCWSTR, LPCWSTR, LPWSTR, DWORD*);
typedef INSTALLSTATE (CALLBACK* LPFNMSIQUERYFEATURESTATEW)(LPCWSTR, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSIGETFEATUREUSAGEW)(LPCWSTR, LPCWSTR, DWORD*, WORD*);
typedef UINT (CALLBACK* LPFNMSIGETFEATUREINFOW)(MSIHANDLE, LPCWSTR, DWORD*, LPWSTR, DWORD*, LPWSTR, DWORD*);
typedef UINT (CALLBACK* LPFNMSICONFIGUREFEATUREW)(LPCWSTR, LPCWSTR, INSTALLSTATE);
typedef UINT (CALLBACK* LPFNMSIREINSTALLFEATUREW)(LPCWSTR, LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIENUMPRODUCTSW)(DWORD, LPWSTR);
typedef UINT (CALLBACK* LPFNMSIGETDATABASESTATE)(MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIRECORDSETSTRINGW)(MSIHANDLE, unsigned int, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSIDATABASECOMMIT)(MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIENUMCOMPONENTSW)(DWORD, LPWSTR);
typedef UINT (CALLBACK* LPFNMSIVIEWCLOSE)(MSIHANDLE);

extern bool g_bMsiPresent;
extern bool g_bMsiLoaded;

extern LPFNMSIVIEWFETCH					g_fpMsiViewFetch;
extern LPFNMSIRECORDGETSTRINGW			g_fpMsiRecordGetStringW;
extern LPFNMSICLOSEHANDLE				g_fpMsiCloseHandle;
extern LPFNMSIDATABASEOPENVIEWW			g_fpMsiDatabaseOpenViewW;
extern LPFNMSIVIEWEXECUTE				g_fpMsiViewExecute;
extern LPFNMSIGETACTIVEDATABASE			g_fpMsiGetActiveDatabase;
extern LPFNMSIGETCOMPONENTPATHW			g_fpMsiGetComponentPathW;
extern LPFNMSIGETCOMPONENTSTATEW		g_fpMsiGetComponentStateW;
extern LPFNMSIOPENPRODUCTW				g_fpMsiOpenProductW;
extern LPFNMSIOPENPACKAGEW				g_fpMsiOpenPackageW;
extern LPFNMSIDATABASEISTABLEPERSITENTW	g_fpMsiDatabaseIsTablePersistentW;
extern LPFNMSISETINTERNALUI				g_fpMsiSetInternalUI;
extern LPFNMSISETEXTERNALUIW			g_fpMsiSetExternalUIW;
extern LPFNMSIENABLELOGW				g_fpMsiEnableLogW;
extern LPFNMSIGETPRODUCTPROPERTYW		g_fpMsiGetProductPropertyW;
extern LPFNMSIQUERYPRODUCTSTATEW		g_fpMsiQueryProductStateW;
extern LPFNMSIINSTALLPRODUCTW			g_fpMsiInstallProductW;
extern LPFNMSICONFIGUREPRODUCTW			g_fpMsiConfigureProductW;
extern LPFNMSIREINSTALLPRODUCTW			g_fpMsiReinstallProductW;
extern LPFNMSIAPPLYPATCHW				g_fpMsiApplyPatchW;
extern LPFNMSIRECORDGETINTEGER			g_fpMsiRecordGetInteger;
extern LPFNMSIENUMFEATURESW				g_fpMsiEnumFeaturesW;
extern LPFNMSIGETPRODUCTINFOW			g_fpMsiGetProductInfoW;
extern LPFNMSIQUERYFEATURESTATEW		g_fpMsiQueryFeatureStateW;
extern LPFNMSIGETFEATUREUSAGEW			g_fpMsiGetFeatureUsageW;
extern LPFNMSIGETFEATUREINFOW			g_fpMsiGetFeatureInfoW;
extern LPFNMSICONFIGUREFEATUREW			g_fpMsiConfigureFeatureW;
extern LPFNMSIREINSTALLFEATUREW			g_fpMsiReinstallFeatureW;
extern LPFNMSIENUMPRODUCTSW				g_fpMsiEnumProductsW;
extern LPFNMSIGETDATABASESTATE			g_fpMsiGetDatabaseState;
extern LPFNMSIRECORDSETSTRINGW			g_fpMsiRecordSetStringW;
extern LPFNMSIDATABASECOMMIT			g_fpMsiDatabaseCommit;
extern LPFNMSIENUMCOMPONENTSW			g_fpMsiEnumComponentsW;
extern LPFNMSIVIEWCLOSE					g_fpMsiViewClose;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasource.h ===
// ODBCDataSource.h: interface for the CODBCDataSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDATASOURCE_H__75F6BA13_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDATASOURCE_H__75F6BA13_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDataSource : public CGenericClass  
{
public:
	CODBCDataSource(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDataSource();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDATASOURCE_H__75F6BA13_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasourceattribute.h ===
// ODBCDataSourceAttribute.h: interface for the CODBCDataSourceAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDATASOURCEATTRIBUTE_H__75F6BA17_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDATASOURCEATTRIBUTE_H__75F6BA17_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDataSourceAttribute : public CGenericClass  
{
public:
	CODBCDataSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDataSourceAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDATASOURCEATTRIBUTE_H__75F6BA17_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasourceattribute.cpp ===
// ODBCDataSourceAttribute.cpp: implementation of the CODBCDataSourceAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDataSourceAttribute.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDataSourceAttribute::CODBCDataSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDataSourceAttribute::~CODBCDataSourceAttribute()
{

}

HRESULT CODBCDataSourceAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt wcProp;

    //These will change from class to class
    bool bDriver, bAttribute;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `DataSource_`, `Attribute` from ODBCSourceAttribute");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCSourceAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                    if(wcscmp(wcBuf, L"") != 0)
					{
						// safe operation
                        wcProp.Copy ( L"Win32_ODBCDataSourcespecification.CheckID=\"" );
						wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
						PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

						// safe operation
                        wcProp.Copy ( L"Win32_ODBCSourceAttribute.Attribute=\"" );
						wcProp.Append ( 2, wcBuf, L"\",DataSource=\"" );

                        dwBufSize = BUFF_SIZE;
						CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							wcProp.Append ( 2, wcBuf, L"\"" );
							PutKeyProperty(m_pObj, pSetting, wcProp, &bAttribute, m_pRequest);

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriver.h ===
// ODBCDriver.h: interface for the CODBCDriver class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDRIVER_H__75F6BA15_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDRIVER_H__75F6BA15_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDriver : public CGenericClass  
{
public:
	CODBCDriver(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDriver();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDRIVER_H__75F6BA15_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriver.cpp ===
// ODBCDriver.cpp: implementation of the CODBCDriver class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDriver.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDriver::CODBCDriver(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDriver::~CODBCDriver()
{

}

HRESULT CODBCDriver::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcDriver[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcDriver);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Driver`, `Component_`, `Description`, `File_`, `File_Setup` from ODBCDriver" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Driver`=\'", wcDriver, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDriver", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pDriver, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //=====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDescription, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pFile, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSetupFile, wcBuf);

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriverattribute.cpp ===
// ODBCDriverAttribute.cpp: implementation of the CODBCDriverAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDriverAttribute.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDriverAttribute::CODBCDriverAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDriverAttribute::~CODBCDriverAttribute()
{

}

HRESULT CODBCDriverAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt wcProp;

    //These will change from class to class
    bool bDriver, bAttribute;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Driver_`, `Attribute` from ODBCAttribute");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                    if(wcscmp(wcBuf, L"") != 0)
					{
						// safe operation
                        wcProp.Copy ( L"Win32_ODBCDriverSpecification.CheckID=\"" );
						wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
						PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

						// safe operation
                        wcProp.Copy ( L"Win32_ODBCAttribute.Attribute=\"" );
						wcProp.Append ( 2, wcBuf, L"\",Driver=\"" );

                        dwBufSize = BUFF_SIZE;
						CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							wcProp.Append ( 2, wcBuf, L"\"" );
							PutKeyProperty(m_pObj, pSetting, wcProp, &bAttribute, m_pRequest);

                        //=====================================================

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriversoftwareelement.h ===
// ODBCDriverSoftwareElement.h: interface for the CODBCDriverSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDRIVERSOFTWAREELEMENT_H__75F6BA19_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDRIVERSOFTWAREELEMENT_H__75F6BA19_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDriverSoftwareElement : public CGenericClass  
{
public:
	CODBCDriverSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDriverSoftwareElement();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDRIVERSOFTWAREELEMENT_H__75F6BA19_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriversoftwareelement.cpp ===
// ODBCDriverSoftwareElement.cpp: implementation of the CODBCDriverSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDriverSoftwareElement.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDriverSoftwareElement::CODBCDriverSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDriverSoftwareElement::~CODBCDriverSoftwareElement()
{

}

HRESULT CODBCDriverSoftwareElement::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt str;

    //These will change from class to class
    bool bFeature, bElement;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Component_`, `Driver` from ODBCDriver");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));
        
		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDriver", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

					dwBufSize = BUFF_SIZE;
					uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																wcBuf,
																wcProductCode,
																wcProp,
																&dwBufSize
														   );

					if ( uiStatus == ERROR_SUCCESS )
					{
                        PutKeyProperty(m_pObj, pElement, wcProp, &bElement, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
                            str.Copy ( L"Win32_ODBCDriverSpecification.CheckID=\"" );
							str.Append ( 3, wcBuf, wcProductCode, L"\"" );
							PutKeyProperty(m_pObj, pCheck, str, &bFeature, m_pRequest);

                            if(bFeature && bElement) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;
                
                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcsourceattribute.cpp ===
// ODBCSourceAttribute.cpp: implementation of the CODBCSourceAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCSourceAttribute.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCSourceAttribute::CODBCSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCSourceAttribute::~CODBCSourceAttribute()
{

}

HRESULT CODBCSourceAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bDriver, bAttribute;
    wcscpy(wcQuery, L"select distinct `DataSource_`, `Attribute`, `Value` from ODBCSourceAttribute");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED)){

		//Open our database

        try
		{
            if ( GetView ( &hView, m_pRequest->Package(i), wcQuery, L"ODBCSourceAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pDataSource, wcBuf, &bDriver, m_pRequest);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pAttribute, wcBuf, &bAttribute, m_pRequest);
                    PutProperty(m_pObj, pCaption, wcBuf);
                    PutProperty(m_pObj, pDescription, wcBuf);

                //=====================================================

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pValue, wcBuf);

                //----------------------------------------------------

                    if(bDriver && bAttribute) bMatch = true;

                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                        hr = pHandler->Indicate(1, &m_pObj);
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcsourceattribute.h ===
// ODBCSourceAttribute.h: interface for the CODBCSourceAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCSOURCEATTRIBUTE_H__75F6BA18_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCSOURCEATTRIBUTE_H__75F6BA18_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCSourceAttribute : public CGenericClass  
{
public:
	CODBCSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCSourceAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCSOURCEATTRIBUTE_H__75F6BA18_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriverattribute.h ===
// ODBCDriverAttribute.h: interface for the CODBCDriverAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDRIVERATTRIBUTE_H__75F6BA16_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDRIVERATTRIBUTE_H__75F6BA16_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDriverAttribute : public CGenericClass  
{
public:
	CODBCDriverAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDriverAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDRIVERATTRIBUTE_H__75F6BA16_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbctranslator.h ===
// ODBCTranslator.h: interface for the CODBCTranslator class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCTRANSLATOR_H__75F6BA14_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCTRANSLATOR_H__75F6BA14_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCTranslator : public CGenericClass  
{
public:
	CODBCTranslator(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCTranslator();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCTRANSLATOR_H__75F6BA14_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\odbctranslator.cpp ===
// ODBCTranslator.cpp: implementation of the CODBCTranslator class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCTranslator.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCTranslator::CODBCTranslator(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCTranslator::~CODBCTranslator()
{

}

HRESULT CODBCTranslator::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTranslator[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcTranslator);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Translator`, `Component_`, `Description`, `File_`, `File_Setup` from ODBCTranslator" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Translator`=\'", wcTranslator, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCTranslator", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pTranslator, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //=====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDescription, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pFile, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSetupFile, wcBuf);

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patch.cpp ===
// Patch.cpp: implementation of the CPatch class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Patch.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatch::CPatch(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatch::~CPatch()
{

}

HRESULT CPatch::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bFile, bSequence, bProduct;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"File" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Sequence`, `PatchSize`, `Attributes` from Patch" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `File`=\'", wcName, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Patch", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pFile, wcBuf, &bFile, m_pRequest);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutKeyProperty(m_pObj, pSequence, g_fpMsiRecordGetInteger(hRecord, 2),
                            &bSequence, m_pRequest);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProduct, m_pRequest);
                    //====================================================

                        PutProperty(m_pObj, pPatchSize, g_fpMsiRecordGetInteger(hRecord, 3));

                        PutProperty(m_pObj, pAttributes, g_fpMsiRecordGetInteger(hRecord, 4));
                    //----------------------------------------------------

                        if(bFile && bSequence && bProduct) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patchfile.h ===
// PatchFile.h: interface for the CPatchFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCHFILE_H__02FF6C8A_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PATCHFILE_H__02FF6C8A_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatchFile : public CGenericClass  
{
public:
	CPatchFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatchFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCHFILE_H__02FF6C8A_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patch.h ===
// Patch.h: interface for the CPatch class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCH_H__DB614F2A_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_PATCH_H__DB614F2A_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatch : public CGenericClass  
{
public:
	CPatch(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatch();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCH_H__DB614F2A_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackage.h ===
// PatchPackAge.h: interface for the CPatchPackAge class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCHPACKAGE_H__DB614F2E_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_PATCHPACKAGE_H__DB614F2E_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatchPackAge : public CGenericClass  
{
public:
	CPatchPackAge(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatchPackAge();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCHPACKAGE_H__DB614F2E_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackage.cpp ===
// PatchPackAge.cpp: implementation of the CPatchPackAge class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PatchPackAge.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatchPackAge::CPatchPackAge(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatchPackAge::~CPatchPackAge()
{

}

HRESULT CPatchPackAge::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bPatchID, bProductCode;

        //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"PatchID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `PatchId` from PatchPackage" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `PatchId`=\'", wcName, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PatchPackage", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pPatchID, wcBuf, &bPatchID, m_pRequest);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProductCode, m_pRequest);

                    //----------------------------------------------------

                        if(bPatchID && bProductCode) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackagesource.h ===
// PatchPackageSource.h: interface for the CPatchPackageSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCHPACKAGESOURCE_H__02FF6C8B_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PATCHPACKAGESOURCE_H__02FF6C8B_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatchPackageSource : public CGenericClass  
{
public:
	CPatchPackageSource(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatchPackageSource();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCHPACKAGESOURCE_H__02FF6C8B_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackagesource.cpp ===
// PatchPackageSource.cpp: implementation of the CPatchPackageSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PatchPackageSource.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatchPackageSource::CPatchPackageSource(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatchPackageSource::~CPatchPackageSource()
{

}

HRESULT CPatchPackageSource::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt wcPatch;
	CStringExt wcMedia;

    //These will change from class to class
    bool bPatch, bMedia;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `PatchId`, `Media_` from PatchPackage");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"PatchPackage", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    if(wcscmp(wcBuf, L"") != 0)
					{
						// safe operation
                        wcPatch.Copy ( L"Win32_PatchPackage.PatchID=\"" );
						wcPatch.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );

						PutKeyProperty(m_pObj, pPatch, wcPatch, &bPatch, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
                            wcMedia.Copy ( L"Win32_MSILogicalDisk.DiskID=\"" );
							wcMedia.Append ( 2, wcBuf, L"\"" );

							PutKeyProperty(m_pObj, pSource, wcMedia, &bMedia, m_pRequest);

                        //----------------------------------------------------

                            if(bPatch && bMedia) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\patchfile.cpp ===
// PatchFile.cpp: implementation of the CPatchFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PatchFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatchFile::CPatchFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatchFile::~CPatchFile()
{

}

HRESULT CPatchFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hFView	= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hFRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery1[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;

	CStringExt wcPatch;
	CStringExt wcFile;

    bool bResource, bProduct;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery1, L"select distinct `File_`, `Sequence` from Patch");

	QueryExt wcQuery ( L"select distinct `File`, `Component_` from File where File=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery1, L"Patch", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

					// safe operation
                    wcPatch.Copy ( L"Win32_Patch.File=\"" );

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    if(wcscmp(wcBuf, L"") != 0)
					{
						wcPatch .Append ( 2, wcBuf, L"\",Sequence=\"" );

						// make query on fly
						wcQuery.Append ( 2, wcBuf, L"\'" );

                        dwBufSize = BUFF_SIZE;
						CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							wcPatch.Append ( 2, wcBuf, L"\"" );
							PutKeyProperty(m_pObj, pSetting, wcPatch, &bResource, m_pRequest);

                            CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery, &hFView));
                            CheckMSI(g_fpMsiViewExecute(hFView, 0));

                            uiStatus = g_fpMsiViewFetch(hFView, &hFRecord);

                            if(uiStatus != ERROR_NO_MORE_ITEMS){

                                CheckMSI(uiStatus);

								// safe operation
                                wcFile.Copy ( L"Win32_FileSpecification.CheckID=\"" );

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hFRecord, 1, wcBuf, &dwBufSize));

								wcFile.Append ( 3, wcProductCode, wcBuf, L"\"");
		                        PutKeyProperty(m_pObj, pCheck, wcFile, &bProduct, m_pRequest);
							}

                            g_fpMsiViewClose(hFView);
                            g_fpMsiCloseHandle(hFView);
                            g_fpMsiCloseHandle(hFRecord);

                        //----------------------------------------------------

                            if(bResource && bProduct) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;
                    
                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include "msiprov.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\product.h ===
// Product.h: interface for the CProduct class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCT_H__AA9CA854_D9EE_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_PRODUCT_H__AA9CA854_D9EE_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"
#include "requestobject.h"

class CProduct : public CGenericClass  
{
public:
    CProduct(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
    virtual ~CProduct();

    virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
        {return WBEM_E_NOT_SUPPORTED;}

    //WBEM Methods
    HRESULT Admin(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                  IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Advertise(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Install(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                    IWbemObjectSink *pHandler, IWbemContext *pCtx);

    HRESULT Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Uninstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Upgrade(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                    IWbemObjectSink *pHandler, IWbemContext *pCtx);

    virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PRODUCT_H__AA9CA854_D9EE_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\productenvironment.cpp ===
// ProductEnvironment.cpp: implementation of the CProductEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProductEnvironment.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProductEnvironment::CProductEnvironment(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProductEnvironment::~CProductEnvironment()
{

}

HRESULT CProductEnvironment::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;

    bool bResource, bProduct;

	CStringExt wcResource;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Environment`, `Component_` from Environment");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if(CreateProductString(wcProductCode, wcProduct)){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Environment", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

						// safe operation
                        wcResource.Copy ( L"Win32_EnvironmentSpecification.CheckID=\"" );

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        if(wcscmp(wcBuf, L"") != 0)
						{
							wcResource.Append ( 3, wcBuf, wcProductCode, L"\"" );

                            dwBufSize = BUFF_SIZE;
							CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
							{
                                PutKeyProperty(m_pObj, pCheck, wcResource, &bResource, m_pRequest);
                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                            //====================================================

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\product.cpp ===
// Product.cpp: implementation of the CProduct class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Product.h"
#include <wininet.h>
#include <ocidl.h>
#include "CRegCls.h"

#include <WbemTime.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProduct::CProduct(CRequestObject *pObj, IWbemServices *pNamespace,
                IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProduct::~CProduct()
{

}

HRESULT CProduct::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufsize;
    bool bMatch = false;
    bool bTestCode = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int iPos = -1;
        BSTR bstrIdentifyingNumber = SysAllocString(L"IdentifyingNumber");

		if ( bstrIdentifyingNumber )
		{
			if(FindIn(m_pRequest->m_Property, bstrIdentifyingNumber, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bTestCode = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrIdentifyingNumber );
					throw hr;
				}

			}

			SysFreeString(bstrIdentifyingNumber);
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    bool bName, bVersion = false, bIDNum, bProductHandle;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0)))
		{
			//Open our database

            try
			{
				if ( GetView ( NULL, wcProductCode, NULL, NULL, FALSE, TRUE ) )
				{
					bProductHandle = true;
				}
				else
				{
					bProductHandle = false;
				}

				if(FAILED(hr = SpawnAnInstance(&m_pObj)))
				{
					throw hr;
				}

                dwBufsize = BUFF_SIZE;
                CheckMSI(g_fpMsiGetProductInfoW(wcProductCode, INSTALLPROPERTY_PRODUCTNAME, wcBuf, &dwBufsize));
                PutKeyProperty(m_pObj, pName, wcBuf, &bName, m_pRequest);

                PutProperty(m_pObj, pCaption, wcBuf);
                PutProperty(m_pObj, pDescription, wcBuf);

                if(bProductHandle)
				{
					dwBufsize = BUFF_SIZE;
					CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"Manufacturer", wcBuf, &dwBufsize));
					PutProperty(m_pObj, pVendor, wcBuf);

					dwBufsize = BUFF_SIZE;
					CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufsize));
					PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                }

                PutKeyProperty(m_pObj, pIdentifyingNumber, wcProductCode, &bIDNum, m_pRequest);

                INSTALLSTATE isState = g_fpMsiQueryProductStateW(wcProductCode);

                switch(isState)
				{
	                case INSTALLSTATE_ABSENT:
                    break;

		            case INSTALLSTATE_ADVERTISED:
						dwBufsize = BUFF_SIZE;
						if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_VERSIONSTRING, wcBuf, &dwBufsize))
						{
							PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
							dwBufsize = BUFF_SIZE;
						}
                    break;

	                case INSTALLSTATE_BADCONFIG:
                    break;

			        case INSTALLSTATE_DEFAULT:
				        dwBufsize = BUFF_SIZE;
					    if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_VERSIONSTRING, wcBuf, &dwBufsize))
						{
	                        PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
		                }

			            dwBufsize = BUFF_SIZE;
				        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_LOCALPACKAGE, wcBuf, &dwBufsize))
						{
	                        PutProperty(m_pObj, pPackageCache, wcBuf);
		                }

			            dwBufsize = BUFF_SIZE;
				        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_INSTALLDATE, wcBuf, &dwBufsize))
						{
	                        PutProperty(m_pObj, pInstallDate, wcBuf);

							if ( ( lstrlenW ( wcBuf ) + lstrlenW ( L"000000.000000+000" ) + 1 ) < BUFF_SIZE )
							{
								lstrcatW ( wcBuf, L"000000.000000+000" );

								BSTR	bstrWbemTime;
								if ( ( bstrWbemTime	= ::SysAllocString ( wcBuf ) ) != NULL )
								{
									WBEMTime	time ( bstrWbemTime );
									::SysFreeString ( bstrWbemTime );

									if ( time.IsOk () )
									{
										bstrWbemTime= time.GetDMTF ( );

										try
										{
											PutProperty( m_pObj, pInstallDate2, bstrWbemTime );
										}
										catch ( ... )
										{
											::SysFreeString ( bstrWbemTime );
											throw;
										}

										::SysFreeString ( bstrWbemTime );
									}
									else
									{
										hr = E_INVALIDARG;
									}
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								hr = E_FAIL;
							}
		                }

			            dwBufsize = BUFF_SIZE;
				        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_INSTALLLOCATION, wcBuf, &dwBufsize))
						{
							PutProperty(m_pObj, pInstallLocation, wcBuf);
						}
                    break;

	                case INSTALLSTATE_INVALIDARG:
                    break;

			        case INSTALLSTATE_UNKNOWN:
                    break;

					default:
					break;
                }

                PutProperty(m_pObj, pInstallState, (int)isState);

                if(bName && bVersion && bIDNum)
				{
					bMatch = true;
				}

                if((atAction != ACTIONTYPE_GET)  || bMatch)
				{
                    hr = pHandler->Indicate(1, &m_pObj);
                }

                m_pObj->Release();
                m_pObj = NULL;
			}
			catch(...)
			{
				msidata.CloseProduct ();

                if(m_pObj)
				{
                    m_pObj->Release();
                    m_pObj = NULL;
                }

                throw;
            }

			msidata.CloseProduct ();
        }
    }

    return hr;
}

HRESULT CProduct::Admin(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                        IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
    BSTR bstrTarget = NULL;
    BSTR bstrOptions = NULL;
    UINT uiStatus = 1603;
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrInstall = SysAllocString(L"Install");
    if(!bstrInstall)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrInstall, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "PackageLocation", &bstrPackage))){

                    if((wcscmp(bstrPackage, L"") != 0) && (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){

                        //Get Options
                        if(SUCCEEDED(GetProperty(pInParams, "TargetLocation", &bstrTarget))){
                            //Get Options
                            if(SUCCEEDED(GetProperty(pInParams, "Options", &bstrOptions)))
							{
								// safe operation
                                wcscpy(wcOptions, L"ACTION=ADMIN");

                                if((wcscmp(bstrTarget, L"") != 0))
								{
									if ( wcslen ( wcOptions ) + wcslen ( L" TARGETDIR=") + wcslen ( bstrTarget ) + 1 < dwOptions )
									{
										wcscat(wcOptions, L" TARGETDIR=");
										wcscat(wcOptions, bstrTarget);
									}
									else
									{
										LPWSTR wsz = NULL;

										try
										{
											if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" TARGETDIR=") + wcslen ( bstrTarget ) + 1 ] ) != NULL )
											{
												wcscpy(wsz, wcOptions);
												wcscat(wsz, L" TARGETDIR=");
												wcscat(wsz, bstrTarget);

												if ( wcOptions )
												{
													delete [] wcOptions;
													wcOptions = NULL;
												}

												wcOptions = wsz;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wsz )
											{
												delete [] wsz;
												wsz = NULL;
											}

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}
									}
                                }

                                if((wcscmp(bstrOptions, L"") != 0))
								{
									if ( wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( bstrOptions ) + 1 < dwOptions )
									{
										wcscat(wcOptions, L" ");
										wcscat(wcOptions, bstrOptions);
									}
									else
									{
										LPWSTR wsz = NULL;

										try
										{
											if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( bstrOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wsz, wcOptions);
												wcscat(wsz, L" ");
												wcscat(wsz, bstrOptions);

												if ( wcOptions )
												{
													delete [] wcOptions;
													wcOptions = NULL;
												}

												wcOptions = wsz;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wsz )
											{
												delete [] wsz;
												wsz = NULL;
											}

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}
									}
                                }

                                if(hrReturn == WBEM_S_NO_ERROR){

                                    if(!IsNT4()){

										if ( msidata.Lock () )
										{
											INSTALLUI_HANDLER ui = NULL;

											//Set UI Level w/ event callback
											ui = SetupExternalUI ( );

											try
											{
												//Call Installer
												uiStatus = g_fpMsiInstallProductW(bstrPackage, wcOptions);
											}
											catch(...)
											{
												uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
											}

											//Restore UI Level w/ event callback
											RestoreExternalUI ( ui );

											msidata. Unlock();
										}

                                    }else{

                                    /////////////////
                                    // NT4 fix code....

                                        try{

                                            WCHAR wcAction[20];
                                            wcscpy(wcAction, L"/admin");

											LPWSTR wcCommandLine = NULL;

											try
											{
												if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
												{
													wcscpy(wcCommandLine, bstrPackage);
													wcscat(wcCommandLine, L" ");
													wcscat(wcCommandLine, wcOptions);

													hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

													delete [] wcCommandLine;
												}
												else
												{
													throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
												}
											}
											catch ( ... )
											{
												if ( wcCommandLine )
												{
													delete [] wcCommandLine;
													wcCommandLine = NULL;
												}

												hrReturn = E_OUTOFMEMORY;
											}

                                        }catch(...){

                                            hrReturn = WBEM_E_FAILED;
                                        }

                                        ////////////////////

                                    }

                                    if(SUCCEEDED(hrReturn)){

                                        //Set up ReturnValue
                                        VariantInit(&v);
                                        V_VT(&v) = VT_I4;
                                        V_I4(&v) = uiStatus;

                                        BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                        if(!bstrReturnValue)
										{
											delete [] wcOptions;
                                            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

                                        if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                            &v, NULL)))
                                            pHandler->Indicate(1, &pOutParams);

                                        SysFreeString(bstrReturnValue);
                                    }
                                }

                                SysFreeString(bstrOptions);

                            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                            SysFreeString(bstrTarget);

                        }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                    }else hrReturn = WBEM_E_INVALID_PARAMETER;

                    SysFreeString(bstrPackage);

                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
                
                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrInstall);

    return hrReturn;
}

HRESULT CProduct::Advertise(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
    WCHAR wcBuf[BUFF_SIZE];
    UINT uiStatus = 1603;
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrAdvertise = SysAllocString(L"Advertise");
    if(!bstrAdvertise)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

    LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

	if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrAdvertise, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "PackageLocation", &bstrPackage))){

                    if((wcscmp(bstrPackage, L"") != 0) && (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){

                        //Get Options
                        if(SUCCEEDED(GetProperty(pInParams, "Options", wcBuf))){

							//Make sure we perform an advertisement
                            wcscpy(wcOptions, L"ACTION=ADVERTISE ALLUSERS=1");

                            if(wcscmp(wcBuf, L"") != 0)
							{
								if ( wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( wcBuf ) + 1 < dwOptions )
								{
									wcscat(wcOptions, L" ");
									wcscat(wcOptions, wcBuf);
								}
								else
								{
									LPWSTR wsz = NULL;

									try
									{
										if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( wcBuf ) + 1 ] ) != NULL )
										{
											wcscpy(wsz, wcOptions);
											wcscat(wsz, L" ");
											wcscat(wsz, wcBuf);

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											wcOptions = wsz;
										}
										else
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}
									}
									catch ( ... )
									{
										if ( wsz )
										{
											delete [] wsz;
											wsz = NULL;
										}

										if ( wcOptions )
										{
											delete [] wcOptions;
											wcOptions = NULL;
										}

										hrReturn = E_OUTOFMEMORY;
									}
								}
                            }

                            if(hrReturn == WBEM_S_NO_ERROR){

                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											uiStatus = g_fpMsiInstallProductW(bstrPackage, wcOptions);
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/advertise");

										LPWSTR wcCommandLine = NULL;

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wcCommandLine, bstrPackage);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcOptions);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                    ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
									{
										delete [] wcOptions;
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }
                            }

                        }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                    }else hrReturn = WBEM_E_INVALID_PARAMETER;

                    SysFreeString(bstrPackage);

                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }
    
	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrAdvertise);

    return hrReturn;
}

HRESULT CProduct::Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iState, iLevel;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrConfigure = SysAllocString(L"Configure");
    if(!bstrConfigure)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    INSTALLSTATE isState;
    int i = -1;
    bool bFoundCode = false;

    m_pRequest = pReqObj;

    LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

	if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrConfigure, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "InstallState", &iState))){

                    //Get Options
                    if(SUCCEEDED(GetProperty(pInParams, "InstallLevel", &iLevel))){

                        //Get the Product Code
                        while(pReqObj->m_Property[++i]){

                            if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
							{
								if ( wcslen ( pReqObj->m_Value[i] ) < BUFF_SIZE )
								{
									wcscpy(wcCode, pReqObj->m_Value[i]);
									bFoundCode = true;
								}
                            }   
                        }

                        if(bFoundCode){

                            //Get the appropriate State
                            switch(iState){
                            case 1:
                                isState = INSTALLSTATE_DEFAULT;
                                break;
                            case 2:
                                isState = INSTALLSTATE_LOCAL;
                                break;
                            case 3:
                                isState = INSTALLSTATE_SOURCE;
                                break;
                            default:
                                isState = INSTALLSTATE_NOTUSED;
                                break;
                            }

                            //Get the appropriate Level
                            switch(iLevel){
                            case 1:
                                iLevel = INSTALLLEVEL_DEFAULT;
                                break;
                            case 2:
                                iLevel = INSTALLLEVEL_MINIMUM;
                                break;
                            case 3:
                                iLevel = INSTALLLEVEL_MAXIMUM;
                                break;
                            default:
                                iLevel = -123;
                                break;
                            }

                            //If everything is valid, proceed
                            if((isState != INSTALLSTATE_NOTUSED) && (iLevel != -123) &&
                                (hrReturn == WBEM_S_NO_ERROR)){

                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											uiStatus = g_fpMsiConfigureProductW(wcCode, iLevel, isState);
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/configure");

										LPWSTR wcCommandLine = NULL;

                                        WCHAR wcTmp1[100];
                                        WCHAR wcTmp2[100];

										_itow((int)iLevel, wcTmp1, 10);
										_itow((int)isState, wcTmp2, 10);

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) +  wcslen ( wcTmp1 ) + wcslen ( wcTmp2 ) + 3 ] ) != NULL )
											{
												wcscpy(wcCommandLine, wcCode);
												wcscat(wcCommandLine, L" ");
												wcscpy(wcCommandLine, wcTmp1);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcTmp2);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
									{
										delete [] wcOptions;
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }

                            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                        }else hrReturn = WBEM_E_FAILED;

                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                pOutParams->Release();

            }else return WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrConfigure);

    return hrReturn;
}

HRESULT CProduct::Install(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                          IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
    WCHAR wcBuf[BUFF_SIZE];
    UINT uiStatus = 1603;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass, 
        0, pCtx, &pClass, NULL))){

        BSTR bstrInstall = SysAllocString(L"Install");
        if(!bstrInstall) throw he;

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrInstall, 0, NULL, &pOutClass))){

            pClass->Release();
            SysFreeString(bstrInstall);

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                pOutClass->Release();

                //Get PackageLocation
                if(SUCCEEDED(hrReturn = GetProperty(pInParams, "PackageLocation", &bstrPackage))){

                    if((wcscmp(bstrPackage, L"") != 0) &&
                        (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){

                        //Get Options
                        if(SUCCEEDED(hrReturn = GetProperty(pInParams, "Options", wcBuf))){

                            //Make sure we perform an advertisement
                            wcscpy(wcOptions, L"ACTION=INSTALL ALLUSERS=1");

                            if(wcscmp(wcBuf, L"") != 0)
							{
								if ( wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( wcBuf ) + 1 < dwOptions )
								{
									wcscat(wcOptions, L" ");
									wcscat(wcOptions, wcBuf);
								}
								else
								{
									LPWSTR wsz = NULL;

									try
									{
										if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( wcBuf ) + 1 ] ) != NULL )
										{
											wcscpy(wsz, wcOptions);
											wcscat(wsz, L" ");
											wcscat(wsz, wcBuf);

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											wcOptions = wsz;
										}
										else
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}
									}
									catch ( ... )
									{
										if ( wsz )
										{
											delete [] wsz;
											wsz = NULL;
										}

										if ( wcOptions )
										{
											delete [] wcOptions;
											wcOptions = NULL;
										}

										hrReturn = E_OUTOFMEMORY;
									}
								}
                            }

                            if(hrReturn == WBEM_S_NO_ERROR){

                                //We want to call MSI ourselves unless we are on NT4
                                // and dealing with a user install.
                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											uiStatus = g_fpMsiInstallProductW(bstrPackage, wcOptions);
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/install");
										LPWSTR wcCommandLine = NULL;

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wcCommandLine, bstrPackage);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcOptions);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                    ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
									{
										delete [] wcOptions;
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }
                            }
                        }
                    }else
                        hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                    SysFreeString(bstrPackage);
                }

                pOutParams->Release();

            }else
                pOutClass->Release();

        }else{

            pClass->Release();
            SysFreeString(bstrInstall);
        }
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    return hrReturn;
}

HRESULT CProduct::Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iMode;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrReinstall = SysAllocString(L"Reinstall");
    if(!bstrReinstall)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    DWORD dwMode;
    int i = -1;
    bool bFoundCode = false;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){
        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrReinstall, 0, NULL, &pOutClass))){
            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){
                //Get Reinstall Mode
                if(SUCCEEDED(GetProperty(pInParams, "ReinstallMode", &iMode))){

                    //Get the Product Code
                    while(pReqObj->m_Property[++i])
					{
                        if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
						{
							if ( wcslen ( pReqObj->m_Value[i] ) < BUFF_SIZE )
							{
								wcscpy(wcCode, pReqObj->m_Value[i]);
								bFoundCode = true;
							}
                        }   
                    }

                    if(bFoundCode){
                        //Get the appropriate ReinstallMode
                        switch(iMode){
                        case 1:
                            dwMode = REINSTALLMODE_FILEMISSING;
                            break;
                        case 2:
                            dwMode = REINSTALLMODE_FILEOLDERVERSION;
                            break;
                        case 3:
                            dwMode = REINSTALLMODE_FILEEQUALVERSION;
                            break;
                        case 4:
                            dwMode = REINSTALLMODE_FILEEXACT;
                            break;
                        case 5:
                            dwMode = REINSTALLMODE_FILEVERIFY;
                            break;
                        case 6:
                            dwMode = REINSTALLMODE_FILEREPLACE;
                            break;
                        case 7:
                            dwMode = REINSTALLMODE_USERDATA;
                            break;
                        case 8:
                            dwMode = REINSTALLMODE_MACHINEDATA;
                            break;
                        case 9:
                            dwMode = REINSTALLMODE_SHORTCUT;
                            break;
                        case 10:
                            dwMode = REINSTALLMODE_PACKAGE;
                            break;
                        default:
                            dwMode = NULL;
                            break;
                        }

                        //If everything is valid, proceed
                        if ( dwMode && hrReturn == WBEM_S_NO_ERROR )
						{
                            if(!IsNT4()){

								if ( msidata.Lock () )
								{
									INSTALLUI_HANDLER ui = NULL;

									//Set UI Level w/ event callback
									ui = SetupExternalUI ( );

									try
									{
										//Call Installer
										uiStatus = g_fpMsiReinstallProductW(wcCode, dwMode);
									}
									catch(...)
									{
										uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
									}

									//Restore UI Level w/ event callback
									RestoreExternalUI ( ui );

									msidata. Unlock();
								}

                            }else{

                            /////////////////
                            // NT4 fix code....

                                try{

                                    WCHAR wcAction[20];
                                    wcscpy(wcAction, L"/reinstall");

                                    WCHAR wcTmp[100];
									_itow((int)dwMode, wcTmp, 10);

									LPWSTR wcCommandLine = NULL;

									try
									{
										if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + 1 + wcslen ( wcTmp ) + 1 ] ) != NULL )
										{
											wcscpy(wcCommandLine, wcCode);
											wcscat(wcCommandLine, L" ");
											wcscat(wcCommandLine, wcTmp);

											hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

											delete [] wcCommandLine;
										}
										else
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}
									}
									catch ( ... )
									{
										if ( wcCommandLine )
										{
											delete [] wcCommandLine;
											wcCommandLine = NULL;
										}

										hrReturn = E_OUTOFMEMORY;
									}

                                }catch(...){

                                    hrReturn = WBEM_E_FAILED;
                                }

                                ////////////////////

                            }

                            if(SUCCEEDED(hrReturn)){

                                //Set up ReturnValue
                                VariantInit(&v);
                                V_VT(&v) = VT_I4;
                                V_I4(&v) = uiStatus;

                                BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                if(!bstrReturnValue)
								{
									delete [] wcOptions;
                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}

                                if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                    &v, NULL)))
                                    pHandler->Indicate(1, &pOutParams);

                                SysFreeString(bstrReturnValue);
                            }

                        }else return WBEM_E_INVALID_METHOD_PARAMETERS;

                    }else hrReturn = WBEM_E_FAILED;

                    pOutParams->Release();
                
                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReinstall);

    return hrReturn;
}

HRESULT CProduct::Uninstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrConfigure = SysAllocString(L"Configure");
    if(!bstrConfigure)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    int i = -1;
    bool bFoundCode = false;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrConfigure, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get the Product Code
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
					{
						if ( wcslen ( pReqObj->m_Value[i] ) < BUFF_SIZE )
						{
							wcscpy(wcCode, pReqObj->m_Value[i]);
							bFoundCode = true;
						}
                    }   
                }

                if(bFoundCode){
                    //If everything is valid, proceed
                    if(hrReturn == WBEM_S_NO_ERROR){
                        
                        if(!IsNT4()){

							if ( msidata.Lock () )
							{
								INSTALLUI_HANDLER ui = NULL;

								//Set UI Level w/ event callback
								ui = SetupExternalUI ( );

								try
								{
									//Call Installer
									uiStatus = g_fpMsiConfigureProductW(wcCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT);
								}
								catch(...)
								{
									uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
								}

								//Restore UI Level w/ event callback
								RestoreExternalUI ( ui );

								msidata. Unlock();
							}

                        }else{

                        /////////////////
                        // NT4 fix code....

                            try{

                                WCHAR wcAction[20];
                                wcscpy(wcAction, L"/uninstall");

								LPWSTR wcCommandLine = NULL;

								try
								{
									if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + 1 ] ) != NULL )
									{
										wcscpy(wcCommandLine, wcCode);
										hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

										delete [] wcCommandLine;
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcCommandLine )
									{
										delete [] wcCommandLine;
										wcCommandLine = NULL;
									}

									hrReturn = E_OUTOFMEMORY;
								}

                            }catch(...){

                                hrReturn = WBEM_E_FAILED;
                            }

                            ////////////////////

                        }

                        if(SUCCEEDED(hrReturn)){

                            //Set up ReturnValue
                            VariantInit(&v);
                            V_VT(&v) = VT_I4;
                            V_I4(&v) = uiStatus;

                            BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                            if(!bstrReturnValue)
							{
								delete [] wcOptions;
                                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}

                            if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                &v, NULL)))
                                pHandler->Indicate(1, &pOutParams);

                            SysFreeString(bstrReturnValue);
                        }
                        
                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
                }else hrReturn = WBEM_E_FAILED;

                pOutParams->Release();
            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrConfigure);

    return hrReturn;
}

HRESULT CProduct::Upgrade(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                          IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
	WCHAR wcOptions[BUFF_SIZE];
    UINT uiStatus = 1603;
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrUpgrade = SysAllocString(L"Upgrade");
    if(!bstrUpgrade)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrUpgrade, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){
                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "PackageLocation", &bstrPackage))){

                    if((wcscmp(bstrPackage, L"") != 0) && (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){
                    
                    //Get Options
                        if(SUCCEEDED(GetProperty(pInParams, "Options", wcOptions))){

                            if(hrReturn == WBEM_S_NO_ERROR){
                                
                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											if (wcscmp(wcOptions, L"") != 0)
											{
												uiStatus = g_fpMsiApplyPatchW(bstrPackage, NULL, INSTALLTYPE_DEFAULT, wcOptions);
											}
											else
											{
												uiStatus = g_fpMsiApplyPatchW(bstrPackage, NULL, INSTALLTYPE_DEFAULT, NULL);
											}
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/upgrade");

										LPWSTR wcCommandLine = NULL;

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wcCommandLine, bstrPackage);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcOptions);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                    ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }
                            }
                        }else
                            hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
                    }else
                        hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                    SysFreeString(bstrPackage);

                }else
                    hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }
    
    SysFreeString(bstrUpgrade);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\productenvironment.h ===
// ProductEnvironment.h: interface for the CProductEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCTENVIRONMENT_H__EAA368A4_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PRODUCTENVIRONMENT_H__EAA368A4_DEA4_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProductEnvironment : public CGenericClass  
{
public:
	CProductEnvironment(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProductEnvironment();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PRODUCTENVIRONMENT_H__EAA368A4_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\productresource1.h ===
// ProductResource1.h: interface for the CProductResource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCTRESOURCE1_H__9374E720_D709_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_PRODUCTRESOURCE1_H__9374E720_D709_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CProductResource : public CGenericClass  
{
public:
	CProductResource(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProductResource();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT ProductPatch(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
	HRESULT ProductProperty(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
	HRESULT ProductPatchPackage(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
	HRESULT ProductUpgradeInformation(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
};

#endif // !defined(AFX_PRODUCTRESOURCE1_H__9374E720_D709_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\productresource1.cpp ===
// ProductResource1.cpp: implementation of the CProductResource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProductResource1.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProductResource::CProductResource(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProductResource::~CProductResource()
{

}

HRESULT CProductResource::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pProductRObj = NULL;
    CRequestObject *pResRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
            int i;

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"Resource") == 0){

                    pResRObj = new CRequestObject();
                    if(!pResRObj) throw he;

                    pResRObj->Initialize(m_pNamespace);

                    pResRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"Product") == 0){

                    pProductRObj = new CRequestObject();
                    if(!pProductRObj) throw he;

                    pProductRObj->Initialize(m_pNamespace);

                    pProductRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_Patch") == 0)))
            if(FAILED(hr = ProductPatch(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_Property") == 0)))
            if(FAILED(hr = ProductProperty(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_PatchPackage") == 0)))
            if(FAILED(hr = ProductPatchPackage(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_Upgrade") == 0)))
            if(FAILED(hr = ProductUpgradeInformation(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if(pResRObj){

            pResRObj->Cleanup();
            delete pResRObj;
            pResRObj = NULL;
        }
        if(pProductRObj){

            pProductRObj->Cleanup();
            delete pProductRObj;
            pProductRObj = NULL;
        }

    }catch(...){

        if(pResRObj){

            pResRObj->Cleanup();
            delete pResRObj;
            pResRObj = NULL;
        }
        if(pProductRObj){

            pProductRObj->Cleanup();
            delete pProductRObj;
            pProductRObj = NULL;
        }
    }

    return hr;
}

HRESULT CProductResource::ProductUpgradeInformation(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcUpgradeCode[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bUpgradeCode = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"UpgradeCode") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcUpgradeCode, pResRObj->m_Value[j]);
						bUpgradeCode = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `UpgradeCode`, `ProductVersion`, `Operator` from Upgrade" );

    //optimize for GetObject
    if ( bUpgradeCode && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `UpgradeCode`=\'", wcUpgradeCode, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){

				//Open our database

                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Upgrade", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_Upgrade.UpgradeCode=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcResource.Append ( 2, wcBuf, L"\",ProductVersion=\"" );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								wcResource.Append ( 2, wcBuf, L"\",Operator=\"" );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

								wcResource.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);

                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
            }
        }
    }

    return hr;
}

HRESULT CProductResource::ProductPatchPackage(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcPatchID[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bPatchID = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"PatchID") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcPatchID, pResRObj->m_Value[j]);
						bPatchID = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `PatchId` from PatchPackage" );

    //optimize for GetObject
    if ( bPatchID && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `PatchId`=\'", wcPatchID, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){

				//Open our database

                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"PatchPackage", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_PatchPackage.PatchID=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcResource.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);

                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                            //====================================================

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;
                            
                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
            }
        }
    }

    return hr;
}

HRESULT CProductResource::ProductProperty(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcProperty[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bProperty = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"PatchID") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcProperty, pResRObj->m_Value[j]);
						bProperty = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Property` from Property" );

    //optimize for GetObject
    if ( bProperty && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `Property`=\'", wcProperty, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){
				//Open our database

                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Property", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_Property.Property=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcResource.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);
                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                            //====================================================

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
            }
        }
    }

    return hr;
}

HRESULT CProductResource::ProductPatch(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcPatch[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bPatch = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"File") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcPatch, pResRObj->m_Value[j]);
						bPatch = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Sequence` from Patch" );

    //optimize for GetObject
    if ( bPatch && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcPatch, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){

				//Open our database

                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Patch", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_Patch.File=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcResource.Append ( 2, wcBuf, L"\",Sequence=\"" );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									wcResource.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);

                                    PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                                //====================================================

                                //----------------------------------------------------

                                    if(bResource && bProduct) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\progidspecification.cpp ===
// ProgIDSpecification.cpp: implementation of the CProgIDSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProgIDSpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProgIDSpecification::CProgIDSpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProgIDSpecification::~CProgIDSpecification()
{

}

HRESULT CProgIDSpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
//  phRecord = new MSIHANDLE();
//  if(!phRecord) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcProgId[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcProgId);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ProgId`, `ProgId_Parent`, `Description` from ProgId" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ProgId`=\'", wcProgId, L"\'" );
	}

    while(m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            bMatch = false;
			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ProgId", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pProgID, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pParent, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pDescription, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\progidspecification.h ===
// ProgIDSpecification.h: interface for the CProgIDSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROGIDSPECIFICATION_H__72CDD5D7_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_PROGIDSPECIFICATION_H__72CDD5D7_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProgIDSpecification : public CGenericClass  
{
public:
	CProgIDSpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProgIDSpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PROGIDSPECIFICATION_H__72CDD5D7_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\publishcomponent.h ===
// PublishComponent.h: interface for the CPublishComponent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PUBLISHCOMPONENT_H__75F6BA29_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_PUBLISHCOMPONENT_H__75F6BA29_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPublishComponent : public CGenericClass  
{
public:
	CPublishComponent(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPublishComponent();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PUBLISHCOMPONENT_H__75F6BA29_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\productsoftwarefeatures.cpp ===
// ProductSoftwareFeatures.cpp: implementation of the CProductSoftwareFeatures class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProductSoftwareFeatures.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProductSoftwareFeatures::CProductSoftwareFeatures(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProductSoftwareFeatures::~CProductSoftwareFeatures()
{

}

HRESULT CProductSoftwareFeatures::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE] = { L'\0' };
    WCHAR wcTmp[BUFF_SIZE] = { L'\0' };
    WCHAR wcProductCode[39] = { L'\0' };
    WCHAR wcProduct[BUFF_SIZE] = { L'\0' };
    WCHAR wcFeature[BUFF_SIZE] = { L'\0' };
    UINT uiStatus;
    bool bMatch = false;

    bool bFeature, bProduct;
    int iEnum;

    try{

        while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED)){

			LPWSTR wszProductCode = NULL;
			wszProductCode = m_pRequest->Package(i);

			if ( wszProductCode != NULL )
			{
				wcscpy(wcProductCode, wszProductCode);

				if(CreateProductString(wcProductCode, wcProduct)){

					iEnum = 0;

					// try to get available feature
					do
					{
						uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcBuf, wcTmp);
					}
					while ( uiStatus == ERROR_MORE_DATA );

					while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED))
					{
						CheckMSI(uiStatus);

						if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

						if(CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, false)){

							PutKeyProperty(m_pObj, pComponent, wcFeature, &bFeature, m_pRequest);
							PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);

							if(bFeature && bProduct) bMatch = true;

							if((atAction != ACTIONTYPE_GET)  || bMatch) hr = pHandler->Indicate(1, &m_pObj);
						}

						m_pObj->Release();
						m_pObj = NULL;

						// try to get available feature
						do
						{
							uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcBuf, wcTmp);
						}
						while ( uiStatus == ERROR_MORE_DATA );
					}
				}
			}
        }

    }catch(...){
        
        if(m_pObj){
                
            m_pObj->Release();
            m_pObj = NULL;
        }

        throw;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\publishcomponent.cpp ===
// PublishComponent.cpp: implementation of the CPublishComponent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PublishComponent.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPublishComponent::CPublishComponent(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPublishComponent::~CPublishComponent()
{

}

HRESULT CPublishComponent::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					GetFirstGUID(m_pRequest->m_Value[iPos], wcAction);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ComponentId`, `Component_`, `Qualifier`, `AppData` from PublishComponent" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ComponentId`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PublishComponent", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcProp, &dwBufSize));
                        PutProperty(m_pObj, pComponentID, wcProp);
                        PutProperty(m_pObj, pName, wcProp);
                        PutProperty(m_pObj, pCaption, wcProp);
                        PutProperty(m_pObj, pDescription, wcProp);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pQual, wcBuf);

							PutKeyProperty ( m_pObj, pActionID, wcProp, &bCheck, m_pRequest, 2, wcBuf, wcProductCode );

						//====================================================

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pAppData, wcBuf);

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\property.cpp ===
// Property.cpp: implementation of the CProperty class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Property.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProperty::CProperty(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProperty::~CProperty()
{

}

HRESULT CProperty::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bProperty, bProduct;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"Property" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Property`, `Value` from Property" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `Property`=\'", wcName, L"\'" );
	}

    while(!bMatch && (m_pRequest->Package(++i)) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Property", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pProperty, wcBuf, &bProperty, m_pRequest);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProduct, m_pRequest);
                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        uiStatus = g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize);

                        //check if we overflowed the buffer.. if so try to compensate
                        if ( uiStatus == ERROR_MORE_DATA)
						{
							LPWSTR wcBigBuf = NULL;

							try
							{
								if ( ( wcBigBuf = new WCHAR [ ++dwBufSize ] ) != NULL )
								{
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBigBuf, &dwBufSize));
									PutProperty(m_pObj, pValue, wcBigBuf);
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							catch ( ... )
							{
								if ( wcBigBuf )
								{
									delete [] wcBigBuf;
									wcBigBuf = NULL;
								}

								throw;
							}

							if ( wcBigBuf )
							{
								delete [] wcBigBuf;
								wcBigBuf = NULL;
							}

                        }else{
                        
                            CheckMSI(uiStatus);
                            PutProperty(m_pObj, pValue, wcBuf);
                        }
                    //----------------------------------------------------

                        if(bProperty && bProduct) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\productsoftwarefeatures.h ===
// ProductSoftwareFeatures.h: interface for the CProductSoftwareFeatures class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCTSOFTWAREFEATURES_H__02FF6C84_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PRODUCTSOFTWAREFEATURES_H__02FF6C84_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProductSoftwareFeatures : public CGenericClass  
{
public:
	CProductSoftwareFeatures(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProductSoftwareFeatures();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PRODUCTSOFTWAREFEATURES_H__02FF6C84_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\property.h ===
// Property.h: interface for the CProperty class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROPERTY_H__DB614F2C_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_PROPERTY_H__DB614F2C_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProperty : public CGenericClass  
{
public:
	CProperty(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProperty();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PROPERTY_H__DB614F2C_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\removeinivalue.h ===
// RemoveIniValue.h: interface for the CRemoveIniValue class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REMOVEINIVALUE_H__DB614F34_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_REMOVEINIVALUE_H__DB614F34_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CRemoveIniValue : public CGenericClass  
{
public:
	CRemoveIniValue(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CRemoveIniValue();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_REMOVEINIVALUE_H__DB614F34_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\removeinivalue.cpp ===
// RemoveIniValue.cpp: implementation of the CRemoveIniValue class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "RemoveIniValue.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRemoveIniValue::CRemoveIniValue(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CRemoveIniValue::~CRemoveIniValue()
{

}

HRESULT CRemoveIniValue::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `RemoveIniFile`, `Component_`, `FileName`, `Section`, `Key`, `Value`, `Action` from RemoveIniFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `RemoveIniFile`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveIniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pSection, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pKey, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pValue, wcBuf);

                            PutProperty(m_pObj, pAction, g_fpMsiRecordGetInteger(hRecord, 7));

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\reservecost.cpp ===
// ReserveCost.cpp: implementation of the CReserveCost class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ReserveCost.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CReserveCost::CReserveCost(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CReserveCost::~CReserveCost()
{

}

HRESULT CReserveCost::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcReserveKey[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheckID;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcReserveKey);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ReserveKey`, `Component_`, `ReserveLocal`, `ReserveSource` from ReserveCost" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ReserveKey`=\'", wcReserveKey, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ReserveCost", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pReserveKey, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcBuf, &bCheckID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pReserveLocal, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pReserveSource, wcBuf);
                        //----------------------------------------------------

                            if(bCheckID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\reservecost.h ===
// ReserveCost.h: interface for the CReserveCost class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RESERVECOST_H__02FF6C8E_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_RESERVECOST_H__02FF6C8E_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CReserveCost : public CGenericClass  
{
public:
	CReserveCost(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CReserveCost();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_RESERVECOST_H__02FF6C8E_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\removefile.h ===
// RemoveFile.h: interface for the CRemoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REMOVEFILE_H__F4A87828_E037_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_REMOVEFILE_H__F4A87828_E037_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CRemoveFile : public CGenericClass  
{
public:
	CRemoveFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CRemoveFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_REMOVEFILE_H__F4A87828_E037_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\removefile.cpp ===
// RemoveFile.cpp: implementation of the CRemoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "RemoveFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRemoveFile::CRemoveFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CRemoveFile::~CRemoveFile()
{

}

HRESULT CRemoveFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `FileName`, `DirProperty`, `InstallMode` from RemoveFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `FileKey`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcProp, &dwBufSize));
                        PutProperty(m_pObj, pFileKey, wcProp);
                        PutProperty(m_pObj, pName, wcProp);
                        PutProperty(m_pObj, pCaption, wcProp);
                        PutProperty(m_pObj, pDescription, wcProp);

						PutKeyProperty ( m_pObj, pActionID, wcProp, &bCheck, m_pRequest, 1, wcProductCode );

                        //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pFileName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDirProperty, wcBuf);

                            PutProperty(m_pObj, pInstallMode, g_fpMsiRecordGetInteger(hRecord, 5));

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                            
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\requestobject.h ===
// RequestObject.h: interface for the CRequestObject class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REQUESTOBJECT_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_REQUESTOBJECT_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define EVENT_THREADS   50
#define THREAD_NO_PROGRESS  -9

class CGenericClass;

//Used to house progress message information
typedef struct ProgressStruct
{
    long field1;
    long field2;
    long field3;
    long field4;
} ProgressStruct;

//Used to house progress message information
typedef struct ProListNode
{
    //Link
    ProListNode *pNext;
    //Data
    int iThread;
    IWbemObjectSink *pSink;
    WORD wTotal;
    __int64 lTotal;
    WORD wComplete;
    __int64 lComplete;
    __int64 lActionData;
} ProListNode;

//Used to house package codes
class PackageListNode
{
public:
    PackageListNode() { pNext = NULL; wcscpy(wcCode, L""); }
    virtual ~PackageListNode() {}

    //Link
    PackageListNode *pNext;
    //Data
    WCHAR wcCode[39];
};

//UI Handler
int WINAPI MyEventHandler(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage);

class CRequestObject
{
	friend BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID );

public:
    CRequestObject();
    virtual ~CRequestObject();

    void Initialize(IWbemServices *pNamespace);

    HRESULT CreateObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT CreateObjectEnum(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT PutObject(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT ExecMethod(BSTR bstrPath, BSTR bstrMethod, IWbemClassObject *pInParams,
                   IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT DeleteObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);

#ifdef _EXEC_QUERY_SUPPORT
    HRESULT ExecQuery(BSTR bstrQuery, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    bool ParseQuery(BSTR bstrQuery);
#endif

    bool ParsePath(BSTR bstrPath);
    HRESULT InitializeList(bool bGetList);
    bool DestroyList();
    bool Cleanup();
    void FinalRelease();

    //Registry Hive stuff
    DWORD GetAccount(HANDLE TokenHandle, WCHAR *wcDomain, WCHAR *wcUser);
    DWORD GetSid(HANDLE TokenHandle, WCHAR *wcSID, DWORD dwSID = BUFF_SIZE );
    DWORD LoadHive();
    DWORD UnloadHive();
    DWORD AcquirePrivilege();
    void RestorePrivilege();

    TOKEN_PRIVILEGES* m_pOriginalPriv;
    HKEY m_hKey;
    DWORD m_dwSize;
    DWORD m_dwCheckKeyPresentStatus;
    WCHAR m_wcAccount[BUFF_SIZE];
    WCHAR m_wcKeyName[1024];
    WCHAR m_wcDomain[BUFF_SIZE];
    WCHAR m_wcUser[BUFF_SIZE];

    BSTR Package(int iPos);

    BSTR m_bstrClass;
    BSTR m_bstrPath;
    BSTR m_Property[MSI_KEY_LIST_SIZE];
    BSTR m_Value[MSI_KEY_LIST_SIZE];
    int m_iPropCount;
    int m_iValCount;
    int m_iThreadID;

    IWbemServices *m_pNamespace;
    IWbemObjectSink *m_pHandler;

    bool ParseProgress			(WCHAR *wcMessage, ProgressStruct *ps);
    bool ActionDataProgress		(HRESULT *hr, int iThread);
    bool ActionStartProgress	(HRESULT *hr, int iThread);
    bool CreateProgress			(ProgressStruct *ps, HRESULT *hr, int iThread);

    ProListNode *	GetNode		(int iThread);

private:
    HRESULT CreateClass(CGenericClass **pClass, IWbemContext *pCtx);

#ifdef _EXEC_QUERY_SUPPORT
    //Query Parsing Functions
    WCHAR * GetNextProperty(WCHAR **pwcString, WCHAR wcProp[]);
    WCHAR * GetNextValue(WCHAR **pwcString, WCHAR wcVal[]);
    bool ExpectedToken(WCHAR **pwcString, WCHAR *pwcExpected);
    WCHAR * GetNextToken(WCHAR **pwcString, WCHAR wcToken[]);
    WCHAR * GetStringValue(WCHAR **pwcString, WCHAR wcToken[]);
    bool EOL(WCHAR **pwcString);
#endif // _EXEC_QUERY_SUPPORT

    bool IsInstance();

    ProListNode * InitializeProgress(IWbemObjectSink *pHandler);

    //Package list head
    PackageListNode *m_pPackageHead;

    //Thread List for progress messages
    ProListNode *	m_pHead;

    ProListNode *	RemoveNode	(int iThread);
    int				InsertNode	(ProListNode *pNode);

    //Critical section for event handling and thread ID assignement
    static CRITICAL_SECTION m_cs;

    static CHeap_Exception m_he;

protected:
    ULONG m_cRef;         //Object reference count
};

//Properties
//////////////////
extern const char * pAccesses;
extern const char * pAction;
extern const char * pActionID;
extern const char * pAntecedent;
extern const char * pAppData;
extern const char * pAppID;
extern const char * pArgument;
extern const char * pArguments;
extern const char * pAttribute;
extern const char * pAttributes;
extern const char * pCabinet;
extern const char * pCaption;
extern const char * pCheck;
extern const char * pCheckID;
extern const char * pCLSID;
extern const char * pCommand;
extern const char * pCommandLine;
extern const char * pComponent;
extern const char * pComponentID;
extern const char * pCondition;
extern const char * pContentType;
extern const char * pContext;
extern const char * pCost;
extern const char * pCreationClassName;
extern const char * pDataSource;
extern const char * pDefaultDir;
extern const char * pDefInprocHandler;
extern const char * pDependencies;
extern const char * pDependent;
extern const char * pDescription;
extern const char * pDestination;
extern const char * pDestFolder;
extern const char * pDestName;
extern const char * pDirectory;
extern const char * pDirectoryName;
extern const char * pDirectoryPath;
extern const char * pDirProperty;
extern const char * pDiskID;
extern const char * pDiskPrompt;
extern const char * pDisplay;
extern const char * pDisplayName;
extern const char * pDomain;
extern const char * pDriver;
extern const char * pDriverDescription;
extern const char * pElement;
extern const char * pEntryName;
extern const char * pEntryValue;
extern const char * pEnvironment;
extern const char * pError;
extern const char * pErrorControl;
extern const char * pEvent;
extern const char * pExpression;
extern const char * pExpressionType;
extern const char * pExtension;
extern const char * pFeature;
extern const char * pFeatures;
extern const char * pField;
extern const char * pFile;
extern const char * pFileKey;
extern const char * pFileName;
extern const char * pFileSize;
extern const char * pFileTypeMask;
extern const char * pFontTitle;
extern const char * pGroupComponent;
extern const char * pHotKey;
extern const char * pID;
extern const char * pIdentificationCode;
extern const char * pIdentifyingNumber;
extern const char * pIniFile;
extern const char * pInsertable;
extern const char * pInstallDate;
extern const char * pInstallDate2;
extern const char * pInstallLocation;
extern const char * pInstallMode;
extern const char * pInstallState;
extern const char * pKey;
extern const char * pLanguage;
extern const char * pLastSequence;
extern const char * pLastUse;
extern const char * pLevel;
extern const char * pLibID;
extern const char * pLoadOrderGroup;
extern const char * pLocation;
extern const char * pManufacturer;
extern const char * pMaxDate;
extern const char * pMaxSize;
extern const char * pMaxVersion;
extern const char * pMessage;
extern const char * pMIME;
extern const char * pMinDate;
extern const char * pMinSize;
extern const char * pMinVersion;
extern const char * pName;
extern const char * pNext;
extern const char * pOperator;
extern const char * pOptions;
extern const char * pPackageCache;
extern const char * pParent;
extern const char * pPartComponent;
extern const char * pPassword;
extern const char * pPatch;
extern const char * pPatchID;
extern const char * pPatchSize;
extern const char * pPath;
extern const char * pPermission;
extern const char * pPrior;
extern const char * pProduct;
extern const char * pProductCode;
extern const char * pProductName;
extern const char * pProductVersion;
extern const char * pProgID;
extern const char * pProperty;
extern const char * pQual;
extern const char * pRegistration;
extern const char * pRegistry;
extern const char * pRemoteName;
extern const char * pReserveKey;
extern const char * pReserveLocal;
extern const char * pReserveSource;
extern const char * pResource;
extern const char * pRoot;
extern const char * pSection;
extern const char * pSequence;
extern const char * pServiceType;
extern const char * pSetting;
extern const char * pSetupFile;
extern const char * pShellNew;
extern const char * pShellNewValue;
extern const char * pSignature;
extern const char * pShortcut;
extern const char * pShowCmd;
extern const char * pSoftware;
extern const char * pSoftwareElementID;
extern const char * pSoftwareElementState;
extern const char * pSource;
extern const char * pSourceFolder;
extern const char * pSourceName;
extern const char * pStartMode;
extern const char * pStartName;
extern const char * pStartType;
extern const char * pStatus;
extern const char * pSystem;
extern const char * pSystemCreationClassName;
extern const char * pSystemName;
extern const char * pTable;
extern const char * pTarget;
extern const char * pTargetOperatingSystem;
extern const char * pTranslator;
extern const char * pType;
extern const char * pUpgradeCode;
extern const char * pUser;
extern const char * pValue;
extern const char * pVendor;
extern const char * pVerb;
extern const char * pVersion;
extern const char * pVolumeLabel;
extern const char * pWait;
extern const char * pWkDir;

#endif // !defined(AFX_REQUESTOBJECT_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\selfregmodule.h ===
// SelfRegModule.h: interface for the CSelfRegModule class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SELFREGMODULE_H__75F6BA28_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SELFREGMODULE_H__75F6BA28_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSelfRegModule : public CGenericClass  
{
public:
	CSelfRegModule(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSelfRegModule();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SELFREGMODULE_H__75F6BA28_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\servicecontrol.h ===
// ServiceControl.h: interface for the CServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICECONTROL_H__72CDD5D9_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_SERVICECONTROL_H__72CDD5D9_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CServiceControl : public CGenericClass  
{
public:
	CServiceControl(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CServiceControl();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SERVICECONTROL_H__72CDD5D9_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\selfregmodule.cpp ===
// SelfRegModule.cpp: implementation of the CSelfRegModule class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SelfRegModule.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSelfRegModule::CSelfRegModule(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSelfRegModule::~CSelfRegModule()
{

}

HRESULT CSelfRegModule::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Cost` from SelfReg" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"SelfReg", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pFile, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);
                        PutProperty(m_pObj, pName, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bCheck, m_pRequest, 1, wcProductCode );

                   //====================================================

                        PutProperty(m_pObj, pCost, g_fpMsiRecordGetInteger(hRecord, 2));

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecification.cpp ===
// ServiceSpecification.cpp: implementation of the CServiceSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ServiceSpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceSpecification::CServiceSpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CServiceSpecification::~CServiceSpecification()
{

}

HRESULT CServiceSpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcKey[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcServiceInstall[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bDiskID;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcServiceInstall);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ServiceInstall`, `Component_`, `Name`, `DisplayName`, `ServiceType`, `StartType`, `ErrorControl`, `LoadOrderGroup`, `Dependencies`, `StartName`, `Password` from ServiceInstall" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ServiceInstall`=\'", wcServiceInstall, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceInstall", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        wcscpy(wcKey, wcBuf);
                        PutProperty(m_pObj, pID, wcBuf);

						PutKeyProperty ( m_pObj, pCheckID, wcKey, &bDiskID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDisplayName, wcBuf);
                            PutProperty(m_pObj, pDescription, wcBuf);
                            PutProperty(m_pObj, pCaption, wcBuf);

                            PutProperty(m_pObj, pServiceType, g_fpMsiRecordGetInteger(hRecord, 5));

                            PutProperty(m_pObj, pStartType, g_fpMsiRecordGetInteger(hRecord, 6));
                            
                            PutProperty(m_pObj, pErrorControl, g_fpMsiRecordGetInteger(hRecord, 7));
                            
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 8, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pLoadOrderGroup, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 9, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pDependencies, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 10, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pStartName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 11, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pPassword, wcBuf);

                        //----------------------------------------------------

                            if(bDiskID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\servicecontrol.cpp ===
// ServiceControl.cpp: implementation of the CServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ServiceControl.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceControl::CServiceControl(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CServiceControl::~CServiceControl()
{

}

HRESULT CServiceControl::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView, hRecord;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bID, bProductCode;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"ID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ServiceControl`, `Name`, `Event`, `Arguments`, `Wait` from ServiceControl" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `ServiceControl`=\'", wcName, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceControl", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pID, wcBuf, &bID, m_pRequest);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProductCode, m_pRequest);
                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pName, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pEvent, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pArguments, wcBuf);

                        PutProperty(m_pObj, pWait, g_fpMsiRecordGetInteger(hRecord, 5));
                    //----------------------------------------------------

                        if(bID && bProductCode) bMatch = true;

                        if((atAction != ACTIONTYPE_GET) || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\requestobject.cpp ===
// RequestObject.cpp: implementation of the CRequestObject class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "requestobject.h"
#include <stdio.h>
#include <CRegCls.h>
#include <wininet.h>

//Classes
#include "ApplicationService.h"
#include "Binary.h"
#include "BindImage.h"
#include "ClassInfoAction.h"
#include "CommandLineAccess.h"
#include "Condition.h"
#include "CreateFolder.h"
#include "DirectorySpecification.h"
#include "DuplicateFile.h"
#include "Environment.h"
#include "ExtensionInfoAction.h"
#include "FileSpecification.h"
#include "FontInfoAction.h"
#include "IniFile.h"
#include "LaunchCondition.h"
#include "MIMEInfoAction.h"
#include "MoveFile.h"
#include "ODBCAttribute.h"
#include "ODBCDataSource.h"
#include "ODBCDriver.h"
#include "ODBCSourceAttribute.h"
#include "ODBCTranslator.h"
#include "Patch.h"
#include "PatchPackAge.h"
#include "ProgIDSpecification.h"
#include "Product.h"
#include "Property.h"
#include "PublishComponent.h"
#include "RemoveFile.h"
#include "RemoveIniValue.h"
#include "ReserveCost.h"
#include "SelfRegModule.h"
#include "ServiceControl.h"
#include "ServiceSpecification.h"
#include "ShortcutAction.h"
#include "SoftwareElement.h"
#include "SoftwareElementCondition.h"
#include "SoftwareFeature.h"
#include "TypeLibraryAction.h"
//#include "Upgrade.h"
#include "WriteRegistry.h"

//Associations
#include "ActionCheck.h"
#include "ApplicationCommandLine.h"
#include "CheckCheck.h"
#include "InstalledSoftwareElement.h"
#include "ODBCDataSourceAttribute.h"
#include "ODBCDriverAttribute.h"
#include "ODBCDriverSoftwareElement.h"
#include "PatchFile.h"
#include "ProductResource1.h"
#include "ProductEnvironment.h"
#include "ProductSoftwareFeatures.h"
#include "ServiceSpecificationService.h"
#include "ShortcutSAP.h"
#include "SoftwareElementAction.h"
#include "SoftwareElementCheck.h"
#include "SoftwareElementServiceControl.h"
#include "SoftwareFeatureAction.h"
#include "SoftwareFeatureCondition.h"
#include "SoftwareFeatureParent.h"
#include "SoftwareFeatureSoftwareElements.h"

CRITICAL_SECTION CRequestObject::m_cs;
CHeap_Exception CRequestObject::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

//////////////////////////////////////////////////////////////////////
// event handler for methods
//////////////////////////////////////////////////////////////////////

int WINAPI MyEventHandler ( LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage )
{
	// request object
	CRequestObject* pObj = NULL;
	pObj = reinterpret_cast < CRequestObject* > ( pvContext );

    BSTR bstrMsg	= NULL;

    try
	{
        if ( pObj && pObj->m_iThreadID != THREAD_NO_PROGRESS )
		{
			ProListNode *pNode = NULL;
			
			if ( ( pNode = pObj->GetNode ( pObj->m_iThreadID ) ) != NULL )
			{
				if ( pNode->pSink != NULL)
				{
					//Get the values we need from the MessageType
					UINT uiMsg = iMessageType & 0x0F000000L;

					if(szMessage)
					{
						bstrMsg = SysAllocString(szMessage);
					}
					else
					{
						bstrMsg = SysAllocString(L"");
					}

					HRESULT hr  = WBEM_S_NO_ERROR;
					HRESULT hrProgress = WBEM_STATUS_PROGRESS;
					bool bSuccess = true;

					switch(uiMsg)
					{
						case INSTALLMESSAGE_FATALEXIT:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_ERROR:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_WARNING:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_USER:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_INFO:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_FILESINUSE:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_RESOLVESOURCE:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_OUTOFDISKSPACE:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_ACTIONSTART:
						if(!pObj->ActionStartProgress(&hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_ACTIONDATA:
						if(!pObj->ActionDataProgress(&hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_PROGRESS:
						ProgressStruct ps;
						if(pObj->ParseProgress(bstrMsg, &ps))
						{
							if(!pObj->CreateProgress(&ps, &hr, pObj->m_iThreadID)) bSuccess = false;
						}

						break;

						case INSTALLMESSAGE_INITIALIZE:
						break;

						case INSTALLMESSAGE_TERMINATE:
						break;

						default:
						bSuccess = false;
						break;
					}

					//Send the message
					if(bSuccess)
					{
						pNode->pSink->SetStatus(hrProgress, hr, bstrMsg, NULL);
					}
				}
			}
		}
    }
	catch(...)
	{
    }

	if ( bstrMsg )
	{
		::SysFreeString(bstrMsg);
	}

    return 0;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRequestObject::CRequestObject()
{
    m_cRef = 0;
    m_bstrPath = NULL;
    m_bstrClass = NULL;
    m_pPackageHead = NULL;
    m_hKey = NULL;
}

CRequestObject::~CRequestObject()
{
}

//***************************************************************************
//
// CRequestObject::QueryInterface
// CRequestObject::AddRef
// CRequestObject::Release
//
// Purpose: IUnknown members for CRequestObject object.
//***************************************************************************
/*
STDMETHODIMP CRequestObject::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv = NULL;

    if(riid == IID_IMsiMethodStatusSink)
       *ppv = (IMsiMethodStatusSink *)this;

    if(riid == IID_IUnknown)
       *ppv = (IMsiMethodStatusSink *)this;

    if(NULL != *ppv){

        AddRef();
        return NOERROR;

    }else return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CRequestObject::AddRef(void)
{
    InterlockedIncrement((long *)&m_cRef);

    return m_cRef;
}

STDMETHODIMP_(ULONG) CRequestObject::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

//    if(0L == nNewCount) delete this;
    
    return nNewCount;
}
*/
void CRequestObject::Initialize(IWbemServices *pNamespace)
{
    m_pNamespace = pNamespace;
    m_pHandler = NULL;
    m_bstrClass = NULL;
    m_bstrPath = NULL;
    m_iPropCount = m_iValCount = 0;
    m_iThreadID = THREAD_NO_PROGRESS;
    m_pHead = NULL;
    m_dwCheckKeyPresentStatus = ERROR_SUCCESS;

    for(int i = 0; i < MSI_KEY_LIST_SIZE; i++) m_Property[i] = m_Value[i] = NULL;

    HANDLE hTokenImpersonationHandle;
    DWORD dwStatus;

    if(OpenThreadToken(GetCurrentThread(), (TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY),
        TRUE ,& hTokenImpersonationHandle)){

        dwStatus = GetAccount(hTokenImpersonationHandle, m_wcDomain, m_wcUser );
        
        if(dwStatus == 0)
		{
			if ( wcslen ( m_wcDomain ) + wcslen ( m_wcUser ) + 1 + 1 < BUFF_SIZE )
			{
				wcscpy(m_wcAccount, m_wcDomain);
				wcscat(m_wcAccount, L"\\");
				wcscat(m_wcAccount, m_wcUser);

				WCHAR wcSID[BUFF_SIZE];

				if((dwStatus = GetSid(hTokenImpersonationHandle, wcSID)) == S_OK ){

					CRegistry *pReg = new CRegistry();
					if(!pReg) throw m_he;
                
					//check if SID already present under HKEY_USER ...
					m_dwCheckKeyPresentStatus = pReg->Open(HKEY_USERS, wcSID, KEY_READ) ;
                
					if(m_dwCheckKeyPresentStatus == ERROR_NOT_ENOUGH_MEMORY)
						throw m_he;

					pReg->Close();
					delete pReg;
				}
			}
        }

        CloseHandle(hTokenImpersonationHandle);
    }
}

void CRequestObject::FinalRelease()
{
}

HRESULT CRequestObject::CreateObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath)
        throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass)
                    throw m_he;

                //get the requested object
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_GET);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            
            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::CreateClass(CGenericClass **pClass, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

        //Create the appropriate class
/////////////
// Classes //
/////////////
    if(0 == _wcsicmp(m_bstrClass, L"WIN32_APPLICATIONSERVICE")){
        *pClass = new CApplicationService(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_BINARY")){
        *pClass = new CBinary(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_BINDIMAGEACTION")){
        *pClass = new CBindImage(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CLASSINFOACTION")){
        *pClass = new CClassInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_COMMANDLINEACCESS")){
        *pClass = new CCommandLineAccess(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CONDITION")){
        *pClass = new CCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CREATEFOLDERACTION")){
        *pClass = new CCreateFolder(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_DIRECTORYSPECIFICATION")){
        *pClass = new CDirectorySpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_DUPLICATEFILEACTION")){
        *pClass = new CDuplicateFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ENVIRONMENTSPECIFICATION")){
        *pClass = new CEnvironment(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_EXTENSIONINFOACTION")){
        *pClass = new CExtensionInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_FILESPECIFICATION")){
        *pClass = new CFileSpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_FONTINFOACTION")){
        *pClass = new CFontInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_INIFILESPECIFICATION")){
        *pClass = new CIniFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_LAUNCHCONDITION")){
        *pClass = new CLaunchCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_MIMEINFOACTION")){
        *pClass = new CMIMEInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_MOVEFILEACTION")){
        *pClass = new CMoveFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCATTRIBUTE")){
        *pClass = new CODBCAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDATASOURCESPECIFICATION")){
        *pClass = new CODBCDataSource(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDRIVERSPECIFICATION")){
        *pClass = new CODBCDriver(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCSOURCEATTRIBUTE")){
        *pClass = new CODBCSourceAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCTRANSLATORSPECIFICATION")){
        *pClass = new CODBCTranslator(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PATCH")){
        *pClass = new CPatch(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PATCHPACKAGE")){
        *pClass = new CPatchPackAge(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PROGIDSPECIFICATION")){
        *pClass = new CProgIDSpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCT")){
        *pClass = new CProduct(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PROPERTY")){
        *pClass = new CProperty(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PUBLISHCOMPONENTACTION")){
        *pClass = new CPublishComponent(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_REMOVEFILEACTION")){
        *pClass = new CRemoveFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_REMOVEINIACTION")){
        *pClass = new CRemoveIniValue(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_RESERVECOST")){
        *pClass = new CReserveCost(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SELFREGMODULEACTION")){
        *pClass = new CSelfRegModule(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SERVICECONTROL")){
        *pClass = new CServiceControl(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SERVICESPECIFICATION")){
        *pClass = new CServiceSpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SHORTCUTACTION")){
        *pClass = new CShortcutAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENT")){
        *pClass = new CSoftwareElement(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTCONDITION")){
        *pClass = new CSoftwareElementCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURE")){
        *pClass = new CSoftwareFeature(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_TYPELIBRARYACTION")){
        *pClass = new CTypeLibraryAction(this, m_pNamespace, pCtx);

//  }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_UPGRADE")){
//      *pClass = new CUpgrade(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_REGISTRYACTION")){
        *pClass = new CRegistryAction(this, m_pNamespace, pCtx);

//////////////////
// Associations //
//////////////////

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ACTIONCHECK")){
        *pClass = new CActionCheck(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_APPLICATIONCOMMANDLINE")){
        *pClass = new CApplicationCommandLine(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CHECKCHECK")){
        *pClass = new CCheckCheck(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_INSTALLEDSOFTWAREELEMENT")){
        *pClass = new CInstalledSoftwareElement(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDATASOURCEATTRIBUTE")){
        *pClass = new CODBCDataSourceAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDRIVERATTRIBUTE")){
        *pClass = new CODBCDriverAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDRIVERSOFTWAREELEMENT")){
        *pClass = new CODBCDriverSoftwareElement(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PATCHFILE")){
        *pClass = new CPatchFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCTCHECK")){
        *pClass = new CProductEnvironment(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCTRESOURCE")){
        *pClass = new CProductResource(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCTSOFTWAREFEATURES")){
        *pClass = new CProductSoftwareFeatures(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SERVICESPECIFICATIONSERVICE")){
        *pClass = new CServiceSpecificationService(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SHORTCUTSAP")){
        *pClass = new CShortcutSAP(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTACTION")){
        *pClass = new CSoftwareElementAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTCHECK")){
        *pClass = new CSoftwareElementCheck(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTRESOURCE")){
        *pClass = new CSoftwareElementServiceControl(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATUREACTION")){
        *pClass = new CSoftwareFeatureAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURECHECK")){
        *pClass = new CSoftwareFeatureCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATUREPARENT")){
        *pClass = new CSoftwareFeatureParent(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURESOFTWAREELEMENTS")){
        *pClass = new CSoftwareFeatureSofwareElements(this, m_pNamespace, pCtx);
    }else return WBEM_E_NOT_FOUND;

    if(!(*pClass)) throw m_he;

    return hr;
};

HRESULT CRequestObject::CreateObjectEnum(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //Enumerate the objects
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_ENUM);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::PutObject(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    return WBEM_E_NOT_SUPPORTED;
}

HRESULT CRequestObject::ExecMethod(BSTR bstrPath, BSTR bstrMethod, IWbemClassObject *pInParams,
                   IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
//  WCHAR wcTmp[BUFF_SIZE];

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    //Initialize Eventing system
    if(!InitializeProgress(pHandler)) return WBEM_E_FAILED;

    if(ParsePath(bstrPath)){

        if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCT")){

            CProduct *pClass = new CProduct(this, m_pNamespace, pCtx);
            if(!pClass) throw m_he;

        //Static Methods
            if(0 == _wcsicmp(bstrMethod, L"ADMIN"))

                if(!IsInstance()){

                    try{

                        hr = pClass->Admin(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }

                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"ADVERTISE"))

                if(!IsInstance()){

                    try{

                        hr = pClass->Advertise(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }

                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"INSTALL"))

                if(!IsInstance()){

                    try{

                        hr = pClass->Install(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

        //Non-Static Methods
            else if(0 == _wcsicmp(bstrMethod, L"CONFIGURE"))

                if(IsInstance()){

                    try{

                        hr = pClass->Configure(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"REINSTALL"))

                if(IsInstance()){

                    try{

                        hr = pClass->Reinstall(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"UNINSTALL"))

                if(IsInstance()){

                    try{

                        hr = pClass->Uninstall(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"UPGRADE"))

                if(IsInstance()){

                    try{

                        hr = pClass->Upgrade(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else hr = WBEM_E_NOT_SUPPORTED;

            pClass->CleanUp();
            delete pClass;
        
        }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURE")){

            CSoftwareFeature *pClass = new CSoftwareFeature(this, m_pNamespace, pCtx);
            if(!pClass) throw m_he;

            if(0 == _wcsicmp(bstrMethod, L"CONFIGURE"))

                if(IsInstance()){

                    try{

                        hr = pClass->Configure(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"REINSTALL"))

                if(IsInstance()){

                    try{

                        hr = pClass->Reinstall(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else hr = WBEM_E_NOT_SUPPORTED;

            pClass->CleanUp();
            delete pClass;

        }else hr = WBEM_E_NOT_SUPPORTED;

    }else
        return WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::DeleteObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
//  WCHAR wcTmp[BUFF_SIZE];

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    //Initialize Eventing system
    if(!InitializeProgress(pHandler)) return WBEM_E_FAILED;

    if(ParsePath(bstrPath)){

        if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCT")){

            CProduct *pClass = new CProduct(this, m_pNamespace, pCtx);
            if(!pClass) throw m_he;

            if(IsInstance()){

                try{

                    hr = pClass->Uninstall(this, NULL, pHandler, pCtx);

                }catch(...){

                    pClass->CleanUp();
                    delete pClass;
                    throw;
                }
            
            }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            pClass->CleanUp();
            delete pClass;

        }else hr = WBEM_E_NOT_SUPPORTED;

    }else hr = WBEM_E_FAILED;

    return hr;
}

#ifdef _EXEC_QUERY_SUPPORT

HRESULT CRequestObject::ExecQuery(BSTR bstrQuery, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    if(ParseQuery(bstrQuery)){
    
        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //Enumerate the objects
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_QUERY);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }
    
    }else
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    return hr;
}

bool CRequestObject::ParseQuery(BSTR bstrQuery)
{
    LPWSTR wcTest = NULL;

	try
	{
		if ( ( wcTest = new WCHAR [ ::SysStringLen ( bstrQuery ) + 1 ] ) != NULL )
		{
			wcscpy ( wcTest, bstrQuery );
		}
		else
		{
			throw m_he;
		}
	}
	catch ( ... )
	{
		if ( wcTest )
		{
			delete [] wcTest;
			wcTest = NULL;
		}

		throw;
	}

    WCHAR *pwcTest = wcTest;
    WCHAR wcProp[BUFF_SIZE];
    WCHAR wcClass[BUFF_SIZE];
    WCHAR wcTmp[BUFF_SIZE];

	bool bResult = false;

    if ( ExpectedToken ( &pwcTest, L"SELECT" ) )
	{
		//Get the requested property list
		GetNextToken(&pwcTest, wcProp);
		if(*wcProp != L'*'){

			while(ExpectedToken(&pwcTest, L",")){
				//not doing anything here yet
				GetNextToken(&pwcTest, wcProp);
			}
		}

		if ( ExpectedToken ( &pwcTest, L"FROM" ) )
		{
			//Get the class name
			if ( GetNextToken ( &pwcTest, wcClass ) != NULL )
			{
				m_bstrClass = SysAllocString(wcClass);

				if ( !EOL ( &pwcTest ) )
				{
					if ( ExpectedToken ( &pwcTest, L"WHERE" ) )
					{
						m_iPropCount = -1;
						int iParens = 0;

						bool bContinue = true;

						//Get the "where" clause
						while ( bContinue && !EOL ( &pwcTest ) )
						{
							GetNextToken(&pwcTest, wcTmp);

							if(_wcsicmp(wcTmp, L"(") == 0){

								iParens++;

							}else if(_wcsicmp(wcTmp, L")") == 0){

								iParens--;

							}else if(!((_wcsicmp(wcTmp, L"or") == 0) || (_wcsicmp(wcTmp, L"and") == 0))){

								//if we have "or" or "and" skip over it... (treat all as or)

								m_Property[++m_iPropCount] = SysAllocString(wcTmp);

								//Syntax checking
								if ( ExpectedToken ( &pwcTest, L"=" ) )
								{
									if(wcscmp(GetNextToken(&pwcTest, wcTmp), L"\"") == 0){

										//Deal with quoted strings
										m_Value[m_iPropCount] = SysAllocString(GetStringValue(&pwcTest, wcTmp));

										if ( !ExpectedToken ( &pwcTest, L"\"" ) )
										{
											bContinue = false;
											bResult = false;
										}

									}else m_Value[m_iPropCount] = SysAllocString(wcTmp);

									m_iValCount++;
								}
								else
								{
									bContinue = false;
									bResult = false;
								}
							}
						}

						m_iPropCount++;

						if(iParens == 0)
						{
							bResult = true;
						}
					}
				}
				else
				{
					bResult = true;
				}
			}
		}
	}

	if ( wcTest )
	{
		delete [] wcTest;
		wcTest = NULL;
	}

    return bResult;
}

WCHAR * CRequestObject::GetStringValue(WCHAR **pwcString, WCHAR wcToken[])
{
    //eat white space
    while(**pwcString == L' '){ (*pwcString)++; }

    wcscpy(wcToken, *pwcString);
    WCHAR *pwcStart = wcToken;
    WCHAR *pwcToken = wcToken;
    WCHAR *pwcPrev;

    //deal with eol
    if(*pwcToken == NULL) return NULL;

    //deal with strings
    while((*pwcToken != NULL) && ((*pwcToken != L'\"') || (*pwcPrev == L'\\'))){
        
        if((*pwcToken == L'\"') && (*pwcPrev == L'\\')){

            WCHAR *pwcTmp = pwcPrev;

            while(*pwcPrev){

                *pwcPrev = *pwcToken;
                pwcPrev = (pwcToken++);
            }

            pwcToken = pwcTmp;
        }

        pwcPrev = (pwcToken++);
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

bool CRequestObject::ExpectedToken(WCHAR **pwcString, WCHAR *pwcExpected)
{
    WCHAR wcTmp[BUFF_SIZE];

    GetNextToken(pwcString, wcTmp);

    if(_wcsicmp(wcTmp, pwcExpected) == 0)   return true;
    else return false;
}

WCHAR *  CRequestObject::GetNextProperty(WCHAR **pwcString, WCHAR wcProp[])
{
    //eat white space
    while(**pwcString == L' '){ (*pwcString)++; }

    wcscpy(wcProp, *pwcString);
    WCHAR *pwcStart = wcProp;
    WCHAR *pwcToken = wcProp;

    //deal with strings
    while(*pwcToken != L'='){
        pwcToken++;
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

WCHAR *  CRequestObject::GetNextValue(WCHAR **pwcString, WCHAR wcVal[])
{
    wcscpy(wcVal, *pwcString);
    WCHAR *pwcStart = wcVal;
    WCHAR *pwcToken = wcVal;
    WCHAR *pwcPrev;

    //deal with strings
    while((*pwcToken != L' ') || ((*pwcToken != L'\"') || (*pwcPrev == L'\\'))){
        pwcPrev = (pwcToken++);
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

bool CRequestObject::EOL(WCHAR **pwcString)
{
    while(**pwcString == L' ') (*pwcString)++;

    if(wcscmp(*pwcString, L"") == 0)    return true;
    else return false;
}

WCHAR * CRequestObject::GetNextToken(WCHAR **pwcString, WCHAR wcToken[])
{
    //eat white space
    while(**pwcString == L' '){ (*pwcString)++; }

    wcscpy(wcToken, *pwcString);
    WCHAR *pwcStart = wcToken;
    WCHAR *pwcToken = wcToken;
    WCHAR *pwcPrev;

    //deal with special chars
    if((*pwcToken == L'(') || (*pwcToken == L')') || (*pwcToken == L',') || (*pwcToken == L'=') || (*pwcToken == L'"')){
        *(++pwcToken) = NULL;
        (*pwcString)++;
        return pwcStart;
    }

    //deal with eol
    if(*pwcToken == NULL) return NULL;

    //deal with strings
    while((*pwcToken != NULL) && (*pwcToken != L' ') && (*pwcToken != L',') &&
        (*pwcToken != L'=') && ((*pwcToken != L'\"') || (*pwcPrev == L'\\'))){
        
        pwcPrev = (pwcToken++);
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

#endif //_EXEC_QUERY_SUPPORT

bool CRequestObject::ParsePath(BSTR bstrPath)
{
    if(wcslen(bstrPath) < 1) return false;

    LPWSTR wcTest = NULL;

	try
	{
		if ( ( wcTest = new WCHAR [ ::SysStringLen ( bstrPath ) + 1 ] ) != NULL )
		{
			wcscpy ( wcTest, bstrPath );
		}
		else
		{
			throw m_he;
		}
	}
	catch ( ... )
	{
		if ( wcTest )
		{
			delete [] wcTest;
			wcTest = NULL;
		}

		throw;
	}

    WCHAR *pwcTest = NULL;
    WCHAR *pwcClassStart = wcTest;
    WCHAR *pwcNamespace = NULL;
    WCHAR *pwcStart = NULL;
    WCHAR *pwcStrip = NULL;
    WCHAR wcPrevious = NULL;
    int iNumQuotes = 0;
    bool bClass = false;
    bool bDoubles = false;

	try
	{
		//Main Parsing Loop
		for(pwcTest = wcTest; *pwcTest; pwcTest++){

			if((*pwcTest == L'\\') && !bClass){

				for(pwcNamespace = pwcTest; *pwcNamespace != L':'; pwcNamespace++){}
				pwcClassStart = pwcNamespace + 1;
				pwcTest = pwcNamespace;

			}else if(*pwcTest == L'.'){

				if(iNumQuotes == 0){

					// issolate the class name.
					*pwcTest = NULL;
					if(m_bstrClass){

						SysFreeString(m_bstrClass);
						m_bstrClass = NULL;
					}
					m_bstrClass = SysAllocString(pwcClassStart);
					if(!m_bstrClass) throw m_he;

					bClass = true;
					pwcStart = (pwcTest + 1);
				}

			}else if(*pwcTest == L'='){

				if(iNumQuotes == 0){

					if(!bClass){

						// issolate the class name.
						*pwcTest = NULL;
						if(m_bstrClass){

							SysFreeString(m_bstrClass);
							m_bstrClass = NULL;
						}
						m_bstrClass = SysAllocString(pwcClassStart);
						if(!m_bstrClass) throw m_he;

						bClass = true;
						pwcStart = (pwcTest + 1);
            
					}else{

						// issolate the property name.
						*pwcTest = NULL;
						if(pwcStart != NULL){

							m_Property[m_iPropCount] = SysAllocString(pwcStart);
							if(!m_Property[m_iPropCount++]) throw m_he;
							pwcStart = (pwcTest + 1);

						}else pwcStart = (pwcTest + 1);
					}
				}
			}else if(*pwcTest == L','){

				if(iNumQuotes != 1){

					// issolate the property value.
					*pwcTest = NULL;
					if(pwcStart != NULL){

						m_Value[m_iValCount] = SysAllocString(pwcStart);
						if(!m_Value[m_iValCount++]) throw m_he;
						pwcStart = (pwcTest + 1);

					}else return false;
				}

			}else if(*pwcTest == L'\"'){

				if(wcPrevious != L'\\'){

					// deal with quotes in path.
					iNumQuotes++;
					if(iNumQuotes == 1) pwcStart = (pwcTest + 1);
					else if(iNumQuotes == 2){

						*pwcTest = NULL;
						iNumQuotes = 0;
					}

				}else if(iNumQuotes == 1){

					//deal with embedded quotes
					for(pwcStrip = (--pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

					*pwcStrip = NULL;
				}

			}else if((*pwcTest == L'\\') && (wcPrevious == L'\\') && bClass && !bDoubles){

				for(pwcStrip = (--pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

				*pwcStrip = NULL;
			}

	#ifdef _STRIP_ESCAPED_CHARS
			else if(*pwcTest == L'%'){

				//deal with escaped URL characters
				if(*(pwcTest + 1) == L'0'){

					if(*(pwcTest + 2) == L'7'){
						//bell
						*pwcTest = L'\\';
						*(++pwcTest) = L'a';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if(*(pwcTest + 2) == L'8'){
						//backspace
						*pwcTest = L'\\';
						*(++pwcTest) = L'b';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if(*(pwcTest + 2) == L'9'){
						//horizontal tab
						*pwcTest = L'\\';
						*(++pwcTest) = L't';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'A') || (*(pwcTest + 2) == L'a')){
						//newline
						*pwcTest = L'\\';
						*(++pwcTest) = L'n';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'B') || (*(pwcTest + 2) == L'b')){
						//vertical tab
						*pwcTest = L'\\';
						*(++pwcTest) = L'v';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'C') || (*(pwcTest + 2) == L'c')){
						//formfeed
						*pwcTest = L'\\';
						*(++pwcTest) = L'f';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'D') || (*(pwcTest + 2) == L'd')){
						//carriage return
						*pwcTest = L'\\';
						*(++pwcTest) = L'r';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else return false;

				}else if(*(pwcTest + 1) == L'1'){

					return false;

				}else if(*(pwcTest + 1) == L'2'){

					if(*(pwcTest + 2) == L'0'){

						//space
						*pwcTest++ = L' ';

						for(int ip = 0; ip < 2; ip++)
							for(pwcStrip = (pwcTest); *pwcStrip; pwcStrip++)
								*pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else return false;
				}
			}
	#endif //_STRIP_ESCAPED_CHARS

			if((wcPrevious == *pwcTest) && !bDoubles) bDoubles = true;
			else bDoubles = false;

			wcPrevious = *pwcTest;
		}

		// if we still have values to add, do so now
		if(pwcStart != NULL){
			m_Value[m_iValCount] = SysAllocString(pwcStart);
			if(!m_Value[m_iValCount++]) throw m_he;

		}else if((m_iPropCount < 1) && (m_iValCount < 1)){

			if(m_bstrClass){

				SysFreeString(m_bstrClass);
				m_bstrClass = NULL;
			}
			m_bstrClass = SysAllocString(pwcClassStart);
			if(!m_bstrClass) throw m_he;
		}

		if(iNumQuotes != 0) return false;

		if(m_iValCount != m_iPropCount){
			if(m_iValCount > m_iPropCount){ if(m_iValCount != 1) return false;  }
			else return false;
		}
	}
	catch ( ... )
	{
		if ( wcTest )
		{
			delete [] wcTest;
			wcTest = NULL;
		}

		throw;
	}

	if ( wcTest )
	{
		delete [] wcTest;
		wcTest = NULL;
	}

    if(!m_bstrClass) return false;

    return true;
}

HRESULT CRequestObject::InitializeList(bool bGetList)
{
    int i = 0;
    WCHAR wcGUIDBuf[39];
    UINT uiStatus;
    bool bHaveItems = false;
    PackageListNode *pLast = NULL;

    try
	{
        if(bGetList)
		{
            m_pPackageHead = new PackageListNode();
            if(!m_pPackageHead) throw m_he;

            PackageListNode *pPos = m_pPackageHead;

            try
			{
                if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
                    LoadHive();
                }

                while((uiStatus = g_fpMsiEnumProductsW(i++, wcGUIDBuf)) != ERROR_NO_MORE_ITEMS)
				{
                    if(uiStatus != S_OK)
					{
						throw ConvertError(uiStatus);
					}

                    bHaveItems = true;

					// ok ( products return string representation of GUID )
                    wcscpy(pPos->wcCode, wcGUIDBuf);
                    pLast = pPos;

                    pPos = pPos->pNext = new PackageListNode();
                    if(!pPos)
					{
						throw m_he;
					}
                }
            }
			catch(...)
			{
                //remove the key if it wasn't there b4....
                if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
                    UnloadHive();
                }

				if ( pPos != m_pPackageHead )
				{
					delete pPos;
					pPos = NULL;
				}

                throw;
            }

            //remove the key if it wasn't there b4....
            if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
                UnloadHive();
            }

            delete pPos;
			pPos = NULL;

            if( !bHaveItems )
			{
				m_pPackageHead = NULL;
				return WBEM_S_NO_MORE_DATA;
			}
			else
			{
				if(pLast)
				{
					pLast->pNext = NULL;
				}
				else
				{
					return WBEM_E_FAILED;
				}
			}
        }
		else
		{
			m_pPackageHead = NULL;
		}
    }
	catch(HRESULT e_hr)
	{
        if(pLast)
		{
			pLast->pNext = NULL;
		}

        return e_hr;
    }
	catch(...)
	{
        if(pLast)
		{
			pLast->pNext = NULL;
		}

        throw;
    }

    return WBEM_S_NO_ERROR;
}

bool CRequestObject::DestroyList()
{
    PackageListNode *pPos = m_pPackageHead;
    PackageListNode *pLast;

    while(pPos){

        pLast = pPos;
        pPos = pPos->pNext;
        delete pLast;
    }

    m_pPackageHead = NULL;

    return true;
}

WCHAR * CRequestObject::Package(int iPos)
{
    PackageListNode *pPos = m_pPackageHead;

    while(iPos-- > 0){

        if(!pPos) return NULL;

        pPos = pPos->pNext;
    }

    if(!pPos) return NULL;
    else return pPos->wcCode;
}

bool CRequestObject::Cleanup()
{
    //Let's destroy our list and clear up some space
    if(m_bstrClass != NULL) SysFreeString(m_bstrClass);
    if(m_bstrPath != NULL) SysFreeString(m_bstrPath);

    for(int i = 0; i < MSI_KEY_LIST_SIZE; i++){

        if(m_Property[i] != NULL) SysFreeString(m_Property[i]);
        if(m_Value[i] != NULL) SysFreeString(m_Value[i]);
    }

    DestroyList();

    if(m_iThreadID != THREAD_NO_PROGRESS){

        ProListNode * pNode = RemoveNode(m_iThreadID);
        delete pNode;
    }

    return true;
}

bool CRequestObject::IsInstance()
{
    if((m_iPropCount > 0) || (m_iValCount > 0)) return true;
    return false;
}

ProListNode * CRequestObject::InitializeProgress(IWbemObjectSink *pHandler)
{
	try
	{
		if(!m_pHead)
		{
			m_pHead = new ProListNode();
			if(!m_pHead) throw m_he;

			m_pHead->pNext = NULL;
			m_pHead->pSink = NULL;
			m_pHead->iThread = 0;
			m_pHead->wTotal = m_pHead->wComplete = 0;
			m_pHead->lTotal = m_pHead->lComplete = m_pHead->lActionData = 0;
		}
	}
	catch(...)
	{
		if ( m_pHead )
		{
			delete m_pHead;
			m_pHead = NULL;
		}

		throw;
	}

    ProListNode *pNode = new ProListNode;
    if(!pNode) throw m_he;

    pNode->pNext = NULL;
    pNode->wTotal = pNode->wComplete = 0;
    pNode->lTotal = pNode->lComplete = pNode->lActionData = 0;
    pNode->pSink = pHandler;

    try
	{
        m_iThreadID = InsertNode(pNode);
    }
	catch(...)
	{
        throw;
    }

    if(m_iThreadID == THREAD_NO_PROGRESS)
	{
    	delete pNode;
		pNode = NULL;
	}

    return pNode;
}

bool CRequestObject::ParseProgress(WCHAR *wcMessage, ProgressStruct *ps)
{
    WCHAR *wcp = wcMessage;
    WCHAR *wcpStart = wcMessage;
    WCHAR *wcpVal;

    while(*wcp){

        if(*wcp == L':'){

            *wcp++ = NULL;
            wcpVal = wcp;
            while(*wcp == ' ') wcp++;
            while(*wcp && (*wcp != ' ')) wcp++;
            *wcp = NULL;

            switch(_wtoi(wcpStart)){

            case 1:
                ps->field1 = _wtoi(wcpVal);
                break;

            case 2:
                ps->field2 = _wtoi(wcpVal);
                break;

            case 3:
                ps->field3 = _wtoi(wcpVal);
                break;

            case 4:
                ps->field4 = _wtoi(wcpVal);
                break;

            default:
                return false;
            }

            wcpStart = (wcp + 1);
        }

        wcp++;
    }
    
    return true;
}

bool CRequestObject::ActionDataProgress(HRESULT *hr, int iThread)
{
    ProListNode *pNode = GetNode(iThread);

	if ( pNode )
	{
		//add the actiondata increment
		if((pNode->lTotal != 0) && (pNode->lActionData != 0)){

			pNode->lComplete += pNode->lActionData;
			pNode->wComplete = (WORD)((10000 * pNode->lComplete) / pNode->lTotal);
		}

		*hr = (pNode->wTotal << 16) + pNode->wComplete; 
		return true;
	}
	else
	{
		*hr = WBEM_E_UNEXPECTED; 
		return false;
	}
}

bool CRequestObject::ActionStartProgress(HRESULT *hr, int iThread)
{
    ProListNode *pNode = GetNode(iThread);

	if ( pNode )
	{
		//reset the actiondata increment
		pNode->lActionData = 0;

		*hr = (pNode->wTotal << 16) + pNode->wComplete; 
		return true;
	}
	else
	{
		*hr = WBEM_E_UNEXPECTED; 
		return false;
	}
}

bool CRequestObject::CreateProgress(ProgressStruct *ps, HRESULT *hr, int iThread)
{
    bool bResult = true;
    ProListNode *pNode = GetNode(iThread);

    //parse the progress information we get from MSI
    if(ps){

        switch(ps->field1){

        //1:0 2:x 3:x 4:x
        case 0:
			if ( pNode )
			{
				pNode->wTotal = 10000;
				pNode->lTotal = ps->field2;
				pNode->wComplete = 0;
				pNode->lComplete = 0;
			}

            break;

        //1:1 2:x 3:x 4:x
        case 1:

            //1:1 2:x 3:1 4:x
            if(ps->field3 == 1)
			{
				if ( pNode )
				{
					pNode->lActionData = ps->field2;
				}
			}
            break;

        //1:2 2:x 3:x 4:x
        case 2:
			if ( pNode )
			{
				pNode->lComplete += ps->field2;
				if(pNode->lTotal != 0)
				{
					pNode->wComplete = (WORD)((10000 * pNode->lComplete)/pNode->lTotal);
				}
			}
            break;

        //1:3 2:x 3:x 4:x
        case 3:
			if ( pNode )
			{
				pNode->lTotal += ps->field2;
				if(pNode->lTotal != 0)
				{
					pNode->wComplete = (WORD)((10000 * pNode->lComplete)/pNode->lTotal);
				}
			}
            break;


        default:
            bResult = false;
            break;
        }
    }

	if ( pNode )
	{
		*hr = (pNode->wTotal << 16) + pNode->wComplete; 
	}
	else
	{
		*hr = WBEM_E_UNEXPECTED;
		bResult = false;
	}

    return bResult;
}

ProListNode * CRequestObject::GetNode(int iThread)
{
    //initial sanity code
    if(!m_pHead) return NULL;

    ProListNode *ptr = m_pHead;

    while( ptr && (ptr->pNext) && (ptr->iThread < iThread) )
	{
		ptr = ptr->pNext;
	}

    if( ptr && ptr->iThread == iThread )
	{
		return ptr;
	}
    else
	{
		return NULL;
	}
}

// Note - does not delete, simply removes from list
ProListNode * CRequestObject::RemoveNode(int iThread)
{
	ProListNode *ptr = m_pHead;
	if ( ptr != NULL )
	{
		while((ptr->pNext) && (ptr->pNext->iThread < iThread)) {ptr = ptr->pNext;}

		if(ptr->pNext){

			if(ptr->pNext->iThread == iThread){

			ProListNode *pTmp = ptr->pNext;
			ptr->pNext = ptr->pNext->pNext;
			return pTmp;

			}else return NULL;

		}else return NULL;
	}

	return NULL;
}

int CRequestObject::InsertNode(ProListNode *pNode)
{
    int iID = 0;
    ProListNode *ptr = m_pHead;

    while(ptr->pNext){
        if(ptr->iThread > iID){
            pNode->iThread = iID;
            
            //If it's already here, fail
            if((ptr->pNext) && (ptr->pNext->iThread == pNode->iThread)) return THREAD_NO_PROGRESS;

            pNode->pNext = ptr->pNext;
            ptr->pNext = pNode;

            return iID;
        }
        iID++;
    }
    pNode->iThread = ++iID;

    //If it's already here, fail
    if((ptr->pNext) && (ptr->pNext->iThread == pNode->iThread)) return THREAD_NO_PROGRESS;

    pNode->pNext = ptr->pNext;
    ptr->pNext = pNode;

    return iID;
}

DWORD CRequestObject::GetAccount(HANDLE TokenHandle, WCHAR *wcDomain, WCHAR *wcUser)
{
    DWORD dwStatus = S_OK;

    TOKEN_USER *tTokenUser = NULL;
    DWORD dwReturnLength = 0;
    TOKEN_INFORMATION_CLASS tTokenInformationClass = TokenUser;

    if(!GetTokenInformation(TokenHandle, tTokenInformationClass, NULL, 0, &dwReturnLength) &&
        GetLastError () == ERROR_INSUFFICIENT_BUFFER){

        tTokenUser = (TOKEN_USER*) new UCHAR[dwReturnLength];

        if(tTokenUser){

            try{

                if(GetTokenInformation(TokenHandle, tTokenInformationClass,
                    (void *)tTokenUser, dwReturnLength, &dwReturnLength)){

                    DWORD dwUserSize = BUFF_SIZE;
                    DWORD dwDomainSize = BUFF_SIZE;
                    SID_NAME_USE Use;

                    if(!LookupAccountSidW(NULL, tTokenUser->User.Sid, wcUser, &dwUserSize,
                        wcDomain, &dwDomainSize, &Use)){

                        dwStatus = GetLastError();
                    }

                }else dwStatus = GetLastError();


            }catch(...){

                delete [] (UCHAR *)tTokenUser;
                throw;
            }

            delete [] (UCHAR *)tTokenUser;

        }else{

            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }else dwStatus = GetLastError();

    return dwStatus ;
}

DWORD CRequestObject::GetSid(HANDLE TokenHandle, WCHAR *wcSID, DWORD dwSID)
{
    DWORD dwStatus = S_OK ;

    TOKEN_USER *tTokenUser = NULL ;
    DWORD dwReturnLength = 0 ;
    TOKEN_INFORMATION_CLASS tTokenInformationClass = TokenUser ;

    if(!GetTokenInformation(TokenHandle, tTokenInformationClass, NULL, 0, &dwReturnLength) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER){

        tTokenUser = (TOKEN_USER *) new UCHAR[dwReturnLength] ;
        
        if(TokenUser){

            try{

                if(GetTokenInformation(TokenHandle, tTokenInformationClass, (void *)tTokenUser,
                    dwReturnLength, &dwReturnLength)){

                    // Initialize m_strSid - human readable form of our SID
                    SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority(tTokenUser->User.Sid);
                    
                    // We assume that only last byte is used (authorities between 0 and 15).
                    // Correct this if needed.
//                  ASSERT(psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3]
//                      == psia->Value[4] == 0);
                    DWORD dwTopAuthority = psia->Value[5];

                    LPWSTR bstrtTempSid = NULL;

					try
					{
						if ( ( bstrtTempSid = new WCHAR [ BUFF_SIZE ] ) == NULL )
						{
							throw m_he;
						}
					}
					catch ( ... )
					{
						if ( bstrtTempSid )
						{
							delete [] bstrtTempSid;
							bstrtTempSid = NULL;
						}

						throw;
					}

                    wcscpy(bstrtTempSid, L"S-1-");

                    WCHAR wstrAuth[32] = { L'\0' };
                    _itow(dwTopAuthority, wstrAuth, 10);

                    wcscat(bstrtTempSid, wstrAuth);
                    int iSubAuthorityCount = *(GetSidSubAuthorityCount(tTokenUser->User.Sid));

					DWORD dwTempSidCur = BUFF_SIZE;
					DWORD dwTempSid = 0L;
					dwTempSid = wcslen ( bstrtTempSid );

                    for(int i = 0; i < iSubAuthorityCount; i++){

                        DWORD dwSubAuthority = *(GetSidSubAuthority( tTokenUser->User.Sid, i ));

						wstrAuth[ 0 ] = L'\0';
                        _itow(dwSubAuthority, wstrAuth,10);

						DWORD dwAuth = 0L;
						dwAuth = wcslen ( wstrAuth );

						if ( dwTempSid + dwAuth + 1 + 1 < dwTempSidCur )
						{
							wcscat(bstrtTempSid, L"-");
							wcscat(bstrtTempSid, wstrAuth);

							dwTempSid = dwTempSid + dwAuth + 1;
						}
						else
						{
							LPWSTR wsz = NULL;

							try
							{
								if ( ( wsz = new WCHAR [ ( dwTempSid + dwAuth + 1 ) * 2 + 1 ] ) != NULL )
								{
									wcscpy ( wsz, bstrtTempSid );
									wcscat ( wsz, L"-" );
									wcscat ( wsz, wstrAuth );

									dwTempSid = wcslen ( wsz );
									dwTempSidCur = dwTempSid * 2;
								}
								else
								{
									throw m_he;
								}

								if ( bstrtTempSid )
								{
									delete [] bstrtTempSid;
									bstrtTempSid = NULL;
								}

								bstrtTempSid = wsz;
							}
							catch ( ... )
							{
								if ( wsz )
								{
									delete [] wsz;
									wsz = NULL;
								}

								if ( bstrtTempSid )
								{
									delete [] bstrtTempSid;
									bstrtTempSid = NULL;
								}

								throw;
							}
						}
                    }

					if ( wcslen ( bstrtTempSid ) + 1 < dwSID )
					{
                        wcscpy(wcSID, bstrtTempSid);
					}
					else
					{
						dwStatus = ERROR_OUTOFMEMORY;
					}

					if ( bstrtTempSid )
					{
						delete [] bstrtTempSid;
						bstrtTempSid = NULL;
					}

                }else dwStatus = GetLastError();

            }catch(...){

                delete [] (UCHAR *)tTokenUser;

                throw ;         
            }

            delete [] (UCHAR *)tTokenUser;

        }else throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    }else dwStatus = GetLastError();

    return dwStatus ;
}


DWORD CRequestObject::LoadHive(/*LPWSTR pszUserName, LPWSTR pszKeyName*/)
{
    DWORD i, dwSIDSize, dwDomainNameSize, dwSubAuthorities ;
	char SIDBuffer [ _MAX_PATH ];
    WCHAR szDomainName[_MAX_PATH], szSID[_MAX_PATH], szTemp[_MAX_PATH];
    SID *pSID = (SID *) SIDBuffer ;
    PSID_IDENTIFIER_AUTHORITY pSIA ;
    SID_NAME_USE AccountType ;
    CRegistry Reg;

	DWORD dwRetCode = ERROR_INVALID_PARAMETER;

    // Set the necessary privs
    //========================

	if ( ( dwRetCode = AcquirePrivilege() ) == ERROR_SUCCESS )
	{
		// Look up the user's account info
		//================================
		dwSIDSize = _MAX_PATH * sizeof ( char ) ;
		dwDomainNameSize = _MAX_PATH * sizeof ( WCHAR ) ;

		BOOL bLookup = FALSE;
		bLookup = LookupAccountNameW	(	NULL,
											m_wcAccount,
											pSID,
											&dwSIDSize, 
											szDomainName,
											&dwDomainNameSize,
											&AccountType
										);

		if(bLookup)
		{
			// Translate the SID into text (a la PSS article Q131320)
			//=======================================================

			pSIA = GetSidIdentifierAuthority(pSID) ;
			dwSubAuthorities = *GetSidSubAuthorityCount(pSID) ;
			dwSIDSize = swprintf(szSID, _T("S-%lu-"), (DWORD) SID_REVISION) ;

			if((pSIA->Value[0] != 0) || (pSIA->Value[1] != 0)){

				dwSIDSize += swprintf(szSID + wcslen(szSID), L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
									 (USHORT) pSIA->Value[0],
									 (USHORT) pSIA->Value[1],
									 (USHORT) pSIA->Value[2],
									 (USHORT) pSIA->Value[3],
									 (USHORT) pSIA->Value[4],
									 (USHORT) pSIA->Value[5]) ;
			}else{

				dwSIDSize += swprintf(szSID + wcslen(szSID), L"%lu",
									 (ULONG)(pSIA->Value[5]      ) +
									 (ULONG)(pSIA->Value[4] <<  8) +
									 (ULONG)(pSIA->Value[3] << 16) +
									 (ULONG)(pSIA->Value[2] << 24));
			}

			for(i = 0 ; i < dwSubAuthorities && dwRetCode == ERROR_SUCCESS; i++)
			{
				if ( dwSIDSize > _MAX_PATH * sizeof ( char ) )
				{
					dwRetCode = ERROR_INSUFFICIENT_BUFFER;
				}
				else
				{
					try
					{
						dwSIDSize += swprintf(szSID + dwSIDSize, L"-%lu", *GetSidSubAuthority(pSID, i)) ;
					}
					catch ( ... )
					{
						dwRetCode = ERROR_INVALID_PARAMETER;
					}
				}
			}

			if ( dwRetCode == ERROR_SUCCESS )
			{
				// See if the key already exists
				//==============================
				dwRetCode = Reg.Open(HKEY_USERS, szSID, KEY_READ) ;

				// We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
				// Reg.vClose();

				if(dwRetCode != ERROR_SUCCESS)
				{
    				// Try to locate user's registry hive
					//===================================

					swprintf(szTemp, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", szSID) ;
					dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ);

					if(dwRetCode == ERROR_SUCCESS)
					{
						CHString chsTemp;

						dwRetCode = Reg.GetCurrentKeyValue ( L"ProfileImagePath", chsTemp );
						Reg.Close();

						if(dwRetCode == ERROR_SUCCESS)
						{
            				// NT 4 doesn't include the file name in the registry
							//===================================================

							if(!IsLessThan4())
							{
                				chsTemp += L"\\NTUSER.DAT";
							}

							ExpandEnvironmentStrings ( (LPCTSTR) chsTemp, szTemp, wcslen ( szTemp ) * sizeof ( WCHAR ) ) ;

							// Try it three times, another process may have the file open
							bool bTryTryAgain = false;
							int  nTries = 0;

							do{
								// need to serialize access, using "write" because RegLoadKey wants exclusive access
								// even though it is a read operation

								try
								{
									EnterCriticalSection(&m_cs);
								}
								catch ( ... )
								{
									throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
								}

								try
								{
									dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, szSID, szTemp) ;
								}
								catch(...)
								{
									SafeLeaveCriticalSection(&m_cs);
									throw;
								}

								SafeLeaveCriticalSection(&m_cs);
        
								if((dwRetCode == ERROR_SHARING_VIOLATION) && (++nTries < 11))
								{
                    				Sleep(20 * nTries); 
									bTryTryAgain = true;
								}
								else
								{
									bTryTryAgain = false;
								}
            
							}while (bTryTryAgain);
						}
					}
				}
			}

			if(dwRetCode == ERROR_SUCCESS)
			{
				DWORD dwLen = 0L;
				dwLen = wcslen ( szSID );

				if ( dwLen < 1024 )
				{
    				wcscpy(m_wcKeyName, szSID) ;

					WCHAR wcKey[BUFF_SIZE];

					if ( dwLen < BUFF_SIZE )
					{
						wcscpy(wcKey, szSID);
						wcscat(wcKey, L"\\Software");

						LONG lRetVal = 0L;
						lRetVal = RegOpenKeyExW(HKEY_USERS, wcKey, 0, KEY_QUERY_VALUE, &m_hKey);

						if ( lRetVal != ERROR_SUCCESS )
						{
							dwRetCode = lRetVal;
						}
					}
					else
					{
						dwRetCode = ERROR_OUTOFMEMORY ;
					}
				}
				else
				{
					dwRetCode = ERROR_OUTOFMEMORY ;
				}
			}
		}
		else
		{
			dwRetCode = ERROR_BAD_USERNAME ;
		}

		// Restore original privilege level
		//=================================
		RestorePrivilege() ;
	}
	

    return dwRetCode ;    
}

DWORD CRequestObject::UnloadHive(/*LPCWSTR pszKeyName*/) 
{
    DWORD dwRetCode = ( DWORD ) E_FAIL;
    
    if(m_hKey != NULL){

        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

	if ( ( dwRetCode = AcquirePrivilege() ) == ERROR_SUCCESS )
	{
		try
		{
			EnterCriticalSection(&m_cs);
		}
		catch ( ... )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		try
		{
			dwRetCode = RegUnLoadKey(HKEY_USERS, m_wcKeyName);
		}
		catch(...)
		{
			SafeLeaveCriticalSection(&m_cs);
			throw;
		}

		SafeLeaveCriticalSection(&m_cs);
		RestorePrivilege() ;
	}

	DWORD dwRetCodeHelp = ERROR_SUCCESS;
	if ( FAILED ( dwRetCodeHelp = ( DWORD ) CoImpersonateClient() ) && SUCCEEDED ( dwRetCode ) )
	{
		// return failure in the case ofimpersonation failed
		dwRetCode = dwRetCodeHelp;
	}

    return dwRetCode ;
}

DWORD CRequestObject::AcquirePrivilege() 
{
    BOOL bRetCode = FALSE;
    HANDLE hToken = INVALID_HANDLE_VALUE ;
    TOKEN_PRIVILEGES TPriv ;
    LUID LUID ;

    // Validate the platform
    //======================

    // Try getting the thread token.  If it fails the first time it's 
    // because we're a system thread and we don't yet have a thread 
    // token, so just impersonate self and try again.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken))
	{

        try{

            GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &m_dwSize);

            if (m_dwSize > 0){

                // This is cleaned in the destructor, so no try/catch required
                m_pOriginalPriv = (TOKEN_PRIVILEGES*) new BYTE[m_dwSize];

                if (m_pOriginalPriv == NULL){

                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }

            if(m_pOriginalPriv && GetTokenInformation(hToken, TokenPrivileges, m_pOriginalPriv, m_dwSize, &m_dwSize)){ 

                // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
//              CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

                bRetCode = LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &LUID);

                if(bRetCode){

                    TPriv.PrivilegeCount = 1 ;
                    TPriv.Privileges[0].Luid = LUID ;
                    TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv,
                        sizeof(TOKEN_PRIVILEGES), NULL, NULL);
                }
                bRetCode = LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &LUID);

                if(bRetCode){

                    TPriv.PrivilegeCount = 1 ;
                    TPriv.Privileges[0].Luid = LUID ;
                    TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv,
                        sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
                }
            }

        }catch(...){

            CloseHandle(hToken);
            throw ;
        }

        CloseHandle(hToken);
    }

    if(!bRetCode){
        
        return GetLastError();
    }

    return ERROR_SUCCESS ;    
}

void CRequestObject::RestorePrivilege() 
{
    if (m_pOriginalPriv != NULL){

        HANDLE hToken;

        try{
            if(OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                TRUE, &hToken)){

                AdjustTokenPrivileges(hToken, FALSE, m_pOriginalPriv, m_dwSize, NULL, NULL);
                CloseHandle(hToken) ;
            }

        }catch(...){

            delete m_pOriginalPriv;
            m_pOriginalPriv = NULL;
            m_dwSize = 0;

            throw;
        }

        delete m_pOriginalPriv;
        m_pOriginalPriv = NULL;
        m_dwSize = 0;
    }
}

//Properties
/////////////////////
const char * pAccesses = "Accesses";
const char * pAction = "Action";
const char * pActionID = "ActionID";
const char * pAntecedent = "Antecedent";
const char * pAppData = "AppData";
const char * pAppID = "AppID";
const char * pArgument = "Argument";
const char * pArguments = "Arguments";
const char * pAttribute = "Attribute";
const char * pAttributes = "Attributes";
const char * pCaption = "Caption";
const char * pCabinet = "Cabinet";
const char * pCheck = "Check";
const char * pCheckID = "CheckID";
const char * pCLSID = "CLSID";
const char * pCommand = "Command";
const char * pCommandLine = "CommandLine";
const char * pComponent = "Component";
const char * pComponentID = "ComponentID";
const char * pCondition = "Condition";
const char * pContext = "Context";
const char * pContentType = "ContentType";
const char * pCost = "Cost";
const char * pCreationClassName = "CreationClassName";
const char * pDataSource = "DataSource";
const char * pDefaultDir = "DefaultDir";
const char * pDefInprocHandler = "DefInprocHandler";
const char * pDependencies = "Dependencies";
const char * pDependent = "Dependent";
const char * pDescription = "Description";
const char * pDestination = "Destination";
const char * pDestFolder = "DestFolder";
const char * pDestName = "DestName";
const char * pDirectory = "Directory";
const char * pDirectoryName = "DirectoryName";
const char * pDirectoryPath = "DirectoryPath";
const char * pDirProperty = "DirProperty";
const char * pDiskID = "DiskID";
const char * pDiskPrompt = "DiskPrompt";
const char * pDisplay = "Display";
const char * pDisplayName = "DisplayName";
const char * pDomain = "Domain";
const char * pDriver = "Driver";
const char * pDriverDescription = "DriverDescription";
const char * pElement = "Element";
const char * pEntryName = "EntryName";
const char * pEntryValue = "EntryValue";
const char * pEnvironment = "Environment";
const char * pError = "Error";
const char * pErrorControl = "ErrorControl";
const char * pEvent = "Event";
const char * pExpression = "Expression";
const char * pExpressionType = "ExpressionType";
const char * pExtension = "Extension";
const char * pFeature = "Feature";
const char * pFeatures = "Features";
const char * pField = "Field";
const char * pFile = "File";
const char * pFileKey = "FileKey";
const char * pFileName = "FileName";
const char * pFileSize = "FileSize";
const char * pFileTypeMask = "FileTypeMask";
const char * pFontTitle = "FontTitle";
const char * pGroupComponent = "GroupComponent";
const char * pHotKey = "HotKey";
const char * pID = "ID";
const char * pIdentificationCode = "IdentificationCode";
const char * pIdentifyingNumber = "IdentifyingNumber";
const char * pIniFile = "IniFile";
const char * pInsertable = "Insertable";
const char * pInstallDate = "InstallDate";
const char * pInstallDate2 = "InstallDate2";
const char * pInstallLocation = "InstallLocation";
const char * pInstallMode = "InstallMode";
const char * pInstallState = "InstallState";
const char * pKey = "Key";
const char * pLanguage = "Language";
const char * pLastSequence = "LastSequence";
const char * pLastUse = "LastUse";
const char * pLevel = "Level";
const char * pLibID = "LibID";
const char * pLoadOrderGroup = "LoadOrderGroup";
const char * pLocation = "Location";
const char * pManufacturer = "Manufacturer";
const char * pMaxDate = "MaxDate";
const char * pMaxSize = "MaxSize";
const char * pMaxVersion = "MaxVersion";
const char * pMessage = "Message";
const char * pMIME = "MIME";
const char * pMinDate = "MinDate";
const char * pMinSize = "MinSize";
const char * pMinVersion = "MinVersion";
const char * pName = "Name";
const char * pNext = "Next";
const char * pOperator = "Operator";
const char * pOptions = "Options";
const char * pPackageCache = "PackageCache";
const char * pParent = "Parent";
const char * pPartComponent = "PartComponent";
const char * pPassword = "Password";
const char * pPatch = "Patch";
const char * pPatchID = "PatchID";
const char * pPatchSize = "PatchSize";
const char * pPath = "Path";
const char * pPermission = "Permission";
const char * pPrior = "Prior";
const char * pProduct = "Product";
const char * pProductCode = "ProductCode";
const char * pProductName = "ProductName";
const char * pProductVersion = "ProductVersion";
const char * pProgID = "ProgID";
const char * pProperty = "Property";
const char * pQual = "Qual";
const char * pRegistration = "Registration";
const char * pRegistry = "Registry";
const char * pRemoteName = "RemoteName";
const char * pReserveKey = "ReserveKey";
const char * pReserveLocal = "ReserveLocal";
const char * pReserveSource = "ReserveSource";
const char * pResource = "Resource";
const char * pRoot = "Root";
const char * pSection = "Section";
const char * pSequence = "Sequence";
const char * pServiceType = "ServiceType";
const char * pSetting = "Setting";
const char * pSetupFile = "SetupFile";
const char * pShellNew = "ShellNew";
const char * pShellNewValue = "ShellNewValue";
const char * pSignature = "Signature";
const char * pShortcut = "Shortcut";
const char * pShowCmd = "ShowCmd";
const char * pSoftware = "Software";
const char * pSoftwareElementID = "SoftwareElementID";
const char * pSoftwareElementState = "SoftwareElementState";
const char * pSource = "Source";
const char * pSourceFolder = "SourceFolder";
const char * pSourceName = "SourceName";
const char * pStartMode = "StartMode";
const char * pStartName = "StartName";
const char * pStartType = "StartType";
const char * pStatus = "Status";
const char * pSystem = "System";
const char * pSystemCreationClassName = "SystemCreationClassName";
const char * pSystemName = "SystemName";
const char * pTable = "Table";
const char * pTarget = "Target";
const char * pTargetOperatingSystem = "TargetOperatingSystem";
const char * pTranslator = "Translator";
const char * pType = "Type";
const char * pUpgradeCode = "UpgradeCode";
const char * pUser = "User";
const char * pValue = "Value";
const char * pVendor = "Vendor";
const char * pVerb = "Verb";
const char * pVersion = "Version";
const char * pVolumeLabel = "VolumeLabel";
const char * pWait = "Wait";
const char * pWkDir = "WkDir";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecification.h ===
// ServiceSpecification.h: interface for the CServiceSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICESPECIFICATION_H__72CDD5DB_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_SERVICESPECIFICATION_H__72CDD5DB_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CServiceSpecification : public CGenericClass  
{
public:
	CServiceSpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CServiceSpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SERVICESPECIFICATION_H__72CDD5DB_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecificationservice.cpp ===
// ServiceSpecificationService.cpp: implementation of the CServiceSpecificationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ServiceSpecificationService.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceSpecificationService::CServiceSpecificationService(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CServiceSpecificationService::~CServiceSpecificationService()
{

}

HRESULT CServiceSpecificationService::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bService, bCheck;
    IWbemClassObject *pObj = NULL;
    VARIANT v;

    VariantInit(&v);

	CStringExt wcKey;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `ServiceInstall`, `Component_`, `Name` from ServiceInstall");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceInstall", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

					// safe operation

                    wcKey.Copy ( L"Win32_ServiceSpecification.CheckID=\"" );

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

					wcKey.Append ( 3, wcBuf, wcProductCode, L"\"" );
					PutKeyProperty(m_pObj, pCheck, wcKey, &bCheck, m_pRequest);

                //====================================================

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                    if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
					{
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                        wcKey.Copy ( L"Win32_Service.Name=\"" );
                        wcKey.Append ( 2, wcBuf, L"\"" );

						BSTR bstrObj;
						if ( ( bstrObj = ::SysAllocString ( wcKey ) ) == NULL )
						{
							throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
						}

                        if SUCCEEDED ( hr = m_pNamespace->GetObject ( bstrObj, 0, m_pCtx, &pObj, NULL ) )
						{
                            PutKeyProperty ( m_pObj, pElement, wcKey, &bService, m_pRequest );
                            pObj->Release();
							pObj = NULL;

                        //----------------------------------------------------

                            if(bService && bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

						::SysFreeString ( bstrObj );
                    }
                    
                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutaction.h ===
// ShortcutAction.h: interface for the CShortcutAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SHORTCUTACTION_H__75F6BA26_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SHORTCUTACTION_H__75F6BA26_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CShortcutAction : public CGenericClass  
{
public:
	CShortcutAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CShortcutAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SHORTCUTACTION_H__75F6BA26_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutsap.h ===
// ShortcutSAP.h: interface for the CShortcutSAP class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SHORTCUTSAP_H__F4A87822_E037_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SHORTCUTSAP_H__F4A87822_E037_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CShortcutSAP : public CGenericClass  
{
public:
	CShortcutSAP(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CShortcutSAP();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SHORTCUTSAP_H__F4A87822_E037_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecificationservice.h ===
// ServiceSpecificationService.h: interface for the CServiceSpecificationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICESPECIFICATIONSERVICE_H__7387F6D5_33AE_11D2_BFB1_00A0C9954921__INCLUDED_)
#define AFX_SERVICESPECIFICATIONSERVICE_H__7387F6D5_33AE_11D2_BFB1_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CServiceSpecificationService : public CGenericClass  
{
public:
	CServiceSpecificationService(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CServiceSpecificationService();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SERVICESPECIFICATIONSERVICE_H__7387F6D5_33AE_11D2_BFB1_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutsap.cpp ===
// ShortcutSAP.cpp: implementation of the CShortcutSAP class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ShortcutSAP.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CShortcutSAP::CShortcutSAP(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CShortcutSAP::~CShortcutSAP()
{

}

HRESULT CShortcutSAP::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcCommand[BUFF_SIZE];
    WCHAR wcProductCode[39];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    WCHAR wcShortcut[BUFF_SIZE];
    WCHAR wcTestCode[39];
    bool bShortcut = false;
    CRequestObject *pActionData = NULL;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int j;
        //GetObject optimizations
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        for(j = 0; j < m_pRequest->m_iPropCount; j++){
            
            if(_wcsicmp(m_pRequest->m_Property[j], L"Action") == 0){

                pActionData = new CRequestObject();
                if(!pActionData) throw he;

                pActionData->Initialize(m_pNamespace);

                pActionData->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pActionData){

            for(j = 0; j < pActionData->m_iPropCount; j++){
            
                if(_wcsicmp(pActionData->m_Property[j], L"ActionID") == 0){

					if ( ::SysStringLen ( pActionData->m_Value[j] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[j]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[j], wcShortcut);

						bShortcut = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }

            pActionData->Cleanup();
            delete pActionData;
            pActionData = NULL;
        }

    }

    //These will change from class to class
    bool bDriver, bAttribute;

    CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_` from Shortcut" );

    //optimize for GetObject
    if ( bShortcut )
	{
		wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
                (bShortcut && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
                            wcProp.Copy ( L"Win32_ShortcutAction.ActionID=\"" );
							wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );

							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

							// make query on fly
							wcQuery1.Append ( 2, wcBuf, L"\'" );

                            CheckMSI(g_fpMsiDatabaseOpenViewW( msidata.GetDatabase (), wcQuery1, &hSEView));
                            CheckMSI(g_fpMsiViewExecute(hSEView, 0));

                            try{

                                uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                                if(uiStatus != ERROR_NO_MORE_ITEMS){

                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hSERecord, 1, wcBuf, &dwBufSize));

                                    if(ValidateComponentID(wcBuf, wcProductCode)){

										INSTALLSTATE piInstalled;

                                        dwBufSize = BUFF_SIZE;
                                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf, wcCommand, &dwBufSize);
                                        
                                        if ( ( wcscmp(wcCommand, L"") != 0 ) &&
											 (piInstalled != INSTALLSTATE_UNKNOWN) &&
											 (piInstalled != INSTALLSTATE_ABSENT) )
										{
											if ( wcCommand [ dwBufSize-1 ] == L'\\' )
											{
												wcCommand [ dwBufSize-1 ] = L'\0';
											}

											wcBuf [ 0 ] = L'\0';
											EscapeStringW ( wcCommand, wcBuf );

											if ( wcBuf [ 0 ] != L'\0' )
											{
												// safe operation
												wcProp.Copy ( L"Win32_CommandLineAccess.Name=\"" );
												wcProp.Append ( 2, wcBuf, L"\"" );

												PutKeyProperty(m_pObj, pElement, wcProp, &bAttribute, m_pRequest);

												if(bDriver && bAttribute)
												{
													bMatch = true;
												}

												if((atAction != ACTIONTYPE_GET)  || bMatch)
												{
													hr = pHandler->Indicate(1, &m_pObj);
												}
											}
                                        }
                                    }
                                }

                            }catch(...){

                                g_fpMsiViewClose(hSEView);
                                g_fpMsiCloseHandle(hSEView);
                                g_fpMsiCloseHandle(hSERecord);
                                throw;
                            }

                            g_fpMsiViewClose(hSEView);
                            g_fpMsiCloseHandle(hSEView);
                            g_fpMsiCloseHandle(hSERecord);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutaction.cpp ===
// ShortcutAction.cpp: implementation of the CShortcutAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ShortcutAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CShortcutAction::CShortcutAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CShortcutAction::~CShortcutAction()
{

}

HRESULT CShortcutAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performa