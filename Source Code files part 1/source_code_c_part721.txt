(hr);
            goto exit;
        }
    }
exit:    
    MemFree ((LPVOID)lpwstrResultFullPath);
    return dwRes;
}   // FindArchivedMessage


static
DWORD
CreatePreviewFile (
    DWORDLONG               dwlMsgId,
    BOOL                    bAllMessages,
    PJOB_QUEUE*             lppJobQueue
)
/*++

Routine name : CreatePreviewFile

Routine description:

    Creates a tiff preview file it if does not exist.
    If the function succeeds it increase the job reference count.

Author:

    Oded Sacher (OdedS), Jan, 2000

Arguments:

    dwlMessageId    [in ] - Unique message id
    bAllMessages    [in ] - TRUE if the caller has right to view all messages
    lppJobQueue     [out] - Address of a pointer to receive the job queue with the new preview file.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD           dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CreatePreviewFile"));
    PJOB_QUEUE       pJobQueue;
    PSID             pUserSid = NULL;
    DWORD            dwJobStatus;

    Assert (lppJobQueue);


    EnterCriticalSection (&g_CsQueue);

    //
    // Find queue entry
    //
    pJobQueue = FindJobQueueEntryByUniqueId (dwlMsgId);
    //
    // The caller may view incoming jobs only if they are ROUTING
    // (if they are successfully finished with routing, they're in the archive) or
    // outgoing jobs that are SEND (that is - not broadcast).
    //
    if (pJobQueue == NULL)
    {
        //
        // dwlMsgId is not in the queue .
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid Parameter - bad job Id (%I64ld) ,not in the queue"),
                     dwlMsgId);
        dwRes = FAX_ERR_MESSAGE_NOT_FOUND;
        goto exit;

    }

    dwJobStatus = (JT_SEND== pJobQueue->JobType) ? pJobQueue->lpParentJob->JobStatus : pJobQueue->JobStatus;
    if (dwJobStatus == JS_DELETING)
    {
        //
        // Job is being deleted.
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid Parameter - job Id (%I64ld) is being deleted"),
                     dwlMsgId);
        dwRes = FAX_ERR_MESSAGE_NOT_FOUND;
        goto exit;
    }

    if ( (pJobQueue->JobType != JT_ROUTING) &&
         (pJobQueue->JobType != JT_SEND) )
    {
        //
        // dwlMsgId is not a valid job id in the queue.
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid Parameter - bad job Id (%I64ld), not a recipient or routing job"),
                     dwlMsgId);
        dwRes = ERROR_INVALID_OPERATION;
        goto exit;
    }

    //
    // Basic access checks
    //
    if (!bAllMessages)
    {
        //
        // Make sure the user looks only at his own messages here
        // Get SID of caller
        //
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), dwRes);
            goto exit;
        }
        if (!UserOwnsJob (pJobQueue, pUserSid))
        {
            DebugPrintEx(DEBUG_WRN,TEXT("UserOwnsJob failed ,Access denied"));
            dwRes = ERROR_ACCESS_DENIED;
            goto exit;
        }
    }

    //
    // Create tiff preview file
    //
    EnterCriticalSection (&pJobQueue->CsPreview);
    if (!CreateTiffFileForPreview(pJobQueue))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] CreateTiffFileForPreview failed. (ec: %ld)"),
            pJobQueue->JobId,
            dwRes
            );
        LeaveCriticalSection (&pJobQueue->CsPreview);
        goto exit;
    }
    LeaveCriticalSection (&pJobQueue->CsPreview);

    Assert (pJobQueue->PreviewFileName);

    //
    // Return the job queue back to caller
    //
    *lppJobQueue = pJobQueue;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree ((LPVOID)pUserSid);
    if (ERROR_SUCCESS == dwRes)
    {
        IncreaseJobRefCount (pJobQueue, TRUE);
    }
    LeaveCriticalSection (&g_CsQueue);
    return dwRes;
}   // CreatePreviewFile


error_status_t
FAX_GetMessage (
    IN handle_t                 hFaxHandle,
    IN DWORDLONG                dwlMessageId,
    IN FAX_ENUM_MESSAGE_FOLDER  Folder,
    IN OUT LPBYTE              *lppBuffer,
    IN OUT LPDWORD             lpdwBufferSize
)
/*++

Routine name : FAX_GetMessage

Routine description:

    Removes a message from an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Unused
    dwlMessageId    [in ] - Unique message id
    Folder          [in ] - Archive folder
    lppBuffer       [out] - Pointer to buffer to hold message information
    lpdwBufferSize  [out] - Pointer to buffer size

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    DWORD_PTR       dwOffset;
    PFAX_MESSAGE    pMsg = NULL;
    WCHAR           wszMsgFileName[MAX_PATH];
    BOOL            fAccess;
    DWORD           dwRights;
    BOOL            bAllMessages = FALSE;
    DWORD           dwClientAPIVersion;

    DEBUG_FUNCTION_NAME(TEXT("FAX_GetMessage"));

    dwClientAPIVersion = FindClientAPIVersion (hFaxHandle);

    Assert (lpdwBufferSize);    // ref pointer in idl
    if (!lppBuffer)             // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid message id sepcified (%I64ld)"),
            dwlMessageId);
        return ERROR_INVALID_PARAMETER;
    }
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_INBOX  == Folder)
    {
        if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to view Inbox messages"));
            return ERROR_ACCESS_DENIED;
        }
        bAllMessages = TRUE;

    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder);

        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to view Sent items messages"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    //
    // Locate the file the caller's talking about
    //
    Rval = FindArchivedMessage (Folder, dwlMessageId, bAllMessages, wszMsgFileName, ARR_SIZE(wszMsgFileName), NULL, 0);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindArchivedMessage returned %ld"),
            Rval);
        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            if (FALSE == bAllMessages)
            {
                //
                //  The message was not found and the user doesn't have administrative rights
                //  so send the user ERROR_ACCESS_DENIED
                //
                Rval = ERROR_ACCESS_DENIED;
            }
            else
            {
                Rval = FAX_ERR_MESSAGE_NOT_FOUND;
            }
        }
        return GetServerErrorCode(Rval);
    }
    //
    // Retrieve FAX_MESSAGE information
    //
    Rval = RetrieveMessage (wszMsgFileName,
                            Folder,
                            &pMsg);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("RetrieveMessage returned error %ld"),
                      Rval);
        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = FAX_ERR_MESSAGE_NOT_FOUND;
        }
        return GetServerErrorCode(Rval);
    }
    //
    // Calculate required message size
    //
    // until MIDL accepts [out, size_is(,__int64*)]
    ULONG_PTR upBufferSize = sizeof (FAX_MESSAGE);
    SerializeMessage (NULL, &upBufferSize, dwClientAPIVersion, 0, pMsg, 0);
    *lpdwBufferSize = DWORD(upBufferSize);

    //
    // Allocate return buffer
    //
    *lppBuffer = (LPBYTE) MemAlloc (*lpdwBufferSize);
    if (!*lppBuffer)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for return buffer (%ld bytes)"),
                      *lpdwBufferSize);
        Rval = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // Serialize message in the return buffer
    //
    dwOffset = sizeof(FAX_MESSAGE);
    SerializeMessage (*lppBuffer, &dwOffset, dwClientAPIVersion, 0, pMsg, *lpdwBufferSize);

    Assert (ERROR_SUCCESS == Rval);

exit:

    if (pMsg)
    {
        FreeMessageBuffer (pMsg, TRUE);
    }
    return GetServerErrorCode(Rval);
}   // FAX_GetMessage

error_status_t
FAX_RemoveMessage (
    IN handle_t                 hFaxHandle,
    IN DWORDLONG                dwlMessageId,
    IN FAX_ENUM_MESSAGE_FOLDER  Folder
)
/*++

Routine name : FAX_RemoveMessage

Routine description:

    Removes a message from an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in] - Unused
    dwlMessageId    [in] - Unique message id
    Folder          [in] - Archive folder

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    WCHAR           wszMsgFilePath[MAX_PATH];
    HANDLE          hFind;
    WIN32_FIND_DATA FindFileData;
    DWORDLONG       dwlFileSize = 0;
    BOOL            fAccess;
    DWORD           dwRights;
    BOOL            bAllMessages = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("FAX_RemoveMessage"));
    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid message id sepcified (%I64ld)"),
            dwlMessageId);
        return ERROR_INVALID_PARAMETER;
    }
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_INBOX == Folder)
    {
        if (FAX_ACCESS_MANAGE_IN_ARCHIVE != (dwRights & FAX_ACCESS_MANAGE_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to manage Inbox messages"));
            return ERROR_ACCESS_DENIED;
        }
        bAllMessages = TRUE;
    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder);

        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_MANAGE_OUT_ARCHIVE != (dwRights & FAX_ACCESS_MANAGE_OUT_ARCHIVE))
        {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights to manage Sent items messages"));
                return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_MANAGE_OUT_ARCHIVE == (dwRights & FAX_ACCESS_MANAGE_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    //
    // Locate the file the caller's talking about
    //
    Rval = FindArchivedMessage (Folder, dwlMessageId, bAllMessages, NULL, 0, wszMsgFilePath, ARR_SIZE(wszMsgFilePath));
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindArchivedMessage returned %ld"),
            Rval);
        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            if (FALSE == bAllMessages)
            {
                //
                //  The message was not found and the user doesn't have administrative rights
                //  so send the user ERROR_ACCESS_DENIED
                //
                Rval = ERROR_ACCESS_DENIED;
            }
            else
            {
                Rval = FAX_ERR_MESSAGE_NOT_FOUND;
            }
        }
        return GetServerErrorCode(Rval);
    }
    //
    // Get the file size
    //
    hFind = FindFirstFile( wszMsgFilePath, &FindFileData);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindFirstFile failed (ec: %lc), File %s"),
            GetLastError(),
            wszMsgFilePath);
    }
    else
    {
        dwlFileSize = (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
        if (!FindClose(hFind))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindClose failed (ec: %lc)"),
                GetLastError());
        }
    }

    //
    // Try to remove the file (message)
    //
    if (!DeleteFile (wszMsgFilePath))
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DeleteFile returned %ld on %s"),
            Rval,
            wszMsgFilePath);

        if (ERROR_ACCESS_DENIED == Rval ||
            ERROR_SHARING_VIOLATION == Rval)
        {
            Rval = FAX_ERR_FILE_ACCESS_DENIED;
        }
        else if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = FAX_ERR_MESSAGE_NOT_FOUND;
        }
    }
    else
    {
        // Send event and update archive size for quota management

        PSID lpUserSid = NULL;
        DWORD dwRes;
        FAX_ENUM_EVENT_TYPE EventType;

        if (FAX_MESSAGE_FOLDER_INBOX == Folder)
        {
            EventType = FAX_EVENT_TYPE_IN_ARCHIVE;
        }
        else
        {
            EventType = FAX_EVENT_TYPE_OUT_ARCHIVE;
            if (!GetMessageIdAndUserSid (wszMsgFilePath, Folder, &lpUserSid, NULL)) // We do not need message id
            {
                dwRes = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("GetMessageIdAndUserSid Failed, Error : %ld"),
                             dwRes);
                return Rval;
            }
        }

        dwRes = CreateArchiveEvent (dwlMessageId, EventType, FAX_JOB_EVENT_TYPE_REMOVED, lpUserSid);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                dwRes);
        }

        if (NULL != lpUserSid)
        {
            LocalFree (lpUserSid);
            lpUserSid = NULL;
        }

        if (0 != dwlFileSize)
        {
            // Update archive size
            EnterCriticalSection (&g_CsConfig);
            if (FAX_ARCHIVE_FOLDER_INVALID_SIZE != g_ArchivesConfig[Folder].dwlArchiveSize)
            {
                g_ArchivesConfig[Folder].dwlArchiveSize -= dwlFileSize;
            }
            LeaveCriticalSection (&g_CsConfig);
        }
    }

    return GetServerErrorCode(Rval);
}   // FAX_RemoveMessage

//********************************************
//*               RPC copy
//********************************************

error_status_t
FAX_StartCopyToServer (
    IN  handle_t              hFaxHandle,
    IN  LPCWSTR               lpcwstrFileExt,
    OUT LPWSTR                lpwstrServerFileName,
    OUT PRPC_FAX_COPY_HANDLE  lpHandle
)
/*++

Routine name : FAX_StartCopyToServer

Routine description:

    Start to copy a file to the server

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle           [in ] - Handle to server
    lpcwstrFileExt       [in ] - Extension of file to create on the server
    lpwstrServerFileName [out] - File name (and extension) of file created on the server
    handle               [out] - RPC copy handle

Return Value:

    Standard RPC error code

--*/
{
    error_status_t   Rval = ERROR_SUCCESS;
    HANDLE           hFile = INVALID_HANDLE_VALUE;
    PSID             pUserSid = NULL;
	LPWSTR			 lpwstrUserSid = NULL;
    PHANDLE_ENTRY    pHandleEntry;
    WCHAR            wszQueueFileName[MAX_PATH] = {0};
	WCHAR            wszUserSidPrefix[MAX_PATH] = {0};
    LPWSTR           pwstr;
    BOOL            fAccess;
    DWORD           dwRights;
	int				Count;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartCopyToServer"));

    Assert (lpHandle && lpwstrServerFileName && lpcwstrFileExt);

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (0 == ((FAX_ACCESS_SUBMIT | FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT_HIGH) & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax submission rights"));
        return ERROR_ACCESS_DENIED;
    }

    if ( (NULL == lpcwstrFileExt) || 
         (_tcsicmp(lpcwstrFileExt,FAX_COVER_PAGE_EXT_LETTERS) && _tcsicmp(lpcwstrFileExt,FAX_TIF_FILE_EXT) )  )
    {
        //
        //  No extension at all, or extension is other then "COV" or "TIF"
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad extension specified (%s)"),
            lpcwstrFileExt);
        return ERROR_INVALID_PARAMETER;
    }

	//
    //Get the user SID
    //
    pUserSid = GetClientUserSID();
    if (NULL == pUserSid)
    {
       Rval = GetLastError();
       DebugPrintEx(DEBUG_ERR,
                    TEXT("GetClientUserSid Failed, Error : %ld"),
                    Rval);
       return GetServerErrorCode(Rval);
    }	

    if (!ConvertSidToStringSid (pUserSid, &lpwstrUserSid))
    {
		Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ConvertSidToStringSid Failed, error : %ld"),
            Rval);
        goto exit;
    }

	Count = _snwprintf (
		wszUserSidPrefix,
		ARR_SIZE(wszUserSidPrefix)-1,
		L"%s$",
		lpwstrUserSid);

    if (Count < 0)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
        Rval = ERROR_BUFFER_OVERFLOW;        
        goto exit;
    }

    //
    // Generate unique file in server's queue
    //
    DWORDLONG dwl = GenerateUniqueFileNameWithPrefix(
							FALSE,
                            g_wszFaxQueueDir,
							wszUserSidPrefix,
                            (LPWSTR)lpcwstrFileExt,							
                            wszQueueFileName,
                            sizeof(wszQueueFileName)/sizeof(wszQueueFileName[0]));
    if (0 == dwl)
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GenerateUniqueFileName failed, ec = %d"),
            Rval);
        goto exit;
    }
    //
    // Open the file for writing (again)
    //
    hFile = SafeCreateFile (
                    wszQueueFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Opening %s for read failed (ec: %ld)"),
            wszQueueFileName,
            Rval);
        goto exit;
    }

	//
    // Get the filename.ext to return buffer (skip the user sid prefix)
    //
    pwstr = wcsrchr( wszQueueFileName, L'$');
    Assert (pwstr);
    //
    // Skip the path and sid prefix
    //
    pwstr++;
    
    //
    // Create copy context
    //
    pHandleEntry = CreateNewCopyHandle( hFaxHandle,
                                        hFile,
                                        TRUE,     // Copy to server
                                        wszQueueFileName,
                                        NULL);

    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("CreateNewCopyHandle failed, Error %ld"), Rval);
        goto exit;
    }
    
    if (lstrlen(lpwstrServerFileName)<lstrlen(pwstr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lpwstrServerFileName out buffer (size=%d) , can't contain pwstr (size=%d)."),
            lstrlen(lpwstrServerFileName)+1,
            lstrlen(pwstr)+1);
        Rval = ERROR_BUFFER_OVERFLOW;        
        goto exit;
    }
    wcsncpy( lpwstrServerFileName, pwstr , MAX_PATH );

    //
    // Return context handle
    //
    *lpHandle = (HANDLE) pHandleEntry;

    Assert (ERROR_SUCCESS == Rval);

exit:

    if (ERROR_SUCCESS != Rval)
    {
        //
        // Some error occured
        //
        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            // Close the file
            //
            if (CloseHandle (hFile))
            {
                DWORD dwErr = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                    TEXT("CloseHandle failed, Error %ld"), dwErr);
            }
        }
        if (lstrlen (wszQueueFileName))
        {
            //
            // Remove unused queue file
            //
            if (!DeleteFile (wszQueueFileName))
            {
                DWORD dwErr = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                    TEXT("DeleteFile failed on %s, Error %ld"),
                    wszQueueFileName,
                    dwErr);
            }
        }
    }
	if (NULL != lpwstrUserSid)
	{
		LocalFree(lpwstrUserSid);
	}
	MemFree (pUserSid);
    return Rval;
}   // FAX_StartCopyToServer


error_status_t
FAX_StartCopyMessageFromServer (
    IN  handle_t                   hFaxHandle,
    IN  DWORDLONG                  dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PRPC_FAX_COPY_HANDLE       lpHandle
)
/*++

Routine name : FAX_StartCopyMessageFromServer

Routine description:

    Starts a copy process of a message from the server's archive / queue
    to the caller

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Handle to server
    dwlMessageId    [in ] - Message id
    Folder          [in ] - Archive / queue folder
    handle          [out] - RPC copy handle

Return Value:

    Standard RPC error code

--*/
{
    error_status_t   Rval = ERROR_SUCCESS;
    HANDLE           hFile = INVALID_HANDLE_VALUE;
    PHANDLE_ENTRY    pHandleEntry;
    PJOB_QUEUE       pJobQueue = NULL;
    WCHAR            wszFileName[MAX_PATH] = {0};
    BOOL             bAllMessages = FALSE;
    BOOL             fAccess;
    DWORD            dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartCopyMessageFromServer"));

    Assert (lpHandle);
    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("zero message id sepcified"));
        return ERROR_INVALID_PARAMETER;
    }
    if ((FAX_MESSAGE_FOLDER_QUEUE != Folder) &&
        (FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_INBOX == Folder)
    {
        if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to preview Inbox tiff files"));
            return ERROR_ACCESS_DENIED;
        }
        bAllMessages = TRUE;
    }

    if (FAX_MESSAGE_FOLDER_SENTITEMS == Folder)
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to preview Sent items tiff files"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    if (FAX_MESSAGE_FOLDER_QUEUE == Folder)
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to preview Outbox tiff files"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            bAllMessages = TRUE;
        }
    }

    //
    // Locate the file the caller's talking about
    //
    if (FAX_MESSAGE_FOLDER_QUEUE == Folder)
    {
        Rval = CreatePreviewFile (dwlMessageId, bAllMessages, &pJobQueue);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreatePreviewFile returned %ld"),
                Rval);
            return GetServerErrorCode(Rval);
        }
        Assert (pJobQueue && pJobQueue->PreviewFileName && pJobQueue->UniqueId == dwlMessageId);
        Assert (wcslen(pJobQueue->PreviewFileName) < MAX_PATH);
        wcscpy (wszFileName, pJobQueue->PreviewFileName);
    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder ||
                FAX_MESSAGE_FOLDER_INBOX == Folder);

        Rval = FindArchivedMessage (Folder, dwlMessageId, bAllMessages, NULL, 0, wszFileName, ARR_SIZE(wszFileName));
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindArchivedMessage returned %ld"),
                Rval);

            if (ERROR_FILE_NOT_FOUND == Rval)
            {
                if (FALSE == bAllMessages)
                {
                    //
                    //  The message was not found and the user doesn't have administrative rights
                    //  so send the user ERROR_ACCESS_DENIED
                    //
                    Rval = ERROR_ACCESS_DENIED;
                }
                else
                {
                    Rval = FAX_ERR_MESSAGE_NOT_FOUND;
                }
            }
            return GetServerErrorCode(Rval);
        }
    }

    //
    // Open the file for reading
    //
    Assert (wcslen(wszFileName));

    hFile = SafeCreateFile (
                    wszFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        // We must decrease the job refrence count if it is a queued job.
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Opening %s for read failed (ec: %ld)"),
            wszFileName,
            Rval);
        goto exit;
    }
    //
    // Create copy context
    //
    pHandleEntry = CreateNewCopyHandle( hFaxHandle,
                                        hFile,
                                        FALSE,    // Copy from server
                                        NULL,
                                        pJobQueue);
    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("CreateNewCopyHandle failed, Error %ld"), Rval);
        goto exit;
    }
    //
    // Return context handle
    //
    *lpHandle = (HANDLE) pHandleEntry;

    Assert (ERROR_SUCCESS == Rval);

exit:
    if (ERROR_SUCCESS != Rval)
    {
        if (FAX_MESSAGE_FOLDER_QUEUE == Folder)
        {
            // Decrease ref count only if it is a queued job.
            EnterCriticalSection (&g_CsQueue);
            DecreaseJobRefCount (pJobQueue, TRUE, TRUE, TRUE);  // TRUE for Preview ref count.
            LeaveCriticalSection (&g_CsQueue);
        }

        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            // Some error occured - close the file
            //
            if (CloseHandle (hFile))
            {
                DWORD dwErr = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                    TEXT("CloseHandle failed, Error %ld"), dwErr);
            }
        }
    }
    return GetServerErrorCode(Rval);
}   // FAX_StartCopyMessageFromServer

error_status_t
FAX_WriteFile (
    IN RPC_FAX_COPY_HANDLE    hCopy,                  // RPC copy handle
    IN LPBYTE                 lpbData,                // Data chunk to append to file on server
    IN DWORD                  dwDataSize              // Size of data chunk
)
/*++

Routine name : FAX_WriteFile

Routine description:

    Copies a chunk of data to the server's queue

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hCopy           [in] - Copy context handle
    lpbData         [in] - Pointer to buffer to copy from
    chunk           [in] - Size of source buffer

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    PHANDLE_ENTRY   pHandle = (PHANDLE_ENTRY)hCopy;
    DWORD           dwBytesWritten;
    DEBUG_FUNCTION_NAME(TEXT("FAX_WriteFile"));

    if (NULL == hCopy)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("NULL context handle"));
        return ERROR_INVALID_PARAMETER;
    }

    Assert (lpbData && (INVALID_HANDLE_VALUE != pHandle->hFile));
    if (!pHandle->bCopyToServer)
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("Handle was created using FAX_StartCopyMessageFromServer"));
        return ERROR_INVALID_HANDLE;
    }
    if (!dwDataSize)
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("Zero data size"));
        return ERROR_INVALID_PARAMETER;
    }
    if (!WriteFile (pHandle->hFile,
                    lpbData,
                    dwDataSize,
                    &dwBytesWritten,
                    NULL))
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("WriteFile failed (ec: %ld)"),
            Rval);
        pHandle->bError = TRUE; // Erase local queue file on handle close
        goto exit;
    }
    if (dwBytesWritten != dwDataSize)
    {
        //
        // Strange situation
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("WriteFile was asked to write %ld bytes but wrote only %ld bytes"),
            dwDataSize,
            dwBytesWritten);
        Rval = ERROR_GEN_FAILURE;
        pHandle->bError = TRUE; // Erase local queue file on handle close
        goto exit;
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    return Rval;
}   // FAX_WriteFile

error_status_t
FAX_ReadFile (
    IN  RPC_FAX_COPY_HANDLE   hCopy,                  // RPC copy handle
    IN  DWORD                 dwMaxDataSize,          // Max size of data to copy
    OUT LPBYTE                lpbData,                // Data buffer to retrieve from server
    OUT LPDWORD               lpdwDataSize            // Size of data retrieved
)
/*++

Routine name : FAX_ReadFile

Routine description:

    Copies a file from the server (in chunks)

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hCopy           [in ] - Copy context
    dwMaxDataSize   [in ] - Max chunk size
    lpbData         [in ] - Pointer to output data buffer
    retrieved       [out] - Number of bytes actually read.
                            A value of zero indicates EOF.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    PHANDLE_ENTRY   pHandle = (PHANDLE_ENTRY)hCopy;
    DEBUG_FUNCTION_NAME(TEXT("FAX_ReadFile"));

    if (NULL == hCopy)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("NULL context handle"));
        return ERROR_INVALID_PARAMETER;
    }

    Assert (lpdwDataSize && lpbData && (INVALID_HANDLE_VALUE != pHandle->hFile));
    if (pHandle->bCopyToServer)
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("Handle was created using FAX_StartCopyToServer"));
        return ERROR_INVALID_HANDLE;
    }
    if (!dwMaxDataSize)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("zero dwMaxDataSizee specified"));
        return ERROR_INVALID_PARAMETER;
    }
    if (dwMaxDataSize != *lpdwDataSize)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("dwMaxDataSize != *lpdwDataSize"));
        return ERROR_INVALID_PARAMETER;
    }
    if (!ReadFile (pHandle->hFile,
                   lpbData,
                   dwMaxDataSize,
                   lpdwDataSize,
                   NULL))
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReadFile failed (ec: %ld)"),
            Rval);
        goto exit;
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    return Rval;
}   // FAX_ReadFile

error_status_t
FAX_EndCopy (
    IN OUT PRPC_FAX_COPY_HANDLE lphCopy
)
/*++

Routine name : FAX_EndCopy

Routine description:

    Ends a copy process (from / to server)

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lphCopy         [in] - Copy context handle

Return Value:

    Standard RPC error code

--*/
{    
    DEBUG_FUNCTION_NAME(TEXT("FAX_EndCopy"));

    if (NULL == *lphCopy)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("NULL context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    
    CloseFaxHandle( (PHANDLE_ENTRY) *lphCopy );
    //
    // NULLify the handle so the rundown will not occur
    //
    *lphCopy = NULL;
    return ERROR_SUCCESS;
} // FAX_EndCopy


VOID
RPC_FAX_COPY_HANDLE_rundown(
    IN HANDLE FaxCopyHandle
    )
/*++

Routine name : RPC_FAX_COPY_HANDLE_rundown

Routine description:

    The RPC rundown function of the copy handle.
    This function is called if the client abruptly disconnected on us.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    FaxCopyHandle            [in] - Message copy handle.

Return Value:

    None.

--*/
{
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) FaxCopyHandle;
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_COPY_HANDLE_rundown"));

    DebugPrintEx(
        DEBUG_WRN,
        TEXT("RPC_FAX_COPY_HANDLE_rundown: handle = 0x%08x"),
        FaxCopyHandle);    
    pHandleEntry->bError = TRUE;
    CloseFaxHandle( pHandleEntry );
    return;    
}   // RPC_FAX_COPY_HANDLE_rundown



error_status_t
FAX_StartServerNotification(
   IN handle_t                      hBinding,
   IN LPCTSTR                       lpcwstrMachineName,
   IN LPCTSTR                       lpcwstrEndPoint,
   IN ULONG64                       Context,
   IN LPWSTR                        lpcwstrProtseqString,
   IN BOOL                          bEventEx,
   IN DWORD                         dwEventTypes,
   OUT PRPC_FAX_EVENT_HANDLE        lpHandle
   )
{   
    DWORD dwRights;
    BOOL fAccess;
    DWORD Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartServerNotification"));

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

    return ERROR_NOT_SUPPORTED;
}


VOID
RPC_FAX_EVENT_HANDLE_rundown(
    IN HANDLE hFaxEventHandle
    )
{
    //
    // This call is not supported.
    //
    Assert (FALSE); //obsolete code
    return; 
}


error_status_t
FAX_StartServerNotificationEx(
   IN handle_t                          hBinding,
   IN LPCTSTR                           lpcwstrMachineName,
   IN LPCTSTR                           lpcwstrEndPoint,
   IN ULONG64                           Context,
   IN LPWSTR                            lpcwstrUnUsed, // This parameter is not used.
   IN BOOL                              bEventEx,
   IN DWORD                             dwEventTypes,
   OUT PRPC_FAX_EVENT_EX_HANDLE         lpHandle
   )
{
    error_status_t   Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartServerNotificationEx"));
    PSID pUserSid = NULL;    
    handle_t hFaxHandle = NULL; // binding handle
    CClientID* pContextClientID = NULL;
    CClientID* pOpenConnClientID = NULL;    
    BOOL bAllQueueMessages = FALSE;
    BOOL bAllOutArchiveMessages = FALSE;
    BOOL fAccess;
    DWORD dwRights;
	DWORD dwRes;
    Assert (lpcwstrEndPoint && lpcwstrMachineName && lpcwstrUnUsed && lpHandle);
    
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Access check for extended events only 
    //
    if (TRUE == bEventEx)
    {
        if (dwEventTypes & FAX_EVENT_TYPE_NEW_CALL)
        {
            if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
            {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights - FAX_ACCESS_QUERY_IN_ARCHIVE"));
                return ERROR_ACCESS_DENIED;
            }
        }

        if ( (dwEventTypes & FAX_EVENT_TYPE_IN_QUEUE) ||
             (dwEventTypes & FAX_EVENT_TYPE_OUT_QUEUE) )
        {
            if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
                FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
                FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
                FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
            {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights to get events of jobs in queue"));
                return ERROR_ACCESS_DENIED;
            }
        }

        if ( (dwEventTypes & FAX_EVENT_TYPE_CONFIG)        ||
             (dwEventTypes & FAX_EVENT_TYPE_DEVICE_STATUS) ||
             (dwEventTypes & FAX_EVENT_TYPE_ACTIVITY) )
        {
            if (FAX_ACCESS_QUERY_CONFIG != (dwRights & FAX_ACCESS_QUERY_CONFIG))
            {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights to get events configuration and activity"));
                return ERROR_ACCESS_DENIED;
            }
        }

        if ( dwEventTypes & FAX_EVENT_TYPE_IN_ARCHIVE )
        {
            if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
                FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
                FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
                FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
            {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights to get events of jobs in Inbox"));
                return ERROR_ACCESS_DENIED;
            }
        }

        if ( dwEventTypes & FAX_EVENT_TYPE_OUT_ARCHIVE )
        {
            if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
                FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
                FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
                FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
            {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights to get events of jobs in Sent items"));
                return ERROR_ACCESS_DENIED;
            }
        }

        //
        // Set bAllQueueMessages to the right value
        //
        if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            bAllQueueMessages = TRUE;
        }

        //
        // Set bAllOutArchiveMessages to the right value
        //
        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            bAllOutArchiveMessages = TRUE;
        }
    }
    else
    {    
		//
		// Legacy events
		//
		BOOL fLocal;
        if (FAX_EVENT_TYPE_LEGACY != dwEventTypes)
        {
            DebugPrintEx(DEBUG_ERR,
                            TEXT("Legacy registration. The user can not get extended events"));
            return ERROR_ACCESS_DENIED;
        }
        
        if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have any Fax rights"));
            return ERROR_ACCESS_DENIED;
        }        
        //
        //  Ok User have rights
        //

		//
		// The user asked for legacy events. make sure it is a local call
		//
		Rval = IsLocalRPCConnectionNP(&fLocal);
		if (RPC_S_OK != Rval)
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("IsLocalRPCConnectionNP failed. - %ld"),
				Rval);
			return Rval;
		}

		if (FALSE == fLocal)
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("The user asked for local events only, but the RPC call is not local"));
			return ERROR_ACCESS_DENIED;
		}
    }		

	if (wcslen (lpcwstrMachineName) > MAX_COMPUTERNAME_LENGTH ||
		wcslen (lpcwstrEndPoint)	>= MAX_ENDPOINT_LEN)
	{
		DebugPrintEx(DEBUG_ERR,
			TEXT("Computer name or endpoint too long. Computer name: %s. Endpoint: %s"),
					lpcwstrMachineName,
					lpcwstrEndPoint);
        return ERROR_BAD_FORMAT;
	}

    //
    //Get the user SID
    //
    pUserSid = GetClientUserSID();
    if (NULL == pUserSid)
    {
       Rval = GetLastError();
       DebugPrintEx(DEBUG_ERR,
                    TEXT("GetClientUserSid Failed, Error : %ld"),
                    Rval);
       return GetServerErrorCode(Rval);
    }

    EnterCriticalSection( &g_CsClients );
    //
    // Create binding to the client RPC server.
    //
    Rval = RpcBindToFaxClient (lpcwstrMachineName,
                               lpcwstrEndPoint,
                               &hFaxHandle);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindToFaxClient faild (ec = %ld)"),
            Rval);
        goto exit;
    }
    //
    // Create 2 new client IDs objects
    //
    pContextClientID = new (std::nothrow) CClientID( g_dwlClientID, lpcwstrMachineName, lpcwstrEndPoint, Context);
    if (NULL == pContextClientID)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin CClientID object"));
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    pOpenConnClientID = new (std::nothrow) CClientID( g_dwlClientID, lpcwstrMachineName, lpcwstrEndPoint, Context);
    if (NULL == pOpenConnClientID)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin CClientID object"));
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    try
    {
        CClient Client(*pContextClientID,
                       pUserSid,
                       dwEventTypes,
                       hFaxHandle,
                       bAllQueueMessages,
                       bAllOutArchiveMessages,
                       FindClientAPIVersion(hBinding));

        //
        // Add a new client object to the clients map
        //
        Rval = g_pClientsMap->AddClient(Client);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CClientsMap::AddClient failed with ec = %ld"),
                Rval);
            goto exit;
        } 
		hFaxHandle = NULL; // CClientMap::DelClient() will free the binding handle
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or CClient caused exception (%S)"),
            ex.what());
        Rval = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // Post the CLIENT_OPEN_CONN_COMPLETION_KEY event to the FaxEvent completion port
    //
    if (!PostQueuedCompletionStatus( g_hSendEventsCompPort,
                                     sizeof(CClientID*),
                                     CLIENT_OPEN_CONN_COMPLETION_KEY,
                                     (LPOVERLAPPED) pOpenConnClientID))
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
            Rval);
		//
		// Remove the map entry		
		// ReleaseClient should be called when not holding g_CsClients because it might call FAX_OpenConnection (RPC call that should not be in critacal section)
		// Here, we dont want to leave g_CsClients (we might get 2 clients with the same ID).
		// However, We can safetly call ReleaseClient while holding g_CsClients because a connection was not opened yet,
		// and FAX_CloseConnection will not be called.
		//
		dwRes = g_pClientsMap->ReleaseClient(*pContextClientID);				
		if (ERROR_SUCCESS != dwRes)
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("CClientsMap::ReleaseClient failed. (ec: %ld)"),
				dwRes);
		}
        goto exit;
    }
    pOpenConnClientID = NULL; // FaxSendEventsThread will free pOpenConnClientID

    //
    // Return a context handle to the client
    //
    *lpHandle = (HANDLE) pContextClientID;
	pContextClientID = NULL;    // RPC_FAX_EVENT_EX_HANDLE_rundown or FAX_EndServerNotification will free pContextClientID
    Assert (ERROR_SUCCESS == Rval);

exit:
	if (NULL != hFaxHandle)
    {
        // free binding handle
        dwRes = RpcBindingFree((RPC_BINDING_HANDLE *)&hFaxHandle);
        if (RPC_S_OK != dwRes)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("RpcBindingFree() failed, ec=0x%08x"), dwRes );
        }
    }   
        
    if (pContextClientID != NULL)
    {
        delete pContextClientID;
        pContextClientID = NULL;
    }

    if (pOpenConnClientID != NULL)
    {
        delete pOpenConnClientID;
        pOpenConnClientID = NULL;
    }
    
	if (ERROR_SUCCESS == Rval)
    {
        g_dwlClientID++;
    }
    LeaveCriticalSection( &g_CsClients );
    MemFree (pUserSid);
    pUserSid = NULL;
    return GetServerErrorCode(Rval);
	UNREFERENCED_PARAMETER(lpcwstrUnUsed);
}     // FAX_StartServerNotificationEx


VOID
RPC_FAX_EVENT_EX_HANDLE_rundown(
    IN HANDLE hFaxEventHandle
    )
{
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_EVENT_EX_HANDLE_rundown"));

    CClientID* pClientID = (CClientID*)(hFaxEventHandle);   
       
    DebugPrintEx(
        DEBUG_WRN,
        TEXT("RPC_FAX_EVENT_EX_HANDLE_rundown() running for event handle 0x%08x"),
        hFaxEventHandle);
    //
    // Remove relevant connections from notification list
    //
    DWORD rVal = g_pClientsMap->ReleaseClient(*pClientID, TRUE);    
	if (ERROR_SUCCESS != rVal)
	{
		DebugPrintEx(
			DEBUG_WRN,
			TEXT("CClientsMap::ReleaseClient failed. ec:%ld"),
			rVal);
	}
    delete pClientID;
    pClientID = NULL;        
    return;
}

error_status_t
FAX_EndServerNotification (
    IN OUT LPHANDLE  lpHandle
)
/*++

Routine name : FAX_EndServerNotification

Routine description:

    A fax client application calls the FAX_EndServerNotification function to stop
    recieving server notifications.

Author:

    Oded Sacher (OdedS), Dec, 1999

Arguments:

    lpHandle    [in] - The notification handle value.
                       This value is obtained by calling FAX_StartServerNotificationEx.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EndServerNotification"));
    CClientID* pClientID = (CClientID*)(*lpHandle);

    if (NULL == pClientID)
    {
        //
        // Empty context handle
        //
        //              
        DebugPrintEx(DEBUG_ERR,
                     _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
    }

    Rval = g_pClientsMap->ReleaseClient (*pClientID);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
			TEXT("CClientsMap::ReleaseClient failed, ec=%ld"),
        Rval);
    }   
    delete pClientID;    
    //
    // NULLify the handle so the rundown will not occur
    //
    *lpHandle = NULL;    
    return GetServerErrorCode(Rval);
}   // FAX_EndServerNotificationEx

//********************************************
//*             Server activity
//********************************************

error_status_t
FAX_GetServerActivity(
    IN handle_t                     hFaxHandle,
    IN OUT PFAX_SERVER_ACTIVITY     pServerActivity
)
/*++

Routine name : FAX_GetServerActivity

Routine description:

    Retrieves the status of the fax server queue activity and event log reports.

Author:

    Oded Sacher (OdedS), Feb, 2000

Arguments:

    hFaxHandle          [in ] - Unused
    pServerActivity     [out] - Returned server activity structure

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetServerActivity"));
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;

    Assert (pServerActivity);

    if (sizeof (FAX_SERVER_ACTIVITY) != pServerActivity->dwSizeOfStruct)
    {
       //
       // Size mismatch
       //
       DebugPrintEx(DEBUG_ERR,
                   TEXT("Invalid size of struct"));
       return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
       DebugPrintEx(DEBUG_ERR,
                   TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                   dwRes);
       return dwRes;
    }

    if (FALSE == fAccess)
    {
       DebugPrintEx(DEBUG_ERR,
                   TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
       return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsActivity);
    CopyMemory (pServerActivity, &g_ServerActivity, sizeof(FAX_SERVER_ACTIVITY));
    LeaveCriticalSection (&g_CsActivity);

    GetEventsCounters( &pServerActivity->dwWarningEvents,
                       &pServerActivity->dwErrorEvents,
                       &pServerActivity->dwInformationEvents);


    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetServerActivity



error_status_t
FAX_SetConfigWizardUsed (
    IN  handle_t hFaxHandle,
    OUT BOOL     bConfigWizardUsed
)
/*++

Routine name : FAX_SetConfigWizardUsed

Routine description:

    Sets if the configuration wizard was used

    Requires no access rights.

Author:

    Eran Yariv (EranY), July 2000

Arguments:

    hFaxHandle           [in ] - Unused
    bConfigWizardUsed    [in]  - Was the wizard used?

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetConfigWizardUsed"));
    HKEY hKey;
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwRes2;
    BOOL fAccess;   

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    dwRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REGKEY_FAX_CLIENT, 0, KEY_WRITE, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening server key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    if (!SetRegistryDword (hKey,
                           REGVAL_CFGWZRD_DEVICE,
                           (DWORD)bConfigWizardUsed))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing REGVAL_CFGWZRD_DEVICE (ec = %ld)"),
            dwRes);
        goto exit;
    }

exit:

    dwRes2 = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRes2)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing server key (ec = %ld)"),
            dwRes2);
    }
    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetConfigWizardUsed


//********************************************
//*            Routing extensions
//********************************************

error_status_t
FAX_EnumRoutingExtensions (
    IN  handle_t   hFaxHandle,
    OUT LPBYTE    *pBuffer,
    OUT LPDWORD    pdwBufferSize,
    OUT LPDWORD    lpdwNumExts
)
/*++

Routine name : FAX_EnumRoutingExtensions

Routine description:

    Enumerates the routing extensions

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold routing extensions array
    pdwBufferSize       [out] - Pointer to buffer size
    lpdwNumExts         [out] - Size of FSPs array

Return Value:

    Standard RPC error codes

--*/
{
    extern LIST_ENTRY           g_lstRoutingExtensions;  // Global list of routing extensions
    PLIST_ENTRY                 Next;
    DWORD_PTR                   dwOffset;
    PFAX_ROUTING_EXTENSION_INFO pExts;
    DWORD                       dwIndex;
    DWORD                       dwRes = ERROR_SUCCESS;
    BOOL                        fAccess;

    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumRoutingExtensions"));

    Assert (pdwBufferSize && lpdwNumExts);    // ref pointer in idl
    if (!pBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // First run - traverse list and count size required + list size
    //
    *lpdwNumExts = 0;
    *pdwBufferSize = 0;
    Next = g_lstRoutingExtensions.Flink;
    if (NULL == Next)
    {
        //
        // The list is corrupted
        //
        ASSERT_FALSE;
        //
        // We'll crash and we deserve it....
        //
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_lstRoutingExtensions)
    {
        PROUTING_EXTENSION    pExt;

        (*lpdwNumExts)++;
        (*pdwBufferSize) += sizeof (FAX_ROUTING_EXTENSION_INFO);
        //
        // Get current extension
        //
        pExt = CONTAINING_RECORD( Next, ROUTING_EXTENSION, ListEntry );
        //
        // Advance pointer
        //
        Next = pExt->ListEntry.Flink;
        (*pdwBufferSize) += StringSize (pExt->FriendlyName);
        (*pdwBufferSize) += StringSize (pExt->ImageName);
        (*pdwBufferSize) += StringSize (pExt->InternalName);
    }
    //
    // Allocate required size
    //
    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Second pass, fill in the array
    //
    pExts = (PFAX_ROUTING_EXTENSION_INFO)(*pBuffer);
    dwOffset = (*lpdwNumExts) * sizeof (FAX_ROUTING_EXTENSION_INFO);
    Next = g_lstRoutingExtensions.Flink;
    dwIndex = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_lstRoutingExtensions)
    {
        PROUTING_EXTENSION    pExt;
        //
        // Get current extension
        //
        pExt = CONTAINING_RECORD( Next, ROUTING_EXTENSION, ListEntry );
        //
        // Advance pointer
        //
        Next = pExt->ListEntry.Flink;
        pExts[dwIndex].dwSizeOfStruct = sizeof (FAX_ROUTING_EXTENSION_INFO);
        StoreString(
            pExt->FriendlyName,
            (PULONG_PTR)&(pExts[dwIndex].lpctstrFriendlyName),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        StoreString(
            pExt->ImageName,
            (PULONG_PTR)&(pExts[dwIndex].lpctstrImageName),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        StoreString(
            pExt->InternalName,
            (PULONG_PTR)&(pExts[dwIndex].lpctstrExtensionName),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        pExts[dwIndex].Version = pExt->Version;
        pExts[dwIndex].Status = pExt->Status;
        pExts[dwIndex].dwLastError = pExt->dwLastError;
        dwIndex++;
    }
    Assert (dwIndex == *lpdwNumExts);
    return ERROR_SUCCESS;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_EnumRoutingExtensions



DWORD
LineInfoToLegacyDeviceStatus(
    const LINE_INFO *lpcLineInfo
    )
{

    DWORD dwState = 0;
    Assert(lpcLineInfo);

    //
    // Return the line state according to the following backward compatability policy:
    //
    //      For devices that do not support FSPI_CAP_MULTISEND we report the same
    //      status code as in W2K by translating the FSPI_JOB_STATUS kept in the job entry
    //      to the correspondign FPS_code (or just passing the proprietry FSP code).
    //
    //      For devices that support FSPI_CAP_MULTISEND filter the state bits
    //      and return only the following states:
    //      FPS_OFFLINE
    //      FPS_AVAILABLE
    //      FPS_UNAVILABLE
    //      0   - ( if the line is already allocated for the future job but a job is not yet assosiated with the line )
    //

    if (lpcLineInfo->JobEntry )
    {            
		dwState = lpcLineInfo->State;                        
    }
    else
    {
        //
        // Legacy FSP device that does not execute
        // anything.
        // In this case the device state is to be found in LineInfo->State but it is limited to
        // FPS_OFFLINE or FPS_AVAILABLE or FPS_UNAVILABLE or 0
        //
        // LineInfo->State could be 0 if - the line is already allocated for the future job but
        // a job is not yet assosiated with the line
        //
        Assert( (FPS_OFFLINE == lpcLineInfo->State) ||
                (FPS_AVAILABLE == lpcLineInfo->State) ||
                (FPS_UNAVAILABLE == lpcLineInfo->State) ||
                (0 == lpcLineInfo->State) );

        dwState      = lpcLineInfo->State;
    }

    return dwState;
}

//********************************************
//*            Manual answering support
//********************************************

error_status_t
FAX_AnswerCall(
        IN  handle_t    hFaxHandle,
        IN  CONST DWORD dwDeviceId
)
/*++

Routine name : FAX_AnswerCall

Routine description:

    A fax client application calls the FAX_AnswerCall to cause server to answer
    the specified call

Arguments:
    hFaxHandle  - unused
    dwDeviceId  - TAPI Permanent line ID (for identification)

Return Value:

    Standard RPC error code

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    LPLINEMESSAGE lpLineMessage;
    BOOL    fAccess;
    LINE_INFO *pLineInfo;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AnswerCall"));
    UNREFERENCED_PARAMETER (hFaxHandle);

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_IN_ARCHIVE, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        rVal = ERROR_ACCESS_DENIED;
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_IN_ARCHIVE"));
        return rVal;
    }
    //
    // Only local connections are allowed to call this procedure
    //
    BOOL  bLocalFlag;

    RPC_STATUS rc = IsLocalRPCConnectionNP(&bLocalFlag);
    if ( rc != RPC_S_OK )
    {
        rVal = ERROR_ACCESS_DENIED;
        DebugPrintEx(DEBUG_ERR,
                TEXT("IsLocalRPCConnectionNP failed. (ec: %ld)"),
                rc);
        return rVal;
    }
    if( !bLocalFlag )
    {
        rVal = ERROR_ACCESS_DENIED;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_AnswerCall is available for local clients only"));
        return rVal;
    }
    //
    // Validate the line exists and can answer calls
    //
    EnterCriticalSection( &g_CsLine );
    //
    // Get LineInfo from permanent device ID
    //
    pLineInfo = GetTapiLineFromDeviceId(dwDeviceId, FALSE);
    if(!pLineInfo)
    {
        rVal = ERROR_INVALID_PARAMETER;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Device %ld not found"),
                     dwDeviceId);
        goto Error;
    }
    //
    // See if the device is still available
    //
    if(pLineInfo->State != FPS_AVAILABLE)
    {
        rVal = ERROR_BUSY;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Line is not available (LineState is 0x%08x)."),
                     pLineInfo->State);
        goto Error;
    }
    //
    // Allocate and compose a LINEMESSAGE structure that'll be
    // used to notify the server about the new inbound message.
    //
    lpLineMessage = (LPLINEMESSAGE)LocalAlloc(LPTR, sizeof(LINEMESSAGE));
    if (lpLineMessage == NULL)
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate LINEMESSAGE structure"));
        goto Error;
    }
    lpLineMessage->dwParam1 = dwDeviceId;
    //
    // Notify the server.
    //
    if (!PostQueuedCompletionStatus(
            g_TapiCompletionPort,
            sizeof(LINEMESSAGE),
            ANSWERNOW_EVENT_KEY,
            (LPOVERLAPPED)lpLineMessage))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed - %d"),
            GetLastError());
        LocalFree(lpLineMessage);
        goto Error;
    }

Error:
    LeaveCriticalSection( &g_CsLine );
    return rVal;
}   // FAX_AnswerCall


//********************************************
//*   Ivalidate archive folder
//********************************************

error_status_t
FAX_RefreshArchive(
    IN  handle_t                 hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder
)
/*++

Routine name : FAX_RefreshArchive

Routine description:

    A fax client application calls the FAX_RefreshArchive to notify server
    that archive folder has been changed and should be refreshed

Arguments:
    hFaxHandle      - unused
    Folder          - Archive folder name

Return Value:

    Standard RPC error code

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    BOOL    fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RefreshArchive"));
    UNREFERENCED_PARAMETER (hFaxHandle);

    if(Folder != FAX_MESSAGE_FOLDER_INBOX &&
       Folder != FAX_MESSAGE_FOLDER_SENTITEMS)
    {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Access check
    //
    rVal = FaxSvcAccessCheck ((Folder == FAX_MESSAGE_FOLDER_INBOX) ? FAX_ACCESS_MANAGE_IN_ARCHIVE :
                               FAX_ACCESS_MANAGE_OUT_ARCHIVE,
                               &fAccess,
                               NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        rVal = ERROR_ACCESS_DENIED;
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_IN_ARCHIVE"));
        return rVal;
    }


    //
    // Refresh archive size
    //
    EnterCriticalSection (&g_CsConfig);
    g_ArchivesConfig[Folder].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
    LeaveCriticalSection (&g_CsConfig);

    //
    // Wake up quota warning thread
    //
    if (!SetEvent (g_hArchiveQuotaWarningEvent))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to set quota warning event, SetEvent failed (ec: %lc)"),
            GetLastError());
    }

    return rVal;
}

static
LPTSTR
GetClientMachineName (
    IN  handle_t                hFaxHandle
)
/*++

Routine name : GetClientMachineName

Routine description:

    A utility function to retrieve the machine name of the RPC client from the 
    server binding handle.

Arguments:
    hFaxHandle       - Server binding handle

Return Value:

    Returns an allocated string of the client machine name.
    The caller should free this string with MemFree().
    
    If the return value is NULL, call GetLastError() to get last error code.

--*/
{
    RPC_STATUS ec;
    LPTSTR lptstrRetVal = NULL;
    unsigned short *wszStringBinding = NULL;
    unsigned short *wszNetworkAddress = NULL;
    RPC_BINDING_HANDLE hServer = INVALID_HANDLE_VALUE;
    DEBUG_FUNCTION_NAME(TEXT("GetClientMachineName"));
    
    //
    // Get server partially-bound handle from client binding handle
    //
    ec = RpcBindingServerFromClient (hFaxHandle, &hServer);
    if (RPC_S_OK != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindingServerFromClient failed with %ld"),
            ec);
        goto exit;            
    }
    //
    // Convert binding handle to string represntation
    //
    ec = RpcBindingToStringBinding (hServer, &wszStringBinding);
    if (RPC_S_OK != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindingToStringBinding failed with %ld"),
            ec);
        goto exit;
    }
    //
    // Parse the returned string, looking for the NetworkAddress
    //
    ec = RpcStringBindingParse (wszStringBinding, NULL, NULL, &wszNetworkAddress, NULL, NULL);
    if (RPC_S_OK != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcStringBindingParse failed with %ld"),
            ec);
        goto exit;
    }
    //
    // Now, just copy the result to the return buffer
    //
    Assert (wszNetworkAddress);
    if (!wszNetworkAddress)
    {
        //
        // Unacceptable client machine name
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Client machine name is invalid"));
        ec = ERROR_GEN_FAILURE;
        goto exit;
    }        
    lptstrRetVal = StringDup (wszNetworkAddress);
    if (!lptstrRetVal)
    {
        ec = GetLastError();
    }
    
exit:

    if (INVALID_HANDLE_VALUE != hServer)
    {
        RpcBindingFree (&hServer);
    }
    if (wszStringBinding)
    {
        RpcStringFree (&wszStringBinding);
    }   
    if (wszNetworkAddress)
    {
        RpcStringFree (&wszNetworkAddress);
    }
    if (!lptstrRetVal)
    {
        //
        // Error
        //
        Assert (ec);
        SetLastError (ec);
        return NULL;
    }
    return lptstrRetVal;
}   // GetClientMachineName      


//********************************************
//*   Recipients limit in a single broadcast
//********************************************

error_status_t
FAX_SetRecipientsLimit(
    IN handle_t hFaxHandle,
    IN DWORD dwRecipientsLimit
)
/*++
Routine name : FAX_SetRecipientsLimit

Routine description:
    A fax client application calls the FAX_SetRecipientsLimit to set the 
    recipients limit of a single broadcast job.

Arguments:
    hFaxHandle					- unused
    dwRecipientsLimit           - the recipients limit to set
	
Return Value:
    Standard Win32 error code
--*/
{
	UNREFERENCED_PARAMETER (hFaxHandle);
	UNREFERENCED_PARAMETER (dwRecipientsLimit);

	return ERROR_NOT_SUPPORTED;
} // FAX_SetRecipientsLimit


error_status_t
FAX_GetRecipientsLimit(
    IN handle_t hFaxHandle,
    OUT LPDWORD lpdwRecipientsLimit
)
/*++
Routine name : FAX_GetRecipientLimit

Routine description:
    A fax client application calls the FAX_GetRecipientsLimit to get the 
    recipients limit of a single broadcast job.

Arguments:
    hFaxHandle					- unused
    lpdwRecipientsLimit         - pointer to a DWORD to receive the recipients limit
	
Return Value:
    Standard Win32 error code
--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    BOOL    fAccess;
	DWORD	dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetRecipientsLimit"));
    UNREFERENCED_PARAMETER (hFaxHandle); 

    Assert (lpdwRecipientsLimit); // ref pointer in IDL.
	//
    // Access check
    //
    rVal = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (0 == ((FAX_ACCESS_SUBMIT | FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT_HIGH) & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax submission rights"));
        return ERROR_ACCESS_DENIED;
    }   
    
	*lpdwRecipientsLimit = g_dwRecipientsLimit;
    return ERROR_SUCCESS;
} // FAX_GetRecipientsLimit


error_status_t
FAX_GetServerSKU(
    IN handle_t hFaxHandle,
    OUT PRODUCT_SKU_TYPE* pServerSKU
)
/*++
Routine name : FAX_GetServerSKU

Routine description:
    A fax client application calls the FAX_GetServerSKU to fax server SKU

Arguments:
    hFaxHandle			- unused
    pServerSKU			- pointer to a PRODUCT_SKU_TYPE to receive the fax server SKU
	
Return Value:
    Standard Win32 error code
--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    BOOL    fAccess;
	DWORD	dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetRecipientsLimit"));
    UNREFERENCED_PARAMETER (hFaxHandle); 	

    Assert (pServerSKU); // ref pointer in IDL.
	//
    // Access check
    //
    rVal = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

	*pServerSKU = GetProductSKU();
    return ERROR_SUCCESS;
} // FAX_GetServerSKU

error_status_t
FAX_CheckValidFaxFolder(
    IN handle_t hFaxHandle,
    IN LPCWSTR  lpcwstrPath
)
/*++
Routine name : FAX_CheckValidFaxFolder

Routine description:
    Used by fax client application to check if a given path is accessible (valid for use)
    by the fax service.

Arguments:
    hFaxHandle	- unused
    lpcwstrPath	- Path to check
	
Return Value:

    ERROR_SUCCESS if path can be used by the fax service.
    Win32 error code otherwise.
    
--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    BOOL    fAccess;
	DWORD	dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_CheckValidFaxFolder"));
    UNREFERENCED_PARAMETER (hFaxHandle); 	

    Assert (lpcwstrPath); // ref pointer in IDL.
	//
    // Access check
    //
    rVal = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }
    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }
    //
    // See if foler is valid (exists and has proper access rights) and does not collide with queue or inbox folder.
    //
    rVal = IsValidArchiveFolder (const_cast<LPWSTR>(lpcwstrPath), FAX_MESSAGE_FOLDER_SENTITEMS);
    if (ERROR_SUCCESS != rVal)
    {
        if(ERROR_ACCESS_DENIED == rVal && 
           FAX_API_VERSION_1 <= FindClientAPIVersion (hFaxHandle))
        {
            rVal = FAX_ERR_FILE_ACCESS_DENIED;
        }
        return rVal;
    }

    //
    // See if foler is valid (exists and has proper access rights) and does not collide with queue or sent-items folder.
    //
    rVal = IsValidArchiveFolder (const_cast<LPWSTR>(lpcwstrPath), FAX_MESSAGE_FOLDER_INBOX);
    if (ERROR_SUCCESS != rVal)
    {
        if(ERROR_ACCESS_DENIED == rVal && 
           FAX_API_VERSION_1 <= FindClientAPIVersion (hFaxHandle))
        {
            rVal = FAX_ERR_FILE_ACCESS_DENIED;
        }
        return rVal;
    }
   
    return rVal;
} // FAX_CheckValidFaxFolder
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\job.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    job.c

Abstract:

    This module implements the job creation and deletion.
    Also included in the file are the queue management
    functions and thread management.

Author:

    Wesley Witt (wesw) 24-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#include "faxreg.h"
#pragma hdrstop
#include <strsafe.h>
#include <efsputil.h>
using namespace std;

// Globals
LIST_ENTRY          g_JobListHead; //List of currently running jobs (for which FaxDevStartJob was called).
CFaxCriticalSection    g_CsJob;
HANDLE              g_StatusCompletionPortHandle;
HINSTANCE           g_hResource;
DWORD               g_dwFaxSendRetries;
DWORD               g_dwFaxSendRetryDelay;
DWORD               g_dwFaxDirtyDays;
BOOL                g_fFaxUseDeviceTsid;
BOOL                g_fFaxUseBranding;
BOOL                g_fServerCp;
FAX_TIME            g_StartCheapTime;
FAX_TIME            g_StopCheapTime;
DWORD               g_dwNextJobId;

#define JOB_GROUP_FILE_EXTENSION TEXT("FSP")

static BOOL SendJobReceipt (BOOL bPositive, JOB_QUEUE * lpJobQueue, LPCTSTR lpctstrAttachment);

static BOOL CheckForJobRetry (PJOB_QUEUE lpJobQueue);

static
DWORD
TranslateCanonicalNumber(
    LPTSTR lptstrCanonicalFaxNumber,
    DWORD  dwDeviceID,
    LPTSTR lptstrDialableAddress,
	DWORD dwDialableAddressCount,
    LPTSTR lptstrDisplayableAddress,
	DWORD dwDisplayableAddressCount
);

static PJOB_ENTRY
StartLegacySendJob(
        PJOB_QUEUE lpJobQueue,
        PLINE_INFO lpLineInfo        
    );

static PJOB_ENTRY CreateJobEntry(PJOB_QUEUE lpJobQueue, LINE_INFO * lpLineInfo, BOOL bTranslateNumber);


BOOL FreeJobEntry(PJOB_ENTRY lpJobEntry , BOOL bDestroy);



static BOOL UpdatePerfCounters(const JOB_QUEUE * lpcJobQueue);
static BOOL
CreateCoverpageTiffFile(
    IN short Resolution,
    IN const FAX_COVERPAGE_INFOW2 *CoverpageInfo,
    IN LPCWSTR lpcwstrExtension,
    OUT LPWSTR lpwstrCovTiffFile,
	IN DWORD dwCovTiffFileCount 
    );

static LPWSTR
GetFaxPrinterName(
    VOID
    );


DWORD BrandFax(LPCTSTR lpctstrFileName, LPCFSPI_BRAND_INFO pcBrandInfo)

{
    #define MAX_BRANDING_LEN  115
    #define BRANDING_HEIGHT  22 // in scan lines.

    //
    // We allocate fixed size arrays on the stack to avoid many small allocs on the heap.
    //
    LPTSTR lptstrBranding = NULL;
    DWORD  lenBranding =0;
    TCHAR  szBrandingEnd[MAX_BRANDING_LEN+1];
    DWORD  lenBrandingEnd = 0;
    LPTSTR lptstrCallerNumberPlusCompanyName = NULL;
    DWORD  lenCallerNumberPlusCompanyName = 0;
    DWORD  delta =0 ;
    DWORD  ec = ERROR_SUCCESS;
    LPTSTR lptstrDate = NULL;
    LPTSTR lptstrTime = NULL;
    LPTSTR lptstrDateTime = NULL;
    int    lenDate =0 ;
    int    lenTime =0;
    LPDWORD MsgPtr[6];
	HRESULT hr;
	DWORD dwDateTimeLength = 0;


    LPTSTR lptstrSenderTsid;
    LPTSTR lptstrRecipientPhoneNumber;
    LPTSTR lptstrSenderCompany;

    DWORD dwSenderTsidLen;
    DWORD dwSenderCompanyLen;


    DEBUG_FUNCTION_NAME(TEXT("BrandFax"));

    Assert(lpctstrFileName);
    Assert(pcBrandInfo);


    lptstrSenderTsid = pcBrandInfo->lptstrSenderTsid ? pcBrandInfo->lptstrSenderTsid : TEXT("");
    lptstrRecipientPhoneNumber =  pcBrandInfo->lptstrRecipientPhoneNumber ? pcBrandInfo->lptstrRecipientPhoneNumber : TEXT("");
    lptstrSenderCompany = pcBrandInfo->lptstrSenderCompany ? pcBrandInfo->lptstrSenderCompany : TEXT("");

    dwSenderTsidLen = lptstrSenderTsid ? _tcslen(lptstrSenderTsid) : 0;
    dwSenderCompanyLen = lptstrSenderCompany ? _tcslen(lptstrSenderCompany) : 0;

    lenDate = GetY2KCompliantDate(
                LOCALE_SYSTEM_DEFAULT,
                0,
                &pcBrandInfo->tmDateTime,
                NULL,
                NULL);

    if ( ! lenDate )
    {

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetY2KCompliantDate() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }

    lptstrDate = (LPTSTR) MemAlloc(lenDate * sizeof(TCHAR)); // lenDate includes terminating NULL
    if (!lptstrDate)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate date buffer of size %ld (ec: %ld)"),
            lenDate * sizeof(TCHAR),
            ec);
        goto Error;
    }

    if (!GetY2KCompliantDate(
                LOCALE_SYSTEM_DEFAULT,
                0,
                &pcBrandInfo->tmDateTime,
                lptstrDate,
                lenDate))
    {

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetY2KCompliantDate() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }

    lenTime = FaxTimeFormat( LOCALE_SYSTEM_DEFAULT,
                                     TIME_NOSECONDS,
                                     &pcBrandInfo->tmDateTime,
                                     NULL,
                                     NULL,
                                     0 );

    if ( !lenTime )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }


    lptstrTime = (LPTSTR) MemAlloc(lenTime * sizeof(TCHAR)); // lenTime includes terminating NULL
    if (!lptstrTime)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate time buffer of size %ld (ec: %ld)"),
            lenTime * sizeof(TCHAR),
            ec);
        goto Error;
    }
    if ( ! FaxTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            TIME_NOSECONDS,
            &pcBrandInfo->tmDateTime,
            NULL,                // use locale format
            lptstrTime,
            lenTime)  )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }


    //
    // Concatenate date and time
    //
	dwDateTimeLength = lenDate + lenTime;  // should be enough, lenDate and lentime both include '\0', and we add only one ' ' between the date and time.
    lptstrDateTime = (LPTSTR) MemAlloc (dwDateTimeLength * sizeof(TCHAR));
    if (!lptstrDateTime)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate DateTime buffer of size %ld (ec: %ld)"),
            dwDateTimeLength,
            ec);
        goto Error;
    }

    hr = StringCchPrintf(lptstrDateTime,
                       dwDateTimeLength,
                       TEXT("%s %s"),
					   lptstrDate,
					   lptstrTime);
	if (FAILED(hr))
	{
		//
		// Should never happen, we just allocated large enough buffer.
		//
		ASSERT_FALSE;
	}

    //
    // Create  lpCallerNumberPlusCompanyName
    //

    if (lptstrSenderCompany)
    {
		DWORD dwCallerNumberPlusCompanyNameCount = dwSenderTsidLen + dwSenderCompanyLen +2; // we add 2 chars, 1 for '\0' and one for the ' '.

        lptstrCallerNumberPlusCompanyName = (LPTSTR) MemAlloc( dwCallerNumberPlusCompanyNameCount * sizeof(TCHAR) ); 

        if (!lptstrCallerNumberPlusCompanyName)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CallerNumberPlusCompanyName buffer of size %ld (ec: %ld)"),
                dwCallerNumberPlusCompanyNameCount,
                ec);
            goto Error;
        }

		hr = StringCchPrintf(lptstrCallerNumberPlusCompanyName,
                       dwCallerNumberPlusCompanyNameCount,
                       TEXT("%s %s"),
					   lptstrSenderTsid,
					   lptstrSenderCompany);
		if (FAILED(hr))
		{
			//
			// Should never happen, we just allocated large enough buffer.
			//
			ASSERT_FALSE;
		}       
    }
    else
	{
        lptstrCallerNumberPlusCompanyName = (LPTSTR)
            MemAlloc( (dwSenderTsidLen + 1) * sizeof(TCHAR));

        if (!lptstrCallerNumberPlusCompanyName)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CallerNumberPlusCompanyName buffer of size %ld (ec: %ld)"),
                (dwSenderTsidLen + 1) * sizeof(TCHAR),
                ec);
            goto Error;
        }
		hr = StringCchCopy(
			lptstrCallerNumberPlusCompanyName,
			dwSenderTsidLen + 1,
			lptstrSenderTsid);
		if (FAILED(hr))
		{
			//
			// Should never happen, we just allocated large enough buffer.
			//
			ASSERT_FALSE;
		}        
    }



    //
    // Try to create a banner of the following format:
    // <szDateTime>  FROM: <szCallerNumberPlusCompanyName>  TO: <pcBrandInfo->lptstrRecipientPhoneNumber>   PAGE: X OF Y
    // If it does not fit we will start chopping it off.
    //
    MsgPtr[0] = (LPDWORD) lptstrDateTime;
    MsgPtr[1] = (LPDWORD) lptstrCallerNumberPlusCompanyName;
    MsgPtr[2] = (LPDWORD) lptstrRecipientPhoneNumber;
    MsgPtr[3] = NULL;

    lenBranding = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        g_hResource,
                        MSG_BRANDING_FULL,
                        0,
                        (LPTSTR)&lptstrBranding,
                        0,
                        (va_list *) MsgPtr
                        );

    if ( ! lenBranding  )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage of MSG_BRANDING_FULL failed (ec: %ld)"),
            ec);
        goto Error;
    }

    Assert(lptstrBranding);

    lenBrandingEnd = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE ,
                        g_hResource,
                        MSG_BRANDING_END,
                        0,
                        szBrandingEnd,
                        sizeof(szBrandingEnd)/sizeof(TCHAR),
                        NULL
                        );

    if ( !lenBrandingEnd)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage of MSG_BRANDING_END failed (ec: %ld)"),
            ec);
        goto Error;
    }

    //
    // Make sure we can fit everything.
    //

    if (lenBranding + lenBrandingEnd + 8 <= MAX_BRANDING_LEN)
    {
        //
        // It fits. Proceed with branding.
        //
       goto lDoBranding;
    }

    //
    // It did not fit. Try a message of the format:
    // <lpDateTime>  FROM: <lpCallerNumberPlusCompanyName>  PAGE: X OF Y
    // This skips the ReceiverNumber. The important part is the CallerNumberPlusCompanyName.
    //
    MsgPtr[0] = (LPDWORD) lptstrDateTime;
    MsgPtr[1] = (LPDWORD) lptstrCallerNumberPlusCompanyName;
    MsgPtr[2] = NULL;

    //
    // Free the previous attempt branding string
    //
    Assert(lptstrBranding);
    LocalFree(lptstrBranding);
    lptstrBranding = NULL;

    lenBranding = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        g_hResource,
                        MSG_BRANDING_SHORT,
                        0,
                        (LPTSTR)&lptstrBranding,
                        0,
                        (va_list *) MsgPtr
                        );

    if ( !lenBranding )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage() failed for MSG_BRANDING_SHORT (ec: %ld)"),
            ec);
        goto Error;
    }

    Assert(lptstrBranding);

    if (lenBranding + lenBrandingEnd + 8 <= MAX_BRANDING_LEN)  {
       goto lDoBranding;
    }

    //
    // It did not fit.
    // We have to truncate the caller number so it fits.
    // delta = how many chars of the company name we need to chop off.
    //
    delta = lenBranding + lenBrandingEnd + 8 - MAX_BRANDING_LEN;

    lenCallerNumberPlusCompanyName = _tcslen (lptstrCallerNumberPlusCompanyName);
    if (lenCallerNumberPlusCompanyName <= delta) {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("Can not truncate CallerNumberPlusCompanyName to fit brand limit.")
           TEXT(" Delta[%ld] >= lenCallerNumberPlusCompanyName[%ld]"),
           delta,
           lenCallerNumberPlusCompanyName);
       ec = ERROR_BAD_FORMAT;
       goto Error;
    }

    lptstrCallerNumberPlusCompanyName[ lenCallerNumberPlusCompanyName - delta] = TEXT('\0');

    MsgPtr[0] = (LPDWORD) lptstrDateTime;
    MsgPtr[1] = (LPDWORD) lptstrCallerNumberPlusCompanyName;
    MsgPtr[2] = NULL;

    //
    // Free the previous attempt branding string
    //
    Assert(lptstrBranding);
    LocalFree(lptstrBranding);
    lptstrBranding = NULL;

    lenBranding = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        g_hResource,
                        MSG_BRANDING_SHORT,
                        0,
                        (LPTSTR)&lptstrBranding,
                        0,
                        (va_list *) MsgPtr
                        );

    if ( !lenBranding )
    {

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage() failed (ec: %ld). MSG_BRANDING_SHORT 2nd attempt"),
            ec);
        goto Error;
    }

    Assert(lptstrBranding);
    //
    // If it did noo fit now then we have a bug.
    //
    Assert(lenBranding + lenBrandingEnd + 8 <= MAX_BRANDING_LEN);


lDoBranding:

    if (!MmrAddBranding(lpctstrFileName, lptstrBranding, szBrandingEnd, BRANDING_HEIGHT) ) 
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MmrAddBranding() failed (ec: %ld)")
            TEXT(" File: [%s]")
            TEXT(" Branding: [%s]")
            TEXT(" Branding End: [%s]")
            TEXT(" Branding Height: [%d]"),
            ec,
            lpctstrFileName,
            lptstrBranding,
            szBrandingEnd,
            BRANDING_HEIGHT);
        goto Error;
    }

    Assert( ERROR_SUCCESS == ec);
    goto Exit;

Error:
        Assert (ERROR_SUCCESS != ec);

Exit:
    if (lptstrBranding)
    {
        LocalFree(lptstrBranding);
        lptstrBranding = NULL;
    }

    MemFree(lptstrDate);
    lptstrDate = NULL;

    MemFree(lptstrTime);
    lptstrTime = NULL;

    MemFree(lptstrDateTime);
    lptstrDateTime = NULL;

    MemFree(lptstrCallerNumberPlusCompanyName);
    lptstrCallerNumberPlusCompanyName = NULL;

    return ec;

}


HRESULT
WINAPI
FaxBrandDocument(
    LPCTSTR lpctsrtFile,
    LPCFSPI_BRAND_INFO lpcBrandInfo)
{

    DEBUG_FUNCTION_NAME(TEXT("FaxBrandDocument"));
    DWORD ec = ERROR_SUCCESS;

    if (!lpctsrtFile)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("NULL target file name"));
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (!lpcBrandInfo)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("NULL branding info"));
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }


    if (lpcBrandInfo->dwSizeOfStruct != sizeof(FSPI_BRAND_INFO))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Bad cover page info parameter, dwSizeOfStruct = %d"),
                     lpcBrandInfo->dwSizeOfStruct);
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }


    ec = BrandFax(lpctsrtFile, lpcBrandInfo);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("BrandFax() for file %s has failed (ec: %ld)"),
            lpctsrtFile,
            ec);
        goto Error;
    }
    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:

    return HRESULT_FROM_WIN32(ec);
}


PJOB_ENTRY
FindJob(
    IN HANDLE FaxHandle
    )

/*++

Routine Description:

    This fuction locates a FAX job by matching
    the FAX handle value.

Arguments:

    FaxHandle       - FAX handle returned from startjob

Return Value:

    NULL for failure.
    Valid pointer to a JOB_ENTRY on success.

--*/

{
    PLIST_ENTRY Next;
    PJOB_ENTRY JobEntry;


    EnterCriticalSection( &g_CsJob );

    Next = g_JobListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &g_CsJob );
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_JobListHead) {

        JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );

        if ((ULONG_PTR)JobEntry->InstanceData == (ULONG_PTR)FaxHandle) {

            LeaveCriticalSection( &g_CsJob );
            return JobEntry;

        }

        Next = JobEntry->ListEntry.Flink;

    }

    LeaveCriticalSection( &g_CsJob );
    return NULL;
}


BOOL
FindJobByJob(
    IN PJOB_ENTRY JobEntryToFind
    )

/*++

Routine Description:

    This fuction check whether a FAX job exist in g_JobListHead (Job's list)

Arguments:

    JobEntryToFind   - PJOB_ENTRY from StartJob()

Return Value:

    TRUE  - if the job was found
    FALSE - otherwise

--*/

{
    PLIST_ENTRY Next;
    PJOB_ENTRY JobEntry;

    Assert(JobEntryToFind);

    EnterCriticalSection( &g_CsJob );

    Next = g_JobListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &g_CsJob );
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_JobListHead) {

        JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );

        if (JobEntry == JobEntryToFind) {

            LeaveCriticalSection( &g_CsJob );
            return TRUE;

        }

        Next = JobEntry->ListEntry.Flink;

    }

    LeaveCriticalSection( &g_CsJob );
    return FALSE;
}


BOOL
FaxSendCallback(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    )

/*++

Routine Description:

    This fuction is called asychronously by a FAX device
    provider after a call is established.  The sole purpose
    of the callback is to communicate the call handle from the
    device provider to the FAX service.

Arguments:

    FaxHandle       - FAX handle returned from startjob
    CallHandle      - Call handle for newly initiated call
    Reserved1       - Always zero.
    Reserved2       - Always zero.

Return Value:

    TRUE for success, FAX operation continues.
    FALSE for failure, FAX operation is terminated.

--*/

{
    PJOB_ENTRY JobEntry = NULL;
    BOOL bRes = FALSE;

    EnterCriticalSection(&g_CsJob);
    JobEntry = FindJob( FaxHandle );
    if (JobEntry)
    {
        if (NULL == JobEntry->CallHandle)
        {
            JobEntry->CallHandle = CallHandle;      
        }
        
        bRes = (JobEntry->CallHandle == CallHandle) ? TRUE : FALSE;
    } 
    LeaveCriticalSection(&g_CsJob);
	if (FALSE == bRes)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}
    return bRes;
}


//*********************************************************************************
//* Name:   CreateCoverpageTiffFileEx()
//* Author: Ronen Barenboim
//* Date:   March 24, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Generates cover page TIFF file from the specified cover page template
//*     and new Client API parameters.
//*     The function returns the name of the generated file.
//* PARAMETERS:
//*     Resolution    [IN]
//*
//*     dwPageCount [IN]
//*
//*     lpcCoverpageEx [IN]
//*
//*     lpcRecipient [IN]
//*
//*     lpcSender [IN]
//*
//*     lpcwstrExtension [IN] - File extension (optional).
//*
//*     lpwstrCovTiffFile [OUT]
//*         A pointer to Unicode string buffer where the function will place
//*         the full path to the generated cover page TIFF file.         
//*		
//*		dwCovTiffFileCount [IN] - size of the buffer pointed by lpwstrCovTiffFile.
//*		
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise. Use GetLastError() to figure out why it failed.
//*
//* REMARKS:
//*     The function does not allocate any memory.
//*********************************************************************************
BOOL
CreateCoverpageTiffFileEx(
    IN short                        Resolution,
    IN DWORD                        dwPageCount,
    IN LPCFAX_COVERPAGE_INFO_EXW  lpcCoverpageEx,
    IN LPCFAX_PERSONAL_PROFILEW  lpcRecipient,
    IN LPCFAX_PERSONAL_PROFILEW  lpcSender,
    IN LPCWSTR                   lpcwstrExtension,
    OUT LPWSTR lpwstrCovTiffFile,
	IN DWORD dwCovTiffFileCount)
{
    FAX_COVERPAGE_INFOW2 covLegacy;
    BOOL                bRes = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("CreateCoverpageTiffFileEx"));

    Assert(lpcCoverpageEx);
    Assert(lpcRecipient);
    Assert(lpcSender);
    Assert(lpwstrCovTiffFile);

    //
    // Prepare a legacy FAX_COVERPAGE_INFO from the new cover page info
    //
    memset(&covLegacy,0,sizeof(covLegacy));
    covLegacy.SizeOfStruct=sizeof(covLegacy);
    covLegacy.CoverPageName=lpcCoverpageEx->lptstrCoverPageFileName;
    covLegacy.UseServerCoverPage=lpcCoverpageEx->bServerBased;
    covLegacy.RecCity=lpcRecipient->lptstrCity;
    covLegacy.RecCompany=lpcRecipient->lptstrCompany;
    covLegacy.RecCountry=lpcRecipient->lptstrCountry;
    covLegacy.RecDepartment=lpcRecipient->lptstrDepartment;
    covLegacy.RecFaxNumber=lpcRecipient->lptstrFaxNumber;
    covLegacy.RecHomePhone=lpcRecipient->lptstrHomePhone;
    covLegacy.RecName=lpcRecipient->lptstrName;
    covLegacy.RecOfficeLocation=lpcRecipient->lptstrOfficeLocation;
    covLegacy.RecOfficePhone=lpcRecipient->lptstrOfficePhone;
    covLegacy.RecState=lpcRecipient->lptstrState;
    covLegacy.RecStreetAddress=lpcRecipient->lptstrStreetAddress;
    covLegacy.RecTitle=lpcRecipient->lptstrTitle;
    covLegacy.RecZip=lpcRecipient->lptstrZip;
    covLegacy.SdrName=lpcSender->lptstrName;
    covLegacy.SdrFaxNumber=lpcSender->lptstrFaxNumber;
    covLegacy.SdrCompany=lpcSender->lptstrCompany;
    covLegacy.SdrTitle=lpcSender->lptstrTitle;
    covLegacy.SdrDepartment=lpcSender->lptstrDepartment;
    covLegacy.SdrOfficeLocation=lpcSender->lptstrOfficeLocation;
    covLegacy.SdrHomePhone=lpcSender->lptstrHomePhone;
    covLegacy.SdrAddress=lpcSender->lptstrStreetAddress;
    covLegacy.SdrOfficePhone=lpcSender->lptstrOfficePhone;
	covLegacy.SdrEmail=lpcSender->lptstrEmail;
    covLegacy.Note=lpcCoverpageEx->lptstrNote;
    covLegacy.Subject=lpcCoverpageEx->lptstrSubject;
    covLegacy.PageCount=dwPageCount;

    //
    // Note covLegacy.TimeSent is not set. This field's value is
    // generated by FaxPrintCoverPageW().
    //

    //
    // Now call the legacy CreateCoverPageTiffFile() to generate the cover page file
    //
    if (!CreateCoverpageTiffFile(Resolution, &covLegacy, lpcwstrExtension, lpwstrCovTiffFile, dwCovTiffFileCount))
	{
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to generate cover page file for recipient %s@%s. (ec: %ld)"),
            lpcRecipient->lptstrName,
            lpcRecipient->lptstrFaxNumber,
            GetLastError()
            );
        bRes = FALSE;
    }

    return bRes;
}


LPWSTR
GetFaxPrinterName(
    VOID
    )
{
    PPRINTER_INFO_2 PrinterInfo;
    DWORD i;
    DWORD Count;


    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &Count, 0 );
    if (PrinterInfo == NULL)
    {
        if (ERROR_SUCCESS == GetLastError())
        {
            //
            // No printers are installed
            //
            SetLastError(ERROR_INVALID_PRINTER_NAME);
        }
        return NULL;
    }

    for (i=0; i<Count; i++)
    {
        if (_wcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0 &&
            _wcsicmp( PrinterInfo[i].pPortName, FAX_PORT_NAME ) == 0)
        {
            LPWSTR p = (LPWSTR) StringDup( PrinterInfo[i].pPrinterName );
            MemFree( PrinterInfo );
            if (NULL == p )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
            return p;
        }
    }

    MemFree( PrinterInfo );
    SetLastError (ERROR_INVALID_PRINTER_NAME);
    return NULL;
}

VOID
FreeCpFields(
    PCOVERPAGEFIELDS pCpFields
    )

/*++

Routine Description:

    Frees all memory associated with a coverpage field structure.


Arguments:

    CpFields    - Pointer to a coverpage field structure.

Return Value:

    None.

--*/

{
    DWORD i; 
    LPTSTR* lpptstrString;

    for (i = 0; i < NUM_INSERTION_TAGS; i++)
    {
        lpptstrString = (LPTSTR*) ((LPBYTE)(&(pCpFields->RecName)) + (i * sizeof(LPTSTR)));        
        MemFree (*lpptstrString) ;              
    }
}


BOOL
FillCoverPageFields(
    IN const FAX_COVERPAGE_INFOW2* pFaxCovInfo,
    OUT PCOVERPAGEFIELDS pCPFields)
/*++

Author:

      Oded Sacher 27-June-2001

Routine Description:

    Fills a COVERPAGEFIELDS structure from the content of a FAX_COVERPAGE_INFO structure.
    Used to prepare a COVERPAGEFIELDS structure for cover page rendering before rendering cover page.

Arguments:

    [IN] pFaxCovInfo - Pointer to a FAX_COVERPAGE_INFO that holds the information to be extracted.

    [OUT] pCPFields - Pointer to a COVERPAGEFIELDS structure that gets filled with
                                      the information from FAX_COVERPAGE_INFO.

Return Value:

    BOOL

Comments:
    The function allocates memory. 
    Call FreeCoverPageFields to free resources.


--*/
{
    DWORD dwDateTimeLen;
    DWORD cch;
    LPTSTR s;
    DWORD ec = 0;
    LPCTSTR *src;
    LPCTSTR *dst;
    DWORD i;
    TCHAR szTimeBuffer[MAX_PATH] = {0};
    TCHAR szNumberOfPages[12] = {0};


    Assert(pFaxCovInfo);
    Assert(pCPFields);

    memset(pCPFields,0,sizeof(COVERPAGEFIELDS));

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    pCPFields->RecName = StringDup(pFaxCovInfo->RecName);
    pCPFields->RecFaxNumber = StringDup(pFaxCovInfo->RecFaxNumber);
    pCPFields->Subject = StringDup(pFaxCovInfo->Subject);
    pCPFields->Note = StringDup(pFaxCovInfo->Note);
    pCPFields->NumberOfPages = StringDup(_itot( pFaxCovInfo->PageCount, szNumberOfPages, 10 ));

   for (i = 0;
         i <= ((LPBYTE)&pFaxCovInfo->SdrEmail - (LPBYTE)&pFaxCovInfo->RecCompany)/sizeof(LPCTSTR);
         i++)
    {
        src = (LPCTSTR *) ((LPBYTE)(&pFaxCovInfo->RecCompany) + (i*sizeof(LPCTSTR)));
        dst = (LPCTSTR *) ((LPBYTE)(&(pCPFields->RecCompany)) + (i*sizeof(LPCTSTR)));

        if (*dst)
        {
            MemFree ( (LPBYTE) *dst ) ;
        }
        *dst = (LPCTSTR) StringDup( *src );
    }

    //
    // the time the fax was sent
    //
    GetLocalTime((LPSYSTEMTIME)&pFaxCovInfo->TimeSent);
    //
    // dwDataTimeLen is the size of s in characters
    //
    dwDateTimeLen = ARR_SIZE(szTimeBuffer);
    s = szTimeBuffer;
    //
    // Get date into s
    //
    GetY2KCompliantDate( LOCALE_USER_DEFAULT, 0, &pFaxCovInfo->TimeSent, s, dwDateTimeLen );
    //
    // Advance s past the date string and attempt to append time
    //
    cch = _tcslen( s );
    s += cch;
    
    if (++cch < dwDateTimeLen)
    {
        *s++ = ' ';
        //
        // DateTimeLen is the decreased by the size of s in characters
        //
        dwDateTimeLen -= cch;
        // 
        // Get the time here
        //
        FaxTimeFormat( LOCALE_USER_DEFAULT, 0, &pFaxCovInfo->TimeSent, NULL, s, dwDateTimeLen );
    }

    pCPFields->TimeSent = StringDup( szTimeBuffer );

    return TRUE;
}


//*****************************************************************************
//* Name:   CreateCoverpageTiffFile
//* Author:
//*****************************************************************************
//* DESCRIPTION:
//*     Renders the specified coverpage into a temp TIFF file and returns the name
//*     of the temp TIFF file.
//* PARAMETERS:
//*     [IN] IN short Resolution:
//*         196 for 200x200 resolution.
//*         98 for 200x100 resolution.
//*     [IN] FAX_COVERPAGE_INFOW *CoverpageInfo:
//*         A pointer to a FAX_COVERPAGE_INFOW structure that contains the cover page
//*         template information (see SDK help).
//*     [IM] LPCWSTR lpcwstrExtension - File extension (".TIF" if NULL)
//*
//*     [OUT] LPWSTR lpwstrCovTiffFile:
//*         A pointer to a buffer where the function returns the name of the temp file
//*         that contains the rendered cover page TIFF file.
//*		
//*		[IN] DWORD dwCovTiffFileCount:
//*			Size in TCHARs of the buffer pointed by lpwstrCovTiffFile.
//* RETURN VALUE:
//*         FALSE if the operation failed.
//*         TRUE is succeeded.
//* Comments:
//*         If the operation failes the function takes care of deleting any temp files.
//*****************************************************************************
BOOL
CreateCoverpageTiffFile(
    IN short Resolution,
    IN const FAX_COVERPAGE_INFOW2 *CoverpageInfo,
    IN LPCWSTR lpcwstrExtension,
    OUT LPWSTR lpwstrCovTiffFile,
	IN DWORD dwCovTiffFileCount
    )
{
    WCHAR TempFile[MAX_PATH];
    WCHAR wszCpName[MAX_PATH];
    LPWSTR FaxPrinter = NULL;            
    BOOL Rslt = TRUE;
    COVDOCINFO  covDocInfo;
    short Orientation = DMORIENT_PORTRAIT;      
    DWORD ec = ERROR_SUCCESS;
    COVERPAGEFIELDS CpFields = {0};
	HRESULT hr;
    DEBUG_FUNCTION_NAME(TEXT("CreateCoverpageTiffFile()"));

    LPCWSTR lpcwstrFileExt =  lpcwstrExtension ? lpcwstrExtension : FAX_TIF_FILE_EXT;
    TempFile[0] = L'\0';

    //
    // Validate the cover page and resolve the full path
    //
    if (!ValidateCoverpage((LPWSTR)CoverpageInfo->CoverPageName,
                           NULL,
                           CoverpageInfo->UseServerCoverPage,
                           wszCpName,
                           ARR_SIZE(wszCpName)))
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("ValidateCoverpage failed. ec = %ld"),
                     ec);
        Rslt=FALSE;
        goto Exit;
    }

    //
    // Collect the cover page fields
    //
    FillCoverPageFields( CoverpageInfo, &CpFields);

    FaxPrinter = GetFaxPrinterName();
    if (FaxPrinter == NULL)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxPrinterName failed. ec = %ld"),
            ec);
        Rslt=FALSE;
        goto Exit;
    }

    //
    // Get the cover page orientation
    //
    ec = PrintCoverPage(NULL, NULL, wszCpName, &covDocInfo); 
    if (ERROR_SUCCESS != ec)             
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PrintCoverPage for coverpage %s failed (ec: %ld)"),
            CoverpageInfo->CoverPageName,
            ec);
        Rslt=FALSE;
        goto Exit;        
    }

    if (!GenerateUniqueFileName( g_wszFaxQueueDir, (LPWSTR)lpcwstrFileExt, TempFile, sizeof(TempFile)/sizeof(WCHAR) ))
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate unique file name for merged TIFF file (ec: %ld)."), ec);
        Rslt=FALSE;
        goto Exit;
    }

    //
    // Change the default orientation if needed
    //
    if (covDocInfo.Orientation == DMORIENT_LANDSCAPE)
    {
        Orientation = DMORIENT_LANDSCAPE;
    }

    //
    // Render the cover page to a file
    //
    ec = PrintCoverPageToFile(
        wszCpName,
        TempFile,
        FaxPrinter,
        Orientation,
        Resolution,
        &CpFields); 
    if (ERROR_SUCCESS != ec)             
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PrintCoverPageToFile for coverpage %s failed (ec: %ld)"),
            CoverpageInfo->CoverPageName,
            ec);
        Rslt=FALSE;

        if (!DeleteFile( TempFile ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteFile for file %s failed (ec: %ld)"),
                TempFile,
                GetLastError());
        }
        goto Exit;        
    }      

	hr = StringCchCopy(
		lpwstrCovTiffFile,
		dwCovTiffFileCount,
		TempFile); 
	if (FAILED(hr))
	{
		DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringCchCopy for coverpage %s failed (ec: %ld)"),
            CoverpageInfo->CoverPageName,
            hr);
        Rslt=FALSE;
		ec = HRESULT_CODE(hr);

        if (!DeleteFile( TempFile ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteFile for file %s failed (ec: %ld)"),
                TempFile,
                GetLastError());
        }
        goto Exit;
	}		
    
    Rslt = TRUE;
    
Exit:
    MemFree(FaxPrinter);
    FreeCpFields(&CpFields);
    if (FALSE == Rslt)
    {
        ec = (ERROR_SUCCESS != ec) ? ec : ERROR_GEN_FAILURE;
        SetLastError(ec);
    }       
    return Rslt;
}


//*****************************************************************************
//* Name:   GetBodyTiffResolution
//* Author:
//*****************************************************************************
//* DESCRIPTION:
//*     Returns the body tiff file resolution. (200x200 or 200x100)
//*     The resolution is determined by the first page only!!
//* PARAMETERS:
//*
//*     [IN] LPCWSTR lpcwstrBodyFile - Body tiff file
//*
//*     [OUT] short* pResolution:
//*         A pointer to a short where the function returns the tiff resolution.
//*         TRUE is 200x200. FALSE is 200x100
//* RETURN VALUE:
//*         FALSE if the operation failed.
//*         TRUE is succeeded.
//* Comments:
//*****************************************************************************
BOOL
GetBodyTiffResolution(
    IN LPCWSTR lpcwstrBodyFile,
    OUT short*  pResolution
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetBodyTiffResolution"));
    TIFF_INFO TiffInfo;
    HANDLE hTiff = NULL;
    BOOL RetVal = TRUE;

    Assert (lpcwstrBodyFile && pResolution);

    //
    // open the tiff file
    //
    hTiff = TiffOpen( lpcwstrBodyFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (hTiff == NULL)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("TiffOpen() failed. Tiff file: %s"),
                lpcwstrBodyFile);
        RetVal = FALSE;
        goto exit;
    }

    if (TiffInfo.YResolution != 98 &&
        TiffInfo.YResolution != 196)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid Tiff Resolutoin. Tiff file: %s, YRes: %ld."),
                lpcwstrBodyFile,
                TiffInfo.YResolution);
        RetVal = FALSE;
        goto exit;
    }

    *pResolution = TiffInfo.YResolution;
    Assert (TRUE == RetVal);

exit:
    if (NULL != hTiff)
    {
        if (!TiffClose(hTiff))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TiffClose() failed. Tiff file: %s"),
                lpcwstrBodyFile);
        }
    }

    return RetVal;
}

//*********************************************************************************
//* Name:   CreateTiffFile ()
//* Author: Ronen Barenboim
//* Date:   March 24, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the TIFF file for a job queue.
//*
//*     The function deals with generating the cover page file and merging it
//*     with the body file (if a body exists).
//*     It returns the name of the TIFF file it generated. The caller must delete
//*     this file when it is no longer needed.
//* PARAMETERS:
//*     PJOB_QUEUE lpJob
//*         A pointer to a JOB_QUEUE structure that holds the recipient or routing job
//*         information.
//*     LPCWSTR lpcwstrFileExt - The new file extension (Null will create the default "*.TIF"
//*
//*     LPWSTR lpwstrFullPath - Pointer to a buffer to receive the full path to the new file
//*
//*		DWORD dwFullPathCount - size in TCHARs of the buffer pointed by lpwstrFullPath.          
//*
//* RETURN VALUE:
//*     TRUE if successful.
//*     FALSE otherwise.   Set last erorr on failure
//*********************************************************************************
BOOL
CreateTiffFile (
    PJOB_QUEUE lpJob,
    LPCWSTR lpcwstrFileExt,
    LPWSTR lpwstrFullPath,
	DWORD dwFullPathCount
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateTiffFile"));
    Assert(lpJob && lpwstrFullPath);
    Assert(JT_SEND == lpJob->JobType ||
           JT_ROUTING == lpJob->JobType);

    PJOB_QUEUE  lpParentJob = NULL;
    WCHAR szCoverPageTiffFile[MAX_PATH] = {0};
    LPCWSTR lpcwstrCoverPageFileName;
    LPCWSTR lpcwstrBodyFileName;
    short Resolution = 0; // Default resolution
    BOOL bRes = FALSE;
	HRESULT hr;

    if (JT_SEND == lpJob->JobType)
    {
        lpParentJob = lpJob->lpParentJob;
        Assert(lpParentJob);
    }

    lpcwstrCoverPageFileName = lpParentJob ? lpParentJob->CoverPageEx.lptstrCoverPageFileName : NULL;
    lpcwstrBodyFileName = lpParentJob ? lpParentJob->FileName : lpJob->FileName;

    if (!lpcwstrCoverPageFileName)
    {
        //
        // No cover page specified.
        // The TIFF to send is the body only.
        // Copy the body for each recipient
        //
        Assert(lpcwstrBodyFileName); // must have a body in this case.
        LPCWSTR lpcwstrExt = lpcwstrFileExt ? lpcwstrFileExt : FAX_TIF_FILE_EXT;

        if (!GenerateUniqueFileName( g_wszFaxQueueDir,
                                     (LPWSTR)lpcwstrExt,
                                     szCoverPageTiffFile,
                                     sizeof(szCoverPageTiffFile)/sizeof(WCHAR) ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GenerateUniqueFileName() failed (ec: %ld)."),
                GetLastError());
            goto Exit;
        }

        if (!CopyFile (lpcwstrBodyFileName, szCoverPageTiffFile, FALSE)) // FALSE - File already exist
        {
            DebugPrintEx(DEBUG_ERR,
                    TEXT("CopyFile Failed with %ld "),
                    GetLastError());
            DeleteFile(szCoverPageTiffFile);
            goto Exit;
        }

		hr = StringCchCopy(
			lpwstrFullPath,
			dwFullPathCount,
			szCoverPageTiffFile);
		if (FAILED(hr))
		{
			DebugPrintEx(DEBUG_ERR,
                    TEXT("StringCchCopy Failed with %ld "),
                    hr);
            DeleteFile(szCoverPageTiffFile);
			SetLastError(HRESULT_CODE(hr));			
		}
		else
		{
            bRes = TRUE;			
		}
        goto Exit;
    }

    //
    // There is a cover page so the tiff is either just the cover page or the cover page
    // merged with the body.
    //

    if (lpParentJob->FileName)
    {
        if (!GetBodyTiffResolution(lpParentJob->FileName, &Resolution))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetBodyTiffResolution() failed (ec: %ld)."),
                GetLastError());
            goto Exit;
        }
    }

    Assert (Resolution == 0 || Resolution == 98 || Resolution == 196);
    //
    // First create the cover page (This generates a file and returns its name).
    //
    if (!CreateCoverpageTiffFileEx(
                              Resolution,
                              lpJob->PageCount,
                              &lpParentJob->CoverPageEx,
                              &lpJob->RecipientProfile,
                              &lpParentJob->SenderProfile,
                              lpcwstrFileExt,
                              szCoverPageTiffFile,
							  ARR_SIZE(szCoverPageTiffFile)))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("[JobId: %ld] Failed to render cover page template %s"),
                     lpJob->JobId,
                     lpParentJob->CoverPageEx.lptstrCoverPageFileName);
        goto Exit;
    }

    if (lpParentJob->FileName)
    {
        //
        // There is a body file specified so merge the body and the cover page into
        // the file specified in szCoverPageTiffFile.
        //
        if (!MergeTiffFiles( szCoverPageTiffFile, lpParentJob->FileName))
		{
                DebugPrintEx(DEBUG_ERR,
                             TEXT("[JobId: %ld] Failed to merge cover (%ws) and body (%ws). (ec: %ld)"),
                             lpJob->JobId,
                             szCoverPageTiffFile,
                             lpParentJob->FileName,
                             GetLastError());
                //
                // Get rid of the coverpage TIFF we generated.
                //
                if (!DeleteFile(szCoverPageTiffFile))
				{
                    DebugPrintEx(DEBUG_ERR,
                             TEXT("[JobId: %ld] Failed to delete cover page TIFF file %ws. (ec: %ld)"),
                             lpJob->JobId,
                             szCoverPageTiffFile,
                             GetLastError());
                }
                goto Exit;
        }				
    }

	hr = StringCchCopy(
		lpwstrFullPath,
		dwFullPathCount,
		szCoverPageTiffFile);
	if (FAILED(hr))
	{
		DebugPrintEx(DEBUG_ERR,
                TEXT("StringCchCopy Failed with %ld "),
                hr);
        DeleteFile(szCoverPageTiffFile);
		SetLastError(HRESULT_CODE(hr));			
		goto Exit;
	}
    bRes =  TRUE;

Exit:
    if (FALSE == bRes)
    {
        //
        // Make sure we set last error
        //
        if (ERROR_SUCCESS == GetLastError())
        {
            SetLastError (ERROR_GEN_FAILURE);
        }
    }
    
    return bRes;
} // CreateTiffFile


BOOL
CreateTiffFileForJob (
    PJOB_QUEUE lpRecpJob
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateTiffFileForJob"));
    WCHAR wszFullPath[MAX_PATH] = {0};

    Assert(lpRecpJob);

    if (!CreateTiffFile (lpRecpJob, TEXT("FRT"), wszFullPath, ARR_SIZE(wszFullPath)))
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("CreateTiffFile failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (NULL == (lpRecpJob->FileName = StringDup(wszFullPath)))
    {
        DWORD dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            TEXT("StringDup failed. (ec: %ld)"),
            dwErr);

        if (!DeleteFile(wszFullPath))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("[JobId: %ld] Failed to delete TIFF file %ws. (ec: %ld)"),
                lpRecpJob->JobId,
                wszFullPath,
                GetLastError());
        }
        SetLastError(dwErr);
        return FALSE;
    }

    return TRUE;
}


BOOL
CreateTiffFileForPreview (
    PJOB_QUEUE lpRecpJob
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateTiffFileForPreview"));
    WCHAR wszFullPath[MAX_PATH] = {0};

    Assert(lpRecpJob);

    if (lpRecpJob->PreviewFileName)
    {
        return TRUE;
    }

    if (!CreateTiffFile (lpRecpJob, TEXT("PRV"), wszFullPath, ARR_SIZE(wszFullPath)))
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("CreateTiffFile failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (NULL == (lpRecpJob->PreviewFileName = StringDup(wszFullPath)))
    {
        DWORD dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            TEXT("StringDup failed. (ec: %ld)"),
            dwErr);

        if (!DeleteFile(wszFullPath))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("[JobId: %ld] Failed to delete TIFF file %ws. (ec: %ld)"),
                lpRecpJob->JobId,
                wszFullPath,
                GetLastError());
        }
        SetLastError(dwErr);
        return FALSE;
    }

    return TRUE;
}

DWORD
FaxRouteThread(
    PJOB_QUEUE lpJobQueueEntry
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    route an incoming job.

Arguments:

    lpJobQueueEntry  - A pointer to the job for which the routing
                        operation is to be performed.
Return Value:

    Always zero.

--*/
{
    BOOL Routed = TRUE;
    DWORD i;
    DWORD dwRes;
    DWORD CountFailureInfo = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxRouteThread"));

    EnterCriticalSectionJobAndQueue;
    CountFailureInfo = lpJobQueueEntry->CountFailureInfo;
    LeaveCriticalSectionJobAndQueue;

    for (i = 0; i < lpJobQueueEntry->CountFailureInfo; i++)
    {
        BOOL fRouteSucceed;

        fRouteSucceed = FaxRouteRetry( lpJobQueueEntry->FaxRoute, &lpJobQueueEntry->pRouteFailureInfo[i] );
        if (FALSE == fRouteSucceed)
        {
            PROUTING_METHOD pRoutingMethod = FindRoutingMethodByGuid( (lpJobQueueEntry->pRouteFailureInfo[i]).GuidString );
            if (pRoutingMethod)
            {
                WCHAR TmpStr[20] = {0};
				HRESULT hr = StringCchPrintf(
					TmpStr,
					ARR_SIZE(TmpStr),
					TEXT("0x%016I64x"),
					lpJobQueueEntry->UniqueId);
				if (FAILED(hr))
				{
					//
					// Should never happen, we use large enough buffer.
					//
					ASSERT_FALSE;
				}                

                FaxLog(FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MIN,
                    6,
                    MSG_FAX_ROUTE_METHOD_FAILED,
                    TmpStr,
                    lpJobQueueEntry->FaxRoute->DeviceName,
                    lpJobQueueEntry->FaxRoute->Tsid,
                    lpJobQueueEntry->FileName,
                    pRoutingMethod->RoutingExtension->FriendlyName,
                    pRoutingMethod->FriendlyName
                    );
            }
        }
        Routed &= fRouteSucceed;
    }

    EnterCriticalSectionJobAndQueue;

    lpJobQueueEntry->dwLastJobExtendedStatus = 0;
    lpJobQueueEntry->ExStatusString[0] = TEXT('\0');

    if ( Routed )
    {
        lpJobQueueEntry->JobStatus = JS_DELETING;
        DecreaseJobRefCount (lpJobQueueEntry, TRUE);
    }
    else
    {
        //
        // We failed to execute the routing method.
        // reschedule the job.
        //
        DWORD dwMaxRetries;

        EnterCriticalSection (&g_CsConfig);
        dwMaxRetries = g_dwFaxSendRetries;
        LeaveCriticalSection (&g_CsConfig);

        lpJobQueueEntry->SendRetries++;
        if (lpJobQueueEntry->SendRetries <= dwMaxRetries)
        {
            lpJobQueueEntry->JobStatus = JS_RETRYING;
            RescheduleJobQueueEntry( lpJobQueueEntry );
        }
        else
        {
            //
            // retries exceeded, mark job as expired
            //
            MarkJobAsExpired(lpJobQueueEntry);

            WCHAR TmpStr[20] = {0};
            HRESULT hr = StringCchPrintf(
					TmpStr,
					ARR_SIZE(TmpStr),
					TEXT("0x%016I64x"),
					lpJobQueueEntry->UniqueId);
			if (FAILED(hr))
			{
				//
				// Should never happen, we use large enough buffer.
				//
				ASSERT_FALSE;
			}  

            FaxLog(FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                3,
                MSG_FAX_ROUTE_FAILED,
                TmpStr,
                lpJobQueueEntry->FaxRoute->DeviceName,
                lpJobQueueEntry->FaxRoute->Tsid
                );
        }

        //
        // Create Fax EventEx
        //
        dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                   lpJobQueueEntry
                                 );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(   DEBUG_ERR,
                            _T("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) ")
                            _T("failed for job id %ld (ec: %lc)"),
                            lpJobQueueEntry->UniqueId,
                            dwRes);
        }

        if (!UpdatePersistentJobStatus(lpJobQueueEntry))
        {
            DebugPrintEx(   DEBUG_ERR,
                            _T("Failed to update persistent job status to 0x%08x"),
                            lpJobQueueEntry->JobStatus);
        }
    }

    LeaveCriticalSectionJobAndQueue;

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return ERROR_SUCCESS;
}


DWORD
FaxSendThread(
    PFAX_SEND_ITEM FaxSendItem
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    send a FAX document.  There is one send thread per outstanding
    FAX send operation.  The thread ends when the document is
    either successfuly sent or the operation is aborted.

Arguments:

    FaxSendItem     - pointer to a FAX send item packet that
                      describes the requested FAX send operation.

Return Value:

    Always zero.

--*/

{
    FAX_SEND FaxSend; // This structure is passed to FaxDevSend()
    BOOL Rslt = FALSE;
    BOOL Retrying = FALSE;

    BOOL bFakeJobStatus = FALSE;
    FSPI_JOB_STATUS FakedJobStatus = {0};
    DWORD  PageCount = 0;
    BOOL bRemoveParentJob = FALSE;  // TRUE if at the end of the send the parent job and all
                                    // recipients need to be removed.
    PJOB_QUEUE lpJobQueue = NULL ;  // Points to the Queue entry attached to the running job.
    LPFSPI_JOB_STATUS lpFSPStatus = NULL;
    LPFSPI_JOB_STATUS pOrigFaxStatus = NULL;
    DWORD dwSttRes;
    BOOL bBranding;
    DWORD dwJobId;
    BOOL bCreateTiffFailed = FALSE;
    BOOL fSetSystemIdleTimer = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("FaxSendThread"));

    Assert (FaxSendItem &&
            FaxSendItem->JobEntry &&
            FaxSendItem->JobEntry->LineInfo &&
            FaxSendItem->JobEntry->LineInfo->Provider);


    //
    // Don't let the system go to sleep in the middle of the fax transmission.
    //
    if (NULL == SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS))
    {
        fSetSystemIdleTimer = FALSE;
        DebugPrintEx(DEBUG_ERR,
            TEXT("SetThreadExecutionState() failed"));
    }

    lpJobQueue=FaxSendItem->JobEntry->lpJobQueueEntry;
    Assert(lpJobQueue);

    //
    // Set the information to be sent to FaxDevSend()
    // Note:
    //      The caller number is the sender TSID ! (we have no other indication of the sender phone number)
    //      This means that the FSP will get the sender TSID which might contain text as well (not just a number)
    //
    FaxSend.SizeOfStruct    = sizeof(FAX_SEND);

    FaxSend.CallerName      = FaxSendItem->SenderName;
    FaxSend.CallerNumber    = FaxSendItem->Tsid;
    FaxSend.ReceiverName    = FaxSendItem->RecipientName;
    FaxSend.ReceiverNumber  = FaxSendItem->PhoneNumber;
    FaxSend.CallHandle      = 0; // filled in later via TapiStatusThread, if appropriate
    FaxSend.Reserved[0]     = 0;
    FaxSend.Reserved[1]     = 0;
    FaxSend.Reserved[2]     = 0;

    //
    // Successfully created a new send job on a device. Update counter.
    //
    (VOID)UpdateDeviceJobsCounter (  FaxSendItem->JobEntry->LineInfo,   // Device to update
                                     TRUE,                              // Sending
                                     1,                                 // Number of new jobs
                                     TRUE);                             // Enable events
    
    if (!lpJobQueue->FileName)
    {
        //
        // We did not generate a body for this recipient yet. This is the
        // time to do so.
        //

        //
        // Set the right body for this job.
        // This is either the body specified at the parent or a merge of the body
        // with the cover page specified in the parent.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] Generating body for recipient job."),
            lpJobQueue->JobId
            );

        if (!CreateTiffFileForJob(lpJobQueue))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] CreateTiffFileForJob failed. (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError()
                );
            bCreateTiffFailed = TRUE;
        }
    }
    else
    {
        //
        // We already generated a body for this recipient.
        // somthing is wrong
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] Using cached body in %s."),
            lpJobQueue->JobId,
            lpJobQueue->FileName
            );

        Assert(FALSE);
    }

    if (bCreateTiffFailed ||
        NULL == (FaxSendItem->FileName = StringDup(lpJobQueue->FileName)))
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("[JobId: %ld] CreateTiffFileForJob or StringDup failed"),
               FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
               GetLastError());
        //
        // Simulate an FSP returning a FS_FATAL_ERROR code.
        //
        EnterCriticalSection(&g_CsJob);
        FreeFSPIJobStatus(&FaxSendItem->JobEntry->FSPIJobStatus, FALSE);
        FaxSendItem->JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_FAILED;
        FaxSendItem->JobEntry->FSPIJobStatus.dwExtendedStatus = FSPI_ES_FATAL_ERROR;

        if (!HandleFailedSendJob(FaxSendItem->JobEntry))
        {
           DebugPrintEx(
               DEBUG_ERR,
               TEXT("[JobId: %ld] HandleFailedSendJob() failed (ec: %ld)."),
               FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
               GetLastError());
        }
        LeaveCriticalSection(&g_CsJob);
        goto Exit;
    }
    FaxSend.FileName = FaxSendItem->FileName;

    //
    // Add branding banner (the line at the top of each page) to the fax if necessary.
    //

    //
    //  Our service takes care of branding so notify FSP not to brand
    //
    FaxSend.Branding = FALSE;

    EnterCriticalSection (&g_CsConfig);
    bBranding = g_fFaxUseBranding;
    LeaveCriticalSection (&g_CsConfig);

    if (bBranding)
    {
        FSPI_BRAND_INFO brandInfo;
        HRESULT hr;
        memset(&brandInfo,0,sizeof(FSPI_BRAND_INFO));
        brandInfo.dwSizeOfStruct=sizeof(FSPI_BRAND_INFO);
        brandInfo.lptstrRecipientPhoneNumber =  FaxSendItem->JobEntry->lpJobQueueEntry->RecipientProfile.lptstrFaxNumber;
        brandInfo.lptstrSenderCompany = FaxSendItem->SenderCompany;
        brandInfo.lptstrSenderTsid = FaxSendItem->Tsid;
        GetLocalTime( &brandInfo.tmDateTime); // can't fail
        hr = FaxBrandDocument(FaxSendItem->FileName,&brandInfo);
        if (FAILED(hr))
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FaxBrandDocument() failed. (hr: 0x%08X)"),
                lpJobQueue->JobId,
                hr);
            //
            // But we go on since it is better to send the fax without the branding
            // then lose it altogether.
            //
        }
    }


    FaxSendItem->JobEntry->LineInfo->State = FPS_INITIALIZING;
    
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[JobId: %ld] Calling FaxDevSend().\n\t File: %s\n\tNumber [%s]\n\thLine = 0x%08X\n\tCallHandle = 0x%08X"),
        lpJobQueue->JobId,
        FaxSend.FileName,
        FaxSendItem->JobEntry->DialablePhoneNumber,
        FaxSendItem->JobEntry->LineInfo->hLine,
        FaxSend.CallHandle
        );
    __try
    {

        //
        // Send the fax (This call is blocking)
        //
        Rslt = FaxSendItem->JobEntry->LineInfo->Provider->FaxDevSend(
            (HANDLE) FaxSendItem->JobEntry->InstanceData,
            &FaxSend,
            FaxSendCallback
            );
        if (!Rslt)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FaxDevSend() failed (ec: 0x%0X)"),
                lpJobQueue->JobId,
                GetLastError());
        }

    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, FaxSendItem->JobEntry->LineInfo->Provider->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }
    //
    // Get the final status of the job.
    //
    dwSttRes = GetDevStatus((HANDLE) FaxSendItem->JobEntry->InstanceData,
                                  FaxSendItem->JobEntry->LineInfo,
                                  &lpFSPStatus);

    if (ERROR_SUCCESS != dwSttRes)
    {
        //
        // Couldn't retrieve device status.
        // Fake one.
        //
        bFakeJobStatus = TRUE;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("[Job: %ld] GetDevStatus failed - %d"),
                     FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                     dwSttRes);
    }
    else if ((FSPI_JS_COMPLETED       != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_ABORTED         != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_FAILED          != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_DELETED         != lpFSPStatus->dwJobStatus) &&             
             (FSPI_JS_FAILED_NO_RETRY != lpFSPStatus->dwJobStatus))
    {
        //
        // Status returned is unacceptable - fake one.
        //
        bFakeJobStatus = TRUE;
        DebugPrintEx(DEBUG_WRN,
                     TEXT("[Job: %ld] GetDevStatus return unacceptable status - %d. Faking the status"),
                     FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                     lpFSPStatus->dwJobStatus);        

        pOrigFaxStatus = lpFSPStatus;
        memcpy (&FakedJobStatus, lpFSPStatus, sizeof (FakedJobStatus));
        if (lpFSPStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE)
        {
            //
            // The FSP returned proprietary status. 
            //
            FakedJobStatus.dwExtendedStatus = lpFSPStatus->dwExtendedStatus;
            FakedJobStatus.dwExtendedStatusStringId = lpFSPStatus->dwExtendedStatusStringId;
        }
        lpFSPStatus = NULL;
    }

    //
    // Enter critical section to block out FaxStatusThread
    //
    EnterCriticalSection( &g_CsJob );

    if (bFakeJobStatus)
    {
        //
        // Fake a job status
        //
        lpFSPStatus = &FakedJobStatus;
        FakedJobStatus.dwSizeOfStruct = sizeof (FakedJobStatus);
        if (Rslt)
        {
            //
            // Fake success
            //
            FakedJobStatus.dwJobStatus = FSPI_JS_COMPLETED;
            if (0 == FakedJobStatus.dwExtendedStatus)
            {
                //
                // The FSP did not report proprietary status
                //
                FakedJobStatus.dwExtendedStatus = FSPI_ES_CALL_COMPLETED;
            }
        }
        else
        {
            //
            // Fake failure
            //
            FakedJobStatus.dwJobStatus = FSPI_JS_FAILED;
            if (0 == FakedJobStatus.dwExtendedStatus)
            {
                //
                // The FSP did not report proprietary status
                //
                FakedJobStatus.dwExtendedStatus = FSPI_ES_FATAL_ERROR;
            }
        }
    }
    if (!UpdateJobStatus(FaxSendItem->JobEntry, lpFSPStatus))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] UpdateJobStatus() failed (ec: %ld)."),
            FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
            GetLastError());
        //
        // Fake a status (we must have some valid status in job entry)
        //
        FreeFSPIJobStatus(&FaxSendItem->JobEntry->FSPIJobStatus, FALSE);
        if (Rslt)
        {
            FaxSendItem->JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_COMPLETED;
            FaxSendItem->JobEntry->FSPIJobStatus.dwExtendedStatus = FSPI_ES_CALL_COMPLETED;
        }
        else
        {
            FaxSendItem->JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_FAILED;
            FaxSendItem->JobEntry->FSPIJobStatus.dwExtendedStatus = FSPI_ES_FATAL_ERROR;
        }
    }
    if (!bFakeJobStatus)
    {
        //
        // Note: The FSPI_JOB_STATUS that is returned by GetDevStatus() is
        // to be freed as one block.
        //
        MemFree(lpFSPStatus);
        lpFSPStatus = NULL;
    }
    else
    {
        //
        // This is a faked job status - pointing to a structure on the stack.
        //
        if (pOrigFaxStatus)
        {
            //
            // The FSP reported some status but we faked it.
            // This is a good time to also free it
            //
            MemFree (pOrigFaxStatus);
            pOrigFaxStatus = NULL;
        }
    }

    //
    // Block FaxStatusThread from changing this status
    //
    FaxSendItem->JobEntry->fStopUpdateStatus = TRUE;
    LeaveCriticalSection( &g_CsJob );

    if (!Rslt)
    {
        if (!HandleFailedSendJob(FaxSendItem->JobEntry))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] HandleFailedSendJob() failed (ec: %ld)."),
                FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                GetLastError());
        }
    }
    else
    {
        //
        // cache the job id since we need id to create the FEI_COMPLETED event
        // and when it is generated the job may alrady be gone
        //
        dwJobId = FaxSendItem->JobEntry->lpJobQueueEntry->JobId;

        if (!HandleCompletedSendJob(FaxSendItem->JobEntry))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] HandleCompletedSendJob() failed (ec: %ld)."),
                FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                GetLastError());
        }
        //
        // The send job is completed. For W2K backward compatibility we should notify
        // FEI_DELETED since the job was allways removed when completed.
        //
        if (!CreateFaxEvent(0, FEI_DELETED, dwJobId))
        {

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (ec: %ld)"),
                FEI_DELETED,
                dwJobId,
                0,
                GetLastError());
        }
    }

Exit:

    MemFree( FaxSendItem->FileName );
    MemFree( FaxSendItem->PhoneNumber );
    MemFree( FaxSendItem->Tsid );
    MemFree( FaxSendItem->RecipientName );
    MemFree( FaxSendItem->SenderName );
    MemFree( FaxSendItem->SenderDept );
    MemFree( FaxSendItem->SenderCompany );
    MemFree( FaxSendItem->BillingCode );
    MemFree( FaxSendItem->DocumentName );
    MemFree( FaxSendItem );

    //
    // Let the system go back to sleep. Set the system idle timer.
    //
    if (TRUE == fSetSystemIdleTimer)
    {
        if (NULL == SetThreadExecutionState(ES_CONTINUOUS))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("SetThreadExecutionState() failed"));
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return 0;
}


//*********************************************************************************
//* Name:   IsSendJobReadyForDeleting()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Determines if an outgoing job is ready for deleting.
//*     A job is ready for deleting when all of the recipients
//*     are in the canceled state or or in the completed state.
//* PARAMETERS:
//*     [IN] PJOB_QUEUE lpRecipientJob
//*
//* RETURN VALUE:
//*     TRUE
//*         If the job is ready for deleting.
//*     FALSE
//*         If the job is not ready for deleting.
//*********************************************************************************
BOOL IsSendJobReadyForDeleting(PJOB_QUEUE lpRecipientJob)
{
    DEBUG_FUNCTION_NAME(TEXT("IsSendJobReadyForDeleting"));
    Assert (lpRecipientJob);
    Assert (lpRecipientJob->JobType == JT_SEND);

    PJOB_QUEUE lpParentJob = lpRecipientJob->lpParentJob;
    Assert(lpParentJob); // must have a parent job
    Assert(lpParentJob->dwRecipientJobsCount>0);
    Assert(lpParentJob->dwCompletedRecipientJobsCount +
           lpParentJob->dwCanceledRecipientJobsCount +
           lpParentJob->dwFailedRecipientJobsCount
           <= lpParentJob->dwRecipientJobsCount);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[JobId: %ld] [Total Rec = %ld] [Canceled Rec = %ld] [Completed Rec = %ld] [Failed Rec = %ld] [RefCount = %ld]"),
        lpParentJob->JobId,
        lpParentJob->dwRecipientJobsCount,
        lpParentJob->dwCanceledRecipientJobsCount,
        lpParentJob->dwCompletedRecipientJobsCount,
        lpParentJob->dwFailedRecipientJobsCount,
        lpParentJob->RefCount);


    if ( (lpParentJob->dwCompletedRecipientJobsCount +
          lpParentJob->dwCanceledRecipientJobsCount  +
          lpParentJob->dwFailedRecipientJobsCount) == lpParentJob->dwRecipientJobsCount )
    {
        return TRUE;
    }
    return FALSE;
}


BOOL FreeJobEntry(PJOB_ENTRY lpJobEntry , BOOL bDestroy)
{
    DEBUG_FUNCTION_NAME(TEXT("FreeJobEntry"));
    Assert(lpJobEntry);
    DWORD ec = ERROR_SUCCESS;
    DWORD dwJobID = lpJobEntry->lpJobQueueEntry ? lpJobEntry->lpJobQueueEntry->JobId : 0xffffffff; // 0xffffffff for invalid job ID

    EnterCriticalSection(&g_CsJob);
   
    //
    // Since CreateJobEntry() called OpenTapiLine() for TAPI lines
    // we need to close it here.
    // Note that the line might alrady be released since ReleaseJob()
    // releases the line but does not free the job entry.
    //
    if (!lpJobEntry->Released)
    {
        if (lpJobEntry->LineInfo->State != FPS_NOT_FAX_CALL) {
            DebugPrintEx( DEBUG_MSG,
                      TEXT("[Job Id: %ld] Before Releasing tapi line hCall=0x%08X hLine=0x%08X"),
                      dwJobID,
                      lpJobEntry->CallHandle,
                      lpJobEntry->LineInfo->hLine
                      );

            ReleaseTapiLine( lpJobEntry->LineInfo, lpJobEntry->CallHandle );
            lpJobEntry->CallHandle = 0;
            lpJobEntry->Released = TRUE;
        }
    }

    //
    // Remove the job from the running job list
    //
    RemoveEntryList( &lpJobEntry->ListEntry );    

    //
    // Cut the link between the line and the job
    //
    EnterCriticalSection( &g_CsLine );
    lpJobEntry->LineInfo->JobEntry = NULL;
    LeaveCriticalSection( &g_CsLine );    

    if (!FreeFSPIJobStatus(&lpJobEntry->FSPIJobStatus, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[Job Id: %ld] FreeFSPIJobStatus() failed (ec: %ld)"),
            dwJobID,
            GetLastError);
    }
    
    MemFree(lpJobEntry->lpwstrJobTsid);
    lpJobEntry->lpwstrJobTsid = NULL;

    if (bDestroy)
    {
        MemFree(lpJobEntry);
    }

    LeaveCriticalSection(&g_CsJob);

    return TRUE;
}


BOOL
EndJob(
    IN PJOB_ENTRY JobEntry
    )

/*++

Routine Description:

    This fuction calls the device provider's EndJob function.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    BOOL rVal = TRUE;
    PJOB_INFO_1 JobInfo = NULL;
    DEBUG_FUNCTION_NAME(TEXT("End Job"));
    Assert(JobEntry);
    DWORD dwJobID = JobEntry->lpJobQueueEntry ? JobEntry->lpJobQueueEntry->JobId : 0xffffffff; // 0xffffffff for invalid job ID


    EnterCriticalSection( &g_CsJob );

    if (!FindJobByJob( JobEntry ))
    {
        //
        // if we get here then it means we hit a race
        // condition where the FaxSendThread called EndJob
        // at the same time that a client app did.
        //
        DebugPrintEx(DEBUG_WRN,TEXT("EndJob() could not find the Job"), dwJobID);
        LeaveCriticalSection( &g_CsJob );
        return ERROR_SUCCESS;
    }


    if (JobEntry->bFSPJobInProgress)
    {
        //
        // If FaxDevEndJob was not yet called for the job then do it now.
        // ( The case in which the line is already released occcurs in a
        //   receive job where we first ReleaseJob() to release the line but
        //   continue to do the inbound routing and only then call EndJob()).
        //

        __try
        {
            DebugPrintEx( DEBUG_MSG,
                          TEXT("[Job Id: %ld] Legacy FSP job is in progress. Calling FaxDevEndJob()"),
                          dwJobID);

            rVal = JobEntry->LineInfo->Provider->FaxDevEndJob(
                (HANDLE) JobEntry->InstanceData
                );
            if (!rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("[Job Id: %ld] FaxDevEndJob() failed"),
                    dwJobID);
            }
            else
            {
                DebugPrintEx( DEBUG_MSG,
                          TEXT("[Job Id: %ld] FaxDevEndJob() succeeded."),
                          dwJobID);
                JobEntry->bFSPJobInProgress = FALSE;
            }


        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, JobEntry->LineInfo->Provider->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }

    }
    else
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job Id: %ld] FaxDevEndJob() NOT CALLED since legacy FSP job is not in progress."),
            dwJobID);
    }


    if (FreeJobEntry(JobEntry, TRUE))
    {
        JobEntry = NULL;
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to free a job entry (%x)."),
            JobEntry);
        ASSERT_FALSE;
    }

    //
    // There could have been a request to change the port status while we were handling this job.
    // We allow the caller to modify a few of these requests to succeed, like the ring count for instance.
    // While we still have the job critical section, let's make sure that we commit any requested changes to the
    // registry.  This should be a fairly quick operation.
    //

    LeaveCriticalSection( &g_CsJob );


    return rVal;
}

//*********************************************************************************
//* Name:   ReleaseJob()
//* Author: Ronen Barenboim
//* Date:   April 18, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Calls the FSP to end the specified job (FaxDevEndJob()).
//*     Releases the line that was assigned to the job.
//*     NOTE: The job itself is NOT DELETED and is NOT remvoed from the running
//*           job list !!!
//*
//* PARAMETERS:
//*     [IN/OUT]    PJOB_ENTRY JobEntry
//*         A pointer to the JOB_ENTRY to be ended.
//* RETURN VALUE:
//* REMARKS:
//* If the function is successful then:
//*     JobEntry->Released = TRUE
//*     JobEntry->hLine = 0
//*     JobEntry->CallHandle = 0
//*********************************************************************************
BOOL
ReleaseJob(
    IN PJOB_ENTRY JobEntry
    )
{
    BOOL rVal = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("ReleaseJob"));
    Assert(JobEntry);
    Assert(JobEntry->lpJobQueueEntry);

    if (!FindJobByJob( JobEntry )) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("[JobId: %ld] was not found in the running job list."),
            JobEntry->lpJobQueueEntry->JobId);
        return TRUE;
    }

    EnterCriticalSection( &g_CsJob );

    Assert(JobEntry->LineInfo);
    Assert(JobEntry->LineInfo->Provider);
    Assert(JobEntry->bFSPJobInProgress);

    __try 
    {
        rVal = JobEntry->LineInfo->Provider->FaxDevEndJob(
            (HANDLE) JobEntry->InstanceData
            );
        if (!rVal) 
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FaxDevEndJob() failed (ec: 0x%0X)"),
                JobEntry->lpJobQueueEntry->JobId,
                GetLastError());
        }
        else
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("[Job Id: %ld] FaxDevEndJob() succeeded."),
                JobEntry->lpJobQueueEntry->JobId);
            JobEntry->bFSPJobInProgress = FALSE;
        }

    } 
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, JobEntry->LineInfo->Provider->FriendlyName, GetExceptionCode())) 
    {
        ASSERT_FALSE;
    }

    if (JobEntry->LineInfo->State != FPS_NOT_FAX_CALL)
    {
        if( !ReleaseTapiLine( JobEntry->LineInfo, JobEntry->CallHandle ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseTapiLine() failed "));
        }
        JobEntry->CallHandle = 0;
    }
    else
    {
        //
        // FSP_NOT_FAX_CALL indicates a received call that was handed off to RAS.
        // In this case we do not want to mark the line as released since it is in
        // use by RAS. We will use TAPI evens that indicate the line was released to update
        // the line info.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] A call is being handed off to RAS. Line 0x%08X not marked as released."),
            JobEntry->lpJobQueueEntry->JobId,
            JobEntry->LineInfo->hLine);
    }

    JobEntry->Released = TRUE;
    //
    // Cut the link between the line and the job
    //
    EnterCriticalSection( &g_CsLine );
    JobEntry->LineInfo->JobEntry = NULL;
    LeaveCriticalSection( &g_CsLine );

    LeaveCriticalSection( &g_CsJob );

    return rVal;
}



//*********************************************************************************
//* Name:   SendDocument()
//* Author: Ronen Barenboim
//* Date:   March 21, 1999
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     lpJobEntry
//*         A pointer to a JOB_ENTRY structure that was created using StartJob().
//*     FileName
//*         The path to the TIFF containing the TIFF to send
//*
//* RETURN VALUE:
//*
//*********************************************************************************
DWORD
SendDocument(
    PJOB_ENTRY  lpJobEntry,
    LPTSTR      FileName
    )
{
    PFAX_SEND_ITEM FaxSendItem;
    DWORD ThreadId;
    HANDLE hThread;
    PJOB_QUEUE lpJobQueue;
    DWORD nRes;
    DWORD ec = ERROR_SUCCESS;
    BOOL bUseDeviceTsid;
    WCHAR       wcZero = L'\0';

    STRING_PAIR pairs[8];

    DEBUG_FUNCTION_NAME(TEXT("SendDocument"));

    Assert(lpJobEntry);

    lpJobQueue=lpJobEntry->lpJobQueueEntry;
    Assert(lpJobQueue &&
           JS_INPROGRESS == lpJobQueue->JobStatus);

    FaxSendItem = (PFAX_SEND_ITEM) MemAlloc(sizeof(FAX_SEND_ITEM));
    if (!FaxSendItem)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    //
    // Pack all the thread parameters into a FAX_SEND_ITEM structure.
    //
    pairs[0].lptstrSrc = lpJobEntry->DialablePhoneNumber; // Use the job entry phone number since it is alrady translated
    pairs[0].lpptstrDst = &FaxSendItem->PhoneNumber;
    pairs[1].lptstrSrc = lpJobQueue->RecipientProfile.lptstrName;
    pairs[1].lpptstrDst = &FaxSendItem->RecipientName;
    pairs[2].lptstrSrc = lpJobQueue->SenderProfile.lptstrName;
    pairs[2].lpptstrDst = &FaxSendItem->SenderName;
    pairs[3].lptstrSrc = lpJobQueue->SenderProfile.lptstrDepartment;
    pairs[3].lpptstrDst = &FaxSendItem->SenderDept;
    pairs[4].lptstrSrc = lpJobQueue->SenderProfile.lptstrCompany;
    pairs[4].lpptstrDst = &FaxSendItem->SenderCompany;
    pairs[5].lptstrSrc = lpJobQueue->SenderProfile.lptstrBillingCode;
    pairs[5].lpptstrDst = &FaxSendItem->BillingCode;
    pairs[6].lptstrSrc = lpJobQueue->JobParamsEx.lptstrDocumentName;
    pairs[6].lpptstrDst = &FaxSendItem->DocumentName;
    pairs[7].lptstrSrc = NULL;
    pairs[7].lpptstrDst = &FaxSendItem->Tsid;

    FaxSendItem->JobEntry = lpJobEntry;
    FaxSendItem->FileName = NULL; // Set by FaxSendThread

    EnterCriticalSection (&g_CsConfig);
    bUseDeviceTsid = g_fFaxUseDeviceTsid;
    LeaveCriticalSection (&g_CsConfig);

    if (!bUseDeviceTsid)
    {
    // Check Sender Tsid
        if  ( lpJobQueue->SenderProfile.lptstrTSID &&
            (lpJobQueue->SenderProfile.lptstrTSID[0] != wcZero))
        {
           pairs[7].lptstrSrc        = lpJobQueue->SenderProfile.lptstrTSID;
        }
        else
        {
        // Use Fax number
            if  ( lpJobQueue->SenderProfile.lptstrFaxNumber &&
                (lpJobQueue->SenderProfile.lptstrFaxNumber[0] != wcZero))
            {
                pairs[7].lptstrSrc      = lpJobQueue->SenderProfile.lptstrFaxNumber;
            }
        }
    }
    else
    {
        // Use device Tsid
        pairs[7].lptstrSrc     = lpJobEntry->LineInfo->Tsid;
    }

    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        ec=GetLastError();
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MultiStringDup failed to copy string with index %d. (ec: %ld)"),
            nRes-1,
            ec);
        goto Error;
    }

    EnterCriticalSection (&g_CsJob);
    lpJobEntry->lpwstrJobTsid = StringDup (FaxSendItem->Tsid);
    LeaveCriticalSection (&g_CsJob);
    if (NULL != FaxSendItem->Tsid && NULL == lpJobEntry->lpwstrJobTsid)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("StringDup failed (ec: 0x%0X)"),ec);
        goto Error;
    }

    hThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxSendThread,
        (LPVOID) FaxSendItem,
        0,
        &ThreadId
        );

    if (!hThread)
    {
        ec=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("CreateThreadAndRefCount for FaxSendThread failed (ec: 0x%0X)"),ec);
        goto Error;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("FaxSendThread thread created for job id %d (thread id: 0x%0x)"),lpJobQueue->JobId,ThreadId);
    }

    CloseHandle( hThread );

    Assert (ERROR_SUCCESS == ec);
    goto Exit;

Error:
    Assert (ERROR_SUCCESS != ec);

    if ( FaxSendItem )
    {
        MemFree( FaxSendItem->FileName );
        MemFree( FaxSendItem->PhoneNumber );
        MemFree( FaxSendItem->Tsid );
        MemFree( FaxSendItem->RecipientName );
        MemFree( FaxSendItem->SenderName );
        MemFree( FaxSendItem->SenderDept );
        MemFree( FaxSendItem->SenderCompany );
        MemFree( FaxSendItem->BillingCode );
        MemFree( FaxSendItem->DocumentName );
        MemFree( FaxSendItem );
    }

    if (0 == lpJobQueue->dwLastJobExtendedStatus)
    {
        //
        // Job was never really executed - this is a fatal error
        //
        lpJobQueue->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
		lpJobQueue->ExStatusString[0] = L'\0';        
    }
    if (!MarkJobAsExpired(lpJobQueue))
    {
        DEBUG_ERR,
        TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
        lpJobQueue->JobId,
        GetLastError();
    }


    EndJob(lpJobEntry);
    lpJobQueue->JobEntry = NULL;

Exit:
     return ec;

}



DWORD
FaxStatusThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    query the status of all outstanding fax jobs.  The status
    is updated in the JOB_ENTRY structure and the print job
    is updated with a explanitory string.

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/

{
    PJOB_ENTRY JobEntry;
    PFAX_DEV_STATUS FaxStatus;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    DWORD dwEventId;

    DEBUG_FUNCTION_NAME(TEXT("FaxStatusThread"));

    while( TRUE )
    {
        Rval = GetQueuedCompletionStatus(
            g_StatusCompletionPortHandle,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &FaxStatus,
            INFINITE
            );
        if (!Rval)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"), GetLastError() );
            continue;
        }

        if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {
            //
            // Service is shutting down
            //
            DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down"));
            //
            //  Notify all FaxStatusThreads to terminate
            //
            if (!PostQueuedCompletionStatus( g_StatusCompletionPortHandle,
                                             0,
                                             SERVICE_SHUT_DOWN_KEY,
                                             (LPOVERLAPPED) NULL))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - FaxStatusThread). (ec: %ld)"),
                    GetLastError());
            }
            break;
        }
        
        //
        // (else we're dealing with a status update from an FSP)
        //

        BOOL fBadComletionKey = TRUE;
        PLINE_INFO pLineInfo = (PLINE_INFO)CompletionKey;

        fBadComletionKey = pLineInfo->Signature != LINE_SIGNATURE;

        if (fBadComletionKey)
        {
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Bad completion key: 0x%08x"),
                         CompletionKey);
            continue;
        }

        BOOL fBadFaxStatus = TRUE;

        fBadFaxStatus = FaxStatus->SizeOfStruct != sizeof(FAX_DEV_STATUS);
        if (fBadFaxStatus)
        {
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Bad FAX_DEV_STATUS: 0x%08x"),
                         FaxStatus);
            continue;
        }

        EnterCriticalSection( &g_CsJob );
        JobEntry = pLineInfo->JobEntry;
        if (!JobEntry)
        {
            //
            // The FSP reported a status on a LineInfo for which the running
            // job no longer exists.
            //
            //
            // Free the completion packet memory
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Provider [%s] reported a status packet that was processed after the job entry was already released.\n")
                TEXT("StatusId : 0x%08x\n")
                TEXT("Line: %s\n")
                TEXT("Packet address: %p\n")
                TEXT("Heap: %p"),
                pLineInfo->Provider->ProviderName,
                FaxStatus->StatusId,
                pLineInfo->DeviceName,
                FaxStatus,
                pLineInfo->Provider->HeapHandle);

            if (!HeapFree(pLineInfo->Provider->HeapHandle, 0, FaxStatus ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to free orphan device status (ec: %ld)"),
                    GetLastError());
                //
                // Nothing else we can do but report it in debug mode
                //
            }
            FaxStatus = NULL;
            LeaveCriticalSection( &g_CsJob );
            continue;
        }

        {
            DWORD dwJobStatus;
            DWORD dwExtendedStatus;
            BOOL bPrivateStatusCode;
                /*
                        *****
                        NTRAID#EdgeBugs-12680-2001/05/14-t-nicali

                               What if in the meantime another job is executing on the
                               same line. In this case ->JobEntry will point to ANOTHER job !!!
                               The solution should be to provide as a completion key the
                               JobEntry and not the LineInfo !!!

                        *****
                */
            Assert (JobEntry->lpJobQueueEntry);

            if (TRUE == JobEntry->fStopUpdateStatus)
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("JobId: %ld. fStopUpdateStatus was set. Not updating status %ld"),
                    JobEntry->lpJobQueueEntry->JobId,
                    JobEntry->lpJobQueueEntry->JobStatus);

                if (!HeapFree(pLineInfo->Provider->HeapHandle, 0, FaxStatus ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to free orphan device status (ec: %ld)"),
                        GetLastError());
                    //
                    // Nothing else we can do but report it in debug mode
                    //
                }
                FaxStatus = NULL;
                LeaveCriticalSection (&g_CsJob);
                continue;
            }

            //
            // Do not update final job states
            //
            LegacyJobStatusToStatus(
                FaxStatus->StatusId,
                &dwJobStatus,
                &dwExtendedStatus,
                &bPrivateStatusCode);

            if (FSPI_JS_ABORTED         == dwJobStatus ||
                FSPI_JS_COMPLETED       == dwJobStatus ||
                FSPI_JS_FAILED          == dwJobStatus ||
                FSPI_JS_FAILED_NO_RETRY == dwJobStatus ||
                FSPI_JS_DELETED         == dwJobStatus )                
            {
                //
                // This is a final status update. Final status is updated from FaxSendThread or FaxReceiveThread
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("JobId: %ld. Final status code. Not updating status %ld"),
                    JobEntry->lpJobQueueEntry->JobId,
                    dwJobStatus);

                if (!HeapFree(pLineInfo->Provider->HeapHandle, 0, FaxStatus ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to free orphan device status (ec: %ld)"),
                        GetLastError());
                    //
                    // Nothing else we can do but report it in debug mode
                    //
                }
                FaxStatus = NULL;
                LeaveCriticalSection (&g_CsJob);
                continue;
            }


            //
            // Go ahead with updating the status
            //
            FreeFSPIJobStatus(&JobEntry->FSPIJobStatus, FALSE);
            memset(&JobEntry->FSPIJobStatus, 0, sizeof(FSPI_JOB_STATUS));
            JobEntry->FSPIJobStatus.dwSizeOfStruct  = sizeof(FSPI_JOB_STATUS);

            //
            // This is done for backward compatability with W2K Fax API.
            // GetJobData() and FAX_GetDeviceStatus() will use this value to return
            // the job status for legacy jobs.
            //
            JobEntry->LineInfo->State = FaxStatus->StatusId;            

            LegacyJobStatusToStatus(
                FaxStatus->StatusId,
                &JobEntry->FSPIJobStatus.dwJobStatus,
                &JobEntry->FSPIJobStatus.dwExtendedStatus,
                &bPrivateStatusCode);

            if (bPrivateStatusCode)
            {
                JobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;
            }

            JobEntry->FSPIJobStatus.dwExtendedStatusStringId = FaxStatus->StringId;

            JobEntry->FSPIJobStatus.dwPageCount = FaxStatus->PageCount;
            JobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_PAGECOUNT;

            if (FaxStatus->CSI)
            {
                JobEntry->FSPIJobStatus.lpwstrRemoteStationId = StringDup( FaxStatus->CSI );
                if (!JobEntry->FSPIJobStatus.lpwstrRemoteStationId  )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( FaxStatus->CSI ) failed (ec: %ld)"),
                        GetLastError());
                }
            }

            if (FaxStatus->CallerId)
            {
                JobEntry->FSPIJobStatus.lpwstrCallerId = StringDup( FaxStatus->CallerId );
                if (!JobEntry->FSPIJobStatus.lpwstrCallerId )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( FaxStatus.CallerId ) failed (ec: %ld)"),
                        GetLastError());
                }
            }

            if (FaxStatus->RoutingInfo)
            {
                JobEntry->FSPIJobStatus.lpwstrRoutingInfo = StringDup( FaxStatus->RoutingInfo );
                if (!JobEntry->FSPIJobStatus.lpwstrRoutingInfo  )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( FaxStatus.RoutingInfo ) failed (ec: %ld)"),
                        GetLastError());
                }
            }

            //
            // Get extended status string
            //			
			JobEntry->ExStatusString[0] = L'\0';            
            if (JobEntry->FSPIJobStatus.dwExtendedStatusStringId != 0)
            {
                DWORD dwSize;
                HINSTANCE hLoadInstance;

                Assert (JobEntry->FSPIJobStatus.dwExtendedStatus != 0);
                if ( !_tcsicmp(JobEntry->LineInfo->Provider->szGUID,REGVAL_T30_PROVIDER_GUID_STRING) )
                {   // special case where the FSP is our FSP (fxst30.dll).
                    hLoadInstance = g_hResource;
                }
                else
                {
                    hLoadInstance = JobEntry->LineInfo->Provider->hModule;
                }
                dwSize = LoadString (hLoadInstance,
                    JobEntry->FSPIJobStatus.dwExtendedStatusStringId,
                    JobEntry->ExStatusString,
                    ARR_SIZE(JobEntry->ExStatusString));
                if (dwSize == 0)
                {                   
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to load extended status string (ec: %ld) stringid : %ld, Provider: %s"),
                        GetLastError(),
                        JobEntry->FSPIJobStatus.dwExtendedStatusStringId,
                        JobEntry->LineInfo->Provider->ImageName);
                
                    JobEntry->FSPIJobStatus.fAvailableStatusInfo &= ~FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;
                    JobEntry->FSPIJobStatus.dwExtendedStatusStringId = 0;
                    JobEntry->FSPIJobStatus.dwExtendedStatus = 0;
                }
            }

            dwEventId = MapFSPIJobStatusToEventId(&JobEntry->FSPIJobStatus);
            //
            // Note: W2K Fax did issue notifications with EventId == 0 whenever an
            // FSP reported proprietry status code. To keep backward compatability
            // we keep up this behaviour although it might be regarded as a bug
            //

            if ( !CreateFaxEvent( JobEntry->LineInfo->PermanentLineID, dwEventId, JobEntry->lpJobQueueEntry->JobId ) )
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateFaxEvent failed. (ec: %ld)"),
                    GetLastError());
            }

            EnterCriticalSection (&g_CsQueue);
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                             JobEntry->lpJobQueueEntry
                                           );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                    JobEntry->lpJobQueueEntry->UniqueId,
                    dwRes);
            }
            LeaveCriticalSection (&g_CsQueue);
            HeapFree( JobEntry->LineInfo->Provider->HeapHandle, 0, FaxStatus );
        }
        LeaveCriticalSection( &g_CsJob );
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return 0;
}



BOOL
InitializeJobManager(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    This fuction initializes the thread pool and
    FAX service queues.

Arguments:

    ThreadHint  - Number of threads to create in the initial pool.

Return Value:

    Thread return value.

--*/

{

    BOOL    bRet;
    DEBUG_FUNCTION_NAME(TEXT("InitializeJobManager"));    


    g_StatusCompletionPortHandle = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        MAX_STATUS_THREADS
        );
    if (!g_StatusCompletionPortHandle)
    {        
        DWORD ec = GetLastError();

        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
               );
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to create StatusCompletionPort (ec: %ld)"), GetLastError() );
        goto Error;
    }


    bRet = TRUE;
    goto Exit;
Error:
    bRet = FALSE;
Exit:

    return bRet;
}

VOID
SetGlobalsFromRegistry(
    PREG_FAX_SERVICE FaxReg
    )
{
    Assert(FaxReg);
    DEBUG_FUNCTION_NAME(TEXT("SetGlobalsFromRegistry"));

    EnterCriticalSection (&g_CsConfig);

    g_dwFaxSendRetries          = FaxReg->Retries;
    g_dwFaxSendRetryDelay       = (INT) FaxReg->RetryDelay;
    g_dwFaxDirtyDays            = FaxReg->DirtyDays;
    g_dwNextJobId               = FaxReg->NextJobNumber;
    g_dwQueueState              = FaxReg->dwQueueState;
    g_fFaxUseDeviceTsid        = FaxReg->UseDeviceTsid;
    g_fFaxUseBranding          = FaxReg->Branding;
    g_fServerCp                = FaxReg->ServerCp;
    g_StartCheapTime          = FaxReg->StartCheapTime;
    g_StopCheapTime           = FaxReg->StopCheapTime;

    LeaveCriticalSection (&g_CsConfig);
    return;
}


BOOL
FillMsTagInfo(
    LPTSTR FaxFileName,
     const JOB_QUEUE * lpcJobQueue
    )

/*++

Routine Description:

    Add Ms Tiff Tags to a sent fax. Wraps TiffAddMsTags...

Arguments:

    FaxFileName - Name of the file to archive
    SendTime    - time the fax was sent
    FaxStatus   - job status
    FaxSend     - FAX_SEND structure for sent fax, includes CSID.

Return Value:

    TRUE    - The tags were added.
    FALSE   - The tags were not added.

--*/
{
    BOOL success = FALSE;
    MS_TAG_INFO MsTagInfo = {0};
    WCHAR       wcZero = L'\0';
    PJOB_ENTRY lpJobEntry;
    LPCFSPI_JOB_STATUS lpcFSPIJobStatus;
    DEBUG_FUNCTION_NAME(TEXT("FillMsTagInfo"));

    Assert (lpcJobQueue);
    Assert (lpcJobQueue->lpParentJob);
    lpJobEntry = lpcJobQueue->JobEntry;
    Assert(lpJobEntry);
    lpcFSPIJobStatus = &lpJobEntry->FSPIJobStatus;

    if (lpcJobQueue->RecipientProfile.lptstrName && (lpcJobQueue->RecipientProfile.lptstrName[0] != wcZero) ) {
       MsTagInfo.RecipName     = lpcJobQueue->RecipientProfile.lptstrName;
    }

    if (lpcJobQueue->RecipientProfile.lptstrFaxNumber && (lpcJobQueue->RecipientProfile.lptstrFaxNumber[0] != wcZero) ) {
       MsTagInfo.RecipNumber   = lpcJobQueue->RecipientProfile.lptstrFaxNumber;
    }

    if (lpcJobQueue->SenderProfile.lptstrName && (lpcJobQueue->SenderProfile.lptstrName[0] != wcZero) ) {
       MsTagInfo.SenderName    = lpcJobQueue->SenderProfile.lptstrName;
    }

    if (lpcFSPIJobStatus->lpwstrRoutingInfo && (lpcFSPIJobStatus->lpwstrRoutingInfo[0] != wcZero) ) {
       MsTagInfo.Routing       = lpcFSPIJobStatus->lpwstrRoutingInfo;
    }

    if (lpcFSPIJobStatus->lpwstrRemoteStationId && (lpcFSPIJobStatus->lpwstrRemoteStationId[0] != wcZero) ) {
       MsTagInfo.Csid          = lpcFSPIJobStatus->lpwstrRemoteStationId;
    }

    if (lpJobEntry->lpwstrJobTsid && (lpJobEntry->lpwstrJobTsid[0] != wcZero) ) {
       MsTagInfo.Tsid      = lpJobEntry->lpwstrJobTsid;
    }

    if (!GetRealFaxTimeAsFileTime (lpJobEntry, FAX_TIME_TYPE_START, (FILETIME*)&MsTagInfo.StartTime))
    {
        MsTagInfo.StartTime = 0;
        DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Start time)  Failed (ec: %ld)"), GetLastError() );
    }

    if (!GetRealFaxTimeAsFileTime (lpJobEntry, FAX_TIME_TYPE_END, (FILETIME*)&MsTagInfo.EndTime))
    {
        MsTagInfo.EndTime = 0;
        DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Eend time) Failed (ec: %ld)"), GetLastError() );
    }

    MsTagInfo.SubmissionTime = lpcJobQueue->lpParentJob->SubmissionTime;
    MsTagInfo.OriginalScheduledTime  = lpcJobQueue->lpParentJob->OriginalScheduleTime;
    MsTagInfo.Type           = JT_SEND;


    if (lpJobEntry->LineInfo->DeviceName && (lpJobEntry->LineInfo->DeviceName[0] != wcZero) )
    {
       MsTagInfo.Port       = lpJobEntry->LineInfo->DeviceName;
    }


    MsTagInfo.Pages         = lpcJobQueue->PageCount;
    MsTagInfo.Retries       = lpcJobQueue->SendRetries;

    if (lpcJobQueue->RecipientProfile.lptstrCompany && (lpcJobQueue->RecipientProfile.lptstrCompany[0] != wcZero) ) {
       MsTagInfo.RecipCompany = lpcJobQueue->RecipientProfile.lptstrCompany;
    }

    if (lpcJobQueue->RecipientProfile.lptstrStreetAddress && (lpcJobQueue->RecipientProfile.lptstrStreetAddress[0] != wcZero) ) {
       MsTagInfo.RecipStreet = lpcJobQueue->RecipientProfile.lptstrStreetAddress;
    }

    if (lpcJobQueue->RecipientProfile.lptstrCity && (lpcJobQueue->RecipientProfile.lptstrCity[0] != wcZero) ) {
       MsTagInfo.RecipCity = lpcJobQueue->RecipientProfile.lptstrCity;
    }

    if (lpcJobQueue->RecipientProfile.lptstrState && (lpcJobQueue->RecipientProfile.lptstrState[0] != wcZero) ) {
       MsTagInfo.RecipState = lpcJobQueue->RecipientProfile.lptstrState;
    }

    if (lpcJobQueue->RecipientProfile.lptstrZip && (lpcJobQueue->RecipientProfile.lptstrZip[0] != wcZero) ) {
       MsTagInfo.RecipZip = lpcJobQueue->RecipientProfile.lptstrZip;
    }

    if (lpcJobQueue->RecipientProfile.lptstrCountry && (lpcJobQueue->RecipientProfile.lptstrCountry[0] != wcZero) ) {
       MsTagInfo.RecipCountry = lpcJobQueue->RecipientProfile.lptstrCountry;
    }

    if (lpcJobQueue->RecipientProfile.lptstrTitle && (lpcJobQueue->RecipientProfile.lptstrTitle[0] != wcZero) ) {
       MsTagInfo.RecipTitle = lpcJobQueue->RecipientProfile.lptstrTitle;
    }

    if (lpcJobQueue->RecipientProfile.lptstrDepartment && (lpcJobQueue->RecipientProfile.lptstrDepartment[0] != wcZero) ) {
       MsTagInfo.RecipDepartment = lpcJobQueue->RecipientProfile.lptstrDepartment;
    }

    if (lpcJobQueue->RecipientProfile.lptstrOfficeLocation && (lpcJobQueue->RecipientProfile.lptstrOfficeLocation[0] != wcZero) ) {
       MsTagInfo.RecipOfficeLocation = lpcJobQueue->RecipientProfile.lptstrOfficeLocation;
    }

    if (lpcJobQueue->RecipientProfile.lptstrHomePhone && (lpcJobQueue->RecipientProfile.lptstrHomePhone[0] != wcZero) ) {
       MsTagInfo.RecipHomePhone = lpcJobQueue->RecipientProfile.lptstrHomePhone;
    }

    if (lpcJobQueue->RecipientProfile.lptstrOfficePhone && (lpcJobQueue->RecipientProfile.lptstrOfficePhone[0] != wcZero) ) {
       MsTagInfo.RecipOfficePhone = lpcJobQueue->RecipientProfile.lptstrOfficePhone;
    }

    if (lpcJobQueue->RecipientProfile.lptstrEmail && (lpcJobQueue->RecipientProfile.lptstrEmail[0] != wcZero) ) {
       MsTagInfo.RecipEMail = lpcJobQueue->RecipientProfile.lptstrEmail;
    }

    if (lpcJobQueue->SenderProfile.lptstrFaxNumber && (lpcJobQueue->SenderProfile.lptstrFaxNumber[0] != wcZero) ) {
       MsTagInfo.SenderNumber   = lpcJobQueue->SenderProfile.lptstrFaxNumber;
    }

    if (lpcJobQueue->SenderProfile.lptstrCompany && (lpcJobQueue->SenderProfile.lptstrCompany[0] != wcZero) ) {
       MsTagInfo.SenderCompany = lpcJobQueue->SenderProfile.lptstrCompany;
    }

    if (lpcJobQueue->SenderProfile.lptstrStreetAddress && (lpcJobQueue->SenderProfile.lptstrStreetAddress[0] != wcZero) ) {
       MsTagInfo.SenderStreet = lpcJobQueue->SenderProfile.lptstrStreetAddress;
    }

    if (lpcJobQueue->SenderProfile.lptstrCity && (lpcJobQueue->SenderProfile.lptstrCity[0] != wcZero) ) {
       MsTagInfo.SenderCity = lpcJobQueue->SenderProfile.lptstrCity;
    }

    if (lpcJobQueue->SenderProfile.lptstrState && (lpcJobQueue->SenderProfile.lptstrState[0] != wcZero) ) {
       MsTagInfo.SenderState = lpcJobQueue->SenderProfile.lptstrState;
    }

    if (lpcJobQueue->SenderProfile.lptstrZip && (lpcJobQueue->SenderProfile.lptstrZip[0] != wcZero) ) {
       MsTagInfo.SenderZip = lpcJobQueue->SenderProfile.lptstrZip;
    }

    if (lpcJobQueue->SenderProfile.lptstrCountry && (lpcJobQueue->SenderProfile.lptstrCountry[0] != wcZero) ) {
       MsTagInfo.SenderCountry = lpcJobQueue->SenderProfile.lptstrCountry;
    }

    if (lpcJobQueue->SenderProfile.lptstrTitle && (lpcJobQueue->SenderProfile.lptstrTitle[0] != wcZero) ) {
       MsTagInfo.SenderTitle = lpcJobQueue->SenderProfile.lptstrTitle;
    }

    if (lpcJobQueue->SenderProfile.lptstrDepartment && (lpcJobQueue->SenderProfile.lptstrDepartment[0] != wcZero) ) {
       MsTagInfo.SenderDepartment = lpcJobQueue->SenderProfile.lptstrDepartment;
    }

    if (lpcJobQueue->SenderProfile.lptstrOfficeLocation && (lpcJobQueue->SenderProfile.lptstrOfficeLocation[0] != wcZero) ) {
       MsTagInfo.SenderOfficeLocation = lpcJobQueue->SenderProfile.lptstrOfficeLocation;
    }

    if (lpcJobQueue->SenderProfile.lptstrHomePhone && (lpcJobQueue->SenderProfile.lptstrHomePhone[0] != wcZero) ) {
       MsTagInfo.SenderHomePhone = lpcJobQueue->SenderProfile.lptstrHomePhone;
    }

    if (lpcJobQueue->SenderProfile.lptstrOfficePhone && (lpcJobQueue->SenderProfile.lptstrOfficePhone[0] != wcZero) ) {
       MsTagInfo.SenderOfficePhone = lpcJobQueue->SenderProfile.lptstrOfficePhone;
    }

    if (lpcJobQueue->SenderProfile.lptstrEmail && (lpcJobQueue->SenderProfile.lptstrEmail[0] != wcZero) ) {
       MsTagInfo.SenderEMail = lpcJobQueue->SenderProfile.lptstrEmail;
    }

    if (lpcJobQueue->SenderProfile.lptstrBillingCode && (lpcJobQueue->SenderProfile.lptstrBillingCode[0] != wcZero) ) {
       MsTagInfo.SenderBilling = lpcJobQueue->SenderProfile.lptstrBillingCode;
    }

    if (lpcJobQueue->JobParamsEx.lptstrDocumentName && (lpcJobQueue->JobParamsEx.lptstrDocumentName[0] != wcZero) ) {
       MsTagInfo.Document   = lpcJobQueue->JobParamsEx.lptstrDocumentName;
    }

    if (lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject && (lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject[0] != wcZero) ) {
       MsTagInfo.Subject   = lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject;
    }

    if (lpcJobQueue->lpParentJob->UserName && (lpcJobQueue->lpParentJob->UserName[0] != wcZero) ) {
       MsTagInfo.SenderUserName = lpcJobQueue->lpParentJob->UserName;
    }

    if (lpcJobQueue->SenderProfile.lptstrTSID && (lpcJobQueue->SenderProfile.lptstrTSID[0] != wcZero) ) {
       MsTagInfo.SenderTsid = lpcJobQueue->SenderProfile.lptstrTSID;
    }

    MsTagInfo.dwStatus              = JS_COMPLETED; // We archive only succesfully sent faxes
    MsTagInfo.dwExtendedStatus      = lpcFSPIJobStatus->dwExtendedStatus;
    
    if (lpJobEntry->ExStatusString[0] != wcZero) {
       MsTagInfo.lptstrExtendedStatus       = lpJobEntry->ExStatusString;
    }    

    MsTagInfo.dwlBroadcastId        = lpcJobQueue->lpParentJob->UniqueId;
    MsTagInfo.Priority              = lpcJobQueue->lpParentJob->JobParamsEx.Priority;

    success = TiffAddMsTags( FaxFileName, &MsTagInfo, TRUE );
    if (!success)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("TiffAddMsTags failed, ec = %ld"),
                      GetLastError ());
    }
    if(!AddNTFSStorageProperties( FaxFileName, &MsTagInfo , TRUE ))
    {
        if (ERROR_OPEN_FAILED != GetLastError ())
        {
            //
            // If AddNTFSStorageProperties fails with ERROR_OPEN_FAIL then the archive
            // folder is not on an NTFS 5 partition.
            // This is ok - NTFS properties are a backup mechanism but not a must
            //
            DebugPrintEx( DEBUG_ERR,
                          TEXT("AddNTFSStorageProperties failed, ec = %ld"),
                          GetLastError ());
            success = FALSE;
        }
        else
        {
            DebugPrintEx( DEBUG_WRN,
                          TEXT("AddNTFSStorageProperties failed with ERROR_OPEN_FAIL. Probably not an NTFS 5 partition"));
        }
    }
    return success;
}   // FillMsTagInfo



//*********************************************************************************
//* Name:   ArchiveOutboundJob()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*    Archive a tiff file that has been sent by copying the file to an archive
//*    directory. Also adds the MSTags to the new file generated at the
//*    archive (not to the source file).
//*
//* PARAMETERS:
//*     [IN ]       const JOB_QUEUE * lpcJobQueue
//*         Pointer to the recipient job which is to be archived.
//*
//* RETURN VALUE:
//*     TRUE if the opeation succeeded.
//*     FALSE if the operation failed.
//*********************************************************************************
BOOL
ArchiveOutboundJob(
    const JOB_QUEUE * lpcJobQueue
    )
{
    BOOL        rVal = FALSE;
    WCHAR       ArchiveFileName[MAX_PATH] = {0};
    LPWSTR      lpwszUserSid = NULL;
    DWORD       ec = ERROR_SUCCESS;
    WCHAR       wszArchiveFolder[MAX_PATH];
    DEBUG_FUNCTION_NAME(TEXT("ArchiveOutboundJob"));

    Assert(lpcJobQueue);

    //
    // be sure that the dir exists
    //
    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (  wszArchiveFolder,
                g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
                MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);
    
    ec=IsValidFaxFolder(wszArchiveFolder);
    if (ERROR_SUCCESS != ec)
    {        
        DebugPrintEx(DEBUG_ERR,
                        TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                        wszArchiveFolder,
                        ec);

        FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_ARCHIVE_OUTBOX_FOLDER_ERR,
                wszArchiveFolder,
                DWORD2DECIMAL(ec)
            );
        goto Error;
    }

    //
    // get the user sid string
    //
    if (!ConvertSidToStringSid(lpcJobQueue->lpParentJob->UserSid, &lpwszUserSid))
    {
       ec = GetLastError();
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("ConvertSidToStringSid() failed (ec: %ld)"),
           ec);
       goto Error;
    }


    //
    // get the file name
    //
    if (GenerateUniqueArchiveFileName(  wszArchiveFolder,
                                        ArchiveFileName,
                                        ARR_SIZE(ArchiveFileName),
                                        lpcJobQueue->UniqueId,
                                        lpwszUserSid)) {
        rVal = TRUE;
    }
    else
    {    
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to generate unique name for archive file at dir [%s] (ec: %ld)"),
            wszArchiveFolder,
            ec);
        FaxLog(
               FAXLOG_CATEGORY_OUTBOUND,
               FAXLOG_LEVEL_MIN,
               1,
               MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
               DWORD2DECIMAL(ec)
        );
        goto Error;
    }

    if (rVal) {

        Assert(lpcJobQueue->FileName);

        rVal = CopyFile( lpcJobQueue->FileName, ArchiveFileName, FALSE );
        if (!rVal)
        {        
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CopyFile [%s] to [%s] failed. (ec: %ld)"),
                lpcJobQueue->FileName,
                ArchiveFileName,
                ec);
            FaxLog(
               FAXLOG_CATEGORY_OUTBOUND,
               FAXLOG_LEVEL_MIN,
               1,
               MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
               DWORD2DECIMAL(ec)
            );

            if (!DeleteFile(ArchiveFileName))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("DeleteFile [%s] failed. (ec: %ld)"),
                    ArchiveFileName,
                    GetLastError());
            }
            goto Error;
        }
    }

    if (rVal)
    {
        DWORD dwRes;
        HANDLE hFind;
        WIN32_FIND_DATA FindFileData;

        if (!FillMsTagInfo( ArchiveFileName,
                            lpcJobQueue
                            ))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add MS TIFF tags to archived file %s. (ec: %ld)"),
                ArchiveFileName,
                dwRes);
            FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_ARCHIVE_NO_TAGS,
                ArchiveFileName,
                DWORD2HEX(dwRes)
            );
        }

        dwRes = CreateArchiveEvent (lpcJobQueue->UniqueId,
                                    FAX_EVENT_TYPE_OUT_ARCHIVE,
                                    FAX_JOB_EVENT_TYPE_ADDED,
                                    lpcJobQueue->lpParentJob->UserSid);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                dwRes);
        }

        hFind = FindFirstFile( ArchiveFileName, &FindFileData);
        if (INVALID_HANDLE_VALUE == hFind)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindFirstFile failed (ec: %lc), File %s"),
                GetLastError(),
                ArchiveFileName);
        }
        else
        {
            // Update the archive size - for quota management
            EnterCriticalSection (&g_CsConfig);
            if (FAX_ARCHIVE_FOLDER_INVALID_SIZE != g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize)
            {
                g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize += (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
            }
            LeaveCriticalSection (&g_CsConfig);
            Assert (FindFileData.nFileSizeLow);

            if (!FindClose(hFind))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FindClose failed (ec: %lc)"),
                    GetLastError());
            }
        }

        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_SENT_ARCHIVE_SUCCESS,
            lpcJobQueue->FileName,
            ArchiveFileName
            );
    }

    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
    FaxLog(
           FAXLOG_CATEGORY_OUTBOUND,
           FAXLOG_LEVEL_MIN,
           3,
           MSG_FAX_ARCHIVE_FAILED,
           lpcJobQueue->FileName,
           wszArchiveFolder,
           DWORD2HEX(GetLastError())
    );
Exit:

    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    if (lpwszUserSid != NULL)
    {
        LocalFree (lpwszUserSid);
    }

    return (ERROR_SUCCESS == ec);
}



BOOL UpdatePerfCounters(const JOB_QUEUE * lpcJobQueue)
{

    SYSTEMTIME SystemTime ;
    DWORD Seconds ;
    HANDLE FileHandle ;
    DWORD Bytes = 0 ; /// Compute #bytes in the file FaxSend.FileName and stick it here!
    const JOB_ENTRY  * lpcJobEntry;

    DEBUG_FUNCTION_NAME(TEXT("UpdatePerfCounters"));

    Assert(lpcJobQueue);
    lpcJobEntry = lpcJobQueue->JobEntry;
    Assert(lpcJobEntry);

    FileHandle = SafeCreateFile(
        lpcJobEntry->lpJobQueueEntry->FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if(FileHandle != INVALID_HANDLE_VALUE)
    {
        Bytes = GetFileSize( FileHandle, NULL );
        CloseHandle( FileHandle );
    }

    if (!FileTimeToSystemTime(
        (FILETIME*)&lpcJobEntry->ElapsedTime,
        &SystemTime
        ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
        memset(&SystemTime,0,sizeof(SYSTEMTIME));
    }


    Seconds = (DWORD)( SystemTime.wSecond + 60 * ( SystemTime.wMinute + 60 * SystemTime.wHour ));
    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFaxes );
    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->TotalFaxes );

    InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->OutboundPages, (LONG)lpcJobEntry->FSPIJobStatus.dwPageCount );
    InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->TotalPages, (LONG)lpcJobEntry->FSPIJobStatus.dwPageCount  );

    EnterCriticalSection( &g_CsPerfCounters );

    g_dwOutboundSeconds += Seconds;
    g_dwTotalSeconds += Seconds;
    g_pFaxPerfCounters->OutboundMinutes = g_dwOutboundSeconds / 60 ;
    g_pFaxPerfCounters->TotalMinutes = g_dwTotalSeconds / 60 ;
    g_pFaxPerfCounters->OutboundBytes += Bytes;
    g_pFaxPerfCounters->TotalBytes += Bytes;

    LeaveCriticalSection( &g_CsPerfCounters );
    return TRUE;


}


BOOL MarkJobAsExpired(PJOB_QUEUE lpJobQueue)
{
    FILETIME CurrentFileTime;
    LARGE_INTEGER NewTime;
    DWORD dwMaxRetries;
    BOOL rVal = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("MarkJobAsExpired"));

    Assert(lpJobQueue);
    Assert( JT_SEND == lpJobQueue->JobType ||
            JT_ROUTING == lpJobQueue->JobType );

    EnterCriticalSection(&g_CsQueue);
    lpJobQueue->JobStatus = JS_RETRIES_EXCEEDED;
    EnterCriticalSection (&g_CsConfig);
    dwMaxRetries = g_dwFaxSendRetries;
    LeaveCriticalSection (&g_CsConfig);
    lpJobQueue->SendRetries = dwMaxRetries + 1;
    //
    // Set the job's ScheduleTime field to the time it totaly failed.
    // (current time).
    //
    GetSystemTimeAsFileTime( &CurrentFileTime ); //Can not fail (Win32 SDK)
    NewTime.LowPart  = CurrentFileTime.dwLowDateTime;
    NewTime.HighPart = CurrentFileTime.dwHighDateTime;
    lpJobQueue->ScheduleTime = NewTime.QuadPart;

    if (!CommitQueueEntry(lpJobQueue))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CommitQueueEntry() for recipien job %s has failed. (ec: %ld)"),
            lpJobQueue->FileName,
            GetLastError());
        rVal = FALSE;
    }

    if (JT_SEND == lpJobQueue->JobType)
    {
        Assert (lpJobQueue->lpParentJob);

        lpJobQueue->lpParentJob->dwFailedRecipientJobsCount+=1;
        //
        // The parent job keeps the schedule of the last recipient job that failed.
        // The job retention policy for the parent will be based on that
        // schedule.
        lpJobQueue->lpParentJob->ScheduleTime = lpJobQueue->ScheduleTime;
        if (!CommitQueueEntry(lpJobQueue->lpParentJob))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CommitQueueEntry() for parent job %s has failed. (ec: %ld)"),
                lpJobQueue->lpParentJob->FileName,
                GetLastError());
            rVal = FALSE;
        }
    }

    LeaveCriticalSection(&g_CsQueue);
    return rVal;
}





//*********************************************************************************
//* Name:   CreateJobEntry()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates and initializes a new JOB_ENTRY.
//*     Opens the line the job is to be executed on (if it is a TAPI line)
//*     and creates the attachement between the line and the job.
//* PARAMETERS:
//*     [IN/OUT]    PJOB_QUEUE lpJobQueue
//*         For outgoing jobs this points to the JOB_QUEUE of the outgoing job.
//*         for receive job this should be set to NULL.
//*     [IN/OUT]     LINE_INFO * lpLineInfo
//*         A pointer to the LINE_INFO information of the line on which the job
//*         is to be executed.
//*     [IN ]    BOOL bTranslateNumber
//*         TRUE if the recipient number needs to be translated into dilable
//*         string (needed for legacy FaxDevSend() where the number must be
//*         dilable and not canonical).
//*     
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_ENTRY CreateJobEntry(
    PJOB_QUEUE lpJobQueue,
    LINE_INFO * lpLineInfo,
    BOOL bTranslateNumber
	)
{
    BOOL Failure = TRUE;
    PJOB_ENTRY JobEntry = NULL;
    DWORD rc  = ERROR_SUCCESS;;

    DEBUG_FUNCTION_NAME(TEXT("CreateJobEntry"));    
    Assert(!(lpJobQueue && lpJobQueue->JobType != JT_SEND));
    Assert(!(bTranslateNumber && !lpJobQueue));
    Assert (lpLineInfo);

    JobEntry = (PJOB_ENTRY) MemAlloc( sizeof(JOB_ENTRY) );
    if (!JobEntry)
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,_T("Failed to allocated memory for JOB_ENTRY."));
        goto exit;
    }

    memset(JobEntry, 0, sizeof(JOB_ENTRY));

    if (lpJobQueue)
    {
        if (! _tcslen(lpJobQueue->tczDialableRecipientFaxNumber))
        {
            //
            //  The Fax Number was not compound, make translation as before
            //
            if (bTranslateNumber)
            {
                rc = TranslateCanonicalNumber(lpJobQueue->RecipientProfile.lptstrFaxNumber,
                                              lpLineInfo->DeviceId,
                                              JobEntry->DialablePhoneNumber,
											  ARR_SIZE(JobEntry->DialablePhoneNumber),
                                              JobEntry->DisplayablePhoneNumber,
											  ARR_SIZE(JobEntry->DisplayablePhoneNumber));
                if (ERROR_SUCCESS != rc)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("TranslateCanonicalNumber() faield for number: %s (ec: %ld)"),
                        lpJobQueue->RecipientProfile.lptstrFaxNumber,
                        rc);
                    goto exit;
                }
            }
            else
            {
                _tcsncpy(JobEntry->DialablePhoneNumber, lpJobQueue->RecipientProfile.lptstrFaxNumber, SIZEOF_PHONENO );
                JobEntry->DialablePhoneNumber[SIZEOF_PHONENO - 1] = '\0';
                _tcsncpy(JobEntry->DisplayablePhoneNumber, lpJobQueue->RecipientProfile.lptstrFaxNumber, SIZEOF_PHONENO );
                JobEntry->DisplayablePhoneNumber[SIZEOF_PHONENO - 1] = '\0';
            }
        }
        else
        {
            //
            //  The Fax Number was compound, no translation needed
            //  Take Dialable from JobQueue and Displayable from Recipient's PersonalProfile's FaxNumber
            //
            _tcsncpy(JobEntry->DialablePhoneNumber, lpJobQueue->tczDialableRecipientFaxNumber, SIZEOF_PHONENO );
            _tcsncpy(JobEntry->DisplayablePhoneNumber, lpJobQueue->RecipientProfile.lptstrFaxNumber, (SIZEOF_PHONENO - 1));
            JobEntry->DisplayablePhoneNumber[SIZEOF_PHONENO - 1] = '\0';
        }
    }
    else
    {
        //
        //  lpJobQueue is NULL
        //			
		JobEntry->DialablePhoneNumber[0] = L'\0';
		JobEntry->DisplayablePhoneNumber[0] = L'\0';          
    }

    JobEntry->CallHandle = 0;
    JobEntry->InstanceData = 0;
    JobEntry->LineInfo = lpLineInfo;
    JobEntry->SendIdx = -1;
    JobEntry->Released = FALSE;
    JobEntry->lpJobQueueEntry = lpJobQueue;    
    JobEntry->bFSPJobInProgress = FALSE;
    memset(&JobEntry->FSPIJobStatus,0,sizeof(FSPI_JOB_STATUS));
    JobEntry->FSPIJobStatus.dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);
    JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_UNKNOWN;   

    GetSystemTimeAsFileTime( (FILETIME*) &JobEntry->StartTime );

    EnterCriticalSection (&g_CsLine);
    if (!(lpLineInfo->Flags & FPF_VIRTUAL) && (!lpLineInfo->hLine))
    {
        if (!OpenTapiLine( lpLineInfo ))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenTapiLine failed. (ec: %ld)"),
                rc);
            LeaveCriticalSection (&g_CsLine);
            goto exit;
        }
    }

    //
    // Attach the job to the line selected to service it.    
    //       
    lpLineInfo->JobEntry = JobEntry;    
    LeaveCriticalSection (&g_CsLine);
    Failure = FALSE;

exit:
    if (Failure)
    {
        // Failure is initialized to TRUE
        if (JobEntry)
        {            
            MemFree( JobEntry );
        }
        JobEntry = NULL;
    }
    if (ERROR_SUCCESS != rc)
    {
        SetLastError(rc);
    }
    return JobEntry;
}   // CreateJobEntry


//*********************************************************************************
//* Name:   TranslateCanonicalNumber()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Translates a canonical number to a dilable + displayable number.
//*
//* PARAMETERS:
//*     [IN ]   LPTSTR lptstrFaxNumber
//*         The canonical number to translate.
//*
//*     [IN ]   DWORD dwDeviceID
//*         The device ID.
//*
//*     [OUT]   LPTSTR lptstrDialableAddress
//*         Buffer to receive the dialable translated address.
//*         
//*     [IN]	DWORD dwDialableAddressCount
//*			size in TCHARs of the buffer pointed by lptstrDialableAddress
//*
//*     [OUT]   LPTSTR lptstrDisplayableAddress
//*         Buffer to receive the displayable translated address.
//*
//*     [IN]	DWORD dwDisplayableAddressCount
//*			size in TCHARs of the buffer pointed by lptstrDialableAddress
//*
//* RETURN VALUE:
//*     Win32 / HRESULT error code
//*********************************************************************************
static
DWORD
TranslateCanonicalNumber(
    LPTSTR lptstrCanonicalFaxNumber,
    DWORD  dwDeviceID,
    LPTSTR lptstrDialableAddress,
	DWORD dwDialableAddressCount,
    LPTSTR lptstrDisplayableAddress,
	DWORD dwDisplayableAddressCount
)
{
    DWORD ec = ERROR_SUCCESS;
    LPLINETRANSLATEOUTPUT LineTranslateOutput = NULL;

    DEBUG_FUNCTION_NAME(TEXT("TranslateCanonicalNumber"));
    Assert(lptstrCanonicalFaxNumber && lptstrDialableAddress && lptstrDisplayableAddress);

    ec = MyLineTranslateAddress( lptstrCanonicalFaxNumber, dwDeviceID, &LineTranslateOutput );
    if (ERROR_SUCCESS == ec)
    {
        LPTSTR lptstrTranslateBuffer;
		HRESULT hr;
        //
        // Copy displayable string
        // TAPI returns credit card numbers in the displayable string.
        // return the input canonical number as the displayable string.
        //       
		hr = StringCchCopy(
			lptstrDisplayableAddress,
			dwDisplayableAddressCount,
			lptstrCanonicalFaxNumber);
		if (FAILED(hr))
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringCchCopy() failed (ec: %ld)"),
                hr);
			ec = HRESULT_CODE(hr);
			goto Exit;
		} 
        
        //
        // Copy dialable string
        //
        Assert (LineTranslateOutput->dwDialableStringSize > 0);
        lptstrTranslateBuffer=(LPTSTR)((LPBYTE)LineTranslateOutput + LineTranslateOutput->dwDialableStringOffset);
		hr = StringCchCopy(
			lptstrDialableAddress,
			dwDialableAddressCount,
			lptstrTranslateBuffer);
		if (FAILED(hr))
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringCchCopy() failed (ec: %ld)"),
                hr);
			ec = HRESULT_CODE(hr);
			goto Exit;
		}        
    }
    else
    {
        // ec is a Tapi ERROR
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("MyLineTranslateAddress() failed for fax number: [%s] (ec: %ld)"),
                lptstrCanonicalFaxNumber,
                ec);
        goto Exit;
    }

    Assert (ERROR_SUCCESS == ec);

Exit:
    MemFree( LineTranslateOutput );
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return ec;
}   // TranslateCanonicalNumber



//*********************************************************************************
//* Name:   HandleCompletedSendJob()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Handles the completion of a recipient job. Called when a recipient job
//*     has reaced a JS_COMPLETED state.
//*
//*     IMPORTANT- This call can be blocking. Calling thread MUST NOT hold any critical section
//*
//*     - Marks the job as completed (JS_COMPLETED).
//*     - Archives the sent file if required.
//*     - Sends a positive receipt
//*     - Removes the parent job if required.
//*
//* PARAMETERS:
//*     [IN ]   PJOB_ENTRY lpJobEntry
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfully.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended errror
//*         information.
//*********************************************************************************
BOOL HandleCompletedSendJob(PJOB_ENTRY lpJobEntry)
{
    PJOB_QUEUE lpJobQueue = NULL;
    DWORD ec = 0;
    BOOL fCOMInitiliazed = FALSE;
    HRESULT hr;

    BOOL bArchiveSentItems;
    DWORD dwRes;

    DEBUG_FUNCTION_NAME(TEXT("HandleCompletedSendJob)"));

    EnterCriticalSection ( &g_CsJob );

    EnterCriticalSection (&g_CsConfig);
    bArchiveSentItems = g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].bUseArchive;
    LeaveCriticalSection (&g_CsConfig);

    Assert(lpJobEntry);
    lpJobQueue = lpJobEntry->lpJobQueueEntry;
    Assert(lpJobQueue);
    Assert(JT_SEND == lpJobQueue->JobType);
    Assert(FSPI_JS_COMPLETED == lpJobEntry->FSPIJobStatus.dwJobStatus);

    //
    // Update end time in JOB_ENTRY
    //
    GetSystemTimeAsFileTime( (FILETIME*) &lpJobEntry->EndTime );
    //
    // Update elapsed time in JOB_ENTRY
    //
    Assert (lpJobEntry->EndTime >= lpJobEntry->StartTime);
    lpJobEntry->ElapsedTime = lpJobEntry->EndTime - lpJobEntry->StartTime;
    //
    // We generate a full tiff for each recipient
    // so we will have something to put in the send archive.
    //

    if (!lpJobQueue->FileName)
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] Generating body for recipient job."),
            lpJobQueue->JobId
            );

        if (!CreateTiffFileForJob(lpJobQueue))
        {            
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] CreateTiffFileForJob failed. (ec: %ld)"),
                lpJobQueue->JobId,
                dwRes);

            FaxLog(
               FAXLOG_CATEGORY_OUTBOUND,
               FAXLOG_LEVEL_MIN,
               1,
               MSG_FAX_TIFF_CREATE_FAILED_NO_ARCHIVE,
           g_wszFaxQueueDir,
               DWORD2DECIMAL(dwRes)
            );
        }
    }

    // Needed for Archiving
    hr = CoInitialize (NULL);
    if (FAILED (hr))
    {
        WCHAR       wszArchiveFolder[MAX_PATH];
        EnterCriticalSection (&g_CsConfig);
        lstrcpyn (  wszArchiveFolder,
                    g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
                    MAX_PATH);
        LeaveCriticalSection (&g_CsConfig);

        DebugPrintEx( DEBUG_ERR,
                      TEXT("CoInitilaize failed, err %ld"),
                      hr);
        
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_ARCHIVE_FAILED,
            lpJobQueue->FileName,
            wszArchiveFolder,
            DWORD2DECIMAL(hr)
        );
    }
    else
    {
        fCOMInitiliazed = TRUE;
    }

    if (lpJobQueue->FileName) //might be null if we failed to generate a TIFF
    {
        //
        // Archive the file (also adds MS Tags to the tiff at the archive directory)
        //
        if (bArchiveSentItems && fCOMInitiliazed)
        {
            if (!ArchiveOutboundJob(lpJobQueue))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("JobId: %ld] ArchiveOutboundJob() failed (ec: %ld)"),
                    lpJobQueue->JobId,
                    GetLastError());
                //
                // The event log entry is generated by the function itself
                //
            }
        }
    }
    //
    // Log the succesful send to the event log
    //
    EnterCriticalSection (&g_CsOutboundActivityLogging);
    if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
    {
        DebugPrintEx(DEBUG_ERR,
                  TEXT("Logging not initialized"));
    }
    else
    {
        if (!LogOutboundActivity(lpJobQueue))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("Logging outbound activity failed"));
        }
    }
    LeaveCriticalSection (&g_CsOutboundActivityLogging);

    if (fCOMInitiliazed == TRUE)
    {
        CoUninitialize ();
    }

    FaxLogSend(lpJobQueue,  FALSE);

    //
    // Increment counters for Performance Monitor
    //
    if (g_pFaxPerfCounters)
    {

         if (!UpdatePerfCounters(lpJobQueue))
         {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("[JobId: %ld] UpdatePerfCounters() failed. (ec: %ld)"),
                 lpJobQueue->JobId,
                 GetLastError());
            Assert(FALSE);
         }
    }

    EnterCriticalSection ( &g_CsQueue );
    //
    // Mark the job as completed (new client API)
    //
    lpJobQueue->JobStatus = JS_COMPLETED;
    //
    // Save the last extended status before ending this job
    //
    lpJobQueue->dwLastJobExtendedStatus = lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus;
	hr = StringCchCopy(
		lpJobQueue->ExStatusString,
		ARR_SIZE(lpJobQueue->ExStatusString),
		lpJobQueue->JobEntry->ExStatusString);
	if (FAILED(hr))
	{
		//
		// Can never happen, we use large enough buffer.
		//
		ASSERT_FALSE;
	}    

    if (!UpdatePersistentJobStatus(lpJobQueue))
    {
         DebugPrintEx(
             DEBUG_ERR,
             TEXT("Failed to update persistent job status to 0x%08x"),
             lpJobQueue->JobStatus);
         Assert(FALSE);
    }

    lpJobQueue->lpParentJob->dwCompletedRecipientJobsCount+=1;

    //
    // Create Fax EventEx
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS, lpJobQueue );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobQueue->UniqueId,
            dwRes);
    }

    //
    // We will send the receipt once we are out of all critical sections because this call can be blocking.
    // just increase the preview refernce count so the job will not be deleted.
    //
    IncreaseJobRefCount (lpJobQueue, TRUE); // TRUE - preview
    //
    // Copy receipt information from JobEntry.
    //
    lpJobQueue->StartTime           = lpJobQueue->JobEntry->StartTime;
    lpJobQueue->EndTime             = lpJobQueue->JobEntry->EndTime;


    //
    // EndJob() must be called BEFORE we remove the parent job (and recipients)
    //
    lpJobQueue->JobEntry->LineInfo->State = FPS_AVAILABLE;
    //
    // We just completed a send job on the device - update counter.
    //
    (VOID) UpdateDeviceJobsCounter (lpJobQueue->JobEntry->LineInfo,   // Device to update
                                    TRUE,                             // Sending
                                    -1,                               // Number of new jobs (-1 = decrease by one)
                                    TRUE);                            // Enable events

    if (!EndJob( lpJobQueue->JobEntry ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EndJob Failed. (ec: %ld)"),
            GetLastError());
    }

    lpJobQueue->JobEntry = NULL;
    DecreaseJobRefCount (lpJobQueue, TRUE);  // This will mark it as JS_DELETING if needed
    //
    // Notify the queue that a device is now available.
    //
    if (!SetEvent( g_hJobQueueEvent ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
            GetLastError());

        g_ScanQueueAfterTimeout = TRUE;
    }
    LeaveCriticalSection ( &g_CsQueue );
    LeaveCriticalSection ( &g_CsJob );

    //
    // Now send the receipt
    //
    if (!SendJobReceipt (TRUE, lpJobQueue, lpJobQueue->FileName))
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] SendJobReceipt failed. (ec: %ld)"),
            lpJobQueue->JobId,
            ec
            );
    }
    EnterCriticalSection (&g_CsQueue);
    DecreaseJobRefCount (lpJobQueue, TRUE, TRUE, TRUE);  // last TRUE for Preview ref count.
    LeaveCriticalSection (&g_CsQueue);
    return TRUE;
}   // HandleCompletedSendJob


//*********************************************************************************
//* Name:   HandleFailedSendJob()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Handles the post failure operations of a send job.
//*
//*     IMPORTANT- This call can be blocking. Calling thread MUST NOT hold any critical section
//*
//* PARAMETERS:
//*     [IN ]   PJOB_ENTRY lpJobEntry
//*         The job that failed. It must be in FSPI_JS_ABORTED or FSPI_JS_FAILED
//*         state.
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfully.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended errror
//*         information.
//*********************************************************************************
BOOL HandleFailedSendJob(PJOB_ENTRY lpJobEntry)
{
    PJOB_QUEUE lpJobQueue;
    BOOL bRetrying = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("HandleFailedSendJob"));
    DWORD dwRes;
    TCHAR tszJobTiffFile[MAX_PATH] = {0};    // Deleted after receipt is sent
    BOOL fAddRetryDelay = TRUE;

    EnterCriticalSection ( &g_CsJob );
    EnterCriticalSection ( &g_CsQueue );

    Assert(lpJobEntry);
    lpJobQueue = lpJobEntry->lpJobQueueEntry;
    Assert(lpJobQueue);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Failed Job: %ld"),
        lpJobQueue->JobId);

    Assert( FSPI_JS_ABORTED == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_FAILED == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_FAILED_NO_RETRY == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_DELETED == lpJobEntry->FSPIJobStatus.dwJobStatus);
    //
    // Do not cache rendered tiff files
    //
    if (lpJobQueue->FileName)
    {
        //
        // We simply store the file name to delete and delete it later
        // since we might need it for receipt attachment.
        //
        _tcsncpy (tszJobTiffFile,
                  lpJobQueue->FileName,
                  (sizeof (tszJobTiffFile) / sizeof (tszJobTiffFile[0]))-1);
        
        MemFree (lpJobQueue->FileName);
        lpJobQueue->FileName = NULL;
    }
    //
    // Update end time in JOB_ENTRY
    //
    GetSystemTimeAsFileTime( (FILETIME*) &lpJobEntry->EndTime );

    //
    // Update elapsed time in JOB_ENTRY
    //
    Assert (lpJobEntry->EndTime >= lpJobEntry->StartTime);
    lpJobEntry->ElapsedTime = lpJobEntry->EndTime - lpJobEntry->StartTime;
    if ( FSPI_JS_ABORTED == lpJobEntry->FSPIJobStatus.dwJobStatus)
    {
        //
        // The FSP reported the job was aborted.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job Id: %ld] EFSP reported that job was aborted."),
            lpJobQueue->JobId);

        //
        // Check if the job was aborted by the service (shutting down) or by the user
        //
        if (FALSE == lpJobEntry->fSystemAbort)
        {
            //
            // The event log about a canceled job will be reported at the end of this if..else block.
            //
            lpJobEntry->Aborting = 1;
            bRetrying = FALSE;  // Do not retry on cancel
        }
        else
        {
            //
            // SystemAbort
            // Don't increase the retry count since this is not really a failure.
            //
            bRetrying = TRUE;
            fAddRetryDelay = FALSE;
        }
    }
    else if ( FSPI_JS_FAILED == lpJobEntry->FSPIJobStatus.dwJobStatus)
    {
        switch (lpJobEntry->FSPIJobStatus.dwExtendedStatus)
        {
            case FSPI_ES_LINE_UNAVAILABLE:
                //
                // this is the glare condition. Someone snatched the line before the FSP
                // had a chance to grab it.
                // We will try again but will not increase the retry count.
                //
                EnterCriticalSection (&g_CsLine);
                //
                // Check if the line was busy or closed
                //
                if (!(lpJobEntry->LineInfo->Flags & FPF_VIRTUAL))
                {
                    //
                    // Tapi line
                    //
                    if (NULL == lpJobEntry->LineInfo->hLine)
                    {
                        //
                        // Tapi worker thread got LINE_CLOSE
                        //
                        fAddRetryDelay = FALSE;
                    }
                }
                LeaveCriticalSection (&g_CsLine);

                bRetrying = TRUE;
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed connections' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedConnections );
                }
                //
                // Don't increase the retry count since this is not really a failure.
                //
                break;

            case FSPI_ES_NO_ANSWER:
            case FSPI_ES_NO_DIAL_TONE:
            case FSPI_ES_DISCONNECTED:
            case FSPI_ES_BUSY:
            case FSPI_ES_NOT_FAX_CALL:
            case FSPI_ES_CALL_DELAYED:
                //
                // For these error codes we need to retry
                //
                bRetrying = CheckForJobRetry(lpJobQueue);
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed connections' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedConnections );
                }
                break;

            case FSPI_ES_FATAL_ERROR:
                //
                // For these error codes we need to retry
                //
                bRetrying = CheckForJobRetry(lpJobQueue);
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed transmissions' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedXmit );
                }
                break;
            case FSPI_ES_BAD_ADDRESS:
            case FSPI_ES_CALL_BLACKLISTED:
                //
                // No retry for these error codes
                //
                bRetrying = FALSE;
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed connections' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedConnections );
                }
                break;
            default:
                //
                // Our default for extension codes
                // is to retry.
                //
                bRetrying = CheckForJobRetry(lpJobQueue);
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed transmissions' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedXmit );
                }
                break;
        }

    }
    else if ( FSPI_JS_FAILED_NO_RETRY == lpJobEntry->FSPIJobStatus.dwJobStatus )
    {
        //
        // The FSP indicated that there is no point in retrying this job.
        //
        bRetrying = FALSE;
    }
    else if ( FSPI_JS_DELETED == lpJobEntry->FSPIJobStatus.dwJobStatus )
    {
        //
        // This is the case where the job can not be reestablished
        // we treat it as a failure with no retry.
        bRetrying = FALSE;
    }

    if (lpJobEntry->Aborting )
    {
        //
        // An abort operation is in progress for this job.
        // No point in retrying.
        // Just mark the job as canceled and see if we can remove the parent job yet.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] lpJobEntry->Aborting is ON."));

         lpJobQueue->JobStatus = JS_CANCELED;
         if (!UpdatePersistentJobStatus(lpJobQueue))
         {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Failed to update persistent job status to 0x%08x"),
                 lpJobQueue->JobStatus);
             Assert(FALSE);
         }
         lpJobQueue->lpParentJob->dwCanceledRecipientJobsCount+=1;
         bRetrying = FALSE;
    }      

    //
    // Save the last extended status before ending this job
    //
    lpJobQueue->dwLastJobExtendedStatus = lpJobEntry->FSPIJobStatus.dwExtendedStatus;
	HRESULT hr = StringCchCopy(
		lpJobQueue->ExStatusString,
		ARR_SIZE(lpJobQueue->ExStatusString),
		lpJobQueue->JobEntry->ExStatusString);
	if (FAILED(hr))
	{
		//
		// Can never happen, we use large enough buffer.
		//
		ASSERT_FALSE;
	}    

    if (!bRetrying && !lpJobEntry->Aborting)
    {
        //
        // If we do not handle an abort request (in this case we do not want
        // to count it as a failure since it will be counted as Canceled) and we decided
        // not to retry then we need to mark the job as expired.
        //
        if (0 == lpJobQueue->dwLastJobExtendedStatus)
        {
            //
            // Job was never really executed - this is a fatal error
            //
            lpJobQueue->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
			lpJobQueue->ExStatusString[0] = L'\0';            
        }
        if (!MarkJobAsExpired(lpJobQueue))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
        }
    }

    if (!bRetrying)
    {
        //
        // Job reached final failure state - send negative receipt
        // We will send the receipt once we are out of all critical sections because this call can be blocking.
        // just increase the preview refernce count so the job will not be deleted.
        //
        IncreaseJobRefCount (lpJobQueue, TRUE); // TRUE - preview
        //
        // Copy receipt information from JobEntry.
        //
        lpJobQueue->StartTime           = lpJobQueue->JobEntry->StartTime;
        lpJobQueue->EndTime             = lpJobQueue->JobEntry->EndTime;
    }
    else
    {
        //
        // Job marked for retry. Do not delete it. Reschedule it.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] Set for retry (JS_RETRYING). Retry Count = %ld)"),
            lpJobQueue->JobId,
            lpJobQueue->SendRetries);

        lpJobQueue->JobStatus = JS_RETRYING;
        //
        // Job entry must be NULLified before leaving the CS.
        // This is done below because we still need the Job entry for logging
        //
        if (TRUE == fAddRetryDelay)
        {
            //
            // Send failure - Reschedule
            //
            RescheduleJobQueueEntry( lpJobQueue );
        }
        else
        {
            //
            // FaxDevShutDown() was called, or We lost the line, Do not add retry delay
            //
            if (!CommitQueueEntry(lpJobQueue))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CommitQueueEntry() for recipien job %s has failed. (ec: %ld)"),
                    lpJobQueue->FileName,
                    GetLastError());
            }
        }
    }

    FaxLogSend(
        lpJobQueue,
        bRetrying);

    if (!bRetrying)
    {
        EnterCriticalSection (&g_CsOutboundActivityLogging);
        if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
        {
            DebugPrintEx(DEBUG_ERR,
                      TEXT("Logging not initialized"));
        }
        else
        {
            if (!LogOutboundActivity(lpJobQueue))
            {
                DebugPrintEx(DEBUG_ERR, TEXT("Logging outbound activity failed"));
            }
        }
        LeaveCriticalSection (&g_CsOutboundActivityLogging);
    }
    //
    // Notify clients on status change
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS, lpJobQueue);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobQueue->UniqueId,
            dwRes);
    }
    //
    // EndJob() must be called BEFORE we remove the parent job (and recipients)
    //
    lpJobEntry->LineInfo->State = FPS_AVAILABLE;
    //
    // We just completed a send job on the device - update counter.
    //
    (VOID) UpdateDeviceJobsCounter ( lpJobEntry->LineInfo,             // Device to update
                                     TRUE,                             // Sending
                                     -1,                               // Number of new jobs (-1 = decrease by one)
                                     TRUE);                            // Enable events

    if (!EndJob( lpJobEntry ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EndJob Failed. (ec: %ld)"),
            GetLastError());
    }

    lpJobQueue->JobEntry = NULL;

    if (JS_CANCELED == lpJobQueue->JobStatus)
    {

        DWORD dwJobId;

        dwJobId = lpJobQueue->JobId;

        // Job was canceled - decrease reference count
        DecreaseJobRefCount (lpJobQueue, TRUE);  // This will mark it as JS_DELETING if needed
         //
         // We need to send the legacy W2K FEI_DELETING notification.
         //
         if (!CreateFaxEvent(0, FEI_DELETED, dwJobId))
        {

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (ec: %ld)"),
                FEI_DELETED,
                lpJobQueue->JobId,
                0,
                GetLastError());
        }
    }

    //
    // Notify the queue that a device is now available.
    //
    if (!SetEvent( g_hJobQueueEvent ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
            GetLastError());

        g_ScanQueueAfterTimeout = TRUE;
    }

    LeaveCriticalSection ( &g_CsQueue );
    LeaveCriticalSection ( &g_CsJob );

    //
    // Now, send the receipt
    //
    if (!bRetrying)
    {
        //
        // Job reached final failure state - send negative receipt
        //
        if (!SendJobReceipt (FALSE, lpJobQueue, tszJobTiffFile))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] SendJobReceipt failed. (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError ());
        }
        EnterCriticalSection (&g_CsQueue);
        DecreaseJobRefCount (lpJobQueue, TRUE, TRUE, TRUE);  // last TRUE for Preview ref count.
        LeaveCriticalSection (&g_CsQueue);
    }

    if (lstrlen (tszJobTiffFile))
    {
        //
        // Now we can safely delete the job's TIFF file
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Deleting per recipient body file %s"),
                     tszJobTiffFile);
        if (!DeleteFile( tszJobTiffFile ))
        {
            DebugPrintEx(DEBUG_MSG,
                         TEXT("Failed to delete per recipient body file %s (ec: %ld)"),
                         tszJobTiffFile,
                         GetLastError());            
        }
    }
    return TRUE;
}   // HandleFailedSendJob


//*********************************************************************************
//* Name:   StartReceiveJob()
//* Author: Ronen Barenboim
//* Date:   June 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Starts a receive job on the specified device.
//* PARAMETERS:
//*     [IN ]       DWORD DeviceId
//*         The permanent line id (not TAPI) of the device on which the fax is
//*         to be received.
//*
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_ENTRY
StartReceiveJob(
    DWORD DeviceId
    )

{
    BOOL Failure = TRUE;
    PJOB_ENTRY JobEntry = NULL;
    PLINE_INFO LineInfo;
    BOOL bRes = FALSE;

    DWORD rc = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("StartRecieveJob"));

    LineInfo = GetTapiLineForFaxOperation(
                    DeviceId,
                    JT_RECEIVE,
                    NULL                    
                    );

    if (!LineInfo)
    {
        //
        // Could not find a line to send the fax on.
        //
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Failed to find a line to send the fax on. (ec: %ld)"),
            rc);
        goto exit;
    }

    JobEntry = CreateJobEntry(NULL, LineInfo, FALSE);
    if (!JobEntry)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create JobEntry. (ec: %ld)"),
            rc);
        goto exit;
    }

    __try
    {
        //
        // Call the FSP associated with the line to start a fax job. Note that at this
        // point it is not known if the job is send or receive.
        //
        bRes = LineInfo->Provider->FaxDevStartJob(
                LineInfo->hLine,
                LineInfo->DeviceId,
                (PHANDLE) &JobEntry->InstanceData, // JOB_ENTRY.InstanceData is where the FSP will place its
                                                   // job handle (fax handle).
                g_StatusCompletionPortHandle,
                (ULONG_PTR) LineInfo ); // Note that the completion key provided to the FSP is the LineInfo
                                        // pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, LineInfo->Provider->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }

    if (!bRes)
    {
        rc = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("FaxDevStartJob failed (ec: %ld)"),GetLastError());
        goto exit;
    }

    //
    // Add the new JOB_ENTRY to the job list.
    //

    EnterCriticalSection( &g_CsJob );
    JobEntry->bFSPJobInProgress =  TRUE;
    InsertTailList( &g_JobListHead, &JobEntry->ListEntry );
    LeaveCriticalSection( &g_CsJob );
    Failure = FALSE;




    //
    // Attach the job to the line selected to service it.
    //
    LineInfo->JobEntry = JobEntry;

exit:
    if (Failure)
    { // Failure is initialized to TRUE
        if (LineInfo)
        {
            ReleaseTapiLine( LineInfo,  0 );
        }

        if (JobEntry)
        {
            EndJob(JobEntry);
        }
        JobEntry = NULL;
    }
    if (ERROR_SUCCESS != rc)
    {
        SetLastError(rc);

        FaxLog(FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            0,
            MSG_FAX_RECEIVE_FAILED);

    }
    return JobEntry;
}


//*********************************************************************************
//* Name:   StartRoutingJob()
//* Author: Mooly Beery (MoolyB)
//* Date:   July 20, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Starts a routing operation. Must lock g_CsJob and g_CsQueue.
//* PARAMETERS:
//*     [IN/OUT ]   PJOB_QUEUE lpJobQueueEntry
//*         A pointer to the job for which the routing operation is to be
//*         performed.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed. Call GetLastError() to get extended error
//*         information.
//*
//*********************************************************************************
BOOL
StartRoutingJob(
    PJOB_QUEUE lpJobQueueEntry
    )
{
    DWORD ec = ERROR_SUCCESS;
    HANDLE hThread = NULL;
    DWORD ThreadId;

    DEBUG_FUNCTION_NAME(TEXT("StartRoutingJob"));

    //
    // We mark the job as IN_PROGRESS so it can not be deleted or routed simultaneously
    //
    lpJobQueueEntry->JobStatus = JS_INPROGRESS;

    hThread = CreateThreadAndRefCount(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) FaxRouteThread,
                            (LPVOID) lpJobQueueEntry,
                            0,
                            &ThreadId
                            );

    if (hThread == NULL)
    {
        ec = GetLastError();
        DebugPrintEx(   DEBUG_ERR,
                        _T("CreateThreadAndRefCount for FaxRouteThread failed (ec: 0x%0X)"),
                        ec);

        if (!MarkJobAsExpired(lpJobQueueEntry))
        {
            DEBUG_ERR,
            TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
            lpJobQueueEntry->JobId,
            GetLastError();
        }

        SetLastError(ec);
        return FALSE;
    }

    DebugPrintEx(   DEBUG_MSG,
                    _T("FaxRouteThread thread created for job id %d ")
                    _T("(thread id: 0x%0x)"),
                    lpJobQueueEntry->JobId,
                    ThreadId);

    CloseHandle( hThread );

    //
    // Create Fax EventEx
    //
    DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                     lpJobQueueEntry);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) ")
                        _T("failed for job id %ld (ec: %ld)"),
                        lpJobQueueEntry->JobId,
                        dwRes);
    }
    return TRUE;
}

//*********************************************************************************
//* Name:   StartSendJob()
//* Author: Ronen Barenboim
//* Date:   June 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Starts a send operation on a legacy of Extened FSP device.
//* PARAMETERS:
//*     [IN/OUT ]   PJOB_QUEUE lpJobQueueEntry
//*         A pointer to the recipient job for which the send operation is to be
//*         performed. For extended sends this is the Anchor recipient.
//*
//*     [IN/OUT]    PLINE_INFO lpLineInfo
//*         A pointer to the line on which the send operatin is to be performed.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed. Call GetLastError() to get extended error
//*         information.
//*
//*********************************************************************************
BOOL
StartSendJob(
    PJOB_QUEUE lpJobQueueEntry,
    PLINE_INFO lpLineInfo    
    )
{
    DWORD rc = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("StartSendJob"));

    Assert(lpJobQueueEntry);
    Assert(JT_SEND == lpJobQueueEntry->JobType);
    Assert(lpLineInfo);

    if (FSPI_API_VERSION_1 == lpLineInfo->Provider->dwAPIVersion)
    {
        if (!StartLegacySendJob(lpJobQueueEntry,lpLineInfo))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StartLegacySendJob() failed for JobId: %ld (ec: %ld)"),
                lpJobQueueEntry->JobId,
                GetLastError());
            goto exit;
        }
    }    
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Unsupported FSPI version (0x%08X) for line : %s "),
            lpLineInfo->Provider->dwAPIVersion,
            lpLineInfo->DeviceName);
        Assert(FALSE);
        goto exit;
    }


exit:

    if (ERROR_SUCCESS != rc) {
        SetLastError(rc);

        TCHAR strJobID[20]={0};
        //
        //  Convert Job ID into a string. (the string is 18 TCHARs long !!!)
        //
		HRESULT hr = StringCchPrintf(
			strJobID,
			ARR_SIZE(strJobID),
			TEXT("0x%016I64x"),
			lpJobQueueEntry->UniqueId);
		if (FAILED(hr))
		{
			//
			// Should never happen, we use large enough buffer.
			//
			ASSERT_FALSE;
		}        
    
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            7,
            MSG_FAX_SEND_FAILED,
            lpJobQueueEntry->SenderProfile.lptstrName,
            lpJobQueueEntry->SenderProfile.lptstrBillingCode,
            lpJobQueueEntry->SenderProfile.lptstrCompany,
            lpJobQueueEntry->SenderProfile.lptstrDepartment,
            lpLineInfo->DeviceName,
            strJobID,
            lpJobQueueEntry->lpParentJob->UserName
            );

    }
    return (0 == rc);

}




//*********************************************************************************
//* Name:   StartLegacySendJob()
//* Author: Ronen Barenboim
//* Date:   June 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Starts the operation of sending a fax on a legacy FSP device.
//*         - creates the JOB_ENTRY
//*         - calls FaxDevStartJob()
//*         - calls SendDocument() to actually send the document
//*         - calls EndJob() if anything goes wrong.
//*
//* PARAMETERS:
//*     [XXX]       PJOB_QUEUE lpJobQueue
//*         A pointer to the recipient job for the send operation is to be started.
//*     [XXX]       PLINE_INFO lpLineInfo
//*         A pointer to the LINE_INFO of the line on which the fax is to be sent.
//*
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if it failed. Call GetLastError() to get extended error information.
//*
//*********************************************************************************
PJOB_ENTRY StartLegacySendJob(
    PJOB_QUEUE lpJobQueue,
    PLINE_INFO lpLineInfo
    )
{

    PJOB_ENTRY lpJobEntry = NULL;
    DWORD rc = 0;
    DWORD dwRes;


    DEBUG_FUNCTION_NAME(TEXT("StartLegacySendJob"));
    Assert(JT_SEND == lpJobQueue->JobType);
    Assert(FSPI_API_VERSION_1 == lpLineInfo->Provider->dwAPIVersion);

    lpJobEntry = CreateJobEntry(lpJobQueue, lpLineInfo, TRUE);
    if (!lpJobEntry)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create JobEntry for JobId: %ld. (ec: %ld)"),
            lpJobQueue->JobId,
            rc);
        goto Error;
    }
    lpJobQueue->JobStatus = JS_INPROGRESS;
    //
    // Add the new JOB_ENTRY to the job list.
    //
    EnterCriticalSection( &g_CsJob );
    InsertTailList( &g_JobListHead, &lpJobEntry->ListEntry );
    LeaveCriticalSection( &g_CsJob );

    //
    // Attach the job to the line selected to service it.
    //
    lpLineInfo->JobEntry = lpJobEntry;
    lpJobQueue->JobEntry = lpJobEntry;


    __try
    {
        //
        // Call the FSP associated with the line to start a fax job. Note that at this
        // point it is not known if the job is send or receive.
        //
        if (lpLineInfo->Provider->FaxDevStartJob(
                lpLineInfo->hLine,
                lpLineInfo->DeviceId,
                (PHANDLE) &lpJobEntry->InstanceData, // JOB_ENTRY.InstanceData is where the FSP will place its
                                                   // job handle (fax handle).
                g_StatusCompletionPortHandle,
                (ULONG_PTR) lpLineInfo )) // Note that the completion key provided to the FSP is the LineInfo
                                        // pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("FaxDevStartJob() Successfuly called for JobId: %ld)"),
                lpJobQueue->JobId);
            lpJobEntry->bFSPJobInProgress = TRUE;
        }
        else
        {
            rc = GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("FaxDevStartJob() failed (ec: %ld)"),rc);
            if (0 == rc)
            {
                //
                // FSP failed to report last error so we set our own.
                //
                DebugPrintEx(DEBUG_ERR,TEXT("FaxDevStartJob() failed but reported 0 for last error"));
                rc = ERROR_GEN_FAILURE;
            }
            goto Error;
        }
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, lpLineInfo->Provider->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }

    //
    // start the send job
    //
    rc = SendDocument(
        lpJobEntry,
        lpJobQueue->FileName
        );


    if (rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SendDocument failed for JobId: %ld (ec: %ld)"),
            lpJobQueue->JobId,
            rc);
        goto Error;
    }

    Assert (0 == rc);
    goto Exit;
Error:
    Assert( 0 != rc);
    if (lpJobEntry)
    {
        if (!EndJob(lpJobEntry))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EndJob() failed for JobId: %ld (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
        }
        lpJobEntry = NULL;
        lpJobQueue->JobEntry = NULL;
    }
    else
    {
        //
        // Release the line
        //
        if (!ReleaseTapiLine(lpLineInfo, NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseTapiLine() failed (ec: %ld)"),
                GetLastError());
        }
    }

    //
    // set the job into the retries exceeded state
    //
    if (0 == lpJobQueue->dwLastJobExtendedStatus)
    {
        //
        // Job was never really executed - this is a fatal error
        //
        lpJobQueue->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
		lpJobQueue->ExStatusString[0] = L'\0';        
    }
    if (!MarkJobAsExpired(lpJobQueue))
    {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
    }

    //
    // Notify clients on status change
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS, lpJobQueue);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobQueue->UniqueId,
            dwRes);
    }

Exit:
    if (rc)
    {
        SetLastError(rc);
    }
    return lpJobEntry;
}


//*********************************************************************************
//* Name:   UpdateJobStatus()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Updated the FSPI job status kept in the job entry.
//*     Generates legacy API event and new events as required.
//* PARAMETERS:
//*     [OUT]           PJOB_ENTRY lpJobEntry
//*         The job entry whose FSPI status is to be udpated.
//*
//*     [IN]            LPCFSPI_JOB_STATUS lpcFSPJobStatus
//*         The new FSPI job status.
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if the operation failed. Call GetLastError() to get extended error
//*     information.
//* Remarks:
//*     The function fress the last FSPI job status held in the job entry
//*     (if any).
//*********************************************************************************
BOOL UpdateJobStatus(
        PJOB_ENTRY lpJobEntry,
        LPCFSPI_JOB_STATUS lpcFSPJobStatus
        )
{
    DWORD ec = 0;
    DWORD dwEventId;
    DWORD Size = 0;
    HINSTANCE hLoadInstance = NULL;

    DEBUG_FUNCTION_NAME(TEXT("UpdateJobStatus"));

    Assert(lpJobEntry);
    Assert(lpcFSPJobStatus);
    Assert (lpJobEntry->lpJobQueueEntry);

    EnterCriticalSection( &g_CsJob );

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("dwJobStatus: 0x%08X dwExtendedStatus: 0x%08X"),
        lpcFSPJobStatus->dwJobStatus,
        lpcFSPJobStatus->dwExtendedStatus
        );

    if (TRUE == lpJobEntry->fStopUpdateStatus)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("JobId: %ld. fStopUpdateStatus was set. Not updating status"),
            lpJobEntry->lpJobQueueEntry->JobId,
            lpJobEntry->lpJobQueueEntry->JobStatus);
        LeaveCriticalSection (&g_CsJob);
        return TRUE;
    }    
    
    //
    // Map the FSPI job status to an FEI_* event (0 if not event matches the status)
    //
    dwEventId = MapFSPIJobStatusToEventId(lpcFSPJobStatus);
    //
    // Note: W2K Fax did issue notifications with EventId == 0 whenever an
    // FSP reported proprietry status code. To keep backward compatability
    // we keep up this behaviour although it might be regarded as a bug
    //
    if (!CreateFaxEvent( lpJobEntry->LineInfo->PermanentLineID, dwEventId, lpJobEntry->lpJobQueueEntry->JobId ))
    {
        if ( TRUE == g_bServiceIsDown)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (Service is going down)"),
                dwEventId,
                lpJobEntry->lpJobQueueEntry->JobId,
                lpJobEntry->LineInfo->PermanentLineID
                );
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (ec: %ld)"),
                dwEventId,
                lpJobEntry->lpJobQueueEntry->JobId,
                lpJobEntry->LineInfo->PermanentLineID,
                GetLastError());
            Assert(FALSE);
        }

    }   

    lpJobEntry->FSPIJobStatus.dwJobStatus = lpcFSPJobStatus->dwJobStatus;
    lpJobEntry->FSPIJobStatus.dwExtendedStatus = lpcFSPJobStatus->dwExtendedStatus;
    lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId = lpcFSPJobStatus->dwExtendedStatusStringId;

    if (lpcFSPJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_PAGECOUNT)
    {
        lpJobEntry->FSPIJobStatus.dwPageCount = lpcFSPJobStatus->dwPageCount;
        lpJobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_PAGECOUNT;
    }

    if (lpcFSPJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_START)
    {
        lpJobEntry->FSPIJobStatus.tmTransmissionStart = lpcFSPJobStatus->tmTransmissionStart;
        lpJobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_TRANSMISSION_START;
    }

    if (lpcFSPJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_END)
    {
        lpJobEntry->FSPIJobStatus.tmTransmissionEnd = lpcFSPJobStatus->tmTransmissionEnd;
        lpJobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_TRANSMISSION_END;
    }

    if (NULL != lpcFSPJobStatus->lpwstrRemoteStationId)
    {
        if (!ReplaceStringWithCopy(&lpJobEntry->FSPIJobStatus.lpwstrRemoteStationId,
                                    lpcFSPJobStatus->lpwstrRemoteStationId))
        {
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReplaceStringWithCopy() failed.  (ec: %ld)"),
            GetLastError());
        }
    }

    if (NULL != lpcFSPJobStatus->lpwstrCallerId)
    {
        if (!ReplaceStringWithCopy(&lpJobEntry->FSPIJobStatus.lpwstrCallerId,
                                    lpcFSPJobStatus->lpwstrCallerId))
        {
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReplaceStringWithCopy() failed.  (ec: %ld)"),
            GetLastError());
        }
    }

    if (NULL != lpcFSPJobStatus->lpwstrRoutingInfo)
    {
        if (!ReplaceStringWithCopy(&lpJobEntry->FSPIJobStatus.lpwstrRoutingInfo,
                                    lpcFSPJobStatus->lpwstrRoutingInfo))
        {
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReplaceStringWithCopy() failed.  (ec: %ld)"),
            GetLastError());
        }
    }
	lpJobEntry->ExStatusString[0] = L'\0';    
    //
    // Get extended status string
    //
    Assert (lpJobEntry->LineInfo != NULL)

    if (lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId != 0)
    {
        Assert (lpJobEntry->FSPIJobStatus.dwExtendedStatus != 0);
        if ( !_tcsicmp(lpJobEntry->LineInfo->Provider->szGUID,REGVAL_T30_PROVIDER_GUID_STRING) )
        {   // special case where the FSP is our FSP (fxst30.dll).
            hLoadInstance = g_hResource;
        }
        else
        {
            hLoadInstance = lpJobEntry->LineInfo->Provider->hModule;
        }
        Size = LoadString (hLoadInstance,
                           lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId,
                           lpJobEntry->ExStatusString,
                           sizeof(lpJobEntry->ExStatusString)/sizeof(WCHAR));
        if (Size == 0)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to load extended status string (ec: %ld) stringid : %ld, Provider: %s"),
                ec,
                lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId,
                lpJobEntry->LineInfo->Provider->ImageName);

            lpJobEntry->FSPIJobStatus.fAvailableStatusInfo &= ~FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;
            lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId = 0;
            lpJobEntry->FSPIJobStatus.dwExtendedStatus = 0;
            goto Error;
        }
    }

    EnterCriticalSection (&g_CsQueue);
    DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                     lpJobEntry->lpJobQueueEntry);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobEntry->lpJobQueueEntry->UniqueId,
            dwRes);
    }
    LeaveCriticalSection (&g_CsQueue);
    

    Assert (0 == ec);
    goto Exit;

Error:
    Assert( ec !=0 );
Exit:
    LeaveCriticalSection( &g_CsJob );
    if (ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);
}




//*********************************************************************************
//* Name:   CheckForJobRetry
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Checks if a recipient job should be retried.
//*     Increments the retry count and marks the job as expired if it passed
//*     the retry limit.
//* PARAMETERS:
//*     [IN/OUT]    PJOB_QUEUE lpJobQueue
//*         A pointer to the JOB_QUEUE structure of the recipient job.
//* RETURN VALUE:
//*     TRUE if the job is to be retried.
//*     FALSE if it is not to be retried.
//*********************************************************************************
BOOL CheckForJobRetry (PJOB_QUEUE lpJobQueue)
{

    PJOB_ENTRY lpJobEntry;
    DWORD dwMaxRetries;
    DEBUG_FUNCTION_NAME(TEXT("CheckForJobRetry"));
    Assert(lpJobQueue);
    lpJobEntry = lpJobQueue->JobEntry;
    Assert(lpJobEntry);
    //
    // Increase the retry count and check if we exceeded maximum retries.
    //
    EnterCriticalSection (&g_CsConfig);
    dwMaxRetries = g_dwFaxSendRetries;
    LeaveCriticalSection (&g_CsConfig);   
    
    lpJobQueue->SendRetries++;
    
    if (lpJobQueue->SendRetries <= dwMaxRetries)
    {
        return TRUE;
    }
    else
    {
        //
        // retries exceeded report that the job is not to be retried
        return FALSE;
    }
}



//*********************************************************************************
//* Name:   FindJobEntryByRecipientNumber()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Finds the first running job that is destined to a certain number.
//*
//* PARAMETERS:
//*     [IN ]   LPTSTR lptstrNumber
//*         The number to match. This must be in canonical form.
//*
//* RETURN VALUE:
//*     A pointer to the JOB_ENTRY in the g_JobListHead list that is destined to
//*     the specified number.
//*     If no such job is found the return value is NULL.
//*********************************************************************************
PJOB_ENTRY FindJobEntryByRecipientNumber(LPCWSTR lpcwstrNumber)
{

    PLIST_ENTRY lpNext;
    PJOB_ENTRY lpJobEntry;
    DEBUG_FUNCTION_NAME(TEXT("FindJobEntryByRecipientNumber"));
    Assert(lpcwstrNumber);
    lpNext = g_JobListHead.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&g_JobListHead) {
        lpJobEntry = CONTAINING_RECORD( lpNext, JOB_ENTRY, ListEntry );
        lpNext = lpJobEntry->ListEntry.Flink;
        if (JT_SEND == lpJobEntry->lpJobQueueEntry->JobType)
        {
            if (!_wcsicmp(lpJobEntry->lpJobQueueEntry->RecipientProfile.lptstrFaxNumber, lpcwstrNumber))
            {
                return lpJobEntry;
            }
        }
    }
    return NULL;
}


BOOL CreateJobQueueThread(void)
{
    DWORD ThreadId;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("CreateJobQueueThread"));

    g_hJobQueueThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) JobQueueThread,
        NULL,
        0,
        &ThreadId
        );
    if (NULL == g_hJobQueueThread)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create JobQueueThread (ec: %ld)."),
            GetLastError());
        goto Error;
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
    //
    // We don't close the already created threads. (They are terminated on process exit).
    //
Exit:    
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}

BOOL CreateStatusThreads(void)
{
    int i;
    DWORD ThreadId;
    DWORD ec = ERROR_SUCCESS;
    HANDLE hStatusThreads[MAX_STATUS_THREADS];

    DEBUG_FUNCTION_NAME(TEXT("CreateStatusThreads"));

    memset(hStatusThreads, 0, sizeof(HANDLE)*MAX_STATUS_THREADS);

    for (i=0; i<MAX_STATUS_THREADS; i++) {
        hStatusThreads[i] = CreateThreadAndRefCount(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) FaxStatusThread,
            NULL,
            0,
            &ThreadId
            );

        if (!hStatusThreads[i]) {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to create status thread %d (CreateThreadAndRefCount)(ec=0x%08x)."),
                i,
                ec);
            goto Error;
        }
    }

    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:
    //
    // Close the thread handles we no longer need them
    //
    for (i=0; i<MAX_STATUS_THREADS; i++)
    {
        if(NULL == hStatusThreads[i])
        {
            continue;
        }
        if (!CloseHandle(hStatusThreads[i]))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to close thread handle at index %ld [handle = 0x%08X] (ec=0x%08x)."),
                i,
                hStatusThreads[i],
                GetLastError());
        }
    }
    if (ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}

static
BOOL
SendJobReceipt (
    BOOL              bPositive,
    JOB_QUEUE *       lpJobQueue,
    LPCTSTR           lpctstrAttachment
)
/*++

Routine name : SendJobReceipt

Routine description:

    Determines if a receipts should be send and calls SendReceipt accordingly

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive         [in]     - Did current job ended successfully?
    lpJobQueue        [in]     - Pointer to recipient job that just ended
    lpctstrAttachment [in]     - Job TIFF file to attach (in case of single recipient job only)

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    BOOL bSingleJobReceipt = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("SendJobReceipt)"));

    if (lpJobQueue->lpParentJob->dwRecipientJobsCount > 1)
    {
        //
        // Broadcast case
        //
        if (lpJobQueue->JobParamsEx.dwReceiptDeliveryType & DRT_GRP_PARENT)
        {
            //
            // Broadcast receipt grouping is requested
            //
            if (IsSendJobReadyForDeleting (lpJobQueue))
            {
                //
                // This is the last job in the broadcast, it's time to send a broadcast receipt
                //

                //
                // As receipt sending is async, there still might be a chance that more than one recipient jobs will reach this point
                // We must verify that only one receipt is sent per broadcast job
                //
                EnterCriticalSection (&g_CsQueue);
                if (FALSE == lpJobQueue->lpParentJob->fReceiptSent)
                {
                    PJOB_QUEUE pParentJob = lpJobQueue->lpParentJob;
                    BOOL bPositiveBroadcast =
                    (pParentJob->dwCompletedRecipientJobsCount == pParentJob->dwRecipientJobsCount) ?
                    TRUE : FALSE;

                    //
                    //  set the flag so we will not send duplicate receipts for broadcast
                    //
                    lpJobQueue->lpParentJob->fReceiptSent = TRUE;

                    //
                    // Leave g_CsQueue so we will not block the service
                    //
                    LeaveCriticalSection (&g_CsQueue);

                    if (!SendReceipt(bPositiveBroadcast,
                                     TRUE,
                                     pParentJob,
                                     pParentJob->FileName))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("[Job Id: %ld] Failed to send broadcast receipt. (ec: %ld)"),
                            lpJobQueue->JobId,
                            GetLastError());
                        return FALSE;
                    }
                }
                else
                {
                    //
                    // More than one job reached this point when the broadcast jo was ready for deleting.
                    // Only on  receipt is sent
                    //
                    LeaveCriticalSection (&g_CsQueue);
                }
            }
            else
            {
                //
                // More jobs are still not finished, do not send receipt
                //
            }
        }
        else
        {
            //
            // This is a recipient part of a broadcast but the user was
            // asking for a receipt for every recipient.
            //
            bSingleJobReceipt = TRUE;
        }
    }
    else
    {
        //
        // This is not a broadcast case
        //
        bSingleJobReceipt = TRUE;
    }
    if (bSingleJobReceipt)
    {
        //
        // Send receipt for this job only
        //
        if (!SendReceipt(bPositive, FALSE, lpJobQueue, lpctstrAttachment))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[Job Id: %ld] Failed to send POSITIVE receipt. (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
            return FALSE;
        }
    }
    return TRUE;
}   // SendJobReceipt

VOID
UpdateDeviceJobsCounter (
    PLINE_INFO      pLine,
    BOOL            bSend,
    int             iInc,
    BOOL            bNotify
)
/*++

Routine name : UpdateDeviceJobsCounter

Routine description:

    Updates the send or receive jobs counter of a device

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    pLine                         [in]     - Device pointer
    bSend                         [in]     - Send counter (FALSE = Receive counter)
    iInc                          [in]     - Increase jobs count (negative means decrease)
    decrease                      [in]     - Allow events (FAX_EVENT_TYPE_DEVICE_STATUS)

Return Value:

    None.

--*/
{
    DWORD dwOldCount;
    DWORD dwNewCount;
    DEBUG_FUNCTION_NAME(TEXT("UpdateDeviceJobsCounter)"));

    Assert (pLine);
    if (!iInc)
    {
        //
        // No change
        //
        ASSERT_FALSE;
        return;
    }
    EnterCriticalSection (&g_CsLine);
    dwOldCount = bSend ? pLine->dwSendingJobsCount : pLine->dwReceivingJobsCount;
    if (0 > iInc)
    {
        //
        // Decrease case
        //
        if ((int)dwOldCount + iInc < 0)
        {
            //
            // Weird - should never happen
            //
            ASSERT_FALSE;
            iInc = -(int)dwOldCount;
        }
    }
    dwNewCount = (DWORD)((int)dwOldCount + iInc);
    if (bSend)
    {
        pLine->dwSendingJobsCount = dwNewCount;
    }
    else
    {
        pLine->dwReceivingJobsCount = dwNewCount;
    }
    LeaveCriticalSection (&g_CsLine);
    if (bNotify && ((0 == dwNewCount) || (0 == dwOldCount)))
    {
        //
        // State change
        //
        DWORD ec = CreateDeviceEvent (pLine, FALSE);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateDeviceEvent() (ec: %lc)"),
                ec);
        }
    }
}   // UpdateDeviceJobsCounter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\queue.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module implements the jobqueue

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/
#include <malloc.h>
#include "faxsvc.h"
#pragma hdrstop




static DWORD
CommitHashedQueueEntry(
    HANDLE          hFile,
    PJOB_QUEUE_FILE pJobQueueFile,
    DWORD           JobQueueFileSize
    );

static DWORD
ComputeHashCode(   
    const LPBYTE pJobData,
    DWORD   dwJobDataSize,
    LPBYTE* ppHashData,
    LPDWORD pHashDataSize
    );

static DWORD
GetQueueFileVersion(
    HANDLE  hFile,
    LPDWORD pdwVersion
    );

static DWORD
ReadHashedJobQueueFile(
    HANDLE  hFile,
    PJOB_QUEUE_FILE* lppJobQueueFile
    );

static DWORD
GetQueueFileHashAndData(   
    HANDLE   hFile,
    LPBYTE*  ppHashData,
    LPDWORD  pHashDataSize,
    LPBYTE*  ppJobData,
    LPDWORD  pJobDataSize
    );

static DWORD
ReadLegacyJobQueueFile(
    HANDLE              hFile,
    PJOB_QUEUE_FILE*    lppJobQueueFile
    );

#define BOS_JOB_QUEUE_FILE_SIZE         (sizeof(BOS_JOB_QUEUE_FILE))
#define NET_XP_JOB_QUEUE_FILE_SIZE      (sizeof(JOB_QUEUE_FILE))
#define CURRENT_JOB_QUEUE_FILE_SIZE     NET_XP_JOB_QUEUE_FILE_SIZE

//
//  Queue files version defines
//

typedef enum    // the enum values should never be equal to sizeof(JOB_QUEUE_FILE)
{
    DOT_NET_QUEUE_FILE_VERSION  = (0x00000001)
} QUEUE_ENUM_FILE_VERSION;

#define CURRENT_QUEUE_FILE_VERSION      DOT_NET_QUEUE_FILE_VERSION


typedef enum
{
    JT_SEND__JS_INVALID,
    JT_SEND__JS_PENDING,
    JT_SEND__JS_INPROGRESS,
    JT_SEND__JS_DELETING,
    JT_SEND__JS_RETRYING,
    JT_SEND__JS_RETRIES_EXCEEDED,
    JT_SEND__JS_COMPLETED,
    JT_SEND__JS_CANCELED,
    JT_SEND__JS_CANCELING,
    JT_SEND__JS_ROUTING,
    JT_SEND__JS_FAILED,
    JT_ROUTING__JS_INVALID,
    JT_ROUTING__JS_PENDING,
    JT_ROUTING__JS_INPROGRESS,
    JT_ROUTING__JS_DELETING,
    JT_ROUTING__JS_RETRYING,
    JT_ROUTING__JS_RETRIES_EXCEEDED,
    JT_ROUTING__JS_COMPLETED,
    JT_ROUTING__JS_CANCELED,
    JT_ROUTING__JS_CANCELING,
    JT_ROUTING__JS_ROUTING,
    JT_ROUTING__JS_FAILED,
    JT_RECEIVE__JS_INVALID,
    JT_RECEIVE__JS_PENDING,
    JT_RECEIVE__JS_INPROGRESS,
    JT_RECEIVE__JS_DELETING,
    JT_RECEIVE__JS_RETRYING,
    JT_RECEIVE__JS_RETRIES_EXCEEDED,
    JT_RECEIVE__JS_COMPLETED,
    JT_RECEIVE__JS_CANCELED,
    JT_RECEIVE__JS_CANCELING,
    JT_RECEIVE__JS_ROUTING,
    JT_RECEIVE__JS_FAILED,
    JOB_TYPE__JOBSTATUS_COUNT
} FAX_ENUM_JOB_TYPE__JOB_STATUS;

typedef enum
{
    NO_CHANGE                   = 0x0000,
    QUEUED_INC                  = 0x0001,
    QUEUED_DEC                  = 0x0002,
    OUTGOING_INC                = 0x0004,   
    OUTGOING_DEC                = 0x0008,   
    INCOMING_INC                = 0x0010,
    INCOMING_DEC                = 0x0020,
    ROUTING_INC                 = 0x0040,
    ROUTING_DEC                 = 0x0080,    
    INVALID_CHANGE              = 0x0100
} FAX_ENUM_ACTIVITY_COUNTERS;



//
//  The following table consists of all posible JobType_JobStaus changes and the effect on Server Activity counters.
//  The rows entry is the old Job_Type_JobStatus.
//  The columns entry is the new Job_Type_JobStatus.

static WORD const gsc_JobType_JobStatusTable[JOB_TYPE__JOBSTATUS_COUNT][JOB_TYPE__JOBSTATUS_COUNT] =
{
//                                     JT_SEND__JS_INVALID  |       JT_SEND__JS_PENDING  |       JT_SEND__JS_INPROGRESS  |       JT_SEND__JS_DELETING  |       JT_SEND__JS_RETRYING  |       JT_SEND__JS_RETRIES_EXCEEDED  |       JT_SEND__JS_COMPLETED |       JT_SEND__JS_CANCELED  |       JT_SEND__JS_CANCELING  |       JT_SEND__JS_ROUTING  |       JT_SEND__JS_FAILED   |   JT_ROUTING__JS_INVALID  |  JT_ROUTING__JS_PENDING  |  JT_ROUTING__JS_INPROGRESS  |  JT_ROUTING__JS_DELETING  |  JT_ROUTING__JS_RETRYING  |  JT_ROUTING__JS_RETRIES_EXCEEDED  |  JT_ROUTING__JS_COMPLETED |  JT_ROUTING__JS_CANCELED  |  JT_ROUTING__JS_CANCELING  |  JT_ROUTING__JS_ROUTING  |  JT_ROUTING__JS_FAILED   |   JT_RECEIVE__JS_INVALID  |  JT_RECEIVE__JS_PENDING  |  JT_RECEIVE__JS_INPROGRESS  |  JT_RECEIVE__JS_DELETING  |  JT_RECEIVE__JS_RETRYING  |  JT_RECEIVE__JS_RETRIES_EXCEEDED  |  JT_RECEIVE__JS_COMPLETED |  JT_RECEIVE__JS_CANCELED  |  JT_RECEIVE__JS_CANCELING  |  JT_RECEIVE__JS_ROUTING |   JT_RECEIVE__JS_FAILED
//
/* JT_SEND__JS_INVALID             */{ NO_CHANGE,                   QUEUED_INC,                  INVALID_CHANGE,                 INVALID_CHANGE,               QUEUED_INC,                   NO_CHANGE,                            NO_CHANGE,                    NO_CHANGE,                    INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_PENDING             */{ QUEUED_DEC,                  NO_CHANGE,                   QUEUED_DEC | OUTGOING_INC,      INVALID_CHANGE,               INVALID_CHANGE,               QUEUED_DEC,                           INVALID_CHANGE,               QUEUED_DEC,                   INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_INPROGRESS          */{ INVALID_CHANGE,              INVALID_CHANGE,              NO_CHANGE,                      INVALID_CHANGE,               QUEUED_INC | OUTGOING_DEC,    OUTGOING_DEC,                         OUTGOING_DEC,                 INVALID_CHANGE,               NO_CHANGE,                     INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_DELETING            */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 NO_CHANGE,                    INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_RETRYING            */{ QUEUED_DEC,                  INVALID_CHANGE,              QUEUED_DEC | OUTGOING_INC,      INVALID_CHANGE,               NO_CHANGE,                    QUEUED_DEC,                           INVALID_CHANGE,               QUEUED_DEC,                   INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_RETRIES_EXCEEDED    */{ NO_CHANGE,                   QUEUED_INC,                  INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               NO_CHANGE,                            INVALID_CHANGE,               NO_CHANGE,                    INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_COMPLETED           */{ NO_CHANGE,                   INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       NO_CHANGE,                    INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_CANCELED            */{ NO_CHANGE,                   INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               NO_CHANGE,                    INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_CANCELING           */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       OUTGOING_DEC,                 OUTGOING_DEC,                 NO_CHANGE,                     INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_ROUTING,            */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                NO_CHANGE,                   INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_FAILED,             */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              NO_CHANGE,               INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_INVALID          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             ROUTING_INC,                NO_CHANGE,                          INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_PENDING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            NO_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_INPROGRESS       */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            NO_CHANGE,                    ROUTING_DEC,                NO_CHANGE,                  ROUTING_DEC,                        INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_DELETING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_RETRYING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          ROUTING_DEC,			   INVALID_CHANGE,            NO_CHANGE,                    ROUTING_DEC,                NO_CHANGE,                  ROUTING_DEC,                        INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_RETRIES_EXCEEDED */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             NO_CHANGE,                          INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_COMPLETED        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_CANCELED         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             NO_CHANGE,                  INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_CANCELING        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             NO_CHANGE,                   INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_ROUTING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              NO_CHANGE,                 INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_FAILED           */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            NO_CHANGE,                  INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_INVALID          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             NO_CHANGE,                 INVALID_CHANGE,            INCOMING_INC,                 INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_PENDING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            NO_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_INPROGRESS       */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            NO_CHANGE,                    INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             NO_CHANGE,                   NO_CHANGE,                 INCOMING_DEC           },

/* JT_RECEIVE__JS_DELETING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_RETRYING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             NO_CHANGE,                  INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_RETRIES_EXCEEDED */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             NO_CHANGE,                          INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_COMPLETED        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INCOMING_DEC,               INVALID_CHANGE,             INVALID_CHANGE,                     NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_CANCELED         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             NO_CHANGE,                  INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_CANCELING        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INCOMING_DEC,               NO_CHANGE,                   NO_CHANGE,                 INVALID_CHANGE         },

/* JT_RECEIVE__JS_ROUTING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INCOMING_DEC,               ROUTING_INC | INCOMING_DEC, INCOMING_DEC,                       INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              NO_CHANGE,                 INVALID_CHANGE         },

/* JT_RECEIVE__JS_FAILED           */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            NO_CHANGE              }
};

static
FAX_ENUM_JOB_TYPE__JOB_STATUS
GetJobType_JobStatusIndex (
    DWORD dwJobType,
    DWORD dwJobStatus
    );


LIST_ENTRY          g_QueueListHead;

CFaxCriticalSection  g_CsQueue;
DWORD               g_dwQueueCount;     // Count of jobs (both parent and non-parent) in the queue. Protected by g_CsQueue
HANDLE              g_hQueueTimer;
HANDLE              g_hJobQueueEvent;
DWORD               g_dwQueueState;
BOOL                g_ScanQueueAfterTimeout; // The JobQueueThread checks this if waked up after JOB_QUEUE_TIMEOUT.
                                                     // If it is TRUE - g_hQueueTimer or g_hJobQueueEvent were not set - Scan the queue.
#define JOB_QUEUE_TIMEOUT       1000 * 60 * 10 //10 minutes
DWORD               g_dwReceiveDevicesCount;    // Count of devices that are receive-enabled. Protected by g_CsLine.
BOOL                g_bServiceCanSuicide;    // Can the service commit suicide on idle activity?
                                                    // Initially TRUE. Can be set to false if the service is launched
                                                    // with SERVICE_ALWAYS_RUNS command line parameter.
BOOL                g_bDelaySuicideAttempt;         // If TRUE, the service initially waits
                                                    // before checking if it can commit suicide.
                                                    // Initially FALSE, can be set to true if the service is launched
                                                    // with SERVICE_DELAY_SUICIDE command line parameter.


static BOOL InsertQueueEntryByPriorityAndSchedule (PJOB_QUEUE lpJobQueue);

HANDLE              g_hJobQueueThread;            // holds the JobQueueThread handle






void
FreeServiceQueue(
    void
    )
{
    PLIST_ENTRY pNext;
    PJOB_QUEUE lpQueueEntry;


    pNext = g_QueueListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_QueueListHead)
    {
        lpQueueEntry = CONTAINING_RECORD( pNext, JOB_QUEUE, ListEntry );
        pNext = lpQueueEntry->ListEntry.Flink;
        RemoveEntryList(&lpQueueEntry->ListEntry);

        //
        // Free the job queue entry
        //
        if (JT_BROADCAST == lpQueueEntry->JobType)
        {
            FreeParentQueueEntry(lpQueueEntry, TRUE);
        }
        else if (JT_SEND == lpQueueEntry->JobType)
        {
            FreeRecipientQueueEntry(lpQueueEntry, TRUE);
        }
        else if (JT_ROUTING == lpQueueEntry->JobType)
        {
            FreeReceiveQueueEntry(lpQueueEntry, TRUE);
        }
        else
        {
            ASSERT_FALSE;
        }
    }
    return;
}



VOID
SafeIncIdleCounter (
    LPDWORD lpdwCounter
)
/*++

Routine name : SafeIncIdleCounter

Routine description:

    Safely increases a global counter that is used for idle service detection

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpdwCounter                   [in]     - Pointer to global counter

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SafeIncIdleCounter"));

    Assert (lpdwCounter);
    DWORD dwNewValue = (DWORD)InterlockedIncrement ((LPLONG)lpdwCounter);
    DebugPrintEx(DEBUG_MSG,
                 TEXT("Increasing %s count from %ld to %ld"),
                 (lpdwCounter == &g_dwQueueCount)          ? TEXT("queue") :
                 (lpdwCounter == &g_dwReceiveDevicesCount) ? TEXT("receive devices") :
                 (lpdwCounter == &g_dwConnectionCount)     ? TEXT("RPC connections") :
                 TEXT("unknown"),
                 dwNewValue-1,
                 dwNewValue);
}   // SafeIncIdleCounter

VOID
SafeDecIdleCounter (
    LPDWORD lpdwCounter
)
/*++

Routine name : SafeDecIdleCounter

Routine description:

    Safely decreases a global counter that is used for idle service detection.
    If the counter reaches zero, the idle timer is re-started.

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpdwCounter                   [in]     - Pointer to global counter

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SafeDecIdleCounter"));

    Assert (lpdwCounter);
    DWORD dwNewValue = (DWORD)InterlockedDecrement ((LPLONG)lpdwCounter);
    if ((DWORD)((long)-1) == dwNewValue)
    {
        //
        // Negative decrease
        //
        ASSERT_FALSE;
        dwNewValue = (DWORD)InterlockedIncrement ((LPLONG)lpdwCounter);
    }
    DebugPrintEx(DEBUG_MSG,
                 TEXT("Deccreasing %s count from %ld to %ld"),
                 (lpdwCounter == &g_dwQueueCount)          ? TEXT("queue") :
                 (lpdwCounter == &g_dwReceiveDevicesCount) ? TEXT("receive devices") :
                 (lpdwCounter == &g_dwConnectionCount)     ? TEXT("RPC connections") :
                 TEXT("unknown"),
                 dwNewValue+1,
                 dwNewValue);

}   // SafeDecIdleCounter


BOOL
ServiceShouldDie(
    VOID
    )
/*++

Routine name : ServiceShouldDie

Routine description:

    Checks to see if the service should die due to inactivity

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    None.

Return Value:

    TRUE if service should die now, FALSE otherwise.

Note:

    The following should happen (concurrently) for the service to die:
        * No devices set to receive
        * No active RPC connections
        * The local fax printer (if exists) is not shared
        * No jobs in the queue

--*/
{
    DWORD dw;
    BOOL bLocalFaxPrinterShared;
    DEBUG_FUNCTION_NAME(TEXT("ServiceShouldDie"));

    if (!g_bServiceCanSuicide)
    {
        //
        // We can never die voluntarily
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Service is not allowed to suicide - service is kept alive"));
        return FALSE;
    }

    dw = InterlockedCompareExchange ( (PLONG)&g_dwManualAnswerDeviceId, -1, -1 );
    if (dw)
    {
        //
        // We have a device set for manual answering - let's check if it's here at all
        //
        PLINE_INFO pLine;

        EnterCriticalSection( &g_CsLine );
        pLine = GetTapiLineFromDeviceId (dw, FALSE);
        LeaveCriticalSection( &g_CsLine );
        if (pLine)
        {
            //
            // There's a valid device set to manual answering
            //
            DebugPrintEx(DEBUG_MSG,
                         TEXT("There's a valid device (id = %ld) set to manual answering - service is kept alive"),
                         dw);
            return FALSE;
        }
    }

    dw = InterlockedCompareExchange ( (PLONG)&g_dwConnectionCount, -1, -1 );
    if (dw > 0)
    {
        //
        // There are active RPC connections - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("There are %ld active RPC connections - service is kept alive"),
                     dw);
        return FALSE;
    }
    dw = InterlockedCompareExchange ( (PLONG)&g_dwReceiveDevicesCount, -1, -1 );
    if (dw > 0)
    {
        //
        // There are devices set to receive - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("There are %ld devices set to receive - service is kept alive"),
                     dw);
        return FALSE;
    }
    dw = InterlockedCompareExchange ( (PLONG)&g_dwQueueCount, -1, -1 );
    if (dw > 0)
    {
        //
        // There are jobs in the queue - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("There are %ld jobs in the queue - service is kept alive"),
                     dw);
        return FALSE;
    }
    dw = IsLocalFaxPrinterShared (&bLocalFaxPrinterShared);
    if (ERROR_SUCCESS != dw)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Call to IsLocalFaxPrinterShared failed with %ld"),
                     dw);
        //
        // Can't determine - assume it's shared and don't die
        //
        return FALSE;
    }
    if (bLocalFaxPrinterShared)
    {
        //
        // The fax printer is shared - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("The fax printer is shared - service is kept alive"));
        return FALSE;
    }
    //
    // Service should die now
    //
    return TRUE;
}   // ServiceShouldDie


#if DBG

/*
 *  Note: This function must be called from withing g_CsQueue Critical Section
 */
void PrintJobQueue(LPCTSTR lptstrStr, const LIST_ENTRY * lpQueueHead)
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpQueueEntry;
    DEBUG_FUNCTION_NAME(TEXT("PrintJobQueue"));
    Assert(lptstrStr);
    Assert(lpQueueHead);

    DebugPrintEx(DEBUG_MSG,TEXT("Queue Dump (%s)"),lptstrStr);

    lpNext = lpQueueHead->Flink;
    if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
    {
        DebugPrint(( TEXT("Queue empty") ));
    } else
    {
        while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
        {
            lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
            switch (lpQueueEntry->JobType)
            {
                case JT_BROADCAST:
                    {
                        DumpParentJob(lpQueueEntry);
                    }
                    break;
                case JT_RECEIVE:
                    {
                        DumpReceiveJob(lpQueueEntry);
                    }
                case JT_ROUTING:
                    break;
                default:
                    {
                    }
            }
            lpNext = lpQueueEntry->ListEntry.Flink;
        }
    }
}

#endif



/******************************************************************************
* Name: StartJobQueueTimer
* Author:
*******************************************************************************
DESCRIPTION:
    Sets the job queue timer (g_hQueueTimer) so it will send an event and wake up
    the queue thread in a time which is right for executing the next job in
    the queue. If it fails , it sets g_ScanQueueAfterTimeout to TRUE, if it succeeds it sets it to FALSE;


PARAMETERS:
   NONE.

RETURN VALUE:
    BOOL.

REMARKS:
    NONE.
*******************************************************************************/
BOOL
StartJobQueueTimer(
    VOID
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE QueueEntry = NULL; 
	LARGE_INTEGER DueTime;
    LARGE_INTEGER MinDueTime;
    DWORD dwQueueState;
    BOOL bFound = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("StartJobQueueTimer"));

    if (TRUE == g_bServiceIsDown)
    {
        //
        // Server is shutting down
        //
        g_ScanQueueAfterTimeout = FALSE;
        return TRUE;
    }

    MinDueTime.QuadPart = (LONGLONG)(0x7fffffffffffffff); // Max 64 bit signed int.
    DueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));  // 1 sec from now.

    EnterCriticalSection( &g_CsQueue );
    DebugPrintEx(DEBUG_MSG,TEXT("Past g_CsQueue"));
    if ((ULONG_PTR) g_QueueListHead.Flink == (ULONG_PTR) &g_QueueListHead)
    {
        //
        // empty list, cancel the timer
        //
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer for g_hQueueTimer failed. (ec: %ld)"),
                GetLastError());
        }

        DebugPrintEx(DEBUG_MSG,TEXT("Queue is empty. Queue Timer disabled."));
        g_ScanQueueAfterTimeout = FALSE;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE ;
    }

    EnterCriticalSection (&g_CsConfig);
    dwQueueState = g_dwQueueState;
    LeaveCriticalSection (&g_CsConfig);
    if (dwQueueState & FAX_OUTBOX_PAUSED)
    {
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer for g_hQueueTimer failed. (ec: %ld)"),
                GetLastError());
        }
        DebugPrintEx(DEBUG_MSG,TEXT("Queue is paused. Disabling queue timer."));
        g_ScanQueueAfterTimeout = FALSE;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    PrintJobQueue( TEXT("StartJobQueueTimer"), &g_QueueListHead );

    //
    // Find the next job in the queue who is in turn for execution.
    //
    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        DWORD dwJobStatus;
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;

        if (QueueEntry->JobType != JT_SEND &&  QueueEntry->JobType != JT_ROUTING )
        {
            //
            // No job other then recipient or routing job gets shceduled for execution
            //
            continue;
        }

        if (QueueEntry->JobStatus & JS_PAUSED)
        {
            //
            // Job is being paused - ignore it
            //
            continue;
        }

        if (QueueEntry->JobStatus & JS_NOLINE)
        {
            //
            // Job does not have free line - ignore it
            //
            continue;
        }

        //
        // Remove all the job status modifier bits.
        //
        dwJobStatus = RemoveJobStatusModifiers(QueueEntry->JobStatus);

        if ((dwJobStatus != JS_PENDING) && (dwJobStatus != JS_RETRYING))
        {
            //
            // Job is not in a waiting and ready state.
            //
            continue;
        }
        
        bFound = TRUE;        

        BOOL bFoundMin = FALSE;

        //
        // OK. Job is in PENDING or RETRYING state.
        //
        switch (QueueEntry->JobParamsEx.dwScheduleAction)
        {
            case JSA_NOW:
                DueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));
                bFoundMin = TRUE;
                break;

            case JSA_SPECIFIC_TIME:
			case JSA_DISCOUNT_PERIOD:
                DueTime.QuadPart = QueueEntry->ScheduleTime;
                break;

			default:
				ASSERT_FALSE;
        }


        if (DueTime.QuadPart < MinDueTime.QuadPart)
        {
            MinDueTime.QuadPart = DueTime.QuadPart;
        }

        if(bFoundMin)
        {
            break;  // no need to continue we found the minimum
        }

    }

    if (TRUE == bFound)
    {

        //
        // Set the job queue timer so it will wake up the queue thread
        // when it is time to execute the next job in the queue.
        //
        if (!SetWaitableTimer( g_hQueueTimer, &MinDueTime, 0, NULL, NULL, FALSE ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetWaitableTimer for g_hQueueTimer failed (ec: %ld)"),
                GetLastError());
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection( &g_CsQueue );
            return FALSE;
        }


        #ifdef DBG
        {
            TCHAR szTime[256] = {0};
            DebugDateTime(MinDueTime.QuadPart, szTime, ARR_SIZE(szTime));
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Setting queue timer to wake up at %s."),
                szTime
                );
        }
        #endif

        g_ScanQueueAfterTimeout = FALSE;
        LeaveCriticalSection( &g_CsQueue );
    }
    else
    {
        //
        // The queue was not empty, yet no jobs found.
        //
        g_ScanQueueAfterTimeout = TRUE;
        LeaveCriticalSection( &g_CsQueue );
    }
    return TRUE;
}




int
__cdecl
QueueCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PQUEUE_SORT)arg1)->Priority < ((PQUEUE_SORT)arg2)->Priority)
    {
        return 1;
    }
    if (((PQUEUE_SORT)arg1)->Priority > ((PQUEUE_SORT)arg2)->Priority)
    {
        return -1;
    }

    //
    // Equal priority, Compare scheduled time.
    //

    if (((PQUEUE_SORT)arg1)->ScheduleTime < ((PQUEUE_SORT)arg2)->ScheduleTime)
    {
        return -1;
    }
    if (((PQUEUE_SORT)arg1)->ScheduleTime > ((PQUEUE_SORT)arg2)->ScheduleTime)
    {
        return 1;
    }
    return 0;
}


BOOL
PauseServerQueue(
    VOID
    )
{
    BOOL bRetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("PauseServerQueue"));

    EnterCriticalSection( &g_CsQueue );
    EnterCriticalSection (&g_CsConfig);
    if (g_dwQueueState & FAX_OUTBOX_PAUSED)
    {
        goto exit;
    }

    if (!CancelWaitableTimer(g_hQueueTimer))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("CancelWaitableTimer failed. ec: %ld"),
                      GetLastError());
        //
        // For optimization only - the queue will be paused
        //
    }
    g_dwQueueState |= FAX_OUTBOX_PAUSED;

    Assert (TRUE == bRetVal);

exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection( &g_CsQueue );
    return bRetVal;
}


BOOL
ResumeServerQueue(
    VOID
    )
{
    BOOL bRetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("ResumeServerQueue"));

    EnterCriticalSection( &g_CsQueue );
    EnterCriticalSection (&g_CsConfig);
    if (!(g_dwQueueState & FAX_OUTBOX_PAUSED))
    {
        goto exit;
    }

    g_dwQueueState &= ~FAX_OUTBOX_PAUSED;  // This must be set before calling StartJobQueueTimer()
    if (!StartJobQueueTimer())
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("StartJobQueueTimer failed. ec: %ld"),
                      GetLastError());
    }
    Assert (TRUE == bRetVal);

exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection( &g_CsQueue );
    return bRetVal;
}


void FixupPersonalProfile(LPBYTE lpBuffer, PFAX_PERSONAL_PROFILE  lpProfile)
{
    Assert(lpBuffer);
    Assert(lpProfile);

    FixupString(lpBuffer, lpProfile->lptstrName);
    FixupString(lpBuffer, lpProfile->lptstrFaxNumber);
    FixupString(lpBuffer, lpProfile->lptstrCompany);
    FixupString(lpBuffer, lpProfile->lptstrStreetAddress);
    FixupString(lpBuffer, lpProfile->lptstrCity);
    FixupString(lpBuffer, lpProfile->lptstrState);
    FixupString(lpBuffer, lpProfile->lptstrZip);
    FixupString(lpBuffer, lpProfile->lptstrCountry);
    FixupString(lpBuffer, lpProfile->lptstrTitle);
    FixupString(lpBuffer, lpProfile->lptstrDepartment);
    FixupString(lpBuffer, lpProfile->lptstrOfficeLocation);
    FixupString(lpBuffer, lpProfile->lptstrHomePhone);
    FixupString(lpBuffer, lpProfile->lptstrOfficePhone);
    FixupString(lpBuffer, lpProfile->lptstrEmail);
    FixupString(lpBuffer, lpProfile->lptstrBillingCode);
    FixupString(lpBuffer, lpProfile->lptstrTSID);
}


//*********************************************************************************
//* Name:   ReadJobQueueFile() [IQR]
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Reads a JOB_QUEUE_FILE structure back into memory for the designated
//*     file. This function is used for all types of persisted jobs.
//* PARAMETERS:
//*     IN LPCWSTR lpcwstrFileName
//*         The full path to the file from which the JOB_QUEUE_FILE is to be read.
//*
//*     OUT PJOB_QUEUE_FILE * lppJobQueueFile
//*         The address of a pointer to JOB_QUEUE_FILE structure where the address
//*         to the newly allocated JOB_QUEUE_FILE structure will be placed.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL ReadJobQueueFile(
    IN LPCWSTR lpcwstrFileName,
    OUT PJOB_QUEUE_FILE * lppJobQueueFile
    )
{
    HANDLE hFile=INVALID_HANDLE_VALUE;

    PJOB_QUEUE_FILE lpJobQueueFile=NULL;

    DWORD dwJobQueueFileStructSize=0;

    DWORD   dwRes;
    DWORD   dwVersion;
    BOOL    bDeleteFile=FALSE;

    Assert(lpcwstrFileName);
    Assert(lppJobQueueFile);

    DEBUG_FUNCTION_NAME(TEXT("ReadJobQueueFile"));

    hFile = SafeCreateFile(
        lpcwstrFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to open file %s for reading. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    dwRes=GetQueueFileVersion(hFile,&dwVersion);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read queue file %s for version check. (ec: %ld)"),
                      lpcwstrFileName,
                      dwRes);
        goto Error;
    }

    if (CURRENT_QUEUE_FILE_VERSION == dwVersion)
    {
        //
        //  This is hashed file.
        //
        dwRes = ReadHashedJobQueueFile(hFile,&lpJobQueueFile);
        if(ERROR_SUCCESS != dwRes)
        {
            if(CRYPT_E_HASH_VALUE == dwRes)
            {
                DebugPrintEx( DEBUG_ERR,
                      TEXT("We got corrupted queue file %s . (ec: %ld)"),
                      lpcwstrFileName,
                      dwRes);
                bDeleteFile = TRUE;
                goto Error;
            }
            else
            {
               DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read hashed queue file for file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      dwRes);
                goto Error;
             }

        }
    }
    else
    {
        //
        //  This is a legacy Queue file, it contains only job data (No hashing data).
        //  We read it as is, and in the next commit we will convert it
        //  into the hashed form of queue file (look at - CommitHashedQueueEntry - for more details)
        //

        //
        // the first DWORD in legacy queue file is sizeof(JOB_QUEUE_FILE).
        // to minimize the effect of corrupted version and to add support for 
        // BOS queue upgrade, we will check if this field is as assumed to be.
        //
        dwJobQueueFileStructSize = dwVersion;

        switch (dwJobQueueFileStructSize)
        {
            case NET_XP_JOB_QUEUE_FILE_SIZE:
                    //
                    //  .Net server and WinXP 
                    //
                    dwRes = ReadLegacyJobQueueFile(hFile,&lpJobQueueFile);
                    if (ERROR_SUCCESS != dwRes)
                    {
                        DebugPrintEx( DEBUG_ERR,
                            TEXT("Failed to read legacy (not hashed) queue file for file %s. (ec: %ld)"),
                            lpcwstrFileName,
                            dwRes);
                        if (ERROR_FILE_CORRUPT == dwRes)
                        {
                            DebugPrintEx( DEBUG_ERR,
                                TEXT("File is corrupted, deleteing file."));
                            bDeleteFile = TRUE;
                        }
                        goto Error;
                    }
                    break;

            case BOS_JOB_QUEUE_FILE_SIZE:
            default:
                    //
                    //  BOS or Win2000 (we do not support queue upgrade) or courrpted queue file
                    //
                    bDeleteFile = TRUE;
                    dwRes = ERROR_FILE_CORRUPT;
                    goto Error;
        }
    }

    goto Exit;
Error:
    MemFree( lpJobQueueFile );
    lpJobQueueFile = NULL;

    if (bDeleteFile)
    {
       //
       // we've got corrupted file, delete it rather than choke on it.
       //
       CloseHandle( hFile ); // must close it to delete the file
       hFile = INVALID_HANDLE_VALUE; // so we won't attempt to close it again on exit
       if (!DeleteFile( lpcwstrFileName )) {
           DebugPrintEx( DEBUG_ERR,
                         TEXT("Failed to delete invalid job file %s (ec: %ld)"),
                         lpcwstrFileName,
                         GetLastError());
       }
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
    }
    *lppJobQueueFile = lpJobQueueFile;
    return (lpJobQueueFile != NULL);

}



//*********************************************************************************
//* Name:   FixupJobQueueFile()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Prepares a JOB_QUEUE_FILE structure so it can be used to add a job to the
//*     queue.
//*     The function fixes all the fields that contain offsets to strings
//*     to contain pointers (by adding the offset to the start of the structure address).
//*     It also sets JOB_QUEUE_FILE.JOB_PARAMS_EX.tmSchedule time so it mataches
//*     JOB_QUEUE_FILE.dwSchedule
//* PARAMETERS:
//*     lpJobQueuFile [IN/OUT]
//*         Pointer to a JOB_QUEUE_FILE structure that should be fixed.
//* RETURN VALUE:
//*     TRUE on success. FALSE on failure. Use GetLastError() to get extended
//*     error information.
//*********************************************************************************
BOOL FixupJobQueueFile(
    IN OUT PJOB_QUEUE_FILE lpJobQueueFile
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FixupJobQueueFile"));

    FixupString(lpJobQueueFile, lpJobQueueFile->QueueFileName);
    FixupString(lpJobQueueFile, lpJobQueueFile->FileName);
    FixupString(lpJobQueueFile, lpJobQueueFile->JobParamsEx.lptstrReceiptDeliveryAddress);
    FixupString(lpJobQueueFile, lpJobQueueFile->JobParamsEx.lptstrDocumentName);
    FixupString(lpJobQueueFile, lpJobQueueFile->CoverPageEx.lptstrCoverPageFileName);
    FixupString(lpJobQueueFile, lpJobQueueFile->CoverPageEx.lptstrNote);
    FixupString(lpJobQueueFile, lpJobQueueFile->CoverPageEx.lptstrSubject);
    FixupPersonalProfile((LPBYTE)lpJobQueueFile, &lpJobQueueFile->SenderProfile);
    FixupString((LPBYTE)lpJobQueueFile, lpJobQueueFile->UserName);
    FixupPersonalProfile((LPBYTE)lpJobQueueFile, &lpJobQueueFile->RecipientProfile);

    lpJobQueueFile->UserSid = ((lpJobQueueFile->UserSid) ? (PSID) ((LPBYTE)(lpJobQueueFile) + (ULONG_PTR)lpJobQueueFile->UserSid) : 0);


    //
    // Convert the job scheduled time from file time to system time.
    // This is necessary since AddJobX functions expect JobParamsEx to
    // contain the scheduled time as system time and not file time.
    //

#if DBG
        TCHAR szSchedule[256] = {0};
        DebugDateTime(lpJobQueueFile->ScheduleTime, szSchedule, ARR_SIZE(szSchedule));
        DebugPrint((TEXT("Schedule: %s (FILETIME: 0x%08X"),szSchedule,lpJobQueueFile->ScheduleTime));
#endif
    if (!FileTimeToSystemTime( (LPFILETIME)&lpJobQueueFile->ScheduleTime, &lpJobQueueFile->JobParamsEx.tmSchedule))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed (ec: %ld)"),
            GetLastError());
        return FALSE;
    }
    return TRUE;

}

//********************************************************************************
//* Name: DeleteQueueFiles()
//* Author: Oded Sacher
//* Date:   Jan 26, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Deletes all unneeded files in the queue
//* PARAMETERS:
//*     [IN] LPCWSTR lpcwstrFileExt - The extension of the files to be deleted from the queue.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If all the files were deleted successfully.
//*     FALSE
//*         If the function failed at deleting at least one of the preview files.
//*********************************************************************************
BOOL
DeleteQueueFiles( LPCWSTR lpcwstrFileExt )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]={0}; // The name of the current parent file.
    BOOL bAnyFailed = FALSE;
    INT  iCount;

    Assert (lpcwstrFileExt);

    DEBUG_FUNCTION_NAME(TEXT("DeleteQueueFiles"));
    //
    // Scan all the files with lpcwstrFileExt postfix.
    // Delete each file
    //

    iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\*.%s"), g_wszFaxQueueDir, lpcwstrFileExt );
    if (0 > iCount)
    {
        //
        //  Path and filename exceeds MAX_PATH
        //
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Path and filename exceeds MAX_PATH. Can't delete Queue files")
                      );
        return FALSE;
    }

    hFind = FindFirstFile( szFileName, &FindData );

    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // No preview files found at queue dir
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No *.%s files found at queue dir %s"),
                      lpcwstrFileExt,
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Deleting file %s"),
                      szFileName);
        if (0 > iCount  ||
            !DeleteFile (szFileName)) 
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("DeleteFile() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}



//*********************************************************************************
//* Name:   RestoreParentJob()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores a parent job and places it back in the queue given
//*     a full path to the queue file where it is persisted.
//* PARAMETERS:
//*     lpcwstrFileName [IN]
//*         A pointer to the full path of the persisted file.
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RestoreParentJob(
    IN LPCWSTR lpcwstrFileName
    )
{
    PJOB_QUEUE_FILE lpJobQueueFile = NULL;
    PJOB_QUEUE lpParentJob = NULL;
    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("RestoreParentJob"));
    Assert(lpcwstrFileName);

    //
    // Read the job into memory and fix it up to contain pointers again
    // If successful the function allocates a JOB_QUEUE_FILE (+ data) .
    //
    if (!ReadJobQueueFile(lpcwstrFileName,&lpJobQueueFile)) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("ReadJobQueueFile() failed. (ec: %ld)"),
                      GetLastError());
        //
        // An event log will be issued by JobQueueThread
        //
        goto Error;
    }
    Assert(lpJobQueueFile);

    if (!FixupJobQueueFile(lpJobQueueFile)) {
        goto Error;
    }

    //
    // Add the parent job to the queue
    //
    lpParentJob=AddParentJob(
                    &g_QueueListHead,
                    lpJobQueueFile->FileName,
                    &lpJobQueueFile->SenderProfile,
                    &lpJobQueueFile->JobParamsEx,
                    &lpJobQueueFile->CoverPageEx,
                    lpJobQueueFile->UserName,
                    lpJobQueueFile->UserSid,
                    NULL,   // Do not render coverpage of first recipient. We already have the correct FileSize.
                    FALSE   // Do not create queue file (we already have one)
                    );
    if (!lpParentJob) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("AddParentJob() failed for PARENT file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    //
    // Set the job state to fit the saved state
    //
    lpParentJob->PageCount = lpJobQueueFile->PageCount;
    lpParentJob->FileSize = lpJobQueueFile->FileSize;
    lpParentJob->QueueFileName = StringDup( lpcwstrFileName );
    lpParentJob->StartTime = lpJobQueueFile->StartTime;
    lpParentJob->EndTime = lpJobQueueFile->EndTime;
    lpParentJob->dwLastJobExtendedStatus = lpJobQueueFile->dwLastJobExtendedStatus;
    lstrcpy (lpParentJob->ExStatusString, lpJobQueueFile->ExStatusString);
    lpParentJob->UniqueId = lpJobQueueFile->UniqueId;
    lpParentJob->SubmissionTime = lpJobQueueFile->SubmissionTime;
    lpParentJob->OriginalScheduleTime = lpJobQueueFile->OriginalScheduleTime;

    bRet = TRUE;
    goto Exit;
Error:
    bRet = FALSE;
Exit:
    MemFree(lpJobQueueFile);
    return bRet;
}


//********************************************************************************
//* Name: RestoreParentJobs()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the parent jobs in the queue directory and puts them
//*     back into the queue. It DOES NOT restore the recipient jobs.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     TRUE
//*         If all the parent jobs were restored successfully.
//*     FALSE
//*         If the function failed at restoring at least one of the parent jobs.
//*********************************************************************************
BOOL
RestoreParentJobs( VOID )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]={0}; // The name of the current parent file.
    BOOL bAnyFailed;
    INT  iCount;

    DEBUG_FUNCTION_NAME(TEXT("RestoreParentJobs"));
    //
    // Scan all the files with .FQP postfix.
    // For each file call RestoreParentJob() to restore
    // the parent job.
    //
    bAnyFailed = FALSE;

    iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\*.FQP"), g_wszFaxQueueDir ); // *.FQP files are parent jobs
    if (0 > iCount)
    {
        //
        //  Path and filename exceeds MAX_PATH
        //
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Path and filename exceeds MAX_PATH. Can't restore Queue")
                      );
        return FALSE;
    }

    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // No parent jobs found at queue dir
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No parent jobs found at queue dir %s"),
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Restoring parent job from file %s"),
                      szFileName);
        if (0 > iCount ||
            !RestoreParentJob(szFileName)) 
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("RestoreParentJob() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}


//*********************************************************************************
//* Name:   RestoreRecipientJob()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores a recipient job and places it back in the queue given
//*     a full path to the queue file where it is persisted.
//* PARAMETERS:
//*     lpcwstrFileName [IN]
//*         A pointer to the full path of the persisted file.
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RestoreRecipientJob(LPCWSTR lpcwstrFileName)
{
    PJOB_QUEUE_FILE lpJobQueueFile = NULL;
    PJOB_QUEUE lpRecpJob = NULL;
    PJOB_QUEUE lpParentJob = NULL;
    DWORD dwJobStatus;
    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("RestoreRecipientJob"));
    Assert(lpcwstrFileName);

    //
    // Read the job into memory and fix it up to contain pointers again
    // The function allocates memeory to hold the file contents in memory.
    //
    if (!ReadJobQueueFile(lpcwstrFileName,&lpJobQueueFile)) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("ReadJobQueueFile() failed. (ec: %ld)"),
                      GetLastError());
        //
        // An event log will be issued by JobQueueThread
        //
        goto Error;
    }
    Assert(lpJobQueueFile);

    if (!FixupJobQueueFile(lpJobQueueFile)) {
        goto Error;
    }

    //
    // Locate the parent job by its unique id.
    //

    lpParentJob = FindJobQueueEntryByUniqueId( lpJobQueueFile->dwlParentJobUniqueId );
    if (!lpParentJob) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to locate parent job with UniqueId: 0x%016I64X for RECIPIENT job 0x%016I64X )"),
            lpJobQueueFile->dwlParentJobUniqueId,
            lpJobQueueFile->UniqueId
            );

        //
        // This recipient job is an orphan. Delete it.
        //
        if (!DeleteFile(lpcwstrFileName)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to delete orphan recipient job %s (ec: %ld)"),
                lpcwstrFileName, GetLastError()
                );
        }
    goto Error;
    }

    //
    // Restore the previous job status unless it is JS_INPROGRESS
    //
    if (JS_INPROGRESS ==  lpJobQueueFile->JobStatus)
    {
        if (0 == lpJobQueueFile->SendRetries)
        {
            dwJobStatus = JS_PENDING;
        }
        else
        {
            dwJobStatus = JS_RETRYING;
        }
    }
    else
    {
        dwJobStatus = lpJobQueueFile->JobStatus;
    }

    //
    // Add the recipient job to the queue
    //
    lpRecpJob=AddRecipientJob(
                    &g_QueueListHead,
                    lpParentJob,
                    &lpJobQueueFile->RecipientProfile,
                    FALSE, // do not commit to disk
                    dwJobStatus
                    );

    if (!lpRecpJob) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("AddRecipientJob() failed for RECIPIENT file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    //
    // Restore last extended status
    //
    lpRecpJob->dwLastJobExtendedStatus = lpJobQueueFile->dwLastJobExtendedStatus;
    lstrcpy (lpRecpJob->ExStatusString, lpJobQueueFile->ExStatusString);
    lstrcpy (lpRecpJob->tczDialableRecipientFaxNumber, lpJobQueueFile->tczDialableRecipientFaxNumber);

    lpRecpJob->QueueFileName = StringDup( lpcwstrFileName );
    if (lpcwstrFileName && !lpRecpJob->QueueFileName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lpRecpJob->QueueFileName StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpRecpJob->UniqueId = lpJobQueueFile->UniqueId;
    MemFree(lpRecpJob->FileName); // need to free the one we copy from the parent as default
    lpRecpJob->FileName=StringDup(lpJobQueueFile->FileName);
    if (lpJobQueueFile->FileName && !lpRecpJob->FileName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lpRecpJob->FileName StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpRecpJob->SendRetries = lpJobQueueFile->SendRetries;

    Assert( !(JS_INPROGRESS & lpRecpJob->JobStatus)); // Jobs are not persisted as in progress

    if (lpRecpJob->JobStatus & JS_CANCELED) {
        lpRecpJob->lpParentJob->dwCanceledRecipientJobsCount+=1;
    } else
    if (lpRecpJob->JobStatus & JS_COMPLETED) {
        lpRecpJob->lpParentJob->dwCompletedRecipientJobsCount+=1;
    } else
    if (lpRecpJob->JobStatus & JS_RETRIES_EXCEEDED) {
        lpRecpJob->lpParentJob->dwFailedRecipientJobsCount+=1;
    }
    
    lpRecpJob->StartTime = lpJobQueueFile->StartTime;
    lpRecpJob->EndTime = lpJobQueueFile->EndTime;

    //
    //  Override the Parent's Schedule Time & Action
    //
    lpRecpJob->JobParamsEx.dwScheduleAction = lpJobQueueFile->JobParamsEx.dwScheduleAction;
    lpRecpJob->ScheduleTime = lpJobQueueFile->ScheduleTime;

    bRet = TRUE;
    goto Exit;
Error:
    bRet = FALSE;
Exit:
    MemFree(lpJobQueueFile);
    return bRet;

}


//********************************************************************************
//* Name: RestoreRecipientJobs() [IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the recipient jobs and their relationships with their parent
//*     jobs.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     TRUE
//*         If all the recipient jobs were restored successfully.
//*     FALSE
//*         If the function failed at restoring at least one of the recipient jobs.
//*********************************************************************************
BOOL
RestoreRecipientJobs( VOID )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]={0}; // The name of the current parent file.
    BOOL bAnyFailed;
    INT  iCount;


    DEBUG_FUNCTION_NAME(TEXT("RestoreRecipientJobs"));
    //
    // Scan all the files with .FQP postfix.
    // For each file call RestoreParentJob() to restore
    // the parent job.
    //
    bAnyFailed=FALSE;

    iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\*.FQE"), g_wszFaxQueueDir ); // *.FQE files are recipient jobs
    if (0 > iCount)
    {
        //
        //  Path and filename exceeds MAX_PATH
        //
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Path and filename exceeds MAX_PATH. Can't restore recipient jobs")
                      );
        return FALSE;
    }

    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // succeed at doing nothing
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No recipient jobs found at queue dir %s"),
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Restoring recipient job from file %s"),
                      szFileName);
        if (0 > iCount ||
            !RestoreRecipientJob(szFileName)) 
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("RestoreRecipientJob() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}



//*********************************************************************************
//* Name:   RestoreReceiveJob() [IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores a receive job and places it back in the queue given
//*     a full path to the queue file where it is persisted.
//* PARAMETERS:
//*     lpcwstrFileName [IN]
//*         A pointer to the full path of the persisted file.
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RestoreReceiveJob(LPCWSTR lpcwstrFileName)
{
    PJOB_QUEUE_FILE lpJobQueueFile = NULL;
    PJOB_QUEUE lpJobQueue = NULL;
    BOOL bRet;
    DWORD i;
    PGUID Guid;
    LPTSTR FaxRouteFileName;
    PFAX_ROUTE_FILE FaxRouteFile;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR fnp;


    DEBUG_FUNCTION_NAME(TEXT("RestoreReceiveJob"));
    Assert(lpcwstrFileName);

    //
    // Read the job into memory and fix it up to contain pointers again
    // The function allocates memeory to hold the file contents in memory.
    //

    if (!ReadJobQueueFile(lpcwstrFileName,&lpJobQueueFile))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("ReadJobQueueFile() failed. (ec: %ld)"),
                      GetLastError());
        //
        // An event log will be issued by JobQueueThread
        //
        goto Error;
    }
    Assert(lpJobQueueFile);

    if (!FixupJobQueueFile(lpJobQueueFile))
    {
        goto Error;
    }

    Assert (JS_RETRYING == lpJobQueueFile->JobStatus ||
            JS_RETRIES_EXCEEDED == lpJobQueueFile->JobStatus);


    //
    // Add the receive job to the queue
    //
    lpJobQueue=AddReceiveJobQueueEntry(
        lpJobQueueFile->FileName,
        NULL,
        JT_ROUTING,
        lpJobQueueFile->UniqueId
        );

    if (!lpJobQueue)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("AddReceiveJobQueueEntry() failed for RECEIVE file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    if (JS_RETRIES_EXCEEDED == lpJobQueueFile->JobStatus)
    {
        lpJobQueue->JobStatus = JS_RETRIES_EXCEEDED;
    }

    lpJobQueue->QueueFileName = StringDup( lpcwstrFileName );
    if (lpcwstrFileName && !lpJobQueue->QueueFileName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpJobQueue->UniqueId = lpJobQueueFile->UniqueId;
    lpJobQueue->FileName = StringDup(lpJobQueueFile->FileName);
    if (lpJobQueueFile->FileName && !lpJobQueue->FileName ) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    lpJobQueue->SendRetries     = lpJobQueueFile->SendRetries; // Routing retries
    lpJobQueue->FileSize        = lpJobQueueFile->FileSize;
    lpJobQueue->PageCount       =   lpJobQueueFile->PageCount;
    lpJobQueue->StartTime       = lpJobQueueFile->StartTime;
    lpJobQueue->EndTime         = lpJobQueueFile->EndTime;
    lpJobQueue->ScheduleTime    = lpJobQueueFile->ScheduleTime;

    lpJobQueue->CountFailureInfo = lpJobQueueFile->CountFailureInfo;
    if (lpJobQueue->CountFailureInfo)
    {
        //
        // Allocate array of  ROUTE_FAILURE_INFO
        //
        lpJobQueue->pRouteFailureInfo = (PROUTE_FAILURE_INFO)MemAlloc(sizeof(ROUTE_FAILURE_INFO) * lpJobQueue->CountFailureInfo);
        if (NULL == lpJobQueue->pRouteFailureInfo)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate ROUTE_FAILURE_INFO")
                );
            goto Error;
        }
        ZeroMemory(lpJobQueue->pRouteFailureInfo, sizeof(ROUTE_FAILURE_INFO) * lpJobQueue->CountFailureInfo);

        CopyMemory(
            lpJobQueue->pRouteFailureInfo,
            (LPBYTE)lpJobQueueFile + (ULONG_PTR)lpJobQueueFile->pRouteFailureInfo,
            sizeof(ROUTE_FAILURE_INFO) * lpJobQueue->CountFailureInfo
            );
    }

    //
    // handle the failure data.
    //
    for (i = 0; i < lpJobQueue->CountFailureInfo; i++)
    {
        if (lpJobQueue->pRouteFailureInfo[i].FailureSize)
        {
            ULONG_PTR ulpOffset = (ULONG_PTR)lpJobQueue->pRouteFailureInfo[i].FailureData;
            lpJobQueue->pRouteFailureInfo[i].FailureData = MemAlloc(lpJobQueue->pRouteFailureInfo[i].FailureSize);

            if (lpJobQueue->pRouteFailureInfo[i].FailureData)
            {
               CopyMemory(
                lpJobQueue->pRouteFailureInfo[i].FailureData,
                (LPBYTE) lpJobQueueFile + ulpOffset,
                lpJobQueue->pRouteFailureInfo[i].FailureSize
                );

            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate FailureData (%ld bytes) (ec: %ld)"),
                    lpJobQueueFile->pRouteFailureInfo[i].FailureSize,
                    GetLastError()
                    );
                goto Error;
            }
        }
        else
        {
            lpJobQueue->pRouteFailureInfo[i].FailureData = NULL;
        }
    }

    if (lpJobQueueFile->FaxRoute)
    {
        PFAX_ROUTE pSerializedFaxRoute = (PFAX_ROUTE)(((LPBYTE)lpJobQueueFile + (ULONG_PTR)lpJobQueueFile->FaxRoute));

        lpJobQueue->FaxRoute = DeSerializeFaxRoute( pSerializedFaxRoute );
        if (lpJobQueue->FaxRoute)
        {
            lpJobQueue->FaxRoute->JobId = lpJobQueue->JobId;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeSerializeFaxRoute() failed (ec: %ld)"),                                
                GetLastError()
                );
            goto Error;
        }
    }
    else
    {
        //
        // Corrupted JobQueueFile
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Corrupted JobQueueFile. No FaxRoute information!"));
        goto Error;
    }

    Guid = (PGUID) (((LPBYTE) lpJobQueueFile) + lpJobQueueFile->FaxRouteFileGuid);
    FaxRouteFileName = (LPTSTR) (((LPBYTE) lpJobQueueFile) + lpJobQueueFile->FaxRouteFiles);
    for (i = 0; i < lpJobQueueFile->CountFaxRouteFiles; i++)
    {
        if (GetFullPathName( FaxRouteFileName, sizeof(FullPathName)/sizeof(WCHAR), FullPathName, &fnp ))
        {
            FaxRouteFile = (PFAX_ROUTE_FILE) MemAlloc( sizeof(FAX_ROUTE_FILE) );
            if (FaxRouteFile)
            {
                ZeroMemory (FaxRouteFile,  sizeof(FAX_ROUTE_FILE));
                FaxRouteFile->FileName = StringDup( FullPathName );
                if (FaxRouteFile->FileName)
                {
                    CopyMemory( &FaxRouteFile->Guid, &Guid, sizeof(GUID) );
                    InsertTailList( &lpJobQueue->FaxRouteFiles, &FaxRouteFile->ListEntry );
                    lpJobQueue->CountFaxRouteFiles += 1;
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup failed (ec: %ld)"),
                        GetLastError()
                        );
                    goto Error;
                }
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate FaxRouteFile for file %s (%ld bytes) (ec: %ld)"),
                    FaxRouteFileName,
                    sizeof(FAX_ROUTE_FILE),
                    GetLastError()
                    );
                goto Error;
            }
        }
        Guid++;
        while(*FaxRouteFileName++); // skip to next file name
    }

    bRet = TRUE;
    goto Exit;
Error:
    if (lpJobQueue)
    {
        EnterCriticalSection (&g_CsQueue);
        DecreaseJobRefCount( lpJobQueue, FALSE );      // don't notify
        LeaveCriticalSection (&g_CsQueue);
    }
    bRet = FALSE;
Exit:
    MemFree(lpJobQueueFile);
    return bRet;
}


//********************************************************************************
//* Name: RestoreReceiveJobs()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the recipient jobs and thier relationships with thier parent
//*     jobs.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     TRUE
//*         If all the recipient jobs were restored successfully.
//*     FALSE
//*         If the function failed at restoring at least one of the recipient jobs.
//*********************************************************************************
BOOL
RestoreReceiveJobs( VOID )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]={0}; // The name of the current parent file.
    BOOL bAnyFailed;
    INT  iCount;


    DEBUG_FUNCTION_NAME(TEXT("RestoreReceiveJobs"));
    //
    // Scan all the files with .FQE postfix.
    // For each file call RestoreReParentJob() to restore
    // the parent job.
    //
    bAnyFailed=FALSE;

    iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\*.FQR"), g_wszFaxQueueDir ); // *.FQR files are receive jobs
    if (0 > iCount)
    {
        //
        //  Path and filename exceeds MAX_PATH
        //
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Path and filename exceeds MAX_PATH. Can't restore received jobs")
                      );
        return FALSE;
    }

    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // succeed at doing nothing
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No receive jobs found at queue dir %s"),
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        iCount=_snwprintf( szFileName, ARR_SIZE(szFileName)-1, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Restoring receive job from file %s"),
                      szFileName);
        if (0 > iCount  ||
            !RestoreReceiveJob(szFileName)) 
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("RestoreReceiveJob() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }


    return bAnyFailed ? FALSE : TRUE;
}



//*********************************************************************************
//* Name:   RemoveRecipientlessParents()[IQR]
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Removes from the job queue any parent jobs which do not have
//*     any recipients.
//* PARAMETERS:
//*     [IN]    const LIST_ENTRY * lpQueueHead
//*         Pointer to the head of the job queue list in which the removal
//*         should be performed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void RemoveRecipientlessParents(
    const LIST_ENTRY * lpQueueHead
    )
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpQueueEntry;
    DEBUG_FUNCTION_NAME(TEXT("RemoveRecipientlessParents"));

    Assert(lpQueueHead);

    lpNext = lpQueueHead->Flink;
    if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Queue empty"));
    }

    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
    {
        lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
        lpNext = lpQueueEntry->ListEntry.Flink;
        if (JT_BROADCAST == lpQueueEntry->JobType)
        {
            if (0 == lpQueueEntry->dwRecipientJobsCount)
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Parent job %ld (UniqueId: 0x%016I64X) has no recipients. Deleting."),
                    lpQueueEntry->JobId,
                    lpQueueEntry->UniqueId
                    );
                RemoveParentJob (lpQueueEntry, FALSE,FALSE); // do not notify, do not remove recipients
            }
        }
    }
}


//*********************************************************************************
//* Name:   RemoveCompletedOrCanceledJobs()[IQR]
//* Author: Oded Sacher
//* Date:   27-Jan-2000
//*********************************************************************************
//* DESCRIPTION:
//*     Removes from the job queue any job that is completed or cancelled.
//* PARAMETERS:
//*     [IN]    const LIST_ENTRY * lpQueueHead
//*         Pointer to the head of the job queue list in which the removal
//*         should be performed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void RemoveCompletedOrCanceledJobs(
    const LIST_ENTRY * lpQueueHead
    )
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpQueueEntry;
    DEBUG_FUNCTION_NAME(TEXT("RemoveCompletedOrCanceledJobs"));

    Assert(lpQueueHead);

    BOOL bFound = TRUE;
    while (bFound)
    {
        lpNext = lpQueueHead->Flink;
        if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
        {
            // empty queue
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Queue empty"));
                return;
        }
        bFound = FALSE;
        while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
        {
            lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
            if (JT_SEND == lpQueueEntry->JobType && lpQueueEntry->RefCount != 0) // we did not decrease ref count for this job yet
            {
                Assert (lpQueueEntry->lpParentJob);
                Assert (1 == lpQueueEntry->RefCount);
                if ( lpQueueEntry->JobStatus == JS_COMPLETED || lpQueueEntry->JobStatus == JS_CANCELED )
                {
                    //
                    //  Recipient job is completed or canceled - decrease its ref count
                    //
                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("Recipient job %ld (UniqueId: 0x%016I64X) is completed or canceled. decrease reference count."),
                        lpQueueEntry->JobId,
                        lpQueueEntry->UniqueId
                        );

                    DecreaseJobRefCount (lpQueueEntry,
                                         FALSE     // // Do not notify
                                         );
                    bFound = TRUE;
                    break; // out of inner while - start search from the begining of the list  because jobs might be removed
                }
            }
            lpNext = lpQueueEntry->ListEntry.Flink;
        }  // end of inner while
    }  // end of outer while
    return;
}   // RemoveCompletedOrCanceledJobs


//*********************************************************************************
//* Name:   RestoreFaxQueue() [IQR]
//* Author: Ronen Barenboim
//* Date:   13-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the jobs in the queue directory back into the job queue.
//*     Deletes all preview files "*.PRV" , and recipient tiff files "*.FRT".
//* PARAMETERS:
//*     VOID
//*
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation completed succesfully for all the jobs.
//*     FALSE
//*         If the restore operation failed for any job.
//*********************************************************************************
BOOL RestoreFaxQueue(VOID)
{
    BOOL bAllParentsRestored = FALSE;
    BOOL bAllRecpRestored = FALSE;
    BOOL bAllRoutingRestored = FALSE;
    BOOL bAllPreviewFilesDeleted = FALSE;
    BOOL bAllRecipientTiffFilesDeleted = FALSE;
    BOOL bAllTempFilesDeleted = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("RestoreFaxQueue"));

    bAllPreviewFilesDeleted = DeleteQueueFiles(TEXT("PRV"));
    if (!bAllPreviewFilesDeleted) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one preview file was not deleted.")
            );
    }

    bAllRecipientTiffFilesDeleted = DeleteQueueFiles(TEXT("FRT"));
    if (!bAllPreviewFilesDeleted) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one recipient tiff  file was not deleted.")
            );
    }

    bAllTempFilesDeleted = DeleteQueueFiles(TEXT("tmp"));
    if (!bAllTempFilesDeleted) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one temp file was not deleted.")
            );
    }

    bAllParentsRestored=RestoreParentJobs();
    if (!bAllParentsRestored) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one parent job was not restored.")
            );
    }

    bAllRecpRestored=RestoreRecipientJobs();
    if (!bAllRecpRestored) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one recipient job was not restored.")
            );
    }
    //
    // Get rid of any parent jobs without recipients
    //
    RemoveRecipientlessParents(&g_QueueListHead); // void return value

    //
    // Get rid of any job that is completed or canceled
    //
    RemoveCompletedOrCanceledJobs(&g_QueueListHead); // void return value

    //
    // Restore routing jobs
    //
    bAllRoutingRestored=RestoreReceiveJobs();

    PrintJobQueue( TEXT("RestoreFaxQueue"), &g_QueueListHead );   

    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer failed. (ec: %ld)"),
            GetLastError());
    }

    return bAllParentsRestored && bAllRecpRestored && bAllRoutingRestored;

}




//*********************************************************************************
//* Name:   JobParamsExSerialize()
//* Author: Ronen Barenboim
//* Date:   11-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Takes a FAX_JOB_PARAM_EXW structure and serializes its data
//*     starting from a specific offset in a provided buffer.
//*     It returns a FAX_JOB_PARAM_EXW structure where memory
//*     addresses are replaced with the offsets where the variable data was placed.
//*     It updates the offset to reflect the size of the serialized variable data.
//*     Supports just recalculating the variable data size.
//* PARAMETERS:
//*
//*     [IN]    LPCFAX_JOB_PARAM_EXW lpJobParamsSrc
//*         The structure to serialize.
//*
//*     [IN]    PFAX_JOB_PARAM_EXW lpJobParamsDst
//*         lpJobParamsDst points to the location of the "serialized" strucutre FAX_JOB_PARAM_EXW in lpbBuffer
//*         Pointers in this structure will be replaced by offsets relevant to the serialize buffer
//*         start (based on the provided pupOffset)
//*         
//*     [OUT]   LPBYTE lpbBuffer
//*         The buffer where varialbe length data should be placed.
//*         If this parameter is NULL the offset is increased to reflect the
//*         variable data size but the data is not copied to the buffer.
//*
//*     [IN/OUT] PULONG_PTR pupOffset
//*         The offset in the serialize buffer where variable data should be placed.
//*         On return it is increased by theh size of the variable length data.
//*
//*     [IN]  dwBufferSize   
//*           Size of the buffer lpbBuffer.
//*           This parameter is used only if dwBufferSize is not NULL.
//*
//* RETURN VALUE:
//*     TRUE  - on success.
//*     FALSE - if lpbBuffer is not NULL and the size of the buffer, dwBufferSize, is not large enough to 
//*     contain the data
//*********************************************************************************
BOOL JobParamsExSerialize(  LPCFAX_JOB_PARAM_EXW lpJobParamsSrc,
                            PFAX_JOB_PARAM_EXW lpJobParamsDst,
                            LPBYTE lpbBuffer,
                            PULONG_PTR pupOffset,
                            DWORD dwBufferSize
                         )
{
    Assert(lpJobParamsSrc);
    Assert(pupOffset);


    if (lpbBuffer) 
    {
        CopyMemory(lpJobParamsDst,lpJobParamsSrc,sizeof(FAX_JOB_PARAM_EXW));
    }
    StoreString(
        lpJobParamsSrc->lptstrReceiptDeliveryAddress,
        (PULONG_PTR)&lpJobParamsDst->lptstrReceiptDeliveryAddress,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpJobParamsSrc->lptstrDocumentName,
        (PULONG_PTR)&lpJobParamsDst->lptstrDocumentName,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    return TRUE;
}
//*********************************************************************************
//* Name:   CoverPageExSerialize()
//* Author: Ronen Barenboim
//* Date:   11-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Takes a FAX_COVERPAGE_INFO_EXW structure and serializes its data
//*     starting from a specific offset in a provided buffer.
//*     It returns a FAX_COVERPAGE_INFO_EXW structure where memory
//*     addresses are replaced with the offsets where the variable data was placed.
//*     It updates the offset to reflect the size of the serialized variable data.
//*     Supports just recalculating the variable data size.
//* PARAMETERS:
//*
//*     [IN]    LPCFAX_COVERPAGE_INFO_EXW lpCoverPageSrc
//*         The structure to serialize.
//*
//*     [IN]   PFAX_COVERPAGE_INFO_EXW lpCoverPageDst
//*         lpCoverPageDst points to the location of the "serialized" strucutre in lpbBuffer
//*         Pointers in this structure will be replaced by offsets relevant to the serialize buffer
//*         start (based on the provided pupOffset)
//*
//*     [OUT]   LPBYTE lpbBuffer
//*         The buffer where varialbe length data should be placed.
//*         If this parameter is NULL the offset is increased to reflect the
//*         variable data size but the data is not copied to the buffer.
//*
//*     [IN/OUT] PULONG_PTR pupOffset
//*         The offset in the serialize buffer where variable data should be placed.
//*         On return it is increased by theh size of the variable length data.
//*
//*     [IN]  dwBufferSize   
//*        Size of the buffer lpbBuffer.
//*        This parameter is used only if dwBufferSize is not NULL.
//*
//* RETURN VALUE:
//*     TRUE  - on success.
//*     FALSE - if lpbBuffer is not NULL and the size of the buffer, dwBufferSize, is not large enough to 
//*     contain the data

//*********************************************************************************
BOOL CoverPageExSerialize(
            IN LPCFAX_COVERPAGE_INFO_EXW lpCoverPageSrc,
            IN PFAX_COVERPAGE_INFO_EXW lpCoverPageDst,
            OUT LPBYTE lpbBuffer,
            IN OUT PULONG_PTR pupOffset,
            IN DWORD dwBufferSize
     )
{
    Assert(lpCoverPageSrc);
    Assert(pupOffset);

    if (lpbBuffer)
    {
        CopyMemory(lpCoverPageDst,lpCoverPageSrc,sizeof(FAX_COVERPAGE_INFO_EXW));
    }

    StoreString(
        lpCoverPageSrc->lptstrCoverPageFileName,
        (PULONG_PTR)&lpCoverPageDst->lptstrCoverPageFileName,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpCoverPageSrc->lptstrNote,
        (PULONG_PTR)&lpCoverPageDst->lptstrNote,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpCoverPageSrc->lptstrSubject,
        (PULONG_PTR)&lpCoverPageDst->lptstrSubject,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    return TRUE;
}

//*********************************************************************************
//* Name:   PersonalProfileSerialize()
//* Author: Ronen Barenboim
//* Date:   11-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Takes a FAX_PERSONAL_PROFILEW structure and serializes its data
//*     starting from a specific offset in a provided buffer.
//*     It returns a FAX_PERSONAL_PROFILEW structure where memory
//*     addresses are replaced with the offsets where the variable data was placed.
//*     It updates the offset to reflect the size of the serialized variable data.
//*     Supports just recalculating the variable data size.
//* PARAMETERS:
//*
//*     [IN]    LPCFAX_PERSONAL_PROFILEW lpProfileSrc
//*         The structure to serialize.
//*
//*     [IN]    PFAX_PERSONAL_PROFILE lpProfileDst
//*         lpProfileDst points to the location of the "serialized" strucutre FAX_PERSONAL_PROFILE in lpbBuffer
//*         Pointers in this structure will be replaced by offsets relevant to the serialize buffer
//*         start (based on the provided pupOffset)
//*
//*     [OUT]   LPBYTE lpbBuffer
//*         The buffer where varialbe length data should be placed.
//*         If this parameter is NULL the offset is increased to reflect the
//*         variable data size but the data is not copied to the buffer.
//*
//*     [IN/OUT] ULONG_PTR pupOffset
//*         The offset in the serialize buffer where variable data should be placed.
//*         On return it is increased by theh size of the variable length data.
//*
//*     [IN]  dwBufferSize   
//*           Size of the buffer lpbBuffer.
//*           This parameter is used only if dwBufferSize is not NULL.
//*
//* RETURN VALUE:
//*     TRUE  - on success.
//*     FALSE - if lpbBuffer is not NULL and the size of the buffer, dwBufferSize, is not large enough to 
//*     contain the data

//*********************************************************************************
BOOL PersonalProfileSerialize(
        IN LPCFAX_PERSONAL_PROFILEW lpProfileSrc,
        IN PFAX_PERSONAL_PROFILE lpProfileDst,
        OUT LPBYTE lpbBuffer,
        IN OUT PULONG_PTR pupOffset,
        IN DWORD dwBufferSize
        )
{
    Assert(lpProfileSrc);
    Assert(pupOffset);
    if (lpbBuffer) 
    {
        lpProfileDst->dwSizeOfStruct=sizeof(FAX_PERSONAL_PROFILE);
    }

    StoreString(
        lpProfileSrc->lptstrName,
        (PULONG_PTR)&lpProfileDst->lptstrName,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpProfileSrc->lptstrFaxNumber,
        (PULONG_PTR)&lpProfileDst->lptstrFaxNumber,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpProfileSrc->lptstrCompany,
        (PULONG_PTR)&lpProfileDst->lptstrCompany,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpProfileSrc->lptstrStreetAddress,
        (PULONG_PTR)&lpProfileDst->lptstrStreetAddress,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrCity,
        (PULONG_PTR)&lpProfileDst->lptstrCity,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrState,
        (PULONG_PTR)&lpProfileDst->lptstrState,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrZip,
        (PULONG_PTR)&lpProfileDst->lptstrZip,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrCountry,
        (PULONG_PTR)&lpProfileDst->lptstrCountry,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrTitle,
        (PULONG_PTR)&lpProfileDst->lptstrTitle,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrDepartment,
        (PULONG_PTR)&lpProfileDst->lptstrDepartment,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrOfficeLocation,
        (PULONG_PTR)&lpProfileDst->lptstrOfficeLocation,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpProfileSrc->lptstrHomePhone,
        (PULONG_PTR)&lpProfileDst->lptstrHomePhone,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpProfileSrc->lptstrOfficePhone,
        (PULONG_PTR)&lpProfileDst->lptstrOfficePhone,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrEmail,
        (PULONG_PTR)&lpProfileDst->lptstrEmail,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    StoreString(
        lpProfileSrc->lptstrBillingCode,
        (PULONG_PTR)&lpProfileDst->lptstrBillingCode,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );

    StoreString(
        lpProfileSrc->lptstrTSID,
        (PULONG_PTR)&lpProfileDst->lptstrTSID,
        lpbBuffer,
        pupOffset,
		dwBufferSize
    );
    return TRUE;
}



//*********************************************************************************
//* Name:   SerializeRoutingInfo()
//* Author: Ronen Barenboim
//* Date:   13-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Serializes the routing information in a JOB_QUEUE structure
//*     into a JOB_QUEUE_FILE structure.
//*     The variable data is put in the provided buffer starting from the provided
//*     offset.
//*     The corresponding fields in JOB_QUEUE_FILE are set to the offsets where
//*     their corresponding variable data was placed.
//*     The offset is updated to follow the new varialbe data in the buffer.
//* PARAMETERS:
//*     [IN]   const JOB_QUEUE * lpcJobQueue
//*         A pointer to thhe JOB_QUEUE strucutre for which routing information
//*         is to be serialized.
//*
//*     [OUT]  PJOB_QUEUE_FILE lpJobQueueFile
//*         A pointer to the JOB_QUEUE_FILE structure where the serialized routing
//*         information is to be placed. The function assumes that the buffer
//*         pointed to by this pointer is large enough to hold all the variable
//*         size routing information starting from the specified offset.
//*
//*     [IN/OUT] PULONG_PTR pupOffset
//*         The offset from the start of the buffer pointet to by lpJobQueueFile
//*         where the variable data should be placed.
//*         On return this parameter is increased by the size of the variable data.
//*
//*     [IN]  dwBufferSize   
//*           Size of the buffer lpJobQueueFile.
//*           This parameter is used only if dwBufferSize is not NULL.
//*
//* RETURN VALUE:
//*     TRUE
//*     FALSE
//*     Call GetLastError() to obtain error code.
//*    
//*********************************************************************************
BOOL SerializeRoutingInfo(
    IN const JOB_QUEUE * lpcJobQueue,
    OUT PJOB_QUEUE_FILE  lpJobQueueFile,
    IN OUT PULONG_PTR    pupOffset,
    IN DWORD             dwBufferSize
    )
{
    DWORD i;
    PFAX_ROUTE lpFaxRoute = NULL;
    DWORD RouteSize;
    PLIST_ENTRY Next;
    PFAX_ROUTE_FILE FaxRouteFile;
    ULONG_PTR ulptrOffset;
    ULONG_PTR ulptrFaxRouteInfoOffset;
    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("SerializeRoutingInfo"));

    Assert(lpcJobQueue);
    Assert(lpJobQueueFile);
    Assert(pupOffset);


    //
    // For a routing job we need to serialize the routing data including:
    //    FAX_ROUTE structure
    //    pRouteFailureInfo
    //    Fax route files array

    ulptrOffset=*pupOffset;

    if(dwBufferSize < sizeof(JOB_QUEUE_FILE))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        bRet=FALSE;
        goto Exit;
    }

    lpJobQueueFile->CountFailureInfo = lpcJobQueue->CountFailureInfo;
    

    if( dwBufferSize <= ulptrOffset || 
       (dwBufferSize - ulptrOffset) < sizeof(ROUTE_FAILURE_INFO) * lpcJobQueue->CountFailureInfo)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        bRet=FALSE;
        goto Exit;
    }
    CopyMemory(
            (LPBYTE) lpJobQueueFile + ulptrOffset,
            lpcJobQueue->pRouteFailureInfo,
            sizeof(ROUTE_FAILURE_INFO) * lpcJobQueue->CountFailureInfo
        );

    ulptrFaxRouteInfoOffset = ulptrOffset;
    lpJobQueueFile->pRouteFailureInfo =  (PROUTE_FAILURE_INFO)((LPBYTE)lpJobQueueFile + ulptrFaxRouteInfoOffset);
    ulptrOffset += sizeof(ROUTE_FAILURE_INFO) * lpcJobQueue->CountFailureInfo;

    for (i = 0; i < lpcJobQueue->CountFailureInfo; i++)
    {
        lpJobQueueFile->pRouteFailureInfo[i].FailureData = (PVOID) ulptrOffset;

        if( dwBufferSize <= ulptrOffset || 
            (dwBufferSize - ulptrOffset) < lpcJobQueue->pRouteFailureInfo[i].FailureSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            bRet=FALSE;
            goto Exit;
        }
        CopyMemory(
            (LPBYTE) lpJobQueueFile + ulptrOffset,
            lpcJobQueue->pRouteFailureInfo[i].FailureData,
            lpcJobQueue->pRouteFailureInfo[i].FailureSize
            );
        ulptrOffset += lpcJobQueue->pRouteFailureInfo[i].FailureSize;
    }
    lpJobQueueFile->pRouteFailureInfo = (PROUTE_FAILURE_INFO)ulptrFaxRouteInfoOffset;

    //
    // Serialze FAX_ROUTE and place it in the bufrer
    //
    lpFaxRoute = SerializeFaxRoute( lpcJobQueue->FaxRoute, &RouteSize,FALSE );
    if (!lpFaxRoute)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SerializeFaxRoute failed. (ec: %ld)"),GetLastError());
        bRet=FALSE;
        goto Exit;
    }

    lpJobQueueFile->FaxRoute = (PFAX_ROUTE) ulptrOffset;

    if( dwBufferSize <= ulptrOffset || 
       (dwBufferSize - ulptrOffset) < RouteSize)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        bRet=FALSE;
        goto Exit;
    }
    CopyMemory(
        (LPBYTE) lpJobQueueFile + ulptrOffset,
        lpFaxRoute,
        RouteSize
        );

    lpJobQueueFile->FaxRouteSize = RouteSize;

    ulptrOffset += RouteSize;


    lpJobQueueFile->CountFaxRouteFiles = 0;

    Next = lpcJobQueue->FaxRouteFiles.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&lpcJobQueue->FaxRouteFiles) {
        DWORD TmpSize;

        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;

        if( dwBufferSize <= ulptrOffset || 
            (dwBufferSize - ulptrOffset) < sizeof(GUID))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            bRet=FALSE;
            goto Exit;
        }
        CopyMemory( (LPBYTE) lpJobQueueFile + ulptrOffset, (LPBYTE) &FaxRouteFile->Guid, sizeof(GUID) );

        if (lpJobQueueFile->CountFaxRouteFiles == 0) {
            lpJobQueueFile->FaxRouteFileGuid = (ULONG)ulptrOffset;
        }

        ulptrOffset += sizeof(GUID);

        TmpSize = StringSize( FaxRouteFile->FileName );

        
        if( dwBufferSize <= ulptrOffset || 
            (dwBufferSize - ulptrOffset) < TmpSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            bRet=FALSE;
            goto Exit;
        }
        CopyMemory( (LPBYTE) lpJobQueueFile + ulptrOffset, FaxRouteFile->FileName, TmpSize );

        if (lpJobQueueFile->CountFaxRouteFiles == 0) {
            lpJobQueueFile->FaxRouteFiles = (ULONG)ulptrOffset;
        }

        ulptrOffset += TmpSize;

        lpJobQueueFile->CountFaxRouteFiles++;
    }

    *pupOffset=ulptrOffset;
    bRet=TRUE;

Exit:
    MemFree(lpFaxRoute);
    return bRet;
}





//*********************************************************************************
//* Name:   CalcJobQueuePersistentSize()
//* Author: Ronen Barenboim
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Calculates the size of the VARIABLE size data in a JOB_QUEUE structure
//*     which is about to be serialized.
//* PARAMETERS:
//*     [IN] const PJOB_QUEUE  lpcJobQueue
//*         Pointer to the JOB_QUEUE structure for which the calculation is to
//*         be performed.
//*
//* RETURN VALUE:
//*     The size of the variable data in bytes.
//*     Does not include sizeof(JOB_QUEUE_FILE) !!!
//*
//*********************************************************************************
DWORD CalcJobQueuePersistentSize(
    IN const PJOB_QUEUE  lpcJobQueue
    )
{
    DWORD i;
    ULONG_PTR Size;
    PLIST_ENTRY Next;
    PFAX_ROUTE_FILE FaxRouteFile;
    DWORD RouteSize;
    DEBUG_FUNCTION_NAME(TEXT("CalcJobQueuePersistentSize"));
    Assert(lpcJobQueue);

    Size=0;

    Size += StringSize( lpcJobQueue->QueueFileName );

    if (lpcJobQueue->JobType == JT_BROADCAST ||
        lpcJobQueue->JobType == JT_ROUTING)
    {
        //
        // Persist file name only for parent and routing jobs
        //
        Size += StringSize( lpcJobQueue->FileName );
    }

    JobParamsExSerialize(&lpcJobQueue->JobParamsEx, NULL, NULL,&Size, 0);
    CoverPageExSerialize(&lpcJobQueue->CoverPageEx, NULL, NULL,&Size, 0);
    PersonalProfileSerialize(&lpcJobQueue->SenderProfile, NULL, NULL, &Size, 0);
    Size += StringSize(lpcJobQueue->UserName);
    PersonalProfileSerialize(&lpcJobQueue->RecipientProfile, NULL, NULL, &Size, 0);

    if (lpcJobQueue->UserSid != NULL)
    {
        // Sid must be valid (checked in CommitQueueEntry)
        Size += GetLengthSid( lpcJobQueue->UserSid );
    }


    for (i = 0; i < lpcJobQueue->CountFailureInfo; i++)
    {
        Size += lpcJobQueue->pRouteFailureInfo[i].FailureSize;
        Size += sizeof(ROUTE_FAILURE_INFO);
    }

    Next = lpcJobQueue->FaxRouteFiles.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&lpcJobQueue->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        Size += sizeof(GUID);
        Size += StringSize( FaxRouteFile->FileName );
    }

    if (lpcJobQueue->JobType == JT_ROUTING)
    {
        SerializeFaxRoute( lpcJobQueue->FaxRoute,
                                      &RouteSize,
                                      TRUE      //Just get the size
                                     );
        Size += RouteSize;
    }       

    return Size;
}


//*********************************************************************************
//* Name:   BOOL CommitQueueEntry() [IQR]
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Serializes a job to a file.
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE JobQueue
//*                 The job to serialize to file.
//*     [IN]    BOOL bDeleteFileOnError (Default - TRUE)
//*                 Delete the file on error ?
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfuly.
//*     FALSE
//*         If the operation failed.
//*********************************************************************************
BOOL
CommitQueueEntry(
    PJOB_QUEUE  JobQueue,
    BOOL        bDeleteFileOnError  /* =TRUE */
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD Size = 0;
    PJOB_QUEUE_FILE JobQueueFile = NULL;
    ULONG_PTR Offset;
    BOOL rVal = TRUE;
    DWORD dwSidSize = 0;

    DWORD dwRes = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("CommitQueueEntry"));

    Assert(JobQueue);
    Assert(JobQueue->QueueFileName);
    Assert(JobQueue->JobType != JT_RECEIVE);

    if (JobQueue->UserSid != NULL)
    {
        if (!IsValidSid (JobQueue->UserSid))
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Does not have a valid SID."),
                      JobQueue->JobId);
            return FALSE;
        }
    }

    //
    // calculate the size required to hold the JOB_QUEUE_FILE structure
    // and all the variable length data.
    //
    Size = sizeof(JOB_QUEUE_FILE);
    Size += CalcJobQueuePersistentSize(JobQueue);

    JobQueueFile = (PJOB_QUEUE_FILE) MemAlloc(Size );

    if (!JobQueueFile)
    {
        return FALSE;
    }

    ZeroMemory( JobQueueFile, Size );
    Offset = sizeof(JOB_QUEUE_FILE);

    //
    // Intialize the JOB_QUEUE_FILE structure with non variable size data.
    //
    JobQueueFile->SizeOfStruct = sizeof(JOB_QUEUE_FILE);
    JobQueueFile->UniqueId = JobQueue->UniqueId;
    JobQueueFile->ScheduleTime = JobQueue->ScheduleTime;
    JobQueueFile->OriginalScheduleTime = JobQueue->OriginalScheduleTime;
    JobQueueFile->SubmissionTime = JobQueue->SubmissionTime;
    JobQueueFile->JobType = JobQueue->JobType;
    //JobQueueFile->QueueFileName = [OFFSET]
    //JobQueue->FileName = [OFFSET]
    JobQueueFile->JobStatus = JobQueue->JobStatus;

    JobQueueFile->dwLastJobExtendedStatus = JobQueue->dwLastJobExtendedStatus;
    lstrcpy (JobQueueFile->ExStatusString, JobQueue->ExStatusString);

    lstrcpy (JobQueueFile->tczDialableRecipientFaxNumber, JobQueue->tczDialableRecipientFaxNumber);

    JobQueueFile->PageCount = JobQueue->PageCount;
    //JobQueueFile->JobParamsEx = [OFFSET]
    //JobQueueFile->CoverPageEx = [OFFSET]
    JobQueueFile->dwRecipientJobsCount =JobQueue->dwRecipientJobsCount;
    //JobQueueFile->lpdwlRecipientJobIds = [OFFSET]
    //JobQueueFile->SenderProfile = [OFFSET]
    JobQueueFile->dwCanceledRecipientJobsCount = JobQueue->dwCanceledRecipientJobsCount;
    JobQueueFile->dwCompletedRecipientJobsCount = JobQueue->dwCompletedRecipientJobsCount;
    JobQueueFile->FileSize = JobQueue->FileSize;
    //JobQueueFile->UserName = [OFFSET]
    //JobQueueFile->RecipientProfile = [OFFSET]
    if (JT_SEND == JobQueue->JobType)
    {
        Assert(JobQueue->lpParentJob);
        JobQueueFile->dwlParentJobUniqueId = JobQueue->lpParentJob->UniqueId;
    }
    JobQueueFile->SendRetries = JobQueue->SendRetries;
    JobQueueFile->StartTime = JobQueue->StartTime;
    JobQueueFile->EndTime = JobQueue->EndTime;

    //
    //Serialize UserSid
    //
    if (JobQueue->UserSid != NULL)
    {
        dwSidSize = GetLengthSid( JobQueue->UserSid );
        JobQueueFile->UserSid = (LPBYTE)Offset;
        memcpy( (LPBYTE)JobQueueFile + Offset,
                JobQueue->UserSid,
                dwSidSize);
        Offset += dwSidSize;
    }

    //
    // JobQueueFile->EFSPPermanentMessageId is obsolete
    //
    ZeroMemory (&(JobQueueFile->EFSPPermanentMessageId), sizeof(JobQueueFile->EFSPPermanentMessageId));

    //
    // Now serialize all the variable length data structures
    //
    StoreString(
        JobQueue->QueueFileName,
        (PULONG_PTR)&JobQueueFile->QueueFileName,
        (LPBYTE)JobQueueFile,
        &Offset,
		Size
        );

    if (JobQueue->JobType == JT_BROADCAST ||
        JobQueue->JobType == JT_ROUTING)
    {
        //
        // Persist file name only for parent and routing jobs
        //
        StoreString(
            JobQueue->FileName,
            (PULONG_PTR)&JobQueueFile->FileName,
            (LPBYTE)JobQueueFile,
            &Offset,
			Size
            );
    }

    if( FALSE == JobParamsExSerialize(
                    &JobQueue->JobParamsEx,
                    &JobQueueFile->JobParamsEx,
                    (LPBYTE)JobQueueFile,
                    &Offset,
                    Size))
    {
        Assert(FALSE);
        rVal = ERROR_INSUFFICIENT_BUFFER;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] JobParamsExSerialize failed, insufficient buffer size."),
                      JobQueue->JobId);
        goto Exit;
    }

    if( FALSE == CoverPageExSerialize(
                    &JobQueue->CoverPageEx,
                    &JobQueueFile->CoverPageEx,
                    (LPBYTE)JobQueueFile,
                    &Offset,
                    Size))
    {
        Assert(FALSE);
        rVal = ERROR_INSUFFICIENT_BUFFER;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] CoverPageExSerialize failed, insufficient buffer size."),
                      JobQueue->JobId);
        goto Exit;
    }

    if( FALSE == PersonalProfileSerialize(
                    &JobQueue->SenderProfile,
                    &JobQueueFile->SenderProfile,
                    (LPBYTE)JobQueueFile,
                    &Offset,
                    Size))
    {
        Assert(FALSE);
        rVal = ERROR_INSUFFICIENT_BUFFER;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] PersonalProfileSerialize failed, insufficient buffer size."),
                      JobQueue->JobId);
        goto Exit;
    }

    StoreString(
        JobQueue->UserName,
        (PULONG_PTR)&JobQueueFile->UserName,
        (LPBYTE)JobQueueFile,
        &Offset,
		Size
        );

    if( FALSE == PersonalProfileSerialize(
                    &JobQueue->RecipientProfile,
                    &JobQueueFile->RecipientProfile,
                    (LPBYTE)JobQueueFile,
                    &Offset,
                    Size))
    {
        Assert(FALSE);
        rVal = ERROR_INSUFFICIENT_BUFFER;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] PersonalProfileSerialize failed, insufficient buffer size."),
                      JobQueue->JobId);
        goto Exit;
    }

    if (JobQueue->JobType == JT_ROUTING)
    {
        rVal = SerializeRoutingInfo(JobQueue,JobQueueFile,&Offset,Size);
        //rVal=TRUE;
        if (!rVal)
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("[JobId: %ld] SerializeRoutingInfo failed. (ec: %ld)"),
                          JobQueue->JobId,
                          GetLastError());
            goto Exit;
        }
    }

    //
    // Make sure the offset we have is in sync with the buffer size we calculated
    //
    Assert(Offset == Size);

    hFile = SafeCreateFile(
        JobQueue->QueueFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
        NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Failed to open file %s for write operation."),
                      JobQueue->JobId,
                      JobQueue->QueueFileName);
        rVal = FALSE;
        goto Exit;
    }

    //
    // Write the buffer to the disk file
    //
    dwRes=CommitHashedQueueEntry( hFile, JobQueueFile, Size);
    if (ERROR_SUCCESS != dwRes)
    {
        if (bDeleteFileOnError)
        {
            DebugPrintEx( DEBUG_ERR,
                        TEXT("[JobId: %ld] Failed to write queue entry buffer to file %s (ec: %ld). Deleting file."),
                        JobQueue->JobId,
                        JobQueue->QueueFileName,
                        dwRes);
            if (!CloseHandle( hFile ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CloseHandle() for file %s (Handle: 0x%08X) failed. (ec: %ld)"),
                    JobQueueFile,
                    hFile,
                    GetLastError());
            }
            hFile = INVALID_HANDLE_VALUE;
            if (!DeleteFile( JobQueue->QueueFileName ))
            {
                DebugPrintEx( DEBUG_ERR,
                            TEXT("[JobId: %ld] Failed to delete file %s (ec: %ld)"),
                            JobQueue->JobId,
                            JobQueue->QueueFileName,
                            GetLastError());
            }
        }
        else
        {
            DebugPrintEx( DEBUG_ERR,
                        TEXT("[JobId: %ld] Failed to write queue entry buffer to file %s (ec: %ld)."),
                        JobQueue->JobId,
                        JobQueue->QueueFileName,
                        dwRes);
        }
        
        rVal = FALSE;
    }
    else
    {
        DebugPrintEx( DEBUG_MSG,
                      TEXT("[JobId: %ld] Successfuly persisted to file %s"),
                      JobQueue->JobId,
                      JobQueue->QueueFileName);
    }


Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle( hFile );
    }

    MemFree( JobQueueFile );
    return rVal;
}

/******************************************************************************
* Name: RescheduleJobQueueEntry
* Author:
*******************************************************************************
DESCRIPTION:
    Reschedules the execution of the specified job queue entry to the current
    time + send retry time.
    The job is removed from the queue in which it is currently located and placed
    in the FAX JOB QUEUE (g_QueueListHead).


PARAMETERS:
   JobQueue [IN/OUT]
        A pointer to a JOB_QUEUE structure holding the information for the
        job to be rescheduled.

RETURN VALUE:
    NONE.

REMARKS:
    Removes the specified job queue entry from its queue.
    Sets it scheduled time to the current time.
    Reinserts it back to the list.
    Commits it back to the SAME file it used to be in.
*******************************************************************************/
VOID
RescheduleJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    FILETIME CurrentFileTime;
    LARGE_INTEGER NewTime;    
    DWORD dwRetryDelay;
    DEBUG_FUNCTION_NAME(TEXT("RescheduleJobQueueEntry"));

    EnterCriticalSection (&g_CsConfig);
    dwRetryDelay = g_dwFaxSendRetryDelay;
    LeaveCriticalSection (&g_CsConfig);

    EnterCriticalSection( &g_CsQueue );

    RemoveEntryList( &JobQueue->ListEntry );

    GetSystemTimeAsFileTime( &CurrentFileTime );

    NewTime.LowPart = CurrentFileTime.dwLowDateTime;
    NewTime.HighPart = CurrentFileTime.dwHighDateTime;

    NewTime.QuadPart += SecToNano( (DWORDLONG)(dwRetryDelay * 60) );

    JobQueue->ScheduleTime = NewTime.QuadPart;
	
    if (JSA_DISCOUNT_PERIOD == JobQueue->JobParamsEx.dwScheduleAction)
	{
		//
		// When calculating the next job retry for cheap time jobs,
		// we must take care of the discount rate 
		//		
		SYSTEMTIME ScheduledTime;
		
        if (FileTimeToSystemTime((LPFILETIME)&JobQueue->ScheduleTime, &ScheduledTime))
		{
			//
			// Call SetDiscountRate to make sure it is in the discount period
			//
			if (SetDiscountTime( &ScheduledTime ))
			{
				//
				// Update the scheduled time in the job queue
				//
				if (!SystemTimeToFileTime( &ScheduledTime, (LPFILETIME)&JobQueue->ScheduleTime ))
				{
					DebugPrintEx(
						DEBUG_ERR,
						TEXT("SystemTimeToFileTime() failed. (ec: %ld)"), GetLastError());					
				}				
			}
			else
			{
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("SetDiscountTime() failed. (ec: %ld)"), GetLastError());           		
			}
		}
		else
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("FileTimeToSystemTime() failed. (ec: %ld)"), GetLastError());            
		}	
	}
	else
	{
		//
		// Change the job to execute at a specific time, when the next retry is due.
		//
		 JobQueue->JobParamsEx.dwScheduleAction = JSA_SPECIFIC_TIME;
	}

    //
    // insert the queue entry into the FAX JOB QUEUE list in a sorted order
    //
    InsertQueueEntryByPriorityAndSchedule(JobQueue);
    //
    // Note that this commits the job queue entry back to the SAME file
    // in which it was in the job queue before moving to the reschedule list.
    // (since JobQueue->UniqueId has not changed).
    //
    if (!CommitQueueEntry(JobQueue))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CommitQueueEntry() for recipien job %s has failed. (ec: %ld)"),
            JobQueue->FileName,
            GetLastError());
    }

    DebugPrintDateTime( TEXT("Rescheduling JobId %d at"), JobQueue->JobId );

    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer (ec: %ld)"),
            GetLastError());
    }

    LeaveCriticalSection( &g_CsQueue );
}


BOOL
PauseJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{

    DWORD dwJobStatus;

    DEBUG_FUNCTION_NAME(TEXT("PauseJobQueueEntry"));

    Assert (JS_DELETING != JobQueue->JobStatus);
    Assert(JobQueue->lpParentJob); // Must not be a parent job for now.

    if (!JobQueue->lpParentJob)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] Attempting to pause parent job [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    //
    // Check the job state modifiers to find out if the job is paused or being paused. If it is
    // then do nothing and return TRUE.
    //
    if (JobQueue->JobStatus & JS_PAUSED)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("[JobId: %ld] Attempting to pause an already paused job [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);
        return TRUE;
    }

    //
    // The job is not paused or being paused. The only modifier that might still be on
    // is JS_NOLINE and we ALLOW to pause jobs in the JS_NOLINE state so it should have
    // no effect on the pause decision.
    //


    //
    // Get rid of all the job status modifier bits
    //
    dwJobStatus = RemoveJobStatusModifiers(JobQueue->JobStatus);


    if ( (JS_RETRYING == dwJobStatus) || (JS_PENDING == dwJobStatus) )
    {
        //
        // Job is in the retrying or pending state. These are the only states
        // in which we allow to pause a job.
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("[JobId: %ld] Pausing job [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);

        EnterCriticalSection (&g_CsQueue);
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("CancelWaitableTimer failed (ec: %ld)"),
                 GetLastError());
        }
        //
        // Turn on the pause flag.
        //
        JobQueue->JobStatus |= JS_PAUSED;
        if (!UpdatePersistentJobStatus(JobQueue))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Failed to update persistent job status to 0x%08x"),
                 JobQueue->JobStatus);
        }

        //
        // Create Fax event
        //
        Assert (NULL == JobQueue->JobEntry); // We assume we do not have job entry so we did not lock g_CsJob
        DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                         JobQueue );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                JobQueue->UniqueId,
                dwRes);
        }

        //
        // We need to recalculate when the wake up the queue thread since the job we just
        // paused may be the one that was scheduled to wakeup the queue thread.
        //
        if (!StartJobQueueTimer())
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("StartJobQueueTimer failed (ec: %ld)"),
                 GetLastError());
        }
        LeaveCriticalSection (&g_CsQueue);
        return TRUE;
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] Can not be paused at this status [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }


}


BOOL
ResumeJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    DEBUG_FUNCTION_NAME(TEXT("ResumeJobQueueEntry"));
    EnterCriticalSection (&g_CsQueue);
    Assert (JS_DELETING != JobQueue->JobStatus);

    if (!CancelWaitableTimer( g_hQueueTimer ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CancelWaitableTimer failed (ec: %ld)"),
            GetLastError());
    }

    JobQueue->JobStatus &= ~JS_PAUSED;
    if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED)
    {
        //
        // This is a RESTART and not RESUME
        //
        JobQueue->JobStatus = JS_PENDING;
        JobQueue->dwLastJobExtendedStatus = 0;
        JobQueue->ExStatusString[0] = TEXT('\0');
        JobQueue->SendRetries = 0;
        if(JobQueue->lpParentJob)
        {
            //
            // lpParentJob is NULL for routing job
            //
            JobQueue->lpParentJob->dwFailedRecipientJobsCount -= 1;
        }
        if (!CommitQueueEntry(JobQueue))
        {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("CommitQueueEntry failed for job %ld"),
                 JobQueue->UniqueId);
        }
    }
    else
    {
        if (!UpdatePersistentJobStatus(JobQueue))
        {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Failed to update persistent job status to 0x%08x"),
                 JobQueue->JobStatus);
        }
    }

    //
    // Create Fax EventEx
    //
    Assert (NULL == JobQueue->JobEntry); // We assume we do not have job entry so we did not lock g_CsJob
    DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                     JobQueue
                                   );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            JobQueue->UniqueId,
            dwRes);
    }


    //
    // Clear up the JS_NOLINE flag so the StartJobQueueTimer will not skip it.
    //
    JobQueue->JobStatus &= (0xFFFFFFFF ^ JS_NOLINE);
    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer failed (ec: %ld)"),
            GetLastError());
    }

    LeaveCriticalSection (&g_CsQueue);
    return TRUE;
}


PJOB_QUEUE
FindJobQueueEntryByJobQueueEntry(
    IN PJOB_QUEUE JobQueueEntry
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if ((ULONG_PTR)JobQueue == (ULONG_PTR)JobQueueEntry) {
            return JobQueue;
        }
    }

    return NULL;
}



PJOB_QUEUE
FindJobQueueEntry(
    DWORD JobId
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->JobId == JobId) {
            return JobQueue;
        }
    }

    return NULL;
}

PJOB_QUEUE
FindJobQueueEntryByUniqueId(
    DWORDLONG UniqueId
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->UniqueId == UniqueId) {
            return JobQueue;
        }
    }

    return NULL;
}

#define ONE_DAY_IN_100NS (24I64 * 60I64 * 60I64 * 1000I64 * 1000I64 * 10I64)

DWORD
JobQueueThread(
    LPVOID UnUsed
    )
{
    DWORDLONG DueTime;
    DWORDLONG ScheduledTime;
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;
    HANDLE Handles[3];    
    DWORD WaitObject;
    DWORDLONG DirtyDays = 0;
    BOOL InitializationOk = TRUE;
    DWORD dwQueueState;
    DWORD dwDirtyDays;
    DWORD dwJobStatus;
    BOOL bUseDirtyDays = TRUE;
    static BOOL fServiceIsDownSemaphoreWasReleased = FALSE;
	LIST_ENTRY ReschduledDiscountRateJobsListHead;
    DEBUG_FUNCTION_NAME(TEXT("JobQueueThread"));

    Assert (g_hQueueTimer && g_hJobQueueEvent && g_hServiceShutDownEvent);

	//
	// Initilaize the list that is used to temporary store
	// discount rate jobs that are rescheduled by JobQueueThread
	//
	InitializeListHead( &ReschduledDiscountRateJobsListHead );

    Handles[0] = g_hQueueTimer;
    Handles[1] = g_hJobQueueEvent;
    Handles[2] = g_hServiceShutDownEvent;

    EnterCriticalSectionJobAndQueue;

    InitializationOk = RestoreFaxQueue();
    if (!InitializationOk)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RestoreFaxQueue() failed (ec: %ld)"),
            GetLastError());
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                0,
                MSG_QUEUE_INIT_FAILED
              );
    }

    LeaveCriticalSectionJobAndQueue;    

    if (!g_bDelaySuicideAttempt)
    {
        //
        // Let's check for suicide conditions now (during service startup).
        // If we can suicide, we do it ASAP.
        //
        // NOTICE: this code assumes the JobQueueThread is the last thread
        // created during service statup.
        // RPC is not initialized yet and no RPC server will be available if we die now.
        //
        if (ServiceShouldDie ())
        {
            //
            // Service should die now
            //
            // NOTICE: We're now in JobQueueThread which is launched by FaxInitThread.
            //         FaxInitThread launches us and immediately returns (dies) and only then the main thread
            //         reports SERVICE_RUNNING to the SCM.
            //         There's a tricky timing probelm here: if we call EndFaxSvc right away, a race
            //         condition may prevent the main thread to report SERVICE_RUNNING and
            //         since EndFaxSvc reports SERVICE_STOP_PENDING to the SCM, the SCM will
            //         think a bad service startup occurred since it did not get SERVICE_RUNNING yet.
            //
            //         Bottom line: we need to wait till the SCM gets the SERVICE_RUNNING status
            //         from the main thread and ONLY THEN call EndFaxSvc.
            //
            //         The way we do this is by calling the utility function WaitForServiceRPCServer.
            //         This function waits for the readiness of the RPC server and it means
            //         FaxInitThread is dead and the SCM knowns we're safely running.
            //
            //         If something bad happened while the RPC was initialized, the main t calls EndFaxSvc.
            //         So the service is down anyway.
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Waiting for full service startup before shutting down the service"));
            if (!WaitForServiceRPCServer(INFINITE))
            {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("WaitForServiceRPCServer(INFINITE) faile with %ld."),
                             GetLastError ());
            }
            else
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down due to idle activity."));

                //
                // StopService() is blocking so we must decrease the thread count and release the ServiceIsDownSemaphore before calling StopService() 
                //
                if (!DecreaseServiceThreadsCount())
                {
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                            GetLastError());
                }

                //
                // Notify EndFaxSvc that we read the shutdown flag
                //
                if (!ReleaseSemaphore(
                    g_hServiceIsDownSemaphore,      // handle to semaphore
                    1,                              // count increment amount
                    NULL                            // previous count
                    ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                        GetLastError());
                }
                
                StopService (NULL, FAX_SERVICE_NAME, TRUE);
                return 0;   // Quit this thread
            }
        }
    }

    while (TRUE)
    {		
		//
		// At this point the reschduled discount rate jobs must be empty
		//
		Assert ((ULONG_PTR)ReschduledDiscountRateJobsListHead.Flink == (ULONG_PTR)&ReschduledDiscountRateJobsListHead);

        WaitObject = WaitForMultipleObjects( 3, Handles, FALSE, JOB_QUEUE_TIMEOUT );
        if (WAIT_FAILED == WaitObject)
        {
            DebugPrintEx(DEBUG_ERR,
                _T("WaitForMultipleObjects failed (ec: %d)"),
                GetLastError());
        }

        if (WaitObject == WAIT_TIMEOUT)
        {
            //
            // Check if the service should suicide
            //
            if (ServiceShouldDie ())
            {
                //
                //  Service should die now
                //
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down due to idle activity."));
                //
                // StopService() is blocking so we must decrease the thread count and release the ServiceIsDownSemaphore before calling StopService() 
                //
                if (!DecreaseServiceThreadsCount())
                {
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                            GetLastError());
                }

                //
                // Notify EndFaxSvc that we read the shutdown flag
                //              
                if (!ReleaseSemaphore(
                    g_hServiceIsDownSemaphore,      // handle to semaphore
                    1,                              // count increment amount
                    NULL                            // previous count
                    ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                        GetLastError());
                }                               
                StopService (NULL, FAX_SERVICE_NAME, TRUE);
                return 0;   // Quit this thread
            }


            //
            // Check if the queue should be scanned
            //
            EnterCriticalSection( &g_CsQueue );
            if (FALSE == g_ScanQueueAfterTimeout)
            {
                //
                // Go back to sleep
                //
                LeaveCriticalSection( &g_CsQueue );
                continue;
            }
            //
            // g_hQueueTimer or g_hJobQueueEvent were not set - Scan the queue.
            //
            g_ScanQueueAfterTimeout = FALSE; // Reset the flag
            LeaveCriticalSection( &g_CsQueue );

            DebugPrintEx(
                DEBUG_WRN,
                _T("JobQueueThread waked up after timeout. g_hJobQueueEvent or")
                _T("g_hQueueTimer are not set properly. Scan the QUEUE"));
        }

        //
        // Check if the service is shutting down
        //
        if (2 == (WaitObject - WAIT_OBJECT_0))
        {
            //
            // Server is shutting down - Stop scanning the queue
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("g_hServiceShutDownEvent is set, Server is shutting down - Stop scanning the queue"));
            break;
        }

        if (TRUE == g_bServiceIsDown)
        {
            //
            // Server is shutting down - Stop scanning the queue
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("g_bServiceIsDown is set, Server is shutting down - Stop scanning the queue"));
            break;
        }

        //
        // Get Dirtydays data
        //
        EnterCriticalSection (&g_CsConfig);
        dwDirtyDays = g_dwFaxDirtyDays;
        LeaveCriticalSection (&g_CsConfig);

        DirtyDays = dwDirtyDays * ONE_DAY_IN_100NS;

        // if dwDirtyDays is 0
        // this means disable dirty days functionality
        //
        bUseDirtyDays = (BOOL)(dwDirtyDays>0);
        //
        // find the jobs that need servicing in the queue
        //

        EnterCriticalSectionJobAndQueue;

        GetSystemTimeAsFileTime( (LPFILETIME)&DueTime );
        if (WaitObject - WAIT_OBJECT_0 == 2)
        {
            DebugPrintDateTime( TEXT("g_hServiceShutDownEvent signaled at "), DueTime );
        }
        else if (WaitObject - WAIT_OBJECT_0 == 1)
        {
            DebugPrintDateTime( TEXT("g_hJobQueueEvent signaled at "), DueTime );
        }

        PrintJobQueue( TEXT("JobQueueThread"), &g_QueueListHead );

        //
        // Go over the job queue list looking for jobs to execute
        //     
        
        Next = g_QueueListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
        {
            if (TRUE == g_bServiceIsDown)
            {
                //
                // Notify EndFaxSvc that we read the shutdown flag
                //
                if (FALSE == fServiceIsDownSemaphoreWasReleased)
                {
                    if (!ReleaseSemaphore(
                        g_hServiceIsDownSemaphore,      // handle to semaphore
                        1,                              // count increment amount
                        NULL                            // previous count
                        ))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                            GetLastError());
                    }
                    else
                    {
                        fServiceIsDownSemaphoreWasReleased = TRUE;
                    }
                }

                //
                // Server is shutting down - Stop scanning the queue
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Server is shutting down - Stop scanning the queue"));
                break;
            }

            JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
            Next = JobQueue->ListEntry.Flink;
            if ((JobQueue->JobStatus & JS_PAUSED) || (JobQueue->JobType == JT_RECEIVE) ) {
                // Don't care about paused or receive jobs
                continue;
            }

            dwJobStatus = (JT_SEND == JobQueue->JobType) ?
                           JobQueue->lpParentJob->JobStatus : JobQueue->JobStatus;
            if (dwJobStatus == JS_DELETING)
            {
                //
                // Job is being deleted - skip it.
                //
                continue;
            }

            if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED)
            {
                ScheduledTime = (JobQueue->JobType == JT_SEND) ? JobQueue->lpParentJob->ScheduleTime : JobQueue->ScheduleTime;
                //
                // Get rid of jobs that have reached maximum retries.
                //
                if ( bUseDirtyDays &&
                     (ScheduledTime + DirtyDays < DueTime) )
                {
                    DebugPrint((TEXT("Removing job from queue (JS_RETRIES_EXCEEDED)\n")));

                    switch (JobQueue->JobType)
                    {
                        case JT_ROUTING:
                            JobQueue->JobStatus = JS_DELETING; // Prevent from decreasing ref count again
                            DecreaseJobRefCount( JobQueue , TRUE);
                            break;

                        case JT_SEND:
                            if (IsSendJobReadyForDeleting (JobQueue))
                            {
                                //
                                // All the recipients are in final state
                                //
                                DebugPrintEx(
                                    DEBUG_MSG,
                                    TEXT("Parent JobId: %ld has expired (dirty days). Removing it and all its recipients."),
                                    JobQueue->JobId);
                                //
                                // Decrease ref count for all failed recipients (since we keep failed
                                // jobs in the queue the ref count on the was not decreased in
                                // HandleFailedSendJob().
                                // We must decrease it now to remove them and their parent.
                                //
                                PLIST_ENTRY NextRecipient;
                                PJOB_QUEUE_PTR pJobQueuePtr;
                                PJOB_QUEUE pParentJob = JobQueue->lpParentJob;
                                DWORD dwFailedRecipientsCount = 0;
                                DWORD dwFailedRecipients = pParentJob->dwFailedRecipientJobsCount;

                                NextRecipient = pParentJob->RecipientJobs.Flink;
                                while (dwFailedRecipients > dwFailedRecipientsCount  &&
                                       (ULONG_PTR)NextRecipient != (ULONG_PTR)&pParentJob->RecipientJobs)
                                {
                                    pJobQueuePtr = CONTAINING_RECORD( NextRecipient, JOB_QUEUE_PTR, ListEntry );
                                    Assert(pJobQueuePtr->lpJob);
                                    NextRecipient = pJobQueuePtr->ListEntry.Flink;

                                    if (JS_RETRIES_EXCEEDED == pJobQueuePtr->lpJob->JobStatus)
                                    {
                                        //
                                        // For legacy compatibility send a FEI_DELETED event
                                        // (it was not send when the job was failed since we keep failed jobs
                                        //  in the queue just like in W2K).
                                        //
                                        if (!CreateFaxEvent(0, FEI_DELETED, pJobQueuePtr->lpJob->JobId))
                                        {
                                            DebugPrintEx(
                                                DEBUG_ERR,
                                                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                                                GetLastError());
                                        }
                                        //
                                        // This will also call RemoveParentJob and mark the broadcast job as JS_DELETEING
                                        //
                                        DecreaseJobRefCount( pJobQueuePtr->lpJob, TRUE);
                                        dwFailedRecipientsCount++;
                                    }
                                }
                                //
                                // Since we removed several jobs from the list, Next is not valid any more. reset to the list start.
                                //
                                Next = g_QueueListHead.Flink;
                            }
                            break;
                    } // end switch
                }
                continue;
            }

            //
            // if the queue is paused or the job is already in progress, don't send it again
            //
            EnterCriticalSection (&g_CsConfig);
            dwQueueState = g_dwQueueState;
            LeaveCriticalSection (&g_CsConfig);
            if ((dwQueueState & FAX_OUTBOX_PAUSED) ||
                ((JobQueue->JobStatus & JS_INPROGRESS) == JS_INPROGRESS) ||
                ((JobQueue->JobStatus & JS_COMPLETED) == JS_COMPLETED)
                )
            {
                continue;
            }

            if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED)
            {
                continue;
            }

            if (JobQueue->JobStatus & JS_CANCELED) {
                //
                // Skip cancelled jobs
                //
                continue;
            }
            if (JobQueue->JobStatus & JS_CANCELING) {
                //
                // Skip cancelled jobs
                //
                continue;
            }

            if (JobQueue->JobType==JT_BROADCAST) {
                //
                // skip it
                //
                continue;
            }

            //
            // Check for routing jobs
            //
            if (JobQueue->JobType == JT_ROUTING)
            {
                //
                // Routing job detected
                //
                if (JobQueue->ScheduleTime != 0 && DueTime < JobQueue->ScheduleTime)
                {
                    //
                    // If its time has not yet arrived skip it.
                    //
                    continue;
                }

                // Time to route...
                if(!StartRoutingJob(JobQueue))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("[JobId: %ld] StartRoutingJob() failed (ec: %ld)"),
                        JobQueue->JobId,
                        GetLastError());
                }
                continue;
            }

            //
            // outbound job
            //						       

            if (JobQueue->ScheduleTime == 0 || DueTime >= JobQueue->ScheduleTime)
            {
				//
				// for discount rate jobs we need to recaclulate the scheduled time
				// so that if the discount period is over, it will not start executing
				//
				if (JSA_DISCOUNT_PERIOD == JobQueue->JobParamsEx.dwScheduleAction)
				{					
					SYSTEMTIME stCurrentTime;
					SYSTEMTIME stScheduledTime;

					GetSystemTime( &stCurrentTime ); // Can't fail according to Win32 SDK
					stScheduledTime = stCurrentTime;

					//
					// calculate the scheduled time based on the discount period
					//
					if (!SetDiscountTime(&stScheduledTime))
					{
						DebugPrintEx(
							DEBUG_ERR,
							TEXT("SetDiscountTime() failed. (ec: %ld)"));
						continue;
					}
					//
					// check the the original and scheduled time are equal.		
					//
					if (0 == memcmp(&stScheduledTime, &stCurrentTime, sizeof(SYSTEMTIME)))
					{
						//
						// SetDiscountRate() did not change the scheduled time
						// this means that we are in the discount rate
						// start executing the job
						//
					}
					else
					{
						//
						// discount rate changed. we can not submit the job
						// clear the JS_NOLINE bit and update the scheduled time, so that StartJobQueueTimer, will not skip it						
						// 
						JobQueue->JobStatus &= ~JS_NOLINE;
						if (!SystemTimeToFileTime( &stScheduledTime, (LPFILETIME)&JobQueue->ScheduleTime ))
						{
							DebugPrintEx(
								DEBUG_ERR,
								TEXT("SystemTimeToFileTime() failed. (ec: %ld)"), GetLastError());					
						}
						else
						{
							//
							// The scheduled time of the job has changed
							// we need to put it back in the correct place in the sorted queue
							// move it to a temporary list, and put it back when we finish searching the whole queue
							RemoveEntryList( &JobQueue->ListEntry); 
							InsertTailList(&ReschduledDiscountRateJobsListHead, &JobQueue->ListEntry);
						}
						continue;
					}
				} 

                PLINE_INFO lpLineInfo;
                //
                // start the job (send job whose time has arrived or handoff job).
                //
                Assert(JT_SEND == JobQueue->JobType);                
                DebugPrintEx(DEBUG_MSG,
                                TEXT("Recipient Job : %ld is ready for execution. Job status is: 0x%0X."),
                                JobQueue->JobId,
                                JobQueue->JobStatus);

                lpLineInfo = GetLineForSendOperation(JobQueue);
                if (!lpLineInfo)
                {
                    DWORD ec = GetLastError();
                    if (ec == ERROR_NOT_FOUND)
                    {
                        DebugPrintEx(
                            DEBUG_WRN,
                            TEXT("Can not find a free line for JobId: %ld."),
                            JobQueue->JobId);
                        //
                        // Mark the fact that we have no line for this job.
                        //
                        JobQueue->JobStatus |= JS_NOLINE;
                    }
                    else
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("FindLineForSendOperation() failed for for JobId: %ld (ec: %ld)"),
                            JobQueue->JobId,
                            ec);
                        JobQueue->JobStatus |= JS_NOLINE;
                    }
                }
                else
                {
                    //
                    // Clear up the JS_NOLINE flag if we were able to start the job.
                    // This is the point where a job which had no line comes back to life.
                    //
                    JobQueue->JobStatus &= ~JS_NOLINE;
                    if (!StartSendJob(JobQueue, lpLineInfo))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("StartSendJob() failed for JobId: %ld on Line: %s (ec: %ld)"),
                            JobQueue->JobId,
                            lpLineInfo->DeviceName,
                            GetLastError());
                    }
                }                
            }
        }
                                                        // while loop breaks
		//
		// move the reschduled discount rate jobs back into the queue
		//
		Next = ReschduledDiscountRateJobsListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&ReschduledDiscountRateJobsListHead)
		{
			JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
			Next = JobQueue->ListEntry.Flink;
			//
			// Remove it from the temporary list
			//
			RemoveEntryList( &JobQueue->ListEntry );
			//
			// Get it back into the correct place in the queue
			//
			InsertQueueEntryByPriorityAndSchedule(JobQueue);	
			//
			// Send a queue status event because the scheduled time changed
			//
			DWORD dwRes = CreateQueueEvent (FAX_JOB_EVENT_TYPE_STATUS, JobQueue );
			if (ERROR_SUCCESS != dwRes)
			{
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
					JobQueue->UniqueId,
					dwRes);
			}
		}

        //
        // restart the timer
        //
        if (!StartJobQueueTimer())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StartJobQueueTimer failed (ec: %ld)"),
                GetLastError());
        }


        LeaveCriticalSectionJobAndQueue;
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }

    //
    // Notify EndFaxSvc that we read the shutdown flag
    //
    if (FALSE == fServiceIsDownSemaphoreWasReleased)
    {
        if (!ReleaseSemaphore(
            g_hServiceIsDownSemaphore,      // handle to semaphore
            1,                              // count increment amount
            NULL                            // previous count
            ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                GetLastError());
        }       
    }
    return 0;
}


BOOL
SetDiscountTime(
   LPSYSTEMTIME CurrentTime
   )
/*++

Routine Description:

    Sets the passed in systemtime to a time inside the discount rate period.
    Some care must be taken here because the time passed in is in UTC time and the discount rate is
    for the current time zone.  Delineating a day must be done using the current time zone.  We convert the
    current time into the time zone specific time, run our time-setting algorithm, and then use an offset
    of the change in the time-zone specific time to set the passed in UTC time.

    Also, note that there are a few subtle subcases that depend on the order of the start and ending time
    for the discount period.

Arguments:

    CurrentTime - the current time of the job

Return Value:

    none. modifies CurrentTime.

--*/
{
   //              nano   microsec  millisec  sec      min    hours
   #define ONE_DAY 10I64 *1000I64*  1000I64 * 60I64 * 60I64 * 24I64
   LONGLONG Time, TzTimeBefore, TzTimeAfter,ftCurrent;
   SYSTEMTIME tzTime;
   FAX_TIME tmStartCheapTime;
   FAX_TIME tmStopCheapTime;

   DEBUG_FUNCTION_NAME(TEXT("SetDiscountTime"));

   //
   // convert our discount rates into UTC rates
   //

   if (!SystemTimeToTzSpecificLocalTime(NULL, CurrentTime, &tzTime)) {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("SystemTimeToTzSpecificLocalTime() failed. (ec: %ld)"),
           GetLastError());
      return FALSE;
   }

   if (!SystemTimeToFileTime(&tzTime, (FILETIME * )&TzTimeBefore)) {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
           GetLastError());
      return FALSE;
   }

   EnterCriticalSection (&g_CsConfig);
   tmStartCheapTime = g_StartCheapTime;
   tmStopCheapTime = g_StopCheapTime;
   LeaveCriticalSection (&g_CsConfig);

   //
   // there are 2 general cases with several subcases
   //

   //
   // case 1: discount start time is before discount stop time (don't overlap a day)
   //
   if ( tmStartCheapTime.Hour < tmStopCheapTime.Hour ||
        (tmStartCheapTime.Hour == tmStopCheapTime.Hour &&
         tmStartCheapTime.Minute < tmStopCheapTime.Minute ))
   {
      //
      // subcase 1: sometime before cheap time starts in the current day.
      //  just set it to the correct hour and minute today.
      //
      if ( tzTime.wHour < tmStartCheapTime.Hour ||
           (tzTime.wHour == tmStartCheapTime.Hour  &&
            tzTime.wMinute <= tmStartCheapTime.Minute) )
      {
         tzTime.wHour   =  tmStartCheapTime.Hour;
         tzTime.wMinute =  tmStartCheapTime.Minute;
         goto convert;
      }

      //
      // subcase 2: inside the current cheap time range
      // don't change anything, just send immediately
      if ( tzTime.wHour <  tmStopCheapTime.Hour ||
           (tzTime.wHour == tmStopCheapTime.Hour &&
            tzTime.wMinute <= tmStopCheapTime.Minute))
      {
         goto convert;
      }

      //
      // subcase 3: we've passed the cheap time range for today.
      //  Increment 1 day and set to the start of the cheap time period
      //
      if (!SystemTimeToFileTime(&tzTime, (FILETIME * )&Time))
      {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
      }

      Time += ONE_DAY;
      if (!FileTimeToSystemTime((FILETIME *)&Time, &tzTime)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FileTimeToSystemTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
      }


      tzTime.wHour   = tmStartCheapTime.Hour;
      tzTime.wMinute = tmStartCheapTime.Minute;
      goto convert;

   } else {
      //
      // case 2: discount start time is after discount stop time (we overlap over midnight)
      //

      //
      // subcase 1: sometime aftert cheap time ended today, but before it starts later in the current day.
      //  set it to the start of the cheap time period today
      //
      if ( ( tzTime.wHour   > tmStopCheapTime.Hour ||
             (tzTime.wHour == tmStopCheapTime.Hour  &&
              tzTime.wMinute >= tmStopCheapTime.Minute) ) &&
           ( tzTime.wHour   < tmStartCheapTime.Hour ||
             (tzTime.wHour == tmStartCheapTime.Hour &&
              tzTime.wMinute <= tmStartCheapTime.Minute) ))
      {
         tzTime.wHour   =  tmStartCheapTime.Hour;
         tzTime.wMinute =  tmStartCheapTime.Minute;
         goto convert;
      }

      //
      // subcase 2: sometime after cheap time started today, but before midnight.
      // don't change anything, just send immediately
      if ( ( tzTime.wHour >= tmStartCheapTime.Hour ||
             (tzTime.wHour == tmStartCheapTime.Hour  &&
              tzTime.wMinute >= tmStartCheapTime.Minute) ))
      {
         goto convert;
      }

      //
      // subcase 3: somtime in next day before cheap time ends
      //  don't change anything, send immediately
      //
      if ( ( tzTime.wHour <= tmStopCheapTime.Hour ||
             (tzTime.wHour == tmStopCheapTime.Hour  &&
              tzTime.wMinute <= tmStopCheapTime.Minute) ))
      {
         goto convert;
      }

      //
      // subcase 4: we've passed the cheap time range for today.
      //  since start time comes after stop time, just set it to the start time later on today.

      tzTime.wHour   =  tmStartCheapTime.Hour;
      tzTime.wMinute =  tmStartCheapTime.Minute;
      goto convert;

   }

convert:

   if (!SystemTimeToFileTime(&tzTime, (FILETIME * )&TzTimeAfter)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
   }


   if (!SystemTimeToFileTime(CurrentTime, (FILETIME * )&ftCurrent)) {
       DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
    }


   ftCurrent += (TzTimeAfter - TzTimeBefore);

   if (!FileTimeToSystemTime((FILETIME *)&ftCurrent, CurrentTime)) {
       DebugPrintEx(
                DEBUG_ERR,
                TEXT("FileTimeToSystemTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
    }


   return TRUE;

}



//*********************************************************************************
//*                         Recipient Job Functions
//*********************************************************************************



//*********************************************************************************
//* Name:   AddRecipientJob()
//* Author: Ronen Barenboim
//* Date:   18-Mar-98
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     [IN]     const PLIST_ENTRY lpcQueueHead
//*                 A pointer to the head entry of the queue to which to add the job.
//*
//*     [IN/OUT] PJOB_QUEUE lpParentJob
//*                 A pointer to the parent job of this recipient job.
//*
//*     [IN]     LPCFAX_PERSONAL_PROFILE lpcRecipientProfile
//*                 The personal information of the recipient.
//*                 When FaxNumber of the Recipient is compound, split it to :
//*                     Displayable ( put in Recipient's PersonalProfile ), and
//*                     Dialable ( put in RecipientJob's tczDialableRecipientFaxNumber ).
//*
//*     [IN]     BOOL bCreateQueueFile
//*                 If TRUE the new queue entry will be comitted to a disk file.
//*                 If FALSE it will not be comitted to a disk file. This is useful
//*                 when this function is used to restore the fax queue.
//*     [IN]     DWORD dwJobStatus  - the new job status - default value is JS_PENDING
//*
//* RETURN VALUE:
//*     On success the function returns a pointer to a newly created
//*     JOB_QUEUE structure.
//*     On failure it returns NULL.
//*********************************************************************************
PJOB_QUEUE
AddRecipientJob(
             IN const PLIST_ENTRY lpcQueueHead,
             IN OUT PJOB_QUEUE lpParentJob,
             IN LPCFAX_PERSONAL_PROFILE lpcRecipientProfile,
             IN BOOL bCreateQueueFile,
             IN DWORD dwJobStatus
            )

{
    PJOB_QUEUE lpJobQEntry = NULL;
    WCHAR QueueFileName[MAX_PATH];
    PJOB_QUEUE_PTR lpRecipientPtr = NULL;
    DWORD rc=ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("AddRecipientJob"));
    Assert(lpcQueueHead); // Must have a queue to add to
    Assert(lpParentJob);  // Must have a parent job
    Assert(lpcRecipientProfile); // Must have a recipient profile
    //
    // Validate that the recipient number is not NULL
    //
    if (NULL == lpcRecipientProfile->lptstrFaxNumber)
    {
        rc = ERROR_INVALID_PARAMETER;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("AddRecipientJob() got NULL Recipient number, fax send will abort."));
        goto Error;
    }
    
    lpJobQEntry = new (std::nothrow) JOB_QUEUE;
    if (!lpJobQEntry)
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for JOB_QUEUE structure. (ec: %ld)"),rc);
        goto Error;
    }

    ZeroMemory( lpJobQEntry, sizeof(JOB_QUEUE) );

    //
    // Notice - This (InitializeListHead) must be done regardles of the recipient type because the current code (for cleanup and persistence)
    // does not make a difference between the job types. I might change that in a while
    //
    InitializeListHead( &lpJobQEntry->FaxRouteFiles );
    InitializeListHead( &lpJobQEntry->RoutingDataOverride );

    if (!lpJobQEntry->CsFileList.Initialize() ||
        !lpJobQEntry->CsRoutingDataOverride.Initialize() ||
        !lpJobQEntry->CsPreview.Initialize())
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    lpJobQEntry->JobId                     = InterlockedIncrement( (PLONG)&g_dwNextJobId );
    lpJobQEntry->JobType                   = JT_SEND;
    lpJobQEntry->JobStatus                 = dwJobStatus;
    //
    // Link back to parent job.
    //
    lpJobQEntry->lpParentJob=lpParentJob;
    //
    // We duplicate the relevant parent job parameters at each recipient (for consistency with legacy code).
    // It wastes some memory but it saves us the trouble of making a major change to the current code base.
    //
    lpJobQEntry->ScheduleTime=lpParentJob->ScheduleTime;
    lpJobQEntry->FileName = NULL;
    lpJobQEntry->FileSize=lpParentJob->FileSize;
    lpJobQEntry->PageCount=lpParentJob->PageCount;
    //
    // Copy job parameters from parent.
    //
    if (!CopyJobParamEx(&lpJobQEntry->JobParamsEx,&lpParentJob->JobParamsEx))
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed. (ec: 0x%0X)"),rc);
        goto Error;
    }
    //
    // Copy Sender Profile from parent.
    //
    if (!CopyPersonalProfile(&lpJobQEntry->SenderProfile,&lpParentJob->SenderProfile))
    {
         rc=GetLastError();
         DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed. (ec: 0x%0X)"),rc);
         goto Error;
    }
    //
    // Set the recipient profile
    //
    if (!CopyPersonalProfile(&(lpJobQEntry->RecipientProfile),lpcRecipientProfile))
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy the sender personal profile (ec: 0x%0X)"),rc);
        goto Error;
    }

    //
    //  Set Dialable Fax Number of the Recipient
    //
    ZeroMemory(lpJobQEntry->tczDialableRecipientFaxNumber, SIZEOF_PHONENO * sizeof(TCHAR));

    if ( 0 == _tcsncmp(COMBINED_PREFIX, lpJobQEntry->RecipientProfile.lptstrFaxNumber, _tcslen(COMBINED_PREFIX)))
    {
        //
        //  Fax Number of the Recipient is Compound, so it contains the Dialable and the Displayable
        //  Extract Dialable to the JobQueue's DialableFaxNumber and
        //      put Displayable in the Recipient's Fax Number instead of the Compound
        //

        LPTSTR  lptstrStart = NULL;
        LPTSTR  lptstrEnd = NULL;
        DWORD   dwSize = 0;

        //
        //  Copy the Diable Fax Number to JobQueue.tczDialableRecipientFaxNumber
        //

        lptstrStart = (lpJobQEntry->RecipientProfile.lptstrFaxNumber) + _tcslen(COMBINED_PREFIX);

        lptstrEnd = _tcsstr(lptstrStart, COMBINED_SUFFIX);
        if (!lptstrEnd)
        {
            rc = ERROR_INVALID_PARAMETER;
            DebugPrintEx(DEBUG_ERR,
                _T("Wrong Compound Fax Number : %s"),
                lpJobQEntry->RecipientProfile.lptstrFaxNumber,
                rc);
            goto Error;
        }

        dwSize = lptstrEnd - lptstrStart;
        if (dwSize >= SIZEOF_PHONENO)
        {
            dwSize = SIZEOF_PHONENO - 1;
        }

        _tcsncpy (lpJobQEntry->tczDialableRecipientFaxNumber, lptstrStart, dwSize);

        //
        //  Replace Recipient's PersonalProfile's Compound Fax Number by the Displayable
        //

        lptstrStart = lptstrEnd + _tcslen(COMBINED_SUFFIX);

        dwSize = _tcslen(lptstrStart);
        lptstrEnd = LPTSTR(MemAlloc(sizeof(TCHAR) * (dwSize + 1)));
        if (!lptstrEnd)
        {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(DEBUG_ERR, _T("MemAlloc() failed"), rc);
            goto Error;
        }

        _tcscpy(lptstrEnd, lptstrStart);

        MemFree(lpJobQEntry->RecipientProfile.lptstrFaxNumber);
        lpJobQEntry->RecipientProfile.lptstrFaxNumber = lptstrEnd;
    }
    
    EnterCriticalSection( &g_CsQueue );
    if (bCreateQueueFile)
    {       
        // JOB_QUEUE::UniqueId holds the generated unique file name as 64 bit value.
        // composed as MAKELONGLONG( MAKELONG( FatDate, FatTime ), i ).
        lpJobQEntry->UniqueId=GenerateUniqueQueueFile(JT_SEND,  QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR));
        if (0==lpJobQEntry->UniqueId)
        {
            // Failed to generate unique id
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate unique id for FQE file (ec: 0x%0X)"),rc);
            LeaveCriticalSection(&g_CsQueue);
            goto Error;
        }
        lpJobQEntry->QueueFileName = StringDup( QueueFileName );
        if (!CommitQueueEntry( lpJobQEntry))
        {
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to commit job queue entry to file %s (ec: %ld)"),QueueFileName,rc);
            LeaveCriticalSection(&g_CsQueue);
            goto Error;
        }    
    }
    //
    // Add the recipient job to the the queue
    //
    if (!InsertQueueEntryByPriorityAndSchedule(lpJobQEntry))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InsertQueueEntryByPriorityAndSchedule() failed (ec: %ld)."),
            rc);
        LeaveCriticalSection( &g_CsQueue );
        goto Error;
    }


    //
    // Add the recipient job to the recipient list at the parent job
    //
    lpRecipientPtr=(PJOB_QUEUE_PTR)MemAlloc(sizeof(JOB_QUEUE_PTR));
    if (!lpRecipientPtr)
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for recipeint JOB_QUEUE_PTR structure. (ec: %ld)"),rc);
        LeaveCriticalSection(&g_CsQueue);
        goto Error;
    }
    lpRecipientPtr->lpJob=lpJobQEntry;
    InsertTailList(&lpParentJob->RecipientJobs,&(lpRecipientPtr->ListEntry));
    lpParentJob->dwRecipientJobsCount++;

    SafeIncIdleCounter(&g_dwQueueCount);
    SetFaxJobNumberRegistry( g_dwNextJobId );
    IncreaseJobRefCount (lpJobQEntry);
    Assert (lpJobQEntry->RefCount == 1);

    LeaveCriticalSection( &g_CsQueue );

    DebugPrintEx(DEBUG_MSG,TEXT("Added Recipient Job %d to Parent Job %d"), lpJobQEntry->JobId,lpJobQEntry->lpParentJob->JobId );


    Assert(ERROR_SUCCESS == rc);
    SetLastError(ERROR_SUCCESS);

    return lpJobQEntry;

Error:
    Assert(ERROR_SUCCESS != rc);
    if (lpJobQEntry)
    {
        FreeRecipientQueueEntry(lpJobQEntry,TRUE);
    }
    SetLastError(rc);
    return NULL;
}


#if DBG


//*********************************************************************************
//* Name:   DumpRecipientJob()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Dumps the content of a recipient job.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpcRecipJob
//*         The recipient job to dump.
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void DumpRecipientJob(const PJOB_QUEUE lpcRecipJob)
{
    TCHAR szTime[256] = {0};
    Assert(lpcRecipJob);
    Assert(JT_SEND == lpcRecipJob->JobType);

    DebugDateTime(lpcRecipJob->ScheduleTime, szTime, ARR_SIZE(szTime));
    DebugPrint((TEXT("\t*******************")));
    DebugPrint((TEXT("\tRecipient Job: %d"),lpcRecipJob->JobId));
    DebugPrint((TEXT("\t*******************")));
    DebugPrint((TEXT("\tUniqueId: 0x%016I64X"),lpcRecipJob->UniqueId));
    DebugPrint((TEXT("\tQueueFileName: %s"),lpcRecipJob->QueueFileName));
    DebugPrint((TEXT("\tParent Job Id: %d"),lpcRecipJob->lpParentJob->JobId));
    DebugPrint((TEXT("\tSchedule: %s"),szTime));
    DebugPrint((TEXT("\tRecipient Name: %s"),lpcRecipJob->RecipientProfile.lptstrName));
    DebugPrint((TEXT("\tRecipient Number: %s"),lpcRecipJob->RecipientProfile.lptstrFaxNumber));
    DebugPrint((TEXT("\tSend Retries: %d"),lpcRecipJob->SendRetries));
    DebugPrint((TEXT("\tJob Status: %d"),lpcRecipJob->JobStatus));
    DebugPrint((TEXT("\tRecipient Count: %d"),lpcRecipJob->JobStatus));
}
#endif

DWORD
GetMergedFileSize(
    LPCWSTR                         lpcwstrBodyFile,
    DWORD                           dwPageCount,
    LPCFAX_COVERPAGE_INFO_EX        lpcCoverPageInfo,
    LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
    LPCFAX_PERSONAL_PROFILEW        lpcRecipientProfile
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwFileSize = 0;
    DWORD dwBodyFileSize = 0;
    short Resolution = 0; // Default resolution
    WCHAR szCoverPageTiffFile[MAX_PATH] = {0};
    BOOL  bDeleteFile = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("GetMergedFileSize"));

    Assert (dwPageCount && lpcCoverPageInfo && lpcSenderProfile && lpcRecipientProfile);

    if (lpcwstrBodyFile)
    {
        if (!GetBodyTiffResolution(lpcwstrBodyFile, &Resolution))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetBodyTiffResolution() failed (ec: %ld)."),
                dwRes);
            goto exit;
        }
    }

    Assert (Resolution == 0 || Resolution == 98 || Resolution == 196);

    //
    // First create the cover page (This generates a file and returns its name).
    //
    if (!CreateCoverpageTiffFileEx(
                              Resolution,
                              dwPageCount,
                              lpcCoverPageInfo,
                              lpcRecipientProfile,
                              lpcSenderProfile,
                              TEXT("tmp"),
                              szCoverPageTiffFile,
                              ARR_SIZE(szCoverPageTiffFile)))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateCoverpageTiffFileEx failed to render cover page template %s (ec : %ld)"),
                     lpcCoverPageInfo->lptstrCoverPageFileName,
                     dwRes);
        goto exit;
    }
    bDeleteFile = TRUE;

    if (0 == (dwFileSize = MyGetFileSize (szCoverPageTiffFile)))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("MyGetFileSize Failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    if (lpcwstrBodyFile)
    {
        //
        // There is a body file specified so get its file size.
        //
        if (0 == (dwBodyFileSize = MyGetFileSize(lpcwstrBodyFile)))
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("MyGetFileSize Failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }
    }

    dwFileSize += dwBodyFileSize;
    Assert (dwFileSize);

exit:
    if (TRUE == bDeleteFile)
    {
        //
        // Get rid of the coverpage TIFF we generated.
        //
        if (!DeleteFile(szCoverPageTiffFile))
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT(" Failed to delete cover page TIFF file %ws. (ec: %ld)"),
                     szCoverPageTiffFile,
                     GetLastError());
        }
    }

    if (0 == dwFileSize)
    {
        Assert (ERROR_SUCCESS != dwRes);
        SetLastError(dwRes);
    }
    return dwFileSize;
}


//*********************************************************************************
//*                         Parent Job Functions
//*********************************************************************************

//*********************************************************************************
//* Name:   AddParentJob()
//* Author: Ronen Barenboim
//* Date:   March 18, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Adds a parent job (with no recipients) to the queue.
//*     After calling this function recipient should be added using
//*     AddRecipientJob()
//* PARAMETERS:
//*     lpcQueueHead
//*
//*     lpcwstrBodyFile
//*
//*     lpcSenderProfile
//*
//*     lpcJobParams
//*
//*     lpcCoverPageInfo
//*
//*     lpcwstrUserName
//*
//*     lpUserSid
//*
//*
//*     lpcRecipientProfile
//*
//* RETURN VALUE:
//*     A pointer to the added parent job. If the function fails it returns a NULL
//*     pointer.
//*********************************************************************************
PJOB_QUEUE AddParentJob(
             IN const PLIST_ENTRY lpcQueueHead,
             IN LPCWSTR lpcwstrBodyFile,
             IN LPCFAX_PERSONAL_PROFILE lpcSenderProfile,
             IN LPCFAX_JOB_PARAM_EXW  lpcJobParams,
             IN LPCFAX_COVERPAGE_INFO_EX  lpcCoverPageInfo,
             IN LPCWSTR lpcwstrUserName,
             IN PSID lpUserSid,
             IN LPCFAX_PERSONAL_PROFILEW lpcRecipientProfile,
             IN BOOL bCreateQueueFile
             )
{

    PJOB_QUEUE lpJobQEntry;
    WCHAR QueueFileName[MAX_PATH];
    HANDLE hTiff;
    TIFF_INFO TiffInfo;
    DWORD rc = ERROR_SUCCESS;
    DWORD Size = sizeof(JOB_QUEUE);
    DWORD dwSidSize = 0;
    DEBUG_FUNCTION_NAME(TEXT("AddParentJob"));

    Assert(lpcQueueHead);
    Assert(lpcSenderProfile);
    Assert(lpcJobParams);
    Assert(lpcwstrUserName);

    
    lpJobQEntry = new (std::nothrow) JOB_QUEUE;
    if (!lpJobQEntry) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for JOB_QUEUE structure. (ec: %ld)"),GetLastError());
        goto Error;
    }

    ZeroMemory( lpJobQEntry, Size );
    // The list heads must be initialized before any chance of error may occure. Otherwise
    // the cleanup code (which traverses these lists is undefined).
    InitializeListHead( &lpJobQEntry->FaxRouteFiles );
    InitializeListHead( &lpJobQEntry->RoutingDataOverride );
    InitializeListHead( &lpJobQEntry->RecipientJobs );

    if (!lpJobQEntry->CsRoutingDataOverride.Initialize() ||
        !lpJobQEntry->CsFileList.Initialize())
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    lpJobQEntry->JobId                     = InterlockedIncrement( (PLONG)&g_dwNextJobId );
    lpJobQEntry->FileName                  = StringDup( lpcwstrBodyFile);
    if (lpcwstrBodyFile && !lpJobQEntry->FileName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( lpcwstrBodyFile) failed (ec: %ld)"),
            rc=GetLastError());
        goto Error;
    }

    lpJobQEntry->JobType                   = JT_BROADCAST;
    lpJobQEntry->UserName                  = StringDup( lpcwstrUserName );
    if (lpcwstrUserName  && !lpJobQEntry->UserName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( lpcwstrUserName ) failed (ec: %ld)"),
            rc=GetLastError());
        goto Error;
    }

    Assert(lpUserSid);
    if (!IsValidSid(lpUserSid))
    {
         rc = ERROR_INVALID_DATA;
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("Not a valid SID"));
        goto Error;
    }
    dwSidSize = GetLengthSid(lpUserSid);

    lpJobQEntry->UserSid = (PSID)MemAlloc(dwSidSize);
    if (lpJobQEntry->UserSid == NULL)
    {
         rc = ERROR_NOT_ENOUGH_MEMORY;
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SID buffer"));
        goto Error;

    }
    if (!CopySid(dwSidSize, lpJobQEntry->UserSid, lpUserSid))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopySid Failed, Error : %ld"),
            rc = GetLastError()
            );
        goto Error;
    }


    if (!CopyJobParamEx( &lpJobQEntry->JobParamsEx,lpcJobParams)) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed. (ec: 0x%0X)"),GetLastError());
        goto Error;
    }
    lpJobQEntry->JobStatus                 = JS_PENDING;

    // Copy the sender profile
    if (!CopyPersonalProfile(&(lpJobQEntry->SenderProfile),lpcSenderProfile)) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy the sender personal profile (ec: 0x%0X)"),GetLastError());
        goto Error;
    }

    // Copy the cover page info
    if (!CopyCoverPageInfoEx(&(lpJobQEntry->CoverPageEx),lpcCoverPageInfo)) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy the cover page information (ec: 0x%0X)"),GetLastError());
        goto Error;
    }



    //
    // get the page count
    //
    if (lpcwstrBodyFile)
    {
        hTiff = TiffOpen( (LPWSTR) lpcwstrBodyFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
        if (hTiff)
        {
            lpJobQEntry->PageCount = TiffInfo.PageCount;
            TiffClose( hTiff );
        }
        else
        {
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to open body file to get page count (ec: 0x%0X)"), rc);
            goto Error;
        }
    }
    if( lpJobQEntry->JobParamsEx.dwPageCount )
    {
        // user specifically asked to use JobParamsEx.dwPageCount in the job
        lpJobQEntry->PageCount = lpJobQEntry->JobParamsEx.dwPageCount;
    }

    //
    // Cover page counts as an extra page
    //
    if (lpcCoverPageInfo && lpcCoverPageInfo->lptstrCoverPageFileName) {
        lpJobQEntry->PageCount++;
    }

    //
    // Get the file size
    //
    if (NULL == lpcRecipientProfile)
    {
        //
        // We restore the job queue - the file size will be stored by RestoreParentJob()
        //
    }
    else
    {
        //
        // This is a new parent job
        //
        if (NULL == lpcCoverPageInfo->lptstrCoverPageFileName)
        {
            Assert (lpcwstrBodyFile);
            //
            // No coverpage - the file size is the body file size only
            //
            if (0 == (lpJobQEntry->FileSize = MyGetFileSize(lpcwstrBodyFile)))
            {
                rc = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("MyGetFileSize Failed (ec: %ld)"),
                             rc);
                goto Error;
            }
        }
        else
        {
            lpJobQEntry->FileSize = GetMergedFileSize (lpcwstrBodyFile,
                                                       lpJobQEntry->PageCount,
                                                       lpcCoverPageInfo,
                                                       lpcSenderProfile,
                                                       lpcRecipientProfile
                                                       );
            if (0 == lpJobQEntry->FileSize)
            {
                rc = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("GetMergedFileSize failed (ec: %ld)"),
                             rc);
                goto Error;
            }
        }
    }

    lpJobQEntry->DeliveryReportProfile = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME)&lpJobQEntry->SubmissionTime);
    if (lpcJobParams->dwScheduleAction == JSA_SPECIFIC_TIME)
    {
        if (!SystemTimeToFileTime( &lpJobQEntry->JobParamsEx.tmSchedule, (FILETIME*) &lpJobQEntry->ScheduleTime)) {
            rc=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime failed. (ec: %ld)"),
                rc);
        }
    }
    else if (lpcJobParams->dwScheduleAction == JSA_DISCOUNT_PERIOD)
        {
            SYSTEMTIME CurrentTime;
            GetSystemTime( &CurrentTime ); // Can not fail (see Win32 SDK)
            // find a time within the discount period to execute this job.
            if (!SetDiscountTime( &CurrentTime )) {
                rc=GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetDiscountTime failed. (ec: %ld)"),
                    rc);
                goto Error;
            }

            if (!SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&lpJobQEntry->ScheduleTime )){
                rc=GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SystemTimeToFileTime failed. (ec: %ld)"),
                    rc);
                goto Error;
            }
        }
        else
        {
            Assert (lpcJobParams->dwScheduleAction == JSA_NOW);
            lpJobQEntry->ScheduleTime = lpJobQEntry->SubmissionTime;
        }

    lpJobQEntry->OriginalScheduleTime = lpJobQEntry->ScheduleTime;

    EnterCriticalSection( &g_CsQueue );

    if (bCreateQueueFile) {
        // JOB_QUEUE::UniqueId holds the generated unique file name as 64 bit value.
        // composed as MAKELONGLONG( MAKELONG( FatDate, FatTime ), i ).
        lpJobQEntry->UniqueId = GenerateUniqueQueueFile(JT_BROADCAST, QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR) );
        if (0==lpJobQEntry->UniqueId) {
            rc=GetLastError();
            // Failed to generate unique id
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate unique id for FQP file (ec: 0x%0X)"),GetLastError());
            LeaveCriticalSection( &g_CsQueue );
            goto Error;
        }
        lpJobQEntry->QueueFileName = StringDup( QueueFileName );
        if (!lpJobQEntry->QueueFileName) {
            rc=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup( QueueFileName ) failed (ec: %ld)"),
                GetLastError());
            LeaveCriticalSection( &g_CsQueue );
            goto Error;
        }

        if (!CommitQueueEntry( lpJobQEntry)) {
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to commit job queue entry to file %s (ec: %ld)"),QueueFileName,GetLastError());
            LeaveCriticalSection( &g_CsQueue );
            goto Error;
        }
    }

     //Add the parent job to the tail of the queue
    InsertTailList( lpcQueueHead, &(lpJobQEntry->ListEntry) )
    SafeIncIdleCounter (&g_dwQueueCount);
    SetFaxJobNumberRegistry( g_dwNextJobId );

    LeaveCriticalSection( &g_CsQueue );

    DebugPrintEx(DEBUG_MSG,TEXT("Added Job with Id: %d"), lpJobQEntry->JobId );

    Assert (ERROR_SUCCESS == rc);
    return lpJobQEntry;

Error:
    Assert(ERROR_SUCCESS != rc);
    if (lpJobQEntry)
    {
        FreeParentQueueEntry(lpJobQEntry,TRUE);
    }
    SetLastError(rc);
    return NULL;
}



//*********************************************************************************
//* Name:   FreeParentQueueEntry()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the memory taken by the members of a JOB_QUEUE structure of type
//*     JT_BROADCAST.
//*     If requested frees the structure as well.
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobQueue
//*         The JOB_QUEUE structure whose fields memeory is to be freed.
//*     [IN]    BOOL bDestroy
//*         If TRUE the structure itself will be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeParentQueueEntry(PJOB_QUEUE lpJobQueue,BOOL bDestroy)
{
    DEBUG_FUNCTION_NAME(TEXT("FreeParentQueueEntry"));
    Assert(lpJobQueue);
    Assert(JT_BROADCAST == lpJobQueue->JobType);

    // No need to check NULL pointers since free() ignores them.
    MemFree( (LPBYTE) lpJobQueue->FileName );
    MemFree( (LPBYTE) lpJobQueue->UserName );
    MemFree( (LPBYTE) lpJobQueue->UserSid  );
    MemFree( (LPBYTE) lpJobQueue->QueueFileName );
    FreeJobParamEx(&lpJobQueue->JobParamsEx,FALSE); // do not destroy
    FreePersonalProfile(&lpJobQueue->SenderProfile,FALSE);
    FreeCoverPageInfoEx(&lpJobQueue->CoverPageEx,FALSE);
    //
    // Free the recipient reference list
    //

    while ((ULONG_PTR)lpJobQueue->RecipientJobs.Flink!=(ULONG_PTR)&lpJobQueue->RecipientJobs.Flink) {

          PJOB_QUEUE_PTR lpJobQueuePtr;

          lpJobQueuePtr = CONTAINING_RECORD( lpJobQueue->RecipientJobs.Flink, JOB_QUEUE_PTR, ListEntry );
          RemoveEntryList( &lpJobQueuePtr->ListEntry); // removes it from the list but does not deallocate its memory
          MemFree(lpJobQueuePtr); // free the memory occupied by the job reference
          lpJobQueue->dwRecipientJobsCount--;
    }
    Assert(lpJobQueue->dwRecipientJobsCount==0);

    if (bDestroy) {
        delete lpJobQueue;
    }

}

//*********************************************************************************
//* Name:   FreeRecipientQueueEntry()
//* Author: Oded Sacher
//* Date:   25-Dec- 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the memory taken by the members of a JOB_QUEUE structure of type
//*     JT_RECIPIENT.
//*     If requested frees the structure as well.
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobQueue
//*         The JOB_QUEUE structure whose fields memeory is to be freed.
//*     [IN]    BOOL bDestroy
//*         If TRUE the structure itself will be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeRecipientQueueEntry(PJOB_QUEUE lpJobQueue,BOOL bDestroy)
{
    DEBUG_FUNCTION_NAME(TEXT("FreeRecipientQueueEntry"));

    DebugPrintEx(DEBUG_MSG,TEXT("Freeing lpJobQueue.JobParams...") );
    FreeJobParamEx(&lpJobQueue->JobParamsEx,FALSE);
    DebugPrintEx(DEBUG_MSG,TEXT("Freeing SenderProfile...") );
    FreePersonalProfile(&lpJobQueue->SenderProfile,FALSE);
    DebugPrintEx(DEBUG_MSG,TEXT("Freeing RecipientProfile...") );
    FreePersonalProfile(&lpJobQueue->RecipientProfile,FALSE);

    MemFree( (LPBYTE) lpJobQueue->FileName );
    MemFree( (LPBYTE) lpJobQueue->UserName );
    MemFree( (LPBYTE) lpJobQueue->QueueFileName );
    MemFree( (LPBYTE) lpJobQueue->PreviewFileName );
    
    if (bDestroy)
    {
        delete lpJobQueue;
    }

}

#if DBG

//*********************************************************************************
//* Name:   DumpParentJob()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Dumps a parent job and its recipients.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpcParentJob
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void DumpParentJob(const PJOB_QUEUE lpcParentJob)
{
   PLIST_ENTRY lpNext;
   PJOB_QUEUE_PTR lpRecipientJobPtr;
   PJOB_QUEUE lpRecipientJob;

   Assert(lpcParentJob);
   Assert(JT_BROADCAST == lpcParentJob->JobType );

   DebugPrint((TEXT("===============================")));
   DebugPrint((TEXT("=====  Parent Job: %d"),lpcParentJob->JobId));
   DebugPrint((TEXT("===============================")));
   DebugPrint((TEXT("JobParamsEx")));
   DumpJobParamsEx(&lpcParentJob->JobParamsEx);
   DebugPrint((TEXT("CoverPageEx")));
   DumpCoverPageEx(&lpcParentJob->CoverPageEx);
   DebugPrint((TEXT("UserName: %s"),lpcParentJob->UserName));
   DebugPrint((TEXT("FileSize: %ld"),lpcParentJob->FileSize));
   DebugPrint((TEXT("PageCount: %ld"),lpcParentJob->PageCount));
   DebugPrint((TEXT("UniqueId: 0x%016I64X"),lpcParentJob->UniqueId));
   DebugPrint((TEXT("QueueFileName: %s"),lpcParentJob->QueueFileName));

   DebugPrint((TEXT("Recipient Count: %ld"),lpcParentJob->dwRecipientJobsCount));
   DebugPrint((TEXT("Completed Recipients: %ld"),lpcParentJob->dwCompletedRecipientJobsCount));
   DebugPrint((TEXT("Canceled Recipients: %ld"),lpcParentJob->dwCanceledRecipientJobsCount));
   DebugPrint((TEXT("Recipient List: ")));



   lpNext = lpcParentJob->RecipientJobs.Flink;
   if ((ULONG_PTR)lpNext == (ULONG_PTR)&lpcParentJob->RecipientJobs) {
        DebugPrint(( TEXT("No recipients.") ));
   } else {
        while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcParentJob->RecipientJobs) {
            lpRecipientJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
            lpRecipientJob=lpRecipientJobPtr->lpJob;
            DumpRecipientJob(lpRecipientJob);
            lpNext = lpRecipientJobPtr->ListEntry.Flink;
        }
   }

}
#endif

//*********************************************************************************
//*                         Receive Job Functions
//*********************************************************************************

//*********************************************************************************
//* Name:   AddReceiveJobQueueEntry()
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     [IN]    LPCTSTR FileName
//*         The full path to the file into which the receive document will
//*         be placed.
//*     [IN]    IN PJOB_ENTRY JobEntry
//*         The run time job entry for the receive job (generated with StartJob())
//*
//*     [IN]    IN DWORD JobType // can be JT_RECEIVE or JT_ROUTING
//*         The type of the receive job.
//*
//*     [IN]    IN DWORDLONG dwlUniqueJobID The jon unique ID
//*
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_QUEUE
AddReceiveJobQueueEntry(
    IN LPCTSTR FileName,
    IN PJOB_ENTRY JobEntry,
    IN DWORD JobType, // can be JT_RECEIVE or JT_ROUTING
    IN DWORDLONG dwlUniqueJobID
    )
{

    PJOB_QUEUE JobQueue;
    DWORD rc = ERROR_SUCCESS;
    DWORD Size = sizeof(JOB_QUEUE);
    DEBUG_FUNCTION_NAME(TEXT("AddReceiveJobQueueEntry"));

    Assert(FileName);
    Assert(JT_RECEIVE == JobType ||
           JT_ROUTING == JobType);

    LPTSTR TempFileName = _tcsrchr( FileName, '\\' ) + 1;

    JobQueue = new (std::nothrow) JOB_QUEUE;
    if (!JobQueue)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for JOB_QUEUE structure. (ec: %ld)"),GetLastError());
        rc = ERROR_OUTOFMEMORY;
        goto Error;
    }

    ZeroMemory( JobQueue, Size );
    JobQueue->fDeleteReceivedTiff = TRUE;

    if (!JobQueue->CsFileList.Initialize() ||
        !JobQueue->CsRoutingDataOverride.Initialize() ||
        !JobQueue->CsPreview.Initialize())
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    JobQueue->UniqueId = dwlUniqueJobID;
    JobQueue->FileName                  = StringDup( FileName );
    if ( FileName && !JobQueue->FileName )
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( FileName ) failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    JobQueue->JobId                     = InterlockedIncrement( (PLONG)&g_dwNextJobId );
    JobQueue->JobType                   = JobType;
    // In case of receive the JOB_QUEUE.UserName is the fax service name.
    JobQueue->UserName                  = StringDup( GetString( IDS_SERVICE_NAME ) );
    if (!JobQueue->UserName)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            rc);
        goto Error;
    }

    if (JobType == JT_RECEIVE)
    {
        JobQueue->JobStatus              = JS_INPROGRESS;
    }
    else
    {
        // JT_ROUTING
        JobQueue->JobStatus              = JS_RETRYING;
    }


    JobQueue->JobEntry                  = JobEntry;
    JobQueue->JobParamsEx.dwScheduleAction = JSA_NOW;        // For the queue sort
    JobQueue->JobParamsEx.Priority = FAX_PRIORITY_TYPE_HIGH; // For the queue sort - Routing jobs do not use devices.
                                                             // Give them the highest priority

    // In case of receive the JOB_QUEUE.DocumentName is the temporary receive file name.
    JobQueue->JobParamsEx.lptstrDocumentName    = StringDup( TempFileName );
    if (!JobQueue->JobParamsEx.lptstrDocumentName && TempFileName)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            rc);
            goto Error;
    }

    // link the running job back to the queued job unless it is
    // a routing job which does not have a running job entry.
    if (JobType == JT_RECEIVE)
    {
        Assert(JobQueue->JobEntry);
        JobQueue->JobEntry->lpJobQueueEntry = JobQueue;
    }

    InitializeListHead( &JobQueue->FaxRouteFiles );
    InitializeListHead( &JobQueue->RoutingDataOverride );

    SafeIncIdleCounter (&g_dwQueueCount);
    //
    // Don't persist to queue file
    //
    IncreaseJobRefCount (JobQueue);
    Assert (JobQueue->RefCount == 1);

    Assert (ERROR_SUCCESS == rc);

    EnterCriticalSection( &g_CsQueue );
    SetFaxJobNumberRegistry( g_dwNextJobId );
    // Add the new job to the queue.
    InsertHeadList( &g_QueueListHead, &JobQueue->ListEntry );
    LeaveCriticalSection( &g_CsQueue );
    return JobQueue;

Error:
    Assert (ERROR_SUCCESS != rc);

    if (NULL != JobQueue)
    {
        FreeReceiveQueueEntry(JobQueue, TRUE);
    }
    SetLastError (rc);
    return NULL;
}


//*********************************************************************************
//* Name:   FreeReceiveQueueEntry()
//* Author: Ronen Barenboim
//* Date:   12-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the memory occupied by the feilds of a
//*     JT_RECEIVE/JT_FAIL_RECEIVE/JT_ROUTING JOB_QUEUE structure.
//*     Fress the entire structure if required.
//*     DOES NOT FREE any other resource (files, handles, etc.)
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobQueue
//*         The structure to free.
//*     [IN]    BOOL bDestroy
//*         TRUE if the structure itself need to be freed.
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeReceiveQueueEntry(
    PJOB_QUEUE lpJobQueue,
    BOOL bDestroy
    )

{
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    PROUTING_DATA_OVERRIDE  RoutingDataOverride;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("FreeReceiveQueueEntry"));
    Assert(lpJobQueue);


    DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.JobParams...") );
    FreeJobParamEx(&lpJobQueue->JobParamsEx,FALSE);
    MemFree( (LPBYTE) lpJobQueue->FileName );
    MemFree( (LPBYTE) lpJobQueue->UserName );
    MemFree( (LPBYTE) lpJobQueue->QueueFileName );
    MemFree( (LPBYTE) lpJobQueue->PreviewFileName );

    if (lpJobQueue->FaxRoute) {
        PFAX_ROUTE FaxRoute = lpJobQueue->FaxRoute;
        DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.FaxRoute...") );
        MemFree( (LPBYTE) FaxRoute->Csid );
        MemFree( (LPBYTE) FaxRoute->Tsid );
        MemFree( (LPBYTE) FaxRoute->CallerId );
        MemFree( (LPBYTE) FaxRoute->ReceiverName );
        MemFree( (LPBYTE) FaxRoute->ReceiverNumber );
        MemFree( (LPBYTE) FaxRoute->RoutingInfo );
    MemFree( (LPBYTE) FaxRoute->DeviceName );
        MemFree( (LPBYTE) FaxRoute->RoutingInfoData );
        MemFree( (LPBYTE) FaxRoute );
    }

    //
    // walk the file list and remove any files
    //

    DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.FaxRouteFiles...") );
    Next = lpJobQueue->FaxRouteFiles.Flink;
    if (Next != NULL) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&lpJobQueue->FaxRouteFiles) {
            FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
            Next = FaxRouteFile->ListEntry.Flink;
            MemFree( FaxRouteFile->FileName );
            MemFree( FaxRouteFile );
        }
    }

    //
    // walk the routing data override list and free all memory
    //
    DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.RoutingDataOverride...") );
    Next = lpJobQueue->RoutingDataOverride.Flink;
    if (Next != NULL) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&lpJobQueue->RoutingDataOverride) {
            RoutingDataOverride = CONTAINING_RECORD( Next, ROUTING_DATA_OVERRIDE, ListEntry );
            Next = RoutingDataOverride->ListEntry.Flink;
            MemFree( RoutingDataOverride->RoutingData );
            MemFree( RoutingDataOverride );
        }
    }

    //
    // free any routing failure data
    //
    for (i =0; i<lpJobQueue->CountFailureInfo; i++)
    {
        DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.RouteFailureInfo...") );
        if ( lpJobQueue->pRouteFailureInfo[i].FailureData )
        {
            MemFree(lpJobQueue->pRouteFailureInfo[i].FailureData);
        }
    }
    MemFree (lpJobQueue->pRouteFailureInfo);

    if (bDestroy) {
            DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue") );
            delete lpJobQueue;
    }



}

#if DBG
//*********************************************************************************
//* Name:   DumpReceiveJob()
//* Author: Ronen Barenboim
//* Date:   14-Apt-99
//*********************************************************************************
//* DESCRIPTION:
//*     Debug dumps a receive job.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpcJob
//*         The receive job to dump.
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void DumpReceiveJob(const PJOB_QUEUE lpcJob)
{
    TCHAR szTime[256] = {0};

    Assert(lpcJob);
    Assert( (JT_RECEIVE == lpcJob->JobType) );

    DebugDateTime(lpcJob->ScheduleTime, szTime , ARR_SIZE(szTime));
    DebugPrint((TEXT("===============================")));
    if (JT_RECEIVE == lpcJob->JobType) {
        DebugPrint((TEXT("=====  Receive Job: %d"),lpcJob->JobId));
    } else {
        DebugPrint((TEXT("=====  Fail Receive Job: %d"),lpcJob->JobId));
    }
    DebugPrint((TEXT("===============================")));
    DebugPrint((TEXT("UserName: %s"),lpcJob->UserName));
    DebugPrint((TEXT("UniqueId: 0x%016I64X"),lpcJob->UniqueId));
    DebugPrint((TEXT("QueueFileName: %s"),lpcJob->QueueFileName));
    DebugPrint((TEXT("Schedule: %s"),szTime));
    DebugPrint((TEXT("Status: %ld"),lpcJob->JobStatus));
    if (lpcJob->JobEntry)
    {
        DebugPrint((TEXT("FSP Queue Status: 0x%08X"), lpcJob->JobEntry->FSPIJobStatus.dwJobStatus));
        DebugPrint((TEXT("FSP Extended Status: 0x%08X"), lpcJob->JobEntry->FSPIJobStatus.dwExtendedStatus));
    }
}
#endif

//*********************************************************************************
//*                 Client API Structures Management
//*********************************************************************************


//*********************************************************************************
//* Name:   FreeJobParamEx()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the members of a FAX_JOB_PARAM_EXW structure and can be instructed
//*     to free the structure itself.
//* PARAMETERS:
//*     [IN]    PFAX_JOB_PARAM_EXW lpJobParamEx
//*         A pointer to the structure to free.
//*
//*     [IN]    BOOL bDestroy
//*         TRUE if the structure itself need to be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeJobParamEx(
        IN PFAX_JOB_PARAM_EXW lpJobParamEx,
        IN BOOL bDestroy
    )
{
    Assert(lpJobParamEx);
    MemFree(lpJobParamEx->lptstrReceiptDeliveryAddress);
    MemFree(lpJobParamEx->lptstrDocumentName);
    if (bDestroy) {
        MemFree(lpJobParamEx);
    }

}

//*********************************************************************************
//* Name:   CopyJobParamEx()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a duplicate of the specified FAX_JOB_PARAM_EXW structure into
//      an already allocated destination structure.
//* PARAMETERS:
//*     [OUT] PFAX_JOB_PARAM_EXW lpDst
//*         A pointer to the destination structure.
//*
//*     [IN]  LPCFAX_JOB_PARAM_EXW lpcSrc
//*         A pointer to the source structure.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL CopyJobParamEx(
    OUT PFAX_JOB_PARAM_EXW lpDst,
    IN LPCFAX_JOB_PARAM_EXW lpcSrc
    )
{
   STRING_PAIR pairs[] =
   {
        { lpcSrc->lptstrReceiptDeliveryAddress, &lpDst->lptstrReceiptDeliveryAddress},
        { lpcSrc->lptstrDocumentName, &lpDst->lptstrDocumentName},
   };
   int nRes;

   DEBUG_FUNCTION_NAME(TEXT("CopyJobParamEx"));

    Assert(lpDst);
    Assert(lpcSrc);

    memcpy(lpDst,lpcSrc,sizeof(FAX_JOB_PARAM_EXW));
    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"),nRes-1);
        return FALSE;
    }
    return TRUE;

}


//*********************************************************************************
//* Name:   CopyCoverPageInfoEx()
//* Author: Ronen Barenboim
//* Date:   14-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a duplicate of the specified FAX_COVERPAGE_INFO_EXW structure into
//      an already allocated destination structure.
//* PARAMETERS:
//*     [OUT] PFAX_COVERPAGE_INFO_EXW lpDst
//*         A pointer to the destination structure.
//*
//*     [IN]  LPCFAX_COVERPAGE_INFO_EXW lpcSrc
//*         A pointer to the source structure.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL CopyCoverPageInfoEx(
        OUT PFAX_COVERPAGE_INFO_EXW lpDst,
        IN LPCFAX_COVERPAGE_INFO_EXW lpcSrc
        )
{
   STRING_PAIR pairs[] =
   {
        { lpcSrc->lptstrCoverPageFileName, &lpDst->lptstrCoverPageFileName},
        { lpcSrc->lptstrNote, &lpDst->lptstrNote},
        { lpcSrc->lptstrSubject, &lpDst->lptstrSubject}
   };
   int nRes;

   DEBUG_FUNCTION_NAME(TEXT("CopyCoverPageInfoEx"));

    Assert(lpDst);
    Assert(lpcSrc);

    memcpy(lpDst,lpcSrc,sizeof(FAX_COVERPAGE_INFO_EXW));
    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"),nRes-1);
        return FALSE;
    }
    return TRUE;
}


//*********************************************************************************
//* Name:   FreeCoverPageInfoEx()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the members of a FAX_COVERPAGE_INFO_EXW structure and can be instructed
//*     to free the structure itself.
//* PARAMETERS:
//*     [IN]    PFAX_COVERPAGE_INFO_EXW lpJobParamEx
//*         A pointer to the structure to free.
//*
//*     [IN]    BOOL bDestroy
//*         TRUE if the structure itself need to be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeCoverPageInfoEx(
        IN PFAX_COVERPAGE_INFO_EXW lpCoverpage,
        IN BOOL bDestroy
    )
{
    Assert(lpCoverpage);
    MemFree(lpCoverpage->lptstrCoverPageFileName);
    MemFree(lpCoverpage->lptstrNote);
    MemFree(lpCoverpage->lptstrSubject);
    if (bDestroy) {
        MemFree(lpCoverpage);
    }
}



//**************************************
//* Outboung Routing Stub
//**************************************





//*********************************************************************************
//* Name:   RemoveParentJob()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a parent job from the queue. Can remove recipients as well.
//*     The caller can determine if a client notification (FEI event) will be
//*     generated for the removal.
//*     If the job reference count is not 0 - its status changes to JS_DELETING
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobToRemove
//*                 The job to be removed.
//*
//*     [IN]    BOOL bRemoveRecipients
//*                 TRUE if the recipients should be removed as well.
//*
//*     [IN]    BOOL bNotify
//*                 TRUE if a FEI_DELETED event should be generated/
//*
//* RETURN VALUE:
//*     TRUE
//*         The removal succeeded. The job is not in the queue.
//*         it might be that some job resources (files) were not removed.
//*     FALSE
//*         The removal failed. The job is still in the queue.
//*********************************************************************************
BOOL RemoveParentJob(
    PJOB_QUEUE lpJobToRemove,
    BOOL bRemoveRecipients,
    BOOL bNotify
    )
{
    PJOB_QUEUE lpJobQueue;
    DEBUG_FUNCTION_NAME(TEXT("RemoveParentJob"));

    Assert(lpJobToRemove);
    Assert(JT_BROADCAST ==lpJobToRemove->JobType);

    EnterCriticalSection( &g_CsQueue );
    //
    // Make sure it is still there. It might been deleted
    // by another thread by the time we get to execute.
    //
    lpJobQueue = FindJobQueueEntryByJobQueueEntry( lpJobToRemove );

    if (lpJobQueue == NULL) {
        DebugPrintEx(   DEBUG_WRN,
                        TEXT("Job %d (address: 0x%08X )was not found in job queue. No op."),
                        lpJobToRemove->JobId,
                        lpJobToRemove);
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    if (lpJobQueue->RefCount > 0)
    {
        DebugPrintEx(   DEBUG_WRN,
                        TEXT("Job %ld Ref count %ld - not removing."),
                        lpJobQueue->JobId,
                        lpJobQueue->RefCount);
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }


    if (lpJobQueue->PrevRefCount > 0)
    {
        // The job can not be removed
        // We should mark it as JS_DELETING.
        //
        // A user is using the job Tiff - Do not delete, Mark it as JS_DELETEING
        //
        lpJobQueue->JobStatus = JS_DELETING;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Removing parent job %ld"),lpJobQueue->JobId);

    //
    // No point in scheduling new jobs before we get rid of the recipients
    //
    if (!CancelWaitableTimer( g_hQueueTimer ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CancelWaitableTimer failed. (ec: %ld)"),
            GetLastError());
    }

    RemoveEntryList( &lpJobQueue->ListEntry );

    //
    // From this point we continue with the delete operation even if error occur since
    // the parent job is already out of the queue.
    //


    //
    // Remove all recipients
    //
    if (bRemoveRecipients) {
        DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Removing recipient jobs."),lpJobQueue->JobId);
        //
        // remove the recipients. send a delete notification for each recipient.
        //
        if (!RemoveParentRecipients(lpJobQueue, TRUE)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveParentRecipients failed. (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
    }

    //
    // Get rid of the persistence file if any.
    //
    if (lpJobQueue->QueueFileName) {
        DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Deleting QueueFileName %s\n"), lpJobQueue->JobId, lpJobQueue->QueueFileName );
        if (!DeleteFile( lpJobQueue->QueueFileName )) {
           DebugPrintEx(DEBUG_ERR,TEXT("[Job: %ld] Failed to delete QueueFileName %s  (ec: %ld)\n"), lpJobQueue->JobId, lpJobQueue->QueueFileName,GetLastError() );           
        }
    }


    //
    // Get rid of the body file. Recipient jobs will get rid of body files that they
    // have created (for legacy FSPs).
    //
    if (lpJobQueue->FileName) {
        DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Deleting body file %s\n"), lpJobQueue->JobId, lpJobQueue->FileName);
        if (!DeleteFile(lpJobQueue->FileName)) {
            DebugPrintEx(DEBUG_ERR,TEXT("[Job: %ld] Failed to delete body file %s  (ec: %ld)\n"), lpJobQueue->JobId, lpJobQueue->FileName, GetLastError() );            
        }
    }

    //
    // Get rid of the cover page template file if it is not a server based
    // cover page.

    if (lpJobQueue->CoverPageEx.lptstrCoverPageFileName &&
        !lpJobQueue->CoverPageEx.bServerBased) {
            DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Deleting personal Cover page template file %s\n"), lpJobQueue->JobId, lpJobQueue->CoverPageEx.lptstrCoverPageFileName );
            if (!DeleteFile(lpJobQueue->CoverPageEx.lptstrCoverPageFileName)) {
                DebugPrintEx( DEBUG_ERR,
                              TEXT("[Job: %ld] Failed to delete personal Cover page template file %s  (ec: %ld)\n"), lpJobQueue->JobId,
                              lpJobQueue->CoverPageEx.lptstrCoverPageFileName,GetLastError() );                
            }
    }

    //
    // One less job in the queue (not counting recipient jobs)
    //
    SafeDecIdleCounter (&g_dwQueueCount);

    if (bNotify)
    {
        if (!CreateFaxEvent(0, FEI_DELETED, lpJobQueue->JobId))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                GetLastError());
        }
    }

    FreeParentQueueEntry(lpJobQueue,TRUE); // Free the memory occupied by the entry itself

    //
    // We are back in business. Time to figure out when to wake up JobQueueThread.
    //
    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer failed. (ec: %ld)"),
            GetLastError());
    }

    LeaveCriticalSection( &g_CsQueue );

    return TRUE;
}


//*********************************************************************************
//* Name:   RemoveParentRecipients()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Removes the recipient jobs that belong to a specific parent job.
//* PARAMETERS:
//*     [OUT]   PJOB_QUEUE lpParentJob
//*         The parent job whose recipients are to be removed.
//*     [IN]    IN BOOL bNotify
//*         TRUE if a FEI_DELETED notification should be generated for
//*         each recipient.
//*
//* RETURN VALUE:
//*     TRUE
//*         All the recipients were removed from the queue.
//*     FALSE
//*         None of the recipient was removed from the queue.
//*********************************************************************************
BOOL RemoveParentRecipients(
        OUT PJOB_QUEUE lpParentJob,
        IN BOOL bNotify
     )
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE_PTR lpJobQueuePtr;
    PJOB_QUEUE lpFoundRecpRef=NULL;

    DEBUG_FUNCTION_NAME(TEXT("RemoveParentRecipients"));

    Assert(lpParentJob);

    lpNext = lpParentJob->RecipientJobs.Flink;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpParentJob->RecipientJobs) {
        lpJobQueuePtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        Assert(lpJobQueuePtr->lpJob);
        lpNext = lpJobQueuePtr->ListEntry.Flink;
        if (!RemoveRecipientJob(lpJobQueuePtr->lpJob,
                           bNotify,
                           FALSE // Do not recalc queue timer after each removal
                           ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveRecipientJob failed for recipient: %ld (ec: %ld)"),
                lpJobQueuePtr->lpJob->JobId,
                GetLastError());
            Assert(FALSE); // Should never happen. If it does we just continue to remove the other recipients.
        }

    }
    return TRUE;

}


//*********************************************************************************
//* Name:   RemoveRecipientJob()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobToRemove
//*         The job to be removed.
//*     [IN]    BOOL bNotify
//*         TRUE if to generate a FEI_DELETED event after the removal.
//*     [IN]    BOOL bRecalcQueueTimer
//*         TRUE if the queue timer need to be recalculated (and enabled)
//*         after the removal.
//*         when many recipients jobs are removed this is not desired since
//*         an about to be removed recipient might be scheduled.
//*
//* RETURN VALUE:
//*     TRUE
//*         The function allways succeeds. The only errors that can occur
//*         are files which can not be deleted in this case the function just
//*         go on with the removal operation.
//*     FALSE
//*
//*********************************************************************************
BOOL RemoveRecipientJob(
        IN PJOB_QUEUE lpJobToRemove,
        IN BOOL bNotify,
        IN BOOL bRecalcQueueTimer)
{
    PJOB_QUEUE lpJobQueue;

    DEBUG_FUNCTION_NAME(TEXT("RemoveRecipientJob"));

    Assert(lpJobToRemove);

    Assert(JT_SEND == lpJobToRemove->JobType);

    Assert(lpJobToRemove->lpParentJob);
    DebugPrintEx( DEBUG_MSG,
                  TEXT("Starting remove of JobId: %ld"),lpJobToRemove->JobId);

    EnterCriticalSection( &g_CsQueue );
    //
    // Make sure it is still there. It might been deleted
    // by another thread by the time we get to execute.
    //
    lpJobQueue = FindJobQueueEntryByJobQueueEntry( lpJobToRemove );
    if (lpJobQueue == NULL) {
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    if (lpJobQueue->RefCount == 0)  {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId :%ld] Reference count is zero. Deleting."),
            lpJobQueue->JobId);

        RemoveEntryList( &lpJobQueue->ListEntry );

        if (!CancelWaitableTimer( g_hQueueTimer )) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer() failed. (ec: %ld)"),
                GetLastError());
        }

        if (bRecalcQueueTimer) {
            if (!StartJobQueueTimer()) {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StartJobQueueTimer() failed. (ec: %ld)"),
                    GetLastError());
            }
        }

        if (lpJobQueue->QueueFileName) {
            DebugPrintEx(   DEBUG_MSG,
                            TEXT("[Job: %ld] Deleting QueueFileName %s"),
                            lpJobQueue->JobId,
                            lpJobQueue->QueueFileName );
            if (!DeleteFile( lpJobQueue->QueueFileName )) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Failed to delete QueueFileName %s (ec: %ld)"),
                                lpJobQueue->JobId,
                                lpJobQueue->QueueFileName,
                                GetLastError());
            }
        }

        if (lpJobQueue->PreviewFileName) {
            DebugPrintEx(   DEBUG_MSG,
                            TEXT("[Job: %ld] Deleting PreviewFileName %s"),
                            lpJobQueue->JobId,
                            lpJobQueue->PreviewFileName );
            if (!DeleteFile( lpJobQueue->PreviewFileName )) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Failed to delete QueueFileName %s (ec: %ld)"),
                                lpJobQueue->JobId,
                                lpJobQueue->PreviewFileName,
                                GetLastError());                
            }
        }

        if (lpJobQueue->FileName) {
            DebugPrintEx(   DEBUG_MSG,
                            TEXT("[Job: %ld] Deleting per recipient body file %s"),
                            lpJobQueue->JobId,
                            lpJobQueue->FileName);
            if (!DeleteFile( lpJobQueue->FileName )) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Failed to delete per recipient body file %s (ec: %ld)"),
                                lpJobQueue->JobId,
                                lpJobQueue->FileName,
                                GetLastError());                
            }
        }

        SafeDecIdleCounter (&g_dwQueueCount);
        //
        // Now remove the reference to the job from its parent job
        //
        if (!RemoveParentRecipientRef(lpJobQueue->lpParentJob,lpJobQueue))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveParentRecipientRef failed (Parent Id: %ld RecipientId: %ld)"),
                lpJobQueue->lpParentJob->JobId,
                lpJobQueue->JobId);
            Assert(FALSE);
        }

        if ( TRUE == bNotify)
        {
            //
            //  Crete FAX_EVENT_EX for each recipient job.
            //
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_REMOVED,
                                             lpJobToRemove
                                            );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_RENOVED) failed for job id %ld (ec: %lc)"),
                    lpJobToRemove->UniqueId,
                    dwRes);
            }
        }

        FreeRecipientQueueEntry (lpJobQueue, TRUE);
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId :%ld] Reference count is %ld. NOT REMOVING"),
            lpJobQueue->JobId,
            lpJobQueue->RefCount);
        Assert(lpJobQueue->RefCount == 0); // Assert FALSE
    }
    LeaveCriticalSection( &g_CsQueue );
    return TRUE;

}


//*********************************************************************************
//* Name:   RemoveParentRecipientRef()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a reference entry from the list of recipient references
//      in a parent job.
//* PARAMETERS:
//*     [IN/OUT]    IN OUT PJOB_QUEUE lpParentJob
//*         The parent job.
//*     [IN]        IN const PJOB_QUEUE lpcRecpJob
//*         The recipient job whose reference is to be removed from the parent job.
//*
//* RETURN VALUE:
//*     TRUE
//*         If successful.
//*     FALSE
//*         otherwise.
//*********************************************************************************
BOOL RemoveParentRecipientRef(
    IN OUT PJOB_QUEUE lpParentJob,
    IN const PJOB_QUEUE lpcRecpJob
    )
{

    PJOB_QUEUE_PTR lpJobPtr;
    DEBUG_FUNCTION_NAME(TEXT("RemoveParentRecipientRef"));
    Assert(lpParentJob);
    Assert(lpcRecpJob);

    lpJobPtr=FindRecipientRefByJobId(lpParentJob,lpcRecpJob->JobId);
    if (!lpJobPtr) {
        DebugPrintEx(DEBUG_ERR,TEXT("Recipient job 0x%X not found in job 0x%X"),lpcRecpJob->JobId,lpParentJob->JobId);
        Assert(FALSE);
        return FALSE;
    }
    Assert(lpJobPtr->lpJob==lpcRecpJob);
    RemoveEntryList(&lpJobPtr->ListEntry); // does not free the struct memory !
    MemFree(lpJobPtr);
    lpParentJob->dwRecipientJobsCount--;
    return TRUE;
}


//*********************************************************************************
//* Name:   FindRecipientRefByJobId()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Returns a pointer to the refernce entry that holds the reference
//*     to the specified job.
//* PARAMETERS:
//*     [IN]        PJOB_QUEUE lpParentJob
//*         The parent job in which the recipient reference is to located.
//*     [IN]        DWORD dwJobId
//*         The job id of the job whose reference is to be located in the parent.
//*
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_QUEUE_PTR FindRecipientRefByJobId(
    PJOB_QUEUE lpParentJob,
    DWORD dwJobId
    )
{

    PLIST_ENTRY lpNext;
    PJOB_QUEUE_PTR lpJobQueuePtr;
    PJOB_QUEUE_PTR lpFoundRecpRef=NULL;
    Assert(lpParentJob);

    lpNext = lpParentJob->RecipientJobs.Flink;

    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpParentJob) {
        lpJobQueuePtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        Assert(lpJobQueuePtr->lpJob);
        if (lpJobQueuePtr->lpJob->JobId == dwJobId) {
            lpFoundRecpRef=lpJobQueuePtr;
            break;
        }
        lpNext = lpJobQueuePtr->ListEntry.Flink;
    }
    return lpFoundRecpRef;
}



//*********************************************************************************
//* Name:   RemoveReceiveJob()
//* Author: Ronen Barenboim
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a receive job from the queue.
//* PARAMETERS:
//*     [OUT]       PJOB_QUEUE lpJobToRemove
//*         A pointer to the job to remove.
//*     [IN]        BOOL bNotify
//*         TRUE if to generate a FEI_DELETED event after the removal.
//* RETURN VALUE:
//*     TRUE
//*         If successful.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RemoveReceiveJob(
    PJOB_QUEUE lpJobToRemove,
    BOOL bNotify
    )
{
    PJOB_QUEUE JobQueue, JobQueueBroadcast = NULL;
    BOOL RemoveMasterBroadcast = FALSE;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    DWORD JobId;

    DEBUG_FUNCTION_NAME(TEXT("RemoveReceiveJob"));

    Assert(lpJobToRemove);

    EnterCriticalSection( &g_CsQueue );

    //
    // need to make sure that the job queue entry we want to remove
    // is still in the list of job queue entries
    //
    JobQueue = FindJobQueueEntryByJobQueueEntry( lpJobToRemove );

    if (JobQueue == NULL)
    {
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    if (JobQueue->PrevRefCount > 0)
    {
        Assert (JT_ROUTING == JobQueue->JobType);

        JobQueue->JobStatus = JS_DELETING;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }


    JobId = JobQueue->JobId;
    if (JobQueue->RefCount == 0)
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId :%ld] Reference count is zero. Removing Receive Job."),
            JobId);

        RemoveEntryList( &JobQueue->ListEntry );
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer failed. (ec: %ld)"),
                GetLastError());
        }
        if (!StartJobQueueTimer())
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StartJobQueueTimer failed. (ec: %ld)"),
                    GetLastError());
        }

        if (JobQueue->FileName)
        {
            if (TRUE == JobQueue->fDeleteReceivedTiff)
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Deleting receive file %s"),
                    JobQueue->FileName);
                if (!DeleteFile(JobQueue->FileName))
                {
                    DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to delete receive file %s (ec: %ld)"),
                    JobQueue->FileName,
                    GetLastError());                    
                }
            }
            else
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("NOT Deleting received tiff file %s"),
                    JobQueue->FileName);
            }
        }

        if (JT_ROUTING == JobQueue->JobType)
        {
            //
            // Delete the Queue File if it exists
            //
            if (JobQueue->QueueFileName)
            {
                DebugPrintEx(DEBUG_MSG,TEXT("Deleting QueueFileName %s\n"), JobQueue->QueueFileName );
                if (!DeleteFile( JobQueue->QueueFileName ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to delete QueueFileName %s. (ec: %ld)"),
                        JobQueue->QueueFileName,
                        GetLastError());                    
                }
            }

            //
            // Delete the Preview File if it exists
            //
            if (JobQueue->PreviewFileName)
            {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Deleting PreviewFileName %s"),
                                JobQueue->JobId,
                                JobQueue->PreviewFileName );
                if (!DeleteFile( JobQueue->PreviewFileName ))
                {
                    DebugPrintEx(   DEBUG_MSG,
                                    TEXT("[Job: %ld] Failed to delete QueueFileName %s (ec: %ld)"),
                                    JobQueue->JobId,
                                    JobQueue->PreviewFileName,
                                    GetLastError());                    
                }
            }

            //
            // Note that the first entry in the route file list is allways the recieved
            // file in case of a JT_ROUTING job.
            // This file deletion is done previously based on the bRemoveReceiveFile parameter.
            // We need to skip the first entry in the file list so we do not attempt to delete
            // it again.
            //

            DebugPrintEx(DEBUG_MSG, TEXT("Deleting JobQueue.FaxRouteFiles..."));
            Next = JobQueue->FaxRouteFiles.Flink;
            if (Next)
            {
                //
                // Set Next to point to the second file in the route file list.
                //
                Next=Next->Flink;
            }
            if (Next != NULL)
            {
                while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueue->FaxRouteFiles)
                {
                    FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
                    Next = FaxRouteFile->ListEntry.Flink;
                    DebugPrintEx(DEBUG_MSG, TEXT("Deleting route file: %s"),FaxRouteFile->FileName );
                    if (!DeleteFile( FaxRouteFile->FileName )) {
                        DebugPrintEx(DEBUG_ERR, TEXT("Failed to delete route file %s. (ec: %ld)"),FaxRouteFile->FileName,GetLastError());                        
                    }
                }
            }
        }

        //
        //  Crete FAX_EVENT_EX
        //
        if (bNotify)
        {
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_REMOVED,
                                             lpJobToRemove
                                           );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_REMOVED) failed for job id %ld (ec: %lc)"),
                    lpJobToRemove->UniqueId,
                    dwRes);
            }
        }

        //
        // Free memory
        //
        FreeReceiveQueueEntry(JobQueue,TRUE);

        if (bNotify)
        {
            if (!CreateFaxEvent(0, FEI_DELETED, JobId))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateFaxEvent failed. (ec: %ld)"),
                    GetLastError());
            }
        }

        SafeDecIdleCounter (&g_dwQueueCount);
    }
    else
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId :%ld] Reference count is %ld. NOT REMOVING."),
                JobId);
        Assert (JobQueue->RefCount == 0); //Assert(FALSE);
    }
    LeaveCriticalSection( &g_CsQueue );
    return TRUE;
}




//*********************************************************************************
//* Name:   UpdatePersistentJobStatus()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Updated the JobStatus field in a job queue file.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpJobQueue
//*         The job whose job status is to be updated in the file.
//* RETURN VALUE:
//*     TRUE
//*         The operation succeeded/
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL UpdatePersistentJobStatus(const PJOB_QUEUE lpJobQueue)
{
    DEBUG_FUNCTION_NAME(TEXT("UpdatePersistentJobStatus"));

    Assert(lpJobQueue);
    Assert(lpJobQueue->QueueFileName);

    //
    // Persist the new status. 
    // Write the file but do not delete the file on error.
    //
    return CommitQueueEntry(lpJobQueue,FALSE);  
}



//*********************************************************************************
//* Name:   InsertQueueEntryByPriorityAndSchedule()
//* Author: Ronen Barenboim
//* Date:   June 15, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Inserts the new queue entry to the queue list based on jo priority and schedule.
//*     The queue list is ordered by ascending shcedule order.
//*     This function puts the new entry in the right place in the list based
//*     on its priority and schedule.
//* PARAMETERS:
//*     [in ]   PJOB_QUEUE lpJobQueue
//*         Pointer to the job queue entry to insert into the queue list.
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if it failed. Call GetLastError() for extended error information.
//*********************************************************************************
BOOL InsertQueueEntryByPriorityAndSchedule (PJOB_QUEUE lpJobQueue)
{
    LIST_ENTRY * lpNext = NULL;
    DEBUG_FUNCTION_NAME(TEXT("InsertQueueEntryByPriorityAndSchedule"));
    Assert(lpJobQueue &&
		(JT_SEND == lpJobQueue->JobType || JT_ROUTING == lpJobQueue->JobType));

    if ( ((ULONG_PTR) g_QueueListHead.Flink == (ULONG_PTR)&g_QueueListHead))
    {
        //
        // just put it at the head of the list
        //
        InsertHeadList( &g_QueueListHead, &lpJobQueue->ListEntry );
    }
    else
    {
        //
        // insert the queue entry into the list in a sorted order
        //
        QUEUE_SORT NewEntry;

        //
        // Set the new QUEUE_SORT structure
        //
        NewEntry.Priority       = lpJobQueue->JobParamsEx.Priority;
        NewEntry.ScheduleTime   = lpJobQueue->ScheduleTime;
        NewEntry.QueueEntry     = NULL;

        lpNext = g_QueueListHead.Flink;
        while ((ULONG_PTR)lpNext != (ULONG_PTR)&g_QueueListHead)
        {
            PJOB_QUEUE lpQueueEntry;
            QUEUE_SORT CurrEntry;

            lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
            lpNext = lpQueueEntry->ListEntry.Flink;

            //
            // Set the current QUEUE_SORT structure
            //
            CurrEntry.Priority       = lpQueueEntry->JobParamsEx.Priority;
            CurrEntry.ScheduleTime   = lpQueueEntry->ScheduleTime;
            CurrEntry.QueueEntry     = NULL;

            if (QueueCompare(&NewEntry, &CurrEntry) < 0)
            {
                //
                // This inserts the new item BEFORE the current item
                //
                InsertTailList( &lpQueueEntry->ListEntry, &lpJobQueue->ListEntry );
                lpNext = NULL;
                break;
            }
        }
        if ((ULONG_PTR)lpNext == (ULONG_PTR)&g_QueueListHead)
        {
            //
            // No entry with earlier time just put it at the end of the queue
            //
            InsertTailList( &g_QueueListHead, &lpJobQueue->ListEntry );
        }
    }
    return TRUE;
}



//*********************************************************************************
//* Name:   RemoveJobStatusModifiers()
//* Author: Ronen Barenboim
//* Date:   June 22, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the job status after stripping the status modifier bits.
//*
//* PARAMETERS:
//*     [IN ]   DWORD dwJobStatus
//*         The status code to strip the job status modifier bits from.
//* RETURN VALUE:
//*     The job status code after the modifier bits were set to 0.
//*********************************************************************************
DWORD RemoveJobStatusModifiers(DWORD dwJobStatus)
{
    dwJobStatus &= ~(JS_PAUSED | JS_NOLINE);
    return dwJobStatus;
}


BOOL UserOwnsJob(
    IN const PJOB_QUEUE lpcJobQueue,
    IN const PSID lpcUserSid
    )
{
    DWORD ulRet = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("UserOwnsJob"));

    if (lpcJobQueue->JobType == JT_SEND)
    {
        Assert (lpcJobQueue->lpParentJob->UserSid != NULL);
        Assert (lpcUserSid);

        if (!EqualSid (lpcUserSid, lpcJobQueue->lpParentJob->UserSid) )
        {
            //
            // dwlMessageId is not a valid queued recipient job Id.
            //
            DebugPrintEx(DEBUG_WRN,TEXT("EqualSid failed ,Access denied (ec: %ld)"), GetLastError());
            return FALSE;
        }
    }
    else
    {
        Assert (lpcJobQueue->JobType == JT_RECEIVE ||
                lpcJobQueue->JobType == JT_ROUTING );

        return FALSE;
    }
    return TRUE;
}


void
DecreaseJobRefCount (
    PJOB_QUEUE pJobQueue,
    BOOL bNotify,
    BOOL bRemoveRecipientJobs, // Default value TRUE
    BOOL bPreview              // Default value FALSE
    )
/*++

Routine name : DecreaseJobRefCount

Routine description:

    Decreases the job reference count.
    Updates parent job refernce count.
    Removes the job if reference count reaches 0.
    Must be called inside critical section g_CsQueue

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pJobQueue               [in] -  Pointer to the job queue.
    bNotify                 [in] -  Flag that indicates to notify the clients of job removal.
    bRemoveRecipientJobs    [in] -  Flag that indicates to remove all the recipients of a broadcast job.
    bPreview                [in] -  Flag that indicates to decrease preview ref count.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("DecreaseJobRefCount"));

    Assert (pJobQueue->JobType == JT_ROUTING ||
            pJobQueue->JobType == JT_RECEIVE ||
            pJobQueue->JobType == JT_SEND);

    if (TRUE == bPreview)
    {
        Assert (pJobQueue->PrevRefCount);
        pJobQueue->PrevRefCount -= 1;
    }
    else
    {
        Assert (pJobQueue->RefCount);
        pJobQueue->RefCount -= 1;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[Job: %ld] job reference count = %ld, PrevRefCount = %ld."),
        pJobQueue->JobId,
        pJobQueue->RefCount,
        pJobQueue->PrevRefCount);


    if (pJobQueue->JobType == JT_SEND)
    {
        Assert (pJobQueue->lpParentJob);

        if (TRUE == bPreview)
        {
            pJobQueue->lpParentJob->PrevRefCount -= 1;
        }
        else
        {
            pJobQueue->lpParentJob->RefCount -= 1;
        }

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Parent job reference count = %ld, Parent job PrevRefCount = %ld."),
            pJobQueue->lpParentJob->JobId,
            pJobQueue->lpParentJob->RefCount,
            pJobQueue->lpParentJob->PrevRefCount);
    }

    if (0 != pJobQueue->RefCount)
    {
        return;
    }

    //
    // Remove Job queue entry
    //
    if (JT_RECEIVE == pJobQueue->JobType ||
        JT_ROUTING == pJobQueue->JobType)
    {
        // receive job
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Job is ready for deleting."),
            pJobQueue->JobId);
        RemoveReceiveJob (pJobQueue, bNotify);
        return;
    }

    //
    // recipient job
    //
    if (IsSendJobReadyForDeleting(pJobQueue))
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Parent job is ready for deleting."),
            pJobQueue->lpParentJob->JobId);
        RemoveParentJob(pJobQueue->lpParentJob,
            bRemoveRecipientJobs, // Remove recipient jobs
            bNotify // Notify
            );
    }
    return;
} // DecreaseJobRefCount


void
IncreaseJobRefCount (
    PJOB_QUEUE pJobQueue,
    BOOL bPreview              // Default value FALSE
    )
/*++

Routine name : IncreaseJobRefCount

Routine description:

    Increases the job reference count. Updates the parent job refernce count.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pJobQueue           [in] - Pointer to the job queue.
    bPreview            [in] -  Flag that indicates to increase preview ref count.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("IncreaseJobRefCount"));

    Assert (pJobQueue);
    Assert (pJobQueue->JobType == JT_ROUTING ||
            pJobQueue->JobType == JT_RECEIVE ||
            pJobQueue->JobType == JT_SEND);

    if (JT_RECEIVE == pJobQueue->JobType ||
        JT_ROUTING == pJobQueue->JobType)
    {
        // receive job
        if (TRUE == bPreview)
        {
            Assert (JT_ROUTING == pJobQueue->JobType);
            pJobQueue->PrevRefCount += 1;
        }
        else
        {
            pJobQueue->RefCount += 1;
        }
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] job reference count = %ld."),
            pJobQueue->JobId,
            pJobQueue->RefCount);
        return;
    }

    //
    // send job
    //
    Assert (pJobQueue->lpParentJob);

    if (TRUE == bPreview)
    {
        pJobQueue->PrevRefCount += 1;
        pJobQueue->lpParentJob->PrevRefCount += 1;
    }
    else
    {
        pJobQueue->RefCount += 1;
        pJobQueue->lpParentJob->RefCount += 1;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[Job: %ld] job reference count = %ld, PrevRefCount = %ld."),
        pJobQueue->JobId,
        pJobQueue->RefCount,
        pJobQueue->PrevRefCount);

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Parent job reference count = %ld, , Parent job PrevRefCount = %ld."),
            pJobQueue->lpParentJob->JobId,
            pJobQueue->lpParentJob->RefCount,
            pJobQueue->lpParentJob->RefCount);
    return;
} // IncreaseJobRefCount


JOB_QUEUE::~JOB_QUEUE()
{
    if (JT_BROADCAST == JobType)
    {
        return;
    }

    JobStatus = JS_INVALID;
    return;
}

void JOB_QUEUE::PutStatus(DWORD dwStatus)
/*++

Routine name : JOB_QUEUE::PutStatus

Routine description:

    Controls all status changes of a job in queue (JobStatus is a virtual property in JOB_QUEUE)

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    dwStatus            [in] - The new status to be assigened to the job

Return Value:

    None.

--*/
{
    DWORD dwOldStatus = RemoveJobStatusModifiers(m_dwJobStatus);
    DWORD dwNewStatus = RemoveJobStatusModifiers(dwStatus);
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("JOB_QUEUE::PutStatus"));
    m_dwJobStatus = dwStatus;

    if (JT_BROADCAST == JobType)
    {
        return;
    }

    FAX_ENUM_JOB_TYPE__JOB_STATUS OldJobType_JobStatusIndex = GetJobType_JobStatusIndex (JobType, dwOldStatus);
    FAX_ENUM_JOB_TYPE__JOB_STATUS NewJobType_JobStatusIndex = GetJobType_JobStatusIndex (JobType, dwNewStatus);
    WORD wAction = gsc_JobType_JobStatusTable[OldJobType_JobStatusIndex][NewJobType_JobStatusIndex];

    Assert (wAction != INVALID_CHANGE);   
    

    if (wAction == NO_CHANGE)
    {
        return;
    }

    //
    // Update Server Activity counters
    //
    EnterCriticalSection (&g_CsActivity);
    if (wAction & QUEUED_INC)
    {
        Assert (!(wAction & QUEUED_DEC));
        g_ServerActivity.dwQueuedMessages++;
    }

    if (wAction & QUEUED_DEC)
    {
        Assert (g_ServerActivity.dwQueuedMessages);
        Assert (!(wAction & QUEUED_INC));
        g_ServerActivity.dwQueuedMessages--;
    }

    if (wAction & OUTGOING_INC)
    {
        Assert (!(wAction & OUTGOING_DEC));            
        g_ServerActivity.dwOutgoingMessages++;        
    }

    if (wAction & OUTGOING_DEC)
    {
        Assert (!(wAction & OUTGOING_INC));
        
        Assert (g_ServerActivity.dwOutgoingMessages);
        g_ServerActivity.dwOutgoingMessages--;        
    }

    if (wAction & INCOMING_INC)
    {
        Assert (!(wAction & INCOMING_DEC));
        g_ServerActivity.dwIncomingMessages++;
    }

    if (wAction & INCOMING_DEC)
    {
        Assert (g_ServerActivity.dwIncomingMessages);
        Assert (!(wAction & INCOMING_INC));
        g_ServerActivity.dwIncomingMessages--;
    }

    if (wAction & ROUTING_INC)
    {
        Assert (!(wAction & ROUTING_DEC));
        g_ServerActivity.dwRoutingMessages++;
    }

    if (wAction & ROUTING_DEC)
    {
        Assert (g_ServerActivity.dwRoutingMessages);
        Assert (!(wAction & ROUTING_INC));
        g_ServerActivity.dwRoutingMessages--;
    }

    //
    // Create FaxEventEx
    //
    dwRes = CreateActivityEvent ();
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateActivityEvent failed (ec: %lc)"),
            dwRes);
    }
    LeaveCriticalSection (&g_CsActivity);
    return;
}


FAX_ENUM_JOB_TYPE__JOB_STATUS
GetJobType_JobStatusIndex (
    DWORD dwJobType,
    DWORD dwJobStatus
    )
/*++

Routine name : GetJobType_JobStatusIndex

Routine description:

    Returns an Index (Row or Column) in the global JobType_JobStatus table.

Author:

    Oded Sacher (OdedS),    Mar, 2000

Arguments:

    dwJobType           [in ] - JT_SEND, JT_RECEIVE or JT_ROUTING.
    dwJobStatus         [in ] - One of JS_ defines without modifiers.

Return Value:

    Global JobType_JobStatus Table Index

--*/
{
    FAX_ENUM_JOB_TYPE__JOB_STATUS Index = JOB_TYPE__JOBSTATUS_COUNT;

    switch (dwJobStatus)
    {
        case JS_INVALID:
            Index = JT_SEND__JS_INVALID;
            break;
        case JS_PENDING:
            Index = JT_SEND__JS_PENDING;
            break;
        case JS_INPROGRESS:
            Index = JT_SEND__JS_INPROGRESS;
            break;
        case JS_DELETING:
            Index = JT_SEND__JS_DELETING;
            break;
        case JS_RETRYING:
            Index = JT_SEND__JS_RETRYING;
            break;
        case JS_RETRIES_EXCEEDED:
            Index = JT_SEND__JS_RETRIES_EXCEEDED;
            break;
        case JS_COMPLETED:
            Index = JT_SEND__JS_COMPLETED;
            break;
        case JS_CANCELED:
            Index = JT_SEND__JS_CANCELED;
            break;
        case JS_CANCELING:
            Index = JT_SEND__JS_CANCELING;
            break;
        case JS_ROUTING:
            Index = JT_SEND__JS_ROUTING;
            break;
        case JS_FAILED:
            Index = JT_SEND__JS_FAILED;
            break;
        default:
            ASSERT_FALSE;
    }

    switch (dwJobType)
    {
        case JT_SEND:
            break;
        case JT_ROUTING:
            Index =  (FAX_ENUM_JOB_TYPE__JOB_STATUS)((DWORD)Index +(DWORD)JT_ROUTING__JS_INVALID);
            break;
        case JT_RECEIVE:
            Index =  (FAX_ENUM_JOB_TYPE__JOB_STATUS)((DWORD)Index +(DWORD)JT_RECEIVE__JS_INVALID);
            break;
        default:
            ASSERT_FALSE;
    }

    Assert (Index >= 0 && Index <JOB_TYPE__JOBSTATUS_COUNT);

    return Index;
}

static DWORD
GetQueueFileVersion(
    HANDLE  hFile,
    LPDWORD pdwVersion
    )
/*++

Routine name : GetQueueFileVersion

Routine description:
    
    Get the queue file version (first DWORD)

Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:

    hFile       - [in]  -   Queue file handle
    pdwVersion  - [out] -   pointer to DWORD which to hold the queue file version. 

Return Value:

    ERROR_SUCCESS on function succeeded, Win32 Error code otherwise

Note:
    
    You must call this function before any ReadFile(..) on hFile was performed!

    hFile must be valid handle.
    
--*/
{
    DWORD   dwRes = ERROR_SUCCESS;  
    
    DWORD   dwReadSize = 0;
    DWORD   dwPtr = 0;
    
    DWORD   dwVersion;

    DEBUG_FUNCTION_NAME(TEXT("GetQueueFileVersion"));
   
    Assert  (INVALID_HANDLE_VALUE != hFile);
    Assert  (pdwVersion);

    //
    //  Read the file version
    //
    if (!ReadFile(  hFile,
                    &dwVersion, 
                    sizeof(dwVersion), 
                    &dwReadSize, 
                    NULL )) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read file version from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    if (sizeof(dwVersion) != dwReadSize)
	{
		dwRes = ERROR_HANDLE_EOF;
		DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read file version from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Update output parameter
    //
    *pdwVersion =  dwVersion;

    Assert(ERROR_SUCCESS == dwRes);
Exit:
    return dwRes;

}   // GetQueueFileVersion



static DWORD
GetQueueFileHashAndData(   
    HANDLE   hFile,
    LPBYTE*  ppHashData,
    LPDWORD  pHashDataSize,
    LPBYTE*  ppJobData,
    LPDWORD  pJobDataSize
    )
/*++

Routine name : GetQueueFileHashAndData

Routine description:
    
    This function returns the hash code and job data from queue file.
    The function assume that the File is a hashed queue file.

    the file has this format:

                +------------------+----------------+---------------+---------------------------+
                |   Queue Version  | Hash code size | Hash code     |    Job Data               |
                +------------------+----------------+---------------+---------------------------+
Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:
    
    hFile           - [in]  - handle to queue file
    ppHashData      - [out] - hash code data
    pHashDataSize   - [out] - hash code size
    ppJobData       - [out] - job data
    pJobDataSize    - [out] - job data size

Return Value:

    ERROR_SUCCESS on function success, Win32 Error code otherwise
Note:

    Caller must deallocate (*ppHashData) and (*ppJobData) buffers using MemFree.
    
--*/
{
    LPBYTE  pbHashData = NULL;
    DWORD   dwHashDataSize = 0;
    
    LPBYTE  pJobData = NULL;
    DWORD   dwJobDataSize = 0;

    DWORD   dwReadSize = 0;
    DWORD   dwFileSize = 0;
    DWORD   dwPtr = 0;
    
    DWORD   dwRes = ERROR_SUCCESS;
    
    Assert (INVALID_HANDLE_VALUE != hFile);
    Assert (ppHashData);
    Assert (pHashDataSize);
    
    DEBUG_FUNCTION_NAME(TEXT("GetQueueFileHashAndData"));
    
    //
    // Move hFile's file pointer to start of Hash data (skip the version)
    //
    dwPtr = SetFilePointer (hFile, sizeof(DWORD), NULL, FILE_BEGIN) ; 
    if (dwPtr == INVALID_SET_FILE_POINTER) // Test for failure
    { 
        dwRes = GetLastError() ; 
        DebugPrintEx( DEBUG_ERR,
                       TEXT("Failed to SetFilePointer. (ec: %lu)"),
                       dwRes); 
        goto Exit;
    } 

    //
    //  Read hash data size 
    //
    if (!ReadFile(  hFile,
                    &dwHashDataSize, 
                    sizeof(dwHashDataSize), 
                    &dwReadSize, 
                    NULL )) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read hash data size from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }
    
    if (sizeof(dwHashDataSize) != dwReadSize)
	{
		dwRes = ERROR_HANDLE_EOF;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read hash data size from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Allocate memory to hold the hash data
    //
    pbHashData = (LPBYTE)MemAlloc(dwHashDataSize);
    if ( NULL == pbHashData )
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to MemAlloc %lu bytes."),
                      dwHashDataSize);
        goto Exit;
    }

    
    //
    //  Read the hash data
    //
    if (!ReadFile(  hFile,
                    pbHashData, 
                    dwHashDataSize, 
                    &dwReadSize, 
                    NULL )) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read hash data from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    if (dwHashDataSize != dwReadSize)
	{
		dwRes = ERROR_HANDLE_EOF;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read hash data size from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Calculate job data size
    //
    dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize == INVALID_FILE_SIZE)
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to GetFileSize(). (ec: %lu)"),
                      dwRes);
        goto Exit;
    }
        

    dwJobDataSize = dwFileSize                  // total file size
                        - sizeof(DWORD)         // Queue file Version section
                        - sizeof(DWORD)         // Hash size section
                        - dwHashDataSize;       // Hash data section

    Assert(dwJobDataSize >= CURRENT_JOB_QUEUE_FILE_SIZE);
    //
    //  Allocate memory to hold the job data
    //
    pJobData = (LPBYTE)MemAlloc(dwJobDataSize);
    if(NULL == pJobData)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to MemAlloc()."));
        goto Exit;                      
    }

    //
    //  Read the job data
    //
    if (!ReadFile(  hFile,
                    pJobData, 
                    dwJobDataSize, 
                    &dwReadSize, 
                    NULL )) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read job data from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    if (dwJobDataSize != dwReadSize)
    {
        dwRes = ERROR_HANDLE_EOF;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read job data from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Update out parameters
    //
    *ppHashData     = pbHashData;
    *pHashDataSize  = dwHashDataSize;

    *ppJobData      = pJobData;
    *pJobDataSize   = dwJobDataSize;
    
    Assert (ERROR_SUCCESS == dwRes);
Exit:
    
    if (ERROR_SUCCESS != dwRes)
    {
        if (pbHashData)
        {
            MemFree(pbHashData);
        }

        if (pJobData)
        {
            MemFree(pJobData);
        }
    }
    return dwRes;
}   // GetQueueFileHashAndData

static DWORD
ComputeHashCode(   
    const LPBYTE    pbData,
    DWORD           dwDataSize,
    LPBYTE*         ppHashData,
    LPDWORD         pHashDataSize
    )
/*++

Routine name : ComputeHashCode

Routine description:

    Computes a hash code based of MD5 algorithm, for a given data buffer.

Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:

    pbData          - [in]  - Data buffer to be hashed
    dwDataSize      - [in]  - Data buffer size 
    ppHashData      - [out] - Hash code
    pHashDataSize   - [out] - Hash code size

Return Value:

    ERROR_SUCCESS - on success , Win32 Error code otherwise

Note:

    Caller must deallocate (*ppHashData) buffer using MemFree.

--*/
{
    const BYTE*        rgpbToBeHashed[1]={0};     
    DWORD              rgcbToBeHashed[1]={0};

    DWORD   cbHashedBlob;
    BYTE*   pbHashedBlob = NULL;

    DWORD   dwRes = ERROR_SUCCESS;
    BOOL    bRet;

    const 
    CRYPT_HASH_MESSAGE_PARA    QUEUE_HASH_PARAM = { sizeof(CRYPT_HASH_MESSAGE_PARA),            // cbSize
                                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,    // dwMsgEncodingType
                                                    0,                                          // hCryptProv
                                                    {szOID_RSA_MD5,{0,0}},                      // HashAlgorithm {pszObjId,Parameters}
                                                    NULL                                        // pvHashAuxInfo
                                                  };

    Assert(ppHashData && pHashDataSize);
    Assert(pbData  && dwDataSize);


    DEBUG_FUNCTION_NAME(TEXT("ComputeHashCode"));

    //
    //  Set CryptHashMessage input parameters
    //
    rgpbToBeHashed[0] = pbData;
    rgcbToBeHashed[0] = dwDataSize;

    //
    // Calculate the size of the encoded hash.
    //
    bRet=CryptHashMessage(
            const_cast<PCRYPT_HASH_MESSAGE_PARA>(&QUEUE_HASH_PARAM),
            TRUE,
            1,
            rgpbToBeHashed,
            rgcbToBeHashed,
            NULL,
            NULL,
            NULL,
            &cbHashedBlob);
    if(FALSE == bRet)
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to use CryptHashMessage for getting hash code size. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }
    
    //
    // Allocate pbHashedBlob buffer to contain the Hash result
    //
    pbHashedBlob = (LPBYTE)MemAlloc(cbHashedBlob);
    if (NULL == pbHashedBlob)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to MemAlloc() pbHashedBlob buffer."));
        goto Exit;
    }

    //
    // Get hash code 
    //
    bRet=CryptHashMessage(
            const_cast<PCRYPT_HASH_MESSAGE_PARA>(&QUEUE_HASH_PARAM),
            TRUE,
            1,
            rgpbToBeHashed,
            rgcbToBeHashed,
            NULL,
            NULL,
            pbHashedBlob,
            &cbHashedBlob
            );
    if(FALSE == bRet)
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to use CryptHashMessage for getting hash code. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Update out parameters
    //
    *ppHashData = pbHashedBlob;
    *pHashDataSize = cbHashedBlob;

    Assert(ERROR_SUCCESS == dwRes);

Exit:
    if (ERROR_SUCCESS != dwRes && NULL != pbHashedBlob)
    {
        MemFree(pbHashedBlob);
    }
    return dwRes;
}// ComputeHashCode


static DWORD
VerifyHashCode(   
    const LPBYTE    pHashData,
    DWORD           dwHashDataSize,
    const LPBYTE    pbData,
    DWORD           dwDataSize,
    LPBOOL          pbRet
    )
/*++

Routine name : VerifyHashCode

Routine description:

    Verify a hash code for a given data buffer

Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:

    pHashData       - [in] -    data buffer 
    dwHashDataSize  - [in] -    data buffer size
    pbData          - [in] -    hash code to verify
    dwDataSize      - [in] -    hash code size
    pbRet           - [out]-    result of verification. TRUE - hash code verified!

Return Value:

    ERROR_SUCCESS - on success , Win32 Error code otherwise

--*/
{
    DWORD   dwRes = ERROR_SUCCESS;

    LPBYTE       pComputedHashData = NULL;
    DWORD        dwComputedHashDataSize = 0;

    Assert(pHashData && dwHashDataSize);
    Assert(pbData  && dwDataSize);

    DEBUG_FUNCTION_NAME(TEXT("VerifyHashCode"));
    
    //
    //  get hash code for pJobData
    //
    dwRes = ComputeHashCode(   
                pbData,
                dwDataSize,
                &pComputedHashData,
                &dwComputedHashDataSize
            );
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to use ComputeHashCode(). (ec=%lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Verify queue file hash
    //
    *pbRet =    (dwComputedHashDataSize == dwHashDataSize) && 
                0 == memcmp(pHashData,pComputedHashData,dwHashDataSize);

    Assert (ERROR_SUCCESS == dwRes);

Exit:
    if (NULL != pComputedHashData)
    {
        MemFree(pComputedHashData);
    }
    return dwRes;
}// VerifyHashCode



static DWORD
CommitHashedQueueEntry(
    HANDLE          hFile,
    PJOB_QUEUE_FILE pJobQueueFile,
    DWORD           JobQueueFileSize
    )
/*++

Routine name : CommitHashedQueueEntry

Routine description:

    Persist a queue file.
    file will be persisit in this format:

        +-----------------------+----------------+---------------+---------------------------+
        |   Queue File Version  | Hash code size | Hash code     |    Job Data               |
        +-----------------------+----------------+---------------+---------------------------+

Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:
    hFile               -   [in]    - queue file handle
    pJobQueueFile       -   [in]    - job data to persist
    JobQueueFileSize    -   [in]    - job data size

Return Value:

    ERROR_SUCCESS - on success , Win32 Error code otherwise

--*/
{
    DWORD   cbHashedBlob = 0;
    BYTE*   pbHashedBlob = NULL;

    DWORD   dwRes = ERROR_SUCCESS;
    BOOL    bRet = TRUE;
    
    DWORD   dwVersion = CURRENT_QUEUE_FILE_VERSION;
    DWORD   NumberOfBytesWritten;

    Assert (INVALID_HANDLE_VALUE != hFile);
    Assert (pJobQueueFile);

    DEBUG_FUNCTION_NAME(TEXT("CommitHashedQueueEntry"));

    dwRes=ComputeHashCode(
            (const LPBYTE)(pJobQueueFile),
            JobQueueFileSize,
            &pbHashedBlob,
            &cbHashedBlob);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to use ComputeHashCode(). (ec=%ld)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Write Queue file version into file
    //
    bRet=WriteFile( hFile, 
                    &dwVersion, 
                    sizeof(dwVersion), 
                    &NumberOfBytesWritten, 
                    NULL );
    if(FALSE == bRet) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to WriteFile() GUID. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    Assert(sizeof(dwVersion) == NumberOfBytesWritten);

    //
    //  Write HASH code size into file
    //
    bRet=WriteFile( hFile, 
                    &cbHashedBlob, 
                    sizeof(cbHashedBlob), 
                    &NumberOfBytesWritten, 
                    NULL );
    if(FALSE == bRet) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to WriteFile() hash code size. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    Assert(sizeof(cbHashedBlob) == NumberOfBytesWritten);

    //
    //  Write HASH code data into file
    //
    bRet=WriteFile( hFile, 
                    pbHashedBlob, 
                    cbHashedBlob, 
                    &NumberOfBytesWritten, 
                    NULL );
    if(FALSE == bRet) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to WriteFile() hash code data. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    Assert(cbHashedBlob == NumberOfBytesWritten);

    //
    //  Write pJobQueueFile into file
    //
    bRet=WriteFile( hFile, 
                    pJobQueueFile, 
                    JobQueueFileSize, 
                    &NumberOfBytesWritten, 
                    NULL );
    if(FALSE == bRet) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to WriteFile() pJobQueueFile. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    Assert(JobQueueFileSize == NumberOfBytesWritten);

    Assert(ERROR_SUCCESS == dwRes);

Exit:
    if (pbHashedBlob)
    {
        MemFree(pbHashedBlob);
    }
    return dwRes;
} // CommitHashedQueueEntry


static DWORD
ReadHashedJobQueueFile(
    HANDLE  hFile,
    PJOB_QUEUE_FILE* lppJobQueueFile
    )
/*++

Routine name : ReadHashedJobQueueFile

Routine description:

    Read a hashed queue file, and verify it using it's hash code.
    The function will fail with CRYPT_E_HASH_VALUE when the file hash will not verified
     
Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:

    hFile           -   [in]    -   Queue file handle 
    lppJobQueueFile -   [out]   -   buffer to be filled with the extracted data

Return Value:

    ERROR_SUCCESS - on success , Win32 Error code otherwise 

Note:

    Caller must deallocate (*lppJobQueueFile) buffer using MemFree()

--*/
{
    LPBYTE  pHashData=NULL;
    DWORD   dwHashDataSize=0;

    LPBYTE  pJobData=NULL;
    DWORD   dwJobDataSize=0;

    DWORD   dwRes = ERROR_SUCCESS;

    BOOL    bSameHash;

    Assert (INVALID_HANDLE_VALUE != hFile);
    Assert (lppJobQueueFile);

    DEBUG_FUNCTION_NAME(TEXT("ReadHashedJobQueueFile"));

    //
    //  Extract the file's hash
    //
    dwRes=GetQueueFileHashAndData(
            hFile,
            &pHashData,
            &dwHashDataSize,
            &pJobData,
            &dwJobDataSize);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to GetQueueFileHashAndData(). (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Verify hash code of the queue file
    //
    dwRes=VerifyHashCode(
            pHashData,
            dwHashDataSize,
            pJobData,
            dwJobDataSize,
            &bSameHash);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to VerifyHashCode(). (ec: %lu)"),
                      dwRes);
        goto Exit;
    }
    if ( !bSameHash )
    {
        dwRes = CRYPT_E_HASH_VALUE;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Hash verification failed. Probably corrupted queue file"));
        goto Exit;
    }

    //
    //  Update out parameter
    //
    *lppJobQueueFile = (PJOB_QUEUE_FILE)pJobData;

  
    Assert (ERROR_SUCCESS == dwRes);
Exit:
    if(pHashData)
    {
        MemFree(pHashData);
    }
    
    if (ERROR_SUCCESS != dwRes)
    {
        if(pJobData)
        {
            MemFree(pJobData);
        }
    }
    
    return dwRes;
}// ReadHashedJobQueueFile


static DWORD
ReadLegacyJobQueueFile(
    HANDLE              hFile,
    PJOB_QUEUE_FILE*    lppJobQueueFile
    )
/*++

Routine name : ReadLegacyJobQueueFile

Routine description:

    Read a legacy .Net or XP queue file into JOB_QUEUE_FILE structure
     
Author:

    Caliv Nir (t-nicali), Jan, 2002

Arguments:

    hFile           -   [in]    -   Queue file handle 
    lppJobQueueFile -   [out]   -   buffer to be filled with the extracted data

Return Value:

    ERROR_SUCCESS - on success , Win32 Error code otherwise 

Note:

    Caller must deallocate (*lppJobQueueFile) buffer using MemFree()

--*/
{
    DWORD   dwFileSize;    
    DWORD   dwReadSize;
    DWORD   dwPtr;

    DWORD   dwRes = ERROR_SUCCESS;
    
    PJOB_QUEUE_FILE lpJobQueueFile=NULL;

    Assert (INVALID_HANDLE_VALUE != hFile);
    Assert (lppJobQueueFile);

    DEBUG_FUNCTION_NAME(TEXT("ReadLegacyJobQueueFile"));

    //
    // Move hFile's file pointer to back start of file
    //
    dwPtr = SetFilePointer (hFile, 0, NULL, FILE_BEGIN) ; 
    if (dwPtr == INVALID_SET_FILE_POINTER) // Test for failure
    { 
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                       TEXT("Failed to SetFilePointer. (ec: %lu)"),
                       dwRes); 
        goto Exit;
    } 

    //
    // See if we did not stumble on some funky file which is smaller than the
    // minimum file size.
    //
    dwFileSize = GetFileSize( hFile, NULL );
    if (dwFileSize < NET_XP_JOB_QUEUE_FILE_SIZE ) {
       DebugPrintEx( DEBUG_WRN,
                      TEXT("Job file size is %ld which is smaller than NET_XP_JOB_QUEUE_FILE_SIZE.Deleting file."),
                      dwFileSize);
       dwRes = ERROR_FILE_CORRUPT;
       goto Exit;
    }

    //
    //  allocate buffer for holding the Job data
    //
    lpJobQueueFile = (PJOB_QUEUE_FILE) MemAlloc( dwFileSize );
    if (!lpJobQueueFile) {
        DebugPrintEx( DEBUG_ERR,
                    TEXT("Failed to allocate JOB_QUEUE_FILE (%lu bytes)."),
                    dwFileSize);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    //  Read the job data from the file
    //
    if (!ReadFile(  hFile,
                    lpJobQueueFile, 
                    dwFileSize, 
                    &dwReadSize, 
                    NULL )) 
    {
        dwRes = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read job data from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }
    
    if (dwFileSize != dwReadSize)
    {
        dwRes = ERROR_HANDLE_EOF;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read job data from queue file. (ec: %lu)"),
                      dwRes);
        goto Exit;
    }

    //
    //  Update out parameter
    //
    *lppJobQueueFile = lpJobQueueFile;

    Assert(ERROR_SUCCESS == dwRes);
Exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if(lpJobQueueFile)
        {
            MemFree(lpJobQueueFile);
        }
    }
    return dwRes;
}   //ReadLegacyJobQueueFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\htmltags.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    htmltags.h

Abstract:

    This file contain HTML tags used to create the HTML body of the receipt message

Author:

    Ishai Nadler  September, 2001

Revision History:

--*/

#define	HTML_START						TEXT("<HTML>")
#define	HTML_END						TEXT("</HTML>")
#define HTML_HEAD_START					TEXT("<HEAD>")
#define HTML_HEAD_END					TEXT("</HEAD>")
#define HTML_META						TEXT("<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=utf-8\">")
#define HTML_TITLE_START				TEXT("<TITLE>")
#define HTML_TITLE_END					TEXT("</TITLE>")
#define	HTML_BODY_START					TEXT("<BODY>")
#define	HTML_BODY_END					TEXT("</BODY>")
#define	HTML_PARAGRAPH_START			TEXT("<P>")
#define	HTML_PARAGRAPH_END				TEXT("</P>")
#define	HTML_NEW_LINE					TEXT("<BR>")
#define	HTML_TABLE_START				TEXT("<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>")
#define	HTML_TABLE_END					TEXT("</TABLE>")
#define	HTML_TABLE_RAW_START			TEXT("<TR>")
#define	HTML_TABLE_RAW_END				TEXT("</TR>")
#define	HTML_TABLE_HEADER_START			TEXT("<TH>")
#define	HTML_TABLE_HEADER_END			TEXT("</TH>")
#define	HTML_TABLE_DATA_START			TEXT("<TD>")
#define	HTML_TABLE_DATA_END				TEXT("</TD>")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\route.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    route.c

Abstract:

    This module implements the inbound routing rules.

Author:

    Wesley Witt (wesw) 1-Apr-1997

Revision History:

--*/

#include "faxsvc.h"
#include "tiff.h"
#pragma hdrstop

#include "..\faxroute\FaxRouteP.h"


extern DWORD FaxPrinters;

LIST_ENTRY g_lstRoutingExtensions;
LIST_ENTRY g_lstRoutingMethods;
DWORD g_dwCountRoutingMethods;
CFaxCriticalSection g_CsRouting;

LONG WINAPI
FaxRouteAddFile(
    IN DWORD JobId,
    IN LPCWSTR FileName,
    IN GUID *Guid
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR fnp;
    DWORD Count;
    WCHAR RouteGuid[MAX_GUID_STRING_LEN];

    StringFromGUID2( *Guid, RouteGuid, MAX_GUID_STRING_LEN );

    if (!JobId || !Guid || !FileName) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    if ((!IsEqualGUID(*Guid,gc_FaxSvcGuid)) && (!FindRoutingMethodByGuid(RouteGuid))) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    if (!GetFullPathName( FileName, sizeof(FullPathName)/sizeof(WCHAR), FullPathName, &fnp )) {
        return -1;
    }

    FaxRouteFile = (PFAX_ROUTE_FILE) MemAlloc( sizeof(FAX_ROUTE_FILE) );
    if (!FaxRouteFile) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return -1;
    }

    FaxRouteFile->FileName = StringDup( FullPathName );

    CopyMemory( &FaxRouteFile->Guid, Guid, sizeof(GUID) );

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    InsertTailList( &JobQueueEntry->FaxRouteFiles, &FaxRouteFile->ListEntry );

    LeaveCriticalSection( &JobQueueEntry->CsFileList );

    //
    // increment file count
    //
    EnterCriticalSection( &g_CsJob );
        EnterCriticalSection( &g_CsQueue );
            JobQueueEntry->CountFaxRouteFiles += 1;
            Count = JobQueueEntry->CountFaxRouteFiles;
        LeaveCriticalSection( &g_CsQueue );
    LeaveCriticalSection( &g_CsJob );



    return Count;
}


LONG WINAPI
FaxRouteDeleteFile(
    IN DWORD JobId,
    IN LPCWSTR FileName
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    LONG Index = 1;

    if (!FileName) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return -1;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (_wcsicmp( FileName, FaxRouteFile->FileName ) == 0) {
            //
            // the initial file is read-only for all extensions
            //
            if (Index == 1) {
                SetLastError( ERROR_INVALID_DATA );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return -1;
            }

            //
            // remove from list, delete the file, cleanup memory
            //
            RemoveEntryList( &FaxRouteFile->ListEntry );
            DeleteFile( FaxRouteFile->FileName );
            MemFree ( FaxRouteFile->FileName ) ;
            MemFree ( FaxRouteFile );

            //
            // decrement file count
            //
            LeaveCriticalSection( &JobQueueEntry->CsFileList );
            EnterCriticalSection( &g_CsJob );
                EnterCriticalSection( &g_CsQueue );
                    JobQueueEntry->CountFaxRouteFiles -= 1;
                LeaveCriticalSection( &g_CsQueue );
            LeaveCriticalSection( &g_CsJob );

            return Index;
        }
        Index += 1;
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );
    SetLastError( ERROR_FILE_NOT_FOUND );
    return -1;

}


BOOL WINAPI
FaxRouteGetFile(
    IN DWORD JobId,
    IN DWORD FileNumber,
    OUT LPWSTR FileNameBuffer,
    OUT LPDWORD RequiredSize
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    ULONG Index = 1;

    if (RequiredSize == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    if (JobQueueEntry->CountFaxRouteFiles < Index) {
        SetLastError( ERROR_INVALID_DATA );
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    //
    // make sure list isn't empty
    //
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return FALSE;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (Index ==  FileNumber) {
            if (*RequiredSize < (wcslen(FaxRouteFile->FileName)+1)*sizeof(WCHAR)) {
                if (FileNameBuffer == NULL) {
                    *RequiredSize = (wcslen(FaxRouteFile->FileName) + 1)*sizeof(WCHAR);
                }
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return FALSE;
            } else if (FileNameBuffer) {
                wcscpy( FileNameBuffer, FaxRouteFile->FileName );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return TRUE;
            } else {
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                SetLastError( ERROR_INVALID_PARAMETER );
                return TRUE;
            }
        }
        Index += 1;
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );
    SetLastError( ERROR_NO_MORE_FILES );

    return FALSE;
}


BOOL WINAPI
FaxRouteEnumFiles(
    IN DWORD JobId,
    IN GUID *Guid,
    IN PFAXROUTEENUMFILE FileEnumerator,
    IN PVOID Context
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;

    if (!FileEnumerator) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return FALSE;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (!FileEnumerator( JobId, &FaxRouteFile->Guid, Guid, FaxRouteFile->FileName, Context )) {
            LeaveCriticalSection( &JobQueueEntry->CsFileList );
            return FALSE;
        }
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );

    SetLastError( ERROR_NO_MORE_FILES );
    return TRUE;
}


PROUTING_METHOD
FindRoutingMethodByGuid(
    IN LPCWSTR RoutingGuidString
    )
{
    PLIST_ENTRY         pNextMethod;
    PROUTING_METHOD     pRoutingMethod;
    GUID                RoutingGuid;


    IIDFromString( (LPWSTR)RoutingGuidString, &RoutingGuid );

    EnterCriticalSection( &g_CsRouting );

    pNextMethod = g_lstRoutingMethods.Flink;
    if (pNextMethod == NULL)
    {
        LeaveCriticalSection( &g_CsRouting );
        return NULL;
    }

    while ((ULONG_PTR)pNextMethod != (ULONG_PTR)&g_lstRoutingMethods) {
        pRoutingMethod = CONTAINING_RECORD( pNextMethod, ROUTING_METHOD, ListEntryMethod );
        pNextMethod = pRoutingMethod->ListEntryMethod.Flink;
        if (IsEqualGUID( RoutingGuid, pRoutingMethod->Guid ))
        {
            LeaveCriticalSection( &g_CsRouting );
            return pRoutingMethod;
        }
    }

    LeaveCriticalSection( &g_CsRouting );
    return NULL;
}


DWORD
EnumerateRoutingMethods(
    IN PFAXROUTEMETHODENUM Enumerator,
    IN LPVOID Context
    )
{
    PLIST_ENTRY         pNextMethod;
    PROUTING_METHOD     pRoutingMethod;
    DWORD               dwCount = 0;

    EnterCriticalSection( &g_CsRouting );

    pNextMethod = g_lstRoutingMethods.Flink;
    Assert(pNextMethod != NULL);

    while ((ULONG_PTR)pNextMethod != (ULONG_PTR)&g_lstRoutingMethods)
    {
        pRoutingMethod = CONTAINING_RECORD( pNextMethod, ROUTING_METHOD, ListEntryMethod );
        pNextMethod = pRoutingMethod->ListEntryMethod.Flink;
        if (!Enumerator( pRoutingMethod, Context ))
        {
            LeaveCriticalSection( &g_CsRouting );
            SetLastError(ERROR_INVALID_FUNCTION);
            return dwCount;
        }
        dwCount += 1;
    }
    LeaveCriticalSection(&g_CsRouting);
    SetLastError(ERROR_SUCCESS);
    return dwCount;
}


BOOL
FaxRouteModifyRoutingData(
    DWORD JobId,
    LPCWSTR RoutingGuid,
    LPBYTE RoutingData,
    DWORD RoutingDataSize
    )
{
    PJOB_QUEUE JobQueueEntry = NULL;
    PROUTING_METHOD RoutingMethod = NULL;
    PROUTING_DATA_OVERRIDE RoutingDataOverride = NULL;


    if (JobId == 0 || RoutingGuid == NULL || RoutingData == NULL || RoutingDataSize == 0) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuid );
    if (RoutingMethod == NULL) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    RoutingDataOverride = (PROUTING_DATA_OVERRIDE) MemAlloc( sizeof(ROUTING_DATA_OVERRIDE) );
    if (RoutingDataOverride == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RoutingDataOverride->RoutingData = (LPBYTE)MemAlloc( RoutingDataSize );
    if (RoutingDataOverride->RoutingData == NULL) {
        MemFree( RoutingDataOverride );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RoutingDataOverride->RoutingDataSize = RoutingDataSize;
    RoutingDataOverride->RoutingMethod = RoutingMethod;

    CopyMemory( RoutingDataOverride->RoutingData, RoutingData, RoutingDataSize );

    EnterCriticalSection( &JobQueueEntry->CsRoutingDataOverride );
    InsertTailList( &JobQueueEntry->RoutingDataOverride, &RoutingDataOverride->ListEntry );
    LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

    return TRUE;
}


int
__cdecl
MethodPriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PMETHOD_SORT)arg1)->Priority < ((PMETHOD_SORT)arg2)->Priority) {
        return -1;
    }
    if (((PMETHOD_SORT)arg1)->Priority > ((PMETHOD_SORT)arg2)->Priority) {
        return 1;
    }
    return 0;
}


BOOL
SortMethodPriorities(
    VOID
    )
{
    PLIST_ENTRY pNext;
    PROUTING_METHOD pRoutingMethod;
    PMETHOD_SORT pMethodSort;
    DWORD i;

    EnterCriticalSection( &g_CsRouting );

    pNext = g_lstRoutingMethods.Flink;
    if (pNext == NULL)
    {
        LeaveCriticalSection( &g_CsRouting );
        return FALSE;
    }

    pMethodSort = (PMETHOD_SORT) MemAlloc( g_dwCountRoutingMethods * sizeof(METHOD_SORT) );
    if (pMethodSort == NULL)
    {
        LeaveCriticalSection( &g_CsRouting );
        return FALSE;
    }

    i = 0;

    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_lstRoutingMethods)
    {
        pRoutingMethod = CONTAINING_RECORD( pNext, ROUTING_METHOD, ListEntryMethod );
        pNext = pRoutingMethod->ListEntryMethod.Flink;
        pMethodSort[i].Priority = pRoutingMethod->Priority;
        pMethodSort[i].RoutingMethod = pRoutingMethod;
        i += 1;
    }

    qsort(
        (PVOID)pMethodSort,
        (int)g_dwCountRoutingMethods,
        sizeof(METHOD_SORT),
        MethodPriorityCompare
        );

    InitializeListHead( &g_lstRoutingMethods );

    for (i=0; i<g_dwCountRoutingMethods; i++)
    {
        pMethodSort[i].RoutingMethod->Priority = i + 1;
        pMethodSort[i].RoutingMethod->ListEntryMethod.Flink = NULL;
        pMethodSort[i].RoutingMethod->ListEntryMethod.Blink = NULL;
        InsertTailList( &g_lstRoutingMethods, &pMethodSort[i].RoutingMethod->ListEntryMethod );
    }

    MemFree( pMethodSort );

    LeaveCriticalSection( &g_CsRouting );

    return TRUE;
}

BOOL
CommitMethodChanges(
    VOID
    )
/*++

Routine Description:

    sticks changes to routing into the registry

Arguments:

    NONE

Return Value:

    TRUE for success

--*/
{
    PLIST_ENTRY pNext;
    PROUTING_METHOD pRoutingMethod;
    TCHAR StrGuid[100];

    EnterCriticalSection(&g_CsRouting);

    pNext = g_lstRoutingMethods.Flink;

    while ((UINT_PTR)pNext != (UINT_PTR)&g_lstRoutingMethods)
    {
        pRoutingMethod = CONTAINING_RECORD( pNext, ROUTING_METHOD , ListEntryMethod );
        pNext = pRoutingMethod->ListEntryMethod.Flink;

        StringFromGUID2( pRoutingMethod->Guid,
                            StrGuid,
                            sizeof(StrGuid)/sizeof(TCHAR)
                        );

        SetFaxRoutingInfo( pRoutingMethod->RoutingExtension->InternalName,
                            pRoutingMethod->InternalName,
                            StrGuid,
                            pRoutingMethod->Priority,
                            pRoutingMethod->FunctionName,
                            pRoutingMethod->FriendlyName
                        );
    }

    LeaveCriticalSection(&g_CsRouting); 
    
    return TRUE;
}

static
void
FreeRoutingMethod(
    PROUTING_METHOD pRoutingMethod
    )
{
    Assert (pRoutingMethod);

    MemFree(pRoutingMethod->FriendlyName);
    MemFree(pRoutingMethod->FunctionName);
    MemFree(pRoutingMethod->InternalName);
    MemFree(pRoutingMethod);
    return;
}

static
void
FreeRoutingExtension(
    PROUTING_EXTENSION  pRoutingExtension
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FreeRoutingExtension"));

    Assert (pRoutingExtension);

    if (pRoutingExtension->hModule)
    {
        FreeLibrary (pRoutingExtension->hModule);
    }

    if (pRoutingExtension->HeapHandle &&
        FALSE == pRoutingExtension->MicrosoftExtension)
    {
        HeapDestroy(pRoutingExtension->HeapHandle);
    }

    MemFree(pRoutingExtension);
    return;
}

void
FreeRoutingExtensions(
    void
    )
{
    PLIST_ENTRY         pNext;
    PROUTING_EXTENSION  pRoutingExtension;
    PROUTING_METHOD  pRoutingMethod;

    //
    // Free routing methods
    //
    pNext = g_lstRoutingMethods.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_lstRoutingMethods)
    {
        pRoutingMethod = CONTAINING_RECORD( pNext, ROUTING_METHOD, ListEntryMethod );
        pNext = pRoutingMethod->ListEntryMethod.Flink;
        RemoveEntryList(&pRoutingMethod->ListEntryMethod);
        FreeRoutingMethod(pRoutingMethod);
    }

    //
    // Free routing extensions
    //
    pNext = g_lstRoutingExtensions.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_lstRoutingExtensions)
    {
        pRoutingExtension = CONTAINING_RECORD( pNext, ROUTING_EXTENSION, ListEntry );
        pNext = pRoutingExtension->ListEntry.Flink;
        RemoveEntryList(&pRoutingExtension->ListEntry);
        FreeRoutingExtension(pRoutingExtension);
    }
    return;
}

BOOL
InitializeRouting(
    PREG_FAX_SERVICE pFaxReg
    )

/*++

Routine Description:

    Initializes routing

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    DWORD i,j;
    DWORD dwRes;
    BOOL bRes;
    PROUTING_EXTENSION pRoutingExtension;
    PROUTING_METHOD pRoutingMethod;
    FAX_ROUTE_CALLBACKROUTINES Callbacks;
    FAX_ROUTE_CALLBACKROUTINES_P Callbacks_private;
    HRESULT hr = NOERROR;
    PLIST_ENTRY ple;
    DEBUG_FUNCTION_NAME(TEXT("InitializeRouting"));

    Assert (wcslen (g_wszFaxQueueDir));

    Callbacks.SizeOfStruct              = sizeof(FAX_ROUTE_CALLBACKROUTINES);
    Callbacks.FaxRouteAddFile           = FaxRouteAddFile;
    Callbacks.FaxRouteDeleteFile        = FaxRouteDeleteFile;
    Callbacks.FaxRouteGetFile           = FaxRouteGetFile;
    Callbacks.FaxRouteEnumFiles         = FaxRouteEnumFiles;
    Callbacks.FaxRouteModifyRoutingData = FaxRouteModifyRoutingData;

    Callbacks_private.SizeOfStruct              = sizeof(FAX_ROUTE_CALLBACKROUTINES_P);
    Callbacks_private.FaxRouteAddFile           = FaxRouteAddFile;
    Callbacks_private.FaxRouteDeleteFile        = FaxRouteDeleteFile;
    Callbacks_private.FaxRouteGetFile           = FaxRouteGetFile;
    Callbacks_private.FaxRouteEnumFiles         = FaxRouteEnumFiles;
    Callbacks_private.FaxRouteModifyRoutingData = FaxRouteModifyRoutingData;
    Callbacks_private.GetRecieptsConfiguration  = GetRecieptsConfiguration;
    Callbacks_private.FreeRecieptsConfiguration = FreeRecieptsConfiguration;
    Callbacks_private.lptstrFaxQueueDir         = g_wszFaxQueueDir;

    for (i = 0; i < pFaxReg->RoutingExtensionsCount; i++)
    {
        HMODULE hModule = NULL;
        WCHAR wszImageFileName[_MAX_FNAME] = {0};
        WCHAR wszImageFileExt[_MAX_EXT] = {0};

        pRoutingExtension = (PROUTING_EXTENSION) MemAlloc( sizeof(ROUTING_EXTENSION) );
        if (!pRoutingExtension)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Could not allocate memory for routing extension %s"),
                pFaxReg->RoutingExtensions[i].ImageName );
            goto InitializationFailed;
        }
        memset(pRoutingExtension, 0, sizeof(ROUTING_EXTENSION));
        InitializeListHead( &pRoutingExtension->RoutingMethods );
        //
        // Copy registry constant info
        //
        wcsncpy( pRoutingExtension->FriendlyName,
                 pFaxReg->RoutingExtensions[i].FriendlyName ?
                    pFaxReg->RoutingExtensions[i].FriendlyName : EMPTY_STRING ,
                 sizeof (pRoutingExtension->FriendlyName) / sizeof (TCHAR) );
        pRoutingExtension->FriendlyName[(sizeof (pRoutingExtension->FriendlyName) / sizeof (TCHAR)) - 1] = TEXT('\0');
        wcsncpy( pRoutingExtension->ImageName,
                 pFaxReg->RoutingExtensions[i].ImageName ?
                    pFaxReg->RoutingExtensions[i].ImageName : EMPTY_STRING,
                 sizeof (pRoutingExtension->ImageName) / sizeof (TCHAR) );
        pRoutingExtension->ImageName[(sizeof (pRoutingExtension->ImageName) / sizeof (TCHAR)) - 1] = TEXT('\0');
        wcsncpy( pRoutingExtension->InternalName,
                 pFaxReg->RoutingExtensions[i].InternalName ?
                    pFaxReg->RoutingExtensions[i].InternalName : EMPTY_STRING,
                 sizeof (pRoutingExtension->InternalName) / sizeof (TCHAR) );
        pRoutingExtension->InternalName[(sizeof (pRoutingExtension->InternalName) / sizeof (TCHAR)) - 1] = TEXT('\0');

        _wsplitpath( pRoutingExtension->ImageName, NULL, NULL, wszImageFileName, wszImageFileExt );
        if (_wcsicmp( wszImageFileName, FAX_ROUTE_MODULE_NAME ) == 0 &&
            _wcsicmp( wszImageFileExt, TEXT(".DLL") ) == 0)
        {
            pRoutingExtension->MicrosoftExtension = TRUE;
        }

        hModule = LoadLibrary( pFaxReg->RoutingExtensions[i].ImageName );
        if (!hModule)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("LoadLibrary() failed: [%s], ec=%d"),
                    pFaxReg->RoutingExtensions[i].ImageName,
                    dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LOAD;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        pRoutingExtension->hModule = hModule;
        //
        // Retrieve the routing extension's version from the DLL
        //
        pRoutingExtension->Version.dwSizeOfStruct = sizeof (FAX_VERSION);
        dwRes = GetFileVersion ( pFaxReg->RoutingExtensions[i].ImageName,
                                 &pRoutingExtension->Version);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // If the routing extension's DLL does not have version data or the
            // version data is non-retrievable, we consider this a
            // warning (debug print) but carry on with the DLL's load.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFileVersion() failed: [%s] (ec: %ld)"),
                pFaxReg->RoutingExtensions[i].ImageName,
                dwRes);
        }

        pRoutingExtension->FaxRouteInitialize = (PFAXROUTEINITIALIZE) GetProcAddress(
            hModule,
            "FaxRouteInitialize"
            );

        pRoutingExtension->FaxRouteGetRoutingInfo = (PFAXROUTEGETROUTINGINFO) GetProcAddress(
            hModule,
            "FaxRouteGetRoutingInfo"
            );

        pRoutingExtension->FaxRouteSetRoutingInfo = (PFAXROUTESETROUTINGINFO) GetProcAddress(
            hModule,
            "FaxRouteSetRoutingInfo"
            );

        pRoutingExtension->FaxRouteDeviceEnable = (PFAXROUTEDEVICEENABLE) GetProcAddress(
            hModule,
            "FaxRouteDeviceEnable"
            );

        pRoutingExtension->FaxRouteDeviceChangeNotification = (PFAXROUTEDEVICECHANGENOTIFICATION) GetProcAddress(
            hModule,
            "FaxRouteDeviceChangeNotification"
            );

        if (pRoutingExtension->FaxRouteInitialize == NULL ||
            pRoutingExtension->FaxRouteGetRoutingInfo == NULL ||
            pRoutingExtension->FaxRouteSetRoutingInfo == NULL ||
            pRoutingExtension->FaxRouteDeviceChangeNotification == NULL ||
            pRoutingExtension->FaxRouteDeviceEnable == NULL)
        {
            //
            // the routing extension dll does not have a complete export list
            //
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Routing extension FAILED to initialized [%s], ec=%ld"),
                pFaxReg->RoutingExtensions[i].FriendlyName,
                dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LINK;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        //
        // Link to the extension configuration and notification init functions
        //
        pRoutingExtension->pFaxExtInitializeConfig = (PFAX_EXT_INITIALIZE_CONFIG) GetProcAddress(
            hModule,
            "FaxExtInitializeConfig"
            );
        if (!pRoutingExtension->pFaxExtInitializeConfig)
        {
            //
            // Optional function
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("FaxExtInitializeConfig() not found for routing extension %s. This is not an error."),
                pRoutingExtension->FriendlyName);
        }
        //
        // create the routing extension's heap and add it to the list
        //
        pRoutingExtension->HeapHandle = pRoutingExtension->MicrosoftExtension ?
                                            GetProcessHeap() : HeapCreate( 0, 1024*100, 1024*1024*2 );
        if (!pRoutingExtension->HeapHandle)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't create heap, ec=%ld"),
                dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        //
        // We 1st call the RoutingExtension->pFaxExtInitializeConfig function (if exported)
        //
        if (pRoutingExtension->pFaxExtInitializeConfig)
        {
            __try
            {

                hr = pRoutingExtension->pFaxExtInitializeConfig(
                    FaxExtGetData,
                    FaxExtSetData,
                    FaxExtRegisterForEvents,
                    FaxExtUnregisterForEvents,
                    FaxExtFreeBuffer);
            }
            __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, pRoutingExtension->FriendlyName, GetExceptionCode()))
            {
                ASSERT_FALSE;
            }
            if (FAILED(hr))
            {
                //
                // Failed to init ext. config.
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxExtInitializeConfig() failed (hr = 0x%08x) for extension [%s]"),
                    hr,
                    pRoutingExtension->FriendlyName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_INIT;
                pRoutingExtension->dwLastError = hr;
                goto InitializationFailed;
            }
        }
        //
        // Next, call the initialization routing of the routing ext.
        //
        __try
        {
            if (pRoutingExtension->MicrosoftExtension)
            {
                //
                // Special hack - for the MS routing extension, pass the extra private structure which
                // contains a pointer to the service's g_CsConfig.
                //
                bRes = pRoutingExtension->FaxRouteInitialize( pRoutingExtension->HeapHandle, (PFAX_ROUTE_CALLBACKROUTINES)(&Callbacks_private) );
            }
            else
            {
                bRes = pRoutingExtension->FaxRouteInitialize( pRoutingExtension->HeapHandle, &Callbacks );
            }
        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, pRoutingExtension->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }
        if (!bRes)
        {
            //
            // Either init faulted or failed
            //
            dwRes = GetLastError ();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxRouteInitialize() failed / faulted: ec=%ld"),
                         dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_INIT;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        //
        // All initialization succeeded - proceed with routing methods.
        //
        for (j = 0; j < pFaxReg->RoutingExtensions[i].RoutingMethodsCount; j++)
        {
            LPSTR lpstrProcName = NULL;

            //
            // Send mail is not supported on desktop SKUs
            //
            if (0 == _wcsicmp(pFaxReg->RoutingExtensions[i].RoutingMethods[j].Guid, REGVAL_RM_EMAIL_GUID) &&
                TRUE == IsDesktopSKU())
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Email is not supported on desktop SKU."));
                continue;
            }

            pRoutingMethod = (PROUTING_METHOD) MemAlloc( sizeof(ROUTING_METHOD) );
            if (!pRoutingMethod)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not allocate memory for routing method %s"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName);
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto InitializationFailed;
            }
            memset (pRoutingMethod, 0, sizeof (ROUTING_METHOD));

            pRoutingMethod->RoutingExtension = pRoutingExtension;

            pRoutingMethod->Priority = pFaxReg->RoutingExtensions[i].RoutingMethods[j].Priority;
            pRoutingMethod->FriendlyName =
                StringDup( pFaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName ?
                               pFaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName : EMPTY_STRING );
            if (!pRoutingMethod->FriendlyName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing function name [%s]"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName);
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            pRoutingMethod->FunctionName =
                StringDup( pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName ?
                               pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName : EMPTY_STRING);
            if (!pRoutingMethod->FunctionName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing function name [%s]"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            pRoutingMethod->InternalName =
                StringDup( pFaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName ?
                               pFaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName : EMPTY_STRING);
            if (!pRoutingMethod->InternalName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing internal name [%s]"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            hr = IIDFromString( pFaxReg->RoutingExtensions[i].RoutingMethods[j].Guid, &pRoutingMethod->Guid );
            if (S_OK != hr)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Invalid GUID string [%s], hr = 0x%x"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].Guid,
                    hr );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_BAD_GUID;
                pRoutingExtension->dwLastError = hr;
                goto MethodError;
            }

            lpstrProcName = UnicodeStringToAnsiString( pRoutingMethod->FunctionName );
            if (!lpstrProcName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing function name [%s]"),
                    pRoutingMethod->FunctionName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            pRoutingMethod->FaxRouteMethod = (PFAXROUTEMETHOD) GetProcAddress(
                hModule,
                lpstrProcName
                );
            if (!pRoutingMethod->FaxRouteMethod)
            {
                dwRes = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("Could not get function address [%S], ec=%ld"),
                             lpstrProcName,
                             dwRes
                            );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LINK;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }
            MemFree( lpstrProcName );
            goto MethodOk;

MethodError:
            MemFree( pRoutingMethod->FriendlyName );
            MemFree( pRoutingMethod->FunctionName );
            MemFree( pRoutingMethod->InternalName );
            MemFree( pRoutingMethod );
            MemFree( lpstrProcName );
            goto InitializationFailed;

MethodOk:
            //
            // Success - add this routing method to the routing extension's list of methods
            //
            InsertTailList( &pRoutingExtension->RoutingMethods, &pRoutingMethod->ListEntry );
        }   // Loop of extension's routing methods
        //
        // Success while loading and initializing this extension
        //
        pRoutingExtension->Status = FAX_PROVIDER_STATUS_SUCCESS;
        pRoutingExtension->dwLastError = ERROR_SUCCESS;
        //
        // All methods successfully initialized.
        // Add all methods to global list of methods (and increase global counter)
        //
        ple = pRoutingExtension->RoutingMethods.Flink;
        while ((ULONG_PTR)ple != (ULONG_PTR)&pRoutingExtension->RoutingMethods)
        {
            pRoutingMethod = CONTAINING_RECORD( ple, ROUTING_METHOD, ListEntry );
            ple = ple->Flink;
            InsertTailList( &g_lstRoutingMethods, &pRoutingMethod->ListEntryMethod );
            g_dwCountRoutingMethods++;
        }
        goto next;

InitializationFailed:
        {           
            FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    4,
                    MSG_ROUTE_INIT_FAILED,
                    pFaxReg->RoutingExtensions[i].FriendlyName,
                    pFaxReg->RoutingExtensions[i].ImageName,
                    pRoutingExtension ? DWORD2DECIMAL(pRoutingExtension->Status) : NULL,
                    pRoutingExtension ? DWORD2DECIMAL(pRoutingExtension->dwLastError) : DWORD2DECIMAL(ERROR_OUTOFMEMORY)
                    );
        }

        if (pRoutingExtension)
        {
            if (pRoutingExtension->hModule)
            {
                FreeLibrary (pRoutingExtension->hModule);
                pRoutingExtension->hModule = NULL;
            }
            //
            // If we created a heap for the routing extension, destroy it
            //
            if ((pRoutingExtension->HeapHandle) &&
                (FALSE == pRoutingExtension->MicrosoftExtension))
            {
                HeapDestroy (pRoutingExtension->HeapHandle);
                pRoutingExtension->HeapHandle = NULL;
            }
            //
            // Clear the list of routing methods and free method structures.
            //
            ple = pRoutingExtension->RoutingMethods.Flink;
            while ((ULONG_PTR)ple != (ULONG_PTR)&pRoutingExtension->RoutingMethods)
            {
                pRoutingMethod = CONTAINING_RECORD(ple, ROUTING_METHOD, ListEntry);
                ple = ple->Flink;
                MemFree( pRoutingMethod->FriendlyName );
                MemFree( pRoutingMethod->FunctionName );
                MemFree( pRoutingMethod->InternalName );
                MemFree( pRoutingMethod );
            }
            //
            // Make the extension have an empty list of methods.
            //
            InitializeListHead( &pRoutingExtension->RoutingMethods );
        }

next:
        if (pRoutingExtension)
        {
            //
            // we have a routing extension object (successful or not), add it to the list
            //
            InsertTailList( &g_lstRoutingExtensions, &pRoutingExtension->ListEntry );
        }
    }

    SortMethodPriorities();

    if (0 == g_dwCountRoutingMethods)
    {
        //
        // No routing methods available
        //
        DebugPrintEx(DEBUG_WRN,
                     TEXT("No routing methods are available on the server !!!!"));
    }

    return TRUE;
}   // InitializeRouting

BOOL
FaxRoute(
    PJOB_QUEUE          JobQueueEntry,
    LPTSTR              TiffFileName,
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO *RouteFailureInfo,
    LPDWORD             RouteFailureCount
    )
/*++

Routine Description:

    Routes a FAX.



Arguments:

    JobQueueEntry           - the job queue entry for the job
    TiffFileName            - filename of the received fax
    FaxRoute                - struct describing received FAX
    RouteFailureInfo        - pointer to receive pointr to eceive buffer ROUTE_FAILURE_INFO structures
    RouteFailureCount       - receives the total number of route failures recorded

Return Value:

    TRUE
        if fax routing succeded ( some methods may still fail )
        check RouteFailureCount to see how many Routing Methods failed
    FALSE
        if the function itself failed ( MemAlloc etc. )

--*/

{
    PLIST_ENTRY             pNextMethod;
    PROUTING_METHOD         pRoutingMethod;
    DWORD                   FailureCount = 0;
    PROUTE_FAILURE_INFO     pRouteFailure;
    PLIST_ENTRY             pNextRoutingOverride;
    PROUTING_DATA_OVERRIDE  pRoutingDataOverride;
    BOOL                    RetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("FaxRoute"));

    *RouteFailureInfo = NULL;
    *RouteFailureCount = 0;

    //
    // if the tiff file has been deleted ==> return
    //
    if (GetFileAttributes( TiffFileName ) == 0xffffffff)
    {
        return FALSE;
    }

    EnterCriticalSection( &g_CsRouting );

    pNextMethod = g_lstRoutingMethods.Flink;
    if (pNextMethod)
    {
        //
        // allocate memory to record the GUIDs of the failed routing methods
        //
        pRouteFailure = (PROUTE_FAILURE_INFO) MemAlloc( g_dwCountRoutingMethods * sizeof(ROUTE_FAILURE_INFO) );
        if (pRouteFailure == NULL)
        {
            RetVal = FALSE;
            goto Exit;
        }
        //
        // add the tiff file as the first file
        // in the file name list, the owner is the fax service
        //
        if (FaxRouteAddFile( FaxRoute->JobId, TiffFileName, const_cast<GUID*>(&gc_FaxSvcGuid) ) < 1)
        {
            RetVal = FALSE;
            goto Exit;
        }
        //
        // walk thru all of the routing methods and call them
        //
        while ((ULONG_PTR)pNextMethod != (ULONG_PTR)&g_lstRoutingMethods)
        {
            BOOL bSuccess;
            pRoutingMethod = CONTAINING_RECORD( pNextMethod, ROUTING_METHOD, ListEntryMethod );
            pNextMethod = pRoutingMethod->ListEntryMethod.Flink;

            FaxRoute->RoutingInfoData = NULL;
            FaxRoute->RoutingInfoDataSize = 0;

            EnterCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

            pNextRoutingOverride = JobQueueEntry->RoutingDataOverride.Flink;
            if (pNextRoutingOverride != NULL)
            {
                while ((ULONG_PTR)pNextRoutingOverride != (ULONG_PTR)&JobQueueEntry->RoutingDataOverride)
                {
                    pRoutingDataOverride = CONTAINING_RECORD( pNextRoutingOverride, ROUTING_DATA_OVERRIDE, ListEntry );
                    pNextRoutingOverride = pRoutingDataOverride->ListEntry.Flink;
                    if (pRoutingDataOverride->RoutingMethod == pRoutingMethod)
                    {
                        FaxRoute->RoutingInfoData = (LPBYTE)MemAlloc(pRoutingDataOverride->RoutingDataSize);
                        if (NULL == FaxRoute->RoutingInfoData)
                        {
                            DebugPrintEx(DEBUG_ERR,
                                _T("MemAlloc Failed (ec: %ld)"),
                                GetLastError());
                            LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );
                            RetVal = FALSE;
                            goto Exit;
                         }
                         CopyMemory (FaxRoute->RoutingInfoData,
                                     pRoutingDataOverride->RoutingData,
                                     pRoutingDataOverride->RoutingDataSize);
                         FaxRoute->RoutingInfoDataSize = pRoutingDataOverride->RoutingDataSize;
                     }
                }
            }

            LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );
            pRouteFailure[FailureCount].FailureData = NULL;
            pRouteFailure[FailureCount].FailureSize = 0;
            __try
            {
                bSuccess = pRoutingMethod->FaxRouteMethod(
                                FaxRoute,
                                &pRouteFailure[FailureCount].FailureData,
                                &pRouteFailure[FailureCount].FailureSize );
            }
            __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, pRoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
            {
                ASSERT_FALSE;
            }     
            if (!bSuccess)                           
            {
                WCHAR TmpStr[20] = {0};
                swprintf(TmpStr,TEXT("0x%016I64x"), JobQueueEntry->UniqueId);

                FaxLog(FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MIN,
                    6,
                    MSG_FAX_ROUTE_METHOD_FAILED,
                    TmpStr,
                    JobQueueEntry->FaxRoute->DeviceName,
                    JobQueueEntry->FaxRoute->Tsid,
                    JobQueueEntry->FileName,
                    pRoutingMethod->RoutingExtension->FriendlyName,
                    pRoutingMethod->FriendlyName
                    );

                StringFromGUID2(pRoutingMethod->Guid,
                    pRouteFailure[FailureCount].GuidString,
                    MAX_GUID_STRING_LEN);

                //
                // Allocate failure data using MemAlloc
                //
                if (pRouteFailure[FailureCount].FailureSize)
                {
                    PVOID pOriginalFailureData = pRouteFailure[FailureCount].FailureData;
                    pRouteFailure[FailureCount].FailureData = MemAlloc (pRouteFailure[FailureCount].FailureSize);
                    if (pRouteFailure[FailureCount].FailureData)
                    {
                        CopyMemory (pRouteFailure[FailureCount].FailureData,
                                    pOriginalFailureData,
                                    pRouteFailure[FailureCount].FailureSize);
                    }
                    else
                    {
                        //
                        // Failed to allocate retry failure data - data will be lost.
                        //
                        DebugPrintEx(DEBUG_ERR,
                            _T("Failed to allocate failure date"));
                        RetVal = FALSE;
                        goto Exit;
                    }

                    if (!HeapFree(pRoutingMethod->RoutingExtension->HeapHandle, // handle to extension heap
                                    0,
                                    pOriginalFailureData
                                    ))
                    {
                        //
                        // Failed to free retry failure data from extension heap - data will be lost.
                        //
                        DebugPrintEx(DEBUG_ERR,
                                        _T("HeapFree Failed (ec: %ld)"),
                                        GetLastError());
                        RetVal = FALSE;
                        goto Exit;
                    }
                }

                if (0 == pRouteFailure[FailureCount].FailureSize ||
                    NULL == pRouteFailure[FailureCount].FailureData)
                {
                    //
                    // Make sure failure data will not be freed
                    //
                    pRouteFailure[FailureCount].FailureData = NULL;
                    pRouteFailure[FailureCount].FailureSize = 0;
                }

                FailureCount++;
            }
        }
    }

    Assert (RetVal == TRUE);

Exit:

    LeaveCriticalSection( &g_CsRouting );

    if (pRouteFailure && FailureCount == 0)
    {
        //
        // We do not delete the routed TIFF file here.
        // RemoveReceiveJob() will take care of that.
        //
        MemFree( pRouteFailure );
        pRouteFailure = NULL;
    }

    *RouteFailureInfo = pRouteFailure;
    *RouteFailureCount = FailureCount;

    return RetVal;
}


BOOL
LoadRouteInfo(
    IN  LPWSTR              RouteFileName,
    OUT PROUTE_INFO         *RouteInfo,
    OUT PROUTE_FAILURE_INFO *RouteFailure,
    OUT LPDWORD             RouteFailureCount
    )

/*++

Routine Description:

    Load routing information from a routing information file.

Arguments:

    RouteFileName - Name of routing information file.

Return value:

    Pointer to routing information structure if success.  NULL if fail.

--*/

{
    return TRUE;
}


BOOL
FaxRouteRetry(
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO pRouteFailureInfo
    )
{
    PROUTING_METHOD         RoutingMethod;
    BOOL                    RetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteRetry"));

    //
    // in this case, we've already retried this method and it succeeded.
    //
    if (!*pRouteFailureInfo->GuidString) {
       return TRUE;
    }

    RoutingMethod = FindRoutingMethodByGuid( pRouteFailureInfo->GuidString );

    if (RoutingMethod) 
    {
        BOOL bSuccess;
        
        PVOID pOriginalFailureData = NULL;
        PVOID pFailureData = pRouteFailureInfo->FailureData;
        //
        // Allocate failure data using the extension heap
        //
        if (pRouteFailureInfo->FailureSize)
        {
            pOriginalFailureData = HeapAlloc (RoutingMethod->RoutingExtension->HeapHandle,
                                                HEAP_ZERO_MEMORY,
                                                pRouteFailureInfo->FailureSize);
            if (!pOriginalFailureData)
            {
                DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("Failed to allocate failure date")
                                );
                    return FALSE;
            }
            pRouteFailureInfo->FailureData = pOriginalFailureData;
            CopyMemory (pRouteFailureInfo->FailureData,
                        pFailureData,
                        pRouteFailureInfo->FailureSize);

        }
        else
        {
            Assert (NULL == pRouteFailureInfo->FailureData);
        }
        MemFree (pFailureData);
        __try
        {
            bSuccess = RoutingMethod->FaxRouteMethod(
                  FaxRoute,
                  &(pRouteFailureInfo->FailureData),
                  &(pRouteFailureInfo->FailureSize));
        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }                  
        if (!bSuccess)
        {
            RetVal = FALSE;
            //
            // Allocate failure data using MemAlloc
            //
            if (pRouteFailureInfo->FailureSize)
            {
                pOriginalFailureData = pRouteFailureInfo->FailureData;
                pRouteFailureInfo->FailureData = MemAlloc (pRouteFailureInfo->FailureSize);
                if (pRouteFailureInfo->FailureData)
                {
                    CopyMemory (pRouteFailureInfo->FailureData,
                                pOriginalFailureData,
                                pRouteFailureInfo->FailureSize);
                }
                else
                {
                    //
                    // Failed to allocate retry failure data - data will be lost.
                    //
                    DebugPrintEx(DEBUG_ERR,
                                    _T("Failed to allocate failure date"));
                    return FALSE;
                }

                if (!HeapFree(RoutingMethod->RoutingExtension->HeapHandle, // handle to extension heap
                                0,
                                pOriginalFailureData
                                ))
                {
                    //
                    // Failed to free retry failure data from extension heap - data will be lost.
                    //
                    DebugPrintEx(DEBUG_ERR,
                                    _T("HeapFree Failed (ec: %ld)"),
                                    GetLastError());
                    return FALSE;
                }
            }
        }
        else
        {
            //
            // set the routing guid to zero so we don't try to route this guy again.  He is
            // deallocated when we delete the queue entry.
            //
            ZeroMemory(pRouteFailureInfo->GuidString, MAX_GUID_STRING_LEN*sizeof(WCHAR) );
        }

        if (0 == pRouteFailureInfo->FailureSize ||
            NULL == pRouteFailureInfo->FailureData ||
            TRUE == RetVal)
        {
            //
            // Make sure failure data will not be freed
            //
            pRouteFailureInfo->FailureData = NULL;
            pRouteFailureInfo->FailureSize = 0;
        }
    }
    else
    {
        return FALSE;
    }

    return RetVal;
}


PFAX_ROUTE
SerializeFaxRoute(
    PFAX_ROUTE FaxRoute,
    LPDWORD Size,
    BOOL bSizeOnly
    )
{
    DWORD ByteCount = sizeof(FAX_ROUTE);
    DWORD_PTR Offset;
    PFAX_ROUTE SerFaxRoute;             // the serialized version


    *Size = 0;

    // Add the size of the strings

    ByteCount += StringSize( FaxRoute->Csid );
    ByteCount += StringSize( FaxRoute->Tsid );
    ByteCount += StringSize( FaxRoute->CallerId );
    ByteCount += StringSize( FaxRoute->RoutingInfo );
    ByteCount += StringSize( FaxRoute->ReceiverName );
    ByteCount += StringSize( FaxRoute->ReceiverNumber );
    ByteCount += StringSize( FaxRoute->DeviceName );
    ByteCount += FaxRoute->RoutingInfoDataSize;

    if (bSizeOnly) {
        *Size = ByteCount;
        return NULL;
    }

    SerFaxRoute = (PFAX_ROUTE) MemAlloc( ByteCount );

    if (SerFaxRoute == NULL) {
        return NULL;
    }

    *Size = ByteCount;

    CopyMemory( (PVOID) SerFaxRoute, (PVOID) FaxRoute, sizeof(FAX_ROUTE) );

    Offset = sizeof( FAX_ROUTE );

    StoreString( FaxRoute->Csid, (PDWORD_PTR)&SerFaxRoute->Csid, (LPBYTE) SerFaxRoute, &Offset, *Size);
    StoreString( FaxRoute->Tsid, (PDWORD_PTR)&SerFaxRoute->Tsid, (LPBYTE) SerFaxRoute, &Offset, *Size);
    StoreString( FaxRoute->CallerId, (PDWORD_PTR)&SerFaxRoute->CallerId, (LPBYTE) SerFaxRoute, &Offset, *Size);
    StoreString( FaxRoute->RoutingInfo, (PDWORD_PTR)&SerFaxRoute->RoutingInfo, (LPBYTE) SerFaxRoute, &Offset, *Size);
    StoreString( FaxRoute->ReceiverName, (PDWORD_PTR)&SerFaxRoute->ReceiverName, (LPBYTE) SerFaxRoute, &Offset, *Size);
    StoreString( FaxRoute->ReceiverNumber, (PDWORD_PTR)&SerFaxRoute->ReceiverNumber, (LPBYTE) SerFaxRoute, &Offset, *Size);
    StoreString( FaxRoute->DeviceName, (PDWORD_PTR)&SerFaxRoute->DeviceName, (LPBYTE) SerFaxRoute, &Offset, *Size);

    SerFaxRoute->RoutingInfoData = (LPBYTE) Offset;
    Offset += FaxRoute->RoutingInfoDataSize;

    CopyMemory(
        (PVOID) ((LPBYTE) &SerFaxRoute + Offset),
        (PVOID) FaxRoute->RoutingInfoData,
        FaxRoute->RoutingInfoDataSize
        );

    return SerFaxRoute;
}

PFAX_ROUTE
DeSerializeFaxRoute(
    PFAX_ROUTE FaxRoute
    )
{
    PFAX_ROUTE NewFaxRoute = NULL;
    DEBUG_FUNCTION_NAME(TEXT("DeSerializeFaxRoute"));

    FixupString( FaxRoute, FaxRoute->Csid );
    FixupString( FaxRoute, FaxRoute->Tsid );
    FixupString( FaxRoute, FaxRoute->CallerId );
    FixupString( FaxRoute, FaxRoute->RoutingInfo );
    FixupString( FaxRoute, FaxRoute->ReceiverName );
    FixupString( FaxRoute, FaxRoute->DeviceName );
    FixupString( FaxRoute, FaxRoute->ReceiverNumber );

    FaxRoute->RoutingInfoData = (LPBYTE) FaxRoute + (ULONG_PTR) FaxRoute->RoutingInfoData;

    //
    // Make a copy where each item is individually malloced so it can be freed properly
    //
    NewFaxRoute = (PFAX_ROUTE)MemAlloc( sizeof( FAX_ROUTE ) );
    if (NULL == NewFaxRoute)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate FAX_ROUTE"));
        return NULL;
    }
    ZeroMemory (NewFaxRoute, sizeof( FAX_ROUTE ));

    NewFaxRoute->SizeOfStruct = sizeof( FAX_ROUTE );
    NewFaxRoute->JobId = FaxRoute->JobId;
    NewFaxRoute->ElapsedTime = FaxRoute->ElapsedTime;
    NewFaxRoute->ReceiveTime = FaxRoute->ReceiveTime;
    NewFaxRoute->PageCount = FaxRoute->PageCount;
    NewFaxRoute->DeviceId = FaxRoute->DeviceId;
    NewFaxRoute->RoutingInfoDataSize = FaxRoute->RoutingInfoDataSize;

    int nRes;
    STRING_PAIR pairs[] =
    {
        { (LPWSTR)FaxRoute->Csid, (LPWSTR*)&(NewFaxRoute->Csid)},
        { (LPWSTR)FaxRoute->Tsid, (LPWSTR*)&(NewFaxRoute->Tsid)},
        { (LPWSTR)FaxRoute->CallerId, (LPWSTR*)&(NewFaxRoute->CallerId)},
        { (LPWSTR)FaxRoute->RoutingInfo, (LPWSTR*)&(NewFaxRoute->RoutingInfo)},
        { (LPWSTR)FaxRoute->ReceiverName, (LPWSTR*)&(NewFaxRoute->ReceiverName)},
        { (LPWSTR)FaxRoute->DeviceName, (LPWSTR*)&(NewFaxRoute->DeviceName)},
        { (LPWSTR)FaxRoute->ReceiverNumber, (LPWSTR*)&(NewFaxRoute->ReceiverNumber)}
    };

    nRes = MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes != 0)
    {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"), nRes-1);
        goto Error;
    }

    NewFaxRoute->RoutingInfoData = (LPBYTE)MemAlloc( FaxRoute->RoutingInfoDataSize );
    if (NULL == NewFaxRoute->RoutingInfoData)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate RoutingInfoData"));
        goto Error;
    }

    CopyMemory( NewFaxRoute->RoutingInfoData, FaxRoute->RoutingInfoData, FaxRoute->RoutingInfoDataSize );
    return NewFaxRoute;

Error:
    MemFree ((void*)NewFaxRoute->Csid);
    MemFree ((void*)NewFaxRoute->Tsid);
    MemFree ((void*)NewFaxRoute->CallerId);
    MemFree ((void*)NewFaxRoute->RoutingInfo);
    MemFree ((void*)NewFaxRoute->ReceiverName);
    MemFree ((void*)NewFaxRoute->DeviceName);
    MemFree ((void*)NewFaxRoute->ReceiverNumber);
    MemFree ((void*)NewFaxRoute->RoutingInfoData);
    MemFree ((void*)NewFaxRoute);
    return NULL;
}


extern "C"
DWORD
GetRecieptsConfiguration(
    PFAX_SERVER_RECEIPTS_CONFIGW* ppServerRecieptConfig,
    BOOL                          bNeedNTLMToken
    )
/*++

Routine name : GetRecieptsConfiguration

Routine description:

    Private callback used by MS Routing Extension to get the server reciept configuration. Also used by the service SendReceipt()
    Used to get a copy of the receipts configuration.

Author:

    Oded Sacher (OdedS),    Mar, 2001

Arguments:

    ppServerRecieptConfig           [out] - Address to a pointer to a private server reciepts configuration struct.
                                            The caller should free the resources by calling FreeRecieptsConfiguration()
                                            
    bNeedNTLMToken                  [in]  - If TRUE, the caller is interested in the user token for NTLM authentication
                                            for SMTP connections. The token is returned in the hLoggedOnUser member
                                            of the FAX_SERVER_RECEIPTS_CONFIGW structure.
                                            
                                            if FALSE, the caller is only interested in the receipts configuration and
                                            is not about to perform any activity based on that configration
                                            (such as sending mail via CDO2).

Return Value:

    Win32 error code

--*/
{
    HKEY  hReceiptsKey = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    PFAX_SERVER_RECEIPTS_CONFIGW    pServerRecieptConfig = NULL;

    DEBUG_FUNCTION_NAME(TEXT("GetRecieptsConfiguration"));

    Assert (ppServerRecieptConfig);

    pServerRecieptConfig = (PFAX_SERVER_RECEIPTS_CONFIGW)MemAlloc(sizeof(FAX_SERVER_RECEIPTS_CONFIGW));
    if (NULL == pServerRecieptConfig)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory (pServerRecieptConfig, sizeof(FAX_SERVER_RECEIPTS_CONFIGW));

    EnterCriticalSection (&g_CsConfig);

    pServerRecieptConfig->dwSizeOfStruct = sizeof (FAX_SERVER_RECEIPTS_CONFIGW);
    pServerRecieptConfig->bIsToUseForMSRouteThroughEmailMethod = g_ReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod;
    pServerRecieptConfig->dwSMTPPort = g_ReceiptsConfig.dwSMTPPort;
    pServerRecieptConfig->dwAllowedReceipts = g_ReceiptsConfig.dwAllowedReceipts;
    pServerRecieptConfig->SMTPAuthOption = g_ReceiptsConfig.SMTPAuthOption;
    pServerRecieptConfig->lptstrReserved = NULL;

    if (NULL != g_ReceiptsConfig.lptstrSMTPServer &&
        NULL == (pServerRecieptConfig->lptstrSMTPServer = StringDup(g_ReceiptsConfig.lptstrSMTPServer)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPFrom &&
        NULL == (pServerRecieptConfig->lptstrSMTPFrom = StringDup(g_ReceiptsConfig.lptstrSMTPFrom)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPUserName &&
        NULL == (pServerRecieptConfig->lptstrSMTPUserName = StringDup(g_ReceiptsConfig.lptstrSMTPUserName)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    //
    //  Read stored password 
    //
    hReceiptsKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_SOFTWARE TEXT("\\") REGKEY_RECEIPTS_CONFIG,
        FALSE,
        KEY_READ | KEY_WRITE);
    if (NULL == hReceiptsKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed. (ec=%lu)"),
            dwRes);
        goto exit;
    }

    if ( NULL == (pServerRecieptConfig->lptstrSMTPPassword = GetRegistrySecureString(hReceiptsKey, REGVAL_RECEIPTS_PASSWORD, EMPTY_STRING, TRUE, NULL) ) )
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (bNeedNTLMToken && 
        FAX_SMTP_AUTH_NTLM == g_ReceiptsConfig.SMTPAuthOption)
    {
        //
        // User needs the NTLM token and NTLM authentication is configured.
        //
        HANDLE hDupToken;

        if (NULL == g_ReceiptsConfig.hLoggedOnUser)
        {
            HANDLE hLoggedOnUserToken;
            WCHAR wszUser[CREDUI_MAX_USERNAME_LENGTH] = {0};
            WCHAR wszDomain[CREDUI_MAX_DOMAIN_TARGET_LENGTH] = {0};

            //
            // Parse user name into user name and domain
            //
            dwRes = CredUIParseUserName (g_ReceiptsConfig.lptstrSMTPUserName,
                                         wszUser,
                                         ARR_SIZE(wszUser),
                                         wszDomain,
                                         ARR_SIZE(wszDomain));
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CredUIParseUserName failed. (ec: %ld)"),
                    dwRes);
                goto exit;
            }

            //
            // We get the a logged on user token
            //
            if (!LogonUser (wszUser,
                            wszDomain,
                            pServerRecieptConfig->lptstrSMTPPassword,
                            LOGON32_LOGON_INTERACTIVE,
                            LOGON32_PROVIDER_DEFAULT,
                            &hLoggedOnUserToken))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("LogonUser failed. (ec: %ld)"),
                    dwRes);
                goto exit;
            }
            g_ReceiptsConfig.hLoggedOnUser = hLoggedOnUserToken;
        }

        //
        // Duplicate that Token
        //
        if (!DuplicateToken(g_ReceiptsConfig.hLoggedOnUser,     // Source token
                              SecurityDelegation,               // The server process can impersonate the client's security context on remote systems
                              &hDupToken))                      // Duplicate token
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DuplicateToken failed. (ec: %ld)"),
                dwRes);
            goto exit;
        }

        pServerRecieptConfig->hLoggedOnUser = hDupToken;
    }

    *ppServerRecieptConfig = pServerRecieptConfig;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);

    if (NULL != hReceiptsKey)
    {
        DWORD ec = RegCloseKey(hReceiptsKey);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegCloseKey failed (ec: %lu)"),
                ec);
        }
    }

    if (ERROR_SUCCESS != dwRes)
    {
        FreeRecieptsConfiguration( pServerRecieptConfig, TRUE);
    }
    return dwRes;
}   // GetRecieptsConfiguration


extern "C"
void
FreeRecieptsConfiguration(
    PFAX_SERVER_RECEIPTS_CONFIGW pServerRecieptConfig,
    BOOL                         fDestroy
    )
/*++

Routine name : FreeRecieptsConfiguration

Routine description:

    Private callback used by MS Routing Extension to get the server reciept configuration.
    Used by the extension to decide on the authentication when sending mail.

Author:

    Oded Sacher (OdedS),    Mar, 2001

Arguments:

    pServerRecieptConfig            [in ] - Pointer to a private server reciepts configuration struct to be freed.
    fDestroy                        [in ] - TRUE if to free the struct as well

Return Value:

    Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FreeRecieptsConfiguration"));

    Assert (pServerRecieptConfig);

    MemFree(pServerRecieptConfig->lptstrSMTPServer);
    pServerRecieptConfig->lptstrSMTPServer = NULL;

    MemFree(pServerRecieptConfig->lptstrSMTPFrom);
    pServerRecieptConfig->lptstrSMTPFrom = NULL;

    MemFree(pServerRecieptConfig->lptstrSMTPUserName);
    pServerRecieptConfig->lptstrSMTPUserName = NULL;

	if (NULL != pServerRecieptConfig->lptstrSMTPPassword)
	{
		SecureZeroMemory(pServerRecieptConfig->lptstrSMTPPassword, _tcslen(pServerRecieptConfig->lptstrSMTPPassword)*sizeof(TCHAR));
		MemFree(pServerRecieptConfig->lptstrSMTPPassword);
		pServerRecieptConfig->lptstrSMTPPassword = NULL;
	}    

    if (NULL != pServerRecieptConfig->hLoggedOnUser )
    {
        if (!CloseHandle(pServerRecieptConfig->hLoggedOnUser))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle failed. (ec: %ld)"),
                GetLastError());
        }
        pServerRecieptConfig->hLoggedOnUser = NULL;
    }
    if (TRUE == fDestroy)
    {
        MemFree (pServerRecieptConfig);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// TIFF View resource ID file                       //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [8000 - 8999]                                    //
//                                                  //
//////////////////////////////////////////////////////
// Duplicated strings located in faxres.rc
#include "..\..\admin\faxres\resource.h"
// 
// Strings 
// 
#define IDS_SVC_DIALING                 8000 
#define IDS_SVC_SENDING                 8001 
#define IDS_SVC_RECEIVING               8002 
#define IDS_COMPLETED                   8003 
#define IDS_HANDLED                     8004 
#define IDS_LINE_UNAVAILABLE            8005 
#define IDS_BUSY                        8006 
#define IDS_NO_ANSWER                   8007 
#define IDS_BAD_ADDRESS                 8008 
#define IDS_NO_DIAL_TONE                8009 
#define IDS_DISCONNECTED                8010 
#define IDS_FATAL_ERROR                 8011 
#define IDS_NOT_FAX_CALL                8012 
#define IDS_CALL_DELAYED                8013 
#define IDS_CALL_BLACKLISTED            8014 
#define IDS_UNAVAILABLE                 8015 
#define IDS_AVAILABLE                   8016 
#define IDS_ABORTING                    8017 
#define IDS_ROUTING                     8018 
#define IDS_INITIALIZING                8019 
#define IDS_SENDFAILED                  8020 
#define IDS_SENDRETRY                   8021 
#define IDS_BLANKSTR                    8022 
#define IDS_ROUTERETRY                  8023 
#define IDS_DR_SUBJECT                  8024 
#define IDS_DR_FILENAME                 8025 
#define IDS_NDR_SUBJECT                 8026 
#define IDS_NDR_FILENAME                8027 
#define IDS_CALL_COMPLETED              8028 
#define IDS_CALL_ABORTED                8029 
#define IDS_ANSWERED                    8030 
#define IDS_NO_MAPI_LOGON               8031 
#define IDS_DEFAULT                     8032 
#define IDS_FAX_LOG_CATEGORY_INIT_TERM  8033 
#define IDS_FAX_LOG_CATEGORY_OUTBOUND   8034 
#define IDS_FAX_LOG_CATEGORY_INBOUND    8035 
#define IDS_FAX_LOG_CATEGORY_UNKNOWN    8036 
#define IDS_SET_CONFIG                  8037 
#define IDS_PARTIALLY_RECEIVED          8038 
#define IDS_FAILED_RECEIVE              8039 
#define IDS_FAILED_SEND                 8040 
#define IDS_CANCELED                    8041 
#define IDS_RECEIPT_RECIPIENT_NUMBER        8042 
#define IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH  8043 
#define IDS_RECEIPT_RECIPIENT_NAME          8044 
#define IDS_RECEIPT_RECIPIENT_NAME_WIDTH    8045 
#define IDS_RECEIPT_START_TIME              8046 
#define IDS_RECEIPT_START_TIME_WIDTH        8047 
#define IDS_RECEIPT_END_TIME                8048 
#define IDS_RECEIPT_END_TIME_WIDTH          8049 
#define IDS_RECEIPT_RETRIES                 8050 
#define IDS_RECEIPT_RETRIES_WIDTH           8051 
#define IDS_RECEIPT_LAST_ERROR              8052 
#define IDS_RECEIPT_LAST_ERROR_WIDTH        8053 
#define IDS_COMPLETED_RECP_LIST_HEADER      8054 
#define IDS_FAILED_RECP_LIST_HEADER         8055 
#define IDS_JOB_CANCELED_BY_USER            8056 
#define IDS_RECEIPT_NO_CP_ATTACH            8057 
#define IDS_RECEIPT_NO_CP_AND_BODY_ATTACH   8058 
#define IDS_HTML_RECEIPT_HEADER             8059 
#define IDS_JOB_ID                  8060 
#define IDS_STATUS                  8061 
#define IDS_ERROR_DESC              8062 
#define IDS_ERROR_CODE              8063 
#define IDS_FILE_NAME               8065 
#define IDS_FILE_SIZE               8066 
#define IDS_DIALED_NUMBER           8067 
#define IDS_CSID                    8068 
#define IDS_TSID                    8069 
#define IDS_CALLER_ID               8070 
#define IDS_ROUTING_INFO            8071 
#define IDS_PAGES                   8072 
#define IDS_SUBMITED                8073 
#define IDS_START_TIME              8074 
#define IDS_COVER_PAGE              8075 
#define IDS_SENDER_NAME             8076 
#define IDS_RECIPIENT_NAME          8077 
#define IDS_RECIPIENT_FAX_NUMBER    8078 
#define IDS_RETRIES                 8079 
#define IDS_BILLING_CODE            8080 
#define IDS_PARENT_JOB_ID           8081 
#define IDS_END_TIME                8082 
#define IDS_SCHEDULED               8083 
#define IDS_DOCUMENT                8084 
#define IDS_SUBJECT                 8085 
#define IDS_NOTE                    8086 
#define IDS_USER_NAME               8087 
#define IDS_SENDER_FAX_NUMBER       8088 
#define IDS_SENDER_COMPANY          8089 
#define IDS_SENDER_STREET           8090 
#define IDS_SENDER_CITY             8091 
#define IDS_SENDER_ZIP              8092 
#define IDS_SENDER_COUNTRY          8093 
#define IDS_SENDER_TITLE            8094 
#define IDS_SENDER_DEPARTMENT       8095 
#define IDS_SENDER_OFFICE           8096 
#define IDS_SENDER_H_PHONE          8097 
#define IDS_SENDER_O_PHONE          8098 
#define IDS_SENDER_E_MAIL           8099 
#define IDS_RECIPIENT_COMPANY       8100 
#define IDS_RECIPIENT_STREET        8101 
#define IDS_RECIPIENT_CITY          8102 
#define IDS_RECIPIENT_ZIP           8103 
#define IDS_RECIPIENT_COUNTRY       8104 
#define IDS_RECIPIENT_TITLE         8105 
#define IDS_RECIPIENT_DEPARTMENT    8106 
#define IDS_RECIPIENT_OFFICE        8107 
#define IDS_RECIPIENT_H_PHONE       8108 
#define IDS_RECIPIENT_O_PHONE       8109 
#define IDS_RECIPIENT_E_MAIL        8110 
#define IDS_TOTAL_PAGES						8111 

//
// Icon
//
#define IDI_APPICON					8113
//////////////////////////////////////////////////////
//                                                  //
// TIFF View resource ID file                       //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [8000 - 8999]                                    //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module handles the FAX receive case.

Author:

    Wesley Witt (wesw) 6-Mar-1996


Revision History:

--*/

#include "faxsvc.h"
#include "faxreg.h"
#pragma hdrstop

DWORD
FaxReceiveThread(
    PFAX_RECEIVE_ITEM FaxReceiveItem
    )

/*++

Routine Description:

    This function process a FAX send operation.  This runs
    asynchronously as a separate thread.  There is one
    thread for each outstanding FAX operation.

Arguments:

    FaxReceiveItem  - FAX receive packet

Return Value:

    Error code.

--*/

{
    WCHAR       ArchiveFileName[MAX_PATH];
    DWORD rVal = ERROR_SUCCESS;
    DWORD dwRes;
    PJOB_ENTRY JobEntry;
    DWORD JobId;
    PLINE_INFO LineInfo;
    PFAX_RECEIVE FaxReceive = NULL;
    DWORD ReceiveSize;
    BOOL Result;
    DWORDLONG ElapsedTime = 0;
    DWORDLONG ReceiveTime = 0;
    BOOL DoFaxRoute = FALSE;
    DWORD Attrib;
    DWORD RecoveredPages,TotalPages;
    MS_TAG_INFO MsTagInfo = {0};
    BOOL fReceiveNoFile = FALSE;
    BOOL ReceiveFailed = FALSE;
    PJOB_QUEUE JobQueue = NULL;
	BOOL fSystemAbort;
    
    BOOL DeviceCanSend = TRUE;  // TRUE if the device is free for send after the receive is completed.
                                // FALSE for handoff jobs and devices that are not send enabled.
                                // Its value determines if to notify the queue that a device was freed up.
    PJOB_QUEUE lpRecoverJob = NULL; // Pointer to a receive recover job if created.
    LPFSPI_JOB_STATUS pFaxStatus = NULL;
    LPFSPI_JOB_STATUS pOrigFaxStatus = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxReceiveThread"));
    DWORD ec;
    BOOL fCOMInitiliazed = FALSE;
    HRESULT hr;
    WCHAR wszArchiveFolder[MAX_PATH];
    FSPI_JOB_STATUS FakedFaxStatus = {0};
    BOOL bFakeStatus = FALSE;
    DWORD dwSttRes = ERROR_SUCCESS;
    WCHAR LastExStatusString[EX_STATUS_STRING_LEN] = {0}; // The last extended status string of this job (when it was active)
    DWORD dwLastJobExtendedStatus = 0;
    BOOL fSetSystemIdleTimer = TRUE;    

    Assert(FaxReceiveItem);

    //
    // Don't let the system go to sleep in the middle of the fax transmission.
    //
    if (NULL == SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS))
    {
        fSetSystemIdleTimer = FALSE;
        DebugPrintEx(DEBUG_ERR,
            TEXT("SetThreadExecutionState() failed"));
    }

    //
    // Successfully created new receive job on line. Update counter
    //
    (VOID) UpdateDeviceJobsCounter ( FaxReceiveItem->LineInfo,  // Device to update
                                     FALSE,                     // Receiving
                                     1,                         // Number of new jobs
                                     TRUE);                     // Enable events
    LineInfo = FaxReceiveItem->LineInfo;
    Assert(LineInfo);
    JobEntry = FaxReceiveItem->JobEntry;
    Assert(JobEntry);

    //
    // Note: The receive job is not backed up by a file.
    // When we turn it into a routing job (JT_ROUTING) we will create a .FQE
    // file for it.

    JobQueue=JobEntry->lpJobQueueEntry;
    Assert(JobQueue);

    JobId = JobQueue->JobId;
    DebugPrintEx( DEBUG_MSG,
                TEXT("[JobId: %ld] Start receive. hLine= 0x%0X hCall=0x%0X"),
                JobId,
                LineInfo->hLine,
                FaxReceiveItem->hCall);

    //
    // allocate memory for the receive packet
    // this is a variable size packet based
    // on the size of the strings contained
    // withing the packet.
    //

    ReceiveSize = sizeof(FAX_RECEIVE) + FAXDEVRECEIVE_SIZE;
    FaxReceive = (PFAX_RECEIVE) MemAlloc( ReceiveSize );
    if (!FaxReceive)
    {
        TCHAR strTo[20+1]={0};
        TCHAR strDeviceName[MAX_PATH]={0};

        ReceiveFailed = TRUE;
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for FAX_RECEIVE"));
        
        //
        // Fake job status;
        //
        bFakeStatus = TRUE;

        //
        //  Point to FakedFaxStatus on stack - all it's field are initialized to zero
        //
        pFaxStatus = &FakedFaxStatus;
        
        FakedFaxStatus.dwSizeOfStruct = sizeof (FakedFaxStatus);
        //
        // Fake general failure
        //
        pFaxStatus->dwJobStatus      = FSPI_JS_FAILED;
        pFaxStatus->dwExtendedStatus = FSPI_ES_FATAL_ERROR;

        EnterCriticalSection (&g_CsLine);
        _tcsncpy(strTo,LineInfo->Csid,ARR_SIZE(strTo)-1);
        _tcsncpy(strDeviceName,LineInfo->DeviceName,ARR_SIZE(strDeviceName)-1);
        LeaveCriticalSection (&g_CsLine);

        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            5,
            MSG_FAX_RECEIVE_FAILED_EX,
            NULL,
            NULL,
            strTo,
            NULL,
            strDeviceName
            );
        
        
    }


    if (NULL != FaxReceive)
    {
        //
        // setup the receive packet
        //

        FaxReceive->SizeOfStruct    = ReceiveSize;

        //
        // copy filename into place
        //
        FaxReceive->FileName        = (LPTSTR) ((LPBYTE)FaxReceive + sizeof(FAX_RECEIVE));
        _tcscpy( FaxReceive->FileName, FaxReceiveItem->FileName );

        //
        // copy number into place right after filename
        //
        FaxReceive->ReceiverNumber  = (LPTSTR) ( (LPBYTE)FaxReceive->FileName +
                            sizeof(TCHAR)*(_tcslen(FaxReceive->FileName) + 1));

        EnterCriticalSection (&g_CsLine);

        _tcscpy( FaxReceive->ReceiverNumber, LineInfo->Csid );
        //
        // copy device name into place right after number
        //
        FaxReceive->ReceiverName  = (LPTSTR) ( (LPBYTE)FaxReceive->ReceiverNumber +
                            sizeof(TCHAR)*(_tcslen(FaxReceive->ReceiverNumber) + 1));
        _tcscpy( FaxReceive->ReceiverName, LineInfo->DeviceName );

        LeaveCriticalSection (&g_CsLine);

        FaxReceive->Reserved[0]     = 0;
        FaxReceive->Reserved[1]     = 0;
        FaxReceive->Reserved[2]     = 0;
        FaxReceive->Reserved[3]     = 0;

        dwRes = IsValidFaxFolder(g_wszFaxQueueDir);
        if (ERROR_SUCCESS != dwRes)
        {               
            DebugPrintEx(DEBUG_ERR,
                            TEXT("[Job: %ld] FaxReceive - IsValidFaxFolder failed for Queue directory [%s] (ec=%lu)"), 
                            JobId, 
                            g_wszFaxQueueDir,
                            dwRes);

            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_QUEUE_FOLDER_ERR,
                g_wszFaxQueueDir,
                DWORD2DECIMAL(dwRes)
                );
        }

        Attrib = GetFileAttributes( FaxReceive->FileName );
        if (Attrib == 0xffffffff)
        {               
            dwRes = GetLastError();

            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_RECEIVE_NOFILE,
                FaxReceive->FileName,
                DWORD2DECIMAL(dwRes)
                );
            fReceiveNoFile = TRUE;
            DebugPrintEx(DEBUG_WRN,TEXT("[Job: %ld] FaxReceive - %s does not exist"), JobId, FaxReceive->FileName );

        }
        else
        {
            DebugPrintEx(DEBUG_MSG, TEXT("[Job: %ld] Starting FAX receive into %s"), JobId,FaxReceive->FileName );
        }

        //
        // do the actual receive
        //

        __try
        {

            Result = LineInfo->Provider->FaxDevReceive(
                    (HANDLE) JobEntry->InstanceData,
                    FaxReceiveItem->hCall,
                    FaxReceive
                    );

        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, LineInfo->Provider->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }

        EnterCriticalSection (&g_CsJob);
        GetSystemTimeAsFileTime( (FILETIME*) &JobEntry->EndTime );
        ReceiveTime = JobEntry->StartTime;
        JobEntry->ElapsedTime = JobEntry->EndTime - JobEntry->StartTime;
        LeaveCriticalSection (&g_CsJob);

        //
        // Get the final status of the job.
        //
        dwSttRes = GetDevStatus((HANDLE)JobEntry->InstanceData,
                                        LineInfo,
                                        &pFaxStatus);
        if (dwSttRes != ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,
                            TEXT("[Job: %ld] GetDevStatus failed - %d"),
                            JobId,
                            dwSttRes);
            //
            // Fake job status;
            //
            bFakeStatus = TRUE;
        }
        else if ((FSPI_JS_ABORTED         != pFaxStatus->dwJobStatus) &&
                    (FSPI_JS_COMPLETED       != pFaxStatus->dwJobStatus) &&
                    (FSPI_JS_FAILED          != pFaxStatus->dwJobStatus) &&                     
                    (FSPI_JS_FAILED_NO_RETRY != pFaxStatus->dwJobStatus) &&
                    (FSPI_JS_DELETED         != pFaxStatus->dwJobStatus))
        {
            //
            // Status returned is unacceptable - fake one.
            //
            bFakeStatus = TRUE;
            DebugPrintEx(DEBUG_WRN,
                            TEXT("GetDevStatus return unacceptable status - %d. Faking the status"),
                            pFaxStatus->dwJobStatus);

            pOrigFaxStatus = pFaxStatus;
            memcpy (&FakedFaxStatus, pFaxStatus, sizeof (FakedFaxStatus));
            if (pFaxStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE)
            {
                //
                // The FSP returned proprietary status. 
                //
                FakedFaxStatus.dwExtendedStatus = pFaxStatus->dwExtendedStatus;
                FakedFaxStatus.dwExtendedStatusStringId = pFaxStatus->dwExtendedStatusStringId;
            }
            pFaxStatus = NULL;
        }
        if (bFakeStatus)
        {
            //
            // Fake status code
            //
            pFaxStatus = &FakedFaxStatus;
            FakedFaxStatus.dwSizeOfStruct = sizeof (FakedFaxStatus);
            if (Result)
            {
                //
                // Fake success
                //
                pFaxStatus->dwJobStatus = FSPI_JS_COMPLETED;
                if (0 == pFaxStatus->dwExtendedStatus)
                {
                    //
                    // The FSP did not report proprietary status
                    //
                    pFaxStatus->dwExtendedStatus = FSPI_ES_CALL_COMPLETED;
                }
            }
            else
            {
                //
                // Fake general failure
                //
                pFaxStatus->dwJobStatus = FSPI_JS_FAILED;
                if (0 == pFaxStatus->dwExtendedStatus)
                {
                    //
                    // The FSP did not report proprietry status
                    //
                    pFaxStatus->dwExtendedStatus = FSPI_ES_FATAL_ERROR;
                }
            }
        }

        if (!Result)
        {

            DebugPrintEx(DEBUG_ERR,
                            TEXT("[Job: %ld] FAX receive failed. FSP reported ")
                            TEXT("status: 0x%08X, extended status: 0x%08x"),
                            JobId,
                            pFaxStatus->dwJobStatus,
                            pFaxStatus->dwExtendedStatus);
            ReceiveFailed = TRUE;

            if (pFaxStatus->dwExtendedStatus == FSPI_ES_NOT_FAX_CALL)
            {
                DebugPrintEx(DEBUG_MSG,
                                TEXT("[Job: %ld] FSP reported that call is not ")
                                TEXT("a fax call. Handing off to RAS."),
                                JobId);
                if (HandoffCallToRas( LineInfo, FaxReceiveItem->hCall ))
                {
                    FaxReceiveItem->hCall = 0;

                    EnterCriticalSection (&g_CsLine);
                    LineInfo->State = FPS_NOT_FAX_CALL;
                    LeaveCriticalSection (&g_CsLine);
                    //
                    // In case of a handoff to RAS the device is still in use and can not send.
                    // We do not want to notify the queue a device was freed.
                    //
                    DeviceCanSend = FALSE;
                }
                else
                {
                    //
                    // since the handoff failed we must notify
                    // the fsp so that the call can be put onhook
                    //        
                    __try
                    {
                        LineInfo->Provider->FaxDevAbortOperation(
                                (HANDLE) JobEntry->InstanceData
                                );

                    }
                    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, LineInfo->Provider->FriendlyName, GetExceptionCode()))
                    {
                        ASSERT_FALSE;
                    }
                }
            }
            else 
            if (FSPI_JS_ABORTED != pFaxStatus->dwJobStatus)
            {
                if (!fReceiveNoFile)
                {
                    //
                    // We have a partially received fax.
                    // The FSP reported some failure but it was not an ABORT.
                    // Try to recover one or more pages of the received fax.
                    //
                    if (!TiffRecoverGoodPages(FaxReceive->FileName,&RecoveredPages,&TotalPages) )
                    {
                        //
                        // Couldn't recover any pages, just log an error and delete the received fax.
                        //
                        LPTSTR ToStr;
                        TCHAR TotalCountStrBuf[64];

                        if (pFaxStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_PAGECOUNT)
                        {
                            _ltot((LONG) pFaxStatus->dwPageCount, TotalCountStrBuf, 10);
                        }
                        else
                        {
                            _ltot((LONG) 0, TotalCountStrBuf, 10);
                        }

                        if ( (NULL == pFaxStatus->lpwstrRoutingInfo) ||
                            (pFaxStatus->lpwstrRoutingInfo[0] == TEXT('\0')) )
                        {
                            ToStr = FaxReceive->ReceiverNumber;
                        }
                        else
                        {
                            ToStr = pFaxStatus->lpwstrRoutingInfo;
                        }
                        FaxLog(
                            FAXLOG_CATEGORY_INBOUND,
                            FAXLOG_LEVEL_MIN,
                            5,
                            MSG_FAX_RECEIVE_FAILED_EX,
                            pFaxStatus->lpwstrRemoteStationId,
                            pFaxStatus->lpwstrCallerId,
                            ToStr,
                            TotalCountStrBuf,
                            JobEntry->LineInfo->DeviceName
                            );
                    }
                    else
                    {
                        //
                        // recovered some pages, log a message and add to job queue
                        //
                        TCHAR RecoverCountStrBuf[64];
                        TCHAR TotalCountStrBuf[64];
                        TCHAR TimeStr[128];
                        LPTSTR ToStr;

                        FormatElapsedTimeStr(
                            (FILETIME*)&JobEntry->ElapsedTime,
                            TimeStr,
                            ARR_SIZE(TimeStr)
                            );

                        _ltot((LONG) RecoveredPages, RecoverCountStrBuf, 10);
                        _ltot((LONG) TotalPages, TotalCountStrBuf, 10);

                        if ( (NULL == pFaxStatus->lpwstrRoutingInfo) ||
                            (pFaxStatus->lpwstrRoutingInfo[0] == TEXT('\0')) )
                        {
                            ToStr = FaxReceive->ReceiverNumber;
                        }
                        else
                        {
                            ToStr = pFaxStatus->lpwstrRoutingInfo;
                        }
                        FaxLog(
                            FAXLOG_CATEGORY_INBOUND,
                            FAXLOG_LEVEL_MIN,
                            8,
                            MSG_FAX_RECEIVE_FAIL_RECOVER,
                            FaxReceive->FileName,
                            pFaxStatus->lpwstrRemoteStationId,
                            pFaxStatus->lpwstrCallerId,
                            ToStr,
                            RecoverCountStrBuf,
                            TotalCountStrBuf,
                            TimeStr,
                            JobEntry->LineInfo->DeviceName
                            );
                        
                        //
                        // Use the JobQueue to temporary store the original extended status for Activity Logging purpose
                        // This value will be overwritten when the activity logging is done
                        // Get extended status string
                        //                          
                        if (pFaxStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE)
                        {
                            //
                            // Proprietary extended status
                            //
                            if (pFaxStatus->dwExtendedStatusStringId != 0)
                            {                                   
                                //
                                // We have a string ID, try to load it.
                                //
                                DWORD Size = 0;
                                HINSTANCE hLoadInstance = NULL;

                                if ( !_tcsicmp(JobEntry->LineInfo->Provider->szGUID,REGVAL_T30_PROVIDER_GUID_STRING) )
                                {   // special case where the FSP is our FSP (fxst30.dll).
                                    hLoadInstance = g_hResource;
                                }
                                else
                                {
                                    hLoadInstance = JobEntry->LineInfo->Provider->hModule;
                                }
                                Size = LoadString (hLoadInstance,
                                                pFaxStatus->dwExtendedStatusStringId,
                                                JobQueue->ExStatusString,
                                                ARR_SIZE(JobQueue->ExStatusString));
                                if (Size == 0)
                                {
                                    ec = GetLastError();
                                    DebugPrintEx(
                                        DEBUG_ERR,
                                        TEXT("Failed to load extended status string (ec: %ld) stringid"),
                                        ec,
                                        pFaxStatus->dwExtendedStatusStringId);                                                                                  
                                }
                            }
                        }
                        else
                        {
                            //
                            // Well known extended status
                            //
                            LPTSTR ResStr = MapFSPIJobExtendedStatusToString(pFaxStatus->dwExtendedStatus);
                            if (NULL == ResStr)
                            {                               
                                DebugPrintEx(
                                    DEBUG_ERR,
                                    TEXT("Unexpected extended status. Extended Status: %ld"),
                                    pFaxStatus->dwExtendedStatus);
                            }
                            else
                            {
                                wcsncpy(JobQueue->ExStatusString, ResStr, ARR_SIZE(JobQueue->ExStatusString) - 1);
                            }  
                        }                               

                        //
                        // Now, change status and extended status to partially received
                        //
                        pFaxStatus->dwJobStatus = FSPI_JS_COMPLETED;
                        pFaxStatus->dwExtendedStatus = FSPI_ES_PARTIALLY_RECEIVED;

                        //
                        // Ignore the private status code and the proprietary string returned from the FSP.
                        // 
                        pFaxStatus->dwExtendedStatusStringId = 0;
                        pFaxStatus->fAvailableStatusInfo &= ~FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;
                        DoFaxRoute = TRUE;
                    }
                }
            }
            else
            {
                //
                // FSPI_JS_ABORTED == pFaxStatus->dwJobStatus
                //
                FaxLog(
                    FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MAX,
                    0,
                    MSG_FAX_RECEIVE_USER_ABORT
                    );
            }
        }
        else
        {
            TCHAR PageCountStrBuf[64];
            TCHAR TimeStr[128];
            LPTSTR ToStr;

            if (!TiffPostProcessFast( FaxReceive->FileName, NULL ))
            {
                ASSERT_FALSE;
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("[Job: %ld] failed to post process the TIFF file, FileName %s"),
                    JobId,
                    FaxReceive->FileName);                      
            }

            DebugPrintEx(
                DEBUG_MSG,
                TEXT("[Job: %ld] FAX receive succeeded"),
                JobId);

            FormatElapsedTimeStr(
                (FILETIME*)&JobEntry->ElapsedTime,
                TimeStr,
                ARR_SIZE(TimeStr)
                );

            _ltot((LONG) pFaxStatus->dwPageCount, PageCountStrBuf, 10);

            if ( (NULL == pFaxStatus->lpwstrRoutingInfo) ||
                    (pFaxStatus->lpwstrRoutingInfo[0] == TEXT('\0')) )
            {
                ToStr = FaxReceive->ReceiverNumber;
            }
            else
            {
                ToStr = pFaxStatus->lpwstrRoutingInfo;
            }
            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MAX,
                7,
                MSG_FAX_RECEIVE_SUCCESS,
                FaxReceive->FileName,
                pFaxStatus->lpwstrRemoteStationId,
                pFaxStatus->lpwstrCallerId,
                ToStr,
                PageCountStrBuf,
                TimeStr,
                JobEntry->LineInfo->DeviceName
                );

            ElapsedTime = JobEntry->ElapsedTime;
            DoFaxRoute = TRUE;
        }
    }
    if (g_pFaxPerfCounters && ReceiveFailed && LineInfo->State != FPS_NOT_FAX_CALL)
    {
        InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->InboundFailedReceive );
    }


    //
    // Call FaxDevEndJob() and Release the receive device but do not delete the job.
    //
    if (!ReleaseJob( JobEntry ))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[Job: %ld] FAX ReleaseJob failed , ec=0x%08x"),
                      JobId,
                      GetLastError());
    }
    //
    // We just successfully completed a receive job on the device - update counter.
    //
    (VOID) UpdateDeviceJobsCounter ( LineInfo,   // Device to update
                                     FALSE,      // Receiving
                                     -1,         // Number of new jobs (-1 = decrease by one)
                                     TRUE);      // Enable events
    //
    // Update the FSPIJobStatus in the JobEntry
    //
    EnterCriticalSection (&g_CsJob); // Block FaxStatusThread
    if (!UpdateJobStatus(JobEntry, pFaxStatus))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] UpdateJobStatus() failed (ec: %ld)."),
            JobEntry->lpJobQueueEntry->JobId,
            GetLastError());
    }
    JobEntry->fStopUpdateStatus = TRUE; // Stop FaxStatusThread from changing this status

    //
    // Save the last extended status
    //
    wcscpy (LastExStatusString, JobEntry->ExStatusString);
    dwLastJobExtendedStatus = pFaxStatus->dwExtendedStatus;
    LeaveCriticalSection (&g_CsJob);

    //
    // route the newly received fax
    //

    if (DoFaxRoute)
    {
        HANDLE hFind;
        WIN32_FIND_DATA FindFileData;
        DWORD Bytes = 0 ;
        BOOL fArchiveSuccess = FALSE;
        BOOL fArchiveInbox;

        //
        // Change JobStatus to JS_ROUTING - This means that the reception is completed succesfully/partially
        //
        EnterCriticalSectionJobAndQueue;
        JobQueue->JobStatus = JS_ROUTING;
        //
        // CreteFaxEventEx
        //
        dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                   JobQueue
                                 );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                JobQueue->UniqueId,
                dwRes);
        }
        LeaveCriticalSectionJobAndQueue;

        EnterCriticalSection (&g_CsConfig);
        lstrcpyn (  wszArchiveFolder,
                    g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder,
                    MAX_PATH);
        LeaveCriticalSection (&g_CsConfig);

        hr = CoInitialize (NULL);
        if (FAILED (hr))
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("CoInitilaize failed, err %ld"),
                          hr);            
            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                3,
                MSG_FAX_ARCHIVE_FAILED,
                JobQueue->FileName,
                wszArchiveFolder,
                DWORD2DECIMAL(hr)
            );
        }
        else
        {
            fCOMInitiliazed = TRUE;
        }

        EnterCriticalSection (&g_CsConfig);
        fArchiveInbox = g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].bUseArchive;
        LeaveCriticalSection (&g_CsConfig);


        if (fArchiveInbox)
        {
            //
            // Add the Microsoft Fax tags to the file
            // this is necessary ONLY when we archive the
            // file when doing a receive.  if we are not
            // routing the file then it is deleted, so
            // adding the tags is not necessary.
            //
            if (NULL != pFaxStatus->lpwstrRoutingInfo)
            {
                MsTagInfo.Routing       = pFaxStatus->lpwstrRoutingInfo;
            }

            if (NULL != pFaxStatus->lpwstrCallerId)
            {
                MsTagInfo.CallerId       = pFaxStatus->lpwstrCallerId;
            }

            if (NULL != pFaxStatus->lpwstrRemoteStationId)
            {
                MsTagInfo.Tsid       = pFaxStatus->lpwstrRemoteStationId;
            }

            if (pFaxStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_PAGECOUNT)
            {
                MsTagInfo.Pages       = pFaxStatus->dwPageCount;
            }

            MsTagInfo.Csid          = FaxReceive->ReceiverNumber;
            MsTagInfo.Port          = FaxReceive->ReceiverName;
            MsTagInfo.Type          = JT_RECEIVE;

            MsTagInfo.dwStatus          = JS_COMPLETED; // We archive only succesfull/Partially received faxes
            MsTagInfo.dwExtendedStatus  = pFaxStatus->dwExtendedStatus;         
            if (lstrlen(JobEntry->ExStatusString))
            {
                MsTagInfo.lptstrExtendedStatus = JobEntry->ExStatusString;
            }    

            if (!GetRealFaxTimeAsFileTime (JobEntry, FAX_TIME_TYPE_START, (FILETIME*)&MsTagInfo.StartTime))
            {
                MsTagInfo.StartTime = 0;
                DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Start time)  Failed (ec: %ld)"), GetLastError() );
            }

            if (!GetRealFaxTimeAsFileTime (JobEntry, FAX_TIME_TYPE_END, (FILETIME*)&MsTagInfo.EndTime))
            {
                MsTagInfo.EndTime = 0;
                DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Eend time) Failed (ec: %ld)"), GetLastError() );
            }
            //
            // Archive the file
            //
            ec = IsValidFaxFolder(wszArchiveFolder);
            if(ERROR_SUCCESS != ec)
            {                
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                    wszArchiveFolder,
                    ec
                    );
                FaxLog(
                        FAXLOG_CATEGORY_INBOUND,
                        FAXLOG_LEVEL_MIN,
                        2,
                        MSG_FAX_ARCHIVE_INBOX_FOLDER_ERR,
                        wszArchiveFolder,
                        DWORD2DECIMAL(ec)
                    );
            }
            else
            {
                if (!GenerateUniqueArchiveFileName(  wszArchiveFolder,
                                                     ArchiveFileName,
                                                     ARR_SIZE(ArchiveFileName),
                                                     JobQueue->UniqueId,
                                                     NULL))
                {                    
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to generate unique name for archive file at dir [%s] (ec: %ld)"),
                        wszArchiveFolder,
                        ec);
                    FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           1,
                           MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
                           DWORD2DECIMAL(ec)
                    );
                }
                else
                {
                    Assert(JobQueue->FileName);

                    if (!CopyFile( JobQueue->FileName, ArchiveFileName, FALSE ))
                    {                        
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CopyFile [%s] to [%s] failed. (ec: %ld)"),
                            JobQueue->FileName,
                            ArchiveFileName,
                            ec);
                        FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           1,
                           MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
                           DWORD2DECIMAL(ec)
                        );

                        if (!DeleteFile(ArchiveFileName))
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("DeleteFile [%s] failed. (ec: %ld)"),
                                ArchiveFileName,
                                GetLastError());
                        }
                    }
                    else
                    {
                        BOOL bTagsEventLogged = FALSE;  // Did we issue event MSG_FAX_ARCHIVE_NO_TAGS?
                        //
                        // Store archive properties as TIFF tags (always)
                        //
                        if (!TiffAddMsTags( ArchiveFileName, &MsTagInfo, FALSE ))
                        {                            
                            ec = GetLastError ();
                            DebugPrintEx( DEBUG_ERR,
                                          TEXT("TiffAddMsTags failed, ec = %ld"),
                                          ec);
                            FaxLog(
                                FAXLOG_CATEGORY_INBOUND,
                                FAXLOG_LEVEL_MIN,
                                2,
                                MSG_FAX_ARCHIVE_NO_TAGS,
                                ArchiveFileName,
                                DWORD2DECIMAL(ec)
                            );
                            bTagsEventLogged = TRUE;
                        }
                        //
                        // Also attempt to persist inbound information using IPropertyStorage-NTFS File System
                        //
                        if (fCOMInitiliazed)
                        {
                            if (!AddNTFSStorageProperties ( ArchiveFileName, &MsTagInfo, FALSE ))
                            {                                
                                ec = GetLastError();
                                if (ERROR_OPEN_FAILED != ec)
                                {
                                    //
                                    // If AddNTFSStorageProperties fails with ERROR_OPEN_FAIL then the archive
                                    // folder is not on an NTFS 5 partition.
                                    // This is ok - NTFS properties are a backup mechanism but not a must
                                    //
                                    DebugPrintEx( DEBUG_ERR,
                                                  TEXT("AddNTFSStorageProperties failed, ec = %ld"),
                                                  ec);
                                    if (!bTagsEventLogged)
                                    {
                                        FaxLog(
                                            FAXLOG_CATEGORY_INBOUND,
                                            FAXLOG_LEVEL_MIN,
                                            2,
                                            MSG_FAX_ARCHIVE_NO_TAGS,
                                            ArchiveFileName,
                                            DWORD2DECIMAL(ec)
                                        );
                                        bTagsEventLogged = TRUE;
                                    }
                                }
                                else
                                {
                                    DebugPrintEx( DEBUG_WRN,
                                                  TEXT("AddNTFSStorageProperties failed with ERROR_OPEN_FAIL. Probably not an NTFS 5 partition"));
                                }
                            }
                        }
                        fArchiveSuccess = TRUE;
                    }
                }
            }

            if (fArchiveSuccess == FALSE)
            {                
                FaxLog(
                    FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MIN,
                    3,
                    MSG_FAX_ARCHIVE_FAILED,
                    JobQueue->FileName,
                    wszArchiveFolder,
                    DWORD2DECIMAL(ec)
                );
                JobQueue->fDeleteReceivedTiff = FALSE; // Do not delete the tiff file from the queue
            }
            else
            {
                dwRes = CreateArchiveEvent (JobQueue->UniqueId,
                                            FAX_EVENT_TYPE_IN_ARCHIVE,
                                            FAX_JOB_EVENT_TYPE_ADDED,
                                            NULL);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                        dwRes);
                }

                hFind = FindFirstFile( ArchiveFileName, &FindFileData);
                if (INVALID_HANDLE_VALUE == hFind)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FindFirstFile failed (ec: %lc), File %s"),
                        GetLastError(),
                        ArchiveFileName);
                }
                else
                {
                    // Update the archive size - for quota management
                    EnterCriticalSection (&g_CsConfig);
                    if (FAX_ARCHIVE_FOLDER_INVALID_SIZE != g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].dwlArchiveSize)
                    {
                        g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].dwlArchiveSize += (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
                    }
                    LeaveCriticalSection (&g_CsConfig);

                    if (!FindClose(hFind))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("FindClose failed (ec: %lc)"),
                            GetLastError());
                    }
                }

                FaxLog(
                    FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MAX,
                    2,
                    MSG_FAX_RECEIVED_ARCHIVE_SUCCESS,
                    JobQueue->FileName,
                    ArchiveFileName
                );
            }
        }

        //
        // The fax receive operation was successful.
        //
        EnterCriticalSection (&g_CsQueue);
        JobQueue->PageCount = pFaxStatus->dwPageCount;      

       // Get the file size
        hFind = FindFirstFile( FaxReceive->FileName, &FindFileData);
        if (INVALID_HANDLE_VALUE == hFind)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindFirstFile failed (ec: %lc), File %s"),
                GetLastError(),
                FaxReceive->FileName);
        }
        else
        {
            Bytes = FindFileData.nFileSizeLow;
            if (!FindClose(hFind))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FindClose failed (ec: %lc)"),
                    GetLastError());
            }
        }

        JobQueue->FileSize = Bytes;

        LeaveCriticalSection( &g_CsQueue );


        if (g_pFaxPerfCounters)
        {
            SYSTEMTIME SystemTime ;
            if (FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &SystemTime ))
            {
                DWORD Seconds ;

                InterlockedIncrement( (LPLONG) &g_pFaxPerfCounters->InboundFaxes ) ;
                InterlockedIncrement( (LPLONG) &g_pFaxPerfCounters->TotalFaxes ) ;
                Seconds = (DWORD)( SystemTime.wSecond + 60 * ( SystemTime.wMinute + 60 * SystemTime.wHour ));
                InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->InboundPages, (LONG)pFaxStatus->dwPageCount );
                InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->TotalPages, (LONG)pFaxStatus->dwPageCount );

                EnterCriticalSection( &g_CsPerfCounters );

                g_dwInboundSeconds += Seconds;
                g_dwTotalSeconds += Seconds;
                g_pFaxPerfCounters->InboundMinutes = g_dwInboundSeconds/60 ;
                g_pFaxPerfCounters->TotalMinutes = g_dwTotalSeconds/60;
                g_pFaxPerfCounters->InboundBytes += Bytes;
                g_pFaxPerfCounters->TotalBytes += Bytes;

                LeaveCriticalSection( &g_CsPerfCounters );
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                    GetLastError());
            }
        }


        PFAX_ROUTE Route = (PFAX_ROUTE)MemAlloc( sizeof(FAX_ROUTE) );
        if (Route == NULL)
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("MemAlloc failed to allocate FAX_ROUTE (ec: %ld)"),
                    GetLastError());
            //
            //  We failed in the FaxRoute() and did not checked any Routing Method
            //
            WCHAR TmpStr[20] = {0};

            swprintf(TmpStr,TEXT("0x%016I64x"), JobQueue->UniqueId);

            FaxLog(FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                3,
                MSG_FAX_ROUTE_FAILED,
                TmpStr,
                LineInfo->DeviceName,
                pFaxStatus->lpwstrRemoteStationId
                );

        }
        else
        {
            BOOL RouteSucceeded;
            PROUTE_FAILURE_INFO RouteFailureInfo;
            DWORD CountFailureInfo;
            //
            // now setup the fax routing data structure
            //

            Route->SizeOfStruct    = sizeof(FAX_ROUTE);
            Route->JobId           = JobId;
            Route->ElapsedTime     = ElapsedTime;
            Route->ReceiveTime     = ReceiveTime;
            Route->PageCount       = pFaxStatus->dwPageCount;

            Route->Csid            = StringDup( LineInfo->Csid );
            if (LineInfo->Csid && !Route->Csid)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( LineInfo->Csid ) failed (ec: %ld)"),
                    GetLastError());
            }

            if (NULL != pFaxStatus->lpwstrRemoteStationId)
            {
                Route->Tsid = StringDup( pFaxStatus->lpwstrRemoteStationId );
                if (!Route->Tsid)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( pFaxStatus->lpwstrRemoteStationId ) ")
                        TEXT("failed (ec: %ld)"),
                        GetLastError());
                }
            }
            if (NULL != pFaxStatus->lpwstrCallerId)
            {
                Route->CallerId = StringDup( pFaxStatus->lpwstrCallerId );
                if (!Route->CallerId)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( pFaxStatus->lpwstrCallerId  ) failed ")
                        TEXT("(ec: %ld)"),
                        GetLastError());
                }
            }
            Route->ReceiverName    = StringDup( FaxReceive->ReceiverName );
            if (FaxReceive->ReceiverName && !Route->ReceiverName)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( FaxReceive->ReceiverName  ) failed ")
                    TEXT("(ec: %ld)"),
                    GetLastError());
            }
            Route->ReceiverNumber  = StringDup( FaxReceive->ReceiverNumber );
            if (FaxReceive->ReceiverNumber && !Route->ReceiverNumber)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( FaxReceive->ReceiverNumber  ) failed ")
                    TEXT("(ec: %ld)"),
                    GetLastError());
            }
            Route->DeviceName      = StringDup(LineInfo->DeviceName);
            if (LineInfo->DeviceName && !Route->DeviceName)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( LineInfo->DeviceName  ) failed ")
                    TEXT("(ec: %ld)"),
                    GetLastError());
            }
            Route->DeviceId        = LineInfo->PermanentLineID;
            if (NULL != pFaxStatus->lpwstrRoutingInfo)
            {
                Route->RoutingInfo = StringDup( pFaxStatus->lpwstrRoutingInfo );
                if (!Route->RoutingInfo)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( pFaxStatus->lpwstrRoutingInfo  ) ")
                        TEXT("failed (ec: %ld)"),
                        GetLastError());
                }
            }
            JobQueue->FaxRoute     = Route;

            RouteSucceeded = FaxRoute(
                JobQueue,
                FaxReceive->FileName,
                Route,
                &RouteFailureInfo,
                &CountFailureInfo
                );

            if ( RouteSucceeded && (CountFailureInfo == 0) )
            {
                DebugPrintEx(DEBUG_MSG,
                    _T("[Job Id: %ld] Routing SUCCEEDED."),
                    JobQueue->UniqueId);
            }
            else
            {
                DebugPrintEx(DEBUG_MSG,
                    _T("[Job Id: %ld] Routing FAILED."),
                    JobQueue->UniqueId);

                if (CountFailureInfo == 0)
                {
                    //
                    //  We failed in the FaxRoute() and did not checked any Routing Method
                    //
                    WCHAR TmpStr[20] = {0};

                    swprintf(TmpStr,TEXT("0x%016I64x"), JobQueue->UniqueId);

                    FaxLog(FAXLOG_CATEGORY_INBOUND,
                        FAXLOG_LEVEL_MIN,
                        3,
                        MSG_FAX_ROUTE_FAILED,
                        TmpStr,
                        Route->DeviceName,
                        Route->Tsid
                        );
                }
                else
                {
                    //
                    //  There are some routing methods failed
                    //

                    TCHAR QueueFileName[MAX_PATH];
                    DWORDLONG dwlUniqueId;
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("[Job Id: %ld] Routing FAILED."));

                    EnterCriticalSectionJobAndQueue;

                    //
                    // Now we turn the receive job to a routing (JT_ROUTING) job.
                    // The receive job was not committed to file but the routing job must be.
                    // So we create a FQR file for it.
                    //
                    dwlUniqueId = GenerateUniqueQueueFile( JT_ROUTING,
                                                        QueueFileName,
                                                        sizeof(QueueFileName)/sizeof(WCHAR) );
                    if (!dwlUniqueId)
                    {
                        //
                        // Failed to generate a unique id for the routing job.
                        // This is a critical error. Job will be lost when the service stops.
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("[JobId: %ld] Failed to generate unique id for routing job. (ec: %ld)"),
                            JobQueue->JobId,
                            GetLastError());
                        Assert ( JobQueue->QueueFileName == NULL );
                    }
                    else
                    {
                        JobQueue->QueueFileName = StringDup( QueueFileName );
                        if (!JobQueue->QueueFileName)
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("[JobId: %ld] StringDup( QueueFileName) failed for routing job.  (ec: %ld)"),
                                JobQueue->JobId,
                                GetLastError());

                            if (!DeleteFile (QueueFileName))
                            {
                                DebugPrintEx(
                                    DEBUG_ERR,
                                    TEXT("DeleteFile.  (ec: %ld)"),
                                    GetLastError());
                            }
                        }

                    }

                    JobQueue->CountFailureInfo = CountFailureInfo;
                    JobQueue->pRouteFailureInfo = RouteFailureInfo;
                    JobQueue->StartTime = JobEntry->StartTime;
                    JobQueue->EndTime = JobEntry->EndTime;


                    //
                    // check if we are supposed to retry.
                    //
                    EnterCriticalSection (&g_CsConfig);
                    DWORD dwMaxRetries = g_dwFaxSendRetries;
                    LeaveCriticalSection (&g_CsConfig);

                    if (0 == dwMaxRetries)
                    {
                        JobQueue->JobStatus = JS_RETRIES_EXCEEDED;

                        WCHAR TmpStr[20] = {0};
                        swprintf(TmpStr,TEXT("0x%016I64x"), JobQueue->UniqueId);

                        FaxLog(FAXLOG_CATEGORY_INBOUND,
                            FAXLOG_LEVEL_MIN,
                            3,
                            MSG_FAX_ROUTE_FAILED,
                            TmpStr,
                            JobQueue->FaxRoute->DeviceName,
                            JobQueue->FaxRoute->Tsid
                            );
                    }
                    else
                    {
                        JobQueue->JobStatus = JS_RETRYING;
                    }

                    //
                    // A job changes its type from RECEIVING to ROUTING after the 1st routing failure.
                    // This is a 2 stages change:
                    // 1. JT_RECEIVE__JS_ROUTING -> JT_RECEIVE__JS_RETRYING/JS_RETRIES_EXCEEDED
                    // 2. JT_RECEIVE__JS_RETRYING/JS_RETRIES_EXCEEDED -> JT_ROUTING__JS_RETRYING/JS_ROUTING_EXCEEDED
                    //
                    // The server activity counters g_ServerActivity are updated in the first change.
                    //
                    JobQueue->JobType = JT_ROUTING;

                    if (JobQueue->JobStatus == JS_RETRIES_EXCEEDED)
                    {
                        MarkJobAsExpired(JobQueue);
                    }
                    else
                    {
                        JobQueue->SendRetries++;
                        RescheduleJobQueueEntry( JobQueue );  // This will also commit the job to a file
                    }

                    #if DEBUG
                    WCHAR szSchedule[256] = {0};
                    DebugDateTime(JobQueue->ScheduleTime, szSchedule, ARR_SIZE(szSchedule) );
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("[JobId: %ld] Transformed into JT_ROUTING job."),
                        JobQueue->JobId,
                        szSchedule);
                    #endif //#if DEBUG

                    //
                    // CreteFaxEventEx
                    //
                    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                            JobQueue
                                            );
                    if (ERROR_SUCCESS != dwRes)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                            JobQueue->UniqueId,
                            dwRes);
                    }
                    LeaveCriticalSectionJobAndQueue;
                }
            }
        }
    }


    //
    // This code executes wether the receive operation succeeded or failed.
    // If the job suceeded we already removed the queue entry (if routing succeeded)
    // or transformed it into routing job (if routing failed).
    //

    EnterCriticalSectionJobAndQueue;
    Assert(JobQueue);

    //
    // Log Inbound Activity
    //
    EnterCriticalSection (&g_CsInboundActivityLogging);
    if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
    {
        DebugPrintEx(DEBUG_ERR,
                  TEXT("Logging not initialized"));
    }
    else
    {
        if (!LogInboundActivity(JobQueue, pFaxStatus))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("Logging inbound activity failed"));
        }
    }
    LeaveCriticalSection (&g_CsInboundActivityLogging);

    if (fCOMInitiliazed == TRUE)
    {
        CoUninitialize ();
    }

	fSystemAbort = JobEntry->fSystemAbort;
    EndJob( JobEntry);
    JobQueue->JobEntry = NULL;
    if (JobQueue->JobType == JT_RECEIVE)
    {
        //
        // Set the final receive job status
        //
        if (FALSE == DoFaxRoute)
        {
            if (FSPI_JS_ABORTED == pFaxStatus->dwJobStatus &&
				FALSE == fSystemAbort)
            {
                JobQueue->JobStatus = JS_CANCELED;
            }
            else
            {
                JobQueue->JobStatus = JS_FAILED;
            }
            wcscpy (JobQueue->ExStatusString, LastExStatusString);
            JobQueue->dwLastJobExtendedStatus = dwLastJobExtendedStatus;

            //
            // CreteFaxEventEx
            //
            dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                       JobQueue
                                     );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                    JobQueue->UniqueId,
                    dwRes);
            }
        }

        //
        // we remove the job unless it was turned into a routing job
        //
        JobQueue->JobStatus = JS_DELETING;
        DecreaseJobRefCount (JobQueue, TRUE); // TRUE means notify
    }
    LeaveCriticalSectionJobAndQueue;

    //
    // clean up and exit
    //

    MemFree( FaxReceiveItem->FileName );
    MemFree( FaxReceiveItem );
    MemFree( FaxReceive );
    if (!bFakeStatus)
    {
        MemFree( pFaxStatus );
        pFaxStatus = NULL;
    }
    else
    {
        //
        // This is a faked job status - pointing to a structure on the stack.
        //
        if (pOrigFaxStatus)
        {
            //
            // The FSP reported some status but we faked it.
            // This is a good time to also free it
            //
            MemFree (pOrigFaxStatus);
            pOrigFaxStatus = NULL;
        }
    }
    //
    // signal our queue if we now have a send capable device available.
    // (DeviceCanSend will be false if we did a RAS handoff, since the device is still in use
    //
    if (TRUE == DeviceCanSend)
    {
        // Not a handoff job - check if the device is send enabled
        EnterCriticalSection (&g_CsLine);
        DeviceCanSend = ((LineInfo->Flags & FPF_SEND) == FPF_SEND);
        LeaveCriticalSection (&g_CsLine);
    }
    if (DeviceCanSend)
    {

        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    //
    // Let the system go back to sleep. Set the system idle timer.
    //
    if (TRUE == fSetSystemIdleTimer)
    {
        if (NULL == SetThreadExecutionState(ES_CONTINUOUS))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("SetThreadExecutionState() failed"));
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return rVal;
}   // FaxReceiveThread


DWORD
StartFaxReceive(
    PJOB_ENTRY      JobEntry,
    HCALL           hCall,
    PLINE_INFO      LineInfo,
    LPTSTR          FileName,
    DWORD           FileNameSize
    )

/*++

Routine Description:

    This function start a FAX receive operation by creating
    a thread that calls the appropriate device provider.

Arguments:

    JobEntry        - Newly allocated job
    hCall           - Call handle
    LineInfo        - LINE_INFO pointer
    FileName        - Receive file name
    FileNameSize    - File name size

Return Value:

    Error code.

--*/

{
    PFAX_RECEIVE_ITEM FaxReceiveItem = NULL;
    DWORD rVal = ERROR_SUCCESS;
    HANDLE hThread;
    DWORD ThreadId;
    PJOB_QUEUE lpRecvJobQEntry=NULL;
    DWORDLONG   UniqueJobId;
    DWORD dwRes;

    DEBUG_FUNCTION_NAME(TEXT("StartFaxReceive"));

    //
    // generate a filename for the received fax
    //
    UniqueJobId = GenerateUniqueQueueFile( JT_RECEIVE, FileName, FileNameSize );
    if (UniqueJobId == 0) {
        rVal=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GenerateUniqueQueueFile for receive file has failed. (ec: %ld) "),
            GetLastError());
        goto Error;
    }


    //
    // allocate the fax receive structure
    //

    FaxReceiveItem =(PFAX_RECEIVE_ITEM) MemAlloc( sizeof(FAX_RECEIVE_ITEM) );
    if (!FaxReceiveItem)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    //
    // setup the fax receive values
    //
    FaxReceiveItem->hCall      = hCall;
    FaxReceiveItem->LineInfo   = LineInfo;
    FaxReceiveItem->JobEntry   = JobEntry;
    FaxReceiveItem->FileName   = StringDup( FileName );
    if (! FaxReceiveItem->FileName )
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( FileName ) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpRecvJobQEntry =AddReceiveJobQueueEntry(FaxReceiveItem->FileName,JobEntry,JT_RECEIVE, UniqueJobId);
    if (!lpRecvJobQEntry)
    {
         rVal = ERROR_NOT_ENOUGH_MEMORY;
         goto Error;
    }
    JobEntry->CallHandle       = hCall;
    LineInfo->State            = FPS_INITIALIZING;
    //
    //  Crete FAX_EVENT_EX.
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_ADDED,
                               lpRecvJobQEntry
                             );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_ADDED) failed for job id %ld (ec: %lc)"),
            UniqueJobId,
            dwRes);
    }


    //
    // start the receive operation
    //
    //
    // Note:
    // If FAX_ABORT happens here (no g_CsQueue protection) the job is alrady is JS_INPROGRESS state so FaxDevAbortOperation() is called.
    // The recieve thread will catch it when it calls FaxDevReceive() (it will get back an error indicating a user abort).
    // FaxReceiveThread() will then cleanup the job and remove it from the queue.
    //
    hThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxReceiveThread,
        (LPVOID) FaxReceiveItem,
        0,
        &ThreadId
        );

    if (!hThread)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create FaxReceiveThread (CreateThreadAndRefCount) (ec: %ld)"),
            GetLastError());
        MemFree( FaxReceiveItem );
        rVal = GetLastError();
        goto Error;
    }
    else
    {
        CloseHandle( hThread );
    }
    goto exit;

Error:

    //
    // EndJob() must be called before RemoveReceiveJob() !!!
    //
    EndJob(JobEntry);

    if (lpRecvJobQEntry)
    {
        lpRecvJobQEntry->JobEntry = NULL;
        DecreaseJobRefCount (lpRecvJobQEntry, FALSE); // do not notify the clients
        //
        // Note that this does not free the running job entry.
        //
    }

    if (FaxReceiveItem) {
        MemFree(FaxReceiveItem);
        MemFree(FaxReceiveItem->FileName);
    }

    FaxLog(
        FAXLOG_CATEGORY_INBOUND,
        FAXLOG_LEVEL_MIN,
        0,
        MSG_FAX_RECEIVE_FAILED
        );

exit:

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\routerule.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RouteRule.cpp

Abstract:

    This file provides implementation of the service
    outbound routing rules.

Author:

    Oded Sacher (OdedS)  Dec, 1999

Revision History:

--*/

#include "faxsvc.h"

#define STRSAFE_NO_DEPRECATE    // This allows using unsafe functions
#include <strsafe.h>

BOOL
EnumOutboundRoutingRulesCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    );


/************************************
*                                   *
*             Globals               *
*                                   *
************************************/

COutboundRulesMap* g_pRulesMap; // Map of dialing location to rule


/***********************************
*                                  *
*  CDialingLocation  Methodes      *
*                                  *
***********************************/

bool
CDialingLocation::operator < ( const CDialingLocation &other ) const
/*++

Routine name : operator <

Class: CDialingLocation

Routine description:

    Compares myself with another Dialing location key

Author:

    Oded Sacher (Odeds), Dec, 1999

Arguments:

    other           [in] - Other key

Return Value:

    true only is i'm less than the other key

--*/
{
    if (m_dwCountryCode < other.m_dwCountryCode)
    {
        return true;
    }
    if (m_dwCountryCode > other.m_dwCountryCode)
    {
        return false;
    }
    //
    // Equal country code , comapre area code
    //
    if (m_dwAreaCode < other.m_dwAreaCode)
    {
        return true;
    }
    return false;
}   // CDialingLocation::operator <




BOOL
CDialingLocation::IsValid () const
/*++

Routine name : CDialingLocation::IsValid

Routine description:

    Validates a dialing location object

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    BOOL

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CDialingLocation::IsValid"));

    if (m_dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY &&
        m_dwAreaCode != ROUTING_RULE_AREA_CODE_ANY)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Not a valid Country and Area code combination"));
        return FALSE;
    }
    return TRUE;
} // CDialingLocation::IsValidDialingLocation


LPCWSTR
CDialingLocation::GetCountryName () const
/*++

Routine name : CDialingLocation::GetCountryName

Routine description:

    Returns a pointer to the country name specifies by its country dialing code  (based on TAPI).
    The caller must  call MemFree() to deallocate memory.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    Pointer to the country name.
    If this is NULL the function failed, call GetLastError() for more info.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CDialingLocation::GetCountryName"));

    LPLINECOUNTRYLIST           lpCountryList = NULL;
    LPLINECOUNTRYENTRY          lpEntry = NULL;
    DWORD                       dwIndex;

    //
    // Get the cached all countries list.
    //
    if (!(lpCountryList = GetCountryList()))
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    lpEntry = (LPLINECOUNTRYENTRY)  // init array of entries
        ((PBYTE) lpCountryList + lpCountryList->dwCountryListOffset);

    for (dwIndex=0; dwIndex < lpCountryList->dwNumCountries; dwIndex++)
    {
        if (lpEntry[dwIndex].dwCountryCode == m_dwCountryCode)
        {
            //
            // Matching country code - copy Country name.
            //
            if (lpEntry[dwIndex].dwCountryNameSize && lpEntry[dwIndex].dwCountryNameOffset)
            {
                return StringDup ((LPWSTR) ((LPBYTE)lpCountryList + lpEntry[dwIndex].dwCountryNameOffset));
            }
        }
    }
    SetLastError (ERROR_NOT_FOUND);

exit:
    return NULL;
}  // CDialingLocation::GetCountryName


/*************************************
*                                    *
* COutboundRoutingRule Methodes      *
*                                    *
*************************************/

DWORD
COutboundRoutingRule::Init (CDialingLocation DialingLocation, wstring wstrGroupName)
/*++

Routine name : COutboundRoutingRule::Init

Routine description:

    Initialize an OutboundRoutingRule object

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    DialingLocation         [in    ] - Dialing location object to use as the rule's dialing location
    wstrGroupName           [in    ] - The group name to use as the rule's destination group

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Init"));

    try
    {
        m_wstrGroupName = wstrGroupName;
        m_bUseGroup = TRUE;
        m_DialingLocation = DialingLocation;
        return ERROR_SUCCESS;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
}

DWORD
COutboundRoutingRule::Save(HKEY hRuleKey) const
/*++

Routine name : COutboundRoutingRule::Save

Routine description:

    Saves an outbound routing rule value to the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hRuleKey           [in] - Handle to the opened rule registry key

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Save"));
    DWORD   dwRes = ERROR_SUCCESS;

    Assert (hRuleKey);

    // Save country code
    if (!SetRegistryDword( hRuleKey,
                           REGVAL_ROUTING_RULE_COUNTRY_CODE,
                           m_DialingLocation.GetCountryCode()))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryDword failed , ec %ld"), dwRes);
        goto exit;
    }

    // Save area code
    if (!SetRegistryDword( hRuleKey,
                           REGVAL_ROUTING_RULE_AREA_CODE,
                           m_DialingLocation.GetAreaCode()))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryDword failed , ec %ld"), dwRes);
        goto exit;
    }

    // // Save boolen flag whether to use group
    if (!SetRegistryDword( hRuleKey,
                           REGVAL_ROUTING_RULE_USE_GROUP,
                           m_bUseGroup ? TRUE : FALSE))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryDword failed , ec %ld"), dwRes);
        goto exit;
    }

    if (FALSE == m_bUseGroup)
    {
        // Save the device ID as the rule destination
        if (!SetRegistryDword( hRuleKey,
                               REGVAL_ROUTING_RULE_DEVICE_ID,
                               m_dwDevice))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("SetRegistryDword failed , ec %ld"), dwRes);
            goto exit;
        }
    }
    else
    {
        // Save the group name as the rule destination
        try
        {
            if (!SetRegistryString( hRuleKey,
                                    REGVAL_ROUTING_RULE_GROUP_NAME,
                                    m_wstrGroupName.c_str()))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("SetRegistryDword failed , ec %ld"), dwRes);
                goto exit;
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }
    }

    Assert (dwRes == ERROR_SUCCESS);

exit:
    return dwRes;
}  // COutboundRoutingRule::Save


DWORD
COutboundRoutingRule::Load(HKEY hRuleKey)
/*++

Routine name : COutboundRoutingRule::Load

Routine description:

    Loads an outboundrouting rule value settings from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hRuleKey           [in] - Handle to the opened registry key

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes, dwType, dwSize;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Load"));
    DWORD dwCountryCode = 0;
    DWORD dwAreaCode = 0;

    Assert (hRuleKey);


    // Read the boolen flag whether to use group
    dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_USE_GROUP,
                                (LPDWORD)&m_bUseGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading UseGroup - GetRegistryDwordEx failed with %ld"),
            dwRes);
        goto exit;
    }

    if (FALSE == m_bUseGroup)
    {
        // read the device ID as the rule destination
        dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_DEVICE_ID,
                                &m_dwDevice);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error reading device ID - GetRegistryDwordEx failed with %ld"),
                dwRes);
            goto exit;
        }

        if (0 == m_dwDevice)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid device ID"));
            dwRes = ERROR_BADDB;
            goto exit;
        }
    }
    else
    {
        // Read the group name as the rule destination
        WCHAR wszGroupName[MAX_ROUTING_GROUP_NAME + 1] = {0};

        dwRes = RegQueryValueEx(
            hRuleKey,
            REGVAL_ROUTING_RULE_GROUP_NAME,
            NULL,
            &dwType,
            NULL,
            &dwSize
            );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryValueEx failed with %ld"),
                dwRes);
            goto exit;
        }

        if (REG_SZ != dwType || dwSize > (sizeof(wszGroupName) - sizeof(WCHAR)))
        {
            // We expect only string data here
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error reading group name"));
            dwRes = ERROR_BADDB;    // The configuration registry database is corrupt.
            goto exit;
        }

        dwRes = RegQueryValueEx(
            hRuleKey,
            REGVAL_ROUTING_RULE_GROUP_NAME,
            NULL,
            &dwType,
            (LPBYTE)wszGroupName,
            &dwSize
            );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryValueEx failed with %ld"),
                dwRes);
            goto exit;
        }

        // Validate that the group exist
        PCGROUP pCGroup = g_pGroupsMap->FindGroup (wszGroupName);
        if (NULL == pCGroup)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGropsMap::FindGroup, with error - %ld"),
                dwRes);
            goto exit;
        }

        try
        {
            m_wstrGroupName = wszGroupName;
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }
    }

    // Read the country code
    dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_COUNTRY_CODE,
                                &dwCountryCode);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading Country code - GetRegistryDwordEx failed with %ld"),
            dwRes);
        goto exit;
    }

    // Read the area code
    dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_AREA_CODE,
                                &dwAreaCode);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading Area code - GetRegistryDwordEx failed with %ld"),
            dwRes);
        goto exit;
    }

    //
    // Create the DialingLocation object
    //
    m_DialingLocation =  CDialingLocation (dwCountryCode, dwAreaCode);
    if (!m_DialingLocation.IsValid())
    {
        dwRes = ERROR_INVALID_PARAMETER;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidDialingLocation failed"));
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  //  COutboundRoutingRule::Load


DWORD
COutboundRoutingRule::GetStatus (FAX_ENUM_RULE_STATUS* lpdwStatus) const
/*++

Routine name : COutboundRoutingRule::GetStatus

Routine description:

    Reports the rule's status. Can be one of FAX_ENUM_RULE_STATUS.
    Enter Critical Section (g_CsLine , g_CsConfig) before calling this function.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpdwStatus          [out   ] - Gets the rule's status on return

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::GetStatus"));
    FAX_ENUM_RULE_STATUS dwRuleStatus = FAX_RULE_STATUS_VALID;
    DWORD dwRes = ERROR_SUCCESS;
    PCGROUP pCGroup;

    if (TRUE == m_bUseGroup)
    {
        // Find the rule's destination group in the goups map
        try
        {
            pCGroup = g_pGroupsMap->FindGroup (m_wstrGroupName.c_str());
            if (NULL == pCGroup)
            {
                dwRes = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
                goto exit;
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }

        //  Get the group's status.
        FAX_ENUM_GROUP_STATUS GroupStatus;
        dwRes = pCGroup->GetStatus(&GroupStatus);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroup::GetStatus failed , ec %ld"), dwRes);
            goto exit;
        }

        switch (GroupStatus)
        {
            case FAX_GROUP_STATUS_SOME_DEV_NOT_VALID:
                dwRuleStatus = FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID;
                break;

            case FAX_GROUP_STATUS_ALL_DEV_NOT_VALID:
                dwRuleStatus = FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID;
                break;

            case FAX_GROUP_STATUS_EMPTY:
                dwRuleStatus = FAX_RULE_STATUS_EMPTY_GROUP;
                break;

            default:
                Assert (FAX_GROUP_STATUS_ALL_DEV_VALID == GroupStatus);
       }

    }
    else
    {
        // A device is the rule's destination
        if (!IsDeviceInstalled (m_dwDevice))
        {
            // Device not installed
            dwRuleStatus =  FAX_RULE_STATUS_BAD_DEVICE;
        }
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS == dwRes)
    {
        *lpdwStatus = dwRuleStatus;
    }
    return dwRes;
}  //  COutboundRoutingRule::GetStatus


DWORD
COutboundRoutingRule::GetDeviceList (LPDWORD* lppdwDevices, LPDWORD lpdwNumDevices) const
/*++

Routine name : COutboundRoutingRule::GetDeviceList

Routine description:

    Returns an ordered device list, which are the rule's destination devices.
    The caller must call MemFree() to deallocate the memory.
    Enter Critical Section (g_CsConfig) before calling this function.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lppdwDevices            [out   ] - Pointer to pointer to a DWORD buffer to recieve the devices list.
    lpdwNumDevices          [out   ] - Pointer to a DWORD to recieve the number of devices returned

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::GetDeviceList"));
    DWORD dwRes = ERROR_SUCCESS;
    PCGROUP pCGroup;

    Assert (lppdwDevices && lpdwNumDevices);

    *lppdwDevices = NULL;
    *lpdwNumDevices = 0;

    if (TRUE == m_bUseGroup)
    {
        // A group is the rule's destination
        try
        {
            pCGroup = g_pGroupsMap->FindGroup (m_wstrGroupName.c_str());
            if (NULL == pCGroup)
            {
                dwRes = GetLastError();
                Assert (FAX_ERR_GROUP_NOT_FOUND != dwRes);

                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
                goto exit;
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }

        // Get the group's device list
        dwRes = pCGroup->SerializeDevices (lppdwDevices, lpdwNumDevices);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroup::SerializeDevices failed with %ld"),
                dwRes);
            goto exit;
        }
    }
    else
    {
        // A single device
        *lppdwDevices = (LPDWORD) MemAlloc(sizeof(DWORD));
        if (*lppdwDevices == NULL)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate devices buffer"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        *(*lppdwDevices) = m_dwDevice;
        *lpdwNumDevices = 1;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  //  COutboundRoutingRule::GetDeviceList


DWORD
COutboundRoutingRule::Serialize (LPBYTE lpBuffer,
                                 PFAX_OUTBOUND_ROUTING_RULEW pFaxRule,
                                 PULONG_PTR pupOffset,
								 DWORD dwBufferSize) const
/*++

Routine name : COutboundRoutingRule::Serialize

Routine description:

    Serializes a rule's info based on FAX_OUTBOUND_ROUTING_RULEW structure.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpBuffer            [in] - Pointer to a pre-allocated buffer. If this parameter is NULL lpdwOffset will get the required buffer size.
    pFaxRule            [in] - Pointer to a specific FAX_OUTBOUND_ROUTING_RULEW structure in the buffer
    pupOffset           [in/out] - Offset from the begining of the buffer where variable length info is stored
	DWORD dwBufferSize  [in] - the size of input buffer, lpBuffer.  

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Serialize"));
    DWORD dwRes = ERROR_SUCCESS;
    const CDialingLocation DialingLocation = GetDialingLocation();
    LPCWSTR lpcwstrCountryName = NULL;
    LPCWSTR lpwstrGroupName;

    Assert (pupOffset);
	if (NULL != lpBuffer)
	{
		Assert (0 != dwBufferSize);
	}

    if (ROUTING_RULE_COUNTRY_CODE_ANY != DialingLocation.GetCountryCode())
    {
        // Get the country name
        lpcwstrCountryName = DialingLocation.GetCountryName();
        if (NULL == lpcwstrCountryName)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingRule::GetCountryName failed , ec %ld"), GetLastError());
        }
    }

    try
    {
        lpwstrGroupName = m_bUseGroup ? m_wstrGroupName.c_str() : NULL;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        MemFree ((void*)lpcwstrCountryName);
        return ERROR_GEN_FAILURE;
    }

    StoreString (lpcwstrCountryName,
                 (PULONG_PTR)&(pFaxRule->lpctstrCountryName),
                 lpBuffer,
                 pupOffset,
				 dwBufferSize);

    if (TRUE == m_bUseGroup)
    {
        StoreString (lpwstrGroupName,
                     (PULONG_PTR)&((pFaxRule->Destination).lpcstrGroupName),
                     lpBuffer,
                     pupOffset,
					 dwBufferSize);
    }

    if (NULL != lpBuffer)
    {
        // Write the data
        Assert (pFaxRule);

        if (FALSE == m_bUseGroup)
        {
            Assert (m_dwDevice);
            (pFaxRule->Destination).dwDeviceId = m_dwDevice;
        }
        pFaxRule->dwSizeOfStruct = sizeof (FAX_OUTBOUND_ROUTING_RULEW);
        pFaxRule->dwAreaCode = DialingLocation.GetAreaCode();
        pFaxRule->dwCountryCode = DialingLocation.GetCountryCode();
        pFaxRule->bUseGroup = m_bUseGroup;
        dwRes = GetStatus (&(pFaxRule->Status));
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingRule::GetStatus failed , ec %ld"), dwRes);
        }
    }

    MemFree ((void*)lpcwstrCountryName);
    return dwRes;
}  // COutboundRoutingRule::Serialize


LPCWSTR
COutboundRoutingRule::GetGroupName () const
/*++

Routine name : COutboundRoutingRule::GetGroupName

Routine description:

    Returns the group name if the rule's destination is a group.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    The group name. If it is NULL call GetLastError() for more info.
    If it is ERROR_SUCCESS the rule's destination is single device.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::GetGroupName"));
    try
    {
        SetLastError (ERROR_SUCCESS);
        if (TRUE == m_bUseGroup)
        {
            return m_wstrGroupName.c_str();
        }
        return NULL;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
}  // GetGroupName




#if DBG
void COutboundRoutingRule::Dump () const
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Dump"));
    WCHAR Buffer[512] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    try
    {
        if (TRUE == m_bUseGroup)
        {
            _snwprintf (Buffer, dwBufferSize -1, TEXT("\tCountry Code - %ld,\tArea Code - %ld,\tGroup name - %s"),
                        m_DialingLocation.GetCountryCode(),
                        m_DialingLocation.GetAreaCode(),
                        m_wstrGroupName.c_str());
        }
        else
        {
            _snwprintf (Buffer, dwBufferSize -1, TEXT("\tCountry Code - %ld,\tArea Code - %ld,\tDevice ID - %ld"),
                        m_DialingLocation.GetCountryCode(),
                        m_DialingLocation.GetAreaCode(),
                        m_dwDevice);
        }
        OutputDebugString (Buffer);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
    }
    return;
}
#endif  // #if DBG

/***********************************
*                                  *
*  COutboundRulesMap  Methodes     *
*                                  *
***********************************/

DWORD
COutboundRulesMap::Load ()
/*++

Routine name : COutboundRulesMap::Load

Routine description:

    Loads all outbound routing rules from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::Load"));
    DWORD   dwRes = ERROR_SUCCESS;
    HKEY    hRuleskey = NULL;
    DWORD dwCount = 0;

    hRuleskey = OpenRegistryKey(  HKEY_LOCAL_MACHINE,
                                  REGKEY_FAX_OUTBOUND_ROUTING,
                                  FALSE,
                                  KEY_READ | KEY_WRITE );
    if (NULL == hRuleskey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey, error  %ld"),
            dwRes);
        return dwRes;
    }

    dwCount = EnumerateRegistryKeys( hRuleskey,
                                     REGKEY_OUTBOUND_ROUTING_RULES,
                                     FALSE,
                                     EnumOutboundRoutingRulesCB,
                                     &dwRes
                                    );

    if (dwRes != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnumerateRegistryKeys failed, error  %ld"),
            dwRes);
    }

    RegCloseKey (hRuleskey);
    return dwRes;
}  // COutboundRulesMap::Load


DWORD
COutboundRulesMap::AddRule (COutboundRoutingRule& Rule)
/*++

Routine name : COutboundRulesMap::AddRule

Routine description:

    Adds a new rule to the global map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    Rule            [in    ] - A reference to the new rule object

Return Value:

    Standard Win32 error code

--*/
{
    RULES_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoulesMap::AddRule"));
    pair <RULES_MAP::iterator, bool> p;

    try
    {
        //
        // Add new map entry
        //
        p = m_RulesMap.insert (RULES_MAP::value_type(Rule.GetDialingLocation(), Rule));

        //
        // See if entry exists in map
        //
        if (p.second == FALSE)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Rule allready in the rules map"));
            dwRes = ERROR_DUP_NAME;
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  // COutboundRulesMap::AddRule



DWORD
COutboundRulesMap::DelRule (CDialingLocation& DialingLocation)
/*++

Routine name : COutboundRulesMap::DelRule

Routine description:

    Deletes a group from the global rules map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    DialingLocation            [in ] - Pointer to the dialing location key

Return Value:

    Standard Win32 error code

--*/
{
    RULES_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::DelRule"));

    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_RulesMap.find(DialingLocation)) == m_RulesMap.end())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("rule is not in the rules map"));
            dwRes = FAX_ERR_RULE_NOT_FOUND;
            goto exit;
        }

        //
        // Delete the map entry
        //
        m_RulesMap.erase (it);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;

}  //  COutboundRulesMap::DelRule

PCRULE
COutboundRulesMap::FindRule (CDialingLocation& DialingLocation) const
/*++

Routine name : COutboundRulesMap::FindRule

Routine description:

    Returns a pointer to a rule object specified by its name

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    DialingLocation            [in] - The rule's dialing location

Return Value:

    Pointer to the found rule object. If it is null the rule was not found

--*/
{
    RULES_MAP::iterator it;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::FindRule"));

    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_RulesMap.find(DialingLocation)) == m_RulesMap.end())
        {
            SetLastError (FAX_ERR_RULE_NOT_FOUND);
            return NULL;
        }
        return &((*it).second);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
}  //  COutboundRulesMap::FindRule


DWORD
COutboundRulesMap::SerializeRules (PFAX_OUTBOUND_ROUTING_RULEW* ppRules,
                                   LPDWORD lpdwNumRules,
                                   LPDWORD lpdwBufferSize) const
/*++

Routine name : COutboundRulesMap::SerializeRules

Routine description:

    Serializes all the rules in the rules map.
    the caller must call MemFree() to deallocate memory.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    ppRules         [out   ] - Pointer to a pointer to recieve the FAX_OUTBOUND_ROUTING_RULEW buffer
    lpdwNumRules    [out   ] - Pointer to a DWORD to recieve the number of rules serialized
    lpdwBufferSize  [out   ] - Pointer to DWORD to recieve the size of the allocated buffer

Return Value:

    Standard Win32 error code

--*/
{
    RULES_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::SerializeRules"));
    DWORD_PTR dwSize = 0;
    DWORD dwCount = 0;
    PCRULE pCRule;

    Assert (ppRules && lpdwNumRules && lpdwBufferSize);

    *ppRules = NULL;
    *lpdwNumRules = 0;

    try
    {
        // Calculate buffer size
        for (it = m_RulesMap.begin(); it != m_RulesMap.end(); ++it)
        {
            pCRule = &((*it).second);

            dwSize += sizeof (FAX_OUTBOUND_ROUTING_RULEW);
            dwRes = pCRule->Serialize (NULL, NULL, &dwSize, 0);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingRule::Serialize failed with %ld"),
                    dwRes);
                goto exit;
            }
            dwCount ++;
        }
        

        //
        //  dwCount can't be 0 - there is always a default rule
        //
        Assert ( dwCount != 0 );

        if ( 0 == dwCount )
        {
            //
            // Somthing wrong we have no outbound routing rule
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRulesMap::SerializeRules, No outbound rules have been found."));
            dwRes = ERROR_INVALID_DATA;
            goto exit;
        }


        // Allocate buffer
        *ppRules = (PFAX_OUTBOUND_ROUTING_RULEW) MemAlloc (dwSize);
        if (NULL == *ppRules)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate rules buffer"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        ZeroMemory(*ppRules, dwSize);

        DWORD_PTR dwOffset = dwCount * sizeof (FAX_OUTBOUND_ROUTING_RULEW);
        dwCount = 0;

        // Fill buffer with serialized info
        for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
        {
            pCRule = &((*it).second);

            (*ppRules)[dwCount].dwSizeOfStruct = DWORD(sizeof (FAX_OUTBOUND_ROUTING_RULEW));
            dwRes = pCRule->Serialize ((LPBYTE)*ppRules, &((*ppRules)[dwCount]), &dwOffset, dwSize);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingRule::Serialize failed with %ld"),
                    dwRes);
                goto exit;
            }
            dwCount++;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    *lpdwNumRules = dwCount;

    // until MIDL accepts [out, size_is(,__int64*)]
    *lpdwBufferSize = (DWORD)dwSize;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (*ppRules);
    }
    return dwRes;
}  //  COutboundRulesMap::SerializeRules


BOOL
COutboundRulesMap::CreateDefaultRule (void)
/*++

Routine name : COutboundRulesMap::CreateDefaultRule

Routine description:

    Creates the default mandatory rule (All CountryCodes, All AreaCodes) if does not exist.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    BOOL , Call GetLastError () for more info

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::CreateDefaultRule"));
    PCRULE pCRule;
    CDialingLocation Dialinglocation (ROUTING_RULE_COUNTRY_CODE_ANY, ROUTING_RULE_AREA_CODE_ANY);
    FAX_ENUM_RULE_STATUS dwRuleStatus;
    HKEY hRuleKey = NULL;
    DWORD rVal;

    pCRule = FindRule (Dialinglocation);
    if (NULL != pCRule)
    {
        // Rule exist
        return TRUE;
    }
    dwRes = GetLastError();
    if (FAX_ERR_RULE_NOT_FOUND != dwRes)
    {
        // general failure
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRulesMap::FindRule failed , ec %ld"), dwRes);
        return FALSE;
    }
    dwRes = ERROR_SUCCESS;
    //
    // Rule does not exist - Create it
    //

    // Create the rule registry key
    hRuleKey = OpenOutboundRuleKey( ROUTING_RULE_COUNTRY_CODE_ANY, ROUTING_RULE_AREA_CODE_ANY, TRUE, KEY_READ | KEY_WRITE );
    if (NULL == hRuleKey)
    {
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create rule key, OpenRegistryKey failed  : %ld"),
          GetLastError ());
        return FALSE;
    }

    COutboundRoutingRule Rule;
    try
    {
        wstring wstrGroupName (ROUTING_GROUP_ALL_DEVICES);
        dwRes = Rule.Init (Dialinglocation, wstrGroupName);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingRule::Init failed , ec %ld"), dwRes);
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    dwRes = AddRule (Rule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingRule::AddRule failed , ec %ld"), dwRes);
        goto exit;
    }

    // Save the new rule to the registry
    dwRes = Rule.Save (hRuleKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Save failed,  with %ld"),
            dwRes);
        g_pRulesMap->DelRule (Dialinglocation);
        goto exit;
    }

    rVal = Rule.GetStatus (&dwRuleStatus);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingRule::GetStatus failed , ec %ld"), rVal);
    }
    else
    {
        if (dwRuleStatus != FAX_RULE_STATUS_VALID &&
            dwRuleStatus != FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID)
        {
            // Can be if <All devices> is empty (The service has no devices).
            DebugPrintEx(
                   DEBUG_MSG,
                   TEXT("Bad default rule configuration, FAX_RULE_STATUS %ld"), dwRuleStatus);

            FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MED,
                2,
                MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION,
                TEXT("*"),
                TEXT("*")
                );
        }
    }

     Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hRuleKey)
    {
        RegCloseKey (hRuleKey);
    }

    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError(dwRes);
    }

    return (ERROR_SUCCESS == dwRes);
}  //  CreateDefaultRule

DWORD
COutboundRulesMap::IsGroupInRuleDest (LPCWSTR lpcwstrGroupName , BOOL* lpbGroupInRule) const
/*++

Routine name : COutboundRulesMap::IsGroupInRuleDest

Routine description:

    Checks if a specific group is a destination of one of the rules

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [in ] - Group name
    lpbGroupInRule              [out] - Pointer to a BOOL. Gets TRUE if the group is in rule, else FALSE

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::IsGroupInRuleDest"));
    RULES_MAP::iterator it;

    Assert (lpbGroupInRule);
    try
    {
        for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
        {
            PCRULE pCRule = &((*it).second);
            LPCWSTR lpcwstrRuleGroupName = pCRule->GetGroupName();
            if (NULL == lpcwstrRuleGroupName)
            {
                dwRes = GetLastError();
                if (dwRes != ERROR_SUCCESS)
                {
                    DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingRule::GetGroupName failed , ec %ld"), dwRes);
                    return dwRes;
                }
                else
                {
                    // This rule uses a single device as its destination
                }
                continue;
            }

            if (wcscmp (lpcwstrGroupName, lpcwstrRuleGroupName) == 0)
            {
                *lpbGroupInRule = TRUE;
                return ERROR_SUCCESS;
            }
        }
        *lpbGroupInRule = FALSE;
        return ERROR_SUCCESS;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
}  //  IsGroupInRuleDest



#if DBG
void COutboundRulesMap::Dump () const
{
    RULES_MAP::iterator it;
    WCHAR Buffer[512] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    _snwprintf (Buffer, dwBufferSize -1, TEXT("DUMP - Outbound routing rules\n"));
    OutputDebugString (Buffer);

    for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
    {
        ((*it).second).Dump();
        OutputDebugString (TEXT("\n"));
    }
    return;
}
#endif   // #if DBG


void
FaxLogOutboundRule (LPCWSTR  lpcwstrRuleName,
                    DWORD   dwMessageID)
{
    WCHAR wszRuleName[MAX_PATH] = {0};
    LPWSTR lpwstrCountryCode;
    LPWSTR lpwstrAreaCode;
    LPWSTR lpwstrDelim = NULL;
    DWORD dwLevel = FAXLOG_LEVEL_MIN;

    Assert (lpcwstrRuleName);
    Assert (dwMessageID == MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION ||
            dwMessageID == MSG_OUTBOUND_ROUTING_RULE_NOT_LOADED ||
            dwMessageID == MSG_OUTBOUND_ROUTING_RULE_NOT_ADDED);


    if (dwMessageID == MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION)
    {
        dwLevel = FAXLOG_LEVEL_MED;
    }

    if (FAILED(StringCchCopy(wszRuleName, ARR_SIZE(wszRuleName), lpcwstrRuleName)))
    {
        ASSERT_FALSE;
        return;
    }

    lpwstrDelim = wcschr (wszRuleName, L':');
    if (NULL == lpwstrDelim)
    {
        //
        // Registry corruption
        //
        ASSERT_FALSE;
        return;

    }

    lpwstrCountryCode = wszRuleName;
    *lpwstrDelim = L'\0';
    lpwstrDelim ++;
    lpwstrAreaCode = lpwstrDelim;

    if (wcscmp( lpwstrAreaCode, TEXT("0")) == 0  )
    {
        wcscpy ( lpwstrAreaCode, TEXT("*"));
    }

    if (wcscmp( lpwstrCountryCode, TEXT("0")) == 0  )
    {
        wcscpy ( lpwstrCountryCode, TEXT("*"));
    }

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        dwLevel,
        2,
        dwMessageID,
        lpwstrCountryCode,
        lpwstrAreaCode
        );

    return;
}


/************************************
*                                   *
*             Registry              *
*                                   *
************************************/

BOOL
EnumOutboundRoutingRulesCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    )
{
    DEBUG_FUNCTION_NAME(TEXT("EnumOutboundRoutingGroupsCB"));
    DWORD dwRes;
    COutboundRoutingRule Rule;
    BOOL bRuleDeleted = FALSE;


    if (!SubKeyName)
    {
        return TRUE;
    }

    //
    // Add rule
    //
    dwRes = Rule.Load (hSubKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Load failed, rule - %s, error %ld"),
            SubKeyName,
            dwRes);

        // Open Outbound Routing\Rules key
        HKEY hRulesKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                          REGKEY_FAX_OUTBOUND_ROUTING_RULES,
                                          FALSE,
                                          KEY_READ | KEY_WRITE | DELETE);
        if (NULL == hRulesKey)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey, error  %ld"),
                dwRes);
        }
        else
        {
            DWORD dwRetVal = RegDeleteKey (hRulesKey, SubKeyName);
            if (ERROR_SUCCESS != dwRetVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RegDeleteKey failed, Rule name - %s,  error %ld"),
                    SubKeyName,
                    dwRetVal);
            }
            else
            {
                bRuleDeleted = TRUE;
            }
        }
        goto exit;
    }

    //
    // Check on which platform are we running
    //
    if ((Rule.GetDialingLocation()).GetCountryCode() != ROUTING_RULE_COUNTRY_CODE_ANY &&
        TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs. Only load default rule *.* (*.AreaCode is not loaded anyway)
        //
        goto exit;
    }

    FAX_ENUM_RULE_STATUS RuleStatus;
    dwRes = Rule.GetStatus(&RuleStatus);
    if (ERROR_SUCCESS == dwRes)
    {
        if (RuleStatus != FAX_RULE_STATUS_VALID &&
            RuleStatus != FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID)
        {
            FaxLogOutboundRule (SubKeyName, MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION);
        }
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::GetStatus failed, error %ld"),
            dwRes);
    }

    dwRes = g_pRulesMap->AddRule  (Rule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundrulesMap::Addrule failed, rule name - %s, error %ld"),
            SubKeyName,
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (bRuleDeleted == FALSE)
        {
            FaxLogOutboundRule (SubKeyName, MSG_OUTBOUND_ROUTING_RULE_NOT_ADDED);
        }
        else
        {
            FaxLogOutboundRule (SubKeyName, MSG_OUTBOUND_ROUTING_RULE_NOT_LOADED);
        }
    }
    *(LPDWORD)pContext = ERROR_SUCCESS; // Let the service start
    return TRUE; // Let the service start

}  //  EnumOutboundRoutingRulesCB




/************************************
*                                   *
*         RPC handlers              *
*                                   *
************************************/

error_status_t
FAX_AddOutboundRule(
    HANDLE      hFaxHandle,
    DWORD       dwAreaCode,
    DWORD       dwCountryCode,
    DWORD       dwDeviceID,
    LPCWSTR     lpcwstrGroupName,
    BOOL        bUseGroup
    )
/*++

Routine name : FAX_AddOutboundRule

Routine description:

    Adds a new rule to the rules map and to the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Fax handle
    dwAreaCode          [in    ] - The rule area code
    dwCountryCode           [in    ] - The rule country code
    dwDeviceID          [in    ] - The rule's destinationis device ID. Valid only if bUseGroup is FALSE
    lpcwstrGroupName            [in    ] - The rule's destination group name. Valid only if bUseGroup is TRUE.
    bUseGroup           [in    ] - Flag that indicates whether to use the group as the rule destination

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AddOutboundRule"));
    HKEY hRuleKey = NULL;
    DWORD rVal;
    BOOL fAccess;

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY)
    {
        //
        // *.* can not be added; *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwCountryCode = 0; *.* can not be added; *.AreaCode is not a valid rule dialing location"));
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    if (TRUE == bUseGroup)
    {
        if (!lpcwstrGroupName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lpctstrGroupName is NULL"));
            return ERROR_INVALID_PARAMETER;
        }

        if (wcslen (lpcwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
            return ERROR_BUFFER_OVERFLOW;
        }
    }
    else
    {
        if (!dwDeviceID)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwDeviceId = 0; Not a valid device ID"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    // Create a new Dialinglocation object
    CDialingLocation Dialinglocation (dwCountryCode, dwAreaCode);
    if (!Dialinglocation.IsValid())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CDialingLocation::IsValidDialingLocation failed, \
                  Area code %ld, Country code %ld"),
            dwAreaCode,
            dwCountryCode);
       return ERROR_INVALID_PARAMETER;
    }

    // Create a new rule object
    COutboundRoutingRule Rule;
    if (TRUE == bUseGroup)
    {
        try
        {
            wstring wstrGroupName(lpcwstrGroupName);
            dwRes = Rule.Init (Dialinglocation, wstrGroupName);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingRule::Init failed , ec %ld"), dwRes);
                return GetServerErrorCode(dwRes);
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            return ERROR_GEN_FAILURE;
        }
    }
    else
    {
        Rule.Init (Dialinglocation ,dwDeviceID);
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

    FAX_ENUM_RULE_STATUS RuleStatus;
    dwRes = Rule.GetStatus(&RuleStatus);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoule::GetStatus failed, error %ld"),
            dwRes);
        goto exit;
    }

    if (FAX_GROUP_STATUS_ALL_DEV_NOT_VALID == RuleStatus  ||
        FAX_RULE_STATUS_EMPTY_GROUP == RuleStatus)
    {
        // Empty group device list
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), RuleStatus);
        dwRes = FAX_ERR_BAD_GROUP_CONFIGURATION;
        goto exit;
    }

    if (FAX_RULE_STATUS_BAD_DEVICE == RuleStatus)
    {
        // Bad device
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), RuleStatus);
        dwRes = ERROR_BAD_UNIT;
        goto exit;
    }

    // Create the rule registry key
    hRuleKey = OpenOutboundRuleKey( dwCountryCode, dwAreaCode, TRUE, KEY_READ | KEY_WRITE );
    if (NULL == hRuleKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create rule key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    // Add the new rule to the map
    dwRes = g_pRulesMap->AddRule (Rule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoulesMap::AddRule failed, error %ld"),
            dwRes);
        goto exit;
    }

    // Save the new rule to the registry
    dwRes = Rule.Save (hRuleKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Save failed,  with %ld"),
            dwRes);
        g_pRulesMap->DelRule (Dialinglocation);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }


#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing rules - after change"));
    g_pRulesMap->Dump();
#endif

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_RULES);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_RULES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hRuleKey)
    {
        RegCloseKey (hRuleKey);
    }
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
} // FAX_AddOutboundRule



error_status_t
FAX_RemoveOutboundRule (
    IN handle_t                   hFaxHandle,
    IN DWORD                      dwAreaCode,
    IN DWORD                      dwCountryCode
    )
/*++

Routine name : FAX_RemoveOutboundRule

Routine description:

    Removes an existing rule from the rules map and from the registry.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Fax handle
    dwAreaCode          [in] - The rule area code
    dwCountryCode       [in] - The rule country code

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RemoveOutboundRule"));
    DWORD rVal;
    PCRULE pCRule = NULL;

    BOOL fAccess;

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY)
    {
        //
        // *.* can not be removed; *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwCountryCode = 0; *.* can not be added; *.AreaCode is not a valid rule dialing location"));
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    CDialingLocation Dialinglocation (dwCountryCode, dwAreaCode);

    EnterCriticalSection (&g_CsConfig);

    pCRule = g_pRulesMap->FindRule (Dialinglocation);
    if (NULL == pCRule)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoulesMap::FindRule failed, error %ld"),
            dwRes);
       goto exit;
    }

    // Delete the specified rule key
    dwRes = DeleteOutboundRuleKey (dwCountryCode, dwAreaCode);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DeleteOutboundRuleKey failed, CountryCode - %ld,  AreaCode - %ld, error %ld"),
            dwCountryCode,
            dwAreaCode,
            dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    // Delete the rule from the memory
    dwRes = g_pRulesMap->DelRule (Dialinglocation);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRulesMap::DelRule failed,  error %ld"),
            dwRes);
        goto exit;
    }


#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing rules - after change"));
    g_pRulesMap->Dump();
#endif

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_RULES);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_RULES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);


exit:
    LeaveCriticalSection (&g_CsConfig);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return dwRes;
} // FAX_RemoveOutboundRule



error_status_t
FAX_SetOutboundRule(
    HANDLE                              hFaxHandle,
    PRPC_FAX_OUTBOUND_ROUTING_RULEW     pRule
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD rVal;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetOutboundRule"));
    HKEY hRuleKey = NULL;
    PCRULE pCRule = NULL;
    FAX_ENUM_RULE_STATUS dwRuleStatus;
    BOOL fAccess;

    Assert (pRule);

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (TRUE == pRule->bUseGroup)
    {
        if (!(pRule->Destination).lpwstrGroupName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lpwstrGroupName is NULL"));
            return ERROR_INVALID_PARAMETER;
        }

        if (wcslen ((pRule->Destination).lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
            return ERROR_BUFFER_OVERFLOW;
        }
    }
    else
    {
        if (!(pRule->Destination).dwDeviceId)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwDeviceId = 0; Not a valid device ID"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    CDialingLocation Dialinglocation (pRule->dwCountryCode, pRule->dwAreaCode);

    COutboundRoutingRule Rule, OldRule;
    if (TRUE == pRule->bUseGroup)
    {
        try
        {
            wstring wstrGroupName((pRule->Destination).lpwstrGroupName);
            dwRes = Rule.Init (Dialinglocation, wstrGroupName);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingRule::Init failed , ec %ld"), dwRes);
                return GetServerErrorCode(dwRes);
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            return ERROR_GEN_FAILURE;
        }
    }
    else
    {
        Rule.Init (Dialinglocation ,(pRule->Destination).dwDeviceId);
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

    // Check the new rule status
    dwRes = Rule.GetStatus (&dwRuleStatus);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingRule::GetStatus failed , ec %ld"), dwRes);
        goto exit;
    }

    if (FAX_GROUP_STATUS_ALL_DEV_NOT_VALID == dwRuleStatus  ||
        FAX_RULE_STATUS_EMPTY_GROUP == dwRuleStatus)
    {
        // Empty group device list
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), dwRuleStatus);
        dwRes = FAX_ERR_BAD_GROUP_CONFIGURATION;
        goto exit;
    }

    if (FAX_RULE_STATUS_BAD_DEVICE == dwRuleStatus)
    {
        // Bad device
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), dwRuleStatus);
        dwRes = ERROR_BAD_UNIT;
        goto exit;
    }

    pCRule = g_pRulesMap->FindRule (Dialinglocation);
    if (NULL == pCRule)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoulesMap::FindRule failed, error %ld"),
            dwRes);
       goto exit;
    }

    // Open the rule registry key
    hRuleKey = OpenOutboundRuleKey( pRule->dwCountryCode, pRule->dwAreaCode, FALSE, KEY_READ | KEY_WRITE );
    if (NULL == hRuleKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't open rule key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    OldRule = *pCRule;
    *pCRule = Rule;

    dwRes = pCRule->Save (hRuleKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Save failed,  with %ld"),
            dwRes);
        *pCRule = OldRule;
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }


#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing rules - after change"));
    g_pRulesMap->Dump();
#endif

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_RULES);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_RULES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hRuleKey)
    {
        RegCloseKey (hRuleKey);
    }
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
} // FAX_FaxSetOutboundRule




error_status_t
FAX_EnumOutboundRules (
    handle_t                             hFaxHandle,
    LPBYTE*                              ppBuffer,
    LPDWORD                              lpdwBufferSize,
    LPDWORD                              lpdwNumRules
    )
/*++

Routine name : FAX_EnumOutboundRules

Routine description:

    Enumurates all outbound routing rules

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Fax server handle
    ppBuffer            [out   ] - Adress of a pointer to a buffer to be filled with info
    lpdwBufferSize          [in/out] - The buffer size
    lpdwNumGroups           [out   ] - Number of rules returned

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumOutboundRules"));
    BOOL fAccess;

    Assert (lpdwNumRules && lpdwBufferSize);    // ref pointer in idl
    if (!ppBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    *ppBuffer = NULL;
    *lpdwNumRules = 0;

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

    dwRes = g_pRulesMap->SerializeRules ((PFAX_OUTBOUND_ROUTING_RULEW*)ppBuffer,
                                        lpdwNumRules,
                                        lpdwBufferSize);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRulesMap::SerializeRules failed, error %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);

}  //FAX_EnumOutboundGroups
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\routegroup.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    OutRoute.cpp

Abstract:

    This file provides implementation of the service
    outbound routing.

Author:

    Oded Sacher (OdedS)  Nov, 1999

Revision History:

--*/

#include "faxsvc.h"

BOOL
EnumOutboundRoutingGroupsCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    );


inline
BOOL
IsDeviceInstalled (DWORD dwDeviceId)
{
    // Make sure to lock g_CsLine
    return (GetTapiLineFromDeviceId (dwDeviceId, FALSE)) ? TRUE : FALSE;
}

/************************************
*                                   *
*             Globals               *
*                                   *
************************************/

COutboundRoutingGroupsMap* g_pGroupsMap; // Map of group name to list of device IDs


/***********************************
*                                  *
*  COutboundRoutingGroup  Methodes *
*                                  *
***********************************/
DWORD
COutboundRoutingGroup::Load(HKEY hGroupKey, LPCWSTR lpcwstrGroupName)
/*++

Routine name : COutboundRoutingGroup::Load

Routine description:

    Loads an outboundrouting group's settings from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hGroupKey           [in] - Handle to the opened registry key
    lpcwstrGroupName    [in] - Group name

Return Value:

    Standard Win32 error code

--*/
{
    LPBYTE lpBuffer = NULL;
    DWORD dwRes;
	DWORD dwType;
	DWORD dwSize=0;
	DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::Load"));

    Assert (hGroupKey);

    dwRes = RegQueryValueEx(
        hGroupKey,
        REGVAL_ROUTING_GROUP_DEVICES,
        NULL,
        &dwType,
        NULL,
        &dwSize
        );

    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx  failed with %ld"),
            dwRes);
        goto exit;
    }
    if (REG_BINARY != dwType)
    {
        //
        // We expect only binary data here
        //
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading devices list, not a binary type"));
        dwRes = ERROR_BADDB;    // The configuration registry database is corrupt.
        goto exit;
    }

    if (0 != dwSize)
    {
        //
        // Allocate required buffer
        //
        lpBuffer = (LPBYTE) MemAlloc( dwSize );
        if (!lpBuffer)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate group devices buffer"));
            goto exit;
        }
        //
        // Read the data
        //
        dwRes = RegQueryValueEx(
            hGroupKey,
            REGVAL_ROUTING_GROUP_DEVICES,
            NULL,
            &dwType,
            lpBuffer,
            &dwSize
            );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryValueEx failed with %ld"),
                dwRes);
            goto exit;
        }

        LPDWORD lpdwDevices = (LPDWORD)lpBuffer;
        DWORD dwNumDevices = dwSize/sizeof(DWORD);
        BOOL fDeviceInstalled = TRUE;

        for (i = 0; i < dwNumDevices; i++)
        {
            if (IsDeviceInstalled(lpdwDevices[i]))
            {
                //
                // Add the device only if it is installed
                //
                dwRes = AddDevice (lpdwDevices[i]);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("COutboundRoutingGroup::AddDevice failed with %ld"),
                        dwRes);
                    goto exit;
                }
            }
            else
            {
                fDeviceInstalled = FALSE;
            }
        }

        if (FALSE == fDeviceInstalled)
        {
            //
            // Save the new configuration
            //
            DWORD ec = Save(hGroupKey);
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::Save failed with %ld"),
                    ec);
            }

            FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MED,
            1,
            MSG_BAD_OUTBOUND_ROUTING_GROUP_CONFIGURATION,
            lpcwstrGroupName
            );
        }
    }
    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree (lpBuffer);
    return dwRes;
}


DWORD
COutboundRoutingGroup::GetStatus (FAX_ENUM_GROUP_STATUS* lpStatus) const
/*++

Routine name : COutboundRoutingGroup::GetStatus

Routine description:

    Retrieves the group status. Caller must lock g_CsConfig

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpStatus     [out] - Pointer to a FAX_ENUM_GROUP_STATUS to recieve the group status



Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::GetStatus"));
    DWORD dwNumDevices;

    Assert (lpStatus);

    try
    {
        if ((dwNumDevices = m_DeviceList.size()) == 0)
        {
            //
            // Empty group
            //
            *lpStatus = FAX_GROUP_STATUS_EMPTY;

        }
        else
        {
            //
            // We remove invalid devices from groups - All devices are valid.
            //
            *lpStatus = FAX_GROUP_STATUS_ALL_DEV_VALID;
        }
        return ERROR_SUCCESS;
    }

    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
}  // GetStatus

DWORD
COutboundRoutingGroup::Save(HKEY hGroupKey) const
/*++

Routine name : COutboundRoutingGroup::Save

Routine description:

    Saves an outbound routing group to the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hGroupKey           [in] - Handle to the opened group registry key

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::Save"));
    DWORD   dwRes = ERROR_SUCCESS;
    LPDWORD lpdwDevices = NULL;
    DWORD dwNumDevices = 0;

    Assert (hGroupKey);

    dwRes = SerializeDevices (&lpdwDevices, &dwNumDevices);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::EnumDevices failed , ec %ld"), dwRes);
        goto exit;
    }

    if (!SetRegistryBinary( hGroupKey,
                            REGVAL_ROUTING_GROUP_DEVICES,
                            (LPBYTE) lpdwDevices,
                            dwNumDevices * sizeof(DWORD)))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryBinary failed , ec %ld"), dwRes);
        goto exit;
    }

    Assert (dwRes == ERROR_SUCCESS);

exit:
    MemFree (lpdwDevices);
    return dwRes;
}


DWORD
COutboundRoutingGroup::SerializeDevices (LPDWORD* lppDevices, LPDWORD lpdwNumDevices, BOOL bAllocate) const
/*++

Routine name : COutboundRoutingGroup::SerializeDevices

Routine description:

    Serializes all group devices to an array. The caller must call MemFree to deallocate memory if bAllocate is TRUE.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lppDevices          [out] - Pointer to recieve the pointer to the allocated devices buffer.
                                If this parameter is NULL, lpdwNumDevices will return the numner of devices in the list.
    lpdwNumDevices      [out] - Pointer to a DWORD to recieve the number of devices in the buffer
    bAllocate           [in]  - Flag to indicate if the function should allocate the memory.

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::SerializeDevices"));
    DWORD   dwRes = ERROR_SUCCESS;
    GROUP_DEVICES::iterator it;
    DWORD dwCount = 0;

    Assert (lpdwNumDevices);

    if (NULL == lppDevices )
    {
        try
        {
            *lpdwNumDevices = m_DeviceList.size();
            return ERROR_SUCCESS;
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("list caused exception (%S)"),
                ex.what());
            return ERROR_GEN_FAILURE;
        }
    }

    if (bAllocate == TRUE)
    {
        *lppDevices = NULL;
    }

    try
    {
        dwCount = m_DeviceList.size();
        if (0 == dwCount)
        {
            *lppDevices = NULL;
            *lpdwNumDevices = 0;
            return dwRes;
        }

        if (TRUE == bAllocate)
        {
            *lppDevices = (LPDWORD) MemAlloc(dwCount * sizeof(DWORD));
            if (*lppDevices == NULL)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Cannot allocate devices buffer"));
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }

        dwCount = 0;
        for (it = m_DeviceList.begin(); it != m_DeviceList.end(); it++)
        {
            (*lppDevices)[dwCount++] = *it;
        }

        if (0 == dwCount)
        {
            *lppDevices = NULL;
        }
        *lpdwNumDevices = dwCount;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (bAllocate == TRUE)
        {
            MemFree (*lppDevices);
        }
        *lppDevices = NULL;
        *lpdwNumDevices = 0;
    }
    return dwRes;
}


BOOL
COutboundRoutingGroup::IsDeviceInGroup (DWORD dwDevice) const
/*++

Routine name : COutboundRoutingGroup::IsDeviceInGroup

Routine description:

    Check if device is in the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice            [in] - Permanent device ID

Return Value:

    BOOL. If the function fails, Call GetLastError for detailed info.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::IsDeviceInGroup"));
    GROUP_DEVICES::iterator location;
    BOOL bFound = FALSE;

    Assert (dwDevice);

    try
    {
        location = find(m_DeviceList.begin(), m_DeviceList.end(), dwDevice);
        if (location != m_DeviceList.end())
        {
            bFound = TRUE;
        }
        SetLastError (ERROR_SUCCESS);
        return bFound;

    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }
}

DWORD
COutboundRoutingGroup::AddDevice (DWORD dwDevice)
/*++

Routine name : COutboundRoutingGroup::AddDevice

Routine description:

    Adds a new device to group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice            [in    ] - Permanent device ID

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::AddDevice"));
    GROUP_DEVICES::iterator it;
    DWORD dwRes;

    Assert (dwDevice);

    if (IsDeviceInGroup(dwDevice))
    {
        return ERROR_SUCCESS;
    }
    else
    {
        dwRes = GetLastError();
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroup::IsDeviceInList failed, error %ld"),
                dwRes);
            return dwRes;
        }
    }

    //
    // Device not in list - Add it
    //
    try
    {
        if (!IsDeviceInstalled(dwDevice))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Device id: %ld is not installed."),
                dwDevice);
            return ERROR_BAD_UNIT;
        }
        m_DeviceList.push_back (dwDevice);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}

DWORD
COutboundRoutingGroup::DelDevice (DWORD dwDevice)
/*++

Routine name : COutboundRoutingGroup::DelDevice

Routine description:

    Deletes a device from the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice            [in    ] - Permanent device ID

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::DelDevice"));
    GROUP_DEVICES::iterator location;
    BOOL bFound = FALSE;

    Assert (dwDevice);

    try
    {
        location = find(m_DeviceList.begin(), m_DeviceList.end(), dwDevice);
        if (location == m_DeviceList.end())
        {
            return ERROR_SUCCESS;
        }

        m_DeviceList.erase (location);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}



DWORD
COutboundRoutingGroup::SetDevices (LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup)
/*++

Routine name : COutboundRoutingGroup::SetDevices

Routine description:

    Sets a new device list to the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpdwDevices         [in] - Pointer to a list of devices
    dwNumDevices        [in] - Number of devices in the list
    fAllDevicesGroup    [in] - TRUE if <All Devices> group.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::SetDevices"));

    dwRes = ValidateDevices( lpdwDevices, dwNumDevices, fAllDevicesGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::ValidateDevices failed , ec %ld"), dwRes);
        return dwRes;
    }

    try
    {
        m_DeviceList.erase (m_DeviceList.begin(), m_DeviceList.end());

        for (DWORD i = 0; i < dwNumDevices; i++)
        {
         m_DeviceList.push_back (lpdwDevices[i]);
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

    return dwRes;
}

DWORD
COutboundRoutingGroup::ValidateDevices (const LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup) const
/*++

Routine name : COutboundRoutingGroup::ValidateDevices

Routine description:

    Validates a list of devices (No duplicates, All devices installed)

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpdwDevices         [in    ] - Pointer to alist of devices
    dwNumDevices            [in    ] - Number of devices in the list

Return Value:

    Standard Win32 error code

--*/
{
    set<DWORD> ValidationSet;
    pair < set<DWORD>::iterator, bool> p;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::ValidateDevices"));

    try
    {
        if (TRUE == fAllDevicesGroup)
        {
            //
            // <All Devices> group - validate that we do not miss or add a device.
            //
            if (m_DeviceList.size() != dwNumDevices)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("<All Devices> group contains diffrent number of devices, (old group - %ld, new group - %ld)"),
                    m_DeviceList.size(),
                    dwNumDevices);
                return FAX_ERR_BAD_GROUP_CONFIGURATION;
            }
        }

        for (DWORD i = 0; i < dwNumDevices; i++)
        {
            p = ValidationSet.insert(lpdwDevices[i]);
            if (p.second == FALSE)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Duplicate device IDs, ID = %ld"),
                    lpdwDevices[i]);
                return FAX_ERR_BAD_GROUP_CONFIGURATION;
            }


            if (!IsDeviceInstalled (lpdwDevices[i]))
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Device ID %ld, is not installed"),
                        lpdwDevices[i]);
                return ERROR_BAD_UNIT;
            }
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("set caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}


#if DBG
void COutboundRoutingGroup::Dump () const
{
    GROUP_DEVICES::iterator it;
    WCHAR Buffer[128] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    for (it = m_DeviceList.begin(); it != m_DeviceList.end(); it++)
    {
        _snwprintf (Buffer, dwBufferSize - 1, TEXT("\tDevice ID = %ld \n"), *it);
        OutputDebugString (Buffer);
    }
    return;
}
#endif


DWORD
COutboundRoutingGroup::SetDeviceOrder (DWORD dwDevice, DWORD dwOrder)
/*++

Routine name : COutboundRoutingGroup::SetDeviceOrder

Routine description:

    Sest the order of a single device in a group of outbound routing devices.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice        [in] - The device ID to be set
    dwOrder         [in] - The device new order

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::SetDeviceOrder"));
    GROUP_DEVICES::iterator it;
    DWORD i = 1;

    Assert (dwDevice);

    try
    {
        // Check if dwOrder is bigger than number of devices in the list
        if (dwOrder > m_DeviceList.size())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Device ID %ld, is not found in group"),
                dwDevice);
            return FAX_ERR_BAD_GROUP_CONFIGURATION;
        }

        it = find(m_DeviceList.begin(), m_DeviceList.end(), dwDevice);
        if (it == m_DeviceList.end())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Device ID %ld, is not found in group"),
                dwDevice);
            return FAX_ERR_BAD_GROUP_CONFIGURATION;
        }

        m_DeviceList.erase (it);

        for (i = 1, it = m_DeviceList.begin(); i < dwOrder; i++, it++)
        {
            ;
        }

        m_DeviceList.insert (it, dwDevice);
        return ERROR_SUCCESS;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }

}

/****************************************
*                                       *
*  COutboundRoutingGroupsMap  Methodes  *
*                                       *
****************************************/

DWORD
COutboundRoutingGroupsMap::Load ()
/*++

Routine name : COutboundRoutingGroupsMap::Load

Routine description:

    Loads all outbound routing groups from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::Load"));
    DWORD   dwRes = ERROR_SUCCESS;
    HKEY    hGroupskey = NULL;
    DWORD dwCount = 0;

    hGroupskey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                  REGKEY_FAX_OUTBOUND_ROUTING,
                                  FALSE,
                                  KEY_READ | KEY_WRITE );
    if (NULL == hGroupskey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey, error  %ld"),
            dwRes);
        return dwRes;
    }

    dwCount = EnumerateRegistryKeys( hGroupskey,
                                     REGKEY_OUTBOUND_ROUTING_GROUPS,
                                     TRUE,  // We might want to change values
                                     EnumOutboundRoutingGroupsCB,
                                     &dwRes
                                    );

    if (dwRes != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnumerateRegistryKeys failed, error  %ld"),
            dwRes);
    }

    RegCloseKey (hGroupskey);
    return dwRes;
}


DWORD
COutboundRoutingGroupsMap::AddGroup (LPCWSTR lpcwstrGroupName, PCGROUP pCGroup)
/*++

Routine name : COutboundRoutingGroupsMap::AddGroup

Routine description:

    Add a new group to the global groups map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [      ] - Group name
    pCGroup         [      ] - Pointer to a group object

Return Value:

    Standard Win32 error code
--*/
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::AddGroup"));
    pair <GROUPS_MAP::iterator, bool> p;

    Assert (pCGroup && lpcwstrGroupName);

    try
    {
        wstring wstrGroupName(lpcwstrGroupName);

        //
        // Add new map entry
        //
        p = m_GroupsMap.insert (GROUPS_MAP::value_type(wstrGroupName, *pCGroup));

        //
        // See if entry exists in map
        //
        if (p.second == FALSE)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group %S is allready in the group map"), lpcwstrGroupName);
            dwRes = ERROR_DUP_NAME;
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

exit:
    return dwRes;

}


DWORD
COutboundRoutingGroupsMap::DelGroup (LPCWSTR lpcwstrGroupName)
/*++

Routine name : COutboundRoutingGroupsMap::DelGroup

Routine description:

    Deletes a group from the global groups map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [      ] - The group name

Return Value:

    Standard Win32 error code

--*/
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::DelGroup"));

    try
    {
        wstring wstrGroupName(lpcwstrGroupName);

        //
        // See if entry exists in map
        //
        if((it = m_GroupsMap.find(wstrGroupName)) == m_GroupsMap.end())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group %S not is not in the group map"), lpcwstrGroupName);
            dwRes = FAX_ERR_GROUP_NOT_FOUND;
            goto exit;
        }

        //
        // Delete the map entry
        //
        m_GroupsMap.erase (it);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }
    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}

PCGROUP
COutboundRoutingGroupsMap::FindGroup ( LPCWSTR lpcwstrGroupName ) const
/*++

Routine name : COutboundRoutingGroupsMap::FindGroup

Routine description:

    Returns a pointer to a group object specified by its name

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [in    ] - The group name

Return Value:

    Pointer to the found group object. If it is null the group was not found

--*/
{
    GROUPS_MAP::iterator it;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::FindGroup"));

    try
    {
        wstring wstrGroupName(lpcwstrGroupName);

        //
        // See if entry exists in map
        //
        if((it = m_GroupsMap.find(wstrGroupName)) == m_GroupsMap.end())
        {
            SetLastError (FAX_ERR_GROUP_NOT_FOUND);
            return NULL;
        }
        return &((*it).second);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
}

#if DBG
void COutboundRoutingGroupsMap::Dump () const
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::Dump"));
    GROUPS_MAP::iterator it;
    WCHAR Buffer [512] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    try
    {   _snwprintf (Buffer, dwBufferSize - 1, TEXT("DUMP - Outbound routing groups\n"));
        OutputDebugString (Buffer);

        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            _snwprintf (Buffer, dwBufferSize - 1, TEXT("Group Name - %s\n"), ((*it).first).c_str());
            OutputDebugString (Buffer);
            ((*it).second).Dump();
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
    }
    return;
}
#endif


DWORD
COutboundRoutingGroupsMap::SerializeGroups (
    PFAX_OUTBOUND_ROUTING_GROUPW*       ppGroups,
    LPDWORD                             lpdwNumGroups,
    LPDWORD                             lpdwBufferSize) const
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::SerializeGroups"));
    DWORD dwSize = 0;
    DWORD dwNumDevices;
    DWORD dwCount = 0;
    LPCWSTR lpcwstrGroupName;
    PCGROUP pCGroup;

    Assert (ppGroups && lpdwNumGroups && lpdwBufferSize);

    *ppGroups = NULL;
    *lpdwNumGroups = 0;

    try
    {
        // Calculate buffer size
        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            lpcwstrGroupName = ((*it).first).c_str();
            pCGroup = &((*it).second);

            dwSize += sizeof (FAX_OUTBOUND_ROUTING_GROUPW);
            dwSize += StringSizeW(lpcwstrGroupName);
            dwRes = pCGroup->SerializeDevices(NULL, &dwNumDevices);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::SerializeDevices failed,  error %ld"),
                    dwRes);
                goto exit;
            }
            dwSize += dwNumDevices * sizeof(DWORD);
            dwCount ++;
        }

        // Allocate buffer
        *ppGroups = (PFAX_OUTBOUND_ROUTING_GROUPW) MemAlloc (dwSize);
        if (NULL == *ppGroups)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate groups buffer"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        DWORD_PTR dwOffset = dwCount * sizeof (FAX_OUTBOUND_ROUTING_GROUPW);
        dwCount = 0;

        // Fill buffer with serialized info
        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            lpcwstrGroupName = ((*it).first).c_str();
            pCGroup = &((*it).second);
            LPDWORD lpdwDevices;

            (*ppGroups)[dwCount].dwSizeOfStruct = sizeof (FAX_OUTBOUND_ROUTING_GROUPW);
            dwRes = pCGroup->GetStatus(&(*ppGroups)[dwCount].Status);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::GetStatus failed,  error %ld"),
                    dwRes);
                goto exit;
            }

            StoreString (lpcwstrGroupName,
                         (PULONG_PTR)&(*ppGroups)[dwCount].lpctstrGroupName,
                         (LPBYTE)*ppGroups,
                         &dwOffset,
						 dwSize);

            lpdwDevices = (LPDWORD)((LPBYTE)*ppGroups + dwOffset);

            dwRes = pCGroup->SerializeDevices(&lpdwDevices,
                                              &dwNumDevices,
                                              FALSE); // Do not allocate
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::SerializeDevices failed,  error %ld"),
                    dwRes);
                goto exit;
            }

            if (dwNumDevices != 0)
            {
                (*ppGroups)[dwCount].lpdwDevices = (LPDWORD)dwOffset;
                dwOffset +=  dwNumDevices * sizeof(DWORD);
            }
            else
            {
                (*ppGroups)[dwCount].lpdwDevices = NULL;
            }

            (*ppGroups)[dwCount].dwNumDevices = dwNumDevices;
            dwCount++;
        }

    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    *lpdwNumGroups = dwCount;
    *lpdwBufferSize = dwSize;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (*ppGroups);
    }
    return dwRes;
}

BOOL
COutboundRoutingGroupsMap::UpdateAllDevicesGroup (void)
/*++

Routine name : COutboundRoutingGroupsMap::UpdateAllDevicesGroup

Routine description:

    Updates <All devices> group with installed devices

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    BOOL

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    PLIST_ENTRY Next;
    PLINE_INFO pLineInfo;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::UpdateAllDevicesGroup"));
    HKEY hGroupKey = NULL;
    LPDWORD lpdwDevices = NULL;
    DWORD dwNumDevices = 0;
    DWORD i;
    PCGROUP pCGroup;

    pCGroup = FindGroup (ROUTING_GROUP_ALL_DEVICESW);
    if (NULL == pCGroup)
    {
        dwRes = GetLastError();
        if (FAX_ERR_GROUP_NOT_FOUND != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
            return FALSE;
        }

        COutboundRoutingGroup CGroup;
        dwRes = AddGroup (ROUTING_GROUP_ALL_DEVICESW, &CGroup);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroup::AddGroup failed , ec %ld"), dwRes);
            SetLastError (dwRes);
            return FALSE;
        }

        pCGroup = FindGroup (ROUTING_GROUP_ALL_DEVICESW);
        if (NULL == pCGroup)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
            return FALSE;
        }
    }

    dwRes = pCGroup->SerializeDevices (&lpdwDevices, &dwNumDevices);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::EnumDevices failed , ec %ld"), dwRes);
        SetLastError (dwRes);
        return FALSE;
    }

    EnterCriticalSection( &g_CsLine );
    Next = g_TapiLinesListHead.Flink;
    Assert (Next);

    //
    // Remove unavailable devices from the group
    //
    for (i = 0; i < dwNumDevices; i++)
    {
        if (IsDeviceInstalled (lpdwDevices[i]))
        {
            continue;
        }

        //
        // Device is not installed - remove it
        //
        dwRes = pCGroup->DelDevice (lpdwDevices[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroup::DelDevice failed , ec %ld"), dwRes);
            goto exit;
        }
    }

    //
    // Add missing devices from TapiLinesList list
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;
        Assert (Next && pLineInfo->PermanentLineID);

        dwRes = pCGroup->AddDevice (pLineInfo->PermanentLineID);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroup::AddDevice failed, error %ld"),
                dwRes);
            goto exit;
        }
    }

    //
    // Save changes
    //
    hGroupKey = OpenOutboundGroupKey( ROUTING_GROUP_ALL_DEVICESW, TRUE, KEY_READ | KEY_WRITE );
    if (NULL == hGroupKey)
    {
      dwRes = GetLastError ();
      DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
          dwRes);
      goto exit;
    }

    dwRes = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            ROUTING_GROUP_ALL_DEVICES,
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree (lpdwDevices);
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }

    LeaveCriticalSection( &g_CsLine );
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
    }
    return (ERROR_SUCCESS == dwRes);
}


DWORD
COutboundRoutingGroupsMap::RemoveDevice (DWORD dwDeviceId)
/*++

Routine name : COutboundRoutingGroupsMap::RemoveDevice

Routine description:

    Deletes a device from all of the groups in the map

Author:

    Oded Sacher (OdedS),    Sep, 2000

Arguments:

    dwDeviceId            [in    ] - The device id to remove

Return Value:

    Standard Win32 error code

--*/
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hGroupKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::RemoveDevice"));

    Assert (dwDeviceId);

    try
    {
        //
        // Delete the device from each group
        //
        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            PCGROUP pCGroup = &((*it).second);
            LPCWSTR lpcwstrGroupName = ((*it).first).c_str();

            //
            // Open the group registry key
            //
            hGroupKey = OpenOutboundGroupKey( lpcwstrGroupName, FALSE, KEY_READ | KEY_WRITE );
            if (NULL == hGroupKey)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("Can't open group key, OpenOutboundGroupKey failed  : %ld"),
                  dwRes);
                goto exit;
            }

            dwRes = pCGroup->DelDevice (dwDeviceId);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("COutboundRoutingGroup::DelDevice failed  : %ld"),
                  dwRes);
                goto exit;
            }

            dwRes = pCGroup->Save(hGroupKey);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("COutboundRoutingGroup::Save failed  : %ld"),
                  dwRes);
                goto exit;
            }

            RegCloseKey (hGroupKey);
            hGroupKey = NULL;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:

    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    return dwRes;
} // RemoveDevice



/************************************
*                                   *
*             Registry              *
*                                   *
************************************/
BOOL
EnumOutboundRoutingGroupsCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    )
{
    DEBUG_FUNCTION_NAME(TEXT("EnumOutboundRoutingGroupsCB"));
    DWORD dwRes;
    COutboundRoutingGroup CGroup;
    BOOL bGroupDeleted = FALSE;

    if (!SubKeyName)
    {
        return TRUE;
    }

    if ((_wcsicmp (SubKeyName, ROUTING_GROUP_ALL_DEVICESW) != 0) &&
        IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs. Do not load group information.
        //
        return TRUE;
    }

    //
    // Add group
    //
    dwRes = CGroup.Load (hSubKey, SubKeyName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Load failed, group name - %s, error %ld"),
            SubKeyName,
            dwRes);

        // Open Outbound Routing\Groups key
        HKEY hGroupsKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                           REGKEY_FAX_OUTBOUND_ROUTING_GROUPS,
                                           FALSE,
                                           KEY_READ | KEY_WRITE | DELETE);
        if (NULL == hGroupsKey)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey, error  %ld"),
                dwRes);
        }
        else
        {
            DWORD dwRetVal = RegDeleteKey (hGroupsKey, SubKeyName);
            if (ERROR_SUCCESS != dwRetVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RegDeleteKey failed, Group name - %s,  error %ld"),
                    SubKeyName,
                    dwRetVal);
            }
            else
            {
                bGroupDeleted = TRUE;
            }
        }
        goto exit;
    }

    dwRes = g_pGroupsMap->AddGroup  (SubKeyName, &CGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::AddGroup failed, group name - %s, error %ld"),
            SubKeyName,
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (bGroupDeleted == FALSE)
        {
            FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_OUTBOUND_ROUTING_GROUP_NOT_ADDED,
            SubKeyName
            );
        }
        else
        {
            FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_OUTBOUND_ROUTING_GROUP_NOT_LOADED,
                SubKeyName
                );
        }
    }
    *(LPDWORD)pContext = ERROR_SUCCESS; // Let the service start
    return TRUE; // Let the service start
}

/************************************
*                                   *
*         RPC handlers              *
*                                   *
************************************/

extern "C"
error_status_t
FAX_AddOutboundGroup (
    IN handle_t   hFaxHandle,
    IN LPCWSTR    lpwstrGroupName
    )
/*++

Routine name : FAX_AddOutboundGroup

Routine description:

    Adds a new Outbound routing group to the fax server

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - FaxServer handle
    lpwstrGroupName         [in    ] - The new group name

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AddOutboundGroup"));
    HKEY hGroupKey = NULL;
    COutboundRoutingGroup CGroup;
    DWORD rVal;
    BOOL fAccess;

    Assert (lpwstrGroupName);

    if (_wcsicmp (lpwstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        return ERROR_DUP_NAME;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    if (wcslen (lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig); // Empty group, no need to lock g_CsLine

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

    hGroupKey = OpenOutboundGroupKey( lpwstrGroupName, TRUE, KEY_READ | KEY_WRITE );
    if (NULL == hGroupKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    dwRes = g_pGroupsMap->AddGroup (lpwstrGroupName, &CGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::AddGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    dwRes = CGroup.Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            lpwstrGroupName,
            dwRes);
        g_pGroupsMap->DelGroup (lpwstrGroupName);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
}


extern "C"
error_status_t
FAX_SetOutboundGroup (
    IN handle_t                         hFaxHandle,
    IN PRPC_FAX_OUTBOUND_ROUTING_GROUPW pGroup
    )
/*++

Routine name : FAX_SetOutboundGroup

Routine description:

    Sets a new device list to an existing group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle      [in] - Fax server handle
    pGroup          [in] - Pointer to a PRPC_FAX_OUTBOUND_ROUTING_GROUPW contaning group info

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetOutboundGroup"));
    HKEY	hGroupKey	= NULL;
    PCGROUP pCGroup		= NULL;
    COutboundRoutingGroup OldGroup;
    DWORD rVal;
    BOOL fAccess;
    BOOL fAllDevicesGroup = FALSE;

    Assert (pGroup);

    if (sizeof (FAX_OUTBOUND_ROUTING_GROUPW) != pGroup->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
       return ERROR_INVALID_PARAMETER;
    }

    if (!pGroup->lpwstrGroupName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (wcslen (pGroup->lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        return ERROR_BUFFER_OVERFLOW;
    }


    if (!pGroup->lpdwDevices && pGroup->dwNumDevices)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (_wcsicmp (pGroup->lpwstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        //
        // If it is <All Devices> group we should validate that no device is missing,
        // and that the new group contains all installed devices.
        //
        fAllDevicesGroup = TRUE;
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

    pCGroup = g_pGroupsMap->FindGroup (pGroup->lpwstrGroupName);
    if (!pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetGroup failed, Group name - %s,  error %ld"),
            pGroup->lpwstrGroupName,
            dwRes);
        goto exit;
    }

    hGroupKey = OpenOutboundGroupKey( pGroup->lpwstrGroupName, FALSE, KEY_READ | KEY_WRITE );
    if (NULL == hGroupKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    OldGroup = *pCGroup;

    dwRes = pCGroup->SetDevices (pGroup->lpdwDevices, pGroup->dwNumDevices, fAllDevicesGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::SetDevices failed, Group name - %s,  failed with %ld"),
            pGroup->lpwstrGroupName,
            dwRes);
        goto exit;
    }

    dwRes = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            pGroup->lpwstrGroupName,
            dwRes);
        *pCGroup = OldGroup;
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
}


extern "C"
error_status_t
FAX_RemoveOutboundGroup (
    IN handle_t   hFaxHandle,
    IN LPCWSTR    lpwstrGroupName
    )
/*++

Routine name : FAX_RemoveOutboundGroup

Routine description:

    Removes an existing Outbound routing group from the fax server

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - FaxServer handle
    lpwstrGroupName         [in    ] - The group name

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RemoveOutboundGroup"));
    HKEY hGroupsKey = NULL;
    DWORD rVal;
    BOOL fAccess;
    PCGROUP pCGroup = NULL;

    Assert (lpwstrGroupName);

    if (_wcsicmp (lpwstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        return ERROR_INVALID_OPERATION;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    if (wcslen (lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before delete"));
    g_pGroupsMap->Dump();
#endif

    BOOL bGroupInRule;
    dwRes = g_pRulesMap->IsGroupInRuleDest(lpwstrGroupName, &bGroupInRule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::IsGroupInRuleDest failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    if (TRUE == bGroupInRule)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Group is a rule destination, Can not be deleted, Group name - %s"),
            lpwstrGroupName);
        dwRes = FAX_ERR_GROUP_IN_USE;
        goto exit;
    }

    //
    // See if the group exists in the map
    //
    pCGroup = g_pGroupsMap->FindGroup (lpwstrGroupName);
    if (!pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    // Open Outbound Routing\Groups key
    hGroupsKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                  REGKEY_FAX_OUTBOUND_ROUTING_GROUPS,
                                  FALSE,
                                  KEY_READ | KEY_WRITE | DELETE);
    if (NULL == hGroupsKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey, error  %ld"),
            dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }


    // Delete the specified group key
    dwRes = RegDeleteKey (hGroupsKey, lpwstrGroupName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegDeleteKey failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    // Delete the group from the memory
    dwRes = g_pGroupsMap->DelGroup (lpwstrGroupName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::DelGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -after delete"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupsKey)
    {
        RegCloseKey (hGroupsKey);
    }
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
} //FAX_RemoveOutboundGroup



error_status_t
FAX_EnumOutboundGroups (
    handle_t                             hFaxHandle,
    LPBYTE*                              ppBuffer,
    LPDWORD                              lpdwBufferSize,
    LPDWORD                              lpdwNumGroups
    )
/*++

Routine name : FAX_EnumOutboundGroups

Routine description:

    Enumurates all outbound routing groups

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Fax server handle
    ppBuffer            [out   ] - Adress of a pointer to a buffer to be filled with info
    lpdwBufferSize          [in/out] - The buffer size
    lpdwNumGroups           [out   ] - Number of groups returned

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumOutboundGroups"));
    BOOL fAccess;

    Assert (lpdwNumGroups && lpdwNumGroups);    // ref pointer in idl
    if (!ppBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    *ppBuffer = NULL;
    *lpdwNumGroups = 0;


    EnterCriticalSection (&g_CsConfig);

    dwRes = g_pGroupsMap->SerializeGroups ((PFAX_OUTBOUND_ROUTING_GROUPW*)ppBuffer,
                                         lpdwNumGroups,
                                         lpdwBufferSize);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SerializeGroups failed, error %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);

}  //FAX_EnumOutboundGroups

error_status_t
FAX_SetDeviceOrderInGroup (
    handle_t           hFaxHandle,
    LPCWSTR            lpwstrGroupName,
    DWORD              dwDeviceId,
    DWORD              dwNewOrder
    )
/*++

Routine name : FAX_SetDeviceOrderInGroup

Routine description:

    Sets the order of the specified device in the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Fax server handle
    lpwstrGroupName     [in] - The group name
    dwDeviceId          [in] - The device permanent ID
    dwNewOrder          [in] - The device new order

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetDeviceOrderInGroup"));
    HKEY hGroupKey = NULL;
    PCGROUP pCGroup = NULL;
    COutboundRoutingGroup OldGroup;
    DWORD rVal;
    BOOL fAccess;

    Assert (lpwstrGroupName);

    if (!dwDeviceId || !dwNewOrder)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (wcslen (lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);

    #if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before changing order"));
    g_pGroupsMap->Dump();
#endif

    // Find the group in memory
    pCGroup = g_pGroupsMap->FindGroup (lpwstrGroupName);
    if (!pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::FindGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    // Open the group registry key
    hGroupKey = OpenOutboundGroupKey( lpwstrGroupName, FALSE, KEY_READ | KEY_WRITE );
    if (NULL == hGroupKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't open group key, OpenOutboundGroupKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    // Save a copy of the old group
    OldGroup = *pCGroup;

    // Cahnge the device order in the group
    dwRes = pCGroup->SetDeviceOrder(dwDeviceId, dwNewOrder);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetDeviceOrder failed, Group name - %s,\
                  Device Id %ld, new order %ld,   error %ld"),
            lpwstrGroupName,
            dwDeviceId,
            dwNewOrder,
            dwRes);
        goto exit;
    }

    // save changes to the registry
    dwRes = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            lpwstrGroupName,
            dwRes);
        // Rollback memory
        *pCGroup = OldGroup;
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -after change"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);

}// FAX_SetDeviceOrderInGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\routegroup.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RouteGroup.h

Abstract:

    This file provides declaration of the service
    outbound routing groups.

Author:

    Oded Sacher (OdedS)  Nov, 1999

Revision History:

--*/

#ifndef _OUT_ROUTE_GROUP_H
#define _OUT_ROUTE_GROUP_H

#include <map>
#include <list>
#include <string>
#include <algorithm>
#include <set>
using namespace std;
#pragma hdrstop

#pragma warning (disable : 4786)    // identifier was truncated to '255' characters in the debug information
// This pragma does not work KB ID: Q167355

/************************************
*                                   *
*      wstrCaseInsensitiveLess      *
*                                   *
************************************/
class wstrCaseInsensitiveLess
{
  public:
    bool operator()(const wstring X, wstring Y) const
    {
        LPCWSTR lpcwstrX = X.c_str();
        LPCWSTR lpcwstrY = Y.c_str();

        if (_wcsicmp(lpcwstrX,lpcwstrY) < 0)
        {
            return true;
        }

        return false;
    }
};


typedef list<DWORD> GROUP_DEVICES, *PGROUP_DEVICES;

/************************************
*                                   *
*         COutboundRoutingGroup     *
*                                   *
************************************/
class COutboundRoutingGroup
{
public:
    COutboundRoutingGroup () {}
    ~COutboundRoutingGroup () {}

    COutboundRoutingGroup (const COutboundRoutingGroup& rhs)
        : m_DeviceList(rhs.m_DeviceList) {}
    COutboundRoutingGroup& operator= (const COutboundRoutingGroup& rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        m_DeviceList = rhs.m_DeviceList;
        return *this;
    }

    DWORD Load(HKEY hGroupKey, LPCWSTR lpcwstrGroupName);
    DWORD SetDevices (const LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup);
    DWORD SerializeDevices (LPDWORD* lppDevices, LPDWORD lpdwNumDevices, BOOL bAllocate = TRUE) const;
    DWORD Save(HKEY hGroupKey) const;
    DWORD AddDevice (DWORD dwDevice);
    DWORD DelDevice (DWORD dwDevice);
    DWORD SetDeviceOrder (DWORD dwDevice, DWORD dwOrder);
    DWORD GetStatus (FAX_ENUM_GROUP_STATUS* lpStatus) const;

#if DBG
    void Dump () const;
#endif

private:
    BOOL IsDeviceInGroup (DWORD dwDevice) const;
    DWORD ValidateDevices (const LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup) const;

    GROUP_DEVICES           m_DeviceList;
};  // COutboundRoutingGroup


/************************************
*                                   *
*     COutboundRoutingGroupsMap     *
*                                   *
************************************/

typedef COutboundRoutingGroup  *PCGROUP;
typedef map<wstring, COutboundRoutingGroup, wstrCaseInsensitiveLess>  GROUPS_MAP, *PGROUPS_MAP;

//
// The CGroupMap class maps between group name and a list of device ID's
//
class COutboundRoutingGroupsMap
{
public:
    COutboundRoutingGroupsMap () {}
    ~COutboundRoutingGroupsMap () {}

    DWORD Load ();
    DWORD AddGroup (LPCWSTR lpcwstrGroupName, PCGROUP pCGroup);
    DWORD DelGroup (LPCWSTR lpcwstrGroupName);
    DWORD SerializeGroups (PFAX_OUTBOUND_ROUTING_GROUPW* ppGroups,
                           LPDWORD lpdwNumGroups,
                           LPDWORD lpdwBufferSize) const;
    PCGROUP FindGroup (LPCWSTR lpcwstrGroupName) const;
    BOOL UpdateAllDevicesGroup (void);
    DWORD RemoveDevice (DWORD dwDeviceId);


#if DBG
    void Dump () const;
#endif

private:
    GROUPS_MAP   m_GroupsMap;
};  // COutboundRoutingGroupsMap



/************************************
*                                   *
*         Externes                  *
*                                   *
************************************/

extern COutboundRoutingGroupsMap* g_pGroupsMap;       // Map of group name to list of device IDs
//
//  IMPORTANT - No locking mechanism - USE g_CsConfig to serialize calls to g_pGroupsMap
//


/************************************
*                                   *
*         Functions                 *
*                                   *
************************************/


BOOL
IsDeviceInstalled (DWORD dwDeviceId);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module provides security for the service.

Author:

    Oded Sacher (OdedS) 13-Feb-2000


Revision History:

--*/

#include "faxsvc.h"
#include <aclapi.h>
#define ATLASSERT Assert
#include <smartptr.h>
#pragma hdrstop

//
// defined in ntrtl.h.
// do this to avoid dragging in ntrtl.h since we already include some stuff
// from ntrtl.h
//
extern "C"
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

//
// Global Fax Service Security Descriptor
//
PSECURITY_DESCRIPTOR   g_pFaxSD;

CFaxCriticalSection g_CsSecurity;

const GENERIC_MAPPING gc_FaxGenericMapping =
{
        (STANDARD_RIGHTS_READ | FAX_GENERIC_READ),
        (STANDARD_RIGHTS_WRITE | FAX_GENERIC_WRITE),
        (STANDARD_RIGHTS_EXECUTE | FAX_GENERIC_EXECUTE),
        (READ_CONTROL | WRITE_DAC | WRITE_OWNER | FAX_GENERIC_ALL)
};


DWORD
FaxSvcAccessCheck(
    IN  ACCESS_MASK DesiredAccess,
    OUT BOOL*      lpbAccessStatus,
    OUT LPDWORD    lpdwGrantedAccess
    )
/*++

Routine name : FaxSvcAccessCheck

Routine description:

    Performs an access check against the fax service security descriptor

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    DesiredAccess           [in    ] - Desired access
    lpbAccessStatus         [out   ] - Address of a BOOL to receive the access check result (TRUE is access allowed)
    lpdwGrantedAccess       [out   ] - Optional., Address of a DWORD to receive the maximum access allowed. Desired Access should be MAXIMUM_ALLOWED

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc;
    DWORD GrantedAccess;
    DWORD dwRes;
    BOOL fGenerateOnClose;
    DEBUG_FUNCTION_NAME(TEXT("FaxSvcAccessCheck"));

    Assert (lpbAccessStatus);

    //
    // Impersonate the client.
    //
    if ((rc = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient() failed. (ec: %ld)"),
            rc);
        goto exit;
    }

    EnterCriticalSection( &g_CsSecurity );
    //
    // purify the access mask - get rid of generic access bits
    //
    MapGenericMask( &DesiredAccess, const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping) );

    //
    // Check if the client has the required access.
    //
    if (!AccessCheckAndAuditAlarm(
        FAX_SERVICE_NAME,                                       // subsystem name
        NULL,                                                   // handle to object
        NULL,                                                   // type of object
        NULL,                                                   // name of object
        g_pFaxSD,                                               // SD
        DesiredAccess,                                          // requested access rights
        const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping),    // mapping
        FALSE,                                                  // creation status
        &GrantedAccess,                                         // granted access rights
        lpbAccessStatus,                                        // result of access check
        &fGenerateOnClose                                       // audit generation option
        ))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AccessCheck() failed. (ec: %ld)"),
            rc);
        LeaveCriticalSection( &g_CsSecurity );
        goto exit;
    }

    if (lpdwGrantedAccess)
    {
        *lpdwGrantedAccess = GrantedAccess;
    }

    LeaveCriticalSection( &g_CsSecurity );
    Assert (ERROR_SUCCESS == rc);

exit:
    dwRes=RpcRevertToSelf();
    if (RPC_S_OK != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed (ec: %ld)"),
            dwRes);
        Assert(FALSE);
    }
    return rc;
}


DWORD
SaveSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    )
/*++

Routine name : SaveSecurityDescriptor

Routine description:

    Saves the Fax Service SD to the registry

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    pSD         [in    ] - Pointer to a SD to be saved

Return Value:

    DWORD

--*/
{
    DWORD rc = ERROR_SUCCESS;
    DWORD dwSize;
    PSECURITY_DESCRIPTOR pSDSelfRelative = NULL;
    HKEY hKey = NULL;
    DWORD Disposition;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_SELF_RELATIVE;
    DWORD dwRevision;
    DEBUG_FUNCTION_NAME(TEXT("SaveSecurityDescriptor"));

    Assert (pSD);

    rc = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_WRITE,
        NULL,
        &hKey,
        &Disposition
        );
    if (rc != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegCreateKeyEx() failed (ec: %ld)"),
            rc);
        return rc;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        rc = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed."));
        goto exit;
    }

    //
    // Check if the security descriptor  is absolute or self relative.
    //
    if (!GetSecurityDescriptorControl( pSD, &Control, &dwRevision))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSecurityDescriptorControl() failed (ec: %ld)"),
            rc);
        goto exit;
    }


    //
    // store the security descriptor in the registry
    //
    dwSize = GetSecurityDescriptorLength( pSD );

    if (SE_SELF_RELATIVE & Control)
    {
        //
        // store the security descriptor in the registry use absolute SD
        //
        rc = RegSetValueEx(
            hKey,
            REGVAL_DESCRIPTOR,
            0,
            REG_BINARY,
            (LPBYTE) pSD,
            dwSize
            );
        if (ERROR_SUCCESS != rc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegSetValueEx() failed (ec: %ld)"),
                rc);
            goto exit;
        }

    }
    else
    {
        //
        // Convert the absolute SD to self relative
        //
        pSDSelfRelative = (PSECURITY_DESCRIPTOR) MemAlloc( dwSize );
        if (NULL == pSDSelfRelative)
        {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error Allocating security descriptor"));
            goto exit;
        }

        //
        // make the security descriptor self relative
        //
        if (!MakeSelfRelativeSD( pSD, pSDSelfRelative, &dwSize))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MakeSelfRelativeSD() failed (ec: %ld)"),
                rc);
            goto exit;
        }
    

        //
        // store the security descriptor in the registry use self relative SD
        //
        rc = RegSetValueEx(
            hKey,
            REGVAL_DESCRIPTOR,
            0,
            REG_BINARY,
            (LPBYTE) pSDSelfRelative,
            dwSize
            );
        if (ERROR_SUCCESS != rc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegSetValueEx() failed (ec: %ld)"),
                rc);
            goto exit;
        }

    }

    Assert (ERROR_SUCCESS == rc);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }

    if (NULL != pSDSelfRelative)
    {
        MemFree (pSDSelfRelative);
    }
    return rc;
}

#define FAX_OWNER_SID       TEXT("O:NS")                  //  Owner sid : Network Service
#define FAX_GROUP_SID       TEXT("G:NS")                  //  Group sid : Network Service

#define FAX_DACL            TEXT("D:")

#define FAX_BA_ALLOW_ACE    TEXT("(A;;0xe07ff;;;BA)")     //  Allow Built-in administrators (BA)  - 
                                                          //  Access mask : 0xe07ff ==  FAX_GENERIC_ALL | 
                                                          //                            WRITE_OWNER     |
                                                          //                            WRITE_DAC       |
                                                          //                            READ_CONTROL    

#define FAX_WD_ALLOW_ACE    TEXT("(A;;0x20003;;;WD)")     //  Allow Everyone (WD) -
                                                          //  Access mask : 0x20003 ==  FAX_ACCESS_SUBMIT | 
                                                          //                            FAX_ACCESS_SUBMIT_NORMAL |
                                                          //                            READ_CONTROL

#define FAX_IU_ALLOW_ACE    TEXT("(A;;0x202BF;;;IU)")     //  Allow Interactive users (IU) -
                                                          //  Access mask : 0x202BF ==  FAX_ACCESS_SUBMIT             |
                                                          //                            FAX_ACCESS_SUBMIT_NORMAL      |
                                                          //                            FAX_ACCESS_SUBMIT_HIGH        |
                                                          //                            FAX_ACCESS_QUERY_JOBS         |
                                                          //                            FAX_ACCESS_MANAGE_JOBS        |
                                                          //                            FAX_ACCESS_QUERY_CONFIG       |
                                                          //                            FAX_ACCESS_QUERY_OUT_ARCHIVE  |
                                                          //                            FAX_ACCESS_QUERY_IN_ARCHIVE   |
                                                          //                            READ_CONTROL

#define FAX_DESKTOP_SKU_SD  (FAX_OWNER_SID FAX_GROUP_SID FAX_DACL FAX_BA_ALLOW_ACE FAX_WD_ALLOW_ACE FAX_IU_ALLOW_ACE)    // SD for per/pro SKU

#define FAX_SERVER_SKU_SD   (FAX_OWNER_SID FAX_GROUP_SID FAX_DACL FAX_BA_ALLOW_ACE FAX_WD_ALLOW_ACE)                     // SD for server SKU


DWORD
CreateDefaultSecurityDescriptor(
    VOID
    )
/*++

Routine name : CreateDefaultSecurityDescriptor

Routine description:

    Creates the default security descriptor

Author:

    Oded Sacher (OdedS),    Feb, 2000
    Caliv Nir   (t-nicali)  Mar, 2002   - changed to use SDDL, while moving Fax service 
                                          to run under "Network service"

Arguments:
    
    None.


Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRet = ERROR_SUCCESS;
    BOOL  bRet;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR pPrivateObjectSD = NULL;
    ULONG   SecurityDescriptorSize = 0;
    HANDLE  hFaxServiceToken = NULL;

    BOOL    bDesktopSKU = FALSE;
    
    TCHAR* ptstrSD = NULL;
    
    DEBUG_FUNCTION_NAME(TEXT("CreateDefaultSecurityDescriptor"));

    //
    //  If this is PERSONAL SKU, then add Interactive Users SID
    //
    bDesktopSKU = IsDesktopSKU();
    ptstrSD = bDesktopSKU ? FAX_DESKTOP_SKU_SD : FAX_SERVER_SKU_SD;

    bRet = ConvertStringSecurityDescriptorToSecurityDescriptor(
                ptstrSD,                // security descriptor string
                SDDL_REVISION_1,        // revision level
                &pSecurityDescriptor,   // SD
                &SecurityDescriptorSize // SD size
                );
    if(!bRet)
    {
        dwRet = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ConvertStringSecurityDescriptorToSecurityDescriptor() failed (ec: %lu)"),
            dwRet);
        goto exit;
    }

    //
    // Get the Fax Service Token
    //
    if (!OpenProcessToken( GetCurrentProcess(), // handle to process
                           TOKEN_QUERY,         // desired access to process
                           &hFaxServiceToken    // handle to open access token
                           ))
    {
        dwRet = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenThreadToken failed. (ec: %ld)"),
            dwRet);
        goto exit;
    }

    //
    // Create a private object SD
    //
    if (!CreatePrivateObjectSecurity( NULL,                                                     // parent directory SD
                                      pSecurityDescriptor,                                      // creator SD
                                      &pPrivateObjectSD,                                        // new SD
                                      FALSE,                                                    // container
                                      hFaxServiceToken,                                         // handle to access token
                                      const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping)       // mapping
                                      ))
    {
        dwRet = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreatePrivateObjectSecurity() failed (ec: %ld)"),
            dwRet);
        goto exit;
    }

    //
    // store the security descriptor in the registry
    //
    dwRet = SaveSecurityDescriptor (pPrivateObjectSD);
    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SaveSecurityDescriptor() failed (ec: %ld)"),
            dwRet);
        goto exit;
    }

    //
    // All done! Set the global fax service security descriptor
    //
    g_pFaxSD = pPrivateObjectSD;
    pPrivateObjectSD = NULL;

    Assert (ERROR_SUCCESS == dwRet);

exit:

    if(NULL != pSecurityDescriptor)
    {
        LocalFree(pSecurityDescriptor);
    }

    if (NULL != hFaxServiceToken)
    {
        if (!CloseHandle(hFaxServiceToken))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle() failed. (ec: %ld)"),
                GetLastError());
        }
    }

    if (NULL != pPrivateObjectSD)
    {
        //
        //  in case of failure in creating the SD destroy the private object SD.
        //
        if (!DestroyPrivateObjectSecurity (&pPrivateObjectSD))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DestroyPrivateObjectSecurity() failed. (ec: %ld)"),
                GetLastError());
        }
    }

    return dwRet;
}   // CreateDefaultSecurityDescriptor



DWORD
LoadSecurityDescriptor(
    VOID
    )
/*++

Routine name : LoadSecurityDescriptor

Routine description:

    Loads the Fax Service security descriptor from the registry

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    None

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc = ERROR_SUCCESS;
    DWORD dwSize;
    HKEY hKey = NULL;
    DWORD Disposition;
    DWORD dwType;
    PSECURITY_DESCRIPTOR pRelativeSD = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LoadSecurityDescriptor"));

    rc = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_READ,
        NULL,
        &hKey,
        &Disposition
        );
    if (rc != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegCreateKeyEx() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    rc = RegQueryValueEx(
        hKey,
        REGVAL_DESCRIPTOR,
        NULL,
        &dwType,
        NULL,
        &dwSize
        );

    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx  failed with %ld"),
            rc);
        goto exit;
    }

    //
    // We opened an existing registry value
    //
    if (REG_BINARY != dwType ||
        0 == dwSize)
    {
        //
        // We expect only binary data here
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading security descriptor from the registry, not a binary type, or size is 0"));
        rc = ERROR_BADDB;    // The configuration registry database is corrupt.
        goto exit;
    }

    //
    // Allocate required buffer
    // The buffer must be allocated using HeapAlloc (GetProcessHeap()...) because this is the way CreatePrivateObjectSecurity() allocates memory
    // This is a result of a bad design of private object security APIs, see Windows Bugs #324906.
    //
    pRelativeSD = (PSECURITY_DESCRIPTOR) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize );
    if (!pRelativeSD)
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate security descriptor buffer"));
        goto exit;
    }

    //
    // Read the data
    //
    rc = RegQueryValueEx(
        hKey,
        REGVAL_DESCRIPTOR,
        NULL,
        &dwType,
        (LPBYTE)pRelativeSD,
        &dwSize
        );
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx failed with %ld"),
            rc);
        goto exit;
    }

    if (!IsValidSecurityDescriptor(pRelativeSD))
    {
        rc = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed."));
        goto exit;
    }

    g_pFaxSD = pRelativeSD;
    pRelativeSD = NULL;
    Assert (ERROR_SUCCESS == rc);

exit:
    if (hKey)
    {
        RegCloseKey( hKey );
    }

    if (NULL != pRelativeSD)
    {
        if (!HeapFree(GetProcessHeap(), 0, pRelativeSD))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("pRelativeSD() failed. (ec: %ld)"),
                GetLastError());
        }
    }
    return rc;
}


DWORD
InitializeServerSecurity(
    VOID
    )
/*++

Routine name : InitializeServerSecurity

Routine description:

    Initializes the Fax Service security

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    None

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("InitializeServerSecurity"));

    rc = LoadSecurityDescriptor();
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadSecurityDescriptor() failed (ec: %ld), Create default security descriptor"),
            rc);
    }
    else
    {
        //success
        return rc;
    }

    //
    // We failed to load the security descriptor
    //
    if (ERROR_NOT_ENOUGH_MEMORY == rc)
    {
        //
        // Do not let the service start
        //
        return rc;
    }

    //
    // The registry is corrupted - create the default security descriptor
    //
    rc = CreateDefaultSecurityDescriptor();
    if (ERROR_SUCCESS != rc)
    {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("CreateDefaultSecurityDescriptor() failed (ec: %ld)"),
           rc);
    }
    return rc;
}

//*********************************************************************************
//* Name:GetClientUserName()
//* Author: Ronen Barenboim
//* Date:   May 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the OS User Name of the connected RPC client.
//* PARAMETERS:
//*         None.
//* RETURN VALUE:
//*     A pointer to a newly allocated string holding the user name.
//*     The caller must free this string using MemFree().
//*     Returns NULL if an error occures.
//*     To get extended error information, call GetLastError.
//*********************************************************************************
LPWSTR
GetClientUserName(
    VOID
    )
{
    RPC_STATUS dwRes;
    LPWSTR lpwstrUserName = NULL;
    HANDLE hToken = NULL;
    PSID pUserSid;
    WCHAR  szShortUserName[64];
    WCHAR  szShortDomainName[64];
    DWORD dwUserNameLen     = sizeof(szShortUserName)   / sizeof(WCHAR);
    DWORD dwDomainNameLen   = sizeof(szShortDomainName) / sizeof(WCHAR);
    
    LPWSTR szUserName =     szShortUserName;    // first point to short on stack buffers
    LPWSTR szDomainName =   szShortDomainName;
    
    SID_NAME_USE SidNameUse;
    LPWSTR szLongUserName = NULL;
    LPWSTR szLongDomainName = NULL;

    DEBUG_FUNCTION_NAME(TEXT("GetClientUserName"));

    //
    // Impersonate the user.
    //
    dwRes=RpcImpersonateClient(NULL);

    if (dwRes != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient(NULL) failed. (ec: %ld)"),
            dwRes);
        SetLastError (dwRes);
        return NULL;
    }

    //
    // Open the thread token. We're in an RPC thread, not the main thread.
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenThreadToken failed. (ec: %ld)"),
            dwRes);
        goto exit;
    }

    //
    // Get the user's SID. A 128 byte long buffer should always suffice since
    // a SID length is limited to +/- 80 bytes at most.
    //
    BYTE abTokenUser[128];
    DWORD dwReqSize;

    if (!GetTokenInformation(hToken,
                             TokenUser,
                             (LPVOID)abTokenUser,
                             sizeof(abTokenUser),
                             &dwReqSize))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetTokenInformation failed. (ec: %ld)"),
            dwRes);
        goto exit;
    }

    //
    // Get the user name and domain.
    //
    pUserSid = ((TOKEN_USER *)abTokenUser)->User.Sid;

    //
    //  Try to get account Sid - with small on stack buffers
    //
    if (!LookupAccountSid(NULL,
                          pUserSid,
                          szShortUserName,
                          &dwUserNameLen,
                          szShortDomainName,
                          &dwDomainNameLen,
                          &SidNameUse))
    {
        dwRes = GetLastError();

        if (dwRes == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // At least one of buffer were too small.
            //
            if (dwUserNameLen > sizeof(szShortUserName) / sizeof(WCHAR))
            {
                //
                // Allocate a buffer for the user name.
                //
                szLongUserName = new (std::nothrow) WCHAR[dwUserNameLen];
                if (!szLongUserName)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to allocate user name buffer (%d bytes)"),
                        dwUserNameLen);
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                //
                //  Update szUserName to point to longer buffers
                //
                szUserName   = szLongUserName;
            }

            if (dwDomainNameLen > sizeof(szShortDomainName) / sizeof(WCHAR))
            {
                //
                // Allocate a buffer for the domain name.
                //
                szLongDomainName = new (std::nothrow) WCHAR[dwDomainNameLen];
                if (!szLongDomainName)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to allocate domain name buffer (%d bytes)"),
                        dwDomainNameLen);
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                //
                //  Update szDomainName to point to longer buffers
                //
                szDomainName = szLongDomainName;
                
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LookupAccountSid(1) failed. (ec: %ld)"),
                dwRes);
            goto exit;
        }

        //
        // Try now with larger buffers.
        //
        if (!LookupAccountSid(NULL,
                              pUserSid,
                              szUserName,
                              &dwUserNameLen,
                              szDomainName,
                              &dwDomainNameLen,
                              &SidNameUse))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LookupAccountSid(2) failed. (ec: %ld)"),
                dwRes);
            goto exit;
        }
        
    }

    //
    // Allocate a buffer for the combined string - domain\user
    //
    dwUserNameLen   = wcslen(szUserName);
    dwDomainNameLen = wcslen(szDomainName);

    lpwstrUserName = (LPWSTR)MemAlloc(sizeof(WCHAR) * (dwUserNameLen + dwDomainNameLen + 2));
    if (!lpwstrUserName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate user and domain name buffer (%d bytes)"),
            sizeof(WCHAR) * (dwUserNameLen + dwDomainNameLen + 2));
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Construct the combined string
    //
    memcpy(lpwstrUserName,
           szDomainName,
           sizeof(WCHAR) * dwDomainNameLen);
    lpwstrUserName[dwDomainNameLen] = L'\\';
    memcpy(lpwstrUserName + dwDomainNameLen + 1,
           szUserName,
           sizeof(WCHAR) * (dwUserNameLen + 1));

exit:
    DWORD dwErr = RpcRevertToSelf();
    if (RPC_S_OK != dwErr)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
            dwRes);
        Assert(dwErr == RPC_S_OK); // Assert(FALSE)
    }

    if (NULL != szLongUserName)
    {
        delete[] szLongUserName;
    }

    if (NULL != szLongDomainName)
    {
        delete[] szLongDomainName;
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (dwRes != ERROR_SUCCESS)
    {
        Assert (NULL == lpwstrUserName);
        SetLastError (dwRes);
    }
    return lpwstrUserName;
}


error_status_t
FAX_SetSecurity (
    IN handle_t hFaxHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN const LPBYTE lpBuffer,
    IN DWORD dwBufferSize
)
/*++

Routine name : FAX_SetSecurity

Routine description:

    RPC implementation of FaxSetSecurity

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in] - Unused
    SecurityInformation [in] - Defines the valid entries in the security descriptor (Bit wise OR )
    lpBuffer            [in] - Pointer to new security descriptor
    dwBufferSize        [in] - Buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DWORD rVal = ERROR_SUCCESS;
    DWORD rVal2;
    BOOL fAccess;
    ACCESS_MASK AccessMask = 0;
    HANDLE hClientToken = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetSecurity"));

    Assert (g_pFaxSD);
    Assert (IsValidSecurityDescriptor(g_pFaxSD));

    if (!lpBuffer || !dwBufferSize)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("'Error Null buffer"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Must validate the RPC blob before calling IsValidSecurityDescriptor();
    //
    if (!RtlValidRelativeSecurityDescriptor( (PSECURITY_DESCRIPTOR)lpBuffer,
                                             dwBufferSize,
                                             SecurityInformation))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RtlValidRelativeSecurityDescriptor failed"));
        return ERROR_INVALID_DATA;
    }

    //
    // Access check
    //
    if (SecurityInformation & OWNER_SECURITY_INFORMATION)
    {
        AccessMask |= WRITE_OWNER;
    }

    if (SecurityInformation & (GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION) )
    {
        AccessMask |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION)
    {
        AccessMask |= ACCESS_SYSTEM_SECURITY;
    }

    //
    // Block other threads from changing the SD
    //
    EnterCriticalSection (&g_CsSecurity);

    rVal = FaxSvcAccessCheck (AccessMask, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        goto exit;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to change the security descriptor"));
        rVal = ERROR_ACCESS_DENIED;
        goto exit;
    }

    //
    // Get the calling client access token
    //
    // Impersonate the user.
    //
    rVal = RpcImpersonateClient(NULL);
    if (rVal != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient(NULL) failed. (ec: %ld)"),
            rVal);
        goto exit;
    }

    //
    // Open the thread token. We're in an RPC thread, not the main thread.
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenThreadToken failed. (ec: %ld)"),
            rVal);

        DWORD dwErr = RpcRevertToSelf();
        if (RPC_S_OK != dwErr)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
                dwErr);
        }
        goto exit;
    }

    //
    // The calling process (SetPrivateObjectSecurity()) must not impersonate the client
    //
    rVal = RpcRevertToSelf();
    if (RPC_S_OK != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
            rVal);
        goto exit;
    }

    //
    // Get a new (Mereged) Fax service private object SD
    //
    if (!SetPrivateObjectSecurity ( SecurityInformation,
                                    (PSECURITY_DESCRIPTOR)lpBuffer,
                                    &g_pFaxSD,
                                    const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping),
                                    hClientToken))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetPrivateObjectSecurity failed. (ec: %ld)"),
            rVal);
        goto exit;
    }
    Assert (IsValidSecurityDescriptor(g_pFaxSD));

    //
    // Save the new SD
    //
    rVal = SaveSecurityDescriptor(g_pFaxSD);
    if (rVal != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error in SaveSecurityDescriptor (%ld)"),
            rVal);
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal2 = CreateConfigEvent (FAX_CONFIG_TYPE_SECURITY);
    if (ERROR_SUCCESS != rVal2)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_SECURITY) (ec: %lc)"),
            rVal2);
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsSecurity);
    if (NULL != hClientToken)
    {
        if (!CloseHandle(hClientToken))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle() failed. (ec: %ld)"),
                GetLastError());
        }
    }
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetSecurity


error_status_t
FAX_GetSecurityEx(
    IN  handle_t hFaxHandle,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPBYTE  *lpBuffer,
    OUT LPDWORD  lpdwBufferSize
    )
/*++

Routine Description:

    Retrieves the FAX security descriptor from the FAX server.

Arguments:

    hFaxHandle      - FAX handle obtained from FaxConnectFaxServer.
    SecurityInformation  - Defines the desired entries in the security descriptor (Bit wise OR )
    lpBuffer        - Pointer to a SECURITY_DESCRIPTOR structure.
    lpdwBufferSize  - Size of lpBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwDescLength = 0;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetSecurityEx"));
    BOOL fAccess;
    ACCESS_MASK AccessMask = 0;
    PSECURITY_DESCRIPTOR pSDPrivateObject = NULL;

    Assert (g_pFaxSD);
    Assert (IsValidSecurityDescriptor(g_pFaxSD));

    Assert (lpdwBufferSize);    // ref pointer in idl
    if (!lpBuffer)              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpBuffer = NULL;
    *lpdwBufferSize = 0;

    //
    // Block other threads from changing the SD
    //
    EnterCriticalSection (&g_CsSecurity);

    //
    // Access check
    //
    if (SecurityInformation & (GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION  |
                               OWNER_SECURITY_INFORMATION) )
    {
        AccessMask |= READ_CONTROL;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION)
    {
        AccessMask |= ACCESS_SYSTEM_SECURITY;
    }

    rVal = FaxSvcAccessCheck (AccessMask, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        goto exit;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the READ_CONTROL or ACCESS_SYSTEM_SECURITY"));
        rVal = ERROR_ACCESS_DENIED;;
        goto exit;
    }

    if (!IsValidSecurityDescriptor( g_pFaxSD ))
    {
        rVal = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed. Got invalid SD"));
        ASSERT_FALSE;
        goto exit;
    }

    //
    // Get the required buffer size
    //
    GetPrivateObjectSecurity( g_pFaxSD,                                    // SD
                              SecurityInformation,                         // requested info type
                              NULL,                                        // requested SD info
                              0,                                           // size of SD buffer
                              &dwDescLength                                // required buffer size
                              );

    //
    // Allocate returned security descriptor buffer
    //
    Assert(dwDescLength);
    *lpBuffer = (LPBYTE)MemAlloc(dwDescLength);
    if (NULL == *lpBuffer)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SD"));
        goto exit;
    }

    if (!GetPrivateObjectSecurity( g_pFaxSD,                                    // SD
                                   SecurityInformation,                         // requested info type
                                   (PSECURITY_DESCRIPTOR)*lpBuffer,             // requested SD info
                                   dwDescLength,                                // size of SD buffer
                                   &dwDescLength                                // required buffer size
                                   ))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetPrivateObjectSecurity() failed. (ec: %ld)"),
            rVal);
        goto exit;
    }

    *lpdwBufferSize = dwDescLength;
    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsSecurity);
    if (ERROR_SUCCESS != rVal)
    {
        MemFree (*lpBuffer);
        *lpBuffer = NULL;
        *lpdwBufferSize = 0;
    }
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetSecurityEx

error_status_t
FAX_GetSecurity(
    IN  handle_t hFaxHandle,
    OUT LPBYTE  *lpBuffer,
    OUT LPDWORD  lpdwBufferSize
    )
/*++

Routine Description:

    Retrieves the FAX security descriptor from the FAX server.

Arguments:

    hFaxHandle      - FAX handle obtained from FaxConnectFaxServer.
    lpBuffer        - Pointer to a SECURITY_DESCRIPTOR structure.
    lpdwBufferSize  - Size of lpBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetSecurity"));

    rVal = FAX_GetSecurityEx (hFaxHandle,
                              DACL_SECURITY_INFORMATION      |   // Read DACL
                              GROUP_SECURITY_INFORMATION     |   // Read group
                              OWNER_SECURITY_INFORMATION     |   // Read owner
                              SACL_SECURITY_INFORMATION,         // Read SACL
                              lpBuffer,
                              lpdwBufferSize);
    if (ERROR_ACCESS_DENIED == rVal)
    {
        //
        // Let's try without the SACL
        //
        rVal = FAX_GetSecurityEx (hFaxHandle,
                                  DACL_SECURITY_INFORMATION      |   // Read DACL
                                  GROUP_SECURITY_INFORMATION     |   // Read group
                                  OWNER_SECURITY_INFORMATION,        // Read owner
                                  lpBuffer,
                                  lpdwBufferSize);
    }
    return rVal;
}   // FAX_GetSecurity



error_status_t
FAX_AccessCheck(
   IN handle_t  hBinding,
   IN DWORD     dwAccessMask,
   OUT BOOL*    pfAccess,
   OUT LPDWORD  lpdwRights
   )
/*++

Routine name : FAX_AccessCheck

Routine description:

    Performs an access check against the fax service security descriptor

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    hBinding        [in ] - Handle to the Fax Server obtained from FaxConnectFaxServer()
    dwAccessMask    [in ] - Desired access
    pfAccess        [out] - Address of a BOOL to receive the access check return value (TRUE - access allowed).
    lpdwRights      [out] - Optional, Address of a DWORD to receive the access rights bit wise OR.
                            To get the access rights, set dwAccessMask to MAXIMUM_ALLOWED

Return Value:

    Standard Win32 error code.

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AccessCheck"));

    if (!pfAccess)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("fAccess is NULL "));
        return ERROR_INVALID_PARAMETER;
    }

    Rval = FaxSvcAccessCheck (dwAccessMask, pfAccess, lpdwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxSvcAccessCheck failed with error (%ld)"),
            Rval);
    }
    return GetServerErrorCode(Rval);
} // FAX_AccessCheck


//*********************************************************************************
//* Name:GetClientUserSID()
//* Author: Oded Sacher
//* Date:   Oct 26, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the  SID of the connected RPC client.
//* PARAMETERS:
//*         None.
//* RETURN VALUE:
//*     A pointer to a newly allocated SID buffer.
//*     The caller must free this buffer using MemFree().
//*     Returns NULL if an error occures.
//*     To get extended error information, call GetLastError.
//*********************************************************************************
PSID
GetClientUserSID(
    VOID
    )
{
    RPC_STATUS dwRes;
    PSID pUserSid;
    DEBUG_FUNCTION_NAME(TEXT("GetClientUserSID"));
    //
    // Impersonate the user.
    //
    dwRes=RpcImpersonateClient(NULL);

    if (dwRes != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient(NULL) failed. (ec: %ld)"),
            dwRes);
        SetLastError( dwRes);
        return NULL;
    }
    //
    // Get SID of (impersonated) thread
    //
    pUserSid = GetCurrentThreadSID ();
    if (!pUserSid)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetCurrentThreadSID failed. (ec: %ld)"),
            dwRes);
    }
    dwRes = RpcRevertToSelf();
    if (RPC_S_OK != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
            dwRes);
        ASSERT_FALSE;
        //
        // Free SID (if exists)
        MemFree (pUserSid);
        SetLastError (dwRes);
        return NULL;
    }
    return pUserSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\routerule.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RouteRule.h

Abstract:

    This file provides declaration of the service
    outbound routing rules.

Author:

    Oded Sacher (OdedS)  Dec, 1999

Revision History:

--*/

#ifndef _OUT_ROUTE_RULE_H
#define _OUT_ROUTE_RULE_H

#include <map>
#include <list>
#include <string>
#include <algorithm>

using namespace std;
#pragma hdrstop

#pragma warning (disable : 4786)    // identifier was truncated to '255' characters in the debug information
// This pragma does not work KB ID: Q167355


/************************************
*                                   *
*         CDialingLocation          *
*                                   *
************************************/
class CDialingLocation
{
public:
    CDialingLocation () {}
    CDialingLocation (DWORD dwCountryCode, DWORD dwAreaCode)
                      : m_dwCountryCode(dwCountryCode), m_dwAreaCode(dwAreaCode) {}
    ~CDialingLocation () {}

    BOOL IsValid () const;
    bool operator < ( const CDialingLocation &other ) const;
    DWORD GetCountryCode () const {return m_dwCountryCode;}
    DWORD GetAreaCode () const    {return m_dwAreaCode;}
    LPCWSTR GetCountryName () const;

private:

    DWORD m_dwCountryCode;
    DWORD m_dwAreaCode;
};  // CDialingLocation


/************************************
*                                   *
*     COutboundRoutingRule          *
*                                   *
************************************/
class COutboundRoutingRule
{
public:
    COutboundRoutingRule () {}
    ~COutboundRoutingRule () {}
    void Init (CDialingLocation DialingLocation, DWORD dwDevice)
    {
        m_dwDevice = dwDevice;
        m_bUseGroup = FALSE;
        m_DialingLocation = DialingLocation;
        return;
    }
    DWORD Init (CDialingLocation DialingLocation, wstring wstrGroupName);

    COutboundRoutingRule& operator= (const COutboundRoutingRule& rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        m_wstrGroupName = rhs.m_wstrGroupName;
        m_dwDevice = rhs.m_dwDevice;
        m_bUseGroup = rhs.m_bUseGroup;
        m_DialingLocation = rhs.m_DialingLocation;
        return *this;
    }

    DWORD GetStatus (FAX_ENUM_RULE_STATUS* lpdwStatus) const;
    DWORD GetDeviceList (LPDWORD* lppdwDevices, LPDWORD lpdwNumDevices) const;
    DWORD Save(HKEY hRuleKey) const;
    DWORD Load(HKEY hRuleKey);
    const CDialingLocation GetDialingLocation () const { return m_DialingLocation; }
    DWORD Serialize (LPBYTE lpBuffer,
                     PFAX_OUTBOUND_ROUTING_RULEW pFaxRule,
                     PULONG_PTR pupOffset,
					 DWORD dwBufferSize) const;
    LPCWSTR GetGroupName () const;

#if DBG
    void Dump () const;
#endif

private:
    wstring m_wstrGroupName;
    DWORD m_dwDevice;
    BOOL m_bUseGroup;       // Flag that indicates whether to use m_dwDevice or m_wstrGroupName
    CDialingLocation m_DialingLocation;

};  // COutboundRoutingRule

typedef COutboundRoutingRule  *PCRULE;

/************************************
*                                   *
*     COutboundRulesMap             *
*                                   *
************************************/

typedef map<CDialingLocation, COutboundRoutingRule>  RULES_MAP, *PRULES_MAP;

//
// The COutboundRulesMap class maps between group name and a list of device ID's
//
class COutboundRulesMap
{
public:
    COutboundRulesMap () {}
    ~COutboundRulesMap () {}

    DWORD Load ();
    DWORD AddRule (COutboundRoutingRule& Rule);
    DWORD DelRule (CDialingLocation& DialingLocation);
    DWORD SerializeRules (PFAX_OUTBOUND_ROUTING_RULEW* ppRules,
                          LPDWORD lpdwNumRules,
                          LPDWORD lpdwBufferSize) const;
    PCRULE  FindRule (CDialingLocation& DialingLocation) const;
    BOOL CreateDefaultRule (void);
    DWORD IsGroupInRuleDest (LPCWSTR lpcwstrGroupName, BOOL* lpbGroupInRule) const;

#if DBG
    void Dump () const;
#endif

private:
    RULES_MAP   m_RulesMap;
};  // COutboundRulesMap



/************************************
*                                   *
*         Externes                  *
*                                   *
************************************/

extern COutboundRulesMap* g_pRulesMap;       // Map of dialing location to list of device IDs
//
//  IMPORTANT - No locking mechanism - USE g_CsConfig to serialize calls to g_pRulesMap
//


/************************************
*                                   *
*         Functions                 *
*                                   *
************************************/

BOOL CheckDefaultRule (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\server.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This module contains the code to provide the RPC server.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

DWORD g_dwAllowRemote;	// If this is non-zero, the service will allow remote calls even if the local printer is not shared.
DWORD g_dwLastUniqueLineId;

DWORD g_dwRecipientsLimit;  // Limits the number of recipients in a single broadcast job. '0' means no limit.
FAX_SERVER_RECEIPTS_CONFIGW         g_ReceiptsConfig;           // Global receipts configuration
FAX_ARCHIVE_CONFIG          g_ArchivesConfig[2];        // Global archives configuration
FAX_SERVER_ACTIVITY_LOGGING_CONFIG g_ActivityLoggingConfig;    // Global activity logging configuration

const GUID gc_FaxSvcGuid = { 0xc3a9d640, 0xab07, 0x11d0, { 0x92, 0xbf, 0x0, 0xa0, 0x24, 0xaa, 0x1c, 0x1 } };

CFaxCriticalSection g_CsConfig;        // Protects configuration read / write

FAX_SERVER_ACTIVITY g_ServerActivity = {sizeof(FAX_SERVER_ACTIVITY), 0, 0, 0, 0, 0, 0, 0, 0};  //  Global Fax Service Activity
CFaxCriticalSection    g_CsActivity;              // Controls access to g_ServerActivity;

CFaxCriticalSection g_CsPerfCounters;
CFaxCriticalSection g_csUniqueQueueFile;

CFaxCriticalSection g_CsServiceThreads;     // Controls service global threads count
LONG                g_lServiceThreadsCount; // Service threads count
HANDLE              g_hThreadCountEvent;    // This Event is set when the service threads count is 0.

BOOL g_bServiceIsDown = FALSE;               // This is set to TRUE by FaxEndSvc()

DWORD g_dwOutboundSeconds;
DWORD g_dwInboundSeconds;
DWORD g_dwTotalSeconds;

HANDLE g_hFaxPerfCountersMap;
PFAX_PERF_COUNTERS g_pFaxPerfCounters;

#ifdef DBG
HANDLE g_hCritSecLogFile;
LIST_ENTRY g_CritSecListHead;
CFaxCriticalSection g_CsCritSecList;
#endif

#define PROGRESS_RESOLUTION         1000 * 10   // 10 seconds
#define STARTUP_SHUTDOWN_TIMEOUT    1000 * 30   // 30 seconds per FSP


HANDLE   g_hRPCListeningThread;

WCHAR   g_wszFaxQueueDir[MAX_PATH];


DWORD
FaxInitThread(
     PREG_FAX_SERVICE FaxReg
    );

DWORD WINAPI FaxRPCListeningThread(
  LPVOID pvUnused
);



VOID
PrintBanner(
    VOID
    )
{
#ifdef DBG
    DWORD LinkTime;
    TCHAR FileName[MAX_PATH]={0};
    DWORD VerSize;
    LPVOID VerInfo;
    VS_FIXEDFILEINFO *pvs;
    DWORD Tmp;
    LPTSTR TimeString;


    LinkTime = GetTimestampForLoadedLibrary( GetModuleHandle(NULL) );
    TimeString = _tctime( (time_t*) &LinkTime );
    TimeString[_tcslen(TimeString)-1] = 0;

    if (!GetModuleFileName( NULL, FileName, ARR_SIZE(FileName)-1 )) {
        return;
    }

    VerSize = GetFileVersionInfoSize( FileName, &Tmp );
    if (!VerSize) {
        return;
    }

    VerInfo = MemAlloc( VerSize );
    if (!VerInfo) {
        return;
    }

    if (!GetFileVersionInfo( FileName, 0, VerSize, VerInfo )) {
        return;
    }

    if (!VerQueryValue( VerInfo, TEXT("\\"), (LPVOID *)&pvs, (UINT *)&VerSize )) {
        MemFree( VerInfo );
        return;
    }

    DebugPrint(( TEXT("------------------------------------------------------------") ));
    DebugPrint(( TEXT("Windows XP Fax Server") ));
    DebugPrint(( TEXT("Copyright (C) Microsoft Corp 1996. All rights reserved.") ));
    DebugPrint(( TEXT("Built: %s"), TimeString ));
    DebugPrint(( TEXT("Version: %d.%d:%d.%d"),
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS)
        ));
    DebugPrint(( TEXT("------------------------------------------------------------") ));

    MemFree( VerInfo );

#endif //DBG
}



/*
 *  InitializeDefaultLogCategoryNames
 *
 *  Purpose:
 *          This function initializes the Name members of DefaultCategories,
 *          the global array of type FAX_LOG_CATEGORY.
 *
 *  Arguments:
 *          DefaultCategories - points to an array of FAX_LOG_CATEGORY structures.
 *          DefaultCategoryCount - the number of entries in DefaultCategories
 *
 *
 *  Returns:
 *          None.
 *
 */

VOID InitializeDefaultLogCategoryNames( PFAX_LOG_CATEGORY DefaultCategories,
                                        int DefaultCategoryCount )
{
    int         xCategoryIndex;
    int         xStringResourceId;
    LPTSTR      ptszCategoryName;

    for ( xCategoryIndex = 0; xCategoryIndex < DefaultCategoryCount; xCategoryIndex++ )
    {
        xStringResourceId = IDS_FAX_LOG_CATEGORY_INIT_TERM + xCategoryIndex;
        ptszCategoryName = GetString( xStringResourceId );

        if ( ptszCategoryName != (LPTSTR) NULL )
        {
            DefaultCategories[xCategoryIndex].Name = ptszCategoryName;
        }
        else
        {
            DefaultCategories[xCategoryIndex].Name = TEXT("");
        }
    }
    return;
}

DWORD
LoadConfiguration (
    PREG_FAX_SERVICE *ppFaxReg
)
/*++

Routine name : LoadConfiguration

Routine description:

    Loads the configuration of the Fax Server from the registry

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    ppFaxReg        [out] - Pointer to fax registry structure to recieve

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("LoadConfiguration"));

    EnterCriticalSection (&g_CsConfig);
    //
    // Get general settings (including outbox config)
    //
    dwRes = GetFaxRegistry(ppFaxReg);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxRegistry() failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    g_dwLastUniqueLineId = (*ppFaxReg)->dwLastUniqueLineId;
    g_dwMaxLineCloseTime = ((*ppFaxReg)->dwMaxLineCloseTime) ? (*ppFaxReg)->dwMaxLineCloseTime : 60 * 5; //Set default value to 5 minutes
    g_dwRecipientsLimit = (*ppFaxReg)->dwRecipientsLimit;
    g_dwAllowRemote = (*ppFaxReg)->dwAllowRemote;
    //
    // Get SMTP configuration
    //
    dwRes = LoadReceiptsSettings (&g_ReceiptsConfig);
    if (ERROR_SUCCESS != dwRes)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadReceiptsSettings() failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_RECEIPTS_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    //
    // Get inbox archive configuration
    //
    dwRes = LoadArchiveSettings (FAX_MESSAGE_FOLDER_INBOX,
                                 &g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX]);
    if (ERROR_SUCCESS != dwRes)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadArchiveSettings(FAX_MESSAGE_FOLDER_INBOX) failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_ARCHIVE_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    //
    // Get SentItems archive configuration
    //
    dwRes = LoadArchiveSettings (FAX_MESSAGE_FOLDER_SENTITEMS,
                                 &g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS]);
    if (ERROR_SUCCESS != dwRes)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadArchiveSettings(FAX_MESSAGE_FOLDER_SENTITEMS) failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_ARCHIVE_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    //
    // Get activity logging configuration
    //
    dwRes = LoadActivityLoggingSettings (&g_ActivityLoggingConfig);
    if (ERROR_SUCCESS != dwRes)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadActivityLoggingSettings() failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_ACTIVITY_LOGGING_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    dwRes = ReadManualAnswerDeviceId (&g_dwManualAnswerDeviceId);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Non-critical
        //
        g_dwManualAnswerDeviceId = 0;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReadManualAnswerDeviceId() failed (ec: %ld)"),
            dwRes);
    }

exit:
    LeaveCriticalSection (&g_CsConfig);
    return dwRes;
}   // LoadConfiguration


DWORD
ServiceStart(
    VOID
    )

/*++

Routine Description:

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.
.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD Rval;
    DWORD ThreadId;
    DWORD dwExitCode;
    HANDLE hThread = NULL;
    SECURITY_ATTRIBUTES SA;
    TCHAR*  ptstrSD = NULL;    // SDDL string
    ULONG  uSDSize=0;
    PREG_FAX_SERVICE FaxReg = NULL;
    RPC_BINDING_VECTOR *BindingVector = NULL;
    BOOL bLogEvent = TRUE;
    BOOL bRet = TRUE;
#if DBG
    HKEY hKeyLog;
    LPTSTR LogFileName;
#endif


   DEBUG_FUNCTION_NAME(TEXT("ServiceStart"));

   ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );

#ifdef DBG   

    hKeyLog = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SOFTWARE,FALSE,KEY_READ);
    if (hKeyLog)
    {
        LogFileName = GetRegistryString(hKeyLog,TEXT("CritSecLogFile"),TEXT("NOFILE"));

        if (_wcsicmp(LogFileName, TEXT("NOFILE")) != 0 )
        {

            g_hCritSecLogFile = SafeCreateFile(LogFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_ARCHIVE,
                                  NULL);
            if (g_hCritSecLogFile != INVALID_HANDLE_VALUE)
            {
                char AnsiBuffer[300];
                DWORD BytesWritten;

                wsprintfA(AnsiBuffer,
                          "Initializing log at %d\r\nTickCount\tObject\tObject Name\tCritical Section API\tFile\tLine\t(Time Held)\r\n",
                          GetTickCount()
                         );

                SetFilePointer(g_hCritSecLogFile,0,0,FILE_END);

                WriteFile(g_hCritSecLogFile,(LPBYTE)AnsiBuffer,strlen(AnsiBuffer) * sizeof(CHAR),&BytesWritten,NULL);
            }
        }

        MemFree( LogFileName );

        RegCloseKey( hKeyLog );
        ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    }
#endif

    PrintBanner();

    if (!IsFaxShared())
    {
        //
        // Make sure, that on non-shared SKUs, the fax printer is never shared.
        //
        BOOL bLocalFaxPrinterShared;
        DWORD dwRes;

        dwRes = IsLocalFaxPrinterShared (&bLocalFaxPrinterShared);
        if (ERROR_SUCCESS == dwRes)
        {
            if (bLocalFaxPrinterShared)
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Local fax printer is shared in desktop SKU - fixing that now."));
                dwRes = SetLocalFaxPrinterSharing (FALSE);
                if (ERROR_SUCCESS == dwRes)
                {
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("Local fax printer is no longer shared"));
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SetLocalFaxPrinterSharing() failed: err = %d"),
                        dwRes);
                }
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IsLocalFaxPrinterShared() failed: err = %d"),
                dwRes);
        }
        ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    }

    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // initialize the event log so we can log events
    //
    if (!InitializeEventLog( &FaxReg))
    {
        Rval = GetLastError();
        Assert (ERROR_SUCCESS != Rval);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeEventLog() failed: err = %d"),
            Rval);
        return Rval;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    
    //
    //  Enable SeAuditPrivilege
    //
    
    Rval = EnableProcessPrivilege(SE_AUDIT_NAME);
    if (ERROR_SUCCESS != Rval)  
    {
        //
        //  Failed to enable SeAuditPrivilege
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnableProcessPrivilege() failed: err = %d"),
            Rval);
        goto Error;
    }
    
    //
    // initialize the string table
    //
    if (!InitializeStringTable())
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeStringTable() failed: err = %d"),
            Rval);
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // Create an event to signal all service threads are terminated.
    // The event is set/reset by the service threads reference count mechanism.
    // (IncreaseServiceThreadsCount DecreaseServiceThreadsCount AND CreateThreadAndRefCount).
    // The event must be created after g_CsServiceThreads is initialized because it is used also to mark g_CsServiceThreads is initialized.
    //
    g_hThreadCountEvent = CreateEvent(
        NULL,   // SD
        TRUE,   // reset type - Manual
        TRUE,   // initial state - Signaled. We didn't create any service threads yet. The event is reset when the first thread is created.
        NULL    // object name
        );
    if (NULL == g_hThreadCountEvent)
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateEvent (g_hThreadCountEvent) failed (ec: %ld)"),
            Rval);
        goto Error;
    }
    //
    // Create the perf counters.
    // we must setup a security descriptor so other account (and other desktops) may access
    // the shared memory region
    //
    

    ptstrSD =   TEXT("O:NS")             // owner Network Service
                TEXT("G:NS")             // group Network Service
                TEXT("D:")               // DACL
                TEXT("(A;;GA;;;NS)")     // give Network Service full access
                TEXT("(A;;0x0004;;;AU)");// give Authenticated users FILE_MAP_READ access

    SA.nLength = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = FALSE;

    bRet = ConvertStringSecurityDescriptorToSecurityDescriptor (
                    ptstrSD,
                    SDDL_REVISION_1,
                    &(SA.lpSecurityDescriptor),
                    &uSDSize);
    if (!bRet)
    {
        Rval = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("ConvertStringSecurityDescriptorToSecurityDescriptor() failed. (ec: %lu)"),
                Rval);
        goto Error;
    }

    g_hFaxPerfCountersMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        &SA,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        sizeof(FAX_PERF_COUNTERS),
        FAXPERF_SHARED_MEMORY
        );
    if (NULL == g_hFaxPerfCountersMap)
    {
        Rval = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFileMapping() failed. (ec: %ld)"),
                Rval);
        if (ERROR_ACCESS_DENIED == Rval)
        {
            //
            // A malicious application holds the performance counter
            //
             FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    0,
                    MSG_FAX_UNDER_ATTACK                    
                  );
             bLogEvent = FALSE;
        }

        LocalFree(SA.lpSecurityDescriptor);
        goto Error;
    }
    LocalFree(SA.lpSecurityDescriptor);

    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    g_pFaxPerfCounters = (PFAX_PERF_COUNTERS) MapViewOfFile(
        g_hFaxPerfCountersMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (NULL == g_pFaxPerfCounters)
    {
        Rval = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("MapViewOfFile() failed. (ec: %ld)"),
                Rval);
        if (ERROR_ACCESS_DENIED == Rval)
        {
            //
            // A malicious application holds the performance counter
            //
             FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    0,
                    MSG_FAX_UNDER_ATTACK                    
                  );
             bLogEvent = FALSE;        
        }       
        goto Error;
    }

    //
    // Running totals used in computing total minutes sending and receiving
    // If perfmon not running the initial contents of the pages in the file mapping object are zero so this
    // globals are also zeroed. 
    // If perfmon is running the globals will get thier values from the shared memory.
    //
    EnterCriticalSection( &g_CsPerfCounters );
    
    g_dwOutboundSeconds = g_pFaxPerfCounters->OutboundMinutes   * 60;
    g_dwTotalSeconds    = g_pFaxPerfCounters->TotalMinutes      * 60;
    g_dwInboundSeconds  = g_pFaxPerfCounters->InboundMinutes    * 60;
    
    LeaveCriticalSection( &g_CsPerfCounters );


    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // get the registry data
    // the FaxInitThread will free this structure
    //
    Assert (FaxReg);
    Rval = LoadConfiguration (&FaxReg);
    if (ERROR_SUCCESS != Rval)
    {
        //
        // Event log issued by LoadConfiguration();
        //
        bLogEvent = FALSE;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadConfiguration() failed (ec: %ld)"),
            Rval);
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    
    if (g_ReceiptsConfig.dwAllowedReceipts & DRT_MSGBOX)
    {
        //
        // Current settings allow message box receipts
        //
        DWORD dwMessengerStartupType;
        if (ERROR_SUCCESS == GetServiceStartupType (NULL, MESSENGER_SERVICE_NAME, &dwMessengerStartupType))
        {
            if (SERVICE_DISABLED == dwMessengerStartupType)
            {
                //
                // Ooops. The local Messenger service is disabled. We can't send message boxes.
                //
                g_ReceiptsConfig.dwAllowedReceipts &= ~DRT_MSGBOX;
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("The local Messenger service is disabled. We can't send message boxes."));
                FaxLog( FAXLOG_CATEGORY_INIT,
                        FAXLOG_LEVEL_MIN,
                        0,
                        MSG_FAX_MESSENGER_SVC_DISABLED_WRN);
            }                
        }
    }   

    if (!InitializeFaxQueue(FaxReg))
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitFaxDirectories failed, Queue folder is unavailable (ec = %lu).")
            TEXT(" Job submission and receive are disabled."),
	       	Rval);

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            2,
            MSG_FAX_QUEUE_FOLDER_ERR,
            g_wszFaxQueueDir,
            DWORD2DECIMAL(Rval)
            );

		//
		//	disable job submission and receive
		//
        EnterCriticalSection (&g_CsConfig);
	    g_dwQueueState |= FAX_INCOMING_BLOCKED | FAX_OUTBOX_BLOCKED | FAX_OUTBOX_PAUSED;
    	LeaveCriticalSection (&g_CsConfig);
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // initialize activity logging
    //
    Rval = InitializeLogging();
    if (ERROR_SUCCESS != Rval)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeLogging failed, (ec = %lu).")
            TEXT(" Activity logging is disabled."),
	       	Rval);

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            2,
            MSG_FAX_ACTIVITY_LOG_FOLDER_ERR,
            g_ActivityLoggingConfig.lptstrDBPath,
            DWORD2DECIMAL(Rval)
            );

		//
		//	Disable activity logging
		//
		EnterCriticalSection (&g_CsInboundActivityLogging);
	    EnterCriticalSection (&g_CsOutboundActivityLogging);
        g_ActivityLoggingConfig.bLogOutgoing = FALSE;
        g_ActivityLoggingConfig.bLogIncoming = FALSE;
        LeaveCriticalSection (&g_CsOutboundActivityLogging);
	    LeaveCriticalSection (&g_CsInboundActivityLogging);

    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // Initialize events mechanism
    //
    Rval = InitializeServerEvents();
    if (ERROR_SUCCESS != Rval)
    {       
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeServerEvents failed (ec: %ld)"),
            Rval);

        FaxLog( FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(Rval)
              );
        bLogEvent = FALSE;
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );

    //
    // Initilaize the extension configuration notification map
    //
    Rval = g_pNotificationMap->Init ();
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CNotificationMap.Init() failed (ec: %ld)"),
            Rval);
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // Create a thread to do the rest of the initialization.
    // See FaxInitThread comments for details.
    //   

    hThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) FaxInitThread,
                            LPVOID(FaxReg),
                            0,
                            &ThreadId
                            );
    if (!hThread)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create FaxInitThread (CreateThread)(ec: %ld)."),
                        Rval = GetLastError());

        bLogEvent = FALSE;
        goto Error;
    }

    //
    //  Wait for FaxInitThread to terminate while report service status as PENDING to SCM
    //
    ReportServiceStatus( SERVICE_START_PENDING, 0, 2*PROGRESS_RESOLUTION );
    do
    {
        Rval = WaitForSingleObject(hThread,PROGRESS_RESOLUTION);
        if (Rval==WAIT_OBJECT_0)
        {
            bRet = GetExitCodeThread(hThread,&dwExitCode);
            if (!bRet)
            {
                DebugPrintEx(   DEBUG_ERR,
                                _T("GetExitCodeThread Failed (ec: %ld)."),
                                Rval = GetLastError());

                bLogEvent = FALSE;
                CloseHandle(hThread);
                goto Error;
            }
            // FaxInitThread finished successfully
            Rval = dwExitCode;
            break;
        }
        else if (Rval==WAIT_TIMEOUT)
        {
            DebugPrintEx(DEBUG_MSG,_T("Waiting for FaxInitThread to terminate.") );
            ReportServiceStatus( SERVICE_START_PENDING, 0, 3*PROGRESS_RESOLUTION );
        }
        else
        {
            // WAIT_FAILED
            DebugPrintEx(   DEBUG_ERR,
                            _T("WaitForSingleObject Failed (ec: %ld)."),
                            Rval = GetLastError());

            bLogEvent = FALSE;
            CloseHandle(hThread);
            goto Error;

        }
    }
    while (Rval==WAIT_TIMEOUT);
    CloseHandle(hThread);

    if (ERROR_SUCCESS != Rval)
    {
        //
        // FaxInitThread failed
        //
        DebugPrintEx( DEBUG_ERR,
                      _T("FaxInitThread Failed (ec: %ld)."),
                      Rval);
        bLogEvent = FALSE;
        goto Error;
    }

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        FAXLOG_LEVEL_MAX,
        0,
        MSG_SERVICE_STARTED
        );

    //
    // Get RPC going
    //
    Rval = StartFaxRpcServer( FAX_RPC_ENDPOINTW, fax_ServerIfHandle );
    if (Rval != 0 )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartFaxRpcServer() failed (ec: %ld)"),
            Rval);
        goto Error;
    }

    //
    // Create a thread to wait for all RPC calls to terminate.
    // This thread Performs the wait operation associated with RpcServerListen only, NOT the listening.
    //
    g_hRPCListeningThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxRPCListeningThread,
        NULL,
        0,
        &ThreadId);
    if (!g_hRPCListeningThread)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create FaxRPCListeningThread (CreateThread)(ec: %ld)."),
                        Rval = GetLastError());
        goto Error;
    }
    return ERROR_SUCCESS;

Error:
    //
    // the fax server did not initialize correctly
    //
    Assert (ERROR_SUCCESS != Rval);
    if (TRUE == bLogEvent)
    {            
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_INTERNAL,
                DWORD2DECIMAL(Rval)
                );
    }
    return Rval;
}


BOOL
NotifyServiceThreadsToTerminate(
    VOID
    )
/*++

Routine name : NotifyServiceThreadsToTerminate

Routine description:

    Notifies all service threads except TapiWorkerThreads that do not wait on g_hServiceShutDownEvent, 
    that the service is going down.

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    VOID            [ ]

Return Value:

    BOOL

--*/
{
    BOOL rVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("NotifyServiceThreadsToTerminate"));

    //
    //  Notify  FaxArchiveQuotaWarningThread & 
    //          FaxArchiveQuotaAutoDeleteThread &
    //          JobQueueThread
    //
    if (!SetEvent(g_hServiceShutDownEvent))
    {
        DebugPrintEx(
             DEBUG_ERR,
             TEXT("SetEvent failed (g_hServiceShutDownEvent) (ec = %ld)"),
             GetLastError());
        rVal = FALSE;
    }



    //
    // Notify FaxSendEventThread
    //
    if (NULL != g_hSendEventsCompPort)
    {
        if (!PostQueuedCompletionStatus( g_hSendEventsCompPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - g_hSendEventsCompPort). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    //
    // Notify FaxDispatchEventThread
    //
    if (NULL != g_hDispatchEventsCompPort)
    {
        if (!PostQueuedCompletionStatus( g_hDispatchEventsCompPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - g_hDispatchEventsCompPort). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    //
    // Notify CNotificationMap::ExtNotificationThread
    //
    if (NULL != g_pNotificationMap->m_hCompletionPort)
    {
        if (!PostQueuedCompletionStatus( g_pNotificationMap->m_hCompletionPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - ExtNotificationThread). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    //
    // Notify FaxStatusThread
    //
    if (NULL != g_StatusCompletionPortHandle)
    {
        if (!PostQueuedCompletionStatus( g_StatusCompletionPortHandle,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - FaxStatusThread). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

 
    return rVal;
}



BOOL
StopFaxServiceProviders()
{
    DWORD ThreadId;
    DWORD dwExitCode;
    BOOL bRet = TRUE;
    HANDLE hThread;
    DWORD Rval;
    DEBUG_FUNCTION_NAME(TEXT("StopFaxServiceProviders"));

    //
    // Call FaxDevShutDown() for all loaded FSPs
    //
    hThread = CreateThread( NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) ShutdownDeviceProviders,
                            (LPVOID)0,
                            0,
                            &ThreadId
                            );
    if (NULL == hThread)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create ShutdownDeviceProviders (ec: %ld)."),
                        GetLastError());
        bRet = FALSE;
    }
    else
    {
        //
        // Wait for FaxDevShutDown to terminate
        //
        ReportServiceStatus( SERVICE_STOP_PENDING, 0, 2*PROGRESS_RESOLUTION );
        do
        {
            Rval = WaitForSingleObject(hThread, PROGRESS_RESOLUTION);
            if (Rval == WAIT_OBJECT_0)
            {
                bRet = GetExitCodeThread(hThread, &dwExitCode);
                if (!bRet)
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    _T("GetExitCodeThread Failed (ec: %ld)."),
                                    GetLastError());
                    bRet = FALSE;
                    break;
                }
                // ShutdownDeviceProviders finished successfully
                bRet = (dwExitCode == ERROR_SUCCESS);
                SetLastError(dwExitCode);
                break;
            }
            else if (Rval == WAIT_TIMEOUT)
            {
                DebugPrintEx(DEBUG_MSG,_T("Waiting for ShutdownDeviceProviders to terminate"));
                ReportServiceStatus( SERVICE_STOP_PENDING, 0, 3*PROGRESS_RESOLUTION );
            }
            else
            {
                // WAIT_FAILED
                DebugPrintEx(   DEBUG_ERR,
                                _T("WaitForSingleObject Failed (ec: %ld)."),
                                GetLastError());
                bRet = FALSE;
                break;
            }
        }
        while (Rval == WAIT_TIMEOUT);
        CloseHandle(hThread);
    }
    return bRet;
}   // StopFaxServiceProviders


void
EndFaxSvc(
    DWORD SeverityLevel
    )
/*++

Routine Description:

    End the fax service.

    Service Shut down process:

        1)  Send a fax-event to legacy RPC clients notifying the service shutdown.
        
        2)  Stop service RPC server. Wait for all RPC threads to terminate and report to SCM.

        3)  Set g_ServiceIsDownFlag to indicate that the service is going down
            TapiWorkerThread and JobQueueThread become in-active (do not create new jobs).
            Setting it is done by synchronization with TapiWorkerThread
            and JobQueueThreadand making sure that no new job will be created after the flag is set.
            The setting is done using a separate thread while reporting SERVICE_STOP_PENDING to SCM.

        4)  Notify server threads (except TapiWorkerThread) to terminate. this is done by setting the 
            g_hServiceShutDownEvent and posting to completion ports.        

        5)  Destroy all in progress jobs (sends and recieves) by calling FaxDevAbortOperation.

        6)  Wait for all service threads (except TapiWorkerThread) to terminate while reporting 
            SERVICE_STOP_PENDING to SCM. this can last for few minutes, waiting for FSP to terminate.

        7)  Notify TapiWorkerThread to terminate by posting to it's completion post.
        
          
        8)  Wait for TapiWorkerThread to terminate while reporting SERVICE_STOP_PENDING to SCM.  

        9)  Stop service providers.

        10) Memory, resources and libraries clean up.



Arguments:

    SeverityLevel           - Event log severity level.

Return Value:

    None.

--*/
{
    DWORD Rval;

    DEBUG_FUNCTION_NAME(TEXT("EndFaxSvc"));
    Assert (g_hThreadCountEvent);

    //
    // let our legacy RPC clients know we're ending
    //
    if( !CreateFaxEvent(0,FEI_FAXSVC_ENDED,0xFFFFFFFF) )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateFaxEvent failed. (ec: %ld)"),
            GetLastError());
    }
    //
    // Stop the service RPC server
    //
    Rval = StopFaxRpcServer();
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StopFaxRpcServer failed. (ec: %ld)"),
            Rval);
    }
    //
    // set g_ServiceIsDownFlag to indicate that the service is going down
    // TapiWorkerThread and JobQueueThread become in-active (do not create new jobs)
    //
    if(!SetServiceIsDownFlag())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetServiceIsDownFlagAndReportServiceStatus() failed. (ec=%ld"),
            GetLastError());    
    }
    //
    // Notify all service threads (except TapiWorkerThread) that we go down
    //
    if (!NotifyServiceThreadsToTerminate())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("At least one thread did not get the shut down event, NotifyServiceThreadsToTerminate() failed"));
    }
    // 
    // Destroy all in-progress jobs (sends and recieves)
    //
    if (!StopAllInProgressJobs()) 
    {
        DebugPrintEx(DEBUG_ERR,
                     _T("StopAllInProgressJobs failed, not all jobs could be destroyed."));
    }
    //
    // Wait for all threads to terminate
    //
    //
    // Check if threads count mechanism is initialized
    //
    if (NULL != g_hThreadCountEvent)
    {
        if (!WaitAndReportForThreadToTerminate( g_hThreadCountEvent, 
                                                TEXT("Waiting for all threads (except TapiWorkerThread) to terminate."))) 
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("WaitAndReportForThreadToTerminate failed (ec: %ld)"),
                GetLastError());
        }

        ReportServiceStatus( SERVICE_STOP_PENDING, 0, 6*MILLISECONDS_PER_SECOND );

        //
        // EndFaxSvc() waits on g_hThreadCountEvent before returning to FaxServiceMain() that calls FreeServiceGlobals().
        // g_hThreadCountEvent is set inside critical section g_CsServiceThreads only when the service thread count is 0, yet when the event is set,
        // the last thread that set it, is still alive, and is calling LeaveCriritcalSection(g_CsServiceThreads).
        // We must block FreeServiceGlobals() from deleting g_CsServiceThreads, untill the last thread is out of the
        // g_CsServiceThreads critical section.
        //
        EnterCriticalSection (&g_CsServiceThreads);
        //
        // Now we are sure that the last thread is out of g_CsServiceThreads critical section,
        // so we can proceed and delete it.
        //
        LeaveCriticalSection (&g_CsServiceThreads);
    }
    //
    // Notify TapiWorkerThread to go down
    //
    if (NULL != g_TapiCompletionPort)
    {
        if (!PostQueuedCompletionStatus( g_TapiCompletionPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - TapiWorkerThread). (ec: %ld)"),
                GetLastError());
        }
    }
    //
    //  Wait for TapiWorkerThread to terminate. This call is blocking! It reports STOP_PENDING to SCM!
    //
    if (NULL != g_hTapiWorkerThread)
    {
        if (!WaitAndReportForThreadToTerminate( g_hTapiWorkerThread, 
                                                TEXT("Waiting for TapiWorkerThread to terminate."))) 
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("WaitAndReportForThreadToTerminate failed (ec: %ld)"),
                GetLastError());
        }
    }
    //
    // Tell all FSP's to shut down. This call is blocking! It reprts STOP_PENDING to SCM!
    //
    if (!StopFaxServiceProviders())
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("StopFaxServiceProviders failed (ec: %ld)"),
            GetLastError());
    }
    //
    // Free extensions (FSPs and Routing extensions)
    //
    UnloadDeviceProviders();
    FreeRoutingExtensions();
    //
    // Free service global lists
    //
    FreeServiceContextHandles();
    FreeTapiLines();
    //
    // Free the service queue
    //
    FreeServiceQueue();

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        SeverityLevel,
        0,
        MSG_SERVICE_STOPPED
        );
}   // EndFaxSvc


BOOL WaitAndReportForThreadToTerminate(HANDLE hThread, LPCTSTR strWaitMessage )
/*++

Routine Description:
    Wait for thread to terminate using it's handle.
    During the wait this function reports to SCM SERVICE_STOP_PENDING

Arguments:

    hThread - thread handle

Return Value:

    TRUE    on success.
    FALSE - on failure, To get extended error information, call GetLastError()

--*/
{
    BOOL    bRval=TRUE;
    DWORD   rVal;
    DWORD   ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("WaitAndReportForThreadToTerminate"));

    if (NULL == hThread)
    {
        //
        //  No thread to wait for
        //
        DebugPrintEx(DEBUG_MSG,_T("No thread to wait for . (NULL == hThread)") );
        return TRUE;
    }
 
    //
    //  Wait for SetServiceIsDownFlagThread to terminate while report service status as PENDING to SCM
    //
    ReportServiceStatus( SERVICE_STOP_PENDING, 0, 2*PROGRESS_RESOLUTION );
    do
    {
        rVal = WaitForSingleObject(hThread,PROGRESS_RESOLUTION);
        
        if (rVal == WAIT_OBJECT_0)
        {
            // ok thread terminate
            DebugPrintEx(DEBUG_MSG,_T("Wait terminated successfully.") );
        }
        else 
        if (rVal == WAIT_TIMEOUT)
        {
            DebugPrintEx(DEBUG_MSG,strWaitMessage);
            ReportServiceStatus( SERVICE_START_PENDING, 0, 2*PROGRESS_RESOLUTION );
        }
        else
        {
            // WAIT_FAILED
            Assert(WAIT_FAILED == rVal);

            ec = GetLastError();
            DebugPrintEx(   DEBUG_ERR,
                            _T("WaitForSingleObject Failed (ec: %ld)."),
                            ec);
            goto Exit;
        }
    }
    while (rVal==WAIT_TIMEOUT);


Exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    
    return (ERROR_SUCCESS == ec);
}


BOOL StopAllInProgressJobs(VOID)
/*++
Routine Description:
    Call this routine to abort all in-progress jobs.
    This routine is called during service shutdown.

    to insure that no other job will be created during or after calling this
    function you must make TapiWorkerThread and JobQueueThread inactive using g_ServiceIsDownFlag.

    You must *NOT* kill TapiWorkerThread for it must still send events to FSPs.

Arguments:

    None.

Return Value:

    TRUE    
        on success.
    FALSE   
        at least one job couldn't be aborted

--*/
{
    BOOL bRval=TRUE;

    DEBUG_FUNCTION_NAME(TEXT("StopAllInProgressJobs"));
    //
    //  iterate through the in-proggress jobs and destroy them
    //
    EnterCriticalSectionJobAndQueue;
    
    PLIST_ENTRY Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        PJOB_QUEUE JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        
        if (NULL != JobQueue->JobEntry  &&
            TRUE == JobQueue->JobEntry->bFSPJobInProgress &&
            FALSE == JobQueue->JobEntry->Aborting) 
        {            
            DebugPrintEx(DEBUG_MSG,
                         _T("[Job: %ld] Aborting in progress job due to service shut down."),
                         JobQueue->JobId);         
            //
            //  abort each job
            //
            __try
            {
                if (!JobQueue->JobEntry->LineInfo->Provider->FaxDevAbortOperation((HANDLE)JobQueue->JobEntry->InstanceData)) 
                {
                    DebugPrintEx(DEBUG_ERR,
                             _T("[Job: %ld] Trying to abort in progress job failed."),
                             JobQueue->JobId);
                    bRval = FALSE;
                }
            }
            __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, JobQueue->JobEntry->LineInfo->Provider->FriendlyName, GetExceptionCode()))
            {
                  ASSERT_FALSE;
            }
            //
            // Mark the job as system abort
            //
            JobQueue->JobEntry->fSystemAbort = TRUE;
        }
    }
    
    LeaveCriticalSectionJobAndQueue;

    return bRval;

}

DWORD
FaxInitThread(
    PREG_FAX_SERVICE FaxReg
    )
/*++

Routine Description:

    Initialize device providers, TAPI, job manager and router.
    This is done in a separate thread because NT Services should
    not block for long periods of time before setting the service status
    to SERVICE_RUNNING.  While a service is marked as START_PENDING, the SCM
    blocks all calls to StartService.  During TAPI initialization, StartService
    is called to start tapisrv and then tapisrv calls UNIMODEM that in turn
    calls StartService.

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    ULONG i = 0;
    BOOL GoodProt = FALSE;
	DWORD dwProviders;
    DEBUG_FUNCTION_NAME(TEXT("FaxInitThread"));  

    //
    // Initialize archives quota
    //
    ec = InitializeServerQuota();
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeServerQuota failed (ec: %ld)"),
            ec);

        FaxLog( FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
              );
        goto exit;
    }
    
    ec = InitializeServerSecurity();
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeServerSecurity failed with %ld."),
            ec);
        goto exit;
    }

    //
    // load the device providers (generates its own event log msgs)
    //
    if (!LoadDeviceProviders( FaxReg ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("At least one provider failed to load."));
    }

    //
    // Initialize the job manager data structures (inlcuding critical sections).
    // The job queue thread is NOT started here !!!
    // This must be called here since the rest of the initialization depends
    // on having the job queue related job structures in placed and initialized !
    //
    if (!InitializeJobManager( FaxReg ))
    {
        ec = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // get the inbound fax router up and running (generates its own event log messages)
    //
    // generates event log for any failed routing module.

    if (!InitializeRouting( FaxReg ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeRouting() failed (ec: %ld)."),
            ec);
        goto exit;
    }

    //
    // initialize TAPI devices (Note that it sets g_dwDeviceCount to the number of valid TAPI devices)
    //
    ec = TapiInitialize( FaxReg );
    if (ec)
    {
        //
        // Note: If ec is not 0 it can be a WINERROR or TAPI ERROR value.
        //+ g_ServerActivity    {...}        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("TapiInitialize() failed (ec: %ld)"),
            ec);
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_TAPI,
                DWORD2DECIMAL(ec)
               );
        goto exit;
    }

	//
	// Initialize the device providers extension configuration.
	// Must be called before InitializeDeviceProviders()
	//
	if (!InitializeDeviceProvidersConfiguration())
	{
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("At least one provider failed failed to initialize the extension configuration."),
			ec);
        //
        // Event log for each failed provider issued by InitializeDeviceProvidersConfiguration().
        //
	}

    //
    // Create the Legacy Virtual Devices. They must be created before the providers are initialized
    // (backword compatability).
    //
    g_dwDeviceCount += CreateVirtualDevices( FaxReg,FSPI_API_VERSION_1 );

    //
    // initialize the device providers [Note: we now initialize the providers before enumerating devices]
    // The Legacy FSPI did not specify when FaxDevVirtualDeviceCreation() will be called so we can
    // "safely" change that.
    //

    if (!InitializeDeviceProviders())
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("At least one provider failed failed to initialize."),
			ec);
        //
        // Event log for each failed provider issued by InitializeDeviceProviders().
        //         
    }   

	dwProviders = GetSuccessfullyLoadedProvidersCount();
    if (0 == dwProviders)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("No device provider was initialized."));

            FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MED,
                    0,
                    MSG_NO_FSP_INITIALIZED
                   );
    }    

    if (g_dwDeviceCount == 0)
    {
        //
        // No TAPI devices and no virtual devices.
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("No devices (TAPI + Virtual) found. exiting !!!."));

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MED,
            0,
            MSG_NO_FAX_DEVICES
            );
    }

    //
    // Update the manual answer device
    //
    UpdateManualAnswerDevice();

    //
    // Make sure we do not exceed device limit
    //
    ec = UpdateDevicesFlags();
    if (ERROR_SUCCESS != ec)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("UpdateDevicesFlags() failed (ec: %ld)"),
            ec);
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
               );
        goto exit;
    }

    UpdateVirtualDevices();
    //
    // Count number of devices that are receive-enabled
    //
    UpdateReceiveEnabledDevicesCount ();

    //
    // Get Outbound routing groups configuration
    //
    ec = g_pGroupsMap->Load();
    if (ERROR_SUCCESS != ec)
    {       
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::Load() failed (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
        goto exit;
    }

    if (!g_pGroupsMap->UpdateAllDevicesGroup())
    {        
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::UpdateAllDevicesGroup() failed (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
        goto exit;
    }

#if DBG
    g_pGroupsMap->Dump();
#endif

    //
    // Get Outbound routing rules configuration
    //
    ec = g_pRulesMap->Load();
    if (ERROR_SUCCESS != ec)
    {        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::Load() failed (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
        goto exit;
    }

    if (!g_pRulesMap->CreateDefaultRule())
    {        
         ec = GetLastError();
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::CreateDefaultRule() failed (ec: %ld)"),
            ec);
         FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
         goto exit;
    }

#if DBG
    g_pRulesMap->Dump();
#endif

    //
    // Create the JobQueueThread resources
    //
    g_hQueueTimer = CreateWaitableTimer( NULL, FALSE, NULL );
    if (NULL == g_hQueueTimer)
    {        
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateWaitableTimer() failed (ec: %ld)"),
            ec);

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }

    g_hJobQueueEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (NULL == g_hJobQueueEvent)
    {        
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateEvent() failed (ec: %ld)"),
            ec);

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }

    if (!CreateStatusThreads())
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create status threads (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }

    if (!CreateTapiThread())
    {        
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create tapi thread (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
           );
        goto exit;
    }

    if (!CreateJobQueueThread())
    {        
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create job queue thread (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }
    //
    // free the registry data
    //
    FreeFaxRegistry( FaxReg ); // It used to be a thread so it frees the input parameter itself

exit:
    return ec;
}   // FaxInitThread


DWORD WINAPI FaxRPCListeningThread(
    LPVOID pvUnused
    )
/*++

Routine Description:

    Performs the wait operation associated with RpcServerListen

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    DEBUG_FUNCTION_NAME(TEXT("FaxRPCListeningThread"));

    RpcStatus = RpcMgmtWaitServerListen();
    if (RPC_S_OK != RpcStatus)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcMgmtStopServerListening failed. (ec: %ld)"),
                RpcStatus);
    }
    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\tapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This module wraps all of the TAPI calls.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop
#include <vector>
using namespace std;
#include "tapiCountry.h"



//
// globals
//
HLINEAPP            g_hLineApp;                     // application line handle
HANDLE              g_TapiCompletionPort;           //

HANDLE              g_hTapiWorkerThread;            // holds the TapiWorkerThread handle


CFaxCriticalSection    g_CsLine;                         // critical section for accessing tapi lines
DWORD               g_dwDeviceCount;                    // number of devices in the g_TapiLinesListHead
LIST_ENTRY          g_TapiLinesListHead;              // linked list of tapi lines
LIST_ENTRY          g_RemovedTapiLinesListHead;       // linked list of removed tapi lines
LPBYTE              g_pAdaptiveFileBuffer;             // list of approved adaptive answer modems

DWORD               g_dwManualAnswerDeviceId;       // Id of (one and only) device capable of manual answering (protected by g_CsLine)

DWORD               g_dwDeviceEnabledLimit;       // Total number of devices
DWORD               g_dwDeviceEnabledCount;       // Device limt by SKU



static BOOL LoadAdaptiveFileBuffer();

static BOOL CreateLegacyVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    const REG_SETUP * lpRegSetup,
    DEVICE_PROVIDER * lpcProvider,
    LPDWORD lpdwDeviceCount);

DWORD g_dwMaxLineCloseTime;   // Wait interval in sec before trying to resend a powered off device

BOOL
AddNewDevice(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    BOOL fServerInitialization,
    PREG_FAX_DEVICES    pInputFaxReg
    );

DWORD
InitializeTapiLine(
    DWORD DeviceId,
    DWORD dwUniqueLineId,
    LPLINEDEVCAPS LineDevCaps,
    DWORD Rings,
    DWORD Flags,
    LPTSTR Csid,
    LPTSTR Tsid,
    LPTSTR lptstrDescription,
    BOOL fCheckDeviceLimit,
    DWORD dwDeviceType
    );

BOOL
RemoveTapiDevice(
    DWORD dwTapiDeviceId
    );

void
ResetDeviceFlags(
    PLINE_INFO pLineInfo
    )
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("ResetDeviceFlags"));

    Assert (pLineInfo);
    pLineInfo->Flags = (pLineInfo->Flags & FPF_VIRTUAL) ? FPF_VIRTUAL : 0; // send/receive disabled
    dwRes = RegSetFaxDeviceFlags( pLineInfo->PermanentLineID,
                                  pLineInfo->Flags);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegSetFaxDeviceFlags() (ec: %ld)"),
            dwRes);
    }

    if (pLineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
    {
        g_dwManualAnswerDeviceId = 0;  // Disable manual receive
        dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }
}

LPTSTR
FixupDeviceName(
    LPTSTR OrigDeviceName
    )
{
    LPTSTR NewDeviceName;
    LPTSTR p;


    NewDeviceName = StringDup( OrigDeviceName );
    if (!NewDeviceName) {
        return NULL;
    }

    p = _tcschr( NewDeviceName, TEXT(',') );
    if (!p) {
        return NewDeviceName;
    }

    p = NewDeviceName;

    while( p ) {
        p = _tcschr( p, TEXT(',') );
        if (p) {
            *p = TEXT('_');
        }
    }

    return NewDeviceName;
}

void
FreeTapiLines(
    void
    )
{
    PLIST_ENTRY     pNext;
    PLINE_INFO      pLineInfo;

    pNext = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
        pNext = pLineInfo->ListEntry.Flink;
        RemoveEntryList(&pLineInfo->ListEntry);
        FreeTapiLine(pLineInfo);
    }

    pNext = g_RemovedTapiLinesListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_RemovedTapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
        pNext = pLineInfo->ListEntry.Flink;
        RemoveEntryList(&pLineInfo->ListEntry);
        FreeTapiLine(pLineInfo);
    }
}


VOID
FreeTapiLine(
    PLINE_INFO LineInfo
    )
{
    HLINE hLine = NULL;


    if (!LineInfo)
    {
        return;
    }

    if (LineInfo->hLine)
    {
        hLine = LineInfo->hLine;
        LineInfo->hLine = NULL;
    }

    MemFree( LineInfo->DeviceName );
    MemFree( LineInfo->Tsid );
    MemFree( LineInfo->Csid );
    MemFree( LineInfo->lptstrDescription );

    MemFree( LineInfo );

    if (hLine)
    {
        lineClose( hLine );
    }
}



int
__cdecl
DevicePriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PDEVICE_SORT)arg1)->Priority < ((PDEVICE_SORT)arg2)->Priority) {
        return -1;
    }
    if (((PDEVICE_SORT)arg1)->Priority > ((PDEVICE_SORT)arg2)->Priority) {
        return 1;
    }
    return 0;
}

DWORD GetFaxDeviceCount(
    VOID
    )
/*++
Routine Description:

    counts the number of installed fax devices

Arguments:

    NONE.

Return Value:

    number of devices

--*/
{
    DWORD FaxDevices = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;

    EnterCriticalSection(&g_CsLine);

    Next = g_TapiLinesListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead) 
    {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (LineInfo->PermanentLineID && LineInfo->DeviceName) 
        {
            FaxDevices += 1;
        }
    }

    LeaveCriticalSection(&g_CsLine);
    return FaxDevices;
}


BOOL GetDeviceTypeCount(
    LPDWORD SendDevices,
    LPDWORD ReceiveDevices
    )
/*++
Routine Description:

    counts the number of devices with receive enabled, number with send enabled

Arguments:

    SendDevices - receives number of send devices
    ReceiveDevices - receives number of receive devices

Return Value:

    number of devices

--*/
{
    DWORD Rx = 0, Tx = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;

    EnterCriticalSection(&g_CsLine);

    Next = g_TapiLinesListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead) 
    {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (LineInfo->PermanentLineID && LineInfo->DeviceName) 
        {
            if ((LineInfo->Flags & FPF_SEND) == FPF_SEND) 
            {
                Tx++;
            }

            if ((LineInfo->Flags & FPF_RECEIVE) == FPF_RECEIVE) 
            {
                Rx++;
            }
        }
    }

    LeaveCriticalSection(&g_CsLine);
    if (SendDevices) 
    {
        *SendDevices = Tx;
    }

    if (ReceiveDevices) 
    {
        *ReceiveDevices = Rx;
    }
    return TRUE;
}

BOOL
CommitDeviceChanges(
    PLINE_INFO LineInfo
    )
/*++
Routine Description:

    commit device changes to registry.

Arguments:

    LineInfo - Pointer to the LINE_INFO describing the device to be commited.

Return Value:

    TRUE for success.

--*/
{

    EnterCriticalSection(&g_CsLine);
    RegAddNewFaxDevice(
                       &g_dwLastUniqueLineId,
                       &LineInfo->PermanentLineID,  // Do not create new device. Update it.
                       LineInfo->DeviceName,
                       LineInfo->Provider->ProviderName,
                       LineInfo->Provider->szGUID,
                       LineInfo->Csid,
                       LineInfo->Tsid,
                       LineInfo->TapiPermanentLineId,
                       LineInfo->Flags & 0x0fffffff,
                       LineInfo->RingsForAnswer);
    LeaveCriticalSection(&g_CsLine);
    return TRUE;


}
BOOL
SendIncomingCallEvent(
    PLINE_INFO LineInfo,
    LPLINEMESSAGE LineMsg,
    HCALL hCall
    )
/*++

Routine Description:
    This function posts FAX_EVENT_EX of
    FAX_EVENT_INCOMING_CALL type.

Arguments:
    LineInfo        - pointer to LINE_INFO structure
    LineMsg         - pointer to LINEMESSAGE structure
    hCall           - call handle to set into message

Return Values:
    TRUE for success
    FALSE for failure
--*/
{
    BOOL success = FALSE;
    DWORD dwEventSize;
    DWORD dwResult;
    PFAX_EVENT_EX pEvent = NULL;
    TCHAR CallerID[512];
    DEBUG_FUNCTION_NAME(TEXT("SendIncomingCallEvent"));

    //
    // save the line msg so we could verify hCall later
    //

    CopyMemory( &LineInfo->LineMsgOffering, LineMsg, sizeof(LINEMESSAGE) );

    //
    // allocate event structure, including caller ID info, if any
    //
    dwEventSize = sizeof(FAX_EVENT_EX);

    CallerID[0] = TEXT('\0');
    if(GetCallerIDFromCall(LineMsg->hDevice, CallerID, ARR_SIZE(CallerID)))
    {
        dwEventSize += (lstrlen(CallerID) + 1) * sizeof(TCHAR);
    }

    pEvent = (PFAX_EVENT_EX)MemAlloc(dwEventSize);
    if(!pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to notify clients of incoming call. Error allocating FAX_EVENT_EX"));
        goto Cleanup;
    }

    //
    // fill in event structure
    //
    ZeroMemory(pEvent, dwEventSize);
    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );
    pEvent->EventType = FAX_EVENT_TYPE_NEW_CALL;
    pEvent->EventInfo.NewCall.hCall = hCall;
    pEvent->EventInfo.NewCall.dwDeviceId = LineInfo->PermanentLineID;

    //
    // copy caller ID info, if available
    //
    if(CallerID[0] != TEXT('\0'))
    {
        pEvent->EventInfo.NewCall.lptstrCallerId = (LPTSTR) sizeof(FAX_EVENT_EX);
        lstrcpy((LPTSTR)((BYTE *)pEvent + sizeof(FAX_EVENT_EX)), CallerID);
    }

    //
    // post extended event to any clients
    //

    dwResult = PostFaxEventEx(pEvent, dwEventSize, NULL);
    if(dwResult != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to notify clients of incoming call. PostFaxEventEx() returned %x"),
            dwResult);
        goto Cleanup;
    }

    success = TRUE;

Cleanup:
    if (NULL != pEvent)
    {
        MemFree(pEvent);
    }
    return success;
}


ULONG
TapiWorkerThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This is worker thread for the FAX service.  All queued
    requests are processed here.

Arguments:

    None.

Return Value:

    Thread return value.

--*/

{
    PLINE_INFO LineInfo;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    LPLINEMESSAGE LineMsg = NULL;
    DWORD dwQueueState;
    BOOL fWakeupJobQueueThread;
    static BOOL fServiceIsDownSemaphoreWasReleased = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("TapiWorkerThread"));


    while( TRUE )
    {
        fWakeupJobQueueThread = FALSE;     // We want to wake up the JobQueueThread if a new devce was added.

        if (LineMsg)
        {
            LocalFree( LineMsg );
        }

        Rval = GetQueuedCompletionStatus(
            g_TapiCompletionPort,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &LineMsg,
            INFINITE
            );

        if (!Rval)
        {
            Rval = GetLastError();
            LineMsg = NULL;
            DebugPrintEx(DEBUG_ERR, TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"), Rval);
            continue;
        }


        if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {
            //
            // Service is shutting down
            //
            DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down"));
            break;
        }

        if(CompletionKey == ANSWERNOW_EVENT_KEY)
        {
            //
            // this is an event posted by FAX_AnswerCall
            //
            // the LINEMESSAGE structure must be filled out
            // as follows:
            //
            //     LineMsg->hDevice               ==  0
            //     LineMsg->dwMessageID           ==  0
            //     LineMsg->dwCallbackInstance    ==  0
            //     LineMsg->dwParam1              ==  Permanent device Id
            //     LineMsg->dwParam2              ==  0
            //     LineMsg->dwParam3              ==  0
            //

            PJOB_ENTRY pJobEntry;
            TCHAR FileName[MAX_PATH];
            DWORD dwOldFlags;

            EnterCriticalSection( &g_CsJob );
            EnterCriticalSection( &g_CsLine );

            if (TRUE == g_bServiceIsDown) 
            {
                //
                // Notify EndFaxSvc that we read the shutdown flag
                //
                if (FALSE == fServiceIsDownSemaphoreWasReleased)
                {
                    if (!ReleaseSemaphore(
                        g_hServiceIsDownSemaphore,      // handle to semaphore
                        1,                              // count increment amount
                        NULL                            // previous count
                        ))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                            GetLastError());
                    }
                    else
                    {
                        fServiceIsDownSemaphoreWasReleased = TRUE;
                    }
                }
                
                //
                // don't process event - from now on TapiWorkerThread is in-active
                // and only sends notifications to FSP
                //
                goto next_event;
            }
            //
            // Get LineInfo from permanent device ID
            //
            LineInfo = GetTapiLineFromDeviceId( (DWORD) LineMsg->dwParam1, FALSE );
            if(!LineInfo)
            {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("Line %ld not found"),
                             LineMsg->dwParam1);
                goto next_event;
            }
            //
            // See if the device is still available
            //
            if(LineInfo->State != FPS_AVAILABLE || LineInfo->JobEntry)
            {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("Line is not available (LineState is 0x%08x) or JobEntry is not NULL."),
                             LineInfo->State);
                goto next_event;
            }

            if (!LineInfo->LineMsgOffering.hDevice)
            {
                //
                // There's no offering call - this is the 'answer-now' mode.
                //
                // If the line is ringing at the same time (has a new call), we must close the line (to make
                // all active calls go away) and re-open it.
                //
                // From MSDN: "If an application calls lineClose while it still has active calls on the opened line,
                //             the application's ownership of these calls is revoked.
                //             If the application was the sole owner of these calls, the calls are dropped as well."
                //
                // Otherwise, when we call the FSP's FaxDevReceive() function with hCall=0,
                // it calls lineMakeCall (..., PASSTHROUGH) which always succeeds but doesn't get LINECALLSTATE_OFFERING
                // until the other offering call is over.
                //
                if (LineInfo->hLine)
                {
                    LONG lRes = lineClose(LineInfo->hLine);
                    if (ERROR_SUCCESS != lRes)
                    {
                        DebugPrintEx(DEBUG_ERR,
                                     TEXT("lineClose failed with 0x%08x"),
                                     lRes);
                    }
                    LineInfo->hLine = 0;
                }
            }
            if (LineInfo->hLine == NULL)
            {
                //
                // Line is closed - open it now
                // This can be because:
                // 1. This is the 'answer now' mode but the line was never send or receive enabled.
                // 2. This is the 'answer now' mode the line was open and there was no call offered, we closed the line (above).
                //
                if (!OpenTapiLine(LineInfo))
                {
                    DWORD dwRes = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("OpenTapiLine failed. (ec: %ld)"),
                        dwRes);
                    goto next_event;
                }
            }
            Assert (LineInfo->hLine);
            //
            // start a receive fax job
            //
            // If we don't fake FPF_RECEIVE, GetTapiLineForFaxOperation() will fail StartReceiveJob() if the device is not
            // set to receive (manually or automatically)
            //
            dwOldFlags = LineInfo->Flags;
            LineInfo->Flags |= FPF_RECEIVE;
            pJobEntry = StartReceiveJob(LineInfo->PermanentLineID);
            //
            // Restore original device flags.
            //
            LineInfo->Flags = dwOldFlags;
            if (pJobEntry)
            {
                if(ERROR_SUCCESS != StartFaxReceive(
                    pJobEntry,
                    (HCALL)LineInfo->LineMsgOffering.hDevice,  // This is either 0 (answer now) or the active hCall (manual-answer)
                    LineInfo,
                    FileName,
                    sizeof(FileName)/sizeof(FileName[0])
                    ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StartFaxReceive failed. Line: %010d (%s) (ec: %ld)"),
                        LineInfo->DeviceId,
                        LineInfo->DeviceName,
                        GetLastError());
                    //
                    // NTRAID#EdgeBugs-12677-2001/05/14-t-nicali: Should place an EVENTLOG entry here
                    //

                }
            }
            else
            {
                DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
            }
            goto next_event;
        }

        if ((CompletionKey == FAXDEV_EVENT_KEY) ||
            (CompletionKey == EFAXDEV_EVENT_KEY))
        {
            //
            // this is an event from a fax service provider
            // that has enumerated virtual device(s)
            //
            // the LINEMESSAGE structure must be filled out
            // as follows:
            //
            //     LineMsg->hDevice               ==  DeviceId from FaxDevStartJob()
            //     LineMsg->dwMessageID           ==  0
            //     LineMsg->dwCallbackInstance    ==  0
            //     LineMsg->dwParam1              ==  LINEDEVSTATE_RINGING
            //     LineMsg->dwParam2              ==  0
            //     LineMsg->dwParam3              ==  0
            //

            EnterCriticalSection( &g_CsJob );
            EnterCriticalSection( &g_CsLine );

            if (TRUE == g_bServiceIsDown) 
            {
                //
                // Notify EndFaxSvc that we read the shutdown flag
                //
                if (FALSE == fServiceIsDownSemaphoreWasReleased)
                {
                    if (!ReleaseSemaphore(
                        g_hServiceIsDownSemaphore,      // handle to semaphore
                        1,                              // count increment amount
                        NULL                            // previous count
                        ))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                            GetLastError());
                    }
                    else
                    {
                        fServiceIsDownSemaphoreWasReleased = TRUE;
                    }
                }

                //
                // don't process event - from now on TapiWorkerThread is in-active
                // and only sends notifications to FSP
                //
                goto next_event;
            }

            LineInfo = GetTapiLineFromDeviceId( (DWORD) LineMsg->hDevice,
                                                CompletionKey == FAXDEV_EVENT_KEY);
            if (!LineInfo) {
                goto next_event;
            }

            if (LineMsg->dwParam1 == LINEDEVSTATE_RINGING)
            {
                DWORD dwRes;
                LineInfo->RingCount += 1;
                if( !CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff ) )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateFaxEvent failed. (ec: %ld)"),
                        GetLastError());
                }

                dwRes = CreateDeviceEvent (LineInfo, TRUE);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateDeviceEvent() (ec: %lc)"),
                        dwRes);
                }

                EnterCriticalSection (&g_CsConfig);
                dwQueueState = g_dwQueueState;
                LeaveCriticalSection (&g_CsConfig);

                if ((LineInfo->State == FPS_AVAILABLE)        &&                   // Device is available and					
                    !LineInfo->JobEntry                                      &&     // no job on this device yet and 
                    !(dwQueueState & FAX_INCOMING_BLOCKED)    &&                   // The incoming queue is not blocked and
                    (LineInfo->Flags & FPF_RECEIVE))                               // Device is set to auto-receive
                {
                    PJOB_ENTRY JobEntry;
                    TCHAR FileName[MAX_PATH];
                    //
                    // start a fax job
                    //
                    JobEntry = StartReceiveJob( LineInfo->PermanentLineID);
                    if (JobEntry)
                    {
                        //
                        // receive the fax
                        //
                        if (ERROR_SUCCESS != StartFaxReceive(
                                                JobEntry,
                                                0,
                                                LineInfo,
                                                FileName,
                                                sizeof(FileName)/sizeof(FileName[0])
                                                ))
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("StartFaxReceive failed. Line: 0x%08X (%s) (ec: %ld)"),
                                LineInfo->DeviceId,
                                LineInfo->DeviceName,
                                GetLastError());
                        }
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
                    }
                }
            }

            goto next_event;
        }



        LineInfo = (PLINE_INFO) LineMsg->dwCallbackInstance;

#if DBG
        ShowLineEvent(
            (HLINE) LineMsg->hDevice,
            (HCALL) LineMsg->hDevice,
            LineInfo == NULL ? TEXT("*NULL LineInfo*") : (LineInfo->JobEntry == NULL) ? TEXT("*NULL Job*") : NULL,
            LineMsg->dwCallbackInstance,
            LineMsg->dwMessageID,
            LineMsg->dwParam1,
            LineMsg->dwParam2,
            LineMsg->dwParam3
            );
#endif // #if DBG

        EnterCriticalSection( &g_CsJob );
        EnterCriticalSection( &g_CsLine );

        if (TRUE == g_bServiceIsDown) 
        {
            //
            // Notify EndFaxSvc that we read the shutdown flag
            //
            if (FALSE == fServiceIsDownSemaphoreWasReleased)
            {
                if (!ReleaseSemaphore(
                    g_hServiceIsDownSemaphore,      // handle to semaphore
                    1,                              // count increment amount
                    NULL                            // previous count
                    ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                        GetLastError());
                }
                else
                {
                    fServiceIsDownSemaphoreWasReleased = TRUE;
                }
            }

            //
            // don't process event - from now on TapiWorkerThread is in-active
            // and only sends notifications to FSP
            //
            goto FSP_call_Back;
        }
        
        
        switch( LineMsg->dwMessageID )
        {
            case LINE_ADDRESSSTATE:
                break;

            case LINE_CALLINFO:
                //
                // generating FAX_EVENT_EX of type FAX_EVENT_TYPE_NEW_CALL when
                // caller ID info becomes available
                //
                if((LineMsg->dwParam1 == LINECALLINFOSTATE_CALLERID)            &&
                    (LineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
                    )
                {
                    //
                    // Only send ringing event about the device set to manual answering
                    //
                    SendIncomingCallEvent(LineInfo, LineMsg, (HCALL)LineMsg->hDevice);
                }
                break;

             case LINE_CALLSTATE:					                    

                    if (LineMsg->dwParam1 == LINECALLSTATE_IDLE)
                    {
						//
						// This is the last event on the call. make sure the line is deallocated.
						//
						if (NULL == LineInfo->JobEntry ||
                            (LineInfo->JobEntry && NULL == LineInfo->JobEntry->CallHandle))
						{
							//
							// We do not have the hCall in the JobEntry, release the call to prevent leaks
							//
							DebugPrintEx(DEBUG_WRN, TEXT("We have LINE_CALLSTATE (IDLE) msg, doing 'ReleaseTapiLine'\r\n"));
							ReleaseTapiLine( LineInfo, (HCALL) LineMsg->hDevice );
						}
                        LineInfo->NewCall = FALSE;
                        if ( !CreateFaxEvent( LineInfo->PermanentLineID, FEI_IDLE, 0xffffffff ) )
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                                GetLastError());
                        }
                        DWORD dwRes = CreateDeviceEvent (LineInfo, FALSE);
                        if (ERROR_SUCCESS != dwRes)
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("CreateDeviceEvent() (ec: %lc)"),
                                dwRes);
                        }
                    }
				else
				{
					//
					// Update the hCall in the JobEntry, so that EndJob()/ReleaseJob()will finally call lineDeallocateCall() to free the hCall.
					//
					if (NULL != LineInfo->JobEntry)
					{
						if (NULL == LineInfo->JobEntry->CallHandle)
						{
							//
							// FSP did not report the hCall yet.
							//
							LineInfo->JobEntry->CallHandle = (HCALL) LineMsg->hDevice;
						}

						if (LineInfo->JobEntry->CallHandle != (HCALL) LineMsg->hDevice)
						{
							//
							// we have a mismatch between the reported hCall from the FSP or previuos TAPI event and the hCall reproted by TAPI.
							//
							DebugPrintEx(
								DEBUG_WRN,
								TEXT("Mismatch between the reported hCall from the FSP or previuos TAPI event and the hCall reproted by TAPI"));							
						}							
					}
				}

                if (LineInfo->NewCall && LineMsg->dwParam1 != LINECALLSTATE_OFFERING && LineInfo->State == FPS_AVAILABLE)
                {
                    LineInfo->State = FPS_NOT_FAX_CALL;
                    LineInfo->NewCall = FALSE;
                }

                //
                // generating FAX_EVENT_EX of type FAX_EVENT_NEW_INCOMING_CALL when
                // line call state changes
                //
                if (LineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
                {
                    //
                    // Only send ringing event about the device set to manual answering
                    //
                    // When a call is offered to us, we send the event with hCall
                    // and any caller ID info we might have
                    //
                    if(LineMsg->dwParam1 == LINECALLSTATE_OFFERING)
                    {
                        SendIncomingCallEvent(LineInfo, LineMsg, (HCALL)LineMsg->hDevice);
                    }
                    //
                    // when the caller hangs up, we send the event without hCall
                    //
                    if(LineMsg->dwParam1 == LINECALLSTATE_IDLE)
                    {
                        SendIncomingCallEvent(LineInfo, LineMsg, NULL);
                    }
                }

                if (LineMsg->dwParam1 == LINECALLSTATE_OFFERING)
                {
                    //
                    // we'll get a LINE_LINEDEVSTATE (RINGING) event, so we'll post the ring event there or we'll get a duplicate event
                    //
                    LineInfo->NewCall = FALSE;

                    if ((LineInfo->State == FPS_AVAILABLE)                      &&      //  Line is available and
                        (LineInfo->Flags & FPF_RECEIVE))                                //  Line is set to receive
                    {
                        EnterCriticalSection (&g_CsConfig);
                        dwQueueState = g_dwQueueState;
                        LeaveCriticalSection (&g_CsConfig);
                        if ((LineInfo->RingCount > LineInfo->RingsForAnswer)         &&     // Rings exceeded threshold and
                            !LineInfo->JobEntry                                      &&     // no job on this device yet and
                            !(dwQueueState & FAX_INCOMING_BLOCKED)                          // Incoming queue is not blocked
                            )
                        {
                            PJOB_ENTRY JobEntry;
                            TCHAR FileName[MAX_PATH];
                            //
                            // start a fax job
                            //
                            JobEntry = StartReceiveJob( LineInfo->PermanentLineID);
                            if (JobEntry)
                            {
                                //
                                // receive the fax
                                //
                                if (ERROR_SUCCESS != StartFaxReceive(
                                                        JobEntry,
                                                        (HCALL) LineMsg->hDevice,
                                                        LineInfo,
                                                        FileName,
                                                        sizeof(FileName)/sizeof(FileName[0])
                                                        ))
                                {
                                    DebugPrintEx(
                                        DEBUG_ERR,
                                        TEXT("StartFaxReceive failed. Line: 0x%08X (%s) (ec: %ld)"),
                                        LineInfo->DeviceId,
                                        LineInfo->DeviceName,
                                        GetLastError());
                                }
                            }
                            else
                            {
                                DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
                            }
                        }
                        else
                        {
                            //
                            // save the line msg
                            //
                            CopyMemory( &LineInfo->LineMsgOffering, LineMsg, sizeof(LINEMESSAGE) );
                        }
                    }
                    else
                    {
                        //
                        // we are not supposed to answer the call, so give it to ras
                        //
                        HandoffCallToRas( LineInfo, (HCALL) LineMsg->hDevice );
                    }
                }
                break;

                case LINE_CLOSE:
                    {
                        //
                        // this usually happens when something bad happens to the modem device.
                        //
                        DebugPrintEx( DEBUG_MSG,
                                      (TEXT("Received LINE_CLOSE message for device %x [%s]."),
                                       LineInfo->DeviceId,
                                       LineInfo->DeviceName) );

                        LineInfo->hLine = NULL;
                        LineInfo->State = FPS_AVAILABLE;
                        GetSystemTimeAsFileTime ((FILETIME*)&LineInfo->LastLineClose);

                        if ((LineInfo->Flags & FPF_RECEIVE) ||                          // Line is in auto-anser or
                            (g_dwManualAnswerDeviceId == LineInfo->PermanentLineID))    // manual-answer mode
                        {
                            //
                            // Try to reopen the line
                            //
                            if (!OpenTapiLine(LineInfo))
                            {
                                DebugPrintEx( DEBUG_ERR,
                                              TEXT("OpenTapiLine failed for device %s"),
                                              LineInfo->DeviceName);
                            }
                        }
                        else
                        {
                            LineInfo->Flags |= FPF_POWERED_OFF;
                        }                        
                    }
                    break;
            case LINE_DEVSPECIFIC:
                break;

            case LINE_DEVSPECIFICFEATURE:
                break;

            case LINE_GATHERDIGITS:
                break;

            case LINE_GENERATE:
                break;

            case LINE_LINEDEVSTATE:
                if (LineMsg->dwParam1 == LINEDEVSTATE_RINGING)
                {
                    DWORD dwRes;

                    LineInfo->RingCount = (DWORD)LineMsg->dwParam3 + 1;

                    if( !CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff ) )
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CreateFaxEvent failed. (ec: %ld)"),
                            GetLastError());
                    }
                    dwRes = CreateDeviceEvent (LineInfo, TRUE);
                    if (ERROR_SUCCESS != dwRes)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CreateDeviceEvent() (ec: %lc)"),
                            dwRes);
                    }

                    //
                    // Pick up the line only if the last inbound job has completed
                    //
                    if (LineInfo->State != FPS_AVAILABLE)
                    {
                        break;
                    }
                    EnterCriticalSection (&g_CsConfig);
                    dwQueueState = g_dwQueueState;
                    LeaveCriticalSection (&g_CsConfig);
                    if (dwQueueState & FAX_INCOMING_BLOCKED)
                    {
                        //
                        // Inbox is blocked - no incoming faxes will be received.
                        //
                        break;
                    }
                    if ((LineInfo->Flags & FPF_RECEIVE)     &&      //    Line is set to receive and
                        (LineInfo->State == FPS_AVAILABLE))         //    the line is available
                    {
                        if (LineInfo->LineMsgOffering.hDevice == 0)
                        {
                            //
                            // wait for the offering message
                            //
                            break;
                        }

                        if ((LineInfo->RingCount > LineInfo->RingsForAnswer)  &&    // Rings count match and
                            !LineInfo->JobEntry                                     // There's no job on the line
                            )
                        {
                            PJOB_ENTRY JobEntry;
                            TCHAR FileName[MAX_PATH];
                            //
                            // Start a fax job
                            //
                            JobEntry = StartReceiveJob( LineInfo->PermanentLineID);
                            if (JobEntry)
                            {
                                //
                                // Receive the fax
                                //
                                if (ERROR_SUCCESS != StartFaxReceive(
                                                        JobEntry,
                                                        (HCALL) LineInfo->LineMsgOffering.hDevice,
                                                        LineInfo,
                                                        FileName,
                                                        sizeof(FileName)/sizeof(FileName[0])
                                                        ))
                                {
                                    DebugPrintEx(
                                        DEBUG_ERR,
                                        TEXT("StartFaxReceive failed. Line: 0x%08X (%s) (ec: %ld)"),
                                        LineInfo->DeviceId,
                                        LineInfo->DeviceName,
                                        GetLastError());
                                }
                            }
                            else
                            {
                                DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
                            }
                        }
                    }
                    else
                    {
                        //
                        // we are not supposed to answer the call, so give it to ras
                        //
                        HandoffCallToRas( LineInfo, (HCALL) LineInfo->LineMsgOffering.hDevice );
                    }
                }
                break;

            case LINE_MONITORDIGITS:
                break;

            case LINE_MONITORMEDIA:
                break;

            case LINE_MONITORTONE:
                break;

            case LINE_REPLY:
                break;

            case LINE_REQUEST:
                break;

            case PHONE_BUTTON:
                break;

            case PHONE_CLOSE:
                break;

            case PHONE_DEVSPECIFIC:
                break;

            case PHONE_REPLY:
                break;

            case PHONE_STATE:
                break;

            case LINE_CREATE:
                {
                    LPLINEDEVCAPS LineDevCaps;
                    LINEEXTENSIONID lineExtensionID;
                    DWORD LocalTapiApiVersion;
                    DWORD Rslt;
                    DWORD DeviceId;

                    DeviceId = (DWORD)LineMsg->dwParam1;


                    Rslt = lineNegotiateAPIVersion(
                        g_hLineApp,
                        DeviceId,
                        MIN_TAPI_LINE_API_VER,
                        MAX_TAPI_LINE_API_VER,
                        &LocalTapiApiVersion,
                        &lineExtensionID
                        );
                    if (Rslt == 0)
                    {
                        LineDevCaps = SmartLineGetDevCaps(g_hLineApp, DeviceId , LocalTapiApiVersion);
                        if (LineDevCaps)
                        {
                            EnterCriticalSection(&g_CsLine);
                            EnterCriticalSection(&g_CsConfig);
                            if (!AddNewDevice( DeviceId, LineDevCaps, FALSE , NULL))
                            {
                                DebugPrintEx(
                                    DEBUG_WRN,
                                    TEXT("AddNewDevice() failed for Tapi Permanent device id: %ld (ec: %ld)"),
                                    LineDevCaps->dwPermanentLineID,
                                    GetLastError());
                            }
                            else
                            {
                                //
                                // A new device was succesfully added - wake up the JobQueueThread
                                //
                                fWakeupJobQueueThread = TRUE;
                            }
                            LeaveCriticalSection(&g_CsConfig);
                            LeaveCriticalSection(&g_CsLine);
                            MemFree( LineDevCaps );
                            UpdateReceiveEnabledDevicesCount ();
                        }
                    }
                }
                break;

            case PHONE_CREATE:
                break;

            case LINE_AGENTSPECIFIC:
                break;

            case LINE_AGENTSTATUS:
                break;

            case LINE_APPNEWCALL:
                LineInfo->NewCall = TRUE;
                break;

            case LINE_PROXYREQUEST:
                break;

            case LINE_REMOVE:
                {
                    DWORD dwDeviceId = (DWORD)LineMsg->dwParam1;

                    EnterCriticalSection(&g_CsLine);
                    EnterCriticalSection (&g_CsConfig);
                    if (!RemoveTapiDevice(dwDeviceId))
                    {
                        DebugPrintEx( DEBUG_WRN,
                                        TEXT("RemoveTapiDevice() failed for device id: %ld (ec: %ld)"),
                                        dwDeviceId,
                                        GetLastError());
                    }
                    LeaveCriticalSection(&g_CsConfig);
                    LeaveCriticalSection(&g_CsLine);
                    UpdateReceiveEnabledDevicesCount ();
                }
                break;

            case PHONE_REMOVE:
                break;
        }


FSP_call_Back:
        //
        // call the device provider's line callback function
        //
        if (LineInfo && LineInfo->JobEntry)
        {
            Assert (LineInfo->Provider && LineInfo->Provider->FaxDevCallback);

            __try
            {
                LineInfo->Provider->FaxDevCallback(
                    (HANDLE) LineInfo->JobEntry->InstanceData,
                    LineMsg->hDevice,
                    LineMsg->dwMessageID,
                    LineMsg->dwCallbackInstance,
                    LineMsg->dwParam1,
                    LineMsg->dwParam2,
                    LineMsg->dwParam3
                    );
            }
            __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, LineInfo->Provider->FriendlyName, GetExceptionCode()))
            {
                ASSERT_FALSE;
            }
        }

next_event:
        
        LeaveCriticalSection( &g_CsLine );
        LeaveCriticalSection( &g_CsJob );


        //
        // Check if we should wake up the JobQueueThread (if a new device was added)
        //
        if (TRUE == fWakeupJobQueueThread)
        {
            if (!SetEvent( g_hJobQueueEvent ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                    GetLastError());

                EnterCriticalSection (&g_CsQueue);  
                g_ScanQueueAfterTimeout = TRUE;
                LeaveCriticalSection (&g_CsQueue);
            }
        }
    }
    //
    // Notify EndFaxSvc that we read the shutdown flag
    //
    if (FALSE == fServiceIsDownSemaphoreWasReleased)
    {
        if (!ReleaseSemaphore(
            g_hServiceIsDownSemaphore,      // handle to semaphore
            1,                              // count increment amount
            NULL                            // previous count
            ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseSemaphore() failed, (ec = %ld)"),
                GetLastError());
        }       
    }
    return 0;
}


BOOL
HandoffCallToRas(
    PLINE_INFO LineInfo,
    HCALL hCall
    )

/*++

Routine Description:

    This function will try to hand a call of to RAS.
    We do this under 2 circumstances:
        1) we've answered an incoming call and
           determined that the call is NOT a fax call
        2) the configuration for the line that is
           ringing is not configured for receiving faxes
    If the handoff fails and we have an open job for the
    line, then we have to call the device provider so that
    the line can be put on hook.

Arguments:

    LineInfo    - LineInfo structure for the line this call is on
    hCall       - TAPI call handle

Return Value:

    TRUE for success
    FALSE for failure

--*/

{
    LONG Rval;
    DEBUG_FUNCTION_NAME(TEXT("HandoffCallToRas"));

    //
    // need to hand the call off to RAS
    //

    Rval = lineHandoff(
        hCall,
        RAS_MODULE_NAME,
        LINEMEDIAMODE_DATAMODEM
        );
    if (Rval != 0 && LineInfo && LineInfo->JobEntry)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("lineHandoff() failed, ec=0x%08x"), Rval);
	}
    else
    {
        DebugPrintEx(DEBUG_MSG, TEXT("call handed off to RAS"));
    }
    return Rval == 0;
}


PLINE_INFO
GetTapiLineFromDeviceId(
    DWORD DeviceId,
    BOOL  fLegacyId
    )
{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;


    Next = g_TapiLinesListHead.Flink;
    if (!Next) {
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead) {

        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (fLegacyId)
        {
            if (LineInfo->TapiPermanentLineId == DeviceId) {
                return LineInfo;
            }
        }
        else
        {
            if (LineInfo->PermanentLineID == DeviceId) {
                return LineInfo;
            }
        }
    }

    return NULL;
}



//*********************************************************************************
//* Name:   GetLineForSendOperation()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns a line to be used for a send operation.
//*
//* PARAMETERS:
//*     [IN ]       PJOB_QUEUE lpJobQueue
//*         The recipient job for which the line is intended.
//*
//* RETURN VALUE:
//*     On success the function returns a pointer to the LINE_INFO structure of
//*     the selected line.
//*     On failure it returns NULL.
//*********************************************************************************
PLINE_INFO
GetLineForSendOperation(
    PJOB_QUEUE lpJobQueue
	)
{
    DEBUG_FUNCTION_NAME(TEXT("GetLineForSendOperation"));
    Assert(lpJobQueue);    
        
    return GetTapiLineForFaxOperation(
        USE_SERVER_DEVICE,
        JT_SEND,
        lpJobQueue->RecipientProfile.lptstrFaxNumber
        );
}



//*********************************************************************************
//* Name:   GetTapiLineForFaxOperation()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Locates an avaliable TAPI device for use in a
//*     FAX operation.  The selection is based on the
//*     available devices and their assigned priority.
//*     If DeviceId is USE_SERVER_DEVICE the function will locate a device which
//*     can be used for the job type specified. It does not revive devices in this
//*     case.
//*
//*     If DeviceId contains a specific device
//*     If Handoff is TRUE and the job type is JT_SEND
//*         The function will return the LINE_INFO for the specified line without
//*         checking if it is availble or not or configured for send or receive.
//*     Else
//*         The function will check first if the specified device match the
//*         requested job type and then return LINE_INFO.
//*         If the device is powered off the function will attempt to revive it.
//*
//* PARAMETERS:
//*     [IN ]       DWORD DeviceId
//*             The permanent device id (not tapi) of the line. If it is
//*             USE_SERVER_DEVICE the function will select a line based on the
//*             line send/receive capabilities, status and priorities.
//*
//*     [IN ]       DWORD JobType
//*             The type of job that is about to be executed on the line.
//*             can be JT_RECEIVE or JT_SEND.
//*
//*     [IN ]       LPWSTR FaxNumber
//*             For a send operation this is the fax number that is going to be
//*             used to send the fax. The function uses it to avoid sending
//*             to faxes to the same number simultaneously.
//*
//* RETURN VALUE:
//*         If the function succeeds it returns a pointer to the LINE_INFO
//*         structure of the selected line.  Otherwise it returns NULL.
//*         If it is NULL the function failed. Call GetLastError() for more info.
//*********************************************************************************
PLINE_INFO
GetTapiLineForFaxOperation(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber    
    )
{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    PLINE_INFO SelectedLine = NULL;
    LPDWORD lpdwDevices = NULL;
    DEBUG_FUNCTION_NAME(TEXT("GetTapiLineForFaxOperation"));
    DWORD ec = ERROR_SUCCESS;

    EnterCriticalSection( &g_CsLine );

    if (FaxNumber)
    {
        if (FindJobEntryByRecipientNumber(FaxNumber))
        {
            //
            // We do not allow to outgoing calls to the same number.
            //
            LeaveCriticalSection( &g_CsLine );
            SetLastError (ERROR_NOT_FOUND);
            return NULL;
        }
    }

    //
    // Find out if there is another send job to the same number.
    // It there is do not select a line and return NULL.
    //

    if (DeviceId != USE_SERVER_DEVICE)
    {		
		Assert (JobType == JT_RECEIVE);
        Next = g_TapiLinesListHead.Flink;
        Assert (Next);

        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
        {
            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;
            //
            // The caller specified a specific device to use. Just find it for him.
            //
            if (LineInfo->PermanentLineID == DeviceId)
            {
                //
                // Found a device with a matching id.
                //
				if (NULL != LineInfo->JobEntry)
				{
					//
                    // Device is busy with another job
                    //
                    break;
				}               

                if ((LineInfo->Flags & FPF_RECEIVE)                            ||      //    Line is in auto-answer mode or
                    (g_dwManualAnswerDeviceId == LineInfo->PermanentLineID)            //    this is the manual-answer device                    
                   )
                {
                    //
                    // For receive jobs we assume that the requested device is free since it is
                    // the FSP that tells us when to receive.                    
                    // we need to mark it as unavailable until the receive operation is completed.
                    //                                       
                    LineInfo->State = 0; // remove the FPS_AVAILABLE bit                    
                    SelectedLine = LineInfo;
                    break;
                }
                
                if (LineInfo->UnimodemDevice && (LineInfo->Flags & FPF_POWERED_OFF))
                {
                    //
                    // If the device is a unimodem device and indicated as powered off
                    // see if we can revive it by opening the line.
                    //
                    if (!OpenTapiLine( LineInfo ))
                    {
                        DebugPrintEx(DEBUG_ERR,
                                     TEXT("OpenTapiLine failed for Device [%s] (ec: %ld)"),
                                     LineInfo->DeviceName,
                                     GetLastError());
                        LineInfo->State = 0; // remove the FPS_AVAILABLE bit'
                        SelectedLine = LineInfo;
                    }
                }
                break;
            }
        }
    }
    else
    {
        //
        // The user wants us to find a free device for him. This is only valid for send operations
        // which are not handoff.
        //
        Assert( JT_SEND == JobType );
        DWORD dwNumDevices, dwCountryCode, dwAreaCode;

        Assert (FaxNumber);

        //
        //  Check DialAsEntered case
        //
        BOOL    bCanonicalAddress = FALSE;
        BOOL    bDialAsEntered = FALSE;

        ec = IsCanonicalAddress (FaxNumber, &bCanonicalAddress, &dwCountryCode, &dwAreaCode, NULL);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("IsCanoicalAddress failed with error %ld"),
                ec);
            goto exit;
        }

        if (TRUE == bCanonicalAddress)
        {
            LPLINECOUNTRYLIST           lpCountryList = NULL;
            //
            // Get the cached all countries list.
            //
            if (!(lpCountryList = GetCountryList()))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Can not get all countries cached list"));
                ec = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            if (IsAreaCodeMandatory(lpCountryList, dwCountryCode) == TRUE &&
                ROUTING_RULE_AREA_CODE_ANY == dwAreaCode)
            {
                //
                // The area code is missing  - dial as entered
                //
                DebugPrintEx(DEBUG_WRN,
                    TEXT("Area code is mandatory for Country code %ld,  FaxNumber - %s. The number will be dialed as entered"),
                    dwCountryCode,
                    FaxNumber);
                bDialAsEntered = TRUE;
            }
        }
        else
        {
            //
            // Not a canonical address - dial as entered
            //
            bDialAsEntered = TRUE;
        }

        if (FALSE == bDialAsEntered)
        {
            EnterCriticalSection( &g_CsConfig );

            ec = GetDeviceListByCountryAndAreaCode( dwCountryCode,
                                                    dwAreaCode,
                                                    &lpdwDevices,
                                                    &dwNumDevices);
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(DEBUG_ERR,
                    TEXT("GetDeviceListByCountryAndAreaCode failed with error %ld"),
                    ec);
                LeaveCriticalSection( &g_CsConfig );
                goto exit;
            }
        }
        else
        {
            //
            //  Dial As Entered case
            //

            //
            //  Bring List of Devices from "All Devices" group
            //
            EnterCriticalSection( &g_CsConfig );

            PCGROUP pCGroup;
            pCGroup = g_pGroupsMap->FindGroup (ROUTING_GROUP_ALL_DEVICESW);

            if (NULL == pCGroup)
            {
                ec = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("g_pGroupsMap->FindGroup(ROUTING_GROUP_ALL_DEVICESW) failed (ec %ld)"), ec);
                LeaveCriticalSection( &g_CsConfig );
                goto exit;
            }

            ec = pCGroup->SerializeDevices (&lpdwDevices, &dwNumDevices);
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("pCGroup->SerializeDevices(&lpdwDevices, &dwNumDevices) failed (ec %ld)"), ec);
                LeaveCriticalSection( &g_CsConfig );
                goto exit;
            }
        }
        LeaveCriticalSection( &g_CsConfig );

        for (DWORD i = 0; i < dwNumDevices; i++)
        {
            Next = g_TapiLinesListHead.Flink;
            Assert (Next);

            while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
            {

                LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
                Next = LineInfo->ListEntry.Flink;               

                if ( (LineInfo->Flags & FPF_SEND)         &&
                     lpdwDevices[i] == LineInfo->PermanentLineID)
                {
                    if ( (LineInfo->Flags & FPF_POWERED_OFF)  ||
                         (LineInfo->Flags & FPF_RECEIVE)
                       )
                    {
                        //
                        // The device is marked as powered off. Check if we should try to send using this device
                        //
                        DWORDLONG dwlCurrentTime;
                        DWORDLONG dwlElapsedTime;
                        GetSystemTimeAsFileTime ((FILETIME*)&dwlCurrentTime);
                        Assert (dwlCurrentTime >= LineInfo->LastLineClose);
                        dwlElapsedTime = dwlCurrentTime - LineInfo->LastLineClose;
                        if (dwlElapsedTime < SecToNano(g_dwMaxLineCloseTime))
                        {
                            //
                            // Not enough time passes since the last LINE_CLOSE. skip this device
                            //
                            continue;
                        }
                    }
                    //
                    // The device is capable of sending and is not marked as FPF_POWERED_OFF.
                    //

                    //
                    // If it is a Tapi device, try to verify it s not busy
                    //
                    if (LineInfo->State == FPS_AVAILABLE &&
						!(LineInfo->JobEntry)            &&
                        !(LineInfo->Flags & FPF_VIRTUAL))
                    {
                        if (NULL == LineInfo->hLine)
                        {
                            if (!OpenTapiLine( LineInfo ))
                            {
                                DebugPrintEx(DEBUG_ERR,
                                             TEXT("OpenTapiLine failed for Device [%s] (ec: %ld)"),
                                             LineInfo->DeviceName,
                                             GetLastError());
                                continue;
                            }
                        }

                        LPLINEDEVSTATUS pLineDevStatus = NULL;
                        BOOL fLineBusy = FALSE;

                        //
                        // check to see if the line is in use
                        //
                        pLineDevStatus = MyLineGetLineDevStatus( LineInfo->hLine );
                        if (NULL != pLineDevStatus)
                        {
                            if (pLineDevStatus->dwNumOpens > 0 && pLineDevStatus->dwNumActiveCalls > 0)
                            {
                                fLineBusy = TRUE;
                            }
                            MemFree( pLineDevStatus );
                        }
                        else
                        {
                            // Assume the line is busy
                            DebugPrintEx(DEBUG_ERR,
                                         TEXT("MyLineGetLineDevStatus failed for Device [%s] (ec: %ld)"),
                                         LineInfo->DeviceName,
                                         GetLastError());

                            fLineBusy = TRUE;
                        }

                        ReleaseTapiLine( LineInfo, NULL );

                        if (TRUE == fLineBusy)
                        {
                            continue;
                        }
                    }

                    if ((LineInfo->State == FPS_AVAILABLE) && !(LineInfo->JobEntry))
                    {
                        //
                        // The line is free 
                        //                        
                        LineInfo->State = 0;                        
                        SelectedLine = LineInfo;
                    }
                    break;  // out of while
                }
            }
            if (SelectedLine != NULL)
            {
                break; // out of for
            }
        }
    }

    if (SelectedLine)
    {
        DebugPrintEx(DEBUG_MSG,
            TEXT("Line selected for FAX operation: %d, %d"),
            SelectedLine->DeviceId,
            SelectedLine->PermanentLineID
            );
    }

    Assert (ERROR_SUCCESS == ec);

exit:
    MemFree (lpdwDevices);
    LeaveCriticalSection( &g_CsLine );
    if (ERROR_SUCCESS == ec &&
        NULL == SelectedLine)
    {
        ec = ERROR_NOT_FOUND;
    }
    SetLastError (ec);
    return SelectedLine;
}

BOOL
ReleaseTapiLine(
    PLINE_INFO LineInfo,
    HCALL hCall
    )

/*++

Routine Description:

    Releases the specified TAPI line back into
    the list as an available device.
    Closes the line and deallocates the call. (line is not closed for a receive enabled
    device.

Arguments:

    LineInfo    - Pointer to the TAPI line to be released

Return Value:

    TRUE    - The line is release.
    FALSE   - The line is not released.

--*/
{
    LONG rVal;
    HLINE hLine;
    DEBUG_FUNCTION_NAME(TEXT("ReleaseTapiLine"));

    Assert(LineInfo);
    if (!LineInfo)
    {
        return FALSE;
    }

    EnterCriticalSection( &g_CsLine );

    LineInfo->State = FPS_AVAILABLE;
    LineInfo->RingCount = 0;
    hLine = LineInfo->hLine;

    ZeroMemory( &LineInfo->LineMsgOffering, sizeof(LINEMESSAGE) );

    if (hCall)
    {
        rVal = lineDeallocateCall( hCall );
        if (rVal != 0)
        {
            DebugPrintEx( DEBUG_ERR,
                        TEXT("lineDeallocateCall() failed, ec=0x%08X, hLine=0x%08X hCall=0x%08X"),
                        rVal,
                        hLine,
                        hCall);
        }
        else
        {
            if (LineInfo->JobEntry && LineInfo->JobEntry->CallHandle == hCall)
            {
                LineInfo->JobEntry->CallHandle = 0;
            }
        }
    }
    else
    {
        DebugPrintEx( DEBUG_WRN,
                    TEXT("ReleaseTapiLine(): cannot deallocate call, NULL call handle"));
    }
    //
    // We actually close the line (by lineClose) only if the line is not
    // intended for receiving.
    //
    if (!(LineInfo->Flags & FPF_RECEIVE)                        &&  // Line is not set to auto-receive and
        LineInfo->hLine                                         &&  // line is open and
        LineInfo->PermanentLineID != g_dwManualAnswerDeviceId       // this device is not set to manual answer mode
       )
    {
        //
        // Attempt to close the line
        //
        LONG lRes;
        LineInfo->hLine = 0;
        lRes=lineClose( hLine );
        if (!lRes)
        {
               DebugPrintEx( DEBUG_MSG,
                      TEXT("hLine 0x%08X closed successfuly"),
                      hLine );
        }
        else
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to close hLine 0x%08X (ec: 0x%08X)"),
                      hLine,
                      lRes);
        }
    }

    LeaveCriticalSection( &g_CsLine );

    return TRUE;
}



LPLINEDEVSTATUS
MyLineGetLineDevStatus(
    HLINE hLine
    )
{
    DWORD LineDevStatusSize;
    LPLINEDEVSTATUS LineDevStatus = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(_T("lineGetLineDevStatus"));


    //
    // allocate the initial linedevstatus structure
    //

    LineDevStatusSize = sizeof(LINEDEVSTATUS) + 4096;
    LineDevStatus = (LPLINEDEVSTATUS) MemAlloc( LineDevStatusSize );
    if (!LineDevStatus)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    LineDevStatus->dwTotalSize = LineDevStatusSize;

    Rslt = lineGetLineDevStatus(
        hLine,
        LineDevStatus
        );

    if (Rslt != 0)
    {
        DebugPrintEx( DEBUG_ERR, TEXT("lineGetLineDevStatus() failed, ec=0x%08x"), Rslt );
        goto exit;
    }

    if (LineDevStatus->dwNeededSize > LineDevStatus->dwTotalSize)
    {
        //
        // re-allocate the LineDevStatus structure
        //

        LineDevStatusSize = LineDevStatus->dwNeededSize;

        MemFree( LineDevStatus );

        LineDevStatus = (LPLINEDEVSTATUS) MemAlloc( LineDevStatusSize );
        if (!LineDevStatus)
        {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        Rslt = lineGetLineDevStatus(
            hLine,
            LineDevStatus
            );

        if (Rslt != 0)
        {
            DebugPrintEx( DEBUG_ERR, TEXT("lineGetLineDevStatus() failed, ec=0x%08x"), Rslt );
            goto exit;
        }
    }

exit:
    if (Rslt != ERROR_SUCCESS)
    {
        MemFree( LineDevStatus );
        LineDevStatus = NULL;
        SetLastError(Rslt);
    }

    return LineDevStatus;
}


LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    )
{
    DWORD LineTransCapsSize;
    LONG Rslt = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(_T("MyLineGetTransCaps"));


    //
    // allocate the initial linetranscaps structure
    //

    LineTransCapsSize = sizeof(LINETRANSLATECAPS) + 4096;
    *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
    if (!*LineTransCaps)
    {
        DebugPrintEx (DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize);
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

    Rslt = lineGetTranslateCaps(
        g_hLineApp,
        MAX_TAPI_API_VER,
        *LineTransCaps
        );

    if (Rslt != 0) {
        DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt);
        goto exit;
    }

    if ((*LineTransCaps)->dwNeededSize > (*LineTransCaps)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransCapsSize = (*LineTransCaps)->dwNeededSize;

        MemFree( *LineTransCaps );

        *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
        if (!*LineTransCaps) {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize);
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

        Rslt = lineGetTranslateCaps(
            g_hLineApp,
            MAX_TAPI_API_VER,
            *LineTransCaps
            );

        if (Rslt != 0) {
            DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt);
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *LineTransCaps );
        *LineTransCaps = NULL;
    }

    return Rslt;
}




/******************************************************************************
* Name: OpenTapiLine
* Author:
*******************************************************************************
DESCRIPTION:
    - Opens the specified TAPI line with the right media modes and ownership.
      Supports both Unimodem devices and fax boards.
    - Sets the line so the required lines and address state events will be
      delivered.
PARAMETERS:
    [IN / OUT ] LineInfo
        A pointer to a LINE_INFO structure that contains the line information.
        LINE_INFO.hLine is set to the open line handle if the operation succeeds.
RETURN VALUE:
    TRUE if no error occured.
    FALSE otherwise.
    Does not explicitly set LastError.
REMARKS:
    NONE.
*******************************************************************************/
BOOL
OpenTapiLine(
    PLINE_INFO LineInfo
    )
{
    LONG Rslt = ERROR_SUCCESS;
    HLINE hLine;
    DWORD LineStates = 0;
    DWORD AddressStates = 0;

    DEBUG_FUNCTION_NAME(_T("OpenTapiLine"));

    EnterCriticalSection( &g_CsLine );

    if (LineInfo->UnimodemDevice)
    {
        Rslt = lineOpen(
            g_hLineApp,
            LineInfo->DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo, // Note that the LineInfo pointer is used as CallbackInstance data. This means we will
                                  // get the LineInfo pointer each time we get a TAPI message.
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_UNKNOWN,
            NULL
            );

        if (Rslt != ERROR_SUCCESS)
        {
            Rslt = lineOpen(
                g_hLineApp,
                LineInfo->DeviceId,
                &hLine,
                MAX_TAPI_API_VER,
                0,
                (DWORD_PTR) LineInfo,
                LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
                LINEMEDIAMODE_DATAMODEM,
                NULL
                );
        }
    }
    else
    {
        Rslt = lineOpen(
            g_hLineApp,
            LineInfo->DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_G3FAX,
            NULL
            );
    }

    if (Rslt != ERROR_SUCCESS)
    {
        DebugPrintEx( DEBUG_ERR,TEXT("Device %s FAILED to initialize, ec=%08x"), LineInfo->DeviceName, Rslt );
    }
    else
    {
        LineInfo->hLine = hLine;
        //
        // set the line status that we need
        //
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_OPEN     ? LINEDEVSTATE_OPEN     : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_CLOSE    ? LINEDEVSTATE_CLOSE    : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_RINGING  ? LINEDEVSTATE_RINGING  : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_NUMCALLS ? LINEDEVSTATE_NUMCALLS : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_REMOVED  ? LINEDEVSTATE_REMOVED  : 0;

        AddressStates = LINEADDRESSSTATE_INUSEZERO | LINEADDRESSSTATE_INUSEONE |
                        LINEADDRESSSTATE_INUSEMANY | LINEADDRESSSTATE_NUMCALLS;

        Rslt = lineSetStatusMessages( hLine, LineStates, AddressStates );
        if (Rslt != 0)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("lineSetStatusMessages() failed, [0x%08x:0x%08x], ec=0x%08x"), LineStates, AddressStates, Rslt );
            Rslt = ERROR_SUCCESS;
        }
    }

    LeaveCriticalSection( &g_CsLine );

    if (ERROR_SUCCESS != Rslt)
    {
        //
        // We set the modem to be FPF_POWERED_OFF to make sure we will not try to constantly resend
        // on this device. After MAX_LINE_CLOSE_TIME we will retry to send on this device.
        //
        LineInfo->hLine = NULL;
        LineInfo->Flags |= FPF_POWERED_OFF;
        GetSystemTimeAsFileTime((FILETIME*)&LineInfo->LastLineClose);
        //
        // Can not map the TAPI error to a win error so we just return general failure.
        // We do generate a debug output with the actual error earlier in this code.
        //
        SetLastError(ERROR_GEN_FAILURE);
        return FALSE;
    }
    else
    {
        LineInfo->Flags &= ~FPF_POWERED_OFF;
        return TRUE;
    }
}


BOOL CALLBACK
NewDeviceRoutingMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    DWORD DeviceId
    )
{
    BOOL Rslt = FALSE;
    DEBUG_FUNCTION_NAME(_T("NewDeviceRoutingMethodEnumerator"));

    __try
    {
        Rslt = RoutingMethod->RoutingExtension->FaxRouteDeviceChangeNotification( DeviceId, TRUE );
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }

    return Rslt;
}


BOOL
AddNewDevice(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    BOOL fServerInitialization,
    PREG_FAX_DEVICES    pInputFaxReg
    )
{
    BOOL rVal = FALSE;
    BOOL UnimodemDevice = FALSE;
    PMDM_DEVSPEC MdmDevSpec = NULL;
    LPSTR ModemKey = NULL;
    LPTSTR DeviceName = NULL;
    REG_SETUP RegSetup = {0};
    DWORD dwUniqueLineId = 0;
    PDEVICE_PROVIDER lpProvider;
    LPTSTR lptstrTSPName;
    DWORD ec = ERROR_SUCCESS;
    BOOL fDeviceAddedToMap = FALSE;
    DWORD dwDeviceType = FAX_DEVICE_TYPE_OLD;
    DEBUG_FUNCTION_NAME(TEXT("AddNewDevice"));

    //
    // only add devices that support fax
    //
    if (! ( ((LineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM) &&
             (UnimodemDevice = IsDeviceModem( LineDevCaps, FAX_MODEM_PROVIDER_NAME ) )) ||
            (LineDevCaps->dwMediaModes & LINEMEDIAMODE_G3FAX) ))
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!(LineDevCaps->dwProviderInfoSize))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("No device provider information"));
         SetLastError (ERROR_INVALID_PARAMETER);
         return FALSE;
    }

    if (!GetOrigSetupData( LineDevCaps->dwPermanentLineID, &RegSetup ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetOrigSetupData failed (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (LineDevCaps->dwLineNameSize)
    {
        DeviceName = FixupDeviceName( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
        if (NULL == DeviceName)
        {
            ec = GetLastError();
            DebugPrintEx( DEBUG_ERR,
                           TEXT("FixupDeviceName failed (ec: %ld)"),
                           ec);
            rVal = FALSE;
            goto exit;
        }
    }
	else
	{
		//
		// The TSP did not provide device name. DO not add the device
		//
		ec = ERROR_BAD_FORMAT;
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Device %d does not have device name, not adding the device"),
			DeviceId);
        rVal = FALSE;
        goto exit;
	}

    //
    // Find the device provider for this device using the TAPI provider name.
    //
    lptstrTSPName = (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) ;
    lpProvider = FindDeviceProvider( lptstrTSPName);
    if (!lpProvider)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not find a valid device provider for TAPI device: [%s]. (Looking for TSP : [%s])"),
            DeviceName,
            lptstrTSPName
            );
        rVal = FALSE;
        goto exit;
    }
    Assert (FAX_PROVIDER_STATUS_SUCCESS == lpProvider->Status);

    // try to find this device from service registry and update RegSetup if found
    if ( pInputFaxReg )
    {
        dwUniqueLineId = FindServiceDeviceByTapiPermanentLineID ( LineDevCaps->dwPermanentLineID, DeviceName, &RegSetup, pInputFaxReg );
    }

    // try to find this device in device cache and update RegSetup if found
    if ( 0 == dwUniqueLineId )
    {
        BOOL fManualAnswer = FALSE;
        if (0 != (dwUniqueLineId = FindCacheEntryByTapiPermanentLineID( LineDevCaps->dwPermanentLineID,
                                                                        DeviceName,
                                                                        &RegSetup,
                                                                        &g_dwLastUniqueLineId,
                                                                        &fManualAnswer)))
        {
            //
            // The device was found in the cache
            //
            dwDeviceType = FAX_DEVICE_TYPE_CACHED;
            if (TRUE == fManualAnswer)
            {
                //
                // The device was set to manual answer when moved to the cache
                //
                dwDeviceType |= FAX_DEVICE_TYPE_MANUAL_ANSWER;
            }
        }
    }

    // still 0 so, add this new device to registry
    if ( 0 == dwUniqueLineId )
    {
        dwDeviceType = FAX_DEVICE_TYPE_NEW;
        ec = RegAddNewFaxDevice( &g_dwLastUniqueLineId,
                             &dwUniqueLineId, // Create new device.
                             DeviceName,
                             (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset),
                             lpProvider->szGUID,
                             RegSetup.Csid,
                             RegSetup.Tsid,
                             LineDevCaps->dwPermanentLineID,
                             RegSetup.Flags,
                             RegSetup.Rings);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("RegAddNewFaxDevice() failed for Tapi permanent device id: %ld (ec: %ld)"),
                LineDevCaps->dwPermanentLineID,
                ec);
            rVal = FALSE;
            goto exit;
        }
    }

    ec = g_pTAPIDevicesIdsMap->AddDevice (LineDevCaps->dwPermanentLineID, dwUniqueLineId);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("g_pTAPIDevicesIdsMap->AddDevice() failed for Tapi permanent device id: %ld (ec: %ld)"),
            LineDevCaps->dwPermanentLineID,
            ec);
        rVal = FALSE;
        goto exit;
    }
    fDeviceAddedToMap = TRUE;

    ec = InitializeTapiLine( DeviceId,
                             dwUniqueLineId,
                             LineDevCaps,
                             RegSetup.Rings,
                             RegSetup.Flags,
                             RegSetup.Csid,
                             RegSetup.Tsid,
                             RegSetup.lptstrDescription,
                             fServerInitialization,
                             dwDeviceType
                             );
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx( DEBUG_WRN,
                      TEXT("InitializeTapiLine failed for Fax unique device id: %ld (ec: %ld)"),
                      dwUniqueLineId,
                      ec);
        rVal = FALSE;
        goto exit;
    }

    if (FALSE == fServerInitialization)
    {
        PLINE_INFO pLineInfo = NULL;

        //
        // Close the line if the device is not receive enabled
        //
        pLineInfo = GetTapiLineFromDeviceId (dwUniqueLineId, FALSE);
        if (pLineInfo)
        {
            if (!(pLineInfo->Flags & FPF_RECEIVE)                        &&  // Device is not set to auto-receive and
                pLineInfo->hLine                                         &&  // device is open and
                pLineInfo->PermanentLineID != g_dwManualAnswerDeviceId       // this device is not set to manual answer mode
               )
            {
                //
                // Attempt to close the device
                //
                HLINE hLine = pLineInfo->hLine;
                LONG Rslt;

                pLineInfo->hLine = 0;
                Rslt = lineClose( hLine );
                if (Rslt)
                {
                    if (LINEERR_INVALLINEHANDLE != Rslt)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("lineClose() for line %s [Permanent Id: %010d] has failed. (ec: %ld)"),
                            pLineInfo->DeviceName,
                            pLineInfo->TapiPermanentLineId,
                            Rslt);
                    }
                    else
                    {
                        //
                        // We can get LINEERR_INVALLINEHANDLE if we got LINE_CLOSE
                        // from TAPI.
                        //
                        DebugPrintEx(
                            DEBUG_WRN,
                            TEXT("lineClose() for line %s [Permanent Id: %010d] reported LINEERR_INVALLINEHANDLE. (May be caused by LINE_CLOSE event)"),
                            pLineInfo->DeviceName,
                            pLineInfo->TapiPermanentLineId
                            );
                    }
                }
            }
        }
        else
        {
            //
            // We must find the line because InitializeTapiLine() did not fail
            //
            ASSERT_FALSE;
        }

        if (!g_pGroupsMap->UpdateAllDevicesGroup())
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroupsMap::UpdateAllDevicesGroup() failed (ec: %ld)"),
                ec);

            //
            // We failed to update <All devices> group. Remove the line.
            //
            if (pLineInfo)
            {
                RemoveEntryList (&pLineInfo->ListEntry);
                //
                // Update enabled device counter
                //
                if (TRUE == IsDeviceEnabled(pLineInfo))
                {
                    Assert (g_dwDeviceEnabledCount);
                    g_dwDeviceEnabledCount -= 1;
                }
                FreeTapiLine (pLineInfo);
                g_dwDeviceCount -= 1;
             }
             rVal = FALSE;
             goto exit;
        }

        //
        //  Call CreateConfigEvent only when LINE_CREATE event accure during service operation
        //  and not during start up
        //
        ec = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) failed (ec: %lc)"),
                ec);
        }

        ec = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) failed (ec: %lc)"),
                ec);
        }
    }

    rVal = TRUE;

exit:
    if (DeviceName)
    {
        MemFree( DeviceName );
    }

    if (FALSE == rVal &&
        TRUE == fDeviceAddedToMap)
    {
        DWORD dwRes = g_pTAPIDevicesIdsMap->RemoveDevice (LineDevCaps->dwPermanentLineID);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cg_pTAPIDevicesIdsMap->RemoveDevice failed (ec: %lc)"),
                dwRes);
        }
    }

    FreeOrigSetupData( &RegSetup );
    EnumerateRoutingMethods( (PFAXROUTEMETHODENUM)NewDeviceRoutingMethodEnumerator, UlongToPtr(dwUniqueLineId) );
    if (FALSE == rVal)
    {
        SetLastError(ec);
    }
    return rVal;
}   // AddNewDevice



DWORD
InitializeTapiLine(
    DWORD DeviceId,
    DWORD dwUniqueLineId,
    LPLINEDEVCAPS LineDevCaps,
    DWORD Rings,
    DWORD Flags,
    LPTSTR Csid,
    LPTSTR Tsid,
    LPTSTR lptstrDescription,
    BOOL fServerInit,
    DWORD dwDeviceType
    )
{
    PLINE_INFO LineInfo = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DWORD len;
    PDEVICE_PROVIDER Provider;
    BOOL UnimodemDevice;
    HLINE hLine = 0;
    LPTSTR ProviderName = NULL;
    LPTSTR DeviceName = NULL;
    BOOL NewDevice = TRUE;
    DWORD LineStates = 0;
    DWORD AddressStates = 0;
    LPLINEDEVSTATUS LineDevStatus;
    DEBUG_FUNCTION_NAME(TEXT("InitializeTapiLine"));

    Assert(dwUniqueLineId);
    //
    // allocate the LINE_INFO structure
    //

    LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
    if (!LineInfo)
    {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    ZeroMemory(LineInfo, sizeof(LINE_INFO));

    //
    // get the provider name
    //

    len = _tcslen( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );
    ProviderName = (LPTSTR)(MemAlloc( (len + 1) * sizeof(TCHAR) ));
    if (!ProviderName)
    {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    _tcscpy( ProviderName, (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );

    //
    // get the device name
    //

    DeviceName = FixupDeviceName( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
    if (!DeviceName)
    {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // verify that the line id is good
    //

    if (LineDevCaps->dwPermanentLineID == 0)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("TAPI lines must have a non-zero line id [%s]"),
                     DeviceName);
        Rslt = ERROR_BAD_DEVICE;
        goto exit;
    }

    //
    // check for a modem device
    //

    UnimodemDevice = IsDeviceModem( LineDevCaps, FAX_MODEM_PROVIDER_NAME );

    //
    // assign the device provider
    //

    Provider = FindDeviceProvider( ProviderName );
    if (!Provider)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Could not find a valid device provider for device: %s"), DeviceName);
        Rslt = ERROR_BAD_PROVIDER;
        goto exit;
    }
    Assert (FAX_PROVIDER_STATUS_SUCCESS == Provider->Status);

    //
    // open the line
    //

    if (UnimodemDevice)
    {
        Rslt = lineOpen(
            g_hLineApp,
            DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_UNKNOWN,
            NULL
            );

        if (Rslt != 0)
        {
            Rslt = lineOpen(
                g_hLineApp,
                DeviceId,
                &hLine,
                MAX_TAPI_API_VER,
                0,
                (DWORD_PTR) LineInfo,
                LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
                LINEMEDIAMODE_DATAMODEM,
                NULL
                );
        }
    }
    else
    {
        Rslt = lineOpen(
            g_hLineApp,
            DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_G3FAX,
            NULL
            );
    }

    if (Rslt != 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Device %s FAILED to initialize, ec=%08x"), DeviceName, Rslt);
        goto exit;
    }
    //
    // Set hLine in the LINE_INFO structure so it will be freed on failure
    //
    LineInfo->hLine = hLine;


    //
    // set the line status that we need
    //

    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_OPEN     ? LINEDEVSTATE_OPEN     : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_CLOSE    ? LINEDEVSTATE_CLOSE    : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING  ? LINEDEVSTATE_RINGING  : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_NUMCALLS ? LINEDEVSTATE_NUMCALLS : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_REMOVED  ? LINEDEVSTATE_REMOVED  : 0;

    AddressStates = LINEADDRESSSTATE_INUSEZERO | LINEADDRESSSTATE_INUSEONE |
                    LINEADDRESSSTATE_INUSEMANY | LINEADDRESSSTATE_NUMCALLS;

    Rslt = lineSetStatusMessages( LineInfo->hLine, LineStates, AddressStates );
    if (Rslt != 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("lineSetStatusMessages() failed, [0x%08x:0x%08x], ec=0x%08x"), LineStates, AddressStates, Rslt);
        if (Rslt == LINEERR_INVALLINEHANDLE)
        {
            LineInfo->hLine = 0;
        }
        Rslt = 0;
    }

    //
    // now assign the necessary values to the line info struct
    //

    LineInfo->Signature             = LINE_SIGNATURE;
    LineInfo->DeviceId              = DeviceId;
    LineInfo->TapiPermanentLineId   = LineDevCaps->dwPermanentLineID;
    LineInfo->Provider              = Provider;
    LineInfo->UnimodemDevice        = UnimodemDevice;
    LineInfo->State                 = FPS_AVAILABLE;
    LineInfo->dwReceivingJobsCount  = 0;
    LineInfo->dwSendingJobsCount    = 0;
    LineInfo->LastLineClose         = 0;

    if (DeviceName)
    {
        LineInfo->DeviceName                  = StringDup( DeviceName );
        if (!LineInfo->DeviceName)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->DeviceName = NULL;
    }

    if (Csid)
    {
        LineInfo->Csid                  = StringDup( Csid );
        if (!LineInfo->Csid)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->Csid = NULL;
    }

    if (Tsid)
    {
        LineInfo->Tsid                  = StringDup( Tsid );
        if (!LineInfo->Tsid)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->Tsid = NULL;
    }

    if (lptstrDescription)
    {
        LineInfo->lptstrDescription                  = StringDup( lptstrDescription );
        if (!LineInfo->lptstrDescription)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->lptstrDescription = NULL;
    }

    LineInfo->RingsForAnswer        = (LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING) ? Rings : 0;
    LineInfo->Flags                 = Flags;
    LineInfo->RingCount             = 0;
    LineInfo->LineStates            = LineDevCaps->dwLineStates;
    LineInfo->PermanentLineID       = dwUniqueLineId;
    LineInfo->dwDeviceType          = dwDeviceType;
    if (LineInfo->hLine)
    {
        //
        // check to see if the line is in use
        //
        LineDevStatus = MyLineGetLineDevStatus( LineInfo->hLine );
        if (LineDevStatus)
        {
            if (LineDevStatus->dwNumOpens > 0 && LineDevStatus->dwNumActiveCalls > 0)
            {
                LineInfo->ModemInUse = TRUE;
            }
            MemFree( LineDevStatus );
        }
    }
    else
    {
        //
        // if we don't have a line handle at this time then the
        // device must be powered off
        //
        DebugPrintEx(DEBUG_ERR, TEXT("Device %s is powered off or disconnected"), DeviceName);
        LineInfo->Flags |= FPF_POWERED_OFF;
        //
        // Since this function is called from TapiInitialize(), we don't have an RPC server up and running yet.
        // Don't create a FAX_EVENT_TYPE_DEVICE_STATUS event.
        //
    }

exit:

    MemFree( DeviceName );
    MemFree( ProviderName );

    if (Rslt == ERROR_SUCCESS)
    {
        InsertTailList( &g_TapiLinesListHead, &LineInfo->ListEntry );
        g_dwDeviceCount += 1;

        if (FALSE == fServerInit)
        {
            //
            // Add cached manual answer device and check device limit
            //
            if (0 == g_dwManualAnswerDeviceId  && // There is no manual answer device
                LineInfo->dwDeviceType == (FAX_DEVICE_TYPE_CACHED | FAX_DEVICE_TYPE_MANUAL_ANSWER) && // this is a cached manual answer device
                !(LineInfo->Flags & FPF_RECEIVE)) // the device is not set to auto receive
            {
                //
                // set this device as manual receive
                //
                g_dwManualAnswerDeviceId = LineInfo->PermanentLineID;
                DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                        dwRes);
                }
            }

            if (g_dwDeviceEnabledCount >= g_dwDeviceEnabledLimit)
            {
                //
                // We reached device limit on this SKU. set this device's flags to 0.
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Reached device limit on this SKU. reset device flags to 0. Device limit: %ld. Current device: %ld"),
                    g_dwDeviceEnabledLimit,
                    g_dwDeviceEnabledCount);

                ResetDeviceFlags(LineInfo);
            }
        }

        //
        // Update enabled device counter
        //
        if (TRUE == IsDeviceEnabled(LineInfo))
        {
            g_dwDeviceEnabledCount += 1;
        }
    }
    else
    {
        FreeTapiLine( LineInfo );
    }

    return Rslt;
} // InitializeTapiLine


BOOL
IsVirtualDevice(
    const LINE_INFO *pLineInfo
    )
{
    if (!pLineInfo) {
        return FALSE;
    }

    return (pLineInfo->Provider->FaxDevVirtualDeviceCreation != NULL);
}

VOID
UpdateVirtualDeviceSendAndReceiveStatus(
    PLINE_INFO  pLineInfo,
    BOOL        bSend,
    BOOL        bReceive
)
/*++

Routine name : UpdateVirtualDeviceSendAndReceiveStatus

Routine description:

    Updates a virtual device with the new send and receive flags

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pLineInfo       [in] - Pointer to line information
    bSend           [in] - Can the device send faxes?
    bReceive        [in] - Can the device receive faxes?

Remarks:

    This function should be called with g_CsLine held.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("UpdateVirtualDeviceSendAndReceiveStatus"));
    if (!IsVirtualDevice(pLineInfo) || !pLineInfo->Provider->FaxDevCallback)
    {
        //
        // Not a virtual device or does not support FaxDevCallback
        //
        return;
    }
    __try
    {
        pLineInfo->Provider->FaxDevCallback( NULL,
                                             pLineInfo->TapiPermanentLineId,
                                             LINE_DEVSPECIFIC,
                                             0,
                                             bReceive,
                                             bSend,
                                             0
                                           );
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, pLineInfo->Provider->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }
}   // UpdateVirtualDeviceSendAndReceiveStatus

VOID
UpdateVirtualDevices(
    VOID
    )
{
    PLIST_ENTRY         Next;
    PLINE_INFO          LineInfo = NULL;

    EnterCriticalSection( &g_CsLine );

    Next = g_TapiLinesListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &g_CsLine );
        return;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;
        UpdateVirtualDeviceSendAndReceiveStatus (LineInfo,
                                                 LineInfo->Flags & FPF_SEND,
                                                 LineInfo->Flags & FPF_RECEIVE
                                                );
    }
    LeaveCriticalSection( &g_CsLine );
}


DWORD
CreateVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    DWORD dwAPIVersion
    )
{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    Provider;
    PLINE_INFO          LineInfo = NULL;
    PREG_DEVICE         FaxDevice = NULL;
    PREG_FAX_DEVICES    FaxDevices = NULL;
    DWORD               dwVirtualDeviceCount = 0;
    REG_SETUP           RegSetup={0};
    DWORD ec;

    DEBUG_FUNCTION_NAME(TEXT("CreateVirtualDevices"));
    Next = g_DeviceProvidersListHead.Flink;
    if (!Next)
    {
        return dwVirtualDeviceCount;
    }

    if (!GetOrigSetupData( 0, &RegSetup ))
    {
        return dwVirtualDeviceCount;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        DWORD dwDeviceCount;

        dwDeviceCount = 0;
        Provider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = Provider->ListEntry.Flink;
        if (Provider->Status != FAX_PROVIDER_STATUS_SUCCESS)
        {
            //
            // This FSP wasn't loaded successfully - skip it
            //
            continue;
        }
        if (Provider->dwAPIVersion != dwAPIVersion)
        {
            //
            // This FSP doesn't match the required API version - skip it
            //
            continue;
        }
        if (FSPI_API_VERSION_1 == Provider->dwAPIVersion)
        {
            if (Provider->FaxDevVirtualDeviceCreation)
            {
                if (!CreateLegacyVirtualDevices(FaxReg, &RegSetup, Provider, &dwDeviceCount))
                {
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateLegacyVirtualDevices failed for provider [%s] (ec: %ld)"),
                        Provider->FriendlyName,
                        ec);
                    goto InitializationFailure;
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("%ld Legacy Virtual devices added by provider [%s]"),
                        dwDeviceCount,
                        Provider->FriendlyName,
                        ec);
                }
            }

        }        
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Unsupported API Version (0x%08X) for provider [%s]"),
                Provider->dwAPIVersion,
                Provider->FriendlyName);
            Assert(FALSE);
            goto InitializationFailure;
        }

        dwVirtualDeviceCount+= dwDeviceCount;

        goto next;
InitializationFailure:
        Provider->Status = FAX_PROVIDER_STATUS_CANT_INIT;
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_VIRTUAL_DEVICE_INIT_FAILED,
                Provider->FriendlyName
              );
next:
    ;
    }

    DebugPrintEx(DEBUG_MSG, TEXT("Virtual devices initialized, devices=%d"), g_dwDeviceCount);

    FreeOrigSetupData( &RegSetup );

    return dwVirtualDeviceCount;
}

//*********************************************************************************
//* Name:   CreateLegacyVirtualDevices()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the virtual line devices reported by a single FSP and adds them
//*     to the line list. Also persists the line information in the registry.
//* PARAMETERS:
//*     [IN]        PREG_FAX_SERVICE FaxReg
//*
//*     [IN]        const REG_SETUP * lpRegSetup
//*
//*     [IN]        const DEVICE_PROVIDER * lpcProvider
//*         A pointer to the provider information.  This should be a virtual
//*         provider.
//*     [OUT]       LPDWORD lpdwDeviceCount
//*         The number of virtual devices actually added.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the creation succeeded.
//*     FALSE
//*         If the creation failed. Call GetLastError() to get extended error
//*         information. an error of ERROR_INVALID_FUNCTION indicates that
//*         the FSP creation function failed.
//*********************************************************************************
BOOL CreateLegacyVirtualDevices(
        PREG_FAX_SERVICE FaxReg,
        const REG_SETUP * lpRegSetup,
        DEVICE_PROVIDER * lpcProvider,
        LPDWORD lpdwDeviceCount)
{
    DWORD               VirtualDeviceCount = 0;
    WCHAR               DevicePrefix[128] = {0};
    DWORD               DeviceIdPrefix;
    LPWSTR              DeviceName = NULL;
    DWORD               i,j;
    PLINE_INFO          LineInfo = NULL;
    PREG_DEVICE         FaxDevice = NULL;
    UINT nDevice;
    PLINE_INFO          * lpAddedLines = NULL;
    DWORD ec = 0;
    PLIST_ENTRY         Next;
    PLINE_INFO          pLineInfo;

    Assert(lpcProvider);
    Assert(lpcProvider->FaxDevVirtualDeviceCreation);
    Assert(lpdwDeviceCount);
    Assert(FaxReg);
    Assert(lpRegSetup);

    DEBUG_FUNCTION_NAME(TEXT("CreateLegacyVirtualDevices"));

    (*lpdwDeviceCount) = 0;

    __try
    {
        if (!lpcProvider->FaxDevVirtualDeviceCreation(
                    &VirtualDeviceCount,
                    DevicePrefix,
                    &DeviceIdPrefix,
                    g_TapiCompletionPort,
                    FAXDEV_EVENT_KEY
                    ))
        {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevVirtualDeviceCreation failed for provider [%s] (ec: %ld)"),
                lpcProvider->FriendlyName,
                GetLastError());
            goto InitializationFailure;
        }
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, lpcProvider->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }

    if (VirtualDeviceCount > 0)
    {
        if (VirtualDeviceCount > 256 )
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("VirtualDeviceCount returned too many devices (%d)- limit to 256"),
                VirtualDeviceCount);

            VirtualDeviceCount = 256;
        }
        if ((DeviceIdPrefix == 0) || (DeviceIdPrefix >= DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE))
        {
            //
            // Provider uses device ids out of allowed range
            //
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Provider [%s] uses device ids base [%ld] out of allowed range."),
                lpcProvider->FriendlyName,
                DeviceIdPrefix);
            goto InitializationFailure;
        }

        //
        // Check if the range of device IDs does not conflict with an already loaded devices of another provider
        // Range [1 ... DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE-1] : Reserved for VFSPs.
        // Since we cannot dictate the range of device ids the VFSPS use, we allocate a space for them
        // and leave segments allocation to a PM effort here.
        //
        Next = g_TapiLinesListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
        {
            pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = pLineInfo->ListEntry.Flink;

            if (pLineInfo->PermanentLineID >= DeviceIdPrefix &&
                pLineInfo->PermanentLineID <= DeviceIdPrefix + VirtualDeviceCount)
            {
                //
                // We have a conflict. log an event and do not load the devices
                //
                ec = ERROR_INVALID_FUNCTION;
                FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    2,
                    MSG_FAX_FSP_CONFLICT,
                    lpcProvider->FriendlyName,
                    pLineInfo->Provider->FriendlyName
                  );
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Provider [%s] uses device id [%ld] that conflicts with another FSP [%s]"),
                    lpcProvider->FriendlyName,
                    DeviceIdPrefix,
                    pLineInfo->Provider->FriendlyName
                    );
                goto InitializationFailure;
            }
        }

        lpAddedLines = (PLINE_INFO *)MemAlloc(VirtualDeviceCount * sizeof(PLINE_INFO));
        if (!lpAddedLines)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate PLINE_INFO array. (ec: %ld)"),
                VirtualDeviceCount,
                GetLastError());
            goto InitializationFailure;
        }
        memset(lpAddedLines, 0, VirtualDeviceCount * sizeof(PLINE_INFO));

        for (i = 0; i < VirtualDeviceCount; i++)
        {
            DWORD dwUniqueLineId;
            //
            // create the device name
            //
            DeviceName = (LPWSTR) MemAlloc( StringSize(DevicePrefix) + 16 );
            if (!DeviceName) {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("MemAlloc() failed for DeviceName (ec: %ld)"),
                    ec);
                goto InitializationFailure;
            }

            swprintf( DeviceName, L"%s%d", DevicePrefix, i );
            //
            // find the registry information for this device
            //
            for (j = 0, FaxDevice = NULL; j < FaxReg->DeviceCount; j++)
            {
                if (TRUE == FaxReg->Devices[j].bValidDevice &&
                    !_tcscmp(FaxReg->Devices[j].lptstrProviderGuid, lpcProvider->szGUID))
                {
                    if (FaxReg->Devices[j].TapiPermanentLineID == DeviceIdPrefix+i)
                    {
                        FaxDevice = &FaxReg->Devices[j];
                        break;
                    }
                }
            }
            //
            // if the device is new then add it to the registry
            //
            if (!FaxDevice)
            {
                //
                // We set the Fax Device Id to be the VFSP device id - we don't create one on our own
                //
                dwUniqueLineId = DeviceIdPrefix + i;
                RegAddNewFaxDevice(
                    &g_dwLastUniqueLineId,
                    &dwUniqueLineId,
                    DeviceName,
                    lpcProvider->ProviderName,
                    lpcProvider->szGUID,
                    lpRegSetup->Csid,
                    lpRegSetup->Tsid,
                    DeviceIdPrefix + i,
                    (lpRegSetup->Flags | FPF_VIRTUAL),
                    lpRegSetup->Rings
                    );
            }
            else
            {
                dwUniqueLineId = FaxDevice->PermanentLineId;
                Assert(dwUniqueLineId > 0);
            }
            //
            // allocate the LINE_INFO structure
            //
            LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
            if (!LineInfo)
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate LINE_INFO (ec: %ld). DeviceId: %010d DeviceName: %s"),
                    GetLastError(),
                    DeviceIdPrefix + i,
                    DeviceName);
                goto InitializationFailure;
            }
            //
            // Save a pointer to it so we can free it if we crash ahead
            //
            lpAddedLines[*lpdwDeviceCount] = LineInfo;
            //
            // now assign the necessary values to the line info struct
            //
            LineInfo->Signature             = LINE_SIGNATURE;
            LineInfo->DeviceId              = i;
            LineInfo->TapiPermanentLineId   = DeviceIdPrefix + i;
            LineInfo->PermanentLineID       = dwUniqueLineId;
            Assert(LineInfo->PermanentLineID > 0);
            LineInfo->hLine                 = 0;
            LineInfo->Provider              =  (PDEVICE_PROVIDER)lpcProvider;
            LineInfo->DeviceName            = DeviceName; // Note: DeviceName is heap allocated and need to be freed
            LineInfo->UnimodemDevice        = FALSE;
            LineInfo->State                 = FPS_AVAILABLE;
            LineInfo->Csid                  = StringDup( FaxDevice ? FaxDevice->Csid : lpRegSetup->Csid );
            LineInfo->Tsid                  = StringDup( FaxDevice ? FaxDevice->Tsid : lpRegSetup->Tsid );
            LineInfo->lptstrDescription     = FaxDevice ? StringDup(FaxDevice->lptstrDescription) : NULL;
            LineInfo->RingsForAnswer        = 0;
            LineInfo->RingCount             = 0;
            LineInfo->LineStates            = 0;
            LineInfo->dwReceivingJobsCount  = 0;
            LineInfo->dwSendingJobsCount    = 0;
            LineInfo->LastLineClose         = 0; // We do not use this for virtual devices
            LineInfo->dwDeviceType          = FaxDevice ? FAX_DEVICE_TYPE_OLD : FAX_DEVICE_TYPE_NEW;
            LineInfo->Flags                 = FaxDevice ? FaxDevice->Flags : (lpRegSetup->Flags | FPF_VIRTUAL);

            InsertTailList( &g_TapiLinesListHead, &LineInfo->ListEntry );
            (*lpdwDeviceCount)++;

            //
            // Update enabled device counter
            //
            if (TRUE == IsDeviceEnabled(LineInfo))
            {
                g_dwDeviceEnabledCount += 1;
            }
        }
    }
    else
    {
        ec = ERROR_INVALID_FUNCTION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxDevVirtualDeviceCreation() reported 0 devices."));
        goto InitializationFailure;
    }


    Assert( (*lpdwDeviceCount) == VirtualDeviceCount);
    Assert (0 == ec);
    goto Exit;

InitializationFailure:
    Assert (0 != ec);
    //
    // Remove the added lines
    //
    if (lpAddedLines)
    {
        for (nDevice=0 ;nDevice < VirtualDeviceCount; nDevice++)
        {
            if (lpAddedLines[nDevice])
            {
                //
                // Remove the LINE_INFO from the line list
                //
                RemoveEntryList(&(lpAddedLines[nDevice]->ListEntry));
                //
                // Update enabled device counter
                //
                if (TRUE == IsDeviceEnabled(lpAddedLines[nDevice]))
                {
                    Assert (g_dwDeviceEnabledCount);
                    g_dwDeviceEnabledCount -= 1;
                }
                //
                // Free the memory occupied by the LINE_INFO
                //
                FreeTapiLine(lpAddedLines[nDevice]);
            }
        }
    }
    (*lpdwDeviceCount) = 0; // If we fail with one device then we fail with all devices.

Exit:
    MemFree(lpAddedLines);
    if (ec)
    {
        SetLastError(ec);
    }

    return ( 0 == ec);
}

DWORD
TapiInitialize(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    This function performs all necessary TAPI initialization.
    This includes device enumeration, message pump creation,
    device capabilities caputure, etc.  It is required that
    the device provider initialization is completed before
    calling this function.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    LONG Rslt;
    DWORD i,j;
    LPLINEDEVCAPS LineDevCaps = NULL;
    PREG_FAX_DEVICES FaxDevices = NULL;
    LINEINITIALIZEEXPARAMS LineInitializeExParams;
	TCHAR FaxSvcName[MAX_PATH*2]={0};
    TCHAR Fname[_MAX_FNAME];
    TCHAR Ext[_MAX_EXT];
    DWORD LocalTapiApiVersion;
    LINEEXTENSIONID lineExtensionID;
    DWORD ec = 0;
    DWORDLONG dwlTimeNow;
    DWORD dwTapiDevices;


    DEBUG_FUNCTION_NAME(TEXT("TapiInitialize"));

    GetSystemTimeAsFileTime((FILETIME *)&dwlTimeNow);

    if (!LoadAdaptiveFileBuffer())  // Note: allocates AdaptiveFileBuffer (take care to delete it if error occurs later on)
    {
        if ( ERROR_FILE_NOT_FOUND == GetLastError()  )
        {
            //
            // We can live without the adaptive file buffer.
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("AdaptiveFileBuffer (faxadapt.lst) not found."));
            ec = 0;
        }
        else
        {
            //
            // This is an unexpected error (no memory , file system error) we exit.
            //

            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LoadAdaptiveFileBuffer() failed (ec: %ld)"),
                ec);
            goto Error;
        }
    }

    //
    // we need to hold onto this cs until tapi is up and ready to serve
    //
    EnterCriticalSection( &g_CsLine );

    //
    // initialize tapi
    //
    g_TapiCompletionPort = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1
        );
    if (!g_TapiCompletionPort)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateIoCompletionPort() failed (ec: %ld)"),
            ec);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }

    LineInitializeExParams.dwTotalSize              = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize             = 0;
    LineInitializeExParams.dwUsedSize               = 0;
    LineInitializeExParams.dwOptions                = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT;
    LineInitializeExParams.Handles.hCompletionPort  = g_TapiCompletionPort;
    LineInitializeExParams.dwCompletionKey          = TAPI_COMPLETION_KEY;

    LocalTapiApiVersion = MAX_TAPI_API_VER;

    Rslt = lineInitializeEx(
        &g_hLineApp,
        GetModuleHandle(NULL),
        NULL,
        FAX_SERVICE_DISPLAY_NAME,
        &dwTapiDevices,
        &LocalTapiApiVersion,
        &LineInitializeExParams
        );

    if (Rslt != 0)
    {
        ec = Rslt;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lineInitializeEx() failed devices=%d (ec: %ld)"),
            dwTapiDevices,
            ec);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }

    if (LocalTapiApiVersion < MIN_TAPI_API_VER)
    {
        ec = LINEERR_INCOMPATIBLEAPIVERSION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Unsupported TAPI API ver (Ver: %ld)"),
            LocalTapiApiVersion);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }

    if (!GetModuleFileName( NULL, FaxSvcName, ARR_SIZE(FaxSvcName)))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetModuleFileName for fax service module failed (ec: %ld)"),
            ec);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }
    else
    {
        _tsplitpath( FaxSvcName, NULL, NULL, Fname, Ext );
        _stprintf( FaxSvcName, TEXT("%s%s"), Fname, Ext );

        Rslt = lineSetAppPriority(
            FaxSvcName,
            LINEMEDIAMODE_UNKNOWN,
            0,
            0,
            NULL,
            1
            );

        Rslt = lineSetAppPriority(
            FaxSvcName,
            LINEMEDIAMODE_DATAMODEM,
            0,
            0,
            NULL,
            1
            );

        if (Rslt != 0)
        {
            ec = Rslt;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lineSetAppPriority() failed (ec: %ld)"),
                ec );
            LeaveCriticalSection( &g_CsLine );
            goto Error;

        }
    }

    //
    // add any new devices to the registry
    //
    FaxDevices = GetFaxDevicesRegistry();

    if (!FaxDevices)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxDevicesRegistry() failed in TapiInitialize. continueing to add devices into registry")
            );
    }

    for (i = 0; i < dwTapiDevices; i++)
    {
        Rslt = lineNegotiateAPIVersion
        (
            g_hLineApp,
            i,
            MIN_TAPI_LINE_API_VER,
            MAX_TAPI_LINE_API_VER,
            &LocalTapiApiVersion,
            &lineExtensionID
            );
        if (Rslt == 0)
        {
            LineDevCaps = SmartLineGetDevCaps (g_hLineApp, i, LocalTapiApiVersion );
            if (LineDevCaps)
            {
                if (!AddNewDevice( i, LineDevCaps, TRUE , FaxDevices))
                {

                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("AddNewDevice() failed for device id: %ld (ec: %ld)"),
                        i,
                        GetLastError());

                    MemFree( LineDevCaps );
                }
                else
                {
                    MemFree( LineDevCaps );
                }
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SmartLineGetDevCaps failed for device id: %ld (ec: %ld)"),
                    i,
                    GetLastError());
                Assert(FALSE);
            }
        }
        else
        {

            DebugPrintEx(
                DEBUG_WRN,
                TEXT("lineNegotiateAPIVersion() failed for device id: %ld (ec: %ld)"),
                i,
                GetLastError());
        }
    }

    //
    // Delete any devices that need deletion
    //
    for (j = 0; j < FaxDevices->DeviceCount; j++)
    {
        //
        // skip any devices not created by us (created by FSPs) and virtual devices
        //
        if(!FaxDevices->Devices[j].bValidDevice ||
           FaxDevices->Devices[j].Flags & FPF_VIRTUAL) // Cache is not supported for VFSPs
        {
            continue;
        }

        if(!FaxDevices->Devices[j].DeviceInstalled)
        {
            //
            // update "LastDetected" field on installed devices
            //
            MoveDeviceRegIntoDeviceCache(
                FaxDevices->Devices[j].PermanentLineId,
                FaxDevices->Devices[j].TapiPermanentLineID,
                (FaxDevices->Devices[j].PermanentLineId == g_dwManualAnswerDeviceId));
        }
    }

    //
    //  Cache cleanning
    //
    CleanOldDevicesFromDeviceCache(dwlTimeNow);

    if (!GetCountries())
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Can't init Countries list"));
        if (!(ec = GetLastError()))
            ec = ERROR_GEN_FAILURE;
        LeaveCriticalSection( &g_CsLine );
        goto Error;

    }

    LeaveCriticalSection( &g_CsLine );

    goto Exit;

Error:
     if (g_hLineApp)
     {
         Rslt = lineShutdown(g_hLineApp);
         if (Rslt)
         {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("lineShutdown() failed (ec: %ld)"),
                 Rslt);
             Assert(FALSE);
         }
         g_hLineApp = NULL;
     }

    if (g_TapiCompletionPort)
    {
        if (!CloseHandle( g_TapiCompletionPort ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle( g_TapiCompletionPort ) failed (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
        g_TapiCompletionPort = NULL;
    }
    MemFree(g_pAdaptiveFileBuffer);
    g_pAdaptiveFileBuffer = NULL;


Exit:
     FreeFaxDevicesRegistry( FaxDevices );

     return ec;

}


BOOL LoadAdaptiveFileBuffer()
{
    DWORD ec = 0;
    DWORD i, j;
    HANDLE AdaptiveFileHandle = INVALID_HANDLE_VALUE;
    LPTSTR AdaptiveFileName  = NULL;

    DEBUG_FUNCTION_NAME(TEXT("LoadAdaptiveFileBuffer"));
    //
    // open faxadapt.lst file to decide on enabling rx
    //
    g_pAdaptiveFileBuffer = NULL;

    AdaptiveFileName = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\faxadapt.lst") );
    if (!AdaptiveFileName)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ExpandEnvironmentString(\"%systemroot%\\system32\\faxadapt.lst\") failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    AdaptiveFileHandle = SafeCreateFile(
        AdaptiveFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (AdaptiveFileHandle == INVALID_HANDLE_VALUE )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not open adaptive file [%s] (ec: %ld)"),
            _tcslwr(AdaptiveFileName),
            ec);
        goto Error;
    }


    i = GetFileSize( AdaptiveFileHandle, NULL );
    if (i != 0xffffffff)
    {
        g_pAdaptiveFileBuffer = (LPBYTE)MemAlloc( i + 16 );
        if (!g_pAdaptiveFileBuffer)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocated g_pAdaptiveFileBuffer (%ld bytes) (ec: %ld)"),
                i + 16,
                ec);
            goto Error;
        }
        if (!ReadFile( AdaptiveFileHandle, g_pAdaptiveFileBuffer, i, &j, NULL ) ) {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Could not read adaptive file [%s] (ec: %ld)"),
                _tcslwr(AdaptiveFileName),
                ec);
            goto Error;
        } else {
            g_pAdaptiveFileBuffer[j] = 0;  // need a string
        }
    }

    Assert (0 == ec);
    goto Exit;

Error:
    MemFree( g_pAdaptiveFileBuffer );
    g_pAdaptiveFileBuffer = NULL;

Exit:
    MemFree( AdaptiveFileName);

    if (AdaptiveFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( AdaptiveFileHandle );
    }

    if (ec) {
        SetLastError(ec);
    }

    return (0 == ec);
}



LONG
MyLineTranslateAddress(
    LPCTSTR               Address,
    DWORD                 DeviceId,
    LPLINETRANSLATEOUTPUT *TranslateOutput
    )
{
    DWORD LineTransOutSize;
    LONG Rslt = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(_T("MyLineTranslateAddress"));

    //
    // allocate the initial linetranscaps structure
    //
    LineTransOutSize = sizeof(LINETRANSLATEOUTPUT) + 4096;
    *TranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc( LineTransOutSize );
    if (!*TranslateOutput)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransOutSize);
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*TranslateOutput)->dwTotalSize = LineTransOutSize;

    Rslt = lineTranslateAddress(
        g_hLineApp,
        0,
        MAX_TAPI_API_VER,
        Address,
        0,
        LINETRANSLATEOPTION_CANCELCALLWAITING,
        *TranslateOutput
        );

    if (Rslt != 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateAddress() failed, ec=0x%08x"), Rslt);
        goto exit;
    }

    if ((*TranslateOutput)->dwNeededSize > (*TranslateOutput)->dwTotalSize)
    {
        //
        // re-allocate the LineTransCaps structure
        //
        LineTransOutSize = (*TranslateOutput)->dwNeededSize;

        MemFree( *TranslateOutput );

        *TranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc( LineTransOutSize );
        if (!*TranslateOutput)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransOutSize);
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*TranslateOutput)->dwTotalSize = LineTransOutSize;

        Rslt = lineTranslateAddress(
            g_hLineApp,
            0,
            MAX_TAPI_API_VER,
            Address,
            0,
            LINETRANSLATEOPTION_CANCELCALLWAITING,
            *TranslateOutput
            );

        if (Rslt != 0)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateAddress() failed, ec=0x%08x"), Rslt);
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS)
    {
        MemFree( *TranslateOutput );
        *TranslateOutput = NULL;
    }
    return Rslt;
}





BOOL CreateTapiThread(void)
{
    DWORD ThreadId;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("CreateTapiThread"));

    g_hTapiWorkerThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) TapiWorkerThread,
        NULL,
        0,
        &ThreadId
        );

    if (!g_hTapiWorkerThread)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not start TapiWorkerThread (CreateThread)(ec: %ld)"),
            ec);
        
        goto Error;
         
    }
    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:
    //
    // freeServiceGlobals is responsible of closing the threads handle
    //

    if (ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}


DWORD
GetDeviceListByCountryAndAreaCode(
    DWORD       dwCountryCode,
    DWORD       dwAreaCode,
    LPDWORD*    lppdwDevices,
    LPDWORD     lpdwNumDevices
    )
/*++

Routine name : GetDeviceListByCountryAndAreaCode

Routine description:

    Returns an ordered list of devices that are a rule destination.
    The rule is  specified by country and area code.
    The caller must call MemFree() to deallocate memory.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwCountryCode       [in    ] - Country code
    dwAreaCode          [in    ] - Area code
    lppdwDevices        [out   ] - Pointer to recieve the device list
    lpdwNumDevices      [out   ] - pointer to recieve the number of devices in the list

Return Value:

    Standard win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("GetDeviceListByCountryAndAreaCode"));
    DWORD ec = ERROR_SUCCESS;

    Assert (lppdwDevices && lpdwNumDevices);

    CDialingLocation DialingLocation(dwCountryCode, dwAreaCode);
    //
    // Search for CountryCode.AreaCode
    //
    PCRULE pCRule = g_pRulesMap->FindRule (DialingLocation);
    if (NULL == pCRule)
    {
        ec = GetLastError();
        if (FAX_ERR_RULE_NOT_FOUND != ec)
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRulesMap::FindRule failed with error %ld"),
                ec);
             goto exit;
        }
        //
        // Search for CountryCode.*
        //
        DialingLocation = CDialingLocation(dwCountryCode, ROUTING_RULE_AREA_CODE_ANY);
        pCRule = g_pRulesMap->FindRule (DialingLocation);
        if (NULL == pCRule)
        {
            ec = GetLastError();
            if (FAX_ERR_RULE_NOT_FOUND != ec)
            {
                 DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRulesMap::FindRule failed with error %ld"),
                    ec);
                 goto exit;
            }
            //
            // Search for *.*
            //
            DialingLocation = CDialingLocation(ROUTING_RULE_COUNTRY_CODE_ANY, ROUTING_RULE_AREA_CODE_ANY);
            pCRule = g_pRulesMap->FindRule (DialingLocation);
            if (NULL == pCRule)
            {
                ec = GetLastError();
                if (FAX_ERR_RULE_NOT_FOUND != ec)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("COutboundRulesMap::FindRule failed with error %ld"),
                        ec);
                     goto exit;
                }
            }
        }
    }

    if (NULL == pCRule)
    {
        // No rule found!!!
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("No outbound routing rule found"));
        *lppdwDevices = NULL;
        *lpdwNumDevices = 0;
        ec = ERROR_NOT_FOUND;
        Assert (NULL != pCRule) // Assert (FALSE)
        goto exit;
    }
    else
    {
        ec = pCRule->GetDeviceList (lppdwDevices, lpdwNumDevices);
        if (ERROR_SUCCESS != ec)
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRule::GetDeviceList failed with error %ld"),
                ec);
             goto exit;
        }
    }
    Assert (ERROR_SUCCESS == ec);

exit:
    return ec;
}


BOOL
IsAreaCodeMandatory(
    LPLINECOUNTRYLIST   lpCountryList,
    DWORD               dwCountryCode
    )
/*++

Routine name : IsAreaCodeMandatory

Routine description:

    Checks if an area code is mandatory for a specific country

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpCountryList           [in    ] - Pointer to LINECOUNTRYLIST list, returned from a call to LineGetCountry
    dwCountryCode           [in    ] - The country country code.

Return Value:

    TRUE - The area code is needed.
    FALSE - The area code is not mandatory.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("IsAreaCodeMandatory"));
    LPLINECOUNTRYENTRY          lpEntry = NULL;
    DWORD                       dwIndex;

    Assert (lpCountryList);

    lpEntry = (LPLINECOUNTRYENTRY)  // init array of entries
        ((PBYTE) lpCountryList + lpCountryList->dwCountryListOffset);
    for (dwIndex=0; dwIndex < lpCountryList->dwNumCountries; dwIndex++)
    {
        if (lpEntry[dwIndex].dwCountryCode == dwCountryCode)
        {
            //
            // Matching country code - Check long distance rule.
            //
            if (lpEntry[dwIndex].dwLongDistanceRuleSize  && lpEntry[dwIndex].dwLongDistanceRuleOffset )
            {
                LPWSTR lpwstrLongDistanceDialingRule = (LPWSTR)((LPBYTE)lpCountryList +
                                                                lpEntry[dwIndex].dwLongDistanceRuleOffset);
                if (wcschr(lpwstrLongDistanceDialingRule, TEXT('F')) != NULL)
                {
                    return TRUE;
                }
                return FALSE;
            }
        }
    }
    return FALSE;
}

VOID
UpdateReceiveEnabledDevicesCount ()
/*++

Routine name : UpdateReceiveEnabledDevicesCount

Routine description:

    Updates the counter of the number of devices that are enabled to receive faxes

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:


Return Value:

    None

--*/
{
    PLIST_ENTRY pNext;
    DWORD dwOldCount;
    BOOL fManualDeviceFound = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("UpdateReceiveEnabledDevicesCount"));

#if DBG
    DWORD dwEnabledDevices = 0;
    DWORD dwDevices        = 0;
#endif

    EnterCriticalSection( &g_CsLine );
    dwOldCount = g_dwReceiveDevicesCount;
    g_dwReceiveDevicesCount = 0;
    pNext = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_TapiLinesListHead)
    {
        PLINE_INFO  pLineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
        pNext = pLineInfo->ListEntry.Flink;

        if (g_dwManualAnswerDeviceId == pLineInfo->PermanentLineID)
        {
            fManualDeviceFound = TRUE;
        }

        if ((pLineInfo->Flags) & FPF_RECEIVE)
        {
            if (g_dwManualAnswerDeviceId == pLineInfo->PermanentLineID)
            {
                DebugPrintEx(DEBUG_WRN,
                             TEXT("Device %ld is set to auto-receive AND manual-receive. Canceling the manual-receive for it"),
                             g_dwManualAnswerDeviceId);
                g_dwManualAnswerDeviceId = 0;
                DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                        dwRes);
                }
            }
            g_dwReceiveDevicesCount++;
        }
#if DBG
        if (TRUE == IsDeviceEnabled(pLineInfo))
        {
            dwEnabledDevices += 1;
        }
        dwDevices += 1;
#endif
    }

#if DBG
    Assert (dwEnabledDevices == g_dwDeviceEnabledCount);
    Assert (dwDevices == g_dwDeviceCount);
#endif

    if (FALSE == fManualDeviceFound &&
        0 != g_dwManualAnswerDeviceId)
    {
        //
        // There manual answer device id is not valid
        //
        g_dwManualAnswerDeviceId = 0;
        DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }

    DebugPrintEx(DEBUG_MSG,
                 TEXT("Number of receive-enabled devices is now %ld"),
                 g_dwReceiveDevicesCount);

    LeaveCriticalSection( &g_CsLine );
}   // UpdateReceiveEnabledDevicesCount



BOOL
RemoveTapiDevice(
    DWORD dwDeviceId
    )
{
    DWORD ec = ERROR_SUCCESS;
    BOOL rVal = TRUE;
    PLINE_INFO pLineInfo = NULL;
    PLIST_ENTRY Next;
    DWORD dwPermanentTapiDeviceId;
    DWORD dwPermanentLineID;

    BOOL fFound = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("RemoveTapiDevice"));

    Next = g_TapiLinesListHead.Flink;
    Assert (Next);
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;
        if (!(pLineInfo->Flags & FPF_VIRTUAL) &&  // Virtual devices may have the same device id (device index) as the Tapi session id
                                                  // We do not support removal of VFSP device
            dwDeviceId == pLineInfo->DeviceId)
        {
            dwPermanentTapiDeviceId = pLineInfo->TapiPermanentLineId;
            dwPermanentLineID = pLineInfo->PermanentLineID;
            fFound = TRUE;
            break;
        }
    }
    if (FALSE == fFound)
    {
        //
        // Can be if for some reason the device was not added.
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("failed to find line for device id: %ld)"),
            dwDeviceId);
        SetLastError(ERROR_NOT_FOUND);
        return FALSE;
    }

    RemoveEntryList (&pLineInfo->ListEntry);
    InsertTailList (&g_RemovedTapiLinesListHead, &pLineInfo->ListEntry);
    Assert (g_dwDeviceCount);
    g_dwDeviceCount -= 1;

    MoveDeviceRegIntoDeviceCache(
        dwPermanentLineID,
        dwPermanentTapiDeviceId,
        (dwPermanentLineID == g_dwManualAnswerDeviceId));

    //
    // Update Enabled devices count
    //
    if (TRUE == IsDeviceEnabled(pLineInfo))
    {
        Assert (g_dwDeviceEnabledCount);
        g_dwDeviceEnabledCount -= 1;
    }

    if (dwPermanentLineID == g_dwManualAnswerDeviceId)
    {
        g_dwManualAnswerDeviceId = 0;
        DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }

    ec = g_pTAPIDevicesIdsMap->RemoveDevice (dwPermanentTapiDeviceId);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("g_pTAPIDevicesIdsMap->RemoveDevice() failed for Tapi device id: %ld (ec: %ld)"),
            dwPermanentTapiDeviceId,
            ec);
        rVal = FALSE;
    }

    //
    // Update outbound routing
    //
    ec = g_pGroupsMap->RemoveDevice(dwPermanentLineID);
    if (ERROR_SUCCESS != ec)
    {
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::RemoveDevice() failed (ec: %ld)"),
            ec);
         rVal = FALSE;
    }

    if (TRUE == rVal)
    {
        DWORD dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) (ec: %lc)"),
                dwRes);
        }

        dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
                dwRes);
        }
    }
    else
    {
        Assert (ERROR_SUCCESS != ec);
        SetLastError(ec);
    }
    return rVal;
}

BOOL
IsDeviceEnabled(
    PLINE_INFO pLineInfo
    )
/*++

Routine name : IsDeviceEnabled

Routine description:

    Checks if a device is send or receive or manual receive enabled
    Must be called inside G_CsLine

Author:

    Oded Sacher (OdedS), Feb, 2001

Arguments:


Return Value:

    TRUE if enabled. FALSE if not

--*/
{
    Assert (pLineInfo);
    if ((pLineInfo->Flags & FPF_RECEIVE) ||
        (pLineInfo->Flags & FPF_SEND)    ||
        pLineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
    {
        //
        // The device was send/receive/manual receive enabled
        //
        return TRUE;
    }
    return FALSE;
}



/*++

Routine name : CleanOldDevicesFromDeviceCache


Routine description:

    The routine scan the device-cache and remove old entries (by DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME constant).

Author:

    Caliv Nir (t-nicali), Apr, 2001

Arguments:

    dwlTimeNow  [in] - current time in UTC ( result of GetSystemTimeAsFileTime )


Return Value:

    ERROR_SUCCESS - when all devices was checked and cleaned

--*/
DWORD
CleanOldDevicesFromDeviceCache(DWORDLONG dwlTimeNow)
{
    DWORDLONG   dwOldestDate = dwlTimeNow - DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME;     // oldest date allowed for cache device
    HKEY        hKeyCache   = NULL;
    DWORDLONG*  pDeviceDate;
    DWORD       dwDataSize = sizeof(DWORDLONG);
    DWORD       dwTapiPermanentLineID;

    DWORD       dwKeyNameLen;
    DWORD       dwIndex ;

    DWORD       dwRes = ERROR_SUCCESS;

    PTSTR       pszKeyName= NULL;

    vector<DWORD>   vecCacheEntryForDeletion;
 

    DEBUG_FUNCTION_NAME(TEXT("CleanOldDevicesFromDeviceCache"));


    //  open cache registry entry
    hKeyCache = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES_CACHE, FALSE, KEY_READ );
    if (!hKeyCache)
    {
        //
        //  No Device cache is present yet
        //
        dwRes = GetLastError();
        DebugPrintEx(
                DEBUG_WRN,
                TEXT("OpenRegistryKey failed with [%lu] for [%s] . Device cache still wasn't created."),
                dwRes,
                REGKEY_FAX_DEVICES_CACHE
                );
        return  dwRes;
    }


    // get length of longest key name in characrter
    DWORD dwMaxSubKeyLen;

    dwRes = RegQueryInfoKey(hKeyCache, NULL, NULL, NULL, NULL, &dwMaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL);

    if ( ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryInfoKey failed with [%lu] for [%s]."),
                dwRes,
                REGKEY_FAX_DEVICES_CACHE
                );
        goto Exit;
    }

    // Add one for the NULL terminator
    dwMaxSubKeyLen++;

    // Allocate buffer for subkey names
    pszKeyName = (PTSTR) MemAlloc(dwMaxSubKeyLen * sizeof(TCHAR));
    if ( NULL == pszKeyName )
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("MemAlloc failure")
                );
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Store buffer length
    dwKeyNameLen = dwMaxSubKeyLen;

    // Start from the begining
    dwIndex = 0;

    while ( ERROR_SUCCESS == RegEnumKeyEx(hKeyCache, dwIndex++, pszKeyName, &dwKeyNameLen, NULL, NULL, NULL, NULL) )
    {
        HKEY    hKeyDevice;

        hKeyDevice = OpenRegistryKey( hKeyCache, pszKeyName, FALSE, KEY_READ );
        if (!hKeyDevice)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("OpenRegistryKey failed for [%s]."),
                pszKeyName
                );

            goto Next;
        }

        //
        //  get caching time
        //
        pDeviceDate = (DWORDLONG *)GetRegistryBinary(hKeyDevice, REGVAL_LAST_DETECTED_TIME, &dwDataSize);

        if ( (NULL == pDeviceDate) || (*pDeviceDate < dwOldestDate) )
        {
            //
            //  mark for deletion old or illegal cache-entry
            //
            if ( 1 == _stscanf( pszKeyName, TEXT("%lx"),&dwTapiPermanentLineID ) )
            {
                try
                {
                    vecCacheEntryForDeletion.push_back(dwTapiPermanentLineID);
                }
                catch (exception &ex)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("push back failed throwing an exception: %S"),
                        ex.what()
                    );
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    MemFree(pDeviceDate);
                    RegCloseKey (hKeyDevice);
                    goto Exit;
                }
            }
            else
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("_stscanf failed can't retrive tapi ID skipping this entry.")
                );
            }

        }

        MemFree(pDeviceDate);
        RegCloseKey (hKeyDevice);

Next:
        // restore buffer length
        dwKeyNameLen = dwMaxSubKeyLen;
    }

    try
    {
        while (!vecCacheEntryForDeletion.empty())
        {
            dwTapiPermanentLineID = vecCacheEntryForDeletion.back();
            DeleteCacheEntry(dwTapiPermanentLineID);
            vecCacheEntryForDeletion.pop_back();
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("vector operation failed throwing an exception, abort cleanning; %S"),
            ex.what()
        );
    }


Exit:

    MemFree(pszKeyName);
    RegCloseKey (hKeyCache);

    return dwRes;
}


DWORD
UpdateDevicesFlags(
    void
    )
/*++

Routine name : UpdateDevicesFlags


Routine description:

    Updates new devices flags ,so we will not exceed device limit on this SKU

Author:

    Sacher Oded (odeds), May, 2001

Arguments:

    None


Return Value:

    Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    PLIST_ENTRY Next;
    PLINE_INFO pLineInfo;
    DEBUG_FUNCTION_NAME(TEXT("UpdateDevicesFlags"));

    //
    // loop thru the devices and reset flags of new devices if we exceeded device limit
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead &&
           g_dwDeviceEnabledCount > g_dwDeviceEnabledLimit)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->dwDeviceType & FAX_DEVICE_TYPE_NEW) ||
            FALSE == IsDeviceEnabled(pLineInfo))
        {
            continue;
        }
        //
        // Device is new and enabled.
        //
        ResetDeviceFlags(pLineInfo);
        g_dwDeviceEnabledCount -= 1;
    }

    //
    // loop thru the devices and reset flags of cached devices if we exceeded device limit
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead &&
           g_dwDeviceEnabledCount > g_dwDeviceEnabledLimit)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->dwDeviceType & FAX_DEVICE_TYPE_CACHED) ||
            FALSE == IsDeviceEnabled(pLineInfo))
        {
            continue;
        }
        //
        // Device is cached and enabled.
        //
        ResetDeviceFlags(pLineInfo);
        g_dwDeviceEnabledCount -= 1;
    }

    //
    // loop thru the devices and reset flags of old devices if we exceeded device limit.
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead &&
           g_dwDeviceEnabledCount > g_dwDeviceEnabledLimit)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->dwDeviceType & FAX_DEVICE_TYPE_OLD) ||
            FALSE == IsDeviceEnabled(pLineInfo))
        {
            continue;
        }
        //
        // Device is old and enabled.
        //
        ResetDeviceFlags(pLineInfo);
        g_dwDeviceEnabledCount -= 1;
    }
    Assert (g_dwDeviceEnabledCount <= g_dwDeviceEnabledLimit);

    //
    // loop thru the devices and close the line handles
    // for all devices that are NOT set to receive
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->Flags & FPF_RECEIVE)                        &&  // Device is not set to auto-receive and
            pLineInfo->hLine                                         &&  // device is open and
            pLineInfo->PermanentLineID != g_dwManualAnswerDeviceId       // this device is not set to manual answer mode
           )
        {
            //
            // Attempt to close the device
            //
            HLINE hLine = pLineInfo->hLine;
            pLineInfo->hLine = 0;
            LONG Rslt = lineClose( hLine );
            if (Rslt)
            {
                if (LINEERR_INVALLINEHANDLE != Rslt)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("lineClose() for line %s [Permanent Id: %010d] has failed. (ec: %ld)"),
                        pLineInfo->DeviceName,
                        pLineInfo->TapiPermanentLineId,
                        Rslt);
                    ASSERT_FALSE;
                }
                else
                {
                    //
                    // We can get LINEERR_INVALLINEHANDLE if we got LINE_CLOSE
                    // from TAPI.
                    //
                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("lineClose() for line %s [Permanent Id: %010d] reported LINEERR_INVALLINEHANDLE. (May be caused by LINE_CLOSE event)"),
                        pLineInfo->DeviceName,
                        pLineInfo->TapiPermanentLineId
                        );
                }
            }
        }
    }
    return dwRes;
}




VOID
UpdateManualAnswerDevice(
    void
    )
/*++

Routine name : UpdateManualAnswerDevice


Routine description:

    Updates the manual answer device with a cached device

Author:

    Sacher Oded (odeds), July, 2001

Arguments:

    None


Return Value:

    None

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("UpdateManualAnswerDevice"));

    //
    // Call UpdateReceiveEnabledDevicesCount () to make sure the manual answer device is valid
    //
    UpdateReceiveEnabledDevicesCount();

    //
    // if we have a valid manual answer device then finish
    //
    if (0 == g_dwManualAnswerDeviceId)
    {
        //
        //  No valid manual answer device is operational so look if chached devices were manual.
        //  loop through the cached devices and look for the first cached device and set it as a manual answer device
        //
        PLIST_ENTRY Next;
        PLINE_INFO pLineInfo;

        Next = g_TapiLinesListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
        {
            BOOL fDeviceWasEnabled;
            DWORD dwRes;

            pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = pLineInfo->ListEntry.Flink;

            //
            // look for a cached manual answer device that is not set to auto receive
            //
            if ( pLineInfo->dwDeviceType != (FAX_DEVICE_TYPE_CACHED | FAX_DEVICE_TYPE_MANUAL_ANSWER) ||
                (pLineInfo->Flags & FPF_RECEIVE))
            {
                continue;
            }

            //
            // We found a device that can be set to manual receive
            //

            //
            // Now it may be that the cached device was not enabled (if for example it was marked as
            // manual-answer and no send ) so we didn't count it in the Enabled Count devices group.
            // if so then after setting it as a manual receive we ought to update g_dwDeviceEnabledCount
            //
            fDeviceWasEnabled = IsDeviceEnabled(pLineInfo);
            
            g_dwManualAnswerDeviceId = pLineInfo->PermanentLineID;
            dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);   // persist in registry
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                    dwRes);
            }

            //
            // Update enabled devices count
            //
            if (FALSE == fDeviceWasEnabled)
            {
                //
                // Another device is now enabled
                //
                g_dwDeviceEnabledCount += 1;
            }

            //
            //  No need to continue the search, only one "manual receive" device is allowed
            //
            break;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\tapicountry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiCountry.c

Abstract:

    Utility functions for working with TAPI

Environment:

    Server

Revision History:

    09/18/96 -davidx-
        Created it.

    07/25/99 -v-sashab-
        Moved from fxsui

--*/

#include "faxsvc.h"
#include "tapiCountry.h"

//
// Global variables used for accessing TAPI services
//
LPLINECOUNTRYLIST g_pLineCountryList;



BOOL
GetCountries(
    VOID
    )

/*++

Routine Description:

    Return a list of countries from TAPI

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

NOTE:

    We cache the result of lineGetCountry here since it's incredibly slow.
    This function must be invoked inside a critical section since it updates
    globally shared information.

--*/

{
#define INITIAL_SIZE_ALL_COUNTRY    22000
    DEBUG_FUNCTION_NAME(TEXT("GetCountries"));
    DWORD   cbNeeded;
    LONG    status;
    INT     repeatCnt = 0;

    if (g_pLineCountryList == NULL) {

        //
        // Initial buffer size
        //

        cbNeeded = INITIAL_SIZE_ALL_COUNTRY;

        while (TRUE) {

            MemFree(g_pLineCountryList);
			g_pLineCountryList = NULL;

            if (! (g_pLineCountryList = (LPLINECOUNTRYLIST)MemAlloc(cbNeeded)))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Memory allocation failed"));
                break;
            }

            g_pLineCountryList->dwTotalSize = cbNeeded;

            status = lineGetCountry(0, MAX_TAPI_API_VER, g_pLineCountryList);

            if ((g_pLineCountryList->dwNeededSize > g_pLineCountryList->dwTotalSize) &&
                (status == NO_ERROR ||
                 status == LINEERR_STRUCTURETOOSMALL ||
                 status == LINEERR_NOMEM) &&
                (repeatCnt++ == 0))
            {
                cbNeeded = g_pLineCountryList->dwNeededSize + 1;
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("LINECOUNTRYLIST size: %d"),cbNeeded);
                continue;
            }

            if (status != NO_ERROR) {

                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("lineGetCountry failed: %x"),status);
                MemFree(g_pLineCountryList);
                g_pLineCountryList = NULL;

            } else
                DebugPrintEx(DEBUG_MSG,TEXT("Number of countries: %d"), g_pLineCountryList->dwNumCountries);

            break;
        }
    }

    return g_pLineCountryList != NULL;
}


LPLINECOUNTRYLIST
GetCountryList(
               )
{
    DEBUG_FUNCTION_NAME(TEXT("GetCountryList"));

    return g_pLineCountryList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\tapicountry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiCountry.h

Abstract:

    Utility functions for working with TAPI

Environment:
	Server

Revision History:

        09/18/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _TAPICOUNTRY_H_
#define _TAPICOUNTRY_H_


#include <tapi.h>
#include <shellapi.h>


//
// Init a list of countries
//

BOOL
GetCountries(
    VOID
    );


//
// Return the list of country
//


LPLINECOUNTRYLIST	
GetCountryList(
			   );

#endif  // !_TAPICOUNTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\systray\monitor.cpp ===
/**

Copyright (c)  Microsoft Corporation 1999-2000

Module Name:

    monitor.cpp

Abstract:

    This module implements the fax monitor dialog.

**/


#include <windows.h>
#include <faxreg.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <commctrl.h>
#include <tchar.h>
#include <DebugEx.h>

#include <list>
using namespace std;

#include "monitor.h"
#include "resource.h"

#define DURATION_TIMER_RESOLUTION   500     // Resolution (millisecs) of duration text update timer

//////////////////////////////////////////////////////////////
// Global data
//

extern HINSTANCE        g_hModule;              // DLL Global instance
extern HINSTANCE        g_hResource;            // Resource DLL handle
extern HANDLE           g_hFaxSvcHandle;
extern DWORD            g_dwCurrentJobID;
extern CONFIG_OPTIONS   g_ConfigOptions;
extern TCHAR            g_szRemoteId[MAX_PATH];  // Sender ID or Recipient ID
extern HCALL            g_hCall;                 // Handle to call (from FAX_EVENT_TYPE_NEW_CALL)
//
// Events log
//

struct EVENT_ENTRY
{
    eIconType eIcon;                // Event icon
    TCHAR     tszTime[30];          // Event time string
    TCHAR     tszEvent[MAX_PATH];   // Event string
};

typedef EVENT_ENTRY *PEVENT_ENTRY;

typedef list<EVENT_ENTRY> EVENTS_LIST, *PEVENTS_LIST;

EVENTS_LIST g_lstEvents;        // Global list of events

#define MAX_EVENT_LIST_SIZE   50  // Maximal number of events in log

//
// Monitor dialog
//
HWND   g_hMonitorDlg = NULL;

//
// Controls
//
HWND   g_hStatus         = NULL;    // Status line (static text)
HWND   g_hElapsedTime    = NULL;    // Elapsed time line (static text)
HWND   g_hToFrom         = NULL;    // To/From line (static text)
HWND   g_hListDetails    = NULL;    // Details list control
HWND   g_hAnimation      = NULL;    // Animation control
HWND   g_hDisconnect     = NULL;    // Disconnect button

HICON      g_hDlgIcon      = NULL;    // Dialog main icon
HIMAGELIST g_hDlgImageList = NULL;  // Dialog's image list

//
// Data
//
BOOL         g_bAnswerNow = FALSE;  // TRUE if the dialog button shows 'Answer Now'. FALSE if it shows 'Disconnect'.
DWORD        g_dwHeightDelta = 0;   // Used when pressing "More >>>" / "Less <<<" to resize the dialog
DWORD        g_dwDlgHeight = 0;     // The dialog height
BOOL         g_bDetails = FALSE;    // Is the "More >>>" button pressed?
DeviceState  g_devState = FAX_IDLE; // Current fax state (animation)
DWORD        g_dwStartTime = 0;     // Activity start time (tick counts)
UINT_PTR     g_nElapsedTimerId = 0; // Timer id for elapsed time (ticks every 1 second)
TCHAR        g_tszTimeSeparator[5] = {0};
DWORD        g_dwCurrentAnimationId = 0;      // Current animation resource ID
TCHAR        g_tszLastEvent[MAX_PATH] = {0};  // The last event string
POINT        g_ptPosition = {-1, -1};         // Dialog position
BOOL         g_bTopMost = FALSE;    // Is the monitor dialog always visible?

#define DETAILS_TIME_COLUMN_WIDTH    90


/////////////////////////////////////////////////////////////////////
// Function prototypes
//

// public
BOOL  IsUserGrantedAccess(DWORD);
DWORD OpenFaxMonitor(VOID);
void  SetStatusMonitorDeviceState(DeviceState devState);
void  OnDisconnect();
void  FreeMonitorDialogData (BOOL bShutdown);

// Private
INT_PTR CALLBACK FaxMonitorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID    CALLBACK ElapsedTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

void  InitMonitorDlg(HWND hDlg);
DWORD UpdateMonitorData(HWND hDlg);
void  AddEventToView(PEVENT_ENTRY pEvent);
void  OnAlwaysOnTop(HWND hDlg);
void  OnDetailsButton(HWND hDlg, BOOL bDetails);
void  OnClearLog();
int   FaxMessageBox(HWND hWnd, DWORD dwTextID, UINT uType);
DWORD  RefreshImageList ();

//////////////////////////////////////////////////////////////////////
// Implementation
//

void  
FreeMonitorDialogData (
    BOOL bShutdown /* = FALSE */
)
/*++

Routine name : FreeMonitorDialogData

Routine description:

    Frees up all the data allocated by the monitor module

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:

    bShutdown - [in] TRUE only is the module is shutting down.

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("FreeMonitorDialogData"), dwRes);

    RECT rc = {0};
    if(GetWindowRect(g_hMonitorDlg, &rc))
    {
        g_ptPosition.x = rc.left;
        g_ptPosition.y = rc.top;
    }
    
    
    g_hMonitorDlg = NULL;

    g_hStatus      = NULL;
    g_hElapsedTime = NULL;
    g_hToFrom      = NULL;
    g_hListDetails = NULL;
    g_hDisconnect  = NULL;
    g_hAnimation   = NULL;
    g_dwCurrentAnimationId = 0;

    if (g_hDlgImageList)
    {
        ImageList_Destroy (g_hDlgImageList);
        g_hDlgImageList = NULL;
    }
    if (bShutdown)
    {
        //
        // DLL is shutting down.
        //

        //
        // The icon is cached in memory even when the dialog is closed.
        // This is a good time to free it.
        //
		if(g_nElapsedTimerId)
		{
			if (!KillTimer(NULL, g_nElapsedTimerId))
			{
				CALL_FAIL (GENERAL_ERR, TEXT("KillTimer"), GetLastError ());
			}
			g_nElapsedTimerId = NULL;
		}

        if (g_hDlgIcon)
        {
            if (!DestroyIcon (g_hDlgIcon))
            {
                CALL_FAIL (WINDOW_ERR, TEXT("DestroyIcon"), GetLastError ());
            }
            g_hDlgIcon = NULL;
        }
        //
        // Also delete all the events from the list
        //
        try
        {
            g_lstEvents.clear();
        }
        catch (exception &ex)
        {
            VERBOSE (MEM_ERR, 
                     TEXT("Got an STL exception while clearing the events list (%S)"),
                     ex.what());
        }

        g_ptPosition.x = -1;
        g_ptPosition.y = -1;
    }
}   // FreeMonitorDialogData


INT_PTR 
CALLBACK 
FaxMonitorDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    fax monitor dialog procedure

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            InitMonitorDlg(hwndDlg);
            return TRUE;

        case WM_DESTROY:
            FreeMonitorDialogData ();
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_DETAILS:
                        g_bDetails = !g_bDetails;
                        OnDetailsButton(hwndDlg, g_bDetails);
                        return TRUE;

                case IDC_ALWAYS_ON_TOP:
                        OnAlwaysOnTop(hwndDlg);
                        return TRUE;

                case IDC_CLEAR_LOG:
                        OnClearLog();
                        return TRUE;

                case IDC_DISCONNECT:
                        OnDisconnect();
                        return TRUE;

                case IDCANCEL:
                        DestroyWindow( hwndDlg );
                        return TRUE;

            } // switch(LOWORD(wParam))

            break;

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hwndDlg);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hwndDlg);            
            return TRUE;

        case WM_SYSCOLORCHANGE:
            RefreshImageList ();
            return TRUE;

    } // switch ( uMsg )
    return FALSE;
} // FaxMonitorDlgProc

DWORD
RefreshImageList ()
/*++

Routine name : RefreshImageList

Routine description:

    Refreshes the image list and list view background color

Author:

    Eran Yariv (EranY), May, 2001

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("RefreshImageList"), dwRes);
    ListView_SetExtendedListViewStyle(g_hListDetails, 
                                      LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP | LVS_EX_ONECLICKACTIVATE);

    if (NULL != g_hDlgImageList)
    {
        ImageList_Destroy (g_hDlgImageList);
        g_hDlgImageList = NULL;
    }
    g_hDlgImageList = ImageList_Create (16, 16, ILC_COLOR8, 4, 0);
    if(!g_hDlgImageList)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT("ImageList_Create"), dwRes);
        return dwRes;
    }
    HBITMAP hBmp = (HBITMAP) LoadImage (
                              g_hModule, 
                              MAKEINTRESOURCE(IDB_LIST_IMAGES),
                              IMAGE_BITMAP,
                              0,
                              0,
                              LR_DEFAULTSIZE | LR_LOADTRANSPARENT);
    if (!hBmp)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT("LoadBitmap"), dwRes);
        ImageList_Destroy (g_hDlgImageList);
        g_hDlgImageList = NULL;
        return dwRes;
    }
    ImageList_Add (g_hDlgImageList, hBmp, NULL);
    //
    // ImageList_Add creates a copy of the bitmap - it's now safe to delete it
    //
    ::DeleteObject ((HGDIOBJ)hBmp);
    ListView_SetImageList(g_hListDetails, g_hDlgImageList, LVSIL_SMALL);
    ListView_SetBkColor  (g_hListDetails, ::GetSysColor(COLOR_WINDOW));
    return dwRes;
}   // RefreshImageList

void
InitMonitorDlg(
    HWND hDlg
)
/*++

Routine description:

    Initialize fax monitor dialog

Arguments:

    hDlg          [in] - fax monitor dialog handle

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("InitMonitorDlg"), dwRes);

    //
    // Set the dialog icon
    //
    if (NULL == g_hDlgIcon)
    {
        //
        // 1st time the dialog is opened - load the icons
        //
        g_hDlgIcon = LoadIcon(g_hModule, MAKEINTRESOURCE(IDI_FAX_MONITOR));
        if(!g_hDlgIcon)
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("LoadIcon"), dwRes);
            return;
        }
    }
    SendMessage(hDlg, WM_SETICON, ICON_BIG,   (LPARAM)g_hDlgIcon);
    SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)g_hDlgIcon);
    //
    // Calculate the height of the details part
    //
    RECT rcList, rcDialog;
    if(!GetWindowRect(hDlg, &rcDialog))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("GetWindowRect"), dwRes);
        return;
    }
    g_dwDlgHeight = rcDialog.bottom - rcDialog.top;

    g_hListDetails = GetDlgItem(hDlg, IDC_LIST_DETAILS);
    ASSERTION (g_hListDetails);

    if(!GetWindowRect(g_hListDetails, &rcList))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("GetWindowRect"), dwRes);
        return;
    }

    g_dwHeightDelta = rcDialog.bottom - rcList.top;

    //
    //  Shrink down to small size (initially)
    //
    OnDetailsButton(hDlg, g_bDetails);

    //
    // Init the list view
    //
    RefreshImageList ();
    //
    // Add time column
    //
    TCHAR tszHeader[MAX_PATH];

    LVCOLUMN lvColumn = {0};
    lvColumn.mask     = LVCF_TEXT | LVCF_WIDTH;
    lvColumn.cx       = DETAILS_TIME_COLUMN_WIDTH;
    lvColumn.pszText  = tszHeader;

    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_DETAIL_TIME_HEADER, tszHeader, ARR_SIZE(tszHeader))))
    {
        return;
    }

    ListView_InsertColumn(g_hListDetails, 0, &lvColumn);

    //
    // add event column
    //
    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_DETAIL_EVENT_HEADER, tszHeader, ARR_SIZE(tszHeader))))
    {
        return;
    }
    ListView_InsertColumn(g_hListDetails, 1, &lvColumn);

    //
    // Autosize the last column width
    //
    ListView_SetColumnWidth(g_hListDetails, 1, LVSCW_AUTOSIZE_USEHEADER); 

    //
    // Animation control
    //
    g_hAnimation = GetDlgItem(hDlg, IDC_ANIMATE);
    ASSERTION (g_hAnimation);
    //
    // Get static text controls
    //
    g_hStatus = GetDlgItem(hDlg, IDC_STATUS);
    ASSERTION (g_hStatus);
    g_hElapsedTime = GetDlgItem(hDlg, IDC_ELAPSED_TIME);
    ASSERTION (g_hElapsedTime);
    g_hToFrom = GetDlgItem(hDlg, IDC_MON_TITLE);
    ASSERTION (g_hToFrom);
    //
    // Disconnect button
    //
    g_hDisconnect = GetDlgItem(hDlg, IDC_DISCONNECT);
    ASSERTION (g_hDisconnect);    
    //
    // Get the time separator string
    //
    if(!GetLocaleInfo(LOCALE_USER_DEFAULT, 
                      LOCALE_STIME, 
                      g_tszTimeSeparator, 
                      ARR_SIZE(g_tszTimeSeparator) - 1))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("GetLocaleInfo(LOCALE_STIME)"), dwRes);
    } 
    
    if(g_ptPosition.x != -1 && g_ptPosition.y != -1)
    {
        SetWindowPos(hDlg, 0, g_ptPosition.x, g_ptPosition.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    }

    UpdateMonitorData(hDlg);

} // InitMonitorDlg


DWORD
UpdateMonitorData(
    HWND hDlg
)
/*++

Routine description:

    Update monitor data and controls

Arguments:

    hDlg          [in] - fax monitor dialog handle
    
Return Value:

    standard error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("UpdateMonitorData"), dwRes);

    if(!hDlg || !g_hStatus || !g_hElapsedTime || !g_hToFrom || !g_hListDetails || !g_hDisconnect)
    {
        return dwRes;
    }
    //
    // elapsed time
    //
    if(FAX_IDLE == g_devState)
    {
        if(!SetWindowText(g_hElapsedTime, TEXT("")))
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
        }        
    }
    //
    // Disconnect/Answer button
    //
    BOOL  bButtonEnable = FALSE;
    DWORD dwButtonTitleID = IDS_BUTTON_DISCONNECT;
    TCHAR tszButtonTitle[MAX_PATH] = {0};
    g_bAnswerNow = FALSE;
    if (ERROR_SUCCESS == CheckAnswerNowCapability (FALSE,           // Don't force service to be up
                                                   NULL))           // Don't care about device id 
    {
        //
        // Answer Now option is valid
        //
        g_bAnswerNow      = TRUE;
        bButtonEnable   = TRUE;
        dwButtonTitleID = IDS_BUTTON_ANSWER;
    }
    else if((FAX_SENDING == g_devState || 
             FAX_RECEIVING == g_devState) 
             && 
            (IsUserGrantedAccess(FAX_ACCESS_SUBMIT)         || 
             IsUserGrantedAccess(FAX_ACCESS_SUBMIT_NORMAL)  ||
             IsUserGrantedAccess(FAX_ACCESS_SUBMIT_HIGH)    ||
             IsUserGrantedAccess(FAX_ACCESS_MANAGE_JOBS)))
    {
        //
        // Fax in progress
        //
        bButtonEnable   = TRUE;
        dwButtonTitleID = IDS_BUTTON_DISCONNECT;
    }

    EnableWindow(g_hDisconnect, bButtonEnable);

    if (ERROR_SUCCESS  == LoadAndFormatString (dwButtonTitleID, tszButtonTitle, ARR_SIZE(tszButtonTitle)))
    {
        SetWindowText(g_hDisconnect, tszButtonTitle);
    }
    else
    {
        ASSERTION_FAILURE;
    }
    //
    // Animation
    //
    DWORD dwAnimationId = IDR_FAX_IDLE;
    switch(g_devState)
    {
        case FAX_IDLE:
            dwAnimationId = IDR_FAX_IDLE;
            break;
        case FAX_RINGING:
            dwAnimationId = IDR_FAX_RINGING;
            break;
        case FAX_SENDING:
            dwAnimationId = IDR_FAX_SEND;
            break;
        case FAX_RECEIVING:
            dwAnimationId = IDR_FAX_RECEIVE;
            break;
    }

    if(g_dwCurrentAnimationId != dwAnimationId)
    {
        if(!Animate_OpenEx(g_hAnimation, g_hModule, MAKEINTRESOURCE(dwAnimationId)))
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("Animate_Open"), 0);
        }
        else
        {
            if(!Animate_Play(g_hAnimation, 0, -1, -1))
            {
                CALL_FAIL (WINDOW_ERR, TEXT ("Animate_Play"), 0);
            }
            else
            {
                g_dwCurrentAnimationId = dwAnimationId;
            }
        }
    }
    // 
    // Status
    //
    if(FAX_IDLE != g_devState)         // Non-idle state and
    {
        if(!SetWindowText(g_hStatus, g_tszLastEvent))
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
        }
    }
    else // idle
    {
        DWORD dwStrId = IDS_FAX_READY;
        TCHAR tszReady[MAX_PATH];

        if(g_ConfigOptions.bSend && 
          (g_ConfigOptions.bReceive || g_ConfigOptions.dwManualAnswerDeviceId == g_ConfigOptions.dwMonitorDeviceId))
        {
            dwStrId = IDS_READY_TO_SND_AND_RCV;
        }
        else if(g_ConfigOptions.bSend)
        {
            dwStrId = IDS_READY_TO_SND;
        }
        else if(g_ConfigOptions.bReceive || g_ConfigOptions.dwManualAnswerDeviceId == g_ConfigOptions.dwMonitorDeviceId)
        {
            dwStrId = IDS_READY_TO_RCV;
        }

        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwStrId, tszReady, ARR_SIZE(tszReady))))
        {
            return dwRes;
        }
        if(!SetWindowText(g_hStatus, tszReady))
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
        }
    }
    //
    // to/from
    //
    TCHAR tszToFrom[MAX_PATH] = {0};
    if(FAX_SENDING == g_devState || FAX_RECEIVING == g_devState)
    {
        LPCTSTR lpctstrAddressParam = NULL;
        DWORD  dwStringResId = (FAX_SENDING == g_devState) ? IDS_SENDING : IDS_RECEIVING;
        if(_tcslen(g_szRemoteId))
        {
            //
            // Remote ID is known
            //
            lpctstrAddressParam = g_szRemoteId;
            dwStringResId = (FAX_SENDING == g_devState) ? IDS_SENDING_TO : IDS_RECEIVING_FROM;
        }
        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwStringResId, 
                                                           tszToFrom, 
                                                           ARR_SIZE(tszToFrom),
                                                           lpctstrAddressParam)))
        {
            return dwRes;
        }
    }
    if(!SetWindowText(g_hToFrom, tszToFrom))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
    }
    //
    // Details log list
    // 
    if(ListView_GetItemCount(g_hListDetails) == 0)
    {
        //
        // Log is empty - fill it with list data
        //
        ASSERTION (g_lstEvents.size() <= MAX_EVENT_LIST_SIZE);
        for (EVENTS_LIST::iterator it = g_lstEvents.begin(); it != g_lstEvents.end(); ++it)
        {
            EVENT_ENTRY &Event = *it;
            AddEventToView(&Event);
        }
    }

    if(!CheckDlgButton(hDlg, IDC_ALWAYS_ON_TOP, g_bTopMost ? BST_CHECKED : BST_UNCHECKED))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("CheckDlgButton(IDC_ALWAYS_ON_TOP)"), dwRes);
    }

    OnAlwaysOnTop(hDlg);

    return dwRes;
} // UpdateMonitorData


void  
OnDetailsButton(
    HWND hDlg,
    BOOL bDetails
)
/*++

Routine description:

  Show/Hide event log and change the details button text 
  according to bDetails value

Arguments:

  hDlg          [in] - fax monitor dialog handle
  bDetails      [in] - new details state
    
Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnDetailsButton"));

    if(!hDlg)
    {
        ASSERTION (FALSE);
        return;
    }

    //
    // Show/Hide the event log
    //
    RECT rc;
    GetWindowRect(hDlg, &rc);

    BOOL bLogOpened = (rc.bottom - rc.top > g_dwDlgHeight - g_dwHeightDelta/2);
    //
    // If the current dialog heigh more then 
    // dlialog heigh with open log minus half log heigh
    // we suppose that the log is opened.
    // This done due to different dialog size in the high contrast mode.
    //
    if(bLogOpened != bDetails)
    {
        //
        // Current log state does not fit the new state
        //
        rc.bottom += g_dwHeightDelta * (bDetails ? 1 : -1);
        MoveWindow(hDlg, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);
    }

    //
    // Set More/Less button text
    //
    TCHAR tszButtonText[MAX_PATH];
    if (ERROR_SUCCESS != LoadAndFormatString (bDetails ? IDS_BUTTON_LESS : IDS_BUTTON_MORE, 
                                              tszButtonText,
                                              ARR_SIZE(tszButtonText)))
    {
        return;
    }

    if(!SetDlgItemText(hDlg, IDC_DETAILS, tszButtonText))
    {
        CALL_FAIL (WINDOW_ERR, TEXT ("SetDlgItemText"), GetLastError());
    }

} // OnDetailsButton

void  
OnAlwaysOnTop(
    HWND hDlg
)
/*++

Routine description:

    Change monitor "on top" state and save it to the registry

Arguments:

  hDlg          [in] - fax monitor dialog handle
    
Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnAlwaysOnTop"));

    if(!hDlg)
    {
        ASSERTION (FALSE);
        return;
    }

    g_bTopMost = (IsDlgButtonChecked(hDlg, IDC_ALWAYS_ON_TOP) == BST_CHECKED) ? 1:0;
    DWORD dwRes;

    if(!SetWindowPos(hDlg,
                     g_bTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,
                     0,
                     0,
                     0,
                     0,
                     SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowPos"), dwRes);
    }

    HKEY  hKey;
    dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_WRITE, &hKey);
    if (ERROR_SUCCESS == dwRes) 
    {
        dwRes = RegSetValueEx(hKey, REGVAL_ALWAYS_ON_TOP, 0, REG_DWORD, (CONST BYTE*)&g_bTopMost, sizeof(g_bTopMost));
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("RegSetValueEx(REGVAL_ALWAYS_ON_TOP)"), dwRes);
        }
    
        RegCloseKey( hKey );
    }
    else
    {
        CALL_FAIL (WINDOW_ERR, TEXT ("RegOpenKeyEx"), dwRes);
    }
} // OnAlwaysOnTop

void
SetStatusMonitorDeviceState(
    DeviceState devState
)
/*++

Routine description:

    Change device state
    Start/stop elapsed timer

Arguments:

    devState  - [in] device state

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("SetStatusMonitorDeviceState"), dwRes);

    if(g_devState != devState)
    {
        //
        // State has changed
        //
        if(g_nElapsedTimerId)
        {
            //
            // Old timer exists
            //
            if(!KillTimer(NULL, g_nElapsedTimerId))
            {
                dwRes = GetLastError();
                CALL_FAIL (WINDOW_ERR, TEXT ("KillTimer"), dwRes);
            }
            g_nElapsedTimerId = 0;
        }
    }

    if(!g_nElapsedTimerId && (devState == FAX_SENDING || devState == FAX_RECEIVING))
    {
        //
        // We need to count elapsed time for send / receive states.
        //
        g_dwStartTime = GetTickCount();

        g_nElapsedTimerId = SetTimer(NULL, 0, DURATION_TIMER_RESOLUTION, ElapsedTimerProc);
        if(!g_nElapsedTimerId)
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetTimer"), dwRes);
        }
    }

    g_devState = devState;

    UpdateMonitorData(g_hMonitorDlg);
}   // SetStatusMonitorDeviceState


VOID 
CALLBACK 
ElapsedTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
/*++

Routine description:

    Timer precedure to update elapsed time value

Arguments:

  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("ElapsedTimerProc"));

    if(!g_hElapsedTime)
    {
        return;
    }

    TCHAR  tszTime[MAX_PATH] = {0};
    TCHAR  tszTimeFormat[MAX_PATH] = {0};

    DWORD dwRes;

    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_ELAPSED_TIME, tszTimeFormat, ARR_SIZE(tszTimeFormat))))
    {
        return;
    }

    DWORD dwElapsedTime = (GetTickCount() - g_dwStartTime)/1000;

    _sntprintf(tszTime, 
               ARR_SIZE(tszTime) - 1, 
               tszTimeFormat, 
               dwElapsedTime/60,
               g_tszTimeSeparator,
               dwElapsedTime%60);
    
    if(!SetWindowText(g_hElapsedTime, tszTime))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
    }
}   // ElapsedTimerProc


DWORD 
LoadAndFormatString (
    IN  DWORD     dwStringResourceId,
    OUT LPTSTR    lptstrFormattedString,
    IN  DWORD     dwOutStrSize,
    IN  LPCTSTR   lpctstrAdditionalParam /* = NULL */
)
/*++

Routine name : LoadAndFormatString

Routine description:

    Loads a string from the resource and optionally formats it with another string

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    dwStringResourceId     [in]     - String resource id
    lptstrFormattedString  [out]    - Result buffer. Must be at least MAX_PATH charactes long.
    dwOutStrSize           [in]     - size of lptstrFormattedString in TCHARs
    lpctstrAdditionalParam [in]     - Optional string paramter.
                                      If non-NULL, this loaded strings is used as a format specifier (sprintf-like) to
                                      format this additional string.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("LoadAndFormatString"), 
              dwRes, 
              TEXT("ResourceId=%d, Param=%s"),
              dwStringResourceId,
              lpctstrAdditionalParam);

    ASSERTION (lptstrFormattedString && dwStringResourceId);

    TCHAR tszString[MAX_PATH] = {0};

    if (!LoadString(g_hResource, dwStringResourceId, tszString, ARR_SIZE(tszString)-1))
    {
        dwRes = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadString"), dwRes);
        return dwRes;
    }
    if (lpctstrAdditionalParam)
    {
        _sntprintf(lptstrFormattedString, 
                   dwOutStrSize - 1,
                   tszString, 
                   lpctstrAdditionalParam);
		lptstrFormattedString[dwOutStrSize -1] = _T('\0');

    }
    else
    {
        lstrcpyn (lptstrFormattedString, tszString, dwOutStrSize - 1);
    }
    return dwRes;
}   // LoadAndFormatString

DWORD 
AddStatusMonitorLogEvent (
    IN  eIconType eIcon,
    IN  DWORD     dwStringResourceId,
    IN  LPCTSTR   lpctstrAdditionalParam /* = NULL */,
    OUT LPTSTR    lptstrFormattedEvent /* = NULL */,
    IN  DWORD     dwOutStrSize /* = 0 */
)
/*++

Routine name : AddStatusMonitorLogEvent

Routine description:

    Adds a status monitor event log line

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    eIcon                  [in]  - Icon to display in log entry
    dwStringResourceId     [in]  - String resource id to use
    lpctstrAdditionalParam [in]  - Optional string. If non-NULL, the string loaded from dwStringResourceId
                                   is used to format the additional parameter.
    lptstrFormattedEvent   [out] - Optional, if non-NULL, points to a buffer to receive the final status string.
                                   Buffer must be at least MAX_PATH characters long.
    dwOutStrSize           [in]  - Optional size of lptstrFormattedEvent in TCHARs

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddStatusMonitorLogEvent"), 
              dwRes, 
              TEXT("Icon=%d, ResourceId=%d, Param=%s"),
              eIcon,
              dwStringResourceId,
              lpctstrAdditionalParam);
    
    TCHAR tszStatus[MAX_PATH * 2] = {0};
    dwRes = LoadAndFormatString (dwStringResourceId, tszStatus, ARR_SIZE(tszStatus), lpctstrAdditionalParam);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    if (lptstrFormattedEvent)
    {
        lstrcpyn (lptstrFormattedEvent, tszStatus, dwOutStrSize - 1);
    }
    dwRes = AddStatusMonitorLogEvent (eIcon, tszStatus);
    return dwRes;
}   // AddStatusMonitorLogEvent


DWORD 
AddStatusMonitorLogEvent (
    eIconType  eIcon,
    LPCTSTR    lpctstrString
)
/*++

Routine description:

    Add new event to the event list

Arguments:
    
    eIcon         - [in] icon index
    lpctstrString - [in] event description

Return Value:

    standard error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddStatusMonitorLogEvent"), 
              dwRes, 
              TEXT("Icon=%d, Status=%s"),
              eIcon,
              lpctstrString);

    TCHAR tszTime [MAX_PATH] = {0};

    ASSERTION (lpctstrString);

    static TCHAR tszRinging[MAX_PATH] = {0};

    if(_tcslen(tszRinging) == 0)
    {
        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_RINGING, tszRinging, ARR_SIZE(tszRinging))))
        {
            ASSERTION_FAILURE;
            return dwRes;
        }
    }

    if(_tcscmp(lpctstrString, g_tszLastEvent) == 0 &&
       _tcscmp(lpctstrString, tszRinging)     != 0)
    {
        //
        // Do not display the same string twice
        // except "Ringing"
        //
        return dwRes;
    }

    EVENT_ENTRY Event;
    Event.eIcon = eIcon;

    SYSTEMTIME sysTime;
    GetLocalTime(&sysTime);
    if(!FaxTimeFormat(LOCALE_USER_DEFAULT, 0, &sysTime, NULL, Event.tszTime, ARR_SIZE(Event.tszTime) - 1))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("FaxTimeFormat"), dwRes);
        return dwRes;
    }

    lstrcpyn (Event.tszEvent, lpctstrString, ARR_SIZE(Event.tszEvent) - 1);
    lstrcpyn (g_tszLastEvent, lpctstrString, ARR_SIZE(g_tszLastEvent) - 1);

    try
    {
        g_lstEvents.push_back (Event);
        if (g_lstEvents.size() > MAX_EVENT_LIST_SIZE)
        {
            //
            // We exceeded the maximal size we permit - remove the most ancient entry
            //
            g_lstEvents.pop_front ();
        }
    }
    catch (exception &ex)
    {
        VERBOSE (MEM_ERR, 
                 TEXT("Got an STL exception while handling with event list (%S)"),
                 ex.what());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    AddEventToView(&Event);
    dwRes = UpdateMonitorData(g_hMonitorDlg);
    return dwRes;
} // AddStatusMonitorLogEvent

void
AddEventToView(
    PEVENT_ENTRY pEvent
)
/*++

Routine description:

    Add event to the list view

Arguments:
    
      pEvent - event data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("AddEventToView"));
    ASSERTION (pEvent);

    if(!g_hListDetails)
    {
        return;
    }

    LV_ITEM lvi = {0};
    DWORD dwItem;

    lvi.pszText  = pEvent->tszTime ? pEvent->tszTime : TEXT("");
    lvi.iItem    = ListView_GetItemCount( g_hListDetails );
    lvi.iSubItem = 0;
    lvi.mask     = LVIF_TEXT | LVIF_IMAGE;
    lvi.iImage   = pEvent->eIcon;

    dwItem = ListView_InsertItem( g_hListDetails, &lvi );

    lvi.pszText  = pEvent->tszEvent ? pEvent->tszEvent : TEXT("");
    lvi.iItem    = dwItem;
    lvi.iSubItem = 1;
    lvi.mask     = LVIF_TEXT;
    ListView_SetItem( g_hListDetails, &lvi );

    ListView_EnsureVisible(g_hListDetails, dwItem, FALSE);

    if(ListView_GetItemCount(g_hListDetails) > MAX_EVENT_LIST_SIZE)
    {
        ListView_DeleteItem(g_hListDetails, 0);
    }

    //
    // Autosize the last column to get rid of unnecessary horizontal scroll bar
    //
    ListView_SetColumnWidth(g_hListDetails, 1, LVSCW_AUTOSIZE_USEHEADER); 

} // AddEventToView


DWORD
OpenFaxMonitor(VOID)
/*++

Routine description:

    Opens fax monitor dialog

Arguments:

    none

Return Value:

    Standard error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("OpenFaxMonitor"), dwRes);

    if(!g_hMonitorDlg)
    {
        //
        // Read 'top most' value
        //
        HKEY hKey;

        dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_READ, &hKey);
        if (ERROR_SUCCESS == dwRes) 
        {
            g_bTopMost = GetRegistryDword(hKey, REGVAL_ALWAYS_ON_TOP);
            RegCloseKey( hKey );
        }
        else
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("RegOpenKeyEx"), dwRes);
        }
        //
        // Create the dialog
        //
        g_hMonitorDlg = CreateDialogParam(g_hResource,
                                          MAKEINTRESOURCE(IDD_MONITOR),
                                          NULL, 
                                          FaxMonitorDlgProc,
                                          NULL);
        if(!g_hMonitorDlg)
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("CreateDialogParam"), dwRes);
            return dwRes;
        }
    }
    //
    // Set the focus on the dialog and make it the top window
    //
    SetFocus(g_hMonitorDlg);
    SetActiveWindow(g_hMonitorDlg);
    SetWindowPos(g_hMonitorDlg, 
                 HWND_TOPMOST, 
                 0, 
                 0, 
                 0,
                 0, 
                 SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
    if (!g_bTopMost)
    {
        SetWindowPos(g_hMonitorDlg, 
                     HWND_NOTOPMOST, 
                     0, 
                     0, 
                     0, 
                     0, 
                     SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
    }
    return dwRes;
} // OpenFaxMonitor

void  
OnDisconnect()
/*++

Routine description:

    Abort current transmission 
    OR 
    Answer a call

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("OnDisconnect"), dwRes);

    if(g_bAnswerNow)
    {
        //
        // The button shows 'Answer Now'
        //
        AnswerTheCall();
        return;
    }
    //
    // Else, the button shows 'Disconnect'
    //
    if(!g_dwCurrentJobID)
    {
        //
        // No job - nothing to disconnect
        //
        SetStatusMonitorDeviceState(FAX_IDLE);
        return;
    }

    DWORD dwMsgId = (FAX_SENDING == g_devState) ? IDS_ABORT_SEND_CONFIRM : IDS_ABORT_RECEIVE_CONFIRM;

    if(IDYES != FaxMessageBox(g_hMonitorDlg, dwMsgId, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION))
    {
        return;
    }

    if(!Connect())
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("Connect"), dwRes);
        return;
    }

    FAX_JOB_ENTRY fje = {0};
    fje.SizeOfStruct = sizeof(FAX_JOB_ENTRY);

    if(g_hDisconnect)
    {
        EnableWindow(g_hDisconnect, FALSE);
    }

    if (!FaxSetJob (g_hFaxSvcHandle, g_dwCurrentJobID, JC_DELETE, &fje))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxSetJob"), dwRes);

        if(g_hDisconnect)
        {
            EnableWindow(g_hDisconnect, TRUE);
        }

        if(ERROR_ACCESS_DENIED == dwRes)
        {
            FaxMessageBox(g_hMonitorDlg, IDS_DELETE_ACCESS_DENIED, MB_OK | MB_ICONSTOP);
        }
    }

} // OnDisconnect


void  
OnClearLog()
/*++

Routine description:

    Clear the monitor event log

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnClearLog"));
    ASSERTION (g_hListDetails);    
    try
    {
        g_lstEvents.clear();
    }
    catch (exception &ex)
    {
        VERBOSE (MEM_ERR, 
                 TEXT("Got an STL exception while clearing the events list (%S)"),
                 ex.what());
    }
    if(!ListView_DeleteAllItems(g_hListDetails))
    {
        CALL_FAIL (WINDOW_ERR, TEXT ("ListView_DeleteAllItems"), 0);
    }
} // OnClearLog


int 
FaxMessageBox(
  HWND  hWnd,   
  DWORD dwTextID,
  UINT  uType    
)
/*++

Routine description:

  Open standard message box

Arguments:

  hWnd     - handle to owner window
  dwTextID - text resource ID in message box
  uType    - message box style

Return Value:

    MessageBox() return value

--*/
{
    int iRes;
    DBG_ENTER(TEXT("FaxMessageBox"), iRes);

    TCHAR tsCaption[MAX_PATH];
    TCHAR tsText[MAX_PATH];

    DWORD dwRes;
    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_MESSAGE_BOX_CAPTION, tsCaption, ARR_SIZE(tsCaption))))
    {
        SetLastError (dwRes);
        iRes = 0;
        return iRes;
    }

    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwTextID, tsText, ARR_SIZE(tsText))))
    {
        SetLastError (dwRes);
        iRes = 0;
        return iRes;
    }
    iRes = AlignedMessageBox(hWnd, tsText, tsCaption, uType);
    return iRes;
}   // FaxMessageBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\systray\fxsst.cpp ===
/**

Copyright (c)  Microsoft Corporation 1999-2000

Module Name:

    fxsst.cpp

Abstract:

    This module implements the tray icon for fax.
    The purpose of the tray icon is to provide
    status and feedback to the fax user.

**/
 
#include <windows.h>
#include <faxreg.h>
#include <fxsapip.h>
#include <faxutil.h>
#include <shellapi.h>
#include <winspool.h>
#include <shlobj.h>
#include <Mmsystem.h>
#include <tchar.h>
#include <DebugEx.h>
#include <FaxRes.h>

#include "monitor.h"
#include "resource.h"

////////////////////////////////////////////////////////////
// Global data
//

//
// The following message ids are used for internal custom messages.
//
#define WM_FAX_STARTED         (WM_USER + 204)      // Message indicating the loca fax service is up and running
#define WM_TRAYCALLBACK        (WM_USER + 205)      // Notification bar icon callback message
#define WM_FAX_EVENT           (WM_USER + 300)      // Fax extended event message

#define TRAY_ICON_ID            12345   // Unique enough

HINSTANCE g_hModule = NULL;                     // DLL Global instance
HINSTANCE g_hResource = NULL;                   // Resource DLL handle
                       
HANDLE    g_hFaxSvcHandle = NULL;               // Handle to the fax service (from FaxConnectFaxServer)
DWORDLONG g_dwlCurrentMsgID = 0;                // ID of current message being monitored
DWORD     g_dwCurrentJobID  = 0;                // ID of current queue job being monitored
HANDLE    g_hServerStartupThread = NULL;        // Handle of thread which waits for the server startup event
HANDLE    g_hStopStartupThreadEvent = NULL;     // Event for stop Server Startup Thread
BOOL      g_bShuttingDown = FALSE;              // Are we shutting down now?
                                                
HWND      g_hWndFaxNotify = NULL;               // Local (hidden) window handle
                                                
HANDLE    g_hNotification = NULL;               // Fax extended notification handle
                                                
HCALL     g_hCall = NULL;                       // Handle to call (from FAX_EVENT_TYPE_NEW_CALL)
DWORDLONG g_dwlNewMsgId;                        // ID of the last incoming fax
DWORDLONG g_dwlSendFailedMsgId;                 // ID of the last outgoing failed fax
DWORDLONG g_dwlSendSuccessMsgId;                // ID of the last successfully sent fax

TCHAR     g_szAddress[MAX_PATH] = {0};   // Current caller ID or recipient number
TCHAR     g_szRemoteId[MAX_PATH] = {0};  // Sender ID or Recipient ID
                                                //
                                                // Sender ID (receive):
                                                //      TSID or
                                                //      Caller ID or
                                                //      "unknown caller"
                                                //
                                                // Recipient ID (send):
                                                //      Recipient name or
                                                //      CSID or
                                                //      Recipient phone number.
                                                //

BOOL   g_bRecipientNameValid = FALSE;     // TRUE if the g_szRecipientName has valid data
TCHAR  g_szRecipientName[MAX_PATH] = {0}; // Keep the recipient name during sending

//
// Configuration options - read from the registry / Service
// Default values are set here.
//
CONFIG_OPTIONS g_ConfigOptions = {0};

//
// Notification bar icon states
//
typedef 
enum 
{
    ICON_RINGING=0,             // Device is ringing
    ICON_SENDING,               // Device is sending
    ICON_RECEIVING,             // Device is receiving  
    ICON_SEND_FAILED,           // Send operation failed
    ICON_RECEIVE_FAILED,        // Receive operation failed
    ICON_NEW_FAX,               // New unread fax
    ICON_SEND_SUCCESS,          // Send was successful
    ICON_IDLE,                  // Don't display an icon
    ICONS_COUNT                 // Number of icons we support                   
} eIconState;

eIconState g_CurrentIcon = ICONS_COUNT;     // The index of the currently displayed icon

#define TOOLTIP_SIZE            128   // Number of characters in the tooltip

struct SIconState
{
    BOOL    bEnable;                        // Is the state active? (e.g. are there any new unread faxes?)
    DWORD   dwIconResId;                    // Resource id of the icon to use
    HICON   hIcon;                          // Handle to icon to use
    LPCTSTR pctsSound;                      // Name of sound event
    TCHAR   tszToolTip[TOOLTIP_SIZE];       // Text to display in icon tooltip
    DWORD   dwBalloonTimeout;               // Timeout of balloon (millisecs)
    DWORD   dwBalloonIcon;                  // The icon to display in the balloon. (see NIIF_* constants)
};

//
// Fax notification icon state array.
// Several states may have the bEnable flag on.
// The array is sorted by priority and EvaluateIcon() scans it looking
// for the first active state.
//
SIconState g_Icons[ICONS_COUNT] = 
{
    {FALSE, IDI_RINGING_1,      NULL, TEXT("FaxLineRings"), TEXT(""), 30000, NIIF_INFO},    // ICON_RINGING   
    {FALSE, IDI_SENDING,        NULL, TEXT(""),             TEXT(""),     0, NIIF_INFO},    // ICON_SENDING
    {FALSE, IDI_RECEIVING,      NULL, TEXT(""),             TEXT(""),     0, NIIF_INFO},    // ICON_RECEIVING
    {FALSE, IDI_SEND_FAILED,    NULL, TEXT("FaxError"),     TEXT(""), 15000, NIIF_WARNING}, // ICON_SEND_FAILED    
    {FALSE, IDI_RECEIVE_FAILED, NULL, TEXT("FaxError"),     TEXT(""), 15000, NIIF_WARNING}, // ICON_RECEIVE_FAILED 
    {FALSE, IDI_NEW_FAX,        NULL, TEXT("FaxNew"),       TEXT(""), 15000, NIIF_INFO},    // ICON_NEW_FAX        
    {FALSE, IDI_SEND_SUCCESS,   NULL, TEXT("FaxSent"),      TEXT(""), 10000, NIIF_INFO},    // ICON_SEND_SUCCESS   
    {FALSE, IDI_FAX_NORMAL,     NULL, TEXT(""),             TEXT(""),     0, NIIF_NONE}     // ICON_IDLE
};

//
// Icons array for ringing animation
//
struct SRingIcon
{
    HICON   hIcon;          // Handle to loaded icon
    DWORD   dwIconResId;    // Resource ID of icon  
};

#define RING_ICONS_NUM                  4   // Number of frames (different icons) in ringing animation  
#define RING_ANIMATION_FRAME_DELAY    300   // Delay (millisecs) between ring animation frames
#define RING_ANIMATION_TIMEOUT      10000   // Timeout (millisecs) of ring animation. When the timeout expires, the animation
                                            // stops and the icon becomes static.

SRingIcon g_RingIcons[RING_ICONS_NUM] = 
{
    NULL, IDI_RINGING_1, 
    NULL, IDI_RINGING_2, 
    NULL, IDI_RINGING_3, 
    NULL, IDI_RINGING_4 
};

UINT_PTR  g_uRingTimerID = 0;           // Timer of ringing animation
DWORD     g_dwCurrRingIconIndex = 0;    // Index of current frame (into g_RingIcons)
DWORD     g_dwRingAnimationStartTick;   // Tick count (time) of animation start

#define MAX_BALLOON_TEXT_LEN     256    // Max number of character in balloon text
#define MAX_BALLOON_TITLE_LEN     64    // Max number of character in balloon title

struct SBalloonInfo
{
    BOOL        bEnable;                            // This flag is set when there's a need to display some balloon.
                                                    // EvaluateIcon() detects this bit, asks for a balloon and turns the bit off.
    BOOL        bDelete;                            // This flag is set when there's a need to destroy some balloon.
    eIconState  eState;                             // The current state of the icon
    TCHAR       szInfo[MAX_BALLOON_TEXT_LEN];       // The text to display on the balloon
    TCHAR       szInfoTitle[MAX_BALLOON_TITLE_LEN]; // The title to display on the balloon
};

BOOL g_bIconAdded = FALSE;                      // Do we have an icon on the status bar?
SBalloonInfo  g_BalloonInfo = {0};              // The current icon + ballon state

struct EVENT_INFO
{
    DWORD     dwExtStatus;      // Extended status code
    UINT      uResourceId;      // String for display
    eIconType eIcon;
};

static const EVENT_INFO g_StatusEx[] =
{
    JS_EX_DISCONNECTED,         IDS_FAX_DISCONNECTED,       LIST_IMAGE_ERROR,
    JS_EX_INITIALIZING,         IDS_FAX_INITIALIZING,       LIST_IMAGE_NONE,
    JS_EX_DIALING,              IDS_FAX_DIALING,            LIST_IMAGE_NONE,
    JS_EX_TRANSMITTING,         IDS_FAX_SENDING,            LIST_IMAGE_NONE,
    JS_EX_ANSWERED,             IDS_FAX_ANSWERED,           LIST_IMAGE_NONE,
    JS_EX_RECEIVING,            IDS_FAX_RECEIVING,          LIST_IMAGE_NONE,
    JS_EX_LINE_UNAVAILABLE,     IDS_FAX_LINE_UNAVAILABLE,   LIST_IMAGE_ERROR,
    JS_EX_BUSY,                 IDS_FAX_BUSY,               LIST_IMAGE_WARNING,
    JS_EX_NO_ANSWER,            IDS_FAX_NO_ANSWER,          LIST_IMAGE_WARNING,
    JS_EX_BAD_ADDRESS,          IDS_FAX_BAD_ADDRESS,        LIST_IMAGE_ERROR,
    JS_EX_NO_DIAL_TONE,         IDS_FAX_NO_DIAL_TONE,       LIST_IMAGE_ERROR,
    JS_EX_FATAL_ERROR,          IDS_FAX_FATAL_ERROR_SND,    LIST_IMAGE_ERROR,
    JS_EX_CALL_DELAYED,         IDS_FAX_CALL_DELAYED,       LIST_IMAGE_ERROR,   
    JS_EX_CALL_BLACKLISTED,     IDS_FAX_CALL_BLACKLISTED,   LIST_IMAGE_ERROR,
    JS_EX_NOT_FAX_CALL,         IDS_FAX_NOT_FAX_CALL,       LIST_IMAGE_ERROR,
    JS_EX_PARTIALLY_RECEIVED,   IDS_FAX_PARTIALLY_RECEIVED, LIST_IMAGE_WARNING,
    JS_EX_CALL_COMPLETED,       IDS_FAX_CALL_COMPLETED,     LIST_IMAGE_NONE,
    JS_EX_CALL_ABORTED,         IDS_FAX_CALL_ABORTED,       LIST_IMAGE_NONE,
    0,                          0,                          LIST_IMAGE_NONE
};

/////////////////////////////////////////////////////////////////////
// Function prototypes
//
BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, void* lpReserved);

void   GetConfiguration();

DWORD WaitForRestartThread(LPVOID  ThreadData);
VOID  WaitForFaxRestart(HWND hWnd);

LRESULT CALLBACK NotifyWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

BOOL Connect();

BOOL RegisterForServerEvents();
VOID OnFaxEvent(FAX_EVENT_EX *pEvent);

VOID OnNewCall (const FAX_EVENT_NEW_CALL &NewCall);
VOID StatusUpdate (PFAX_JOB_STATUS pStatus);
BOOL GetStatusEx(PFAX_JOB_STATUS pStatus, eIconType* peIcon, TCHAR* ptsStatusEx, DWORD dwSize);
BOOL IsUserGrantedAccess(DWORD);

void EvaluateIcon();
void SetIconState(eIconState eIcon, BOOL bEnable, TCHAR* ptsStatus = NULL);

VOID AnswerTheCall();
VOID InvokeClientConsole();
VOID DoFaxContextMenu(HWND hwnd);
VOID OnTrayCallback (HWND hwnd, WPARAM wp, LPARAM lp);
VOID CALLBACK RingTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
VOID OnDeviceRing(DWORD dwDeviceID);
VOID InitGlobals ();
VOID GetRemoteId(PFAX_JOB_STATUS pStatus);
BOOL InitModule ();
BOOL DestroyModule ();
DWORD CheckAnswerNowCapability (BOOL bForceReconnect, LPDWORD lpdwDeviceId /* = NULL */);
VOID FaxPrinterProperties(DWORD dwPage);
VOID CopyLTRString(TCHAR* szDest, LPCTSTR szSource, DWORD dwSize);

//////////////////////////////////////////////////////////////////////
// Implementation
//

extern "C"
BOOL
FaxMonitorShutdown()
{
    g_bShuttingDown = TRUE;
    return DestroyModule();
}   // FaxMonitorShutdown

extern "C"
BOOL
IsFaxMessage(
    PMSG pMsg
)
/*++

Routine name : IsFaxMessage

Routine description:

    Fax message handle 

Arguments:

    pMsg - pointer to a message

Return Value:

    TRUE if the message was handled
    FALSE otherwise

--*/
{
    BOOL bRes = FALSE;

    if(g_hMonitorDlg)
    {
        bRes = IsDialogMessage(g_hMonitorDlg, pMsg);
    }
    return bRes;

} // IsFaxMessage

VOID 
InitGlobals ()
/*++

Routine name : InitGlobals

Routine description:

    Initializes all server connection related global variables

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("InitGlobals"));
                                               
    g_hFaxSvcHandle   = NULL;
    g_dwlCurrentMsgID = 0;
    g_dwCurrentJobID  = 0;
    g_hNotification   = NULL;
    g_hCall           = NULL;
    g_szAddress[0]    = TEXT('\0');
    g_szRemoteId[0]   = TEXT('\0');

    g_bRecipientNameValid = FALSE;
    g_szRecipientName[0]  = TEXT('\0');     

    BOOL bDesktopSKU = IsDesktopSKU();

    g_ConfigOptions.dwMonitorDeviceId      = 0;
    g_ConfigOptions.bSend                  = FALSE;
    g_ConfigOptions.bReceive               = FALSE;
    g_ConfigOptions.dwManualAnswerDeviceId = 0;
    g_ConfigOptions.dwAccessRights         = 0;   
    g_ConfigOptions.bNotifyProgress        = bDesktopSKU;  
    g_ConfigOptions.bNotifyInCompletion    = bDesktopSKU; 
    g_ConfigOptions.bNotifyOutCompletion   = bDesktopSKU; 
    g_ConfigOptions.bMonitorOnSend         = bDesktopSKU; 
    g_ConfigOptions.bMonitorOnReceive      = bDesktopSKU; 
    g_ConfigOptions.bSoundOnRing           = bDesktopSKU; 
    g_ConfigOptions.bSoundOnReceive        = bDesktopSKU; 
    g_ConfigOptions.bSoundOnSent           = bDesktopSKU; 
    g_ConfigOptions.bSoundOnError          = bDesktopSKU; 

    for (DWORD dw = 0; dw < ICONS_COUNT; dw++)
    {
        g_Icons[dw].bEnable = FALSE;
        g_Icons[dw].tszToolTip[0] = TEXT('\0');
    }

    g_uRingTimerID                  = 0;
    g_dwCurrRingIconIndex           = 0;
    g_dwRingAnimationStartTick      = 0;
    g_BalloonInfo.bEnable           = FALSE;
    g_BalloonInfo.bDelete           = FALSE;
    g_BalloonInfo.szInfo[0]         = TEXT('\0');
    g_BalloonInfo.szInfoTitle[0]    = TEXT('\0');
    g_CurrentIcon                   = ICONS_COUNT;
}   // InitGlobals

BOOL
InitModule ()
/*++

Routine name : InitModule

Routine description:

	Initializes the DLL module. Call only once.

Author:

	Eran Yariv (EranY),	Mar, 2001

Arguments:


Return Value:

    TRUE on success

--*/
{
    BOOL    bRes = FALSE;
    DWORD   dwRes;
    DBG_ENTER(TEXT("InitModule"), bRes);

    InitGlobals ();
    //
    // Don't have DllMain called for thread inits and shutdown.
    //
    DisableThreadLibraryCalls(g_hModule);
    //
    // Load icons
    //
    for(DWORD dw=0; dw < ICONS_COUNT; ++dw)
    {
        g_Icons[dw].hIcon = LoadIcon(g_hModule, MAKEINTRESOURCE(g_Icons[dw].dwIconResId));
        if(!g_Icons[dw].hIcon)
        {
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadIcon"), dwRes);
            bRes = FALSE;
            return bRes;
        }
    }
    //
    // Load animation icons
    //
    for(dw=0; dw < RING_ICONS_NUM; ++dw)
    {
        g_RingIcons[dw].hIcon = LoadIcon(g_hModule, MAKEINTRESOURCE(g_RingIcons[dw].dwIconResId));
        if(!g_RingIcons[dw].hIcon)
        {
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadIcon"), dwRes);
            bRes = FALSE;
            return bRes;
        }
    }
    //
    // Load "new fax" tooltip
    //
    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_NEW_FAX, g_Icons[ICON_NEW_FAX].tszToolTip, TOOLTIP_SIZE)))
    {
        SetLastError (dwRes);
        bRes = FALSE;
        return bRes;
    }
    //
    // Register our hidden window and create it
    //
    WNDCLASSEX  wndclass = {0};

    wndclass.cbSize         = sizeof(wndclass);
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = NotifyWndProc;
    wndclass.hInstance      = g_hModule;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    wndclass.lpszClassName  = FAXSTAT_WINCLASS;

    if(!RegisterClassEx(&wndclass))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("RegisterClassEx"), dwRes);
        bRes = FALSE;
        return bRes;
    }

    g_hWndFaxNotify = CreateWindow (FAXSTAT_WINCLASS, 
                                    TEXT("HiddenFaxWindow"),
                                    0, 
                                    CW_USEDEFAULT, 
                                    0, 
                                    CW_USEDEFAULT, 
                                    0,
                                    NULL, 
                                    NULL, 
                                    g_hModule, 
                                    NULL);
    if(!g_hWndFaxNotify)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("CreateWindow"), dwRes);
        bRes = FALSE;
        return bRes;
    }
    //
    // Create stop thread event
    //
    g_hStopStartupThreadEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if(!g_hStopStartupThreadEvent)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("CreateEvent"), dwRes);
        bRes = FALSE;
        return bRes;
    }
    //
    // Launch a thread which waits for the local fax service startup event.
    // When the event is set, the thread posts WM_FAX_STARTED to our hidden window.
    //
    WaitForFaxRestart(g_hWndFaxNotify);
    bRes = TRUE;
    return bRes;
}   // InitModule

DWORD 
WaitForBackgroundThreadToDie ()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("WaitForBackgroundThreadToDie"), dwRes);

    ASSERTION (g_hServerStartupThread);

    DWORD dwWaitRes = WaitForSingleObject (g_hServerStartupThread, INFINITE);
    switch (dwWaitRes)
    {
        case WAIT_OBJECT_0:
            //
            // Thread terminated - hooray
            //
            VERBOSE (DBG_MSG, TEXT("Background thread terminated successfully"));
            CloseHandle (g_hServerStartupThread);
            g_hServerStartupThread = NULL;
            break;

        case WAIT_FAILED:
            //
            // Error waiting for thread to die
            //
            dwRes = GetLastError ();
            VERBOSE (DBG_MSG, TEXT("Can't wait for background thread: %ld"), dwRes);
            break;

        default:
            //
            // No other return value from WaitForSingleObject is valid
            //
            ASSERTION_FAILURE;
            dwRes = ERROR_GEN_FAILURE;
            break;
    }
    return dwRes;
}   // WaitForBackgroundThreadToDie

BOOL
DestroyModule ()
/*++

Routine name : DestroyModule

Routine description:

	Destroys the DLL module. Call only once.

Author:

	Eran Yariv (EranY),	Mar, 2001

Arguments:


Return Value:

    TRUE on success

--*/
{
    BOOL    bRes = FALSE;
    DBG_ENTER(TEXT("DestroyModule"), bRes);

    //
    // Prepare for shutdown - destroy all active windows
    //
    if (g_hMonitorDlg)
    {
        //
        // Fake 'hide' key press on the monitor dialog
        //
        SendMessage (g_hMonitorDlg, WM_COMMAND, IDCANCEL, 0);
    }
    //
    // Delete the system tray icon if existed
    //
    if (g_bIconAdded)
    {
        NOTIFYICONDATA iconData = {0};

        iconData.cbSize           = sizeof(iconData);
        iconData.hWnd             = g_hWndFaxNotify;
        iconData.uID              = TRAY_ICON_ID;

        Shell_NotifyIcon(NIM_DELETE, &iconData);
        g_bIconAdded = FALSE;
    }
    //
    // Destory this window
    //
    if (!DestroyWindow (g_hWndFaxNotify))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("DestroyWindow"), GetLastError ());
    }
    g_hWndFaxNotify = NULL;
    //
    // Signal the DLL shutdown event
    //
    ASSERTION (g_hStopStartupThreadEvent);
    if (SetEvent (g_hStopStartupThreadEvent))
    {
        VERBOSE (DBG_MSG, TEXT("DLL shutdown event signaled"));
        if (g_hServerStartupThread)
        {
            //
            // Wait for background thread to die
            //
            DWORD dwRes = WaitForBackgroundThreadToDie();
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("WaitForBackgroundThreadToDie"), dwRes);
            }
        }
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SetEvent (g_hStopStartupThreadEvent)"), GetLastError ());
    }
    //
    // Release our DLL shutdown event
    //
    CloseHandle (g_hStopStartupThreadEvent);
    g_hStopStartupThreadEvent = NULL;
    //
    // Free the data of the monitor module
    //
    FreeMonitorDialogData (TRUE);
    //
    // Unregister window class
    //
    if (!UnregisterClass (FAXSTAT_WINCLASS, g_hModule))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("UnregisterClass"), GetLastError ());
    }
    //
    // Unregister from server notifications
    //
    if (g_hNotification)
    {
        if(!FaxUnregisterForServerEvents(g_hNotification))
        {
            CALL_FAIL (RPC_ERR, TEXT("FaxUnregisterForServerEvents"), GetLastError());
        }
        g_hNotification = NULL;
    }
    //
    // Disconnect from the fax service
    //
    if (g_hFaxSvcHandle)
    {
        if (!FaxClose (g_hFaxSvcHandle))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FaxClose"), GetLastError ());
        }
        g_hFaxSvcHandle = NULL;
    }
    //
    // Unload all icons
    //
    for (DWORD dw = 0; dw < ICONS_COUNT; dw++)
    {
        if (g_Icons[dw].hIcon)
        {   
            if (!DestroyIcon (g_Icons[dw].hIcon))
            {
                CALL_FAIL (WINDOW_ERR, TEXT("DestroyIcon"), GetLastError ());
            }
            g_Icons[dw].hIcon = NULL;
        }
    }
    for (DWORD dw = 0; dw < RING_ICONS_NUM; dw++)
    {
        if (g_RingIcons[dw].hIcon)
        {   
            if (!DestroyIcon (g_RingIcons[dw].hIcon))
            {
                CALL_FAIL (WINDOW_ERR, TEXT("DestroyIcon"), GetLastError ());
            }
            g_RingIcons[dw].hIcon = NULL;
        }
    }
    //
    // Kill animation timer
    //
    if(g_uRingTimerID)
    {
        if (!KillTimer(NULL, g_uRingTimerID))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("KillTimer"), GetLastError ());
        }
        g_uRingTimerID = NULL;
    }
    bRes = TRUE;
    return bRes;
}   // DestroyModule

BOOL
WINAPI 
DllMain(
    HINSTANCE hModule, 
    DWORD     dwReason, 
    void*     lpReserved
)
/*++

Routine description:

    Fax notifications startup 

Arguments:

    hinstDLL    - handle to the DLL module
    fdwReason   - reason for calling function
    lpvReserved - reserved

Return Value:

    TRUE if success
    FALSE otherwise

--*/
{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("DllMain"), bRes, TEXT("Reason = %ld"), dwReason);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hModule = hModule;
            g_hResource = GetResInstance(hModule);
            if(!g_hResource)
            {
                return FALSE;
            }

            bRes = InitModule ();
            return bRes;

        case DLL_PROCESS_DETACH:
            //
            // If g_bShuttingDown is not TRUE, someone (STOBJECT.DLL) forgot to call 
            // FaxMonitorShutdown() (our shutdown procedure) before doing FreeLibrary on us. 
            // This is not the way we're supposed to be used - a bug.
            //
            ASSERTION (g_bShuttingDown);
			HeapCleanup();
            FreeResInstance();
            return bRes;

        default:
            return bRes;
    }
} // DllMain


DWORD
WaitForRestartThread(
   LPVOID  ThreadData
)
{
    //
    // Wait for event to be signaled, indicating fax service started
    //
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hKey = NULL;
    HANDLE hEvents[2] = {0};
    DBG_ENTER(TEXT("WaitForRestartThread"), dwRes);

    //
    // NOTICE: Events order in the array matters - we want to detect DLL shutdown BEFORE we detect service startup
    //
    hEvents[0] = g_hStopStartupThreadEvent;

    if (hEvents[1])
    {
        CloseHandle (hEvents[1]);
    }
    if (hKey)
    {
        RegCloseKey (hKey);
    }
    //
    // Obtain service startup event handle.
    // We need to do this every time before calling WaitForMultipleObjects
    // because the event returned from CreateSvcStartEvent is a single-shot event.
    //
    dwRes = CreateSvcStartEvent (&(hEvents[1]), &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateSvcStartEvent"), dwRes);
        goto ExitThisThread;
    }
    //
    // Wait for either the service startup event or the DLL shutdown event
    //
    DWORD dwWaitRes = WaitForMultipleObjects(ARR_SIZE(hEvents), 
                                             hEvents, 
                                             FALSE, 
                                             INFINITE);
    switch (dwWaitRes)
    {
        case WAIT_OBJECT_0 + 1:
            //
            // Service startup event
            //
            VERBOSE (DBG_MSG, TEXT("Service startup event received"));

            PostMessage((HWND) ThreadData, WM_FAX_STARTED, 0, 0);
            break;

        case WAIT_OBJECT_0:
            //
            // Stop thread event - exit thread ASAP.
            //
            VERBOSE (DBG_MSG, TEXT("DLL shutdown event received"));
            break;

        case WAIT_FAILED:
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT("WaitForMultipleObjects"), dwRes);
            break;

        default:
            //
            // No other return value from WaitForMultipleObjects is valid.
            //
            ASSERTION_FAILURE;
            break;

    } // switch (dwWaitRes)


ExitThisThread:

    if (hEvents[1])
    {
        CloseHandle (hEvents[1]);
    }
    if (hKey)
    {
        RegCloseKey (hKey);
    }
    return dwRes;

} // WaitForRestartThread

VOID
WaitForFaxRestart(
    HWND  hWnd
)
{
    DBG_ENTER(TEXT("WaitForFaxRestart"));

    if (g_bShuttingDown)
    {
        //
        // Shutting down - no thread creation allowed
        //
        return;
    }
    if (g_hServerStartupThread)
    {
        //
        // Signal to Startup Thread to stop
        //
        if (!SetEvent (g_hStopStartupThreadEvent))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("SetEvent"), GetLastError());
            return;
        }

        //
        // A Previous thead exists - wait for it to die
        //
        DWORD dwRes = WaitForBackgroundThreadToDie();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("WaitForBackgroundThreadToDie"), dwRes);
            return;
        }
    }

    if (!ResetEvent (g_hStopStartupThreadEvent))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("ResetEvent"), GetLastError());
        return;
    }

    ASSERTION (NULL == g_hServerStartupThread);
    g_hServerStartupThread = CreateThread(NULL, 0, WaitForRestartThread, (LPVOID) hWnd, 0, NULL);
    if (g_hServerStartupThread) 
    {
        VERBOSE (DBG_MSG, TEXT("Background therad created successfully"));
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateThread(WaitForRestartThread)"), GetLastError());
    }
} // WaitForFaxRestart


void
GetConfiguration()
/*++

Routine description:

    Read notification configuration from the registry

Arguments:

    none

Return Value:

  none

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("GetConfiguration"));

    HKEY  hKey;

    if(Connect())
    {
        if (!FaxAccessCheckEx(g_hFaxSvcHandle, MAXIMUM_ALLOWED, &g_ConfigOptions.dwAccessRights))
        {
            dwRes = GetLastError ();
            CALL_FAIL (RPC_ERR, TEXT("FaxAccessCheckEx"), dwRes);
        }
    }
    
    dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_READ, &hKey);
    if (dwRes != ERROR_SUCCESS) 
    {
        //
        // Can't open user information key - use defaults
        //
        CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx(REGKEY_FAX_USERINFO)"), dwRes);
        BOOL bDesktopSKU = IsDesktopSKU();

        g_ConfigOptions.dwMonitorDeviceId      = 0;
        g_ConfigOptions.bNotifyProgress        = bDesktopSKU;  
        g_ConfigOptions.bNotifyInCompletion    = bDesktopSKU; 
        g_ConfigOptions.bNotifyOutCompletion   = bDesktopSKU; 
        g_ConfigOptions.bMonitorOnSend         = bDesktopSKU; 
        g_ConfigOptions.bMonitorOnReceive      = bDesktopSKU; 
        g_ConfigOptions.bSoundOnRing           = bDesktopSKU; 
        g_ConfigOptions.bSoundOnReceive        = bDesktopSKU; 
        g_ConfigOptions.bSoundOnSent           = bDesktopSKU; 
        g_ConfigOptions.bSoundOnError          = bDesktopSKU; 
    }
    else
    {
        GetRegistryDwordEx(hKey, REGVAL_NOTIFY_PROGRESS,     &g_ConfigOptions.bNotifyProgress);
        GetRegistryDwordEx(hKey, REGVAL_NOTIFY_IN_COMPLETE,  &g_ConfigOptions.bNotifyInCompletion);
        GetRegistryDwordEx(hKey, REGVAL_NOTIFY_OUT_COMPLETE, &g_ConfigOptions.bNotifyOutCompletion);
        GetRegistryDwordEx(hKey, REGVAL_MONITOR_ON_SEND,     &g_ConfigOptions.bMonitorOnSend);
        GetRegistryDwordEx(hKey, REGVAL_MONITOR_ON_RECEIVE,  &g_ConfigOptions.bMonitorOnReceive);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_RING,       &g_ConfigOptions.bSoundOnRing);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_RECEIVE,    &g_ConfigOptions.bSoundOnReceive);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_SENT,       &g_ConfigOptions.bSoundOnSent);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_ERROR,      &g_ConfigOptions.bSoundOnError);
        GetRegistryDwordEx(hKey, REGVAL_DEVICE_TO_MONITOR,   &g_ConfigOptions.dwMonitorDeviceId);
        RegCloseKey( hKey );
    }

    g_ConfigOptions.dwManualAnswerDeviceId = 0;

    if(Connect() && IsUserGrantedAccess(FAX_ACCESS_QUERY_CONFIG))
    {
        PFAX_PORT_INFO_EX  pPortsInfo = NULL;
        DWORD              dwPorts = 0;

        if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pPortsInfo, &dwPorts))
        {
            dwRes = GetLastError ();
            CALL_FAIL (RPC_ERR, TEXT("FaxEnumPortsEx"), dwRes);
        }
        else
        {
            if (dwPorts)
            {
                DWORD dwDevIndex = 0;
                for(DWORD dw=0; dw < dwPorts; ++dw)
                {
                    //
                    // Iterate all fax devices
                    //
                    if ((g_ConfigOptions.dwMonitorDeviceId == pPortsInfo[dw].dwDeviceID)    ||  // Found the monitored device or
                        (!g_ConfigOptions.dwMonitorDeviceId &&                                  //    No monitored device and
                            (pPortsInfo[dw].bSend ||                                            //       the device is send-enabled or
                             (FAX_DEVICE_RECEIVE_MODE_OFF != pPortsInfo[dw].ReceiveMode)        //       the device is receive-enabled
                            )
                        )
                       )
                    {
                        //
                        // Mark the index of the device we use for monitoring.
                        //
                        dwDevIndex = dw;
                    }
                    if (FAX_DEVICE_RECEIVE_MODE_MANUAL == pPortsInfo[dw].ReceiveMode)
                    {
                        //
                        // Mark the id of the device set for manual-answer
                        //
                        g_ConfigOptions.dwManualAnswerDeviceId = pPortsInfo[dw].dwDeviceID;
                    }
                }
                //
                // Update the device used for monitoring from the index we found
                //
                g_ConfigOptions.dwMonitorDeviceId = pPortsInfo[dwDevIndex].dwDeviceID;
                g_ConfigOptions.bSend             = pPortsInfo[dwDevIndex].bSend;
                g_ConfigOptions.bReceive          = FAX_DEVICE_RECEIVE_MODE_OFF != pPortsInfo[dwDevIndex].ReceiveMode;
            }
            else
            {
                //
                // No devices
                //
                g_ConfigOptions.dwMonitorDeviceId = 0;
                g_ConfigOptions.bSend = FALSE;
                g_ConfigOptions.bReceive = FALSE;   
            }
            FaxFreeBuffer(pPortsInfo);
        }
    }
} // GetConfiguration


BOOL
Connect(
)
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("Connect"), bRes);

    if (g_hFaxSvcHandle) 
    {
        //
        // Already connected
        //
        bRes = TRUE;
        return bRes;
    }

    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) 
    {
        CALL_FAIL (RPC_ERR, TEXT("FaxConnectFaxServer"), GetLastError());
        return bRes;
    }
    bRes = TRUE;
    return bRes;
} // Connect


VOID 
CALLBACK 
WaitForFaxRestartTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
/*++

Routine description:

    Timer proc for restart waiting thread

Arguments:

  hwnd    - handle to window
  uMsg    - WM_TIMER message
  idEvent - timer identifier
  dwTime  - current system time

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("WaitForFaxRestartTimerProc"));

    if(!KillTimer(NULL, idEvent))
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("KillTimer"), GetLastError());
    }

    WaitForFaxRestart(g_hWndFaxNotify);

}   // WaitForFaxRestartTimerProc


BOOL
RegisterForServerEvents()
/*++

Routine description:

    Register for fax notifications

Arguments:

    none

Return Value:

    none

--*/
{
    BOOL  bRes = FALSE;
    DWORD dwEventTypes;

    DBG_ENTER(TEXT("RegisterForServerEvents"));

    if (!Connect())
    {
        goto exit;
    }

    //
    // Load configuration
    //
    GetConfiguration ();

    if(g_hNotification)
    {
        if(!FaxUnregisterForServerEvents(g_hNotification))
        {
            CALL_FAIL (RPC_ERR, TEXT("FaxUnregisterForServerEvents"), GetLastError());
        }
        g_hNotification = NULL;
    }

    //
    // Register for the fax events
    //
    dwEventTypes = FAX_EVENT_TYPE_FXSSVC_ENDED;

    VERBOSE (DBG_MSG, 
             TEXT("User has the following rights: %x. Asking for FAX_EVENT_TYPE_FXSSVC_ENDED"), 
             g_ConfigOptions.dwAccessRights);

    if(IsUserGrantedAccess(FAX_ACCESS_SUBMIT)			||
	   IsUserGrantedAccess(FAX_ACCESS_SUBMIT_NORMAL)	||
	   IsUserGrantedAccess(FAX_ACCESS_SUBMIT_HIGH))      // User can submit new faxes (and view his own faxes)
    {
        dwEventTypes |= FAX_EVENT_TYPE_OUT_QUEUE;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_OUT_QUEUE"));
    }

    if(IsUserGrantedAccess(FAX_ACCESS_QUERY_JOBS))    // User can view all jobs (in and out)
    {
        dwEventTypes |= FAX_EVENT_TYPE_OUT_QUEUE | FAX_EVENT_TYPE_IN_QUEUE;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_OUT_QUEUE & FAX_EVENT_TYPE_IN_QUEUE"));
    }

    if(IsUserGrantedAccess(FAX_ACCESS_QUERY_CONFIG))
    {
        dwEventTypes |= FAX_EVENT_TYPE_CONFIG | FAX_EVENT_TYPE_DEVICE_STATUS;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_CONFIG & FAX_EVENT_TYPE_DEVICE_STATUS"));
    }

    if(IsUserGrantedAccess(FAX_ACCESS_QUERY_IN_ARCHIVE))
    {
        dwEventTypes |= FAX_EVENT_TYPE_IN_ARCHIVE | FAX_EVENT_TYPE_NEW_CALL;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_IN_ARCHIVE"));
    }

    if (!FaxRegisterForServerEvents (g_hFaxSvcHandle,
                dwEventTypes,       // Types of events to receive
                NULL,               // Not using completion ports
                0,                  // Not using completion ports
                g_hWndFaxNotify,    // Handle of window to receive notification messages
                WM_FAX_EVENT,       // Message id
                &g_hNotification))  // Notification handle
    {
        DWORD dwRes = GetLastError ();
        CALL_FAIL (RPC_ERR, TEXT("FaxRegisterForServerEvents"), dwRes);
        g_hNotification = NULL;
    }
    else
    {
        bRes = TRUE;
    }

    if(!FaxRelease(g_hFaxSvcHandle))
    {
        CALL_FAIL (RPC_ERR, TEXT("FaxRelease"), GetLastError ());
    }

exit:

    if(!bRes)
    {
        //
        // FaxRegisterForServerEvents failed, try again 1 minute later
        //
        if(!SetTimer(NULL, 0, 60000, WaitForFaxRestartTimerProc))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("SetTimer"), GetLastError ());
        }
    }

    return bRes;

} // RegisterForServerEvents


VOID
OnFaxEvent(FAX_EVENT_EX* pEvent)
/*++

Routine description:

    Handle fax events

Arguments:

    pEvent - fax event data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnFaxEvent"), TEXT("%x"), pEvent);
    if(!pEvent || pEvent->dwSizeOfStruct != sizeof(FAX_EVENT_EX))
    {
        VERBOSE (DBG_MSG, TEXT("Either event is bad or it has bad size"));
        return;
    }
    
    switch (pEvent->EventType)
    {
        case FAX_EVENT_TYPE_NEW_CALL:

            OnNewCall (pEvent->EventInfo.NewCall);
            break;

        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:

            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                case FAX_JOB_EVENT_TYPE_REMOVED:
                    break;

                case FAX_JOB_EVENT_TYPE_STATUS:
                    if(pEvent->EventInfo.JobInfo.pJobData &&
                       pEvent->EventInfo.JobInfo.pJobData->dwDeviceID &&
                       pEvent->EventInfo.JobInfo.pJobData->dwDeviceID == g_ConfigOptions.dwMonitorDeviceId)
                    {   
                        if(g_dwlCurrentMsgID != pEvent->EventInfo.JobInfo.dwlMessageId)
                        {
                            g_bRecipientNameValid = FALSE;
                        }
                        g_dwlCurrentMsgID = pEvent->EventInfo.JobInfo.dwlMessageId;
                    }

                    if(g_dwlCurrentMsgID == pEvent->EventInfo.JobInfo.dwlMessageId)
                    {
                        StatusUpdate(pEvent->EventInfo.JobInfo.pJobData);
                    }
                    break;
            }
            break;

        case FAX_EVENT_TYPE_IN_ARCHIVE:
            if(FAX_JOB_EVENT_TYPE_ADDED == pEvent->EventInfo.JobInfo.Type)
            {                
                g_dwlNewMsgId = pEvent->EventInfo.JobInfo.dwlMessageId;

                SetIconState(ICON_NEW_FAX, TRUE);
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            if (FAX_CONFIG_TYPE_SECURITY == pEvent->EventInfo.ConfigType)
            {
                //
                // Security has changed. 
                // We should re-register for events now.
                // Also re-read the current user rights
                //
                RegisterForServerEvents();
            }
            else if (FAX_CONFIG_TYPE_DEVICES == pEvent->EventInfo.ConfigType)
            {
                //
                // Device configuration has changed.
                // The only reason we need to know that is because the device we were listening on might be gone now.
                // If that's true, we should pick the first available device as the monitoring device.
                //
                GetConfiguration();
                UpdateMonitorData(g_hMonitorDlg);
            }
            else
            {
                //
                // Non-interesting configuraton change - ignore.
                //
            }
            break;

        case FAX_EVENT_TYPE_DEVICE_STATUS:
            if(pEvent->EventInfo.DeviceStatus.dwDeviceId == g_ConfigOptions.dwMonitorDeviceId ||
               pEvent->EventInfo.DeviceStatus.dwDeviceId == g_ConfigOptions.dwManualAnswerDeviceId)
            {
                //
                // we only care about the monitored / manual-answer devices
                //
                if ((pEvent->EventInfo.DeviceStatus.dwNewStatus) & FAX_DEVICE_STATUS_RINGING)
                {
                    //
                    // Device is ringing
                    //
                    OnDeviceRing (pEvent->EventInfo.DeviceStatus.dwDeviceId);
                }
                else
                {   
                    if (FAX_RINGING == g_devState)
                    {
                        //
                        // Device is not ringing anymore but the monitor shows 'ringing'.
                        // Set the monitor to idle state.
                        //
                        SetStatusMonitorDeviceState(FAX_IDLE);
                    }
                }
            }
            break;

        case FAX_EVENT_TYPE_FXSSVC_ENDED:
            //
            // Service was stopped
            //
            SetIconState(ICON_RINGING,   FALSE);
            SetIconState(ICON_SENDING,   FALSE);
            SetIconState(ICON_RECEIVING, FALSE);

            SetStatusMonitorDeviceState(FAX_IDLE);
            //
            // We just lost our RPC connection handle and our notification handle. Close and zero them.
            //
            if (g_hNotification)
            {
                FaxUnregisterForServerEvents (g_hNotification);
                g_hNotification = NULL;
            }
            if (g_hFaxSvcHandle)
            {
                FaxClose (g_hFaxSvcHandle);
                g_hFaxSvcHandle = NULL;
            }

            WaitForFaxRestart(g_hWndFaxNotify);
            break;
    }

    FaxFreeBuffer (pEvent);
} // OnFaxEvent


VOID  
OnDeviceRing(
    DWORD dwDeviceID
)
/*++

Routine description:

    Called when a device is ringing

Arguments:

    dwDeviceID - device ID 

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnDeviceRing"), TEXT("%d"), dwDeviceID);

    //
    // It can be monitored or manual answer device
    //
    SetStatusMonitorDeviceState(FAX_RINGING);
    AddStatusMonitorLogEvent(LIST_IMAGE_NONE, IDS_RINGING);
    if(g_ConfigOptions.bSoundOnRing)
    {
        if(!PlaySound(g_Icons[ICON_RINGING].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
        }
    }
}


VOID
OnNewCall (
    const FAX_EVENT_NEW_CALL &NewCall
)
/*++

Routine description:

    Handle "new call" fax event

Arguments:

    NewCall - fax event data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnNewCall"));

    //
    // It can be any manual answer device
    //
    g_hCall = NewCall.hCall;

    if(NewCall.hCall)
    {
        LPCTSTR lpctstrParam = NULL;
        DWORD  dwStringResId = IDS_INCOMING_CALL;

        CopyLTRString(g_szAddress, NewCall.lptstrCallerId, ARR_SIZE(g_szAddress) - 1);

        _tcscpy(g_szRemoteId, g_szAddress);

        if(NewCall.lptstrCallerId && _tcslen(NewCall.lptstrCallerId))
        {
            //
            // We know the caller id.
            // Use another string which formats the caller ID parameter
            //
            lpctstrParam  = NewCall.lptstrCallerId;
            dwStringResId = IDS_INCOMING_CALL_FROM;
        }
        TCHAR tszEvent[MAX_PATH] = {0};
        AddStatusMonitorLogEvent (LIST_IMAGE_NONE, dwStringResId, lpctstrParam, tszEvent, ARR_SIZE(tszEvent));
        SetStatusMonitorDeviceState(FAX_RINGING);
        SetIconState(ICON_RINGING, TRUE, tszEvent);
    }
    else
    {
        //
        // Call is gone
        //
        SetStatusMonitorDeviceState(FAX_IDLE);
        SetIconState(ICON_RINGING, FALSE, TEXT(""));
    }
} // OnNewCall

VOID
GetRemoteId(
    PFAX_JOB_STATUS pStatus
)
/*++

Routine description:

    Write Sender ID or Recipient ID into g_szRemoteId
    Sender ID (receive):
          TSID or
          Caller ID or
          "unknown caller"
    
    Recipient ID (send):
          Recipient name or
          CSID or
          Recipient phone number.

Arguments:

    pStatus - job status data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("GetRemoteId"));

    if(!pStatus)
    {
        return;
    }

    if(JT_SEND == pStatus->dwJobType)
    {
        //
        // Recipient ID (send)
        //
        if(!g_bRecipientNameValid)
        {
            //
            // Store the recipient name into g_szRecipientName
            //
            PFAX_JOB_ENTRY_EX pJobEntry = NULL;
            if(!FaxGetJobEx(g_hFaxSvcHandle, g_dwlCurrentMsgID, &pJobEntry))
            {
                CALL_FAIL (RPC_ERR, TEXT ("FaxGetJobEx"), GetLastError());
                g_szRecipientName[0] = TEXT('\0');
            }
            else
            {
                if(pJobEntry->lpctstrRecipientName && _tcslen(pJobEntry->lpctstrRecipientName))
                {
                    _tcsncpy(g_szRecipientName, pJobEntry->lpctstrRecipientName, ARR_SIZE(g_szRecipientName) - 1);
                }
                else
                {
                    g_szRecipientName[0] = TEXT('\0');
                }
                g_bRecipientNameValid = TRUE;

                FaxFreeBuffer(pJobEntry);
            }
        }

        if(_tcslen(g_szRecipientName))
        {
            //
            // Recipient name
            //
            _tcsncpy(g_szRemoteId, g_szRecipientName, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrCsid && _tcslen(pStatus->lpctstrCsid))
        {
            //
            // CSID
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrCsid, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrCallerID && _tcslen(pStatus->lpctstrCallerID))
        {
            //
            // Recipient number
            // For outgoing fax FAX_JOB_STATUS.lpctstrCallerID field
            // contains a recipient fax number.
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrCallerID, ARR_SIZE(g_szRemoteId) - 1);
        }
    }
    else if(JT_RECEIVE == pStatus->dwJobType)
    {
        //
        // Sender ID (receive)
        //
        if(pStatus->lpctstrTsid     && _tcslen(pStatus->lpctstrTsid) &&
           pStatus->lpctstrCallerID && _tcslen(pStatus->lpctstrCallerID))
        {
            //
            // We have Caller ID and TSID
            //
			TCHAR szTmp[MAX_PATH] = {0};
            _sntprintf(szTmp, 
                       ARR_SIZE(szTmp)-1, 
                       TEXT("%s (%s)"), 
                       pStatus->lpctstrCallerID,
                       pStatus->lpctstrTsid); 
            CopyLTRString(g_szRemoteId, szTmp, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrTsid && _tcslen(pStatus->lpctstrTsid))
        {
            //
            // TSID
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrTsid, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrCallerID && _tcslen(pStatus->lpctstrCallerID))
        {
            //
            // Caller ID
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrCallerID, ARR_SIZE(g_szRemoteId) - 1);
        }
        else
        {
            //
            // unknown caller
            //
            _tcsncpy(g_szRemoteId, TEXT(""), ARR_SIZE(g_szRemoteId) - 1);
        }
    }
}


VOID
StatusUpdate(PFAX_JOB_STATUS pStatus)
/*++

Routine description:

    Handle "status update" fax event

Arguments:

    pStatus - job status data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("StatusUpdate"));

    DWORD dwRes;

    if(!pStatus)
    {
        return;
    }
    VERBOSE (DBG_MSG, 
             TEXT("Job status event - Type=%x, QueueStatus=%x, ExtendedStatus=%x"),
             pStatus->dwJobType, 
             pStatus->dwQueueStatus, 
             pStatus->dwExtendedStatus);

    if(JT_RECEIVE != pStatus->dwJobType && JT_SEND != pStatus->dwJobType)
    {
        VERBOSE (DBG_MSG, TEXT("Job type (%d) is not JT_RECEIVE or JT_SEND. Ignoring."), pStatus->dwJobType);
        return;
    }

    eIconType eIcon = LIST_IMAGE_NONE;  // New icon to set

    DWORD  dwStatusId = 0;             // string resource ID
    TCHAR  tszStatus[MAX_PATH] = {0};  // String to show in status monitor
    BOOL   bStatus = FALSE;            // TRUE if tszStatus has valid string

    if(pStatus->dwQueueStatus & JS_PAUSED)
    {
        //
        // The job has been paused in the outbox queue after a failure
        //
        g_dwlCurrentMsgID = 0;
        return;
    }

    if(pStatus->dwQueueStatus & JS_COMPLETED || pStatus->dwQueueStatus & JS_ROUTING)
    {
        //
        // Incoming job sends JS_ROUTING status by completion
        //
        if(JS_EX_PARTIALLY_RECEIVED == pStatus->dwExtendedStatus)
        {
            bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1);
        }
        else
        {
            eIcon = LIST_IMAGE_SUCCESS;
            dwStatusId = (JT_SEND == pStatus->dwJobType) ? IDS_FAX_SNT_COMPLETED : IDS_FAX_RCV_COMPLETED;
        }
    }
    else if(pStatus->dwQueueStatus & JS_CANCELING)
    {
        dwStatusId = IDS_FAX_CANCELING;
    }
    else if(pStatus->dwQueueStatus & JS_CANCELED)
    {
        dwStatusId = IDS_FAX_CANCELED;
    }
    else if(pStatus->dwQueueStatus & JS_INPROGRESS)
    {
        GetRemoteId(pStatus);

        bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1);

        g_dwCurrentJobID = pStatus->dwJobID;

        SetIconState((JT_SEND == pStatus->dwJobType) ? ICON_SENDING : ICON_RECEIVING, TRUE, tszStatus);

        SetStatusMonitorDeviceState((JT_SEND == pStatus->dwJobType) ? FAX_SENDING : FAX_RECEIVING);
    }
    else if(pStatus->dwQueueStatus & JS_FAILED)
    {
        if(!(bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1)))
        {
            eIcon = LIST_IMAGE_ERROR;
            dwStatusId = (JT_SEND == pStatus->dwJobType) ? IDS_FAX_FATAL_ERROR_SND : IDS_FAX_FATAL_ERROR_RCV;
        }
    }
    else if(pStatus->dwQueueStatus & JS_RETRIES_EXCEEDED)
    {
        //
        // Add two strings to the log.
        // The first is extended status.
        // The second is "Retries exceeded"
        //
        if(bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1))
        {
            AddStatusMonitorLogEvent(eIcon, tszStatus);
            bStatus = FALSE;
        }

        eIcon = LIST_IMAGE_ERROR;
        dwStatusId = IDS_FAX_RETRIES_EXCEEDED;
    }
    else if(pStatus->dwQueueStatus & JS_RETRYING)
    {
        if(!(bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1)))
        {
            eIcon = LIST_IMAGE_ERROR;
            dwStatusId = IDS_FAX_FATAL_ERROR_SND;
        }
    }
    

    if(!bStatus && dwStatusId)
    {
        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwStatusId, tszStatus, ARR_SIZE(tszStatus))))
        {
            bStatus = FALSE;
        }
        else
        {
            bStatus = TRUE;
        }
    }

    if(bStatus)
    {
        AddStatusMonitorLogEvent (eIcon, tszStatus);
    }    

    if(!(pStatus->dwQueueStatus & JS_INPROGRESS))
    {
        g_dwCurrentJobID = 0;

        SetStatusMonitorDeviceState(FAX_IDLE);

        SetIconState(ICON_SENDING,   FALSE);
        SetIconState(ICON_RECEIVING, FALSE);
    }
    
    if(pStatus->dwQueueStatus & (JS_FAILED | JS_RETRIES_EXCEEDED | JS_RETRYING))
    {
        if(JT_SEND == pStatus->dwJobType)
        {
            g_dwlSendFailedMsgId = g_dwlCurrentMsgID;
        }

        SetIconState((JT_SEND == pStatus->dwJobType) ? ICON_SEND_FAILED : ICON_RECEIVE_FAILED, TRUE, tszStatus);
    }

    if((JT_SEND == pStatus->dwJobType) && (pStatus->dwQueueStatus & JS_COMPLETED))
    {
        SetIconState(ICON_SEND_SUCCESS, TRUE, tszStatus);
        g_dwlSendSuccessMsgId = g_dwlCurrentMsgID;
    }
} // StatusUpdate

/*
Unhandled Job Statuses:
 JS_NOLINE 
 JS_PAUSED 
 JS_PENDING
 JS_DELETING     
 
Unhandled Extneded Job Statuses:
 JS_EX_HANDLED           
*/

BOOL
GetStatusEx(
    PFAX_JOB_STATUS pStatus,
    eIconType*      peIcon,
    TCHAR*          ptsStatusEx,
    DWORD           dwSize
)
/*++

Routine description:

    Find string description and icon type for a job 
    according to its extended status

Arguments:

    pStatus     - [in]  job status data
    peIcon      - [out] job icon type
    ptsStatusEx - [out] job status string
    dwSize      - [in]  status string size

Return Value:

    TRUE if success
    FALSE otherwise

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("GetStatusEx"), bRes);

    ASSERTION (pStatus && peIcon && ptsStatusEx);   

    TCHAR tszFormat[MAX_PATH]={0};
		
	if (pStatus->lpctstrExtendedStatus)
	{
		//
		// FSP provided proprietary status string - use it as is.
		// 
		*peIcon = LIST_IMAGE_WARNING;
		_tcsncpy(ptsStatusEx, pStatus->lpctstrExtendedStatus, dwSize);
		ptsStatusEx[dwSize-1] = TEXT('\0');
		bRes = TRUE;
		return bRes;
	}	

	//
	// No extended status string, check for well known status code
	//
	if(!(pStatus->dwValidityMask & FAX_JOB_FIELD_STATUS_EX) || 
        !pStatus->dwExtendedStatus)
    {
        return FALSE;
    }
	
    *peIcon = LIST_IMAGE_NONE;
    for(DWORD dw=0; g_StatusEx[dw].dwExtStatus != 0; ++dw)
    {
        if(g_StatusEx[dw].dwExtStatus == pStatus->dwExtendedStatus)
        {
            DWORD dwRes;

            *peIcon = g_StatusEx[dw].eIcon;
            if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (g_StatusEx[dw].uResourceId, tszFormat, ARR_SIZE(tszFormat))))
            {
                return bRes;
            }
            break;
        }
    }

    switch(pStatus->dwExtendedStatus)    
    {
        case JS_EX_DIALING:
            //
            // For outgoing fax FAX_JOB_STATUS.lpctstrCallerID field
            // contains a recipient fax number.
            //
            CopyLTRString(g_szAddress, pStatus->lpctstrCallerID, ARR_SIZE(g_szAddress) - 1);

            _sntprintf(ptsStatusEx, dwSize -1, tszFormat, g_szAddress);
			ptsStatusEx[dwSize-1] = TEXT('\0');
            break;

        case JS_EX_TRANSMITTING:
            _sntprintf(ptsStatusEx, dwSize -1, tszFormat, pStatus->dwCurrentPage, pStatus->dwPageCount);
			ptsStatusEx[dwSize-1] = TEXT('\0');
            break;

        case JS_EX_RECEIVING:
            _sntprintf(ptsStatusEx, dwSize -1, tszFormat, pStatus->dwCurrentPage);
			ptsStatusEx[dwSize-1] = TEXT('\0');
            break;

        case JS_EX_FATAL_ERROR:
            {
                DWORD dwRes;
                if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (
                                        (JT_SEND == pStatus->dwJobType) ? 
                                                IDS_FAX_FATAL_ERROR_SND : 
                                                IDS_FAX_FATAL_ERROR_RCV, 
                                        ptsStatusEx,
                                        dwSize)))
                {
                    return bRes;
                }
            }
            break;

        default:
            _tcsncpy(ptsStatusEx, tszFormat, dwSize);
            break;
    }
    bRes = TRUE;
    return bRes;
} // GetStatusEx


BOOL
IsNotifyEnable(
    eIconState state
)
/*++

Routine description:

  Check if the UI notification is enabled for a specific icon state

Arguments:

  state  [in] - icon state

Return Value:

  TRUE if the notification is enabled
  FASLE otherwise

--*/
{
    BOOL bEnable = TRUE;
    switch(state)
    {
    case ICON_SENDING:
    case ICON_RECEIVING:
        bEnable = g_ConfigOptions.bNotifyProgress;
        break;

    case ICON_NEW_FAX:
    case ICON_RECEIVE_FAILED:
        bEnable = g_ConfigOptions.bNotifyInCompletion;
        break;

    case ICON_SEND_SUCCESS:
    case ICON_SEND_FAILED:
        bEnable = g_ConfigOptions.bNotifyOutCompletion;
        break;

    };

    return bEnable;

} // IsNotifyEnable

eIconState
GetVisibleIconType ()
/*++

Routine name : GetVisibleIconType

Routine description:

	Return the index (type) of the currently visible icon

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:


Return Value:

    Icon type

--*/
{
    for(int index = ICON_RINGING; index < ICONS_COUNT; ++index)
    {
        if(!IsNotifyEnable(eIconState(index)))
        {
            continue;
        }

        if(g_Icons[index].bEnable)
        {
            return eIconState(index);
        }
    }
    return ICONS_COUNT;
}   // GetVisibleIconType

void
EvaluateIcon()
/*++

Routine description:

  Show notification icon, tooltip and balloon
  according to the current icon state

Arguments:

Return Value:

  none

--*/
{    
    DBG_ENTER(TEXT("EvaluateIcon"));

    ASSERTION (g_hWndFaxNotify);

    NOTIFYICONDATA iconData = {0};

    iconData.cbSize           = sizeof(iconData);
    iconData.hWnd             = g_hWndFaxNotify;
    iconData.uID              = TRAY_ICON_ID;
    iconData.uFlags           = NIF_MESSAGE | NIF_TIP;
    iconData.uCallbackMessage = WM_TRAYCALLBACK;


    g_CurrentIcon = GetVisibleIconType();
    if(ICONS_COUNT == g_CurrentIcon)
    {
        //
        // No visible icon
        //
        if(g_bIconAdded)
        {
            Shell_NotifyIcon(NIM_DELETE, &iconData);
            g_bIconAdded = FALSE;
        }

        //
        // No icon - no balloon
        //
        g_BalloonInfo.bDelete = FALSE;
        g_BalloonInfo.bEnable = FALSE;
        return;
    }
    iconData.uFlags = iconData.uFlags | NIF_ICON;
    iconData.hIcon  = g_Icons[g_CurrentIcon].hIcon;
    
    _tcscpy(iconData.szTip, g_Icons[g_CurrentIcon].tszToolTip);

    if(g_BalloonInfo.bEnable)
    {
        if(IsNotifyEnable(g_BalloonInfo.eState))
        {
            //
            // Show balloon tooltip
            //
            iconData.uTimeout    = g_Icons[g_BalloonInfo.eState].dwBalloonTimeout;
            iconData.uFlags      = iconData.uFlags | NIF_INFO;
            iconData.dwInfoFlags = g_Icons[g_BalloonInfo.eState].dwBalloonIcon | NIIF_NOSOUND;

            _tcscpy(iconData.szInfo,      g_BalloonInfo.szInfo);
            _tcscpy(iconData.szInfoTitle, g_BalloonInfo.szInfoTitle);
        }
        g_BalloonInfo.bEnable = FALSE;
    }

    if(g_BalloonInfo.bDelete)
    {
        //
        // Destroy currently open balloon tooltip
        //
        iconData.uFlags = iconData.uFlags | NIF_INFO;

        _tcscpy(iconData.szInfo,      TEXT(""));
        _tcscpy(iconData.szInfoTitle, TEXT(""));

        g_BalloonInfo.bDelete = FALSE;
    }

    Shell_NotifyIcon(g_bIconAdded ? NIM_MODIFY : NIM_ADD, &iconData);
    g_bIconAdded = TRUE;
} // EvaluateIcon

void
SetIconState(
    eIconState eIcon,
    BOOL       bEnable,
    TCHAR*     ptsStatus /* = NULL */
)
/*++

Routine description:

  Change notification bar icon state.

Arguments:

    eIcon      - icon type
    bEnable    - icon state (enable/disable)
    ptsStatus  - status string (optional)

Return Value:

  none

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("SetIconState"), 
              TEXT("Icon id=%d, Enable=%d, Status=%s"),
              eIcon,
              bEnable,
              ptsStatus);

    ASSERTION (eIcon < ICONS_COUNT);

    if(!bEnable && eIcon != ICON_RINGING)
    {
        //
        // We're turning off a state - nothing special to do
        //
        goto exit;
    }

    TCHAR   tsFormat[MAX_PATH]= {0};
    LPCTSTR strParam      = NULL;
    DWORD   dwStringResId = 0;

    switch(eIcon)
    {
        case ICON_RINGING:
            if(bEnable)
            {
                //
                // Sound, Balloon, and Animation 
                //
                SetIconState(ICON_SENDING,   FALSE);
                SetIconState(ICON_RECEIVING, FALSE);

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;

                //
                // Compose the balloon tooltip
                //
                strParam      = NULL;
                dwStringResId = IDS_INCOMING_CALL;
                if(_tcslen(g_szAddress))
                {
                    //
                    // Caller id is known - use it in formatted string
                    //
                    strParam = g_szAddress;
                    dwStringResId = IDS_INCOMING_CALL_FROM;
                }
                if (ERROR_SUCCESS != LoadAndFormatString(dwStringResId, tsFormat, ARR_SIZE(tsFormat), strParam))
                {
                    return;
                }

                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);

                if (ERROR_SUCCESS != LoadAndFormatString(IDS_CLICK_TO_ANSWER, 
                                                         g_BalloonInfo.szInfo, 
                                                         ARR_SIZE(g_BalloonInfo.szInfo)))
                {
                    return;
                }

                //
                // Set tooltip
                //
                _sntprintf(g_Icons[eIcon].tszToolTip, 
                           TOOLTIP_SIZE-1, 
                           TEXT("%s\n%s"), 
                           tsFormat, 
                           g_BalloonInfo.szInfo);

                if(!g_uRingTimerID)
                {
                    //
                    // Set animation timer
                    //
                    g_uRingTimerID = SetTimer(NULL, 0, RING_ANIMATION_FRAME_DELAY, RingTimerProc);
                    if(!g_uRingTimerID)
                    {
                        dwRes = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT ("SetTimer"), dwRes);
                    }
                    else
                    {
                        g_dwRingAnimationStartTick = GetTickCount();
                    }
                }
            }
            else // disable ringing
            {   
                if(g_Icons[eIcon].bEnable)
                {
                    //
                    // Remove ringing balloon
                    //
                    g_BalloonInfo.bDelete = TRUE;
                }

                if(g_uRingTimerID)
                {
                    //
                    // kill animation timer
                    //
                    if(!KillTimer(NULL, g_uRingTimerID))
                    {
                        dwRes = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT ("KillTimer"), dwRes);
                    }
                    g_uRingTimerID = 0;
                    g_dwRingAnimationStartTick = 0;
                }
            }
            break;

        case ICON_SENDING:
            //
            // Compose tooltip
            //
            if (ERROR_SUCCESS != LoadAndFormatString (IDS_SENDING_TO, tsFormat, ARR_SIZE(tsFormat), g_szRemoteId))
            {
                return;
            }              
            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"), 
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                SetIconState(ICON_RINGING,   FALSE);
                SetIconState(ICON_RECEIVING, FALSE);

                //
                // Open fax monitor 
                //
                if(g_ConfigOptions.bMonitorOnSend)
                {
                    dwRes = OpenFaxMonitor();
                    if(ERROR_SUCCESS != dwRes)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT ("OpenFaxMonitor"), dwRes);
                    }
                }
            }
            break;

        case ICON_RECEIVING:

            //
            // Compose tooltip
            // 
            strParam      = NULL;
            dwStringResId = IDS_RECEIVING;
            if(_tcslen(g_szRemoteId))
            {
                strParam      = g_szRemoteId;
                dwStringResId = IDS_RECEIVING_FROM;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (dwStringResId, tsFormat, ARR_SIZE(tsFormat), strParam))
            {
                return;
            }
            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"), 
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                SetIconState(ICON_RINGING, FALSE);
                SetIconState(ICON_SENDING, FALSE);

                //
                // open fax monitor 
                //
                if(g_ConfigOptions.bMonitorOnReceive)
                {
                    dwRes = OpenFaxMonitor();
                    if(ERROR_SUCCESS != dwRes)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT ("OpenFaxMonitor"), dwRes);
                    }
                }
            }
            break;

        case ICON_SEND_FAILED:
            //
            // Compose tooltip
            //
            if (ERROR_SUCCESS != LoadAndFormatString (IDS_SEND_ERROR_BALLOON, tsFormat, ARR_SIZE(tsFormat), g_szRemoteId))
            {
                return;
            }

            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"),
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if(g_ConfigOptions.bSoundOnError)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;            

                //
                // Compose the balloon
                //
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
                _tcsncpy(g_BalloonInfo.szInfo, ptsStatus ? ptsStatus : TEXT(""), MAX_BALLOON_TEXT_LEN-1);
            }
            break;

        case ICON_RECEIVE_FAILED:
            //
            // Compose tooltip
            // 
            strParam      = NULL;
            dwStringResId = IDS_RCV_ERROR_BALLOON;
            if(_tcslen(g_szRemoteId))
            {
                strParam      = g_szRemoteId;
                dwStringResId = IDS_RCV_FROM_ERROR_BALLOON;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (dwStringResId, tsFormat, ARR_SIZE(tsFormat), strParam))
            {
                return;
            }

            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"),
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if(g_ConfigOptions.bSoundOnError)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon; 

                //
                // Compose the balloon
                //
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
                _tcsncpy(g_BalloonInfo.szInfo, ptsStatus ? ptsStatus : TEXT(""), MAX_BALLOON_TEXT_LEN-1);
            }
            break;

        case ICON_NEW_FAX:
            //
            // Compose tooltip
            // 
            strParam      = NULL;
            dwStringResId = IDS_NEW_FAX_BALLOON;
            if(_tcslen(g_szRemoteId))
            {
                strParam      = g_szRemoteId;
                dwStringResId = IDS_NEW_FAX_FROM_BALLOON;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (dwStringResId, tsFormat, ARR_SIZE(tsFormat), strParam))
            {
                return;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (IDS_CLICK_TO_VIEW, 
                                                      g_BalloonInfo.szInfo, 
                                                      ARR_SIZE(g_BalloonInfo.szInfo)))
            {
                return;
            }

            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"),
                       tsFormat, 
                       g_BalloonInfo.szInfo);

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if (g_ConfigOptions.bSoundOnReceive)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;            
        
                //
                // Compose the balloon
                //
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
            }
            break;

        case ICON_SEND_SUCCESS:

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if(g_ConfigOptions.bSoundOnSent)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;

                //
                // Compose the balloon
                //
                if (ERROR_SUCCESS != LoadAndFormatString (IDS_SEND_OK, tsFormat, ARR_SIZE(tsFormat)))
                {
                    return;
                }
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
                
                if (ERROR_SUCCESS != LoadAndFormatString (IDS_SEND_OK_BALLOON, 
                                                          g_BalloonInfo.szInfo, 
                                                          ARR_SIZE(g_BalloonInfo.szInfo), 
                                                          g_szRemoteId))
                {
                    return;
                }
            }
            break;

        default:
            break;
    }

exit:
    g_Icons[eIcon].bEnable = bEnable;
	g_Icons[eIcon].tszToolTip[TOOLTIP_SIZE -1] = _T('\0');

    EvaluateIcon();
} // SetIconState

VOID 
CALLBACK 
RingTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
/*++

Routine description:

    Animate ringing icon

Arguments:

  hwnd    - handle to window
  uMsg    - WM_TIMER message
  idEvent - timer identifier
  dwTime  - current system time

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("RingTimerProc"));
    if ((GetTickCount() - g_dwRingAnimationStartTick) > RING_ANIMATION_TIMEOUT)
    {
        //
        // Animation has expired - keep static icon
        //
        g_Icons[ICON_RINGING].hIcon = g_RingIcons[0].hIcon;
        if(!KillTimer(NULL, g_uRingTimerID))
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("KillTimer"), GetLastError());
        }
        g_uRingTimerID = 0;
        g_dwRingAnimationStartTick = 0;
    }
    else
    {
        g_dwCurrRingIconIndex = (g_dwCurrRingIconIndex + 1) % RING_ICONS_NUM;
        g_Icons[ICON_RINGING].hIcon = g_RingIcons[g_dwCurrRingIconIndex].hIcon;
    }
    EvaluateIcon();
}   // RingTimerProc


VOID
InvokeClientConsole ()
/*++

Routine description:

  Invoke Client Console

Arguments:

  none

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("InvokeClientConsole"));

    TCHAR szCmdLine[MAX_PATH];
    static TCHAR szFmtMsg[]   = TEXT(" -folder %s -MessageId %I64x");
    static TCHAR szFmtNoMsg[] = TEXT(" -folder %s");

    DWORDLONG dwlMsgId = 0;
    LPCWSTR lpcwstrFolder = TEXT("");


    switch (g_CurrentIcon)
    {
        case ICON_RINGING:          // Line is ringing - nothing special to do
        case ICON_RECEIVE_FAILED:   // Receive operation failed - nothing special to do
        default:                    // Any other icon state - nothing special to do
            break;

        case ICON_SENDING:
            //
            // Device is sending - open fax console in Outbox folder
            //
            dwlMsgId = g_dwlCurrentMsgID;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_OUTBOX;
            break;

        case ICON_SEND_FAILED:
            //
            // Send operation failed - open fax console in Outbox folder
            //
            dwlMsgId = g_dwlSendFailedMsgId;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_OUTBOX;
            break;

        case ICON_RECEIVING:
            //
            // Device is receiving - open fax console in Incoming folder
            //
            dwlMsgId = g_dwlCurrentMsgID;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_INCOMING;
            break;
    
            break;

        case ICON_NEW_FAX:
            //
            // New unread fax - open fax console in Inbox folder
            //
            dwlMsgId = g_dwlNewMsgId;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_INBOX;
            break;

        case ICON_SEND_SUCCESS:
            //
            // Send was successful - open fax console in Sent Items folder
            //
            dwlMsgId = g_dwlSendSuccessMsgId;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_SENT_ITEMS;
            break;
    }

    if (dwlMsgId)
    {
        wsprintf (szCmdLine, szFmtMsg, lpcwstrFolder, dwlMsgId);
    }
    else
    {
        wsprintf (szCmdLine, szFmtNoMsg, lpcwstrFolder);
    }

    HINSTANCE hRes;
    hRes = ShellExecute(g_hWndFaxNotify, 
                 NULL, 
                 FAX_CLIENT_CONSOLE_IMAGE_NAME,
                 szCmdLine,
                 NULL,
                 SW_SHOW);
    if((DWORD_PTR)hRes <= 32)
    {
        //
        // error
        //
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecute"), PtrToUlong(hRes));
    }    

} // InvokeClientConsole

VOID
AnswerTheCall ()
/*++

Routine description:

  Answer the current incoming call

Arguments:

  none

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("AnswerTheCall"));
    DWORD dwDeviceId;

    //
    // Check for 'Answer now' capabilities and auto-detect the device id.
    //
    DWORD dwRes = CheckAnswerNowCapability (TRUE,           // Start service if necessary
                                            &dwDeviceId);   // Get device id for FaxAnswerCall
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't 'Answer Now' - dwRes has the string resource id for the message to show to the user.
        //
        FaxMessageBox (g_hMonitorDlg, dwRes, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    //
    // Reset remote ID
    //
    _tcscpy(g_szRemoteId, TEXT(""));

    //
    // Looks like we have a chance of FaxAnswerCall succeeding - let's try it.
    // First, open the monitor (or make sure it's already open).
    //
    OpenFaxMonitor ();
    //
    // Start by disabling the 'Answer Now' button on the monitor dialog
    //
    if (g_hMonitorDlg)
    {
        //
        // Monitor dialog is there
        //
        HWND hWndAnswerNow = GetDlgItem(g_hMonitorDlg, IDC_DISCONNECT);
        if(hWndAnswerNow)
        {
            EnableWindow(hWndAnswerNow, FALSE);
        }
    }
    //
    // Call is gone
    //
    g_hCall = NULL;
    SetIconState(ICON_RINGING, FALSE, TEXT(""));

    if(!FaxAnswerCall(g_hFaxSvcHandle, dwDeviceId))
    {
        CALL_FAIL (RPC_ERR, TEXT ("FaxAnswerCall"), GetLastError());
        FaxMessageBox(g_hWndFaxNotify, IDS_CANNOT_ANSWER, MB_OK | MB_ICONEXCLAMATION);
        SetStatusMonitorDeviceState (FAX_IDLE);
    }
    else
    {
        g_tszLastEvent[0] = TEXT('\0');
        SetStatusMonitorDeviceState(FAX_RECEIVING);
    }
} // AnswerTheCall

VOID 
FaxPrinterProperties(DWORD dwPage)
/*++

Routine description:

  Open Fax Printer Property Sheet

Arguments:

  dwPage - page number

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("FaxPrinterProperties"));

    //
    // open fax printer properties on the Tracking page
    //
    TCHAR tsPrinter[MAX_PATH];

    typedef VOID (*PRINTER_PROP_PAGES_PROC)(HWND, LPCTSTR, INT, LPARAM);  

    HMODULE hPrintUI = NULL;
    PRINTER_PROP_PAGES_PROC fpPrnPropPages = NULL;

    if(!GetFirstLocalFaxPrinterName(tsPrinter, MAX_PATH))
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("GetFirstLocalFaxPrinterName"), GetLastError());
        return;
    }
    
    hPrintUI = LoadLibrary(TEXT("printui.dll"));
    if(!hPrintUI)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("LoadLibrary(printui.dll)"), GetLastError());
        return;
    }

    fpPrnPropPages = (PRINTER_PROP_PAGES_PROC)GetProcAddress(hPrintUI, "vPrinterPropPages");
    if(fpPrnPropPages)
    {
        fpPrnPropPages(g_hWndFaxNotify, tsPrinter, SW_SHOWNORMAL, dwPage);
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("GetProcAddress(vPrinterPropPages)"), GetLastError());
    }
    
    FreeLibrary(hPrintUI);

} // FaxPrinterProperties

VOID
DoFaxContextMenu (HWND hwnd)
/*++

Routine description:

  Popup and handle context menu

Arguments:

  hwnd   - notification window handle

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("DoFaxContextMenu"));

    POINT pt;
    HMENU hm = LoadMenu (g_hResource, MAKEINTRESOURCE (IDM_FAX_MENU));
    HMENU hmPopup = GetSubMenu(hm, 0);

    if (!g_Icons[ICON_RINGING].bEnable)
    {
        RemoveMenu (hmPopup, ID_ANSWER_CALL, MF_BYCOMMAND);
    }

    if(g_dwCurrentJobID == 0)
    {
        RemoveMenu (hmPopup, ID_DISCONNECT_CALL, MF_BYCOMMAND);
    }

    if(!g_Icons[ICON_RINGING].bEnable && g_dwCurrentJobID == 0)
    {
        //
        // delete the menu separator
        //
        DeleteMenu(hmPopup, 0, MF_BYPOSITION);
    }

    SetMenuDefaultItem(hmPopup, ID_FAX_QUEUE, FALSE);

    GetCursorPos (&pt);
    SetForegroundWindow(hwnd);

    INT idCmd = TrackPopupMenu (GetSubMenu(hm, 0),
                                TPM_RETURNCMD | TPM_NONOTIFY,
                                pt.x, pt.y,
                                0, hwnd, NULL);
    switch (idCmd)
    {
        case ID_ICON_PROPERTIES:
            FaxPrinterProperties(IsSimpleUI() ? 3 : 5);
            break;

         case ID_FAX_QUEUE:
             InvokeClientConsole ();
             break;

         case ID_ANSWER_CALL:
             AnswerTheCall ();
             break;

         case ID_FAX_MONITOR:
             OpenFaxMonitor ();
             break;

         case ID_DISCONNECT_CALL:
             OnDisconnect();
             break;
    }
    if (hm)
    {
        DestroyMenu (hm);
    }
} // DoFaxContextMenu


VOID
OnTrayCallback (HWND hwnd, WPARAM wp, LPARAM lp)
/*++

Routine description:

  Handle messages from the notification icon

Arguments:

  hwnd   - notification window handle
  wp     - message parameter
  lp     - message parameter

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("OnTrayCallback"), TEXT("hWnd=%08x, wParam=%08x, lParam=%08x"), hwnd, wp, lp);

    switch (lp)
    {
        case NIN_BALLOONUSERCLICK:      // User clicked balloon or (WM_USER + 5 = 1029)
        case WM_LBUTTONDOWN:            // User pressed icon       (513)
        {
            //
            // Our behavior depends on the icon currently being displyed
            //
            switch (g_CurrentIcon)
            {
                case ICON_RINGING:
                    //    
                    // Device is ringing - answer the call
                    //
                    AnswerTheCall ();
                    break;

                case ICON_NEW_FAX:              // New unread fax - open fax console in Inbox folder
                case ICON_SEND_SUCCESS:         // Send was successful - open fax console in Sent Items folder
                case ICON_SEND_FAILED:          // Send operation failed - open fax console in Outbox folder
                    //
                    // Turn off the current icon state
                    //
                    InvokeClientConsole ();
                    SetIconState(g_CurrentIcon, FALSE);
                    break;

                case ICON_SENDING:              // Device is sending - open fax console in Outbox folder
                case ICON_RECEIVING:            // Device is receiving - open fax console in Incoming folder
                    InvokeClientConsole ();
                    break;

                case ICON_RECEIVE_FAILED:
                    //
                    // Receive operation failed
                    //
                    SetIconState(g_CurrentIcon, FALSE);
                    break;

                default:
                    //
                    // When balloon is opened and the user clicks on the icon we get two notifications
                    // NIN_BALLOONUSERCLICK and WM_LBUTTONDOWN. The first one reset the icon state and the second do nothing.
                    //
                    break;
            }    
        }
        //
        // no break ==> fall-through
        //
        case NIN_BALLOONTIMEOUT:
            if (g_BalloonInfo.eState == ICON_RECEIVE_FAILED ||
                g_BalloonInfo.eState == ICON_SEND_SUCCESS)
            {
                SetIconState(g_BalloonInfo.eState, FALSE);
            }
            g_BalloonInfo.eState = ICON_IDLE;
            break;

        case WM_RBUTTONDOWN:
            DoFaxContextMenu (hwnd);
            break;

    }
} // OnTrayCallback

BOOL 
IsUserGrantedAccess(
    DWORD dwAccess
)
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("IsUserGrantedAccess"), bRes, TEXT("%d"), dwAccess);
    if (!g_hFaxSvcHandle)
    {
        //
        // Not connected - no rights
        //
        return bRes;
    }
    if (dwAccess == (g_ConfigOptions.dwAccessRights & dwAccess))
    {
        bRes = TRUE;
    }
    return bRes;
}   // IsUserGrantedAccess


DWORD
CheckAnswerNowCapability (
    BOOL    bForceReconnect,
    LPDWORD lpdwDeviceId /* = NULL */
)
/*++

Routine name : CheckAnswerNowCapability

Routine description:

	Checks if the 'Answer Now' option can be used

Author:

	Eran Yariv (EranY),	Mar, 2001

Arguments:

    bForceReconnect [in]  - If the service is down, should we bring it up now?
    lpdwDeviceId    [out] - The device id to use when calling FaxAnswerCall.
                            If the Manual-Answer-Device is ringing, we use the Manual-Answer-Device id.
                            Otherwise, it's the monitored device id. (Optional)

Return Value:

    ERROR_SUCCESS if the 'Answer Now' can be used.
    Othewise, returns a string resource id that can be used in a message box to tell the user
    why 'Answer Now' is not available.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CheckAnswerNowCapability"), dwRes);
    //
    // First, let's see if we're connected to the local server
    //
    if (NULL == g_hFaxSvcHandle)
    {
        //
        // Service is down
        //
        if (!bForceReconnect)
        {   
            //
            // We assume the user can 'Answer now'
            //
            ASSERTION (NULL == lpdwDeviceId);
            return dwRes;
        }
        //
        // Try to start up the local fax service
        //
        if (!Connect())
        {
            //
            // Couldn't start up the service
            //
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT("Connect"), dwRes);
            dwRes = IDS_ERR_CANT_TALK_TO_SERVICE; 
            return dwRes;
        }
        //
        // Now that the service is up - we need to connect.
        // Send a message to the main window to bring up the connection.
        //
        if (!SendMessage (g_hWndFaxNotify, WM_FAX_STARTED, 0, 0))
        {
            //
            // Failed to connect
            //
            dwRes = IDS_ERR_CANT_TALK_TO_SERVICE; 
            return dwRes;
        }
        //
        // Now we're connected !!!
        //
    }
    if (!IsUserGrantedAccess (FAX_ACCESS_QUERY_IN_ARCHIVE))
    {
        //
        // User can't receive-now
        //
        dwRes = IDS_ERR_ANSWER_ACCESS_DENIED; 
        return dwRes;
    }
    if (0 == g_ConfigOptions.dwMonitorDeviceId)
    {
        //
        // No devices
        //
        dwRes = IDS_ERR_NO_DEVICES;
        return dwRes;
    }
    if (g_hCall)
    {
        //
        // The Manual-Answer-Device is ringing, we use the Manual-Answer-Device id.
        //
        ASSERTION (g_ConfigOptions.dwManualAnswerDeviceId);
        if (lpdwDeviceId)
        {
            *lpdwDeviceId = g_ConfigOptions.dwManualAnswerDeviceId;
        }
        return dwRes;
    }
    //
    // The Manual-Answer-Device is NOT ringing; we should receive on the monitored device
    //
    if ((0 != g_dwCurrentJobID) || (FAX_IDLE != g_devState))
    {
        //
        // There's a job on the monitored device
        //
        dwRes = IDS_ERR_DEVICE_BUSY;
        return dwRes;
    }
    //
    // One last check - is the monitored device virtual?
    //
    BOOL bVirtual;
    dwRes = IsDeviceVirtual (g_hFaxSvcHandle, g_ConfigOptions.dwMonitorDeviceId, &bVirtual);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't tell - assume virtual
        //
        bVirtual = TRUE;
    }
    if (bVirtual)
    {
        //
        // Sorry, manual answering on virtual devices is NOT supported
        //
        dwRes = IDS_ERROR_VIRTUAL_DEVICE;
        return dwRes;
    }
    //
    // It's ok to call FaxAnswerCall on the monitored device
    //
    if (lpdwDeviceId)
    {
        *lpdwDeviceId = g_ConfigOptions.dwMonitorDeviceId;
    }
    return dwRes;
}   // CheckAnswerNowCapability

LRESULT 
CALLBACK
NotifyWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
/*++

Routine description:

  Notification window procedure

Arguments:

  hwnd   - notification window handle
  msg    - message ID
  wp     - message parameter
  lp     - message parameter

Return Value:

  result

--*/
{
    switch (msg)
    {
        case WM_CREATE:
            break;

        case WM_FAX_STARTED:
            //
            // We get this message after service startup event
            //
            return RegisterForServerEvents();

        case WM_TRAYCALLBACK:
            OnTrayCallback (hwnd, wp, lp);
            break;

        case WM_FAX_EVENT:

#ifndef DEBUG
            try
            {
#endif
                OnFaxEvent ((FAX_EVENT_EX*)lp);
#ifndef DEBUG
            }
            catch(...)
            {
                //
                // Do not handle the exception for the debug version
                //
                DBG_ENTER(TEXT("NotifyWndProc"));
                CALL_FAIL (GENERAL_ERR, TEXT("OnFaxEvent"), 0);
                return 0;
            }
#endif
            return 0;

        case WM_FAXSTAT_CONTROLPANEL:
            //
            // configuration has been changed
            //
            GetConfiguration ();
            EvaluateIcon();
            UpdateMonitorData(g_hMonitorDlg);
            return 0;

        case WM_FAXSTAT_OPEN_MONITOR:
            OpenFaxMonitor ();
            return 0;

        case WM_FAXSTAT_INBOX_VIEWED:
            //
            // Client Console Inbox has been viewed
            //
            SetIconState(ICON_NEW_FAX, FALSE);
            return 0;

        case WM_FAXSTAT_OUTBOX_VIEWED:
            //
            // Client Console Outbox has been viewed
            //
            SetIconState(ICON_SEND_FAILED, FALSE);
            return 0;

        case WM_FAXSTAT_RECEIVE_NOW:
            //
            // Start receiving now
            //
            AnswerTheCall ();
            return 0;

        case WM_FAXSTAT_PRINTER_PROPERTY:
            //
            // Open Fax Printer Property Sheet
            //
            FaxPrinterProperties((DWORD)(wp));
            return 0;

        default:
           break;
    }
    return CallWindowProc (DefWindowProc, hwnd, msg, wp, lp);
} // NotifyWndProc

VOID
CopyLTRString(
    TCHAR*  szDest, 
    LPCTSTR szSource, 
    DWORD   dwSize)
/*++

Routine description:

  Copy the string and add left-to-right Unicode control characters if needed

Arguments:

  szDest    - destination string
  szSource  - source string
  dwSize    - destination string maximum size in characters

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CopyLTRString"));

    if(!szDest)
    {
        ASSERTION_FAILURE;
        return;
    }

    if(IsRTLUILanguage() && szSource && _tcslen(szSource))
    {
        //
        // The string always should be LTR
        // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
        //
        _sntprintf(szDest, 
                   dwSize -1,
                   TEXT("%c%s%c"),
                   UNICODE_LRO,
                   szSource,
                   UNICODE_PDF);
		szDest[dwSize -1] = _T('\0');

    }
    else
    {
        _tcsncpy(szDest, 
                 szSource ? szSource : TEXT(""), 
                 dwSize);
    }

} // CopyLTRString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\tapidbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapidbg.c

Abstract:

    This module provides tapi specific debug support

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


typedef struct _LOOKUP {
    DWORD   dwVal;
    LPTSTR   lpszVal;
} LOOKUP, *PLOOKUP;

typedef struct _MSGTYPE {
    DWORD   MsgId;
    BOOL    LineMsg;
    LPTSTR  Text;
} MSGTYPE, *PMSGTYPE;


MSGTYPE  aMsgs[] =
{
    { LINE_ADDRESSSTATE,             TRUE,     TEXT("LINE_ADDRESSSTATE")         },
    { LINE_AGENTSPECIFIC,            TRUE,     TEXT("LINE_AGENTSPECIFIC")        },
    { LINE_AGENTSTATUS,              TRUE,     TEXT("LINE_AGENTSTATUS")          },
    { LINE_APPNEWCALL,               TRUE,     TEXT("LINE_APPNEWCALL")           },
    { LINE_CALLINFO,                 TRUE,     TEXT("LINE_CALLINFO")             },
    { LINE_CALLSTATE,                TRUE,     TEXT("LINE_CALLSTATE")            },
    { LINE_CLOSE,                    TRUE,     TEXT("LINE_CLOSE")                },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_DEVSPECIFIC,              TRUE,     TEXT("LINE_DEVSPECIFIC")          },
    { LINE_DEVSPECIFICFEATURE,       TRUE,     TEXT("LINE_DEVSPECIFICFEATURE")   },
    { LINE_GATHERDIGITS,             TRUE,     TEXT("LINE_GATHERDIGITS")         },
    { LINE_GENERATE,                 TRUE,     TEXT("LINE_GENERATE")             },
    { LINE_LINEDEVSTATE,             TRUE,     TEXT("LINE_LINEDEVSTATE")         },
    { LINE_MONITORDIGITS,            TRUE,     TEXT("LINE_MONITORDIGITS")        },
    { LINE_MONITORMEDIA,             TRUE,     TEXT("LINE_MONITORMEDIA")         },
    { LINE_MONITORTONE,              TRUE,     TEXT("LINE_MONITORTONE")          },
    { LINE_PROXYREQUEST,             TRUE,     TEXT("LINE_PROXYREQUEST")         },
    { LINE_REMOVE,                   TRUE,     TEXT("LINE_REMOVE")               },
    { LINE_REPLY,                    TRUE,     TEXT("LINE_REPLY")                },
    { LINE_REQUEST,                  TRUE,     TEXT("LINE_REQUEST")              },
    { PHONE_BUTTON,                  FALSE,    TEXT("PHONE_BUTTON")              },
    { PHONE_CLOSE,                   FALSE,    TEXT("PHONE_CLOSE")               },
    { PHONE_CREATE,                  FALSE,    TEXT("PHONE_CREATE")              },
    { PHONE_DEVSPECIFIC,             FALSE,    TEXT("PHONE_DEVSPECIFIC")         },
    { PHONE_REMOVE,                  FALSE,    TEXT("PHONE_REMOVE")              },
    { PHONE_REPLY,                   FALSE,    TEXT("PHONE_REPLY")               },
    { PHONE_STATE,                   FALSE,    TEXT("PHONE_STATE")               },
    { 0xffffffff,                    FALSE,    NULL                              }
};

LOOKUP  aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER           ,TEXT("OTHER")              },
    { LINEADDRESSSTATE_DEVSPECIFIC     ,TEXT("DEVSPECIFIC")        },
    { LINEADDRESSSTATE_INUSEZERO       ,TEXT("INUSEZERO")          },
    { LINEADDRESSSTATE_INUSEONE        ,TEXT("INUSEONE")           },
    { LINEADDRESSSTATE_INUSEMANY       ,TEXT("INUSEMANY")          },
    { LINEADDRESSSTATE_NUMCALLS        ,TEXT("NUMCALLS")           },
    { LINEADDRESSSTATE_FORWARD         ,TEXT("FORWARD")            },
    { LINEADDRESSSTATE_TERMINALS       ,TEXT("TERMINALS")          },
    { LINEADDRESSSTATE_CAPSCHANGE      ,TEXT("CAPSCHANGE")         },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aBearerModes[] =
{
    { LINEBEARERMODE_VOICE             ,TEXT("VOICE")              },
    { LINEBEARERMODE_SPEECH            ,TEXT("SPEECH")             },
    { LINEBEARERMODE_MULTIUSE          ,TEXT("MULTIUSE")           },
    { LINEBEARERMODE_DATA              ,TEXT("DATA")               },
    { LINEBEARERMODE_ALTSPEECHDATA     ,TEXT("ALTSPEECHDATA")      },
    { LINEBEARERMODE_NONCALLSIGNALING  ,TEXT("NONCALLSIGNALING")   },
    { LINEBEARERMODE_PASSTHROUGH       ,TEXT("PASSTHROUGH")        },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY            ,TEXT("DUMMY")              },
    { PHONEBUTTONMODE_CALL             ,TEXT("CALL")               },
    { PHONEBUTTONMODE_FEATURE          ,TEXT("FEATURE")            },
    { PHONEBUTTONMODE_KEYPAD           ,TEXT("KEYPAD")             },
    { PHONEBUTTONMODE_LOCAL            ,TEXT("LOCAL")              },
    { PHONEBUTTONMODE_DISPLAY          ,TEXT("DISPLAY")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP              ,TEXT("UP")                 },
    { PHONEBUTTONSTATE_DOWN            ,TEXT("DOWN")               },
    { PHONEBUTTONSTATE_UNKNOWN         ,TEXT("UNKNOWN")            },
    { PHONEBUTTONSTATE_UNAVAIL         ,TEXT("UNAVAIL")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER          ,TEXT("OTHER")              },
    { LINECALLINFOSTATE_DEVSPECIFIC    ,TEXT("DEVSPECIFIC")        },
    { LINECALLINFOSTATE_BEARERMODE     ,TEXT("BEARERMODE")         },
    { LINECALLINFOSTATE_RATE           ,TEXT("RATE")               },
    { LINECALLINFOSTATE_MEDIAMODE      ,TEXT("MEDIAMODE")          },
    { LINECALLINFOSTATE_APPSPECIFIC    ,TEXT("APPSPECIFIC")        },
    { LINECALLINFOSTATE_CALLID         ,TEXT("CALLID")             },
    { LINECALLINFOSTATE_RELATEDCALLID  ,TEXT("RELATEDCALLID")      },
    { LINECALLINFOSTATE_ORIGIN         ,TEXT("ORIGIN")             },
    { LINECALLINFOSTATE_REASON         ,TEXT("REASON")             },
    { LINECALLINFOSTATE_COMPLETIONID   ,TEXT("COMPLETIONID")       },
    { LINECALLINFOSTATE_NUMOWNERINCR   ,TEXT("NUMOWNERINCR")       },
    { LINECALLINFOSTATE_NUMOWNERDECR   ,TEXT("NUMOWNERDECR")       },
    { LINECALLINFOSTATE_NUMMONITORS    ,TEXT("NUMMONITORS")        },
    { LINECALLINFOSTATE_TRUNK          ,TEXT("TRUNK")              },
    { LINECALLINFOSTATE_CALLERID       ,TEXT("CALLERID")           },
    { LINECALLINFOSTATE_CALLEDID       ,TEXT("CALLEDID")           },
    { LINECALLINFOSTATE_CONNECTEDID    ,TEXT("CONNECTEDID")        },
    { LINECALLINFOSTATE_REDIRECTIONID  ,TEXT("REDIRECTIONID")      },
    { LINECALLINFOSTATE_REDIRECTINGID  ,TEXT("REDIRECTINGID")      },
    { LINECALLINFOSTATE_DISPLAY        ,TEXT("DISPLAY")            },
    { LINECALLINFOSTATE_USERUSERINFO   ,TEXT("USERUSERINFO")       },
    { LINECALLINFOSTATE_HIGHLEVELCOMP  ,TEXT("HIGHLEVELCOMP")      },
    { LINECALLINFOSTATE_LOWLEVELCOMP   ,TEXT("LOWLEVELCOMP")       },
    { LINECALLINFOSTATE_CHARGINGINFO   ,TEXT("CHARGINGINFO")       },
    { LINECALLINFOSTATE_TERMINAL       ,TEXT("TERMINAL")           },
    { LINECALLINFOSTATE_DIALPARAMS     ,TEXT("DIALPARAMS")         },
    { LINECALLINFOSTATE_MONITORMODES   ,TEXT("MONITORMODES")       },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallSelects[] =
{
    { LINECALLSELECT_LINE              ,TEXT("LINE")               },
    { LINECALLSELECT_ADDRESS           ,TEXT("ADDRESS")            },
    { LINECALLSELECT_CALL              ,TEXT("CALL")               },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallStates[] =
{
    { LINECALLSTATE_IDLE               ,TEXT("IDLE")               },
    { LINECALLSTATE_OFFERING           ,TEXT("OFFERING")           },
    { LINECALLSTATE_ACCEPTED           ,TEXT("ACCEPTED")           },
    { LINECALLSTATE_DIALTONE           ,TEXT("DIALTONE")           },
    { LINECALLSTATE_DIALING            ,TEXT("DIALING")            },
    { LINECALLSTATE_RINGBACK           ,TEXT("RINGBACK")           },
    { LINECALLSTATE_BUSY               ,TEXT("BUSY")               },
    { LINECALLSTATE_SPECIALINFO        ,TEXT("SPECIALINFO")        },
    { LINECALLSTATE_CONNECTED          ,TEXT("CONNECTED")          },
    { LINECALLSTATE_PROCEEDING         ,TEXT("PROCEEDING")         },
    { LINECALLSTATE_ONHOLD             ,TEXT("ONHOLD")             },
    { LINECALLSTATE_CONFERENCED        ,TEXT("CONFERENCED")        },
    { LINECALLSTATE_ONHOLDPENDCONF     ,TEXT("ONHOLDPENDCONF")     },
    { LINECALLSTATE_ONHOLDPENDTRANSFER ,TEXT("ONHOLDPENDTRANSFER") },
    { LINECALLSTATE_DISCONNECTED       ,TEXT("DISCONNECTED")       },
    { LINECALLSTATE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aDigitModes[] =
{
    { LINEDIGITMODE_PULSE              ,TEXT("PULSE")              },
    { LINEDIGITMODE_DTMF               ,TEXT("DTMF")               },
    { LINEDIGITMODE_DTMFEND            ,TEXT("DTMFEND")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET       ,TEXT("HANDSET")            },
    { PHONEHOOKSWITCHDEV_SPEAKER       ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHDEV_HEADSET       ,TEXT("HEADSET")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK       ,TEXT("ONHOOK")             },
    { PHONEHOOKSWITCHMODE_MIC          ,TEXT("MIC")                },
    { PHONEHOOKSWITCHMODE_SPEAKER      ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHMODE_MICSPEAKER   ,TEXT("MICSPEAKER")         },
    { PHONEHOOKSWITCHMODE_UNKNOWN      ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLampModes[] =
{
    { PHONELAMPMODE_DUMMY              ,TEXT("DUMMY")              },
    { PHONELAMPMODE_OFF                ,TEXT("OFF")                },
    { PHONELAMPMODE_STEADY             ,TEXT("STEADY")             },
    { PHONELAMPMODE_WINK               ,TEXT("WINK")               },
    { PHONELAMPMODE_FLASH              ,TEXT("FLASH")              },
    { PHONELAMPMODE_FLUTTER            ,TEXT("FLUTTER")            },
    { PHONELAMPMODE_BROKENFLUTTER      ,TEXT("BROKENFLUTTER")      },
    { PHONELAMPMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLineStates[] =
{
    { LINEDEVSTATE_OTHER               ,TEXT("OTHER")              },
    { LINEDEVSTATE_RINGING             ,TEXT("RINGING")            },
    { LINEDEVSTATE_CONNECTED           ,TEXT("CONNECTED")          },
    { LINEDEVSTATE_DISCONNECTED        ,TEXT("DISCONNECTED")       },
    { LINEDEVSTATE_MSGWAITON           ,TEXT("MSGWAITON")          },
    { LINEDEVSTATE_MSGWAITOFF          ,TEXT("MSGWAITOFF")         },
    { LINEDEVSTATE_INSERVICE           ,TEXT("INSERVICE")          },
    { LINEDEVSTATE_OUTOFSERVICE        ,TEXT("OUTOFSERVICE")       },
    { LINEDEVSTATE_MAINTENANCE         ,TEXT("MAINTENANCE")        },
    { LINEDEVSTATE_OPEN                ,TEXT("OPEN")               },
    { LINEDEVSTATE_CLOSE               ,TEXT("CLOSE")              },
    { LINEDEVSTATE_NUMCALLS            ,TEXT("NUMCALLS")           },
    { LINEDEVSTATE_NUMCOMPLETIONS      ,TEXT("NUMCOMPLETIONS")     },
    { LINEDEVSTATE_TERMINALS           ,TEXT("TERMINALS")          },
    { LINEDEVSTATE_ROAMMODE            ,TEXT("ROAMMODE")           },
    { LINEDEVSTATE_BATTERY             ,TEXT("BATTERY")            },
    { LINEDEVSTATE_SIGNAL              ,TEXT("SIGNAL")             },
    { LINEDEVSTATE_DEVSPECIFIC         ,TEXT("DEVSPECIFIC")        },
    { LINEDEVSTATE_REINIT              ,TEXT("REINIT")             },
    { LINEDEVSTATE_LOCK                ,TEXT("LOCK")               },
    { LINEDEVSTATE_CAPSCHANGE          ,TEXT("CAPSCHANGE")         },
    { LINEDEVSTATE_CONFIGCHANGE        ,TEXT("CONFIGCHANGE")       },
    { LINEDEVSTATE_TRANSLATECHANGE     ,TEXT("TRANSLATECHANGE")    },
    { LINEDEVSTATE_COMPLCANCEL         ,TEXT("COMPLCANCEL")        },
    { LINEDEVSTATE_REMOVED             ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { LINEMEDIAMODE_INTERACTIVEVOICE   ,TEXT("INTERACTIVEVOICE")   },
    { LINEMEDIAMODE_AUTOMATEDVOICE     ,TEXT("AUTOMATEDVOICE")     },
    { LINEMEDIAMODE_DATAMODEM          ,TEXT("DATAMODEM")          },
    { LINEMEDIAMODE_G3FAX              ,TEXT("G3FAX")              },
    { LINEMEDIAMODE_TDD                ,TEXT("TDD")                },
    { LINEMEDIAMODE_G4FAX              ,TEXT("G4FAX")              },
    { LINEMEDIAMODE_DIGITALDATA        ,TEXT("DIGITALDATA")        },
    { LINEMEDIAMODE_TELETEX            ,TEXT("TELETEX")            },
    { LINEMEDIAMODE_VIDEOTEX           ,TEXT("VIDEOTEX")           },
    { LINEMEDIAMODE_TELEX              ,TEXT("TELEX")              },
    { LINEMEDIAMODE_MIXED              ,TEXT("MIXED")              },
    { LINEMEDIAMODE_ADSI               ,TEXT("ADSI")               },
    { LINEMEDIAMODE_VOICEVIEW          ,TEXT("VOICEVIEW")          },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aPhoneStates[] =
{
    { PHONESTATE_OTHER                 ,TEXT("OTHER")              },
    { PHONESTATE_CONNECTED             ,TEXT("CONNECTED")          },
    { PHONESTATE_DISCONNECTED          ,TEXT("DISCONNECTED")       },
    { PHONESTATE_OWNER                 ,TEXT("OWNER")              },
    { PHONESTATE_MONITORS              ,TEXT("MONITORS")           },
    { PHONESTATE_DISPLAY               ,TEXT("DISPLAY")            },
    { PHONESTATE_LAMP                  ,TEXT("LAMP")               },
    { PHONESTATE_RINGMODE              ,TEXT("RINGMODE")           },
    { PHONESTATE_RINGVOLUME            ,TEXT("RINGVOLUME")         },
    { PHONESTATE_HANDSETHOOKSWITCH     ,TEXT("HANDSETHOOKSWITCH")  },
    { PHONESTATE_HANDSETVOLUME         ,TEXT("HANDSETVOLUME")      },
    { PHONESTATE_HANDSETGAIN           ,TEXT("HANDSETGAIN")        },
    { PHONESTATE_SPEAKERHOOKSWITCH     ,TEXT("SPEAKERHOOKSWITCH")  },
    { PHONESTATE_SPEAKERVOLUME         ,TEXT("SPEAKERVOLUME")      },
    { PHONESTATE_SPEAKERGAIN           ,TEXT("SPEAKERGAIN")        },
    { PHONESTATE_HEADSETHOOKSWITCH     ,TEXT("HEADSETHOOKSWITCH")  },
    { PHONESTATE_HEADSETVOLUME         ,TEXT("HEADSETVOLUME")      },
    { PHONESTATE_HEADSETGAIN           ,TEXT("HEADSETGAIN")        },
    { PHONESTATE_SUSPEND               ,TEXT("SUSPEND")            },
    { PHONESTATE_RESUME                ,TEXT("RESUME")             },
    { PHONESTATE_DEVSPECIFIC           ,TEXT("DEVSPECIFIC")        },
    { PHONESTATE_REINIT                ,TEXT("REINIT")             },
    { PHONESTATE_CAPSCHANGE            ,TEXT("CAPSCHANGE")         },
    { PHONESTATE_REMOVED               ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS             ,TEXT("BUTTONS")            },
    { LINETERMMODE_LAMPS               ,TEXT("LAMPS")              },
    { LINETERMMODE_DISPLAY             ,TEXT("DISPLAY")            },
    { LINETERMMODE_RINGER              ,TEXT("RINGER")             },
    { LINETERMMODE_HOOKSWITCH          ,TEXT("HOOKSWITCH")         },
    { LINETERMMODE_MEDIATOLINE         ,TEXT("MEDIATOLINE")        },
    { LINETERMMODE_MEDIAFROMLINE       ,TEXT("MEDIAFROMLINE")      },
    { LINETERMMODE_MEDIABIDIRECT       ,TEXT("MEDIABIDIRECT")      },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aToneModes[] =
{
    { LINETONEMODE_CUSTOM              ,TEXT("CUSTOM")             },
    { LINETONEMODE_RINGBACK            ,TEXT("RINGBACK")           },
    { LINETONEMODE_BUSY                ,TEXT("BUSY")               },
    { LINETONEMODE_BEEP                ,TEXT("BEEP")               },
    { LINETONEMODE_BILLING             ,TEXT("BILLING")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER        ,TEXT("TRANSFER")           },
    { LINETRANSFERMODE_CONFERENCE      ,TEXT("CONFERENCE")         },
    { 0xffffffff                       ,TEXT("")                   }
};


LPTSTR
GetFlags(
    DWORD_PTR dwFlags,
    PLOOKUP   pLookup
    )
{
    int i;
    TCHAR buf[256];
    LPTSTR p = NULL;


    buf[0] = 0;

    for (i = 0; (dwFlags && (pLookup[i].dwVal != 0xffffffff)); i++) {
        if (dwFlags & pLookup[i].dwVal) {
            _tcscat( buf, pLookup[i].lpszVal );
            dwFlags = dwFlags & (~(DWORD_PTR)pLookup[i].dwVal);
        }
    }

    if (buf[0]) {
        p = (LPTSTR) MemAlloc( (_tcslen(buf) + 1) * sizeof(buf[1]) );
        if (p) {
            _tcscpy( p, buf );
        }
    }

    return p;
}


void
ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    )
{
    int       i;
    LPTSTR    lpszParam1 = NULL;
    LPTSTR    lpszParam2 = NULL;
    LPTSTR    lpszParam3 = NULL;
    TCHAR     MsgBuf[1024];

	DEBUG_FUNCTION_NAME(TEXT("ShowLineEvent"));



    MsgBuf[0] = 0;

    if (MsgStr) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("%s "), MsgStr );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwCallbackInstance=0x%08x "), dwCallbackInstance );

    for (i = 0; aMsgs[i].MsgId != 0xffffffff; i++) {
        if (dwMsg == aMsgs[i].MsgId) {
            break;
        }
    }

    if (aMsgs[i].MsgId == 0xffffffff) {
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("<unknown msg id = %d> : hLine=0x%08x, hCall=0x%08x "),
            dwMsg,
            htLine,
            htCall
            );
    } else {
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("%s : hLine=0x%08x, hCall=0x%08x "),
            aMsgs[i].Text,
            htLine,
            htCall
            );
    }

    if (aMsgs[i].LineMsg) {

        switch (dwMsg) {
            case LINE_ADDRESSSTATE:
                lpszParam2 = GetFlags( dwParam2, aAddressStates );
                break;

            case LINE_CALLINFO:
                lpszParam1 = GetFlags( dwParam1, aCallInfoStates );
                break;

            case LINE_CALLSTATE:
                lpszParam1 = GetFlags( dwParam1, aCallStates );
                break;

            case LINE_LINEDEVSTATE:
                lpszParam1 = GetFlags( dwParam1, aLineStates );
                break;
        }

    } else {

        switch (dwMsg) {
            case PHONE_BUTTON:
                lpszParam2 = GetFlags( dwParam2, aButtonModes );
                lpszParam3 = GetFlags( dwParam3, aButtonStates );
                break;

            case PHONE_STATE:
                lpszParam1 = GetFlags( dwParam1, aPhoneStates);
                break;
        }

    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam1=0x%08x"), dwParam1 );
    if (lpszParam1) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam1 );
    } else {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam2=0x%08x"), dwParam2 );
    if (lpszParam2) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam2 );
    } else {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam3=0x%08x"), dwParam3 );
    if (lpszParam3) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s)"), lpszParam3 );
    }

    DebugPrintEx(DEBUG_TAPI, TEXT("**%s"), MsgBuf);

    if (lpszParam1) {
        MemFree( lpszParam1 );
    }

    if (lpszParam2) {
        MemFree( lpszParam2 );
    }

    if (lpszParam3) {
        MemFree( lpszParam3 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\systray\monitor.h ===
#ifndef _INC_FAX_MONITOR_
#define _INC_FAX_MONITOR_

#include <windows.h>

//
// Fax Monitor dialog states
//
enum DeviceState {FAX_IDLE, FAX_RINGING, FAX_SENDING, FAX_RECEIVING};

//
// Status monitor log icons
//
enum eIconType
{
    LIST_IMAGE_NONE = 0,
    LIST_IMAGE_WARNING,
    LIST_IMAGE_ERROR,
    LIST_IMAGE_SUCCESS
};

//
// monitor.cpp
//

DWORD 
LoadAndFormatString (
    IN  DWORD     dwStringResourceId,
    OUT LPTSTR    lptstrFormattedString,
    IN  DWORD     dwOutStrSize,
    IN  LPCTSTR   lpctstrAdditionalParam = NULL
);
//
// Add string to the monitor dialog's events log
//
DWORD 
AddStatusMonitorLogEvent (
    IN  eIconType eIcon,
    IN  DWORD     dwStringResourceId,
    IN  LPCTSTR   lpctstrAdditionalParam = NULL,
    OUT LPTSTR    lptstrFormattedEvent = NULL,
    IN  DWORD     dwOutStrSize = 0
);

DWORD 
AddStatusMonitorLogEvent (
    eIconType eIcon,
    LPCTSTR    lpctstrString
);

void  
FreeMonitorDialogData (BOOL bShutdown = FALSE);

//
// Open the monitor dialog
//
DWORD OpenFaxMonitor(VOID);

DWORD UpdateMonitorData(HWND hDlg);

int   FaxMessageBox(HWND hWnd, DWORD dwTextID, UINT uType);

//
// Change state of the monitor dialog
//
void SetStatusMonitorDeviceState(DeviceState devState);


//
// fxsst.cpp
//

//
// configuration structure
//
struct CONFIG_OPTIONS 
{
    DWORD   dwMonitorDeviceId;      // Device ID to monitor
    BOOL    bSend;                  // Is monitored device configured to send faxes
    BOOL    bReceive;               // Is monitored device configured to receive faxes
    DWORD   dwManualAnswerDeviceId; // Manual answer device ID
    DWORD   dwAccessRights;         // User access rights
    DWORD   bNotifyProgress;        // Show notification icon during send/receive
    DWORD   bNotifyInCompletion;    // Show notification icon and baloons upon incoming job completion
    DWORD   bNotifyOutCompletion;   // Show notification icon and baloons upon outgoing job completion
    DWORD   bMonitorOnSend;         // Open monitor dialog upon outgoing job start
    DWORD   bMonitorOnReceive;      // Open monitor dialog upon incoming job start
    DWORD   bSoundOnRing;           // Play sound when manual answer line is ringing
    DWORD   bSoundOnReceive;        // Play sound when fax is received
    DWORD   bSoundOnSent;           // Play sound when fax is sent
    DWORD   bSoundOnError;          // Play sound when upon error
};

//
// connect to the fax server
//
BOOL Connect();

//
// Answer the incoming call
//
VOID AnswerTheCall();
DWORD CheckAnswerNowCapability (BOOL bForceReconnect, LPDWORD lpdwDeviceId = NULL);

//
// Abort current transmission
//
void OnDisconnect();

//
// Window handle to the status monitor dialog
//
extern HWND   g_hMonitorDlg;  

extern DeviceState  g_devState;

extern TCHAR        g_tszLastEvent[];


#endif // _INC_FAX_MONITOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains various utility functions.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:
    BoazF 24-May-1999 - Added GetDevStatus

--*/

#include "faxsvc.h"
#include "faxreg.h"
#include <comenum.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#pragma hdrstop

#ifdef EnterCriticalSection
    #undef EnterCriticalSection
#endif


#ifdef LeaveCriticalSection
    #undef LeaveCriticalSection
#endif


DWORDLONG g_dwLastUniqueId;


STRING_TABLE g_ServiceStringTable[] =
{
    { IDS_SVC_DIALING,                      FPS_DIALING,                          NULL },
    { IDS_SVC_SENDING,                      FPS_SENDING,                          NULL },
    { IDS_SVC_RECEIVING,                    FPS_RECEIVING,                        NULL },
    { IDS_COMPLETED,                        FPS_COMPLETED,                        NULL },
    { IDS_HANDLED,                          FPS_HANDLED,                          NULL },
    { IDS_BUSY,                             FPS_BUSY,                             NULL },
    { IDS_NO_ANSWER,                        FPS_NO_ANSWER,                        NULL },
    { IDS_BAD_ADDRESS,                      FPS_BAD_ADDRESS,                      NULL },
    { IDS_NO_DIAL_TONE,                     FPS_NO_DIAL_TONE,                     NULL },
    { IDS_DISCONNECTED,                     FPS_DISCONNECTED,                     NULL },
    { IDS_FATAL_ERROR,                      FPS_FATAL_ERROR,                      NULL },
    { IDS_NOT_FAX_CALL,                     FPS_NOT_FAX_CALL,                     NULL },
    { IDS_CALL_DELAYED,                     FPS_CALL_DELAYED,                     NULL },
    { IDS_CALL_BLACKLISTED,                 FPS_CALL_BLACKLISTED,                 NULL },
    { IDS_UNAVAILABLE,                      FPS_UNAVAILABLE,                      NULL },
    { IDS_AVAILABLE,                        FPS_AVAILABLE,                        NULL },
    { IDS_ABORTING,                         FPS_ABORTING,                         NULL },
    { IDS_ROUTING,                          FPS_ROUTING,                          NULL },
    { IDS_INITIALIZING,                     FPS_INITIALIZING,                     NULL },
    { IDS_SENDFAILED,                       FPS_SENDFAILED,                       NULL },
    { IDS_SENDRETRY,                        FPS_SENDRETRY,                        NULL },
    { IDS_BLANKSTR,                         FPS_BLANKSTR,                         NULL },
    { IDS_ROUTERETRY,                       FPS_ROUTERETRY,                       NULL },
    { IDS_CALL_COMPLETED,                   IDS_CALL_COMPLETED,                   NULL },
    { IDS_CALL_ABORTED,                     IDS_CALL_ABORTED,                     NULL },
    { IDS_ANSWERED,                         FPS_ANSWERED,                         NULL },
    { IDS_DR_SUBJECT,                       IDS_DR_SUBJECT,                       NULL },
    { IDS_DR_FILENAME,                      IDS_DR_FILENAME,                      NULL },
    { IDS_NDR_SUBJECT,                      IDS_NDR_SUBJECT,                      NULL },
    { IDS_NDR_FILENAME,                     IDS_NDR_FILENAME,                     NULL },
    { IDS_SERVICE_NAME,                     IDS_SERVICE_NAME,                     NULL },
    { IDS_NO_MAPI_LOGON,                    IDS_NO_MAPI_LOGON,                    NULL },
    { IDS_DEFAULT,                          IDS_DEFAULT,                          NULL },
    { IDS_FAX_LOG_CATEGORY_INIT_TERM,       IDS_FAX_LOG_CATEGORY_INIT_TERM,       NULL },
    { IDS_FAX_LOG_CATEGORY_OUTBOUND,        IDS_FAX_LOG_CATEGORY_OUTBOUND,        NULL },
    { IDS_FAX_LOG_CATEGORY_INBOUND,         IDS_FAX_LOG_CATEGORY_INBOUND,         NULL },
    { IDS_FAX_LOG_CATEGORY_UNKNOWN,         IDS_FAX_LOG_CATEGORY_UNKNOWN,         NULL },
    { IDS_SET_CONFIG,                       IDS_SET_CONFIG,                       NULL },
    { IDS_PARTIALLY_RECEIVED,               IDS_PARTIALLY_RECEIVED,               NULL },
    { IDS_FAILED_SEND,                      IDS_FAILED_SEND,                      NULL },
    { IDS_FAILED_RECEIVE,                   IDS_FAILED_RECEIVE,                   NULL },
    { IDS_CANCELED,                         IDS_CANCELED,                         NULL },
    { IDS_RECEIPT_RECIPIENT_NUMBER,         IDS_RECEIPT_RECIPIENT_NUMBER,         NULL },
    { IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH,   IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH,   NULL },
    { IDS_RECEIPT_RECIPIENT_NAME,           IDS_RECEIPT_RECIPIENT_NAME,           NULL },
    { IDS_RECEIPT_RECIPIENT_NAME_WIDTH,     IDS_RECEIPT_RECIPIENT_NAME_WIDTH,     NULL },
    { IDS_RECEIPT_START_TIME,               IDS_RECEIPT_START_TIME,               NULL },
    { IDS_RECEIPT_START_TIME_WIDTH,         IDS_RECEIPT_START_TIME_WIDTH,         NULL },
    { IDS_RECEIPT_END_TIME,                 IDS_RECEIPT_END_TIME,                 NULL },
    { IDS_RECEIPT_END_TIME_WIDTH,           IDS_RECEIPT_END_TIME_WIDTH,           NULL },
    { IDS_RECEIPT_RETRIES,                  IDS_RECEIPT_RETRIES,                  NULL },
    { IDS_RECEIPT_RETRIES_WIDTH,            IDS_RECEIPT_RETRIES_WIDTH,            NULL },
    { IDS_RECEIPT_LAST_ERROR,               IDS_RECEIPT_LAST_ERROR,               NULL },
    { IDS_RECEIPT_LAST_ERROR_WIDTH,         IDS_RECEIPT_LAST_ERROR_WIDTH,         NULL },
    { IDS_COMPLETED_RECP_LIST_HEADER,       IDS_COMPLETED_RECP_LIST_HEADER,       NULL },
    { IDS_FAILED_RECP_LIST_HEADER,          IDS_FAILED_RECP_LIST_HEADER,          NULL },
    { IDS_RECEIPT_NO_CP_AND_BODY_ATTACH,    IDS_RECEIPT_NO_CP_AND_BODY_ATTACH,    NULL },
    { IDS_RECEIPT_NO_CP_ATTACH,             IDS_RECEIPT_NO_CP_ATTACH,             NULL },
    { IDS_HTML_RECEIPT_HEADER,              IDS_HTML_RECEIPT_HEADER,              NULL }
};

const DWORD gc_dwCountServiceStringTable  = (sizeof(g_ServiceStringTable)/sizeof(g_ServiceStringTable[0]));



#ifdef DBG
//*********************************************************************************
//* Name:   DebugDateTime()
//* Author:
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Accepts a 64 bit file time and generates a string with its content.
//*     The format is Date Time (GMT). Date and Time format are system settings
//*     specific.
//* PARAMETERS:
//*     [IN]    DWORD DateTime
//*                 64 bit file time value
//*     [OUT]   LPTSTR lptstrDateTime
//*                 A pointer to a string buffer where the resulting string will
//*                 be placed.
//*     [IN]    UINT cchstrDateTime
//*                 The number of TCHARs in the lptstrDateTime buffer.
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL DebugDateTime( IN DWORDLONG DateTime,
                    OUT LPTSTR lptstrDateTime,
                    IN UINT cchstrDateTime)
{

    SYSTEMTIME SystemTime;
    TCHAR DateBuffer[256] = TEXT("NULL");
    TCHAR TimeBuffer[256] = TEXT("NULL");

    DEBUG_FUNCTION_NAME(TEXT("DebugDateTime"));

    if (!FileTimeToSystemTime( (LPFILETIME) &DateTime, &SystemTime ))
    {
        return FALSE;
    }

    GetY2KCompliantDate (
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        DateBuffer,
        sizeof(DateBuffer)/sizeof(DateBuffer[0])
        );

    FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    HRESULT hRc = StringCchPrintf(lptstrDateTime, cchstrDateTime,
                                  TEXT("%s %s (GMT)"),DateBuffer, TimeBuffer);

    if(FAILED(hRc))
    {
        ASSERT_FALSE
        return FALSE;
    }
                 

    return TRUE;

}

VOID
DebugPrintDateTime(
    LPTSTR Heading,
    DWORDLONG DateTime
    )
{
    SYSTEMTIME SystemTime;
    TCHAR DateBuffer[256] = TEXT("NULL");
    TCHAR TimeBuffer[256] = TEXT("NULL");

    if (!FileTimeToSystemTime( (LPFILETIME) &DateTime, &SystemTime ))
    {
        return;
    }

    GetY2KCompliantDate (
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        DateBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    if (Heading) {
        DebugPrint((TEXT("%s %s %s (GMT)"), Heading, DateBuffer, TimeBuffer));
    } else {
        DebugPrint((TEXT("%s %s (GMT)"), DateBuffer, TimeBuffer));
    }

}


//*********************************************************************************
//* Name:   SystemTimeToStr()
//* Author:
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Accepts a pointer to a system time structure and generates a string with its content.
//*     The format is Date Time (GMT). Date and Time format are system settings
//*     specific.
//* PARAMETERS:
//*     [IN]    SYSTEMTIME *  lptmTime
//*                 Pointer to SYSTEMTIME structure to convet to string
//*     [OUT]   LPTSTR lptstrDateTime
//*                 A pointer to a string buffer where the resulting string will
//*                 be placed.
//*     [IN]    UINT cchstrDateTime
//*                 The number of TCHARs in the lptstrDateTime out buffer.
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL SystemTimeToStr( IN const SYSTEMTIME *  lptmTime,
                      OUT LPTSTR lptstrDateTime,
                      IN UINT cchstrDateTime)
{

    TCHAR DateBuffer[256] = TEXT("NULL");
    TCHAR TimeBuffer[256] = TEXT("NULL");

    GetY2KCompliantDate (
        LOCALE_SYSTEM_DEFAULT,
        0,
        lptmTime,
        DateBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        lptmTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    HRESULT hRc = StringCchPrintf(lptstrDateTime, cchstrDateTime,
                          TEXT("%s %s (GMT)"),DateBuffer, TimeBuffer);
    if(FAILED(hRc))
    {
        ASSERT_FALSE
        return FALSE;
    }

    return TRUE;

}

#endif
BOOL
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    TCHAR Buffer[512];
    DWORD ec = ERROR_SUCCESS;

    for (i = 0; i < gc_dwCountServiceStringTable; i++)
    {
        if (LoadString(
                g_hResource,
                g_ServiceStringTable[i].ResourceId,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR)
                ))
        {
            g_ServiceStringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) );
            if (!g_ServiceStringTable[i].String)
            {
                ec = ERROR_OUTOFMEMORY;
                goto Error;
            }
            else
            {
                _tcscpy( g_ServiceStringTable[i].String, Buffer );
            }
        }
        else
        {
            ec = GetLastError();
            goto Error;
        }
    }
    return TRUE;

Error:
    Assert (ERROR_SUCCESS != ec);

    for (i = 0; i < gc_dwCountServiceStringTable; i++)
    {
        MemFree (g_ServiceStringTable[i].String);
        g_ServiceStringTable[i].String = NULL;
    }

    SetLastError(ec);
    return FALSE;
}



LPTSTR
GetString(
    DWORD InternalId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<gc_dwCountServiceStringTable; i++) {
        if (g_ServiceStringTable[i].InternalId == InternalId) {
            return g_ServiceStringTable[i].String;
        }
    }

    return NULL;
}


BOOL
InitializeFaxQueue(
    PREG_FAX_SERVICE pFaxReg
    )
/*++

Routine Description:

    Initializes the queue directory that fax will use.
    The administrator can configure the queue directory using the registry.
    This function does not create the queue directory. 

Arguments:

    pFaxReg - pointer to the fax registry data.

Return Value:

    TRUE if successful. modifies path globals

--*/
{
    DWORD   dwRet;
    WCHAR   FaxDir[MAX_PATH] = {0};
    DEBUG_FUNCTION_NAME(TEXT("InitializeFaxQueue"));

    SetGlobalsFromRegistry( pFaxReg ); 	// Can not fail.
                               			// sets the following globals from registry -
                               			//     g_dwFaxSendRetries        
                               			//     g_dwFaxSendRetryDelay
                               			//     g_dwFaxDirtyDays
                               			//     g_dwNextJobId
                               			//     g_dwQueueState
                               			//     g_fFaxUseDeviceTsid
                               			//     g_fFaxUseBranding
                               			//     g_fServerCp
                               			//     g_StartCheapTime
                               			//     g_StopCheapTime
                               			//

    if (NULL != pFaxReg->lptstrQueueDir)
    {
        //
        // The administrator changed the queue directory
        //
        wcsncpy (g_wszFaxQueueDir, pFaxReg->lptstrQueueDir, ARR_SIZE(g_wszFaxQueueDir)-1);      
    }
    else
    {
        //
        // Get the default queue directory
        //
        if (!GetSpecialPath( CSIDL_COMMON_APPDATA, FaxDir, ARR_SIZE(FaxDir) ) )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Couldn't GetSpecialPath, ec = %d\n"),
                GetLastError());
            return FALSE;
        }

        if (wcslen(FaxDir) + wcslen(FAX_QUEUE_DIR) + 1 >= ARR_SIZE(g_wszFaxQueueDir)) // 1 for '\'
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Queue folder exceeds MAX_PATH"));
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }

        _sntprintf( g_wszFaxQueueDir, 
                    ARR_SIZE(g_wszFaxQueueDir) -1,
                    TEXT("%s\\%s"),
                    FaxDir,
                    FAX_QUEUE_DIR);

    }
	g_wszFaxQueueDir[ARR_SIZE(g_wszFaxQueueDir) -1] = _T('\0');

    dwRet = IsValidFaxFolder(g_wszFaxQueueDir);
    if(ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR,
                        TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                        g_wszFaxQueueDir,
                        dwRet);
        SetLastError(dwRet);
    }
    return (dwRet == ERROR_SUCCESS);
}


//*********************************************************************************
//* Name:   GenerateUniqueQueueFile()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Generates a unique QUEUE file in the queue directory.
//*     returns a UNIQUE id for the file based on the job type. (see the remarks
//*     section for more details).
//* PARAMETERS:
//*     [IN]    DWORD dwJobType
//*         The job type for which a file is to be generated
//*     [OUT]       LPTSTR lptstrFileName
//*         A pointer to the buffer where the resulting file name (including path)
//*         will be placed.
//*     [IN]        DWORD  dwFileNameSize
//*         The size of the output file name buffer.
//* RETURN VALUE:
//*      If successful the function returns A DWORDLONG with the unique id for the file.
//*      On failure it returns 0.
//* REMARKS:
//*     The generated unique id is derived from the unique name of the generated
//*     file (which is only unique within files with the same extension) and the
//*     type of the job for which the file was generated.
//*     Thus it is ensured that there can be no two jobs with the same unique id
//*     although there can be two jobs with the same unique file name which are
//*     different only by the file extension.
//*     The 64 bit unique file id is the result of SystemTimeToFileTime.
//*     This is the number of 100 nano seconds intervals since 1-1-1601
//*     In year 3000 it will be approximately 5BC826A600000 i.e. 52 bites long.
//      We use the left most 8 bits for the job type. Leaving extra 4 more bits
//*     |-----------------3----------------2----------------1----------------|
//*     |FEDCBA98|76543210|FEDCBA9876543210|FEDCBA9876543210|FEDCBA9876543210|
//*     |-----------------|----------------|----------------|----------------|
//*     | JobType|          56 LSB bits of  SystemTimeToFileTime             |
//*     |-----------------|----------------|----------------|----------------|
//*     Job Type:
//*         The JT_* value of the job type.
//*********************************************************************************
DWORDLONG GenerateUniqueQueueFile(
    DWORD dwJobType,
    LPTSTR lptstrFileName,
    DWORD  dwFileNameSize)
{
    DWORD dwUniqueIdHigh;
    DWORD dwUniqueIdLow;
    DWORDLONG dwlUniqueId = 0 ;
    FILETIME FileTime;
    SYSTEMTIME SystemTime;
    LPTSTR lpszExt=NULL;

      DEBUG_FUNCTION_NAME(TEXT("GenerateUniqueQueueFile"));

    EnterCriticalSection(&g_csUniqueQueueFile);

    GetSystemTime( &SystemTime ); // returns VOID
    if (!SystemTimeToFileTime( &SystemTime, &FileTime ))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SystemTimeToFileTime() failed (ec: %ld)"), GetLastError());
        goto Error;
    }

    dwlUniqueId = MAKELONGLONG(FileTime.dwLowDateTime, FileTime.dwHighDateTime);

    dwlUniqueId = dwlUniqueId >> 8;
    if(dwlUniqueId == g_dwLastUniqueId)
    {
        //
        // Not enough time has passed since the last generation to ensure
        // out time based unique id algorithm will produce a unique id
        // (in case the already generated file was deleted from the queue directory).
        // Let some more time pass to ensure uniqueness.
        //
        Sleep(1);
    }
    //
    // Note that dwlUniqueId might be smaller than g_dwLastUniqueId if the system time was moved
    // back during the service operation.
    //
    switch (dwJobType)
    {
            case JT_SEND:
            {
                lpszExt=TEXT("FQE");
            }
            break;

        case JT_BROADCAST:
            {
                lpszExt=TEXT("FQP");
            }
            break;

        case JT_RECEIVE:
            {
                lpszExt=FAX_TIF_FILE_EXT;
            }
            break;
        case JT_ROUTING:
            {
                lpszExt=TEXT("FQR");
            }
            break;
        default:
            Assert(FALSE);
    }

    dwlUniqueId=GenerateUniqueFileName(
        g_wszFaxQueueDir,
        lpszExt,
        lptstrFileName,
        dwFileNameSize);
    if (!dwlUniqueId) {
        goto Error;
    }

    g_dwLastUniqueId = dwlUniqueId;

    dwUniqueIdHigh = (DWORD) (dwlUniqueId >> 32);
    dwUniqueIdLow = (DWORD) dwlUniqueId;

    //
    // Set the 8 MSB bits to zero.
    //
    dwUniqueIdHigh &= 0x00FFFFFF;

    //
    // skip past the 56 bits of SystemTimeToFileTime and put the job type at the high 8 MSB bits.
    //
    dwUniqueIdHigh |= (dwJobType << 24) ;


    dwlUniqueId = MAKELONGLONG(dwUniqueIdLow,dwUniqueIdHigh);

Error:
    LeaveCriticalSection(&g_csUniqueQueueFile);
    return dwlUniqueId;
}


//*********************************************************************************
//* Name:   GenerateUniqueArchiveFileName()
//* Author: Oded Sacher
//* Date:   7/11/99
//*********************************************************************************
//* DESCRIPTION:
//*     Generates a unique file name and creates an archived file.
//* PARAMETERS:
//*     [IN]    LPTSTR Directory
//*         The path where the file is to be created.
//*     [OUT]    LPTSTR FileName
//*         The buffer where the resulting file name (including path) will be
//*         placed. FileName size must not exceed MAX_PATH
//*     [IN]     UINT cchFileName
//*         The size of FileName buffer in TCHARs.
//*     [IN]     DWORDLONG JobId
//*         Input for the file name.
//*     [IN]    LPTSTR lptstrUserSid
//*         Input for the file name.
//* RETURN VALUE:
//*      If successful the function returns TRUE.
//* REMARKS:
//*    FileName size must not exceed MAX_PATH
BOOL
GenerateUniqueArchiveFileName(
    IN LPTSTR Directory,
    OUT LPTSTR FileName,
    IN UINT cchFileName,
    IN DWORDLONG JobId,
    IN LPTSTR lptstrUserSid
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GenerateUniqueArchiveFileName"));
    
    if(!Directory || Directory[0] == TEXT('\0'))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Archive folder directory should be supplied"));
        ASSERT_FALSE
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (Directory[_tcslen(Directory)-1] == TEXT('\\')) {
        Directory[_tcslen(Directory)-1] = 0;
    }

    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hRc = E_FAIL;

    if (lptstrUserSid != NULL)
    {
        hRc = StringCchPrintf(  FileName,
                                cchFileName,
                                TEXT("%s\\%s$%I64x.%s"),
                                Directory,
                                lptstrUserSid,
                                JobId,
                                FAX_TIF_FILE_EXT);
    }
    else
    {
        hRc = StringCchPrintf(  FileName,
                                cchFileName,
                                TEXT("%s\\%I64x.%s"),
                                Directory,
                                JobId,
                                FAX_TIF_FILE_EXT
                                );
    }

    if(FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("File Name exceeded buffer length"));
        SetLastError(HRESULT_CODE(hRc));
        return FALSE;
    }

    hFile = SafeCreateFile(
        FileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateFile Failed, err : %ld"),
                     GetLastError());
        return FALSE;
    }

    CloseHandle( hFile );
    return TRUE;
}



DWORD
MapFSPIJobStatusToEventId(
    LPCFSPI_JOB_STATUS lpcFSPIJobStatus
    )
{
    DEBUG_FUNCTION_NAME(TEXT("MapFSPIJobStatusToEventId"));
    DWORD EventId = 0;

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("lpcFSPIJobStatus->dwJobStatus: 0x%08X lpcFSPIJobStatus->dwExtendedStatus: 0x%08X"),
        lpcFSPIJobStatus->dwJobStatus,
        lpcFSPIJobStatus->dwExtendedStatus
        );



    switch (lpcFSPIJobStatus->dwJobStatus)
    {
        case FSPI_JS_INPROGRESS:
        {
            switch( lpcFSPIJobStatus->dwExtendedStatus) {
                case FSPI_ES_INITIALIZING:
                    EventId = FEI_INITIALIZING;
                    break;
                case FSPI_ES_DIALING:
                    EventId = FEI_DIALING;
                    break;
                case FSPI_ES_TRANSMITTING:
                    EventId = FEI_SENDING;
                    break;
                case FSPI_ES_RECEIVING:
                    EventId = FEI_RECEIVING;
                    break;
                case FSPI_ES_HANDLED:
                    EventId = FEI_HANDLED;
                    break;
                case FSPI_ES_ANSWERED:
                    EventId = FEI_ANSWERED;
                    break;
                default:
                    //
                    // In W2K Fax a proprietry code generated an event with EventId ==0
                    //
                    EventId = 0;
                    break;
            }
        }
        break;

        case FSPI_JS_COMPLETED:
            EventId = FEI_COMPLETED;
            break;

        case FSPI_JS_FAILED_NO_RETRY:
        case FSPI_JS_FAILED:
        case FSPI_JS_RETRY:
        case FSPI_JS_DELETED:
            switch( lpcFSPIJobStatus->dwExtendedStatus)
            {
                case FSPI_ES_LINE_UNAVAILABLE:
                    EventId = FEI_LINE_UNAVAILABLE;
                break;
                case FSPI_ES_BUSY:
                    EventId = FEI_BUSY;
                    break;
                case FSPI_ES_NO_ANSWER:
                    EventId = FEI_NO_ANSWER;
                    break;
                case FSPI_ES_BAD_ADDRESS:
                    EventId = FEI_BAD_ADDRESS;
                    break;
                case FSPI_ES_NO_DIAL_TONE:
                    EventId = FEI_NO_DIAL_TONE;
                    break;
                case FSPI_ES_DISCONNECTED:
                    EventId = FEI_DISCONNECTED;
                    break;
                case FSPI_ES_FATAL_ERROR:
                    EventId = FEI_FATAL_ERROR;
                    break;
                case FSPI_ES_NOT_FAX_CALL:
                    EventId = FEI_NOT_FAX_CALL;
                    break;
                case FSPI_ES_CALL_DELAYED:
                    EventId = FEI_CALL_DELAYED;
                    break;
                case FSPI_ES_CALL_BLACKLISTED:
                    EventId = FEI_CALL_BLACKLISTED;
                    break;
                default:
                    //
                    // In W2K Fax a proprietry code generated an event with EventId ==0
                    //
                    EventId = 0;
                    break;

            }
            break;

        case FSPI_JS_ABORTED:
        case FSPI_JS_ABORTING:
            EventId = FEI_ABORTING;
            break;

        case FSPI_JS_UNKNOWN:
        case FSPI_JS_RESUMING:
        case FSPI_JS_SUSPENDED:
        case FSPI_JS_SUSPENDING:        
            //
            // No legacy notification for these states
            //
            EventId = 0;
            break;


        default:
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid FSPI_JS: 0x%08X"),
                lpcFSPIJobStatus->dwJobStatus);
            Assert(FSPI_JS_ABORTED == lpcFSPIJobStatus->dwJobStatus); // ASSERT_FALSE
            break;
    }

    return EventId;

}


void
FaxLogSend(
    const JOB_QUEUE * lpcJobQueue, BOOL bRetrying
    )
/*++

Routine Description:

    Log a fax send event.

Arguments:
    lpcJobQueue  - Pointer to the recipient job to log send information for.
                  (It must be in a running state).

Return Value:

    VOID

--*/


{
    DWORD Level;
    DWORD FormatId;
    TCHAR PageCountStr[64];
    TCHAR TimeStr[128];
    BOOL fLog = TRUE;
    TCHAR strJobID[20]={0};
    PJOB_ENTRY lpJobEntry;

    Assert(lpcJobQueue);
    lpJobEntry = lpcJobQueue->JobEntry;
    Assert(lpJobEntry);

    //
    //  Convert Job ID into a string. (the string is 18 TCHARs long !!!)
    //
    _sntprintf(strJobID,ARR_SIZE(strJobID)-1,TEXT("0x%016I64x"), lpcJobQueue->UniqueId);

    FormatElapsedTimeStr(
        (FILETIME*)&lpJobEntry->ElapsedTime,
        TimeStr,
        ARR_SIZE(TimeStr)
        );
    _ltot((LONG) lpJobEntry->FSPIJobStatus.dwPageCount, PageCountStr, 10);
    if ( FSPI_JS_COMPLETED == lpJobEntry->FSPIJobStatus.dwJobStatus ) {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MAX,
            10,
            MSG_FAX_SEND_SUCCESS,
            lpcJobQueue->SenderProfile.lptstrName,
            lpcJobQueue->SenderProfile.lptstrBillingCode,
            lpcJobQueue->SenderProfile.lptstrCompany,
            lpcJobQueue->SenderProfile.lptstrDepartment,
            lpJobEntry->FSPIJobStatus.lpwstrRemoteStationId,
            PageCountStr,
            TimeStr,
            lpJobEntry->LineInfo->DeviceName,
            strJobID,
            lpcJobQueue->lpParentJob->UserName
            );
		return;
    }
    else
    {
        if (FSPI_JS_ABORTED == lpJobEntry->FSPIJobStatus.dwJobStatus )
        {
                Level = FAXLOG_LEVEL_MAX;
                FormatId = MSG_FAX_SEND_USER_ABORT;
        }
        else if (lstrlen(lpJobEntry->ExStatusString))
		{
			//
			// We have a FSP proprietary extended status.
			//
			Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
			FormatId = bRetrying ? MSG_FAX_PROPRIETARY_RETRY : MSG_FAX_PROPRIETARY_ABORT;
			FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                Level,
                8,
                FormatId,
				lpJobEntry->ExStatusString,
                lpcJobQueue->SenderProfile.lptstrName,
                lpcJobQueue->SenderProfile.lptstrBillingCode,
                lpcJobQueue->SenderProfile.lptstrCompany,
                lpcJobQueue->SenderProfile.lptstrDepartment,
                lpJobEntry->LineInfo->DeviceName,
                strJobID,
                lpcJobQueue->lpParentJob->UserName
                );
			return;
		}
		else
        {
			//
			// well known extended status
			//
            switch (lpJobEntry->FSPIJobStatus.dwExtendedStatus)
            {
                case FSPI_ES_FATAL_ERROR:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_FATAL_RETRY : MSG_FAX_SEND_FATAL_ABORT;
                    break;
                case FSPI_ES_NO_DIAL_TONE:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_NDT_RETRY : MSG_FAX_SEND_NDT_ABORT;
                    break;
                case FSPI_ES_NO_ANSWER:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_NA_RETRY : MSG_FAX_SEND_NA_ABORT;
                    break;
                case FSPI_ES_DISCONNECTED:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_INTERRUPT_RETRY : MSG_FAX_SEND_INTERRUPT_ABORT;
                    break;
                case FSPI_ES_NOT_FAX_CALL:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_NOTFAX_RETRY : MSG_FAX_SEND_NOTFAX_ABORT;
                    break;
                case FSPI_ES_BUSY:
                    Level = bRetrying ? FAXLOG_LEVEL_MAX : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_BUSY_RETRY : MSG_FAX_SEND_BUSY_ABORT;
                    break;
                case FSPI_ES_CALL_BLACKLISTED:
                    Level = FAXLOG_LEVEL_MIN;
                    FormatId = MSG_FAX_CALL_BLACKLISTED_ABORT;
                    break;
                case FSPI_ES_CALL_DELAYED:
                    Level = FAXLOG_LEVEL_MIN;
                    FormatId = MSG_FAX_CALL_DELAYED_ABORT;
                    break;
                case FSPI_ES_BAD_ADDRESS:
                    Level = FAXLOG_LEVEL_MIN;
                    FormatId = MSG_FAX_BAD_ADDRESS_ABORT;
                    break;
                default:
                    fLog = FALSE;
            }
        }
        if(fLog)
        {
            FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                Level,
                7,
                FormatId,
                lpcJobQueue->SenderProfile.lptstrName,
                lpcJobQueue->SenderProfile.lptstrBillingCode,
                lpcJobQueue->SenderProfile.lptstrCompany,
                lpcJobQueue->SenderProfile.lptstrDepartment,
                lpJobEntry->LineInfo->DeviceName,
                strJobID,
                lpcJobQueue->lpParentJob->UserName
                );
        }
    }
	return;
}



DWORD MyGetFileSize(LPCTSTR FileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD sizelow=0, sizehigh=0;
    DWORD ec = ERROR_SUCCESS;

    hFile = SafeCreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    sizelow = GetFileSize(hFile,&sizehigh);
    if (sizelow == 0xFFFFFFFFF)
    {
        ec = GetLastError();
        sizelow = 0;
    }
    else if (sizehigh != 0)
    {
        sizelow=0xFFFFFFFF;
    }

    CloseHandle(hFile);
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return sizelow;
}


LPCWSTR szCsClients = L"g_CsClients";
LPCWSTR szCsHandleTable = L"g_CsHandleTable";
LPCWSTR szCsJob = L"g_CsJob";
LPCWSTR szCsLine = L"g_CsLine";
LPCWSTR szCsPerfCounters = L"g_CsPerfCounters";
LPCWSTR szCsQueue = L"g_CsQueue";
LPCWSTR szCsRouting = L"g_CsRouting";
LPCWSTR szCsConfig = L"g_CsConfig";
LPCWSTR szCsInboundActivityLogging = L"g_CsInboundActivityLogging";
LPCWSTR szCsOutboundActivityLogging = L"g_CsOutboundActivityLogging";
LPCWSTR szCsActivity = L"g_CsActivity";
LPCWSTR szCsUnknown = L"Other CS";

LPCWSTR GetSzCs(
    LPCRITICAL_SECTION cs
    )
{



    if (cs == &g_CsClients) {
        return szCsClients;
    } else if (cs == &g_CsHandleTable) {
        return szCsHandleTable;
    } else if (cs == &g_CsLine) {
        return szCsLine;
    } else if (cs == &g_CsJob) {
        return szCsJob;
    } else if (cs == &g_CsPerfCounters) {
        return szCsPerfCounters;
    } else if (cs == &g_CsQueue) {
        return szCsQueue;
    } else if (cs == &g_CsRouting) {
        return szCsRouting;
    } else if (cs == &g_CsConfig) {
        return szCsConfig;
    } else if (cs == &g_CsInboundActivityLogging) {
        return szCsInboundActivityLogging;
    } else if (cs == &g_CsOutboundActivityLogging) {
        return szCsOutboundActivityLogging;
    } else if (cs == &g_CsActivity) {
        return szCsActivity;
    }

    return szCsUnknown;
}


#if DBG
VOID AppendToLogFile(
    LPWSTR String
    )
{
    DWORD BytesWritten;
    LPSTR AnsiBuffer = UnicodeStringToAnsiString( String );

    if (g_hCritSecLogFile != INVALID_HANDLE_VALUE) {
        WriteFile(g_hCritSecLogFile,(LPBYTE)AnsiBuffer,strlen(AnsiBuffer) * sizeof(CHAR),&BytesWritten,NULL);
    }

    MemFree(AnsiBuffer);

}

VOID AppendFuncToLogFile(
    LPCRITICAL_SECTION cs,
    LPTSTR szFunc,
    DWORD line,
    LPTSTR file,
    PDBGCRITSEC CritSec
    )
{
    WCHAR Buffer[300];
    LPWSTR FileName;
    LPCWSTR szcs = GetSzCs(cs);

    FileName = wcsrchr(file,'\\');
    if (!FileName) {
        FileName = TEXT("Unknown  ");
    } else {
        FileName += 1;
    }
    if (CritSec) {
        wsprintf(Buffer,TEXT("%d\t%p\t%s\t%s\t%s\t%d\t%d\r\n"),
                 GetTickCount(),
                 (PULONG_PTR)cs,
                 szcs,
                 szFunc,
                 FileName,
                 line,
                 CritSec->ReleasedTime - CritSec->AquiredTime);
    } else {
        wsprintf(Buffer,TEXT("%d\t%p\t%s\t%s\t%s\t%d\r\n"),GetTickCount(),(PULONG_PTR)cs,szcs,szFunc, FileName,line);
    }

    AppendToLogFile( Buffer );

    return;

}

VOID pEnterCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    PDBGCRITSEC pCritSec = (PDBGCRITSEC)MemAlloc(sizeof(DBGCRITSEC));
    if( pCritSec == NULL )
    {
        // memory allocation failed, do the actual work and exit...
        EnterCriticalSection(cs);
        return;
    }

    pCritSec->CritSecAddr = (ULONG_PTR) cs;
    pCritSec->AquiredTime = GetTickCount();
    pCritSec->ThreadId = GetCurrentThreadId();


    EnterCriticalSection(&g_CsCritSecList);

    InsertHeadList( &g_CritSecListHead, &pCritSec->ListEntry );
    AppendFuncToLogFile(cs,TEXT("EnterCriticalSection"), line, file, NULL );
    //
    // check ordering of threads. ALWAYS aquire g_CsLine before aquiring g_CsQueue!!!
    //
    if ((LPCRITICAL_SECTION)cs == (LPCRITICAL_SECTION)&g_CsQueue)
    {
        if ((DWORD)GetCurrentThreadId() != PtrToUlong(g_CsJob.OwningThread()))
        {
            WCHAR DebugBuf[300];
            wsprintf(DebugBuf, TEXT("%d : Attempting to aquire g_CsQueue (thread %x) without aquiring g_CsJob (thread %p, lock count %x) first, possible deadlock!\r\n"),
                         GetTickCount(),
                         GetCurrentThreadId(),
                         g_CsJob.OwningThread(),
                         g_CsJob.LockCount());
            AppendToLogFile( DebugBuf );
        }
    }

    LeaveCriticalSection(&g_CsCritSecList);

    EnterCriticalSection(cs);
}

VOID pLeaveCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    PDBGCRITSEC CritSec = NULL;
    BOOL fRemove = FALSE;

    EnterCriticalSection(&g_CsCritSecList);

    PLIST_ENTRY Next = g_CritSecListHead.Flink;


    while ((ULONG_PTR)Next != (ULONG_PTR) &g_CritSecListHead)
    {
        CritSec = CONTAINING_RECORD( Next, DBGCRITSEC, ListEntry );
        if ((ULONG_PTR)CritSec->CritSecAddr == (ULONG_PTR) cs &&
            ( GetCurrentThreadId() == CritSec->ThreadId ) )
        {
            CritSec->ReleasedTime = GetTickCount();
            fRemove = TRUE;
            break;
        }
        Next = Next->Flink;
    }

    AppendFuncToLogFile(cs,TEXT("LeaveCriticalSection"),line, file, CritSec );

    if (fRemove) {
        RemoveEntryList( &CritSec->ListEntry );
        MemFree( CritSec );
    }

    LeaveCriticalSection(&g_CsCritSecList);


    LeaveCriticalSection(cs);
}

BOOL
ThreadOwnsCs(
    VOID
    )
{
    PDBGCRITSEC pCritSec = NULL;
    DWORD dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&g_CsCritSecList);
    PLIST_ENTRY Next = g_CritSecListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR) &g_CritSecListHead)
    {
        pCritSec = CONTAINING_RECORD( Next, DBGCRITSEC, ListEntry );
        if (dwThreadId == pCritSec->ThreadId )
        {
            LeaveCriticalSection(&g_CsCritSecList);
            return TRUE;
        }
        Next = Next->Flink;
    }

    LeaveCriticalSection(&g_CsCritSecList);
    return FALSE;
}


#endif


DWORD
ValidateTiffFile(
    LPCWSTR TifFileName
    )
{

    HANDLE hTiff;
    DWORD rc = ERROR_SUCCESS;
    TIFF_INFO TiffInfo;

    //
    // Validate tiff format
    //
    hTiff = TiffOpen( (LPWSTR)TifFileName, &TiffInfo, FALSE, FILLORDER_MSB2LSB );
    if (!hTiff) {
        rc = GetLastError();
        return rc;
    }

    TiffClose( hTiff );
    return ERROR_SUCCESS;
}

//
// Function:
//      LegacyJobStatusToStatus
//
// Parameters:
//      dwLegacyStatus - Legacy job status (FS_*)
//      pdwStatus - A pointer to a DWORD that receives the new job status.
//      pdwExtendedStatus - A pointer to a DWORD that receives the extended
//          job status.
//
// Return Value:
//      If the function succeeds, the return value is ERROR_SUCCESS, else the
//      return value is an error code.
//
// Description:
//      The function converts legacy FSP job status values to new job status.
//      
//
DWORD
LegacyJobStatusToStatus(
    DWORD dwLegacyStatus,
    PDWORD pdwStatus,
    PDWORD pdwExtendedStatus,
    PBOOL  pbPrivateStatusCode)
{

    Assert(pdwStatus);
    Assert(pdwExtendedStatus);
    Assert(pbPrivateStatusCode);
    *pbPrivateStatusCode = FALSE;

    switch (dwLegacyStatus)
    {
    case FS_INITIALIZING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_INITIALIZING;
        break;

    case FS_DIALING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_DIALING;
        break;

    case FS_TRANSMITTING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_TRANSMITTING;
        break;

    case FS_RECEIVING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_RECEIVING;
        break;

    case FS_COMPLETED:
        *pdwStatus = FSPI_JS_COMPLETED;
        *pdwExtendedStatus = FSPI_ES_CALL_COMPLETED;
        break;

    case FS_HANDLED:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_HANDLED;
        break;

    case FS_LINE_UNAVAILABLE:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_LINE_UNAVAILABLE;
        break;

    case FS_BUSY:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_BUSY;
        break;

    case FS_NO_ANSWER:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_NO_ANSWER;
        break;

    case FS_BAD_ADDRESS:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_BAD_ADDRESS;
        break;

    case FS_NO_DIAL_TONE:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_NO_DIAL_TONE;
        break;

    case FS_DISCONNECTED:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_DISCONNECTED;
        break;

    case FS_FATAL_ERROR:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_FATAL_ERROR;
        break;

    case FS_NOT_FAX_CALL:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_NOT_FAX_CALL;
        break;

    case FS_CALL_DELAYED:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_CALL_DELAYED;
        break;

    case FS_CALL_BLACKLISTED:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_CALL_BLACKLISTED;
        break;

    case FS_USER_ABORT:
        *pdwStatus = FSPI_JS_ABORTED;
        *pdwExtendedStatus = FSPI_ES_CALL_ABORTED;
        break;

    case FS_ANSWERED:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_ANSWERED;
        break;

    default:
        //
        // The FSP reports a status code which is not one of the predefined status codes.
        // This can be a proprietry status code (in this case the StringId must not be zero)
        // or a TAPI line error (one of LINEERR_constants). Note that all LINERR_constants
        // are negative numbers (documented in MSDN).
        // We mark the fact that it is not one of the stock values so we can map it back
        // to legacy Fax API status codes. Otherwise we might get confused and think that
        // a FSP proprietry code is one of the EFSPI extended status codes.
        //
        // Note that we don't have a way to correctly map the proprietry code
        // to a FSPI_JS status code since we do not know the semantics of the
        // proprietry code. We choose to report it as FSPI_JS_INPROGRESS.
        //
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = dwLegacyStatus;
        *pbPrivateStatusCode = TRUE;

        break;
    }
    return(ERROR_SUCCESS);
}


//
// Function:
//      GetDevStatus
//
// Parameters:
//      hFaxJob - the job handle that FaxDevStartJob returned.
//      LineInfo - Ther line information structure.
//      ppFaxStatus - A pointer to a buffer that receives the address of the
//          FSPI_JOB_STATUS that contains the status.
//
// Return Value:
//      If the function succeeds, the return value is ERROR_SUCCESS, else the
//      return value is an error code.
//
// Description:
//      The function allocates a FSPI_JOB_STATUS structure and calls the FSP
//      for final job status report. 
//      If the FSP is a legacy FSP, the function allocates first a
//      FAX_DEV_STATUS structure, calls the legacy FSP status report function
//      and mapps the returned values into the FSPI_JOB_STATUS structure.
//
DWORD
GetDevStatus(
    HANDLE hFaxJob,
    PLINE_INFO LineInfo,
    LPFSPI_JOB_STATUS *ppFaxStatus)
{
    DEBUG_FUNCTION_NAME(TEXT("GetDevStatus"));
    DWORD dwRet = ERROR_SUCCESS;
    LPWSTR szStatusStr = NULL;
    DWORD dwSize = 0;
    BOOL bPrivateStatusCode = FALSE;

    Assert(hFaxJob);
    Assert(LineInfo);
    Assert(ppFaxStatus);

    Assert(LineInfo->Provider->dwAPIVersion == FSPI_API_VERSION_1);

    //
    // We're have a legacy FSP to deal with.
    //
    PFAX_DEV_STATUS pLegacyFaxStatus = NULL;
    LPFSPI_JOB_STATUS pFaxStatus = NULL;

    //
    // Allocate memory for the status packet this is a variable size packet
    // based on the size of the strings contained withing the packet.
    //
    DWORD StatusSize = sizeof(FAX_DEV_STATUS) + FAXDEVREPORTSTATUS_SIZE;
    pLegacyFaxStatus = (PFAX_DEV_STATUS) MemAlloc( StatusSize );
    if (!pLegacyFaxStatus)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate memory for FAX_DEV_STATUS"));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Setup the status packet
    //
    pLegacyFaxStatus->SizeOfStruct = StatusSize;

    Assert(LineInfo->Provider->FaxDevReportStatus);

    __try
    {

        //
        // Call the FSP
        //
        DWORD BytesNeeded;

        if (!LineInfo->Provider->FaxDevReportStatus(
                     hFaxJob,
                     pLegacyFaxStatus,
                     StatusSize,
                     &BytesNeeded
                    )) {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxDevReportStatus() failed - %d"),
                         dwRet);
            dwRet = GetLastError();

            // catch the case in which FaxDevReportStatus() failded but doesn't
            // report an error
            Assert (ERROR_SUCCESS != dwRet);

            // in case the provider did not set last error 
            if ( dwRet == ERROR_SUCCESS )
            {
                // force it to report an error
                dwRet = ERROR_INVALID_FUNCTION;
            }

            goto Exit;
        }

    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, LineInfo->Provider->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }

    //
    // Map FAX_DEV_STATUS into FSPI_JOB_STATUS.
    //

    //
    // Compute the extra space that is needed after the structure for the
    // various strings.
    //
    dwSize = sizeof(FSPI_JOB_STATUS);

    if (pLegacyFaxStatus->CSI)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pLegacyFaxStatus->CSI) + 1);
    }
    if (pLegacyFaxStatus->CallerId)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pLegacyFaxStatus->CallerId) + 1);
    }
    if (pLegacyFaxStatus->RoutingInfo)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pLegacyFaxStatus->RoutingInfo) + 1);
    }
    //
    // Allocate the FSPI_JOB_STATUS structure with extra space for the strings.
    //
    pFaxStatus = (LPFSPI_JOB_STATUS)MemAlloc(dwSize);
    if (!pFaxStatus)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate memory for FSPI_JOB_STATUS"));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Zero-out the structure.
    //
    memset(pFaxStatus, 0, dwSize);

    pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);

    //
    // Map the legacy status into new EFSPI status.
    //
    dwRet = LegacyJobStatusToStatus(pLegacyFaxStatus->StatusId,
                                    &(pFaxStatus->dwJobStatus),
                                    &(pFaxStatus->dwExtendedStatus),
                                    &bPrivateStatusCode);
    if (dwRet != ERROR_SUCCESS)
    {

        DebugPrintEx(DEBUG_ERR,
                     TEXT("LegacyJobStatusToStatus failed  - %d"),
                     dwRet);
        goto Exit;
    }

    if  (bPrivateStatusCode)
    {
        //
        // The FSP  reported a private status code (not one of the FS_* status codes).
        // We mark this in the returned FSPI_JOB_STATUS by turning on the private flag
        // FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE.
        // We will check this flag when converting the FSPI_JOB_STATUS
        // back to FPS_ device status so we won't get confused by an FSP that returned
        // a proprietry status code which is equal to one the new FSPI_JS_* codes.
        //
         pFaxStatus->fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;

#if DEBUG
         if (0 == pLegacyFaxStatus->StringId && pLegacyFaxStatus->StatusId < LINEERR_ALLOCATED)
         {
             //
             // The status reported is not one of the stock status codes and is not a TAPI Error code.
             // pLegacyFaxStatus->StringId must not be 0.
             //
             DebugPrintEx(
                 DEBUG_WRN,
                 TEXT("Provider [%s] has reported an illegal FAX_DEV_STATUS for device [%s]\n. ")
                 TEXT("Although the reported status code (0x%08X) is proprietry the string id is 0"),
                 LineInfo->Provider->FriendlyName,
                 LineInfo->DeviceName,
                 pLegacyFaxStatus->StatusId);

         }
#endif
    }
    pFaxStatus->dwExtendedStatusStringId = pLegacyFaxStatus->StringId;


    szStatusStr = (LPWSTR)(((PBYTE)pFaxStatus) + sizeof(FSPI_JOB_STATUS));

    //
    // Copy CSI into lpwstrRemoteStationId
    //
    if (pLegacyFaxStatus->CSI)
    {
        pFaxStatus->lpwstrRemoteStationId = szStatusStr;
        wcscpy(szStatusStr, pLegacyFaxStatus->CSI);
        szStatusStr += wcslen(pLegacyFaxStatus->CSI) + 1;
    }

    //
    // Copy the Caller ID string.
    //
    if (pLegacyFaxStatus->CallerId)
    {
        pFaxStatus->lpwstrCallerId = szStatusStr;
        wcscpy(szStatusStr, pLegacyFaxStatus->CallerId);
        szStatusStr += wcslen(pLegacyFaxStatus->CallerId) + 1;
    }

    //
    // Copy the Routing Info string.
    //
    if (pLegacyFaxStatus->RoutingInfo)
    {
        pFaxStatus->lpwstrRoutingInfo = szStatusStr;
        wcscpy(szStatusStr, pLegacyFaxStatus->RoutingInfo);
    }   
    //
    // Copy Page Count.
    //
    pFaxStatus->dwPageCount = pLegacyFaxStatus->PageCount;
    pFaxStatus->fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_PAGECOUNT;

Exit:
    if (dwRet == ERROR_SUCCESS)
    {
        *ppFaxStatus = pFaxStatus;
    }
    else
    {
        MemFree(pFaxStatus);
    }

    MemFree(pLegacyFaxStatus);
    return(dwRet);
}

BOOL
GetRealFaxTimeAsSystemTime (
    const PJOB_ENTRY lpcJobEntry,
    FAX_ENUM_TIME_TYPES TimeType,
    SYSTEMTIME* lpFaxTime
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetRealFaxTimeAsSystemTime)"));
    Assert (lpcJobEntry);
    Assert (lpFaxTime);

    PJOB_QUEUE pJobQueue = lpcJobEntry->lpJobQueueEntry;
    Assert (pJobQueue);
    DWORDLONG dwlFileTime;

    dwlFileTime = ((TimeType == FAX_TIME_TYPE_START) ? lpcJobEntry->StartTime : lpcJobEntry->EndTime);
    if (dwlFileTime == 0)
    {
        DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("JonEntry contains invalid time (=0) "));
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    if (!FileTimeToSystemTime ((FILETIME*)&dwlFileTime, lpFaxTime))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed (ec: %ld)"),
            GetLastError());
        return FALSE;
    } 
    return TRUE;
}


BOOL
GetRealFaxTimeAsFileTime (
    const PJOB_ENTRY lpcJobEntry,
    FAX_ENUM_TIME_TYPES TimeType,
    FILETIME* lpFaxTime
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetRealFaxTimeAsSystemTime)"));
    Assert (lpcJobEntry);
    Assert (lpFaxTime);

    PJOB_QUEUE pJobQueue = lpcJobEntry->lpJobQueueEntry;
    Assert (pJobQueue);
    DWORDLONG dwlFileTime;

    
    dwlFileTime = ((TimeType == FAX_TIME_TYPE_START) ? lpcJobEntry->StartTime : lpcJobEntry->EndTime);
    if (dwlFileTime == 0)
    {
        DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("JonEntry contains invalid time (=0) "));
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }
    *lpFaxTime = *((FILETIME*)&dwlFileTime);    
    return TRUE;
}


VOID
FaxExtFreeBuffer(
    LPVOID lpvBuffer
)
{
    MemFree( lpvBuffer );
}

//
// Service threads count functions.
// The service is terminated only when service threads refernce count is 0.
// When the count is 0 the  g_hThreadCountEvent is set.
// When the count is greater than 0, the g_hThreadCountEvent is reset.
// EndFaxSvc() waits on g_hThreadCountEvent before starting to cleanup.
//
BOOL
IncreaseServiceThreadsCount(
    VOID
    )
/*++

Routine name : IncreaseServiceThreadsCount

Routine description:

    Safetly increments the service threads reference count

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    VOID

Return Value:

    BOOL

--*/
{
    BOOL bRet = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("IncreaseServiceThreadsCount"));

    EnterCriticalSection (&g_CsServiceThreads);
    g_lServiceThreadsCount++;

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("Current service threads count is %ld"),
            g_lServiceThreadsCount);

    if (1 == g_lServiceThreadsCount)
    {
        bRet = ResetEvent (g_hThreadCountEvent);
        if (FALSE == bRet)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ResetEvent failed (g_hThreadCountEvent) (ec: %ld"),
                GetLastError());
        }
    }

    LeaveCriticalSection (&g_CsServiceThreads);
    return bRet;
}

BOOL
DecreaseServiceThreadsCount(
    VOID
    )
/*++

Routine name : DecreaseServiceThreadsCount

Routine description:

    Safetly decrements the service threads reference count

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    VOID

Return Value:

    BOOL

--*/
{
    BOOL bRet = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("DecreaseServiceThreadsCount"));

    Assert (!ThreadOwnsCs()); // verify that the terminating thread does not own a critical section!!!

    EnterCriticalSection (&g_CsServiceThreads);

    g_lServiceThreadsCount--;
    Assert (g_lServiceThreadsCount >= 0);

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("Current service threads count is %ld"),
            g_lServiceThreadsCount);

    if (0 == g_lServiceThreadsCount)
    {
        bRet = SetEvent (g_hThreadCountEvent);
        if (FALSE == bRet)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetEvent failed (g_hThreadCountEvent) (ec: %ld"),
                GetLastError());
        }
    }

    LeaveCriticalSection (&g_CsServiceThreads);
    return bRet;
}



HANDLE CreateThreadAndRefCount(
  LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD
  DWORD dwStackSize,                        // initial stack size
  LPTHREAD_START_ROUTINE lpStartAddress,    // thread function
  LPVOID lpParameter,                       // thread argument
  DWORD dwCreationFlags,                    // creation option
  LPDWORD lpThreadId                        // thread identifier
)
/*++

Routine name : CreateThreadAndRefCount

Routine description:

    Creates a thread and saftely increments the service threads reference count.
    All function parameters and return value are IDENTICAL to CreateThread().

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    lpThreadAttributes  [      ] -
    dwStackSize         [      ] -
    lpStartAddress      [      ] -
    lpParameter         [      ] -
    dwCreationFlags     [      ] -
    lpThreadId          [      ] -

Return Value:

    HANDLE

--*/
{
    HANDLE hThread;
    DWORD ec;
    DEBUG_FUNCTION_NAME(TEXT("CreateThreadAndRefCount"));


    //
    // First enter g_CsServiceThreads so the threads reference counter is always ssynced!
    //
    EnterCriticalSection (&g_CsServiceThreads);

    hThread = CreateThread( lpThreadAttributes,
                            dwStackSize,
                            lpStartAddress,
                            lpParameter,
                            dwCreationFlags,
                            lpThreadId
                          );
    if (NULL == hThread)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateThread failed (ec: %ld"),
            ec);
    }
    else
    {
        if (!IncreaseServiceThreadsCount())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IncreaseServiceThreadsCount failed (ec: %ld"),
                GetLastError());
        }
    }

    LeaveCriticalSection (&g_CsServiceThreads);
    if (NULL == hThread)
    {
        SetLastError(ec);
    }
    return hThread;
}

LPTSTR
MapFSPIJobExtendedStatusToString (DWORD dwFSPIExtendedStatus)
//*********************************************************************************
//* Name: MapFSPIJobExtendedStatusToString()
//* Author: Oded sacher
//* Date:   Jan 2002
//*********************************************************************************
//* DESCRIPTION:
//*     Maps FSPI extended job status codes to a displayable string
//* PARAMETERS:
//*     [IN ]       DWORD dwFSPIExtendedStatus
//*         The FSPI extended Status code.
//*
//* RETURN VALUE:
//*     Pointer to a string describing the well known extended status
//*
//*********************************************************************************
{	
	struct _ExStatusStringsMapEntry
    {
        DWORD dwFSPIExtendedStatus;
        DWORD dwStringResourceId;
    } ExStatusStringsMap [] =
    {
        {FSPI_ES_DISCONNECTED,			  FPS_DISCONNECTED          },
        {FSPI_ES_INITIALIZING,			  FPS_INITIALIZING          },
        {FSPI_ES_DIALING,				  FPS_DIALING               },
        {FSPI_ES_TRANSMITTING,            FPS_SENDING               },
        {FSPI_ES_ANSWERED,                FPS_ANSWERED              },
        {FSPI_ES_RECEIVING,               FPS_RECEIVING             },
        {FSPI_ES_LINE_UNAVAILABLE,        FPS_UNAVAILABLE           },
        {FSPI_ES_BUSY,                    FPS_BUSY                  },
        {FSPI_ES_NO_ANSWER,               FPS_NO_ANSWER             },
        {FSPI_ES_BAD_ADDRESS,             FPS_BAD_ADDRESS           },
        {FSPI_ES_NO_DIAL_TONE,            FPS_NO_DIAL_TONE          },
        {FSPI_ES_FATAL_ERROR,             FPS_FATAL_ERROR           },
        {FSPI_ES_CALL_DELAYED,            FPS_CALL_DELAYED          },
        {FSPI_ES_CALL_BLACKLISTED,        FPS_CALL_BLACKLISTED      },
        {FSPI_ES_NOT_FAX_CALL,            FPS_NOT_FAX_CALL          },
        {FSPI_ES_PARTIALLY_RECEIVED,      IDS_PARTIALLY_RECEIVED    },
        {FSPI_ES_HANDLED,                 FPS_HANDLED               },
        {FSPI_ES_CALL_COMPLETED,          IDS_CALL_COMPLETED        },
        {FSPI_ES_CALL_ABORTED,            IDS_CALL_ABORTED          }
    };

    LPTSTR lptstrString = NULL;
    for (DWORD dwIndex = 0; dwIndex < sizeof (ExStatusStringsMap) / sizeof (_ExStatusStringsMapEntry); dwIndex++)
    {
        if (ExStatusStringsMap[dwIndex].dwFSPIExtendedStatus == dwFSPIExtendedStatus)
        {
            lptstrString = GetString (ExStatusStringsMap[dwIndex].dwStringResourceId);
            break;
        }
    }
	return lptstrString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\systray\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Monitor resource ID file                     //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [9000 - 9999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#ifndef _INC_FAX_ST_RES_ 
#define _INC_FAX_ST_RES_                     

// dialogs 
#define IDD_FAX_ANSWER_CALL             9001 
// resources 
#define IDR_FAX_IDLE                    9002 
#define IDR_FAX_SEND                    9003 
#define IDR_FAX_RECEIVE                 9004 
#define IDI_SEND_SUCCESS                9005 
#define IDI_SENDING                     9006 
#define IDI_RECEIVING                   9007 
#define IDI_SEND_FAILED                 9008 
#define IDI_RECEIVE_FAILED              9009 
#define IDI_NEW_FAX                     9010 
#define IDI_RINGING_1                   9011 
#define IDI_RINGING_2                   9012 
#define IDI_RINGING_3                   9013 
#define IDI_RINGING_4                   9014 
#define IDR_FAX_RINGING                 9015 
// icons 
#define IDI_FAX_NORMAL                  9016 
#define IDI_FAX_MONITOR                 9018 
#define IDB_LIST_IMAGES                 9019 
// menus 
#define IDM_FAX_MENU                    9020 
#define ID_ICON_PROPERTIES              9021 
#define ID_FAX_QUEUE                    9022 
#define ID_DISABLE_MONITORING           9023 
#define ID_ANSWER_CALL                  9024 
#define ID_FAX_MONITOR                  9025 
// strings 
#define IDS_FAX_DIALING                 9026 
#define IDS_FAX_SENDING                 9027 
#define IDS_FAX_RECEIVING               9028 
#define IDS_FAX_BUSY                    9029 
#define IDS_FAX_NO_ANSWER               9030 
#define IDS_FAX_BAD_ADDRESS             9031 
#define IDS_FAX_NO_DIAL_TONE            9032 
#define IDS_FAX_DISCONNECTED            9033 
#define IDS_FAX_FATAL_ERROR_SND         9034 
#define IDS_FAX_FATAL_ERROR_RCV         9035 
#define IDS_FAX_NOT_FAX_CALL            9036 
#define IDS_FAX_CALL_DELAYED            9037 
#define IDS_FAX_CALL_BLACKLISTED        9038 
#define IDS_FAX_ANSWERED                9039 
#define IDS_FAX_UNKNOWN_CALLER          9040 
#define IDS_NEW_FAX                     9041 
#define IDS_FAX_INCOMING                9042 
#define IDS_FAX_INCOMING_TITLE          9043 
// 
// Monitor dialog 
// 
#define IDD_MONITOR                     9044 
#define IDC_ANIMATE                     9045 
#define IDC_STATUS                      9046 
#define IDC_ELAPSED_TIME                9047 
#define IDC_MON_TITLE                   9048 
#define IDC_ALWAYS_ON_TOP               9049 
#define IDC_ANSWER_NEXT_CALL            9050 
#define IDC_HIDE                        9051 
#define IDC_DISCONNECT                  9052 
#define IDC_DETAILS                     9053 
#define IDC_LIST_DETAILS                9054 
#define IDC_CLEAR_LOG                   9055 
#define ID_DISCONNECT_CALL              9056 
#define IDS_DETAIL_TIME_HEADER          9057 
#define IDS_DETAIL_EVENT_HEADER         9058 
#define IDS_ELAPSED_TIME                9059 
#define IDS_STATUS_IDLE                 9060 
#define IDS_SENDING_TO                  9061 
#define IDS_RECEIVING_FROM              9062 
#define IDS_INCOMING_CALL               9063 
#define IDS_INCOMING_CALL_FROM          9064 
#define IDS_FAX_INITIALIZING            9065 
#define IDS_FAX_LINE_UNAVAILABLE        9066 
#define IDS_FAX_PARTIALLY_RECEIVED      9067 
#define IDS_FAX_CANCELED                9068 
#define IDS_FAX_RETRIES_EXCEEDED        9069 
#define IDS_FAX_CANCELING               9070 
#define IDS_SENDING                     9071 
#define IDS_RECEIVING                   9072 
#define IDS_MESSAGE_BOX_CAPTION         9073 
#define IDS_DISCONNECT_CONFIRM          9074 
#define IDS_FAX_SNT_COMPLETED           9075 
#define IDS_FAX_RCV_COMPLETED           9076 
#define IDS_CANNOT_ANSWER               9077 
#define IDS_RINGING_BALLOON             9078 
#define IDS_RINGING_FROM_BALLOON        9079 
#define IDS_SEND_ERROR_BALLOON          9080 
#define IDS_RCV_ERROR_BALLOON           9081 
#define IDS_RCV_FROM_ERROR_BALLOON      9082 
#define IDS_NEW_FAX_BALLOON             9083 
#define IDS_SEND_OK_BALLOON             9084 
#define IDS_RINGING                     9085 
#define IDS_BUTTON_MORE                 9086 
#define IDS_BUTTON_LESS                 9087 
#define IDS_DELETE_ACCESS_DENIED        9088 
#define IDS_FAX_CALL_COMPLETED          9089 
#define IDS_FAX_CALL_ABORTED            9090 
#define IDS_FAX_READY                   9091 
#define IDS_READY_TO_SND                9092 
#define IDS_READY_TO_RCV                9093 
#define IDS_READY_TO_SND_AND_RCV        9094 
#define IDS_ABORT_SEND_CONFIRM          9095 
#define IDS_ABORT_RECEIVE_CONFIRM       9096 
#define IDS_BUTTON_DISCONNECT           9097 
#define IDS_BUTTON_ANSWER               9098 
#define IDS_CLICK_TO_ANSWER             9099 
#define IDS_CLICK_TO_VIEW               9100 
#define IDS_NEW_FAX_FROM_BALLOON        9101 
#define IDS_SEND_OK                     9102 
#define IDS_ERR_CANT_TALK_TO_SERVICE    9103 
#define IDS_ERR_ANSWER_ACCESS_DENIED    9104 
#define IDS_ERR_NO_DEVICES              9105 
#define IDS_ERR_DEVICE_BUSY             9106 
#define IDS_ERROR_VIRTUAL_DEVICE        9107 

//////////////////////////////////////////////////////
//                                                  //
// Fax Monitor resource ID file                     //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [9000 - 9999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#endif // _INC_FAX_ST_RES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\winfax\devtest\testwinfax.cpp ===
#include <winfax.h>

void CallEverythingWithGarbage ()
{
    FaxAbort (NULL, 0);
    FaxAccessCheck (NULL, 0);
    FaxClose (NULL);
    FaxCompleteJobParamsA (NULL, NULL);
    FaxCompleteJobParamsW (NULL, NULL);
    FaxConnectFaxServerA (NULL, NULL);
    FaxConnectFaxServerW (NULL, NULL);
    FaxEnableRoutingMethodA (NULL, NULL, FALSE);
    FaxEnableRoutingMethodW (NULL, NULL, FALSE);
    FaxEnumGlobalRoutingInfoA (NULL, NULL, NULL);
    FaxEnumGlobalRoutingInfoW (NULL, NULL, NULL);
    FaxEnumJobsA (NULL, NULL, NULL);
    FaxEnumJobsW (NULL, NULL, NULL);
    FaxEnumPortsA (NULL, NULL, NULL);
    FaxEnumPortsW (NULL, NULL, NULL);
    FaxEnumRoutingMethodsA (NULL, NULL, NULL);
    FaxEnumRoutingMethodsW (NULL, NULL, NULL);
    FaxFreeBuffer (NULL);
    FaxGetConfigurationA (NULL, NULL);
    FaxGetConfigurationW (NULL, NULL);
    FaxGetDeviceStatusA (NULL, NULL);
    FaxGetDeviceStatusW (NULL, NULL);
    FaxGetJobA (NULL, 0, NULL);
    FaxGetJobW (NULL, 0, NULL);
    FaxGetLoggingCategoriesA (NULL, NULL, NULL);
    FaxGetLoggingCategoriesW (NULL, NULL, NULL);
    FaxGetPageData (NULL, 0, NULL, NULL, NULL, NULL);
    FaxGetPortA (NULL, NULL);
    FaxGetPortW (NULL, NULL);
    FaxGetRoutingInfoA (NULL, NULL, NULL, NULL);
    FaxGetRoutingInfoW (NULL, NULL, NULL, NULL);
    FaxInitializeEventQueue (NULL, NULL, NULL, NULL, 0);
    FaxOpenPort (NULL, 0, 0, NULL);
    FaxPrintCoverPageA (NULL, NULL);
    FaxPrintCoverPageW (NULL, NULL);
    FaxRegisterRoutingExtensionW (NULL, NULL, NULL, NULL, NULL, NULL);
    FaxRegisterServiceProviderW (NULL, NULL, NULL, NULL);
    FaxSendDocumentA (NULL, NULL, NULL, NULL, NULL);
    FaxSendDocumentW (NULL, NULL, NULL, NULL, NULL);
    FaxSendDocumentForBroadcastA (NULL, NULL, NULL, NULL, NULL);
    FaxSendDocumentForBroadcastW (NULL, NULL, NULL, NULL, NULL);
    FaxSetConfigurationA (NULL, NULL);
    FaxSetConfigurationW (NULL, NULL);
    FaxSetGlobalRoutingInfoA (NULL, NULL);
    FaxSetGlobalRoutingInfoW (NULL, NULL);
    FaxSetJobA (NULL, 0, 0, NULL);
    FaxSetJobW (NULL, 0, 0, NULL);
    FaxSetLoggingCategoriesA (NULL, NULL, 0);
    FaxSetLoggingCategoriesW (NULL, NULL, 0);
    FaxSetPortA (NULL, NULL);
    FaxSetPortW (NULL, NULL);
    FaxSetRoutingInfoA (NULL, NULL, NULL, 0);
    FaxSetRoutingInfoW (NULL, NULL, NULL, 0);
    FaxStartPrintJobA (NULL, NULL, NULL, NULL);
    FaxStartPrintJobW (NULL, NULL, NULL, NULL);
}

#ifndef _UNICODE
int main (
    int argc,
    char *argv[]
)
{
    //
    // We only check the linkage - not performance.
    //
    CallEverythingWithGarbage();
    return 0;
}
#else
int wmain (
    int argc,
    WCHAR *argv[]
)
{
    //
    // We only check the linkage - not performance.
    //
    CallEverythingWithGarbage();
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\winfax\winfax.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	winfax.cpp

Abstract:

	A wrapper DLL that provides old WinFax.dll support from the new (private) DLL

Author:

	Eran Yariv (EranY)	Jun, 2000

Revision History:

Remarks:

    FAXAPI is defined in the sources file as the name of the private DLL to actualy use.

--*/

#define _WINFAX_
#include <winfax.h>
#include <DebugEx.h>
#include <faxutil.h>
#include <tchar.h>
#include <faxreg.h>
#include <FaxUIConstants.h>


extern "C"
DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvContext
)
{
    BOOL bRes = TRUE;
    DBG_ENTER (TEXT("DllMain"), bRes, TEXT("Reason = %d"), dwReason);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInstance );
            break;

        case DLL_PROCESS_DETACH:
			HeapCleanup();
            break;
    }
    return bRes;
}

/****************************************************************************

               L e g a c y   f u n c t i o n s   w r a p p e r s

****************************************************************************/

extern "C"
BOOL 
WINAPI WinFaxAbort(
  HANDLE    FaxHandle,      // handle to the fax server
  DWORD     JobId           // identifier of fax job to terminate
)
{
    return FaxAbort (FaxHandle, JobId);
}

extern "C"
BOOL 
WINAPI WinFaxAccessCheck(
  HANDLE    FaxHandle,      // handle to the fax server
  DWORD     AccessMask      // set of access level bit flags
)
{
    return FaxAccessCheck (FaxHandle, AccessMask);
}

extern "C"
BOOL 
WINAPI WinFaxClose(
  HANDLE FaxHandle  // fax handle to close
)
{
    return FaxClose (FaxHandle);
}

extern "C"
BOOL 
WINAPI WinFaxCompleteJobParamsA(
  PFAX_JOB_PARAMA *JobParams,          // pointer to 
                                       //   job information structure
  PFAX_COVERPAGE_INFOA *CoverpageInfo  // pointer to 
                                       //   cover page structure
)
{
    return FaxCompleteJobParamsA (JobParams, CoverpageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxCompleteJobParamsW(
  PFAX_JOB_PARAMW *JobParams,          // pointer to 
                                       //   job information structure
  PFAX_COVERPAGE_INFOW *CoverpageInfo  // pointer to 
                                       //   cover page structure
)
{
    return FaxCompleteJobParamsW (JobParams, CoverpageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxConnectFaxServerA(
  LPCSTR MachineName OPTIONAL,   // fax server name
  LPHANDLE FaxHandle             // handle to the fax server
)
{
    if (IsLocalMachineNameA (MachineName))
    {
        //
        // Windows 2000 supported only local fax connection.
        // Prevent apps that use the Windows 2000 API from connection to remote fax servers.
        //
        return FaxConnectFaxServerA (MachineName, FaxHandle);
    }
    else
    {
        DBG_ENTER (TEXT("WinFaxConnectFaxServerA"), TEXT("MachineName = %s"), MachineName);
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }
}


extern "C"
BOOL 
WINAPI WinFaxConnectFaxServerW(
  LPCWSTR MachineName OPTIONAL,  // fax server name
  LPHANDLE FaxHandle             // handle to the fax server
)
{
    if (IsLocalMachineNameW (MachineName))
    {
        //
        // Windows 2000 supported only local fax connection.
        // Prevent apps that use the Windows 2000 API from connection to remote fax servers.
        //
        return FaxConnectFaxServerW (MachineName, FaxHandle);
    }
    else
    {
        DBG_ENTER (TEXT("WinFaxConnectFaxServerA"), TEXT("MachineName = %s"), MachineName);
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }
}


extern "C"
BOOL 
WINAPI WinFaxEnableRoutingMethodA(
  HANDLE FaxPortHandle,  // fax port handle
  LPCSTR RoutingGuid,    // GUID that identifies the fax routing method
  BOOL Enabled           // fax routing method enable/disable flag
)
{
    return FaxEnableRoutingMethodA (FaxPortHandle, RoutingGuid, Enabled);
}


extern "C"
BOOL 
WINAPI WinFaxEnableRoutingMethodW(
  HANDLE FaxPortHandle,  // fax port handle
  LPCWSTR RoutingGuid,   // GUID that identifies the fax routing method
  BOOL Enabled           // fax routing method enable/disable flag
)
{
    return FaxEnableRoutingMethodW (FaxPortHandle, RoutingGuid, Enabled);
}


extern "C"
BOOL 
WINAPI WinFaxEnumGlobalRoutingInfoA(
  HANDLE FaxHandle,       //handle to the fax server
  PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo, 
                          //buffer to receive global routing structures
  LPDWORD MethodsReturned //number of global routing structures returned
)
{
   return FaxEnumGlobalRoutingInfoA (FaxHandle, RoutingInfo, MethodsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumGlobalRoutingInfoW(
  HANDLE FaxHandle,       //handle to the fax server
  PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo, 
                          //buffer to receive global routing structures
  LPDWORD MethodsReturned //number of global routing structures returned
)
{
    return FaxEnumGlobalRoutingInfoW (FaxHandle, RoutingInfo, MethodsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumJobsA(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_JOB_ENTRYA *JobEntry, // buffer to receive array of job data
  LPDWORD JobsReturned       // number of fax job structures returned
)
{
    return FaxEnumJobsA (FaxHandle, JobEntry, JobsReturned);
}



extern "C"
BOOL 
WINAPI WinFaxEnumJobsW(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_JOB_ENTRYW *JobEntry, // buffer to receive array of job data
  LPDWORD JobsReturned       // number of fax job structures returned
)
{
    return FaxEnumJobsW (FaxHandle, JobEntry, JobsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumPortsA(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_PORT_INFOA *PortInfo, // buffer to receive array of port data
  LPDWORD PortsReturned      // number of fax port structures returned
)
{
    return FaxEnumPortsA (FaxHandle, PortInfo, PortsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumPortsW(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_PORT_INFOW *PortInfo, // buffer to receive array of port data
  LPDWORD PortsReturned      // number of fax port structures returned
)
{
    return FaxEnumPortsW (FaxHandle, PortInfo, PortsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumRoutingMethodsA(
  HANDLE FaxPortHandle,    // fax port handle
  PFAX_ROUTING_METHODA *RoutingMethod, 
                           // buffer to receive routing method data
  LPDWORD MethodsReturned  // number of routing method structures returned
)
{
    return FaxEnumRoutingMethodsA (FaxPortHandle, RoutingMethod, MethodsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumRoutingMethodsW(
  HANDLE FaxPortHandle,    // fax port handle
  PFAX_ROUTING_METHODW *RoutingMethod, 
                           // buffer to receive routing method data
  LPDWORD MethodsReturned  // number of routing method structures returned
)
{
    return FaxEnumRoutingMethodsW (FaxPortHandle, RoutingMethod, MethodsReturned);
}


extern "C"
VOID 
WINAPI WinFaxFreeBuffer(
  LPVOID Buffer  // pointer to buffer to free
)
{
    return FaxFreeBuffer (Buffer);
}


extern "C"
BOOL 
WINAPI WinFaxGetConfigurationA(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_CONFIGURATIONA *FaxConfig  // structure to receive configuration data
)
{
    return FaxGetConfigurationA (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxGetConfigurationW(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_CONFIGURATIONW *FaxConfig  // structure to receive configuration data
)
{
    return FaxGetConfigurationW (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxGetDeviceStatusA(
  HANDLE FaxPortHandle,  // fax port handle
  PFAX_DEVICE_STATUSA *DeviceStatus
                         // structure to receive fax device data
)
{
    return FaxGetDeviceStatusA (FaxPortHandle, DeviceStatus);
}


extern "C"
BOOL 
WINAPI WinFaxGetDeviceStatusW(
  HANDLE FaxPortHandle,  // fax port handle
  PFAX_DEVICE_STATUSW *DeviceStatus
                         // structure to receive fax device data
)
{
    return FaxGetDeviceStatusW (FaxPortHandle, DeviceStatus);
}


extern "C"
BOOL 
WINAPI WinFaxGetJobA(
  HANDLE FaxHandle,         // handle to the fax server
  DWORD JobId,              // fax job identifier
  PFAX_JOB_ENTRYA *JobEntry  // pointer to job data structure
)
{
    return FaxGetJobA (FaxHandle, JobId, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxGetJobW(
  HANDLE FaxHandle,         // handle to the fax server
  DWORD JobId,              // fax job identifier
  PFAX_JOB_ENTRYW *JobEntry  // pointer to job data structure
)
{
    return FaxGetJobW (FaxHandle, JobId, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxGetLoggingCategoriesA(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_LOG_CATEGORYA *Categories, // buffer to receive category data
  LPDWORD NumberCategories       // number of logging categories returned
)
{
    return FaxGetLoggingCategoriesA (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxGetLoggingCategoriesW(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_LOG_CATEGORYW *Categories, // buffer to receive category data
  LPDWORD NumberCategories       // number of logging categories returned
)
{
    return FaxGetLoggingCategoriesW (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxGetPageData(
  HANDLE FaxHandle,    // handle to the fax server
  DWORD JobId,         // fax job identifier
  LPBYTE *Buffer,      // buffer to receive first page of data
  LPDWORD BufferSize,  // size of buffer, in bytes
  LPDWORD ImageWidth,  // page image width, in pixels
  LPDWORD ImageHeight  // page image height, in pixels
)
{
    return FaxGetPageData (FaxHandle, JobId, Buffer, BufferSize, ImageWidth, ImageHeight);
}


extern "C"
BOOL 
WINAPI WinFaxGetPortA(
  HANDLE FaxPortHandle,     // fax port handle
  PFAX_PORT_INFOA *PortInfo  // structure to receive port data
)
{
    return FaxGetPortA (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxGetPortW(
  HANDLE FaxPortHandle,     // fax port handle
  PFAX_PORT_INFOW *PortInfo  // structure to receive port data
)
{
    return FaxGetPortW (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxGetRoutingInfoA(
  HANDLE FaxPortHandle,  // fax port handle
  LPCSTR RoutingGuid,   // GUID that identifies fax routing method
  LPBYTE *RoutingInfoBuffer, 
                         // buffer to receive routing method data
  LPDWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    return FaxGetRoutingInfoA (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxGetRoutingInfoW(
  HANDLE FaxPortHandle,  // fax port handle
  LPCWSTR RoutingGuid,   // GUID that identifies fax routing method
  LPBYTE *RoutingInfoBuffer, 
                         // buffer to receive routing method data
  LPDWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    return FaxGetRoutingInfoW (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxInitializeEventQueue(
  HANDLE FaxHandle,        // handle to the fax server
  HANDLE CompletionPort,   // handle to an I/O completion port
  ULONG_PTR CompletionKey, // completion key value
  HWND hWnd,               // handle to the notification window
  UINT MessageStart        // window message base event number
)
{
    return FaxInitializeEventQueue (FaxHandle, CompletionPort, CompletionKey, hWnd, MessageStart);
}


extern "C"
BOOL 
WINAPI WinFaxOpenPort(
  HANDLE FaxHandle,       // handle to the fax server
  DWORD DeviceId,         // receiving device identifier
  DWORD Flags,            // set of port access level bit flags
  LPHANDLE FaxPortHandle  // fax port handle
)
{
    return FaxOpenPort (FaxHandle, DeviceId, Flags, FaxPortHandle);
}


extern "C"
BOOL 
WINAPI WinFaxPrintCoverPageA(
  CONST FAX_CONTEXT_INFOA *FaxContextInfo,
                         // pointer to device context structure
  CONST FAX_COVERPAGE_INFOA *CoverPageInfo 
                         // pointer to local cover page structure
)
{
    return FaxPrintCoverPageA (FaxContextInfo, CoverPageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxPrintCoverPageW(
  CONST FAX_CONTEXT_INFOW *FaxContextInfo,
                         // pointer to device context structure
  CONST FAX_COVERPAGE_INFOW *CoverPageInfo 
                         // pointer to local cover page structure
)
{
    return FaxPrintCoverPageW (FaxContextInfo, CoverPageInfo);
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW (
    IN LPCWSTR lpcwstrDeviceProvider,
    IN LPCWSTR lpcwstrFriendlyName,
    IN LPCWSTR lpcwstrImageName,
    IN LPCWSTR lpcwstrTspName
    )
{
    HKEY    hKey = NULL;
    HKEY    hProviderKey = NULL;
    DWORD   dwRes;
    DWORD   Disposition = REG_OPENED_EXISTING_KEY;
    DEBUG_FUNCTION_NAME(TEXT("FaxRegisterServiceProviderW"));

    if (!lpcwstrDeviceProvider ||
        !lpcwstrFriendlyName   ||
        !lpcwstrImageName      ||
        !lpcwstrTspName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("At least one of the given strings is NULL."));
        return FALSE;
    }

    if (MAX_FAX_STRING_LEN < _tcslen (lpcwstrFriendlyName) ||
        MAX_FAX_STRING_LEN < _tcslen (lpcwstrImageName) ||
        MAX_FAX_STRING_LEN < _tcslen (lpcwstrTspName) ||
        MAX_FAX_STRING_LEN < _tcslen (lpcwstrDeviceProvider))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("At least one of the given strings is too long."));
        return FALSE;
    }
    //
    // Try to open the registry key of the providers
    //
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
                           REGKEY_DEVICE_PROVIDER_KEY,
                           TRUE,    // Create if not existing
                           0);
    if (!hKey)
    {
        //
        // Failed - this is probably not a local call.
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to open providers key (ec = %ld)"),
            GetLastError ());
        return FALSE;
    }
    //
    // Try to create this FSP's key
    //
    dwRes = RegCreateKeyEx(
        hKey,
        lpcwstrDeviceProvider,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hProviderKey,
        &Disposition);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create provider key (ec = %ld)"),
            dwRes);
        goto exit;
    }

    if (REG_OPENED_EXISTING_KEY == Disposition)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Provider already exist (orovider name: %s)."),
            lpcwstrDeviceProvider);
        dwRes = ERROR_ALREADY_EXISTS;
        goto exit;
    }

    //
    // Write provider's data into the key
    //
    if (!SetRegistryString (hProviderKey, REGVAL_FRIENDLY_NAME, lpcwstrFriendlyName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryStringExpand (hProviderKey, REGVAL_IMAGE_NAME, lpcwstrImageName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing auto-expand string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString (hProviderKey, REGVAL_PROVIDER_NAME, lpcwstrTspName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword (hProviderKey, REGVAL_PROVIDER_API_VERSION, FSPI_API_VERSION_1))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing DWORD value (ec = %ld)"),
            dwRes);
        goto exit;
    }    

    Assert (ERROR_SUCCESS == dwRes);
    //
    // Adding an FSP is always local.
    // If we don't have a fax printer installed, this is the time to install one.
    //
    AddOrVerifyLocalFaxPrinter();

exit:
    if (hKey)
    {
        DWORD dw;
        if (ERROR_SUCCESS != dwRes &&
            REG_OPENED_EXISTING_KEY != Disposition)
        {
            //
            // Delete provider's key on failure, only if it was created now
            //
            dw = RegDeleteKey (hKey, lpcwstrDeviceProvider);
            if (ERROR_SUCCESS != dw)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Error deleting provider key (ec = %ld)"),
                    dw);
            }
        }
        dw = RegCloseKey (hKey);
        if (ERROR_SUCCESS != dw)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error closing providers key (ec = %ld)"),
                dw);
        }
    }
    if (hProviderKey)
    {
        DWORD dw = RegCloseKey (hProviderKey);
        if (ERROR_SUCCESS != dw)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error closing provider key (ec = %ld)"),
                dw);
        }
    }
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    return TRUE;
}   // FaxRegisterServiceProviderW


WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderW (
    IN LPCWSTR lpcwstrDeviceProvider
    )
{    
    HKEY    hProvidersKey = NULL;
    LONG    lRes = ERROR_SUCCESS;   
	LONG	lRes2;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnregisterServiceProviderW"));

    if (!lpcwstrDeviceProvider)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpcwstrDeviceProvider is NULL."));
        return FALSE;
    }
    
    //
    // Try to open the registry key of the providers
    //
    hProvidersKey = OpenRegistryKey(
		HKEY_LOCAL_MACHINE,
		REGKEY_DEVICE_PROVIDER_KEY,
		FALSE,    // Do not create if not existing
		0);
    if (!hProvidersKey)
    {
        //
        // Failed - this is probably not a local call.
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to open providers key (ec = %ld)"),
            GetLastError ());
        return FALSE;
    }    
    
    lRes = RegDeleteKey (hProvidersKey, lpcwstrDeviceProvider);
    if (ERROR_SUCCESS != lRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error deleting provider key (ec = %ld)"),
            lRes);
    }   
	
    
    lRes2 = RegCloseKey (hProvidersKey);
    if (ERROR_SUCCESS != lRes2)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing provider key (ec = %ld)"),
            lRes2);
    }    

    if (ERROR_SUCCESS != lRes)
    {
        SetLastError (lRes);
        return FALSE;
    }
    return TRUE;
}   // FaxUnegisterServiceProviderW


extern "C"
BOOL 
WINAPI WinFaxRegisterRoutingExtensionW(
  HANDLE FaxHandle,       // handle to the fax server
  LPCWSTR ExtensionName,  // fax routing extension DLL name
  LPCWSTR FriendlyName,   // fax routing extension user-friendly name
  LPCWSTR ImageName,      // path to fax routing extension DLL
  PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack, // pointer to fax 
                          // routing installation callback function
  LPVOID Context          // pointer to context information
)
{
    return FaxRegisterRoutingExtensionW (FaxHandle, ExtensionName, FriendlyName, ImageName, CallBack, Context);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentA(
  HANDLE FaxHandle,          // handle to the fax server
  LPCSTR FileName,          // file with data to transmit
  PFAX_JOB_PARAMA JobParams,  // pointer to job information structure
  CONST FAX_COVERPAGE_INFOA *CoverpageInfo OPTIONAL, 
                             // pointer to local cover page structure
  LPDWORD FaxJobId           // fax job identifier
)
{
    return FaxSendDocumentA (FaxHandle, FileName, JobParams, CoverpageInfo, FaxJobId);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentW(
  HANDLE FaxHandle,          // handle to the fax server
  LPCWSTR FileName,          // file with data to transmit
  PFAX_JOB_PARAMW JobParams,  // pointer to job information structure
  CONST FAX_COVERPAGE_INFOW *CoverpageInfo OPTIONAL, 
                             // pointer to local cover page structure
  LPDWORD FaxJobId           // fax job identifier
)
{
    return FaxSendDocumentW (FaxHandle, FileName, JobParams, CoverpageInfo, FaxJobId);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentForBroadcastA(
  HANDLE FaxHandle,  // handle to the fax server
  LPCSTR FileName,  // fax document file name
  LPDWORD FaxJobId,  // fax job identifier
  PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback, 
                     // pointer to fax recipient callback function
  LPVOID Context     // pointer to context information
)
{
    return FaxSendDocumentForBroadcastA (FaxHandle, FileName, FaxJobId, FaxRecipientCallback, Context);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentForBroadcastW(
  HANDLE FaxHandle,  // handle to the fax server
  LPCWSTR FileName,  // fax document file name
  LPDWORD FaxJobId,  // fax job identifier
  PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback, 
                     // pointer to fax recipient callback function
  LPVOID Context     // pointer to context information
)
{
    return FaxSendDocumentForBroadcastW (FaxHandle, FileName, FaxJobId, FaxRecipientCallback, Context);
}


extern "C"
BOOL 
WINAPI WinFaxSetConfigurationA(
  HANDLE FaxHandle,                   // handle to the fax server
  CONST FAX_CONFIGURATIONA *FaxConfig  // new configuration data
)
{
    return FaxSetConfigurationA (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxSetConfigurationW(
  HANDLE FaxHandle,                   // handle to the fax server
  CONST FAX_CONFIGURATIONW *FaxConfig  // new configuration data
)
{
    return FaxSetConfigurationW (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxSetGlobalRoutingInfoA(
  HANDLE FaxHandle, //handle to the fax server
  CONST FAX_GLOBAL_ROUTING_INFOA *RoutingInfo 
                    //pointer to global routing information structure
)
{
    return FaxSetGlobalRoutingInfoA (FaxHandle, RoutingInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetGlobalRoutingInfoW(
  HANDLE FaxHandle, //handle to the fax server
  CONST FAX_GLOBAL_ROUTING_INFOW *RoutingInfo 
                    //pointer to global routing information structure
)
{
    return FaxSetGlobalRoutingInfoW (FaxHandle, RoutingInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetJobA(
  HANDLE FaxHandle,        // handle to the fax server
  DWORD JobId,             // fax job identifier
  DWORD Command,           // job command value
  CONST FAX_JOB_ENTRYA *JobEntry 
                           // pointer to job information structure
)
{
    return FaxSetJobA (FaxHandle, JobId, Command, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxSetJobW(
  HANDLE FaxHandle,        // handle to the fax server
  DWORD JobId,             // fax job identifier
  DWORD Command,           // job command value
  CONST FAX_JOB_ENTRYW *JobEntry 
                           // pointer to job information structure
)
{
    return FaxSetJobW (FaxHandle, JobId, Command, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxSetLoggingCategoriesA(
  HANDLE FaxHandle,              // handle to the fax server
  CONST FAX_LOG_CATEGORYA *Categories, 
                                 // new logging categories data
  DWORD NumberCategories         // number of category structures
)
{
    return FaxSetLoggingCategoriesA (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxSetLoggingCategoriesW(
  HANDLE FaxHandle,              // handle to the fax server
  CONST FAX_LOG_CATEGORYW *Categories, 
                                 // new logging categories data
  DWORD NumberCategories         // number of category structures
)
{
    return FaxSetLoggingCategoriesW (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxSetPortA(
  HANDLE FaxPortHandle,          // fax port handle
  CONST FAX_PORT_INFOA *PortInfo  // new port configuration data
)
{
    return FaxSetPortA (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetPortW(
  HANDLE FaxPortHandle,          // fax port handle
  CONST FAX_PORT_INFOW *PortInfo  // new port configuration data
)
{
    return FaxSetPortW (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetRoutingInfoA(
  HANDLE FaxPortHandle,  // fax port handle
  LPCSTR RoutingGuid,   // GUID that identifies fax routing method
  CONST BYTE *RoutingInfoBuffer, 
                         // buffer with routing method data
  DWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    return FaxSetRoutingInfoA (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxSetRoutingInfoW(
  HANDLE FaxPortHandle,  // fax port handle
  LPCWSTR RoutingGuid,   // GUID that identifies fax routing method
  CONST BYTE *RoutingInfoBuffer, 
                         // buffer with routing method data
  DWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    return FaxSetRoutingInfoW (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxStartPrintJobA(
  LPCSTR PrinterName,        // printer for fax job
  CONST FAX_PRINT_INFOA *PrintInfo, 
                              // print job information structure
  LPDWORD FaxJobId,           // fax job identifier
  PFAX_CONTEXT_INFOA FaxContextInfo 
                              // pointer to device context structure
)
{
    return FaxStartPrintJobA (PrinterName, PrintInfo, FaxJobId, FaxContextInfo);
}


extern "C"
BOOL 
WINAPI WinFaxStartPrintJobW(
  LPCWSTR PrinterName,        // printer for fax job
  CONST FAX_PRINT_INFOW *PrintInfo, 
                              // print job information structure
  LPDWORD FaxJobId,           // fax job identifier
  PFAX_CONTEXT_INFOW FaxContextInfo 
                              // pointer to device context structure
)
{
    return FaxStartPrintJobW (PrinterName, PrintInfo, FaxJobId, FaxContextInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\bootstrap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <tchar.h>
#include <faxreg.h>
#include <setuputil.h>
#include <shellapi.h>
#include <faxutil.h>
#include <faxsetup.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\customactions\migration.h ===
// File Migration.h


extern HINSTANCE g_hModule;

BOOL
GetUserValues
(
    PFAX_PERSONAL_PROFILE pFaxPersonalProfiles, 
    BOOL fWin9X,
    LPCTSTR lpctstrRegKey
);

BOOL IsFaxClientInstalled(
	VOID
	);


BOOL SetSenderInformation(
	PFAX_PERSONAL_PROFILE pPersonalProfile
	);

BOOL UninstallWin9XFaxClient(
	VOID
	);

BOOL UninstallNTFaxClient(
    LPCTSTR lpctstrSetupImageName
    );

BOOL
GetInstallationInfo
(
    IN LPCTSTR lpctstrRegKey,
    OUT LPDWORD Installed
);

BOOL DuplicateCoverPages(	
	BOOL fWin9X
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\customactions\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:



Author:

    Asaf Shaar (asafs) 22-Dec-1999

Environment:

    User Mode

--*/


//
// string table
//
#define		IDS_FAXXP_DISPLAY_NAME		100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\customactions\msiclientcustomactions.cpp ===
// Defines the entry point for the DLL application.
//
#include "stdafx.h"
#include <winver.h>
#include <shlwapi.h>
#include <mapix.h>
#include <routemapi.h>
#include <faxsetup.h>
#include "Aclapi.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


HINSTANCE g_hModule = NULL;

BOOL SetDefaultPrinter(LPTSTR pPrinterName);
DWORD CreateFaxPrinterName(IN LPCTSTR tzPortName, OUT LPTSTR* ptzFaxPrinterName);


BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    SET_DEBUG_MASK(DBG_ALL);

    g_hModule = hModule;
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            {
                OPEN_DEBUG_LOG_FILE(SHARED_FAX_SERVICE_SETUP_LOG_FILE);
                DBG_ENTER(TEXT("DllMain called reason DLL_PROCESS_ATTACH."));
                if (!DisableThreadLibraryCalls(hModule))
                {
                    VERBOSE(GENERAL_ERR,
                            _T("DisableThreadLibraryCalls failed (ec=%d)"),
                            GetLastError());
                }
                break;
            }
        case DLL_PROCESS_DETACH:
            {
                DBG_ENTER(TEXT("DllMain called reason DLL_PROCESS_DETACH."));
                CLOSE_DEBUG_LOG_FILE;
                break;
            }
    }
    return TRUE;
}

///////////////////////////////
// VerifySpoolerIsRunning
//
// Start the Spooler service on NT4 & NT5
//
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD VerifySpoolerIsRunning()
{
    OSVERSIONINFO       osv;
    BOOL                bSuccess                    = FALSE;
    DWORD               dwReturn                    = NO_ERROR;
    SC_HANDLE           hSvcMgr                     = NULL;
    SC_HANDLE           hService                    = NULL;
    DWORD               i                           = 0;
    SERVICE_STATUS      Status;
    LPCTSTR             lpctstrSpoolerServiceName   = _T("Spooler");

    DBG_ENTER(_T("VerifySpoolerIsRunning"),dwReturn);

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        dwReturn = GetLastError();
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                dwReturn);
        goto exit;
    }

    // If Windows NT, use WriteProfileString for version 4.0 and earlier...
    if (osv.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W9X OS, Skipping Spooler verification"));
        goto exit;
    }

    // open the service manager
    hSvcMgr = ::OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);

    if (hSvcMgr == NULL)
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to open the service manager, rc = 0x%lx"),
                dwReturn);
        goto exit;
    }

    hService = ::OpenService(hSvcMgr,
                             lpctstrSpoolerServiceName,
                             SERVICE_QUERY_STATUS|SERVICE_START);

    if (hService == NULL)
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to open service '%s', rc = 0x%lx"),
                lpctstrSpoolerServiceName,
                dwReturn);
        goto exit;
    }

    // Start the fax service.
    bSuccess = StartService(hService, 0, NULL);
    if (!bSuccess)
    {
        dwReturn = ::GetLastError();
        if (dwReturn == ERROR_SERVICE_ALREADY_RUNNING)
        {
            dwReturn = NO_ERROR;
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start service '%s', rc = 0x%lx"),
                    lpctstrSpoolerServiceName, 
                    dwReturn);
            goto exit;
        }
    }

    do 
    {
        QueryServiceStatus(hService, &Status);
        i++;

        if (Status.dwCurrentState != SERVICE_RUNNING)
        {
            Sleep(1000);
        }

    } while ((i < 60) && (Status.dwCurrentState != SERVICE_RUNNING));

    if (Status.dwCurrentState != SERVICE_RUNNING)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to start '%s' service"),
                lpctstrSpoolerServiceName);
        dwReturn = ERROR_SERVICE_REQUEST_TIMEOUT;
        goto exit;
    }


exit:
    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hSvcMgr)
    {
        CloseServiceHandle(hSvcMgr);
    }

    return dwReturn;
}

// 
//
// Function:    ConnectW9XToRemotePrinter
// Platform:    This function intended to run on Win9X platforms
// Description: Add fax printer connection (driver + printer connection)
//              This function is exported by the DLL for use by the MSI as custom action to add printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure.
//
// Remarks:     
//
// Args:        hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS

DLL_API UINT __stdcall ConnectW9XToRemotePrinter(MSIHANDLE hInstall)
{
    UINT rc = ERROR_INSTALL_FAILURE;    
    DBG_ENTER(TEXT("ConnectW9XToRemotePrinter"), rc);

    TCHAR szFaxPortName[MAX_PATH] = {0};
    TCHAR szPrinterDriverFolder[MAX_PATH] = {0};
    DWORD dwNeededSize = 0;

	PRINTER_INFO_2 pi2 = {0};
	DRIVER_INFO_3 di3 = {0};
    HANDLE hPrinter = NULL;

    if (!GetPrinterDriverDirectory(
        NULL,
        TEXT("Windows 4.0"),
        1,
        (LPBYTE) szPrinterDriverFolder,
        sizeof(szPrinterDriverFolder)/sizeof(TCHAR),
        &dwNeededSize
        ))
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("GetPrinterDriverDirectory failed or not enough space dwNeededSize %ld (ec: %ld)"),
                 dwNeededSize,
                 GetLastError ());
        goto exit;
    }

    // Get the remote printer path
    
    if (!PrivateMsiGetProperty(hInstall,_T("CustomActionData"),szFaxPortName))
    {
        VERBOSE (SETUP_ERR, _T("PrivateMsiGetProperty failed (ec: %ld)"), GetLastError());
        goto exit;
    }

    if (!FillDriverInfo(&di3,W9X_PRINT_ENV))
    {
        VERBOSE (PRINT_ERR, _T("FillDriverInfo failed (ec: %ld)"), GetLastError());
        goto exit;
    }
    
    if (!AddPrinterDriver(NULL, 3, (LPBYTE)&di3))
    {
        VERBOSE (PRINT_ERR, _T("AddPrinterDriver failed (ec: %ld)"), GetLastError());
        goto exit;
    }

	pi2.pPortName       = szFaxPortName;
    pi2.pDriverName     = FAX_DRIVER_NAME;
    pi2.pPrintProcessor = TEXT("WinPrint");
    pi2.pDatatype       = TEXT("RAW");

	rc = CreateFaxPrinterName(szFaxPortName, &(pi2.pPrinterName));
	if (rc != NO_ERROR)
	{
        VERBOSE (PRINT_ERR, _T("CreateFaxPrinterName() is failed, rc= %d. Use default."), rc);

		pi2.pPrinterName = FAX_PRINTER_NAME;
	}

	VERBOSE(DBG_MSG, _T("PrinterName is : '%s'."), pi2.pPrinterName);

    hPrinter = AddPrinter(NULL, 2, (LPBYTE)&pi2);

	if (!hPrinter)
    {
        rc = GetLastError();
        if (rc==ERROR_PRINTER_ALREADY_EXISTS)
        {
            VERBOSE (DBG_MSG,TEXT("Printer already exists, continue..."));
            rc = ERROR_SUCCESS;
        }
        else
        {
            VERBOSE (PRINT_ERR, _T("AddPrinter failed (ec: %ld)"), GetLastError());
            goto exit;
        }
    }

    if (hPrinter)
    {
        ClosePrinter(hPrinter); 
        hPrinter = NULL;
    }

	rc = ERROR_SUCCESS;

exit:

	if (pi2.pPrinterName)
	{
		MemFree(pi2.pPrinterName);
	}

	if (rc != ERROR_SUCCESS)
	{
        VERBOSE (GENERAL_ERR, _T("CustomAction ConnectW9XToRemotePrinter() failed !"));
	}

    return rc;
}



// 
//
// Function:    RemoveW9XPrinterConnection
// Platform:    This function intended to run on Win9X platforms
// Description: Remove the fax printer connection from the current machine.

//              This function is exported by the DLL for use by the MSI as custom action to delete printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall RemoveW9XPrinterConnection(MSIHANDLE hInstall)
{
    UINT			retVal		= ERROR_INSTALL_FAILURE;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD			dwCount		= 0;
    HANDLE			hPrinter	= NULL;

	DBG_ENTER(TEXT("RemoveW9XPrinterConnection"), retVal);

	PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL, 2, &dwCount, 0);
	if (!PrinterInfo)
	{
		VERBOSE(PRINT_ERR, _T("MyEnumPrinters failed : %d."), GetLastError());
		goto error;
	}

	VERBOSE(DBG_MSG, _T("MyEnumPrinters found %d printers installed."), dwCount);

	for (DWORD i=0 ; i<dwCount ; i++ )
	{
		if (_tcscmp(PrinterInfo[i].pDriverName, FAX_DRIVER_NAME) == 0)
		{
			VERBOSE(DBG_MSG, _T("Found Fax Printer : %s."), PrinterInfo[i].pPrinterName);

			if (!OpenPrinter(PrinterInfo[i].pPrinterName, &hPrinter, NULL))
			{
				VERBOSE(PRINT_ERR, _T("OpenPrinter() failed ! (ec: %ld)"), GetLastError());
				continue;
			}

			if (!DeletePrinter(hPrinter))
			{
				VERBOSE(PRINT_ERR, _T("DeletePrinter() failed ! (ec: %ld)"), GetLastError());
			}

			if (hPrinter)
			{
				ClosePrinter(hPrinter);
				hPrinter = NULL;
			}
		}
		else
		{
			VERBOSE(DBG_MSG, _T("This is not Fax Printer : %s."), PrinterInfo[i].pPrinterName);
		}
	}

    retVal = ERROR_SUCCESS;

error:

	if (PrinterInfo)
	{
        MemFree( PrinterInfo );
		PrinterInfo = NULL;
	}

    return retVal;
}


class CSignalSetupInProgress
{
public:
	CSignalSetupInProgress();
	~CSignalSetupInProgress();
};

CSignalSetupInProgress::CSignalSetupInProgress()
{
	HKEY hFaxKey = NULL;

	DBG_ENTER(TEXT("CSignalSetupInProgress::CSignalSetupInProgress"));

	// write 'setup in progress' to the registry, to be used by the point & print 
	// mechanism to skip doing a client installation during a setup that is
	// user driven
	hFaxKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP,TRUE,KEY_WRITE);
	if (hFaxKey)
	{
		if (!SetRegistryDword(hFaxKey,REGVAL_SETUP_IN_PROGRESS,1))
		{
			VERBOSE(GENERAL_ERR,_T("SetRegistryDword failed: (ec=%d)"),GetLastError());
		}
	}
	else
	{
		VERBOSE(GENERAL_ERR,_T("OpenRegistryKey failed: (ec=%d)"),GetLastError());
	}

	if (hFaxKey)
	{
		RegCloseKey(hFaxKey);
	}
}

CSignalSetupInProgress::~CSignalSetupInProgress()
{
	HKEY hFaxKey = NULL;

    DBG_ENTER(TEXT("CSignalSetupInProgress::~CSignalSetupInProgress"));

	hFaxKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP,FALSE,KEY_WRITE);
	if (hFaxKey)
	{
		if (RegDeleteValue(hFaxKey,REGVAL_SETUP_IN_PROGRESS)!=ERROR_SUCCESS)
		{
			VERBOSE(GENERAL_ERR, TEXT("RegDeleteValue failed with %ld"), GetLastError());
		}
	}
	else
	{
		VERBOSE(DBG_MSG, TEXT("down leve client setup is not in progress"));
	}

	if (hFaxKey)
	{
		RegCloseKey(hFaxKey);
	}
}

// 
//
// Function:    AddFaxPrinterConnection
// Platform:    This function intended to run on NT platforms (NT4 and Win2K)
// Description: Add fax printer connection
//              This function is exported by the DLL for use by the MSI as custom action to add printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure.
//
// Remarks:     
//
// Args:        hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS

  
DLL_API UINT __stdcall AddFaxPrinterConnection(MSIHANDLE hInstall)
{
    UINT rc = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddFaxPrinterConnection"), rc);
    
    BOOL fFaxPrinterConnectionAdded = FALSE;
    
    TCHAR szFaxPrinterName[MAX_PATH]   = {0};

    if (!PrivateMsiGetProperty(hInstall,_T("PRINTER_NAME"),szFaxPrinterName))
    {
        VERBOSE (SETUP_ERR, 
                 TEXT("PrivateMsiGetProperty() failed ! (ec: %ld)"),
                 GetLastError ());
        goto error;
    }


   
    //////////////////////////////////////////
    // Add the printer connection on client //
    //////////////////////////////////////////
    
	{
		CSignalSetupInProgress SignalSetupInProgress;
		fFaxPrinterConnectionAdded = AddPrinterConnection(szFaxPrinterName);
		if (!fFaxPrinterConnectionAdded) 
		{
			DWORD dwLastError = GetLastError();
			VERBOSE (PRINT_ERR, 
					TEXT("AddPrinterConnection() failed ! (ec: %ld)"),
					dwLastError);

			goto error;
		}
		else
		{
			VERBOSE (DBG_MSG, 
					TEXT("Successfully added fax printer connection to %s"),
					szFaxPrinterName);
		}
	}

    
    if (!SetDefaultPrinter(szFaxPrinterName))
    {
        DWORD dwLastError = GetLastError();
        VERBOSE (PRINT_ERR, 
                 TEXT("SetDefaultPrinter() failed ! (ec: %ld)"),
                 dwLastError);
        goto error;
    }

    return rc;

error:

    VERBOSE (GENERAL_ERR, 
             TEXT("CustomAction AddFaxPrinterConnection() failed !"));
    rc = ERROR_INSTALL_FAILURE;
    return rc;
}


// 
//
// Function:    RemoveFaxPrinterConnection
// Platform:    This function intended to run on NT platforms (NT4 and Win2K)
// Description: Remove the fax printer connection from the current machine.
//              This function is exported by the DLL for use by the MSI as custom action to delete printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall RemoveFaxPrinterConnection(MSIHANDLE hInstall)
{
    PPRINTER_INFO_2 pPrinterInfo    = NULL;
    DWORD dwNumPrinters             = 0;
    DWORD dwPrinter                 = 0;
    DWORD ec                        = ERROR_SUCCESS;

    DBG_ENTER(TEXT("RemoveFaxPrinterConnection"), ec);

    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_CONNECTIONS
                                                    );
    if (!pPrinterInfo)
    {
        ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            ec = ERROR_PRINTER_NOT_FOUND;
        }
        VERBOSE (GENERAL_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 ec);
        goto error;
    }

    for (dwPrinter=0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        if (IsPrinterFaxPrinter(pPrinterInfo[dwPrinter].pPrinterName))
        {
            if (!DeletePrinterConnection(pPrinterInfo[dwPrinter].pPrinterName))
            {
                VERBOSE (PRINT_ERR, 
                         TEXT("DeletePrinterConnection() %s failed ! (ec: %ld)"),
                         pPrinterInfo[dwPrinter].pPrinterName,
                         GetLastError ());
                goto error;
            
            }
            else
            {
                VERBOSE (DBG_MSG, 
                         TEXT("fax printer connection %s was deleted successfully"),
                         pPrinterInfo[dwPrinter].pPrinterName);
            } 
        }
    }

error:

    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }

    if (ec!=ERROR_SUCCESS)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("CustomAction RemoveFaxPrinterConnection() failed !"));
    }
    return ec;
}


#define FXSEXTENSION    _T("FXSEXT32.DLL")

// 
//
// Function:    Create_FXSEXT_ECF_File
// Description: Creates FxsExt.ecf in <WindowsFolder>\addins
//              a default file will be installed there by Windows Installer
//              to enable it to keep track of install/remove
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall Create_FXSEXT_ECF_File(MSIHANDLE hInstall)
{
    // CustomActionData has the following format <WindowsFolder>;<INSTALLDIR>
    TCHAR szCustomActionData[2*MAX_PATH] = {0};
    TCHAR szWindowsFolder[2*MAX_PATH] = {0};
    TCHAR szExtensionPath[MAX_PATH] = {0};
    TCHAR* tpInstallDir = NULL;
    UINT uiRet = ERROR_SUCCESS;

    DBG_ENTER(_T("Create_FXSEXT_ECF_File"));

    // get the custom action data from Windows Installer (deffered action)
    if (!PrivateMsiGetProperty(hInstall,_T("CustomActionData"),szCustomActionData))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:CustomActionData failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    if (_tcstok(szCustomActionData,_T(";"))==NULL)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("_tcstok failed on first token."));
        uiRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    if ((tpInstallDir=_tcstok(NULL,_T(";\0")))==NULL)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("_tcstok failed on second token."));
        uiRet = ERROR_INVALID_PARAMETER;
        goto error;
    }
    _tcscpy(szWindowsFolder,szCustomActionData);

    // construct the full path to the file
    if (_tcslen(szWindowsFolder)+_tcslen(ADDINS_DIRECTORY)+_tcslen(FXSEXT_ECF_FILE)>=MAX_PATH)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("Path to <WindowsFolder>\\Addins\\fxsext.ecf is too long"));
        goto error;
    }
    _tcscat(szWindowsFolder,ADDINS_DIRECTORY);
    _tcscat(szWindowsFolder,FXSEXT_ECF_FILE);

    VERBOSE (DBG_MSG, 
             _T("Filename to create is: %s."),
             szWindowsFolder);

    if (_tcslen(tpInstallDir)+_tcslen(FXSEXTENSION)+2>=MAX_PATH)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("Path to <INSTALLDIR>\\Bin\\fxsext32.dll is too long"));
        goto error;
    }

    _tcscpy(szExtensionPath,_T("\""));
    _tcscat(szExtensionPath,tpInstallDir);
    _tcscat(szExtensionPath,FXSEXTENSION);
    _tcscat(szExtensionPath,_T("\""));

    VERBOSE (DBG_MSG, 
             _T("MAPI Extension dll path dir is: %s."),
             szExtensionPath);

    if (!WritePrivateProfileString( _T("General"), 
                                    _T("Path"),                 
                                    szExtensionPath, 
                                    szWindowsFolder)) 
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("WritePrivateProfileString failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    Assert(uiRet==ERROR_SUCCESS);
    return uiRet;

error:

    Assert(uiRet!=ERROR_SUCCESS);
    return uiRet;
}

// 
//
// Function:    ValidatePrinter
// Description: Validates that the printer name which was entered is a legitimate
//              Fax Printer, and that the server is available.
//              Uses the MSI Property 'ValidPrinterFormat' to notify MSI if the
//              name is valid or not.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall ValidatePrinter(MSIHANDLE hInstall)
{
    TCHAR szPrinterName[MAX_PATH] = {0};
    UINT uiRet = ERROR_SUCCESS;
    HANDLE hPrinterHandle = INVALID_HANDLE_VALUE;
    BOOL bValidPrinter = TRUE;
    DBG_ENTER(_T("ValidatePrinter"));

    // first get the PRINTER_NAME proterty from Windows Installer
    if (!PrivateMsiGetProperty(hInstall,_T("PRINTER_NAME"),szPrinterName))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:PRINTER_NAME failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    if (VerifySpoolerIsRunning()!=NO_ERROR)
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("VerifySpoolerIsRunning (ec:%d)"),
                 uiRet);
        goto error;
    }

    // we have a string with the PRINTER_NAME, let's try to open it...
    if (bValidPrinter=IsPrinterFaxPrinter(szPrinterName))
    {
        VERBOSE (DBG_MSG, 
                 _T("IsPrinterFaxPrinter: %s succeeded."),
                 szPrinterName);
    }
    else
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("IsPrinterFaxPrinter: %s failed (ec: %ld)."),
                 szPrinterName,
                 uiRet);
    }


    uiRet = MsiSetProperty( hInstall,
                            _T("ValidPrinterFormat"),
                            bValidPrinter ? _T("TRUE") : _T("FALSE"));
    if (uiRet!=ERROR_SUCCESS)
    {
        VERBOSE (DBG_MSG,
                 TEXT("MsiSetProperty failed."));
        goto error;
    }

    return ERROR_SUCCESS;

error:

    return ERROR_FUNCTION_FAILED;
}

// 
//
// Function:    GuessPrinterName
// Description: Tries to understand whether the installation is performed from the 
//              server's FaxClients share, and if it is tries to establish a default
//              printer to be used
// 
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall GuessPrinterName(MSIHANDLE hInstall)
{
    UINT    uiRet                   = ERROR_SUCCESS;
    TCHAR   szSourceDir[MAX_PATH]   = {0};
    TCHAR   szPrinterName[MAX_PATH] = {0};
    TCHAR*  tpClientShare           = NULL;
    PPRINTER_INFO_2 pPrinterInfo    = NULL;
    DWORD dwNumPrinters             = 0;
    DWORD dwPrinter                 = 0;

    DBG_ENTER(_T("GuessPrinterName"),uiRet);

    // get the source directory from Windows Installer
    if (!PrivateMsiGetProperty(hInstall,_T("SourceDir"),szSourceDir))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:SourceDir failed (ec: %ld)."),
                 uiRet);
        goto exit;
    }

    // check if we have a UNC path
    if (_tcsncmp(szSourceDir,_T("\\\\"),2))
    {
        VERBOSE (DBG_MSG, 
                 _T("SourceDir doesn't start with \\\\"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // find drive name (skip server name)
    if ((tpClientShare=_tcschr(_tcsninc(szSourceDir,2),_T('\\')))==NULL)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("_tcschr failed"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (VerifySpoolerIsRunning()!=NO_ERROR)
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("VerifySpoolerIsRunning (ec:%d)"),
                 uiRet);
        goto exit;
    }

    // extract the server's name
    *tpClientShare = 0;
    // szSourceDir now holds the server's name
    // enumerate the printers on the server
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(szSourceDir,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_NAME
                                                    );

    if (!pPrinterInfo)
    {
        uiRet = GetLastError();
        if (uiRet == ERROR_SUCCESS)
        {
            uiRet = ERROR_PRINTER_NOT_FOUND;
        }
        VERBOSE (GENERAL_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 uiRet);
        goto exit;
    }

    for (dwPrinter=0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        // check if we have a valid fax printer driver name
        if (_tcscmp(pPrinterInfo[dwPrinter].pDriverName,FAX_DRIVER_NAME ) == 0) 
        {
            if (    (pPrinterInfo[dwPrinter].pServerName==NULL)         ||
                    (_tcslen(pPrinterInfo[dwPrinter].pServerName)==0)   ||
                    (pPrinterInfo[dwPrinter].pShareName==NULL)          ||
                    (_tcslen(pPrinterInfo[dwPrinter].pShareName)==0)    )
            {
                // on win9x the printer name lives in the Port name field
                _tcscpy(szPrinterName,pPrinterInfo[dwPrinter].pPortName);
            }
            else
            {
                _tcscpy(szPrinterName,pPrinterInfo[dwPrinter].pServerName);
                _tcscat(szPrinterName,_T("\\"));
                _tcscat(szPrinterName,pPrinterInfo[dwPrinter].pShareName);
            }
            VERBOSE (DBG_MSG,
                     TEXT("Setting PRINTER_NAME to %s."),
                     szPrinterName);
            // set property to Installer
            uiRet = MsiSetProperty(hInstall,_T("PRINTER_NAME"),szPrinterName);
            if (uiRet!=ERROR_SUCCESS)
            {
                VERBOSE (GENERAL_ERR,
                         TEXT("MsiSetProperty failed."));
                goto exit;
            }
            break;
        }
        else
        {
            VERBOSE (DBG_MSG,
                     TEXT("%s is not a Fax printer - driver name is %s."),
                     pPrinterInfo[dwPrinter].pPrinterName,
                     pPrinterInfo[dwPrinter].pDriverName);
        }
    }

exit:

    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }

    return uiRet;
}

// 
//
// Function:    Remove_FXSEXT_ECF_File
// Description: Removes FxsExt.ecf from <WindowsFolder>\addins
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall Remove_FXSEXT_ECF_File(MSIHANDLE hInstall)
{
    TCHAR szWindowsFolder[MAX_PATH] = {0};
    UINT uiRet = ERROR_SUCCESS;

    DBG_ENTER(_T("Remove_FXSEXT_ECF_File"));


    // check if the service is installed on this machine
    INSTALLSTATE currentInstallState = MsiQueryProductState(PRODCODE_SBS5_SERVER);
    
    if (currentInstallState != INSTALLSTATE_UNKNOWN)
    {
        VERBOSE (DBG_MSG, _T("The Microsoft Shared Fax Service is installed. Returning without removing file."));
        return uiRet;
    }

    // get the <WindowsFolder> from Windows Installer
    if (!PrivateMsiGetProperty(hInstall,_T("WindowsFolder"),szWindowsFolder))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:WindowsFolder failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    // construct the full path to the file
    if (_tcslen(szWindowsFolder)+_tcslen(ADDINS_DIRECTORY)+_tcslen(FXSEXT_ECF_FILE)>=MAX_PATH)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("Path to <WindowsFolder>\\Addins\\fxsext.ecf is too long"));
        goto error;
    }
    _tcscat(szWindowsFolder,ADDINS_DIRECTORY);
    _tcscat(szWindowsFolder,FXSEXT_ECF_FILE);

    VERBOSE (DBG_MSG, 
             _T("Filename to delete is: %s."),
             szWindowsFolder);

    if (DeleteFile(szWindowsFolder))
    {
        VERBOSE (DBG_MSG, 
                 _T("File %s was deleted successfully."),
                 szWindowsFolder);
    }
    else
    {
        VERBOSE (GENERAL_ERR, 
                 _T("DeleteFile %s failed (ec=%d)."),
                 szWindowsFolder,
                 GetLastError());
    }
    
    return ERROR_SUCCESS;

error:

    return ERROR_INSTALL_FAILURE;
}


// 
//
// Function:    RemoveTrasportProviderFromProfile
// Description: removes the Trasnport Provider from a MAPI profile
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
HRESULT RemoveTrasportProviderFromProfile(LPSERVICEADMIN  lpServiceAdmin)
{
    static SRestriction sres;
    static SizedSPropTagArray(2, Columns) =   {2,{PR_DISPLAY_NAME_A,PR_SERVICE_UID}};

    HRESULT         hr                          = S_OK;
    LPMAPITABLE     lpMapiTable                 = NULL;
    LPSRowSet       lpSRowSet                   = NULL;
    LPSPropValue    lpProp                      = NULL;
    ULONG           Count                       = 0;
    BOOL            bMapiInitialized            = FALSE;
    SPropValue      spv;
    MAPIUID         ServiceUID;
    
    DBG_ENTER(TEXT("RemoveTrasportProviderFromProfile"), hr);
    // get message service table
    hr = lpServiceAdmin->GetMsgServiceTable(0,&lpMapiTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetMsgServiceTable failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // notify MAPI that we want PR_DISPLAY_NAME_A & PR_SERVICE_UID
    hr = lpMapiTable->SetColumns((LPSPropTagArray)&Columns, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("SetColumns failed (ec: %ld)."),
                 hr);
        goto exit;
    }
 
    // restrict the search to our service provider
    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = PR_SERVICE_NAME_A;
    sres.res.resProperty.lpProp = &spv;

    spv.ulPropTag = PR_SERVICE_NAME_A;
    spv.Value.lpszA = FAX_MESSAGE_SERVICE_NAME_SBS50;

    // find it
    hr = lpMapiTable->FindRow(&sres, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("FindRow failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // get our service provider's row
    hr = lpMapiTable->QueryRows(1, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    if (lpSRowSet->cRows != 1)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows returned %d rows, there should be only one."),
                 lpSRowSet->cRows);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // get the MAPIUID of our service
    lpProp = &lpSRowSet->aRow[0].lpProps[1];

    if (lpProp->ulPropTag != PR_SERVICE_UID)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Property is %d, should be PR_SERVICE_UID."),
                 lpProp->ulPropTag);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // Copy the UID into our member.
    memcpy(&ServiceUID.ab, lpProp->Value.bin.lpb,lpProp->Value.bin.cb);

    // finally, delete our service provider
    hr = lpServiceAdmin->DeleteMsgService(&ServiceUID);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("DeleteMsgService failed (ec: %ld)."),
                 hr);
        goto exit;
    }

exit:
    return hr;
}

// 
//
// Function:    RemoveTrasportProvider
// Description: delete FXSXP32.DLL from mapisvc.inf 
//              and removes the Trasnport Provider from MAPI
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB

DLL_API UINT __stdcall RemoveTrasportProvider(MSIHANDLE hInstall)
{
    TCHAR           szMapisvcFile[2 * MAX_PATH]     = {0};
    DWORD           err                             = 0;
    DWORD           rc                              = ERROR_SUCCESS;
    HRESULT         hr                              = S_OK;
    LPSERVICEADMIN  lpServiceAdmin                  = NULL;
    LPMAPITABLE     lpMapiTable                     = NULL;
    LPPROFADMIN     lpProfAdmin                     = NULL;
    LPMAPITABLE     lpTable                         = NULL;
    LPSRowSet       lpSRowSet                       = NULL;
    LPSPropValue    lpProp                          = NULL;
    ULONG           Count                           = 0;
    int             iIndex                          = 0;
    BOOL            bMapiInitialized                = FALSE;
    HINSTANCE       hMapiDll                        = NULL;
                                                    
    LPMAPIINITIALIZE      fnMapiInitialize          = NULL;
    LPMAPIADMINPROFILES   fnMapiAdminProfiles       = NULL;
    LPMAPIUNINITIALIZE    fnMapiUninitialize        = NULL;

    DBG_ENTER(TEXT("RemoveTrasportProvider"), rc);

    CRouteMAPICalls rmcRouteMapiCalls;

    // first remove ourselves from MAPISVC.INF
    if(!GetSystemDirectory(szMapisvcFile, sizeof(szMapisvcFile)/sizeof(TCHAR)))
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetSystemDirectory failed (ec: %ld)."),
                 rc);
        goto exit;
    }
    _tcscat(szMapisvcFile, TEXT("\\mapisvc.inf"));

    VERBOSE (DBG_MSG, 
             TEXT("The mapi file is %s."),
             szMapisvcFile);

    if (!WritePrivateProfileString( TEXT("Default Services"), 
                                    FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
                                    NULL, 
                                    szMapisvcFile 
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }

    if (!WritePrivateProfileString( TEXT("Services"),
                                    FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
                                    NULL, 
                                    szMapisvcFile
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_SBS50_T,         
                                    NULL,
                                    NULL,
                                    szMapisvcFile
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
                                    NULL,
                                    NULL, 
                                    szMapisvcFile                   
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }
    
    // now remove the MAPI Service provider
    rc = rmcRouteMapiCalls.Init(_T("msiexec.exe"));
    if (rc!=ERROR_SUCCESS)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CRouteMAPICalls::Init failed (ec: %ld)."), rc);
        goto exit;
    }
    
    hMapiDll = LoadLibrary(_T("MAPI32.DLL"));
    if (NULL == hMapiDll)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadLibrary"), GetLastError()); 
        goto exit;
    }

    fnMapiInitialize = (LPMAPIINITIALIZE)GetProcAddress(hMapiDll, "MAPIInitialize");
    if (NULL == fnMapiInitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIInitialize)"), GetLastError());  
        goto exit;
    }

    fnMapiAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(hMapiDll, "MAPIAdminProfiles");
    if (NULL == fnMapiAdminProfiles)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(fnMapiAdminProfiles)"), GetLastError());  
        goto exit;
    }

    fnMapiUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(hMapiDll, "MAPIUninitialize");
    if (NULL == fnMapiUninitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIUninitialize)"), GetLastError());  
        goto exit;
    }

    // get access to MAPI functinality
    hr = fnMapiInitialize(NULL);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIInitialize failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    bMapiInitialized = TRUE;

    // get admin profile object
    hr = fnMapiAdminProfiles(0,&lpProfAdmin);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIAdminProfiles failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile table
    hr = lpProfAdmin->GetProfileTable(0,&lpTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetProfileTable failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile rows
    hr = lpTable->QueryRows(4000, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    for (iIndex=0; iIndex<(int)lpSRowSet->cRows; iIndex++)
    {
        lpProp = &lpSRowSet->aRow[iIndex].lpProps[0];

        if (lpProp->ulPropTag != PR_DISPLAY_NAME_A)
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("Property is %d, should be PR_DISPLAY_NAME_A."),
                     lpProp->ulPropTag);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_TABLE);
            goto exit;
        }

        hr = lpProfAdmin->AdminServices(LPTSTR(lpProp->Value.lpszA),NULL,0,0,&lpServiceAdmin);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("AdminServices failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
         
        hr = RemoveTrasportProviderFromProfile(lpServiceAdmin);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("RemoveTrasportProviderFromProfile failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
    }

exit:

    if (bMapiInitialized)
    {
        fnMapiUninitialize();
    }

    if (hMapiDll)
    {
        FreeLibrary(hMapiDll);
        hMapiDll = NULL;
    }

    return rc;
}

// 
//
// Function:    AddOutlookExtension
// Description: Add fax as outlook provider. Write into the MAPI file: 'mapisvc.inf'
//              This function is exported by the DLL for use by the MSI as custom action.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall AddOutlookExtension(MSIHANDLE hInstall)
{
    TCHAR szMapisvcFile[2 * MAX_PATH] = {0};
    TCHAR szDisplayName[MAX_PATH] = {0};

    DWORD err = 0;
    DWORD rc = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddOutlookExtension"), rc);


    if(!GetSystemDirectory(szMapisvcFile, sizeof(szMapisvcFile)/sizeof(TCHAR)))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetSystemDirectory failed (ec: %ld)."),
                 GetLastError ());
        goto error;
    }
    _tcscat(szMapisvcFile, TEXT("\\mapisvc.inf"));

    VERBOSE (DBG_MSG, 
             TEXT("The mapi file is %s."),
             szMapisvcFile);
    if (!LoadString(
        g_hModule,
        IDS_FAXXP_DISPLAY_NAME,
        szDisplayName,
        sizeof(szDisplayName)/sizeof(TCHAR)
        )) goto error;
    err++;

    if (!WritePrivateProfileString( 
        TEXT("Default Services"), 
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
        szDisplayName, 
        szMapisvcFile 
        )) goto error;
    err++;

    if (!WritePrivateProfileString( 
        TEXT("Services"),
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
        szDisplayName, 
        szMapisvcFile
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,         
        TEXT("PR_DISPLAY_NAME"),
        szDisplayName,
        szMapisvcFile
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,
        TEXT("Providers"),
        FAX_MESSAGE_PROVIDER_NAME_SBS50_T,
        szMapisvcFile
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,
        TEXT("PR_SERVICE_DLL_NAME"),
        FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
        szMapisvcFile
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_NAME_SBS50_T, 
        TEXT("PR_SERVICE_SUPPORT_FILES"),
        FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
        szMapisvcFile
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,         
        TEXT("PR_SERVICE_ENTRY_NAME"),
        TEXT("ServiceEntry"), 
        szMapisvcFile                
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_NAME_SBS50_T,         
        TEXT("PR_RESOURCE_FLAGS"),
        TEXT("SERVICE_SINGLE_COPY|SERVICE_NO_PRIMARY_IDENTITY"), 
        szMapisvcFile 
        )) goto error;
    err++;

    if (!WritePrivateProfileString(  
        FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
        TEXT("PR_PROVIDER_DLL_NAME"),
        FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T, 
        szMapisvcFile                   
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString(  
        FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
        TEXT("PR_RESOURCE_TYPE"),
        TEXT("MAPI_TRANSPORT_PROVIDER"), 
        szMapisvcFile     
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString(  
        FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
        TEXT("PR_RESOURCE_FLAGS"),
        TEXT("STATUS_NO_DEFAULT_STORE"), 
        szMapisvcFile     
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
        TEXT("PR_DISPLAY_NAME"), 
        szDisplayName, 
        szMapisvcFile 
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_PROVIDER_NAME_SBS50_T,      
        TEXT("PR_PROVIDER_DISPLAY"),
        szDisplayName,
        szMapisvcFile 
        )) goto error;
    err++;

    return rc;

error:

    VERBOSE (GENERAL_ERR, 
             TEXT("CustomAction AddOutlookExtension() failed ! (ec: %ld) (err = %ld)"),
             GetLastError(),
             err
             );
    rc = ERROR_INSTALL_FAILURE;
    return rc;
}

#define COMCTL32_401 PACKVERSION (4,72)

DLL_API UINT __stdcall IsComctlRequiresUpdate(MSIHANDLE hInstall)
{
    UINT uiRet = ERROR_SUCCESS;
    BOOL bRes = FALSE;
    DWORD dwVer = 0;

    DBG_ENTER(TEXT("IsComctlRequiresUpdate"), uiRet);
    
    dwVer = GetDllVersion(TEXT("comctl32.dll"));
    VERBOSE (DBG_MSG, 
             TEXT("Current COMCTL32 version is 0x%08X."),
             dwVer);

    if (COMCTL32_401 > dwVer)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("COMCTL32.DLL requires update."));
        bRes = TRUE;
    }

    uiRet = MsiSetProperty( hInstall,
                            _T("IsComctlRequiresUpdate"),
                            bRes ? _T("TRUE") : _T("FALSE"));
    if (uiRet!=ERROR_SUCCESS)
    {
        VERBOSE (DBG_MSG,
                 TEXT("MsiSetProperty IsComctlRequiresUpdate failed."));   
    }

    return uiRet;
}

typedef struct _TypeCommand 
{
    LPCTSTR lpctstrType;
    LPCTSTR lpctstrFolder;
    LPCTSTR lpctstrCommand;
} TypeCommand;

static TypeCommand tcWin9XCommand[] = 
{
    // Win9X PrintTo verbs
    { _T("txtfile"),    _T("WindowsFolder"),    _T("write.exe /pt \"%1\" \"%2\" \"%3\" \"%4")     },
    { _T("jpegfile"),   _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
};

static TypeCommand tcWinMECommand[] = 
{
    // WinME PrintTo verbs
    { _T("txtfile"),        _T("WindowsFolder"),    _T("write.exe /pt \"%1\" \"%2\" \"%3\" \"%4")     },
    { _T("jpegfile"),       _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
    { _T("giffile"),        _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
    { _T("Paint.Picture"),  _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
};

static TypeCommand tcWin2KCommand[] = 
{
    // NT4 PrintTo verbs
    { _T("txtfile"),    _T("SystemFolder"),     _T("write.exe /pt \"%1\" \"%2\" \"%3\" \"%4")     },
    { _T("jpegfile"),   _T("SystemFolder"),     _T("mspaint.exe /pt \"%1\" \"%2\" \"%3\" \"%4")   },
};

static int iCountWin9XCommands = sizeof(tcWin9XCommand)/sizeof(tcWin9XCommand[0]);
static int iCountWinMECommands = sizeof(tcWinMECommand)/sizeof(tcWinMECommand[0]);
static int iCountWin2KCommands = sizeof(tcWin2KCommand)/sizeof(tcWin2KCommand[0]);

// 
//
// Function:    CrearePrintToVerb
//
// Description: Creates the PrintTo verb for text files to associate it with wordpad
//              if the PrintTo verb already exists, this function does nothing.
//
// Remarks:     
//          on Win9x
//              txtfile  - PrintTo = <WindowsFolder>\write.exe /pt "%1" "%2" "%3" "%4"
//              jpegfile - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//
//          on WinME
//              txtfile         - PrintTo = <WindowsFolder>\write.exe /pt "%1" "%2" "%3" "%4"
//              jpegfile        - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//              giffile         - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//              Paint.Picture   - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//
//          on NT4
//              txtfile  - PrintTo = <SystemFolder>\write.exe /pt "%1" "%2" "%3" "%4"
//              jpegfile - PrintTo = <SystemFolder>\mspaint.exe /pt "%1" "%2" "%3" "%4"
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall CreatePrintToVerb(MSIHANDLE hInstall)
{
    UINT            uiRet                   = ERROR_SUCCESS;
    LPCTSTR         lpctstrPrintToCommand   = _T("\\shell\\printto\\command");
    int             iCount                  = 0;
    DWORD           cchValue                = MAX_PATH;
    TCHAR           szValueBuf[MAX_PATH]    = {0};
    TCHAR           szKeyBuf[MAX_PATH]      = {0};
    BOOL            bOverwriteExisting      = FALSE;
    LONG            rVal                    = 0;
    HKEY            hKey                    = NULL;
    HKEY            hCommandKey             = NULL;
    TypeCommand*    pTypeCommand            = NULL;
    int             iCommandCount           = 0;
    OSVERSIONINFO   osv;

    DBG_ENTER(TEXT("CreatePrintToVerb"),uiRet);

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        uiRet = GetLastError();
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                uiRet);
        goto exit;
    }

    if (osv.dwPlatformId==VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, _T("This is NT4/NT5"));
        pTypeCommand = tcWin2KCommand;
        iCommandCount = iCountWin2KCommands;
    }
    else if (osv.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
    {
        if (osv.dwMinorVersion>=90)
        {
            VERBOSE (DBG_MSG, _T("This is WinME"));
            pTypeCommand = tcWinMECommand;
            iCommandCount = iCountWinMECommands;
            bOverwriteExisting = TRUE;
        }
        else
        {
            VERBOSE (DBG_MSG, _T("This is Win9X"));
            pTypeCommand = tcWin9XCommand;
            iCommandCount = iCountWin9XCommands;
        }
    }
    else
    {
        VERBOSE (GENERAL_ERR, _T("This is an illegal OS"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    for (iCount=0; iCount<iCommandCount; iCount++)
    {
        _tcscpy(szKeyBuf,pTypeCommand[iCount].lpctstrType);
        _tcscat(szKeyBuf,lpctstrPrintToCommand);

        // go get the appropriate folder from Windows Installer
        if (!PrivateMsiGetProperty( hInstall,
                                    pTypeCommand[iCount].lpctstrFolder,
                                    szValueBuf))
        {
            VERBOSE (SETUP_ERR, 
                     TEXT("PrivateMsiGetProperty failed (ec: %ld)"),
                     GetLastError());
            goto exit;
        }

        if (_tcslen(szValueBuf)+_tcslen(pTypeCommand[iCount].lpctstrCommand)>=MAX_PATH-1)
        {
            VERBOSE (SETUP_ERR, 
                     TEXT("command to create is too long"));
            uiRet = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        _tcscat(szValueBuf,pTypeCommand[iCount].lpctstrCommand);

        // if we should not replace existing keys, let's check if it exists
        if (!bOverwriteExisting)
        {
            uiRet = RegOpenKey( HKEY_CLASSES_ROOT,
                                szKeyBuf,
                                &hKey);
            if (uiRet==ERROR_SUCCESS) 
            {
                // this means we should skip this key
                RegCloseKey(hKey);
                VERBOSE(DBG_MSG, 
                        _T("RegOpenKey:PrintTo succedded, no change in PrintTo verb for %s"),
                        pTypeCommand[iCount].lpctstrType);
                continue;
            }
            else
            {
                if (uiRet==ERROR_FILE_NOT_FOUND)
                {
                    VERBOSE(DBG_MSG, 
                            _T("PrintTo verb does not exist for %s, creating..."),
                            pTypeCommand[iCount].lpctstrType);
                }
                else
                {
                    VERBOSE (REGISTRY_ERR, 
                             TEXT("Could not open registry key %s (ec=0x%08x)"), 
                             szKeyBuf,
                             uiRet);
                    goto exit;
                }
            }
        }
        // if we're here, we should create the key
        uiRet = RegCreateKey(   HKEY_CLASSES_ROOT,
                                szKeyBuf,
                                &hCommandKey);
        if (uiRet!=ERROR_SUCCESS) 
        {
            VERBOSE (REGISTRY_ERR, 
                     TEXT("Could not create registry key %s (ec=0x%08x)"), 
                     szKeyBuf,
                     uiRet);
            goto exit;
        }

        uiRet = RegSetValue(hCommandKey,
                            NULL,
                            REG_SZ,
                            szValueBuf,
                            sizeof(szValueBuf));
        if (uiRet==ERROR_SUCCESS) 
        {
            VERBOSE(DBG_MSG, 
                    _T("RegSetValue success: %s "),
                    szValueBuf);
        }
        else
        {
            VERBOSE (REGISTRY_ERR, 
                     TEXT("Could not set value registry key %s\\shell\\printto\\command to %s (ec=0x%08x)"), 
                     pTypeCommand[iCount].lpctstrType,
                     szValueBuf,
                     uiRet);
            goto exit;
        }

        if (hKey)
        {
            RegCloseKey(hKey);
        }
        if (hCommandKey)
        {
            RegCloseKey(hCommandKey);
        }
    }

exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    if (hCommandKey)
    {
        RegCloseKey(hCommandKey);
    }

    return uiRet;
}

/*-----------------------------------------------------------------*/ 
/* DPSetDefaultPrinter                                             */ 
/*                                                                 */ 
/* Parameters:                                                     */ 
/*   pPrinterName: Valid name of existing printer to make default. */ 
/*                                                                 */ 
/* Returns: TRUE for success, FALSE for failure.                   */ 
/*-----------------------------------------------------------------*/ 
BOOL SetDefaultPrinter(LPTSTR pPrinterName)
{
    OSVERSIONINFO   osv;
    DWORD           dwNeeded        = 0;
    HANDLE          hPrinter        = NULL;
    PPRINTER_INFO_2 ppi2            = NULL;
    LPTSTR          pBuffer         = NULL;
    BOOL            bRes            = TRUE;
    PPRINTER_INFO_2 pPrinterInfo    = NULL;
    DWORD dwNumPrinters             = 0;

    DBG_ENTER(TEXT("SetDefaultPrinter"),bRes);

    // What version of Windows are you running?
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }

    // If Windows NT, use WriteProfileString for version 4.0 and earlier...
    if (osv.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W9X OS, not setting default printer"));
        goto exit;
    }

    if (osv.dwMajorVersion >= 5) // Windows 2000 or later...
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W2K OS, not setting default printer"));
        goto exit;
    }

    // are we the only printer installed?
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL
                                                    );
    if (!pPrinterInfo)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 GetLastError());

        bRes = FALSE;
        goto exit;
    }

    if (dwNumPrinters!=1)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("More than one printer installed on NT4, not setting default printer"));
        goto exit;
    }
    // Open this printer so you can get information about it...
    if (!OpenPrinter(pPrinterName, &hPrinter, NULL))
    {
        VERBOSE(GENERAL_ERR, 
                _T("OpenPrinter failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }
    // The first GetPrinter() tells you how big our buffer should
    // be in order to hold ALL of PRINTER_INFO_2. Note that this will
    // usually return FALSE. This only means that the buffer (the 3rd
    // parameter) was not filled in. You don't want it filled in here...
    if (!GetPrinter(hPrinter, 2, 0, 0, &dwNeeded))
    {
        if (GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
        {
            VERBOSE(GENERAL_ERR, 
                    _T("GetPrinter failed: (ec=%d)"),
                    GetLastError());
            bRes = FALSE;
            goto exit;
        }
    }

    // Allocate enough space for PRINTER_INFO_2...
    ppi2 = (PRINTER_INFO_2 *)MemAlloc(dwNeeded);
    if (!ppi2)
    {
        VERBOSE(GENERAL_ERR, 
                _T("MemAlloc failed"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRes = FALSE;
        goto exit;
    }

    // The second GetPrinter() fills in all the current<BR/>
    // information...
    if (!GetPrinter(hPrinter, 2, (LPBYTE)ppi2, dwNeeded, &dwNeeded))
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetPrinter failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }
    if ((!ppi2->pDriverName) || (!ppi2->pPortName))
    {
        VERBOSE(GENERAL_ERR, 
                _T("pDriverName or pPortNameare NULL"));
        SetLastError(ERROR_INVALID_PARAMETER);
        bRes = FALSE;
        goto exit;
    }

    // Allocate buffer big enough for concatenated string.
    // String will be in form "printername,drivername,portname"...
    pBuffer = (LPTSTR)MemAlloc( (   _tcslen(pPrinterName) +
                                    _tcslen(ppi2->pDriverName) +
                                    _tcslen(ppi2->pPortName) + 3) *
                                    sizeof(TCHAR)   );
    if (!pBuffer)
    {
        VERBOSE(GENERAL_ERR, 
                _T("MemAlloc failed"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRes = FALSE;
        goto exit;
    }

    // Build string in form "printername,drivername,portname"...
    _tcscpy(pBuffer, pPrinterName);  
    _tcscat(pBuffer, _T(","));
    _tcscat(pBuffer, ppi2->pDriverName);  
    _tcscat(pBuffer, _T(","));
    _tcscat(pBuffer, ppi2->pPortName);

    // Set the default printer in Win.ini and registry...
    if (!WriteProfileString(_T("windows"), _T("device"), pBuffer))
    {
        VERBOSE(GENERAL_ERR, 
                _T("WriteProfileString failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }

    // Tell all open applications that this change occurred. 
    // Allow each app 1 second to handle this message.
    if (!SendMessageTimeout(    HWND_BROADCAST, 
                                WM_SETTINGCHANGE, 
                                0L, 
                                0L,
                                SMTO_NORMAL, 
                                1000, 
                                NULL))
    {
        VERBOSE(GENERAL_ERR, 
                _T("SendMessageTimeout failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }
  
exit:
    // Cleanup...
    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }
    if (hPrinter)
    {
        ClosePrinter(hPrinter);
    }
    if (ppi2)
    {
        MemFree(ppi2);
    }
    if (pBuffer)
    {
        MemFree(pBuffer);
    }
  
    return bRes;
} 


// 
//
// Function:    CheckForceReboot
//
// Description: This function checks if the ForceReboot flag is set in the registry
//              if it is, signals WindowsInstaller that a reboot is needed
//
// Remarks:     
//              this is due to a bug in the Install Shield bootstrap which doesn't
//              force a reboot after initial installation of WindowsIsntaller.
//              this flag is set by our custom bootstrap before running the 
//              Install Shield bootstrap
//              if we are run from the Application Launcher then we need to leave 
//              this registry entry for the Launcher to reboot, we know this by 
//              using the property APPLAUNCHER=TRUE
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall CheckForceReboot(MSIHANDLE hInstall)
{
    UINT    uiRet   = ERROR_SUCCESS;
    TCHAR   szPropBuffer[MAX_PATH] = {0};
    HKEY    hKey    = NULL;
    DWORD   Size    = sizeof(DWORD);
    DWORD   Value   = 0;
    LONG    Rslt;
    DWORD   Type;

    DBG_ENTER(TEXT("CheckForceReboot"),uiRet);

    // check if we're running from the AppLauncher
    if (!PrivateMsiGetProperty(hInstall,_T("APPLAUNCHER"),szPropBuffer))
    {
        VERBOSE (SETUP_ERR, 
                 TEXT("PrivateMsiGetProperty failed (ec: %ld)"),
                 GetLastError());
        goto exit;
    }
    if (_tcscmp(szPropBuffer,_T("TRUE"))==0)
    {
        // we're running from the Application Launcher, the registry entry DeferredReboot
        // is sufficient.
         VERBOSE(DBG_MSG, 
                _T("AppLauncher will take care of any needed boot"));
        goto exit;
    }
   // open HKLM\\Software\\Microsoft\\SharedFax
    Rslt = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_SBS2000_FAX_SETUP,
        0,
        KEY_READ,
        &hKey
        );
    if (Rslt != ERROR_SUCCESS) 
    {
         VERBOSE(DBG_MSG, 
                _T("RegOpenKeyEx failed: (ec=%d)"),
                GetLastError());
        goto exit;
    }

    // check if ForceReboot flag exists
    Rslt = RegQueryValueEx(
        hKey,
        DEFERRED_BOOT,
        NULL,
        &Type,
        (LPBYTE) &Value,
        &Size
        );
    if (Rslt!=ERROR_SUCCESS) 
    {
         VERBOSE(DBG_MSG, 
                _T("RegQueryValueEx failed: (ec=%d)"),
                GetLastError());
        goto exit;
    }

    // tell WindowsInstaller a reboot is needed
    uiRet = MsiSetProperty(hInstall,_T("REBOOT"),_T("Force"));
    if (uiRet!=ERROR_SUCCESS) 
    {
         VERBOSE(DBG_MSG, 
                _T("MsiSetProperty failed: (ec=%d)"),
                uiRet);
        goto exit;
    }

    // delete ForceReboot flag
    Rslt = RegDeleteValue(hKey,DEFERRED_BOOT);
    if (Rslt!=ERROR_SUCCESS) 
    {
         VERBOSE(DBG_MSG, 
                _T("MsiSetMode failed: (ec=%d)"),
                Rslt);
        goto exit;
    }

exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return uiRet;
}


#define KODAKPRV_EXE_NAME       _T("\\KODAKPRV.EXE")
#define TIFIMAGE_COMMAND_KEY    _T("TIFImage.Document\\shell\\open\\command")
#define TIFIMAGE_DDEEXEC_KEY    _T("TIFImage.Document\\shell\\open\\ddeexec")
// 
//
// Function:    ChangeTifAssociation
//
// Description: This function changes the open verb for TIF files 
//              on WinME from Image Preview to Kodak Imaging
//
// Remarks:     
//              this is due to bad quality of viewing TIF faxes in the Image Preview tool
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall ChangeTifAssociation(MSIHANDLE hInstall)
{
    UINT            uiRet                           = ERROR_SUCCESS;
    TCHAR           szWindowsDirectory[MAX_PATH]    = {0};
    HANDLE          hFind                           = INVALID_HANDLE_VALUE;
    HKEY            hKey                            = NULL;
    LONG            lRet                            = 0;
    OSVERSIONINFO   viVersionInfo;
    WIN32_FIND_DATA FindFileData;

    DBG_ENTER(TEXT("ChangeTifAssociation"),uiRet);

    viVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&viVersionInfo))
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("GetVersionEx failed (ec: %ld)"),
                 uiRet);
        goto exit;
   }

    // Is this millennium?
    if (!
        (   (viVersionInfo.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) && 
            (viVersionInfo.dwMajorVersion==4) && 
            (viVersionInfo.dwMinorVersion>=90)
        )
       )
    {
        VERBOSE(DBG_MSG, 
                _T("This is not Windows Millenium, exit fucntion"));
        goto exit;
    }

    // find <WindowsFolder>\KODAKPRV.EXE 
    if (GetWindowsDirectory(szWindowsDirectory,MAX_PATH)==0)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("GetWindowsDirectory failed (ec: %ld)"),
                 uiRet);
        goto exit;
    }

    if (_tcslen(KODAKPRV_EXE_NAME)+_tcslen(szWindowsDirectory)>=MAX_PATH-4)
    {
        VERBOSE( SETUP_ERR, 
                 TEXT("Path to Kodak Imaging too long"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    _tcscat(szWindowsDirectory,KODAKPRV_EXE_NAME);

    hFind = FindFirstFile(szWindowsDirectory, &FindFileData);

    if (hFind==INVALID_HANDLE_VALUE) 
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("FindFirstFile %s failed (ec: %ld)"),
                 szWindowsDirectory,
                 uiRet);
        goto exit;
    }

    FindClose(hFind);

    _tcscat(szWindowsDirectory,_T(" \"%1\""));

    // set open verb
    lRet = RegOpenKey(  HKEY_CLASSES_ROOT,
                        TIFIMAGE_COMMAND_KEY,
                        &hKey);
    if (lRet!=ERROR_SUCCESS)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("RegOpenKey %s failed (ec: %ld)"),
                 TIFIMAGE_COMMAND_KEY,
                 uiRet);
        goto exit;
    }

    lRet = RegSetValueEx(   hKey,
                            NULL,
                            0,
                            REG_EXPAND_SZ,
                            (LPBYTE) szWindowsDirectory,
                            (_tcslen(szWindowsDirectory) + 1) * sizeof (TCHAR)
                        );
    if (lRet!=ERROR_SUCCESS)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("RegSetValueEx %s failed (ec: %ld)"),
                 szWindowsDirectory,
                 uiRet);

        goto exit;
    }

    lRet = RegDeleteKey(HKEY_CLASSES_ROOT,TIFIMAGE_DDEEXEC_KEY);
    if (lRet!=ERROR_SUCCESS)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("RegDeleteKey %s failed (ec: %ld)"),
                 TIFIMAGE_DDEEXEC_KEY,
                 uiRet);

        goto exit;
    }


exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return uiRet;
}


#define MAKE_RELATIVE(pMember,pBase) (pMember ? (((UINT)pMember)-UINT(pBase)) : NULL)
#define MAKE_ABSOLUTE(pMember,pBase) (pMember ? (((UINT)pMember)+UINT(pBase)) : NULL)

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FindExistingPrinters
//
//  Purpose:        
//                  This function enumerates the existing printers to SBS/BOS 2000
//                  Fax servers.
//                  The found printers are stored in the registry to be restored
//                  after the RemoveExistingProducts is run.
//                  Since the upgrade from SBS/BOS2000 requires uninstalling the existing
//                  Shared fax service client, the printer connection will be lost unless we
//                  save it prior to the removal of the client and restore afterwards.
//
//  Params:
//                  MSIHANDLE hInstall - handle to the instllation package
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 28-Oct-2001
///////////////////////////////////////////////////////////////////////////////////////
DLL_API UINT __stdcall FindExistingPrinters(MSIHANDLE hInstall)
{
    BYTE*   pbPrinterInfo   = NULL;
    DWORD   cb              = 0;
    DWORD   dwNumPrinters   = 0;
    DWORD   dwIndex         = 0;
    HKEY    hKey            = NULL;
    DWORD   dwRet           = ERROR_SUCCESS;

    DBG_ENTER(TEXT("FindExistingPrinters"), dwRet);

    // this call should fail due to lack of space...
    if (EnumPrinters(PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS,NULL,2,NULL,0,&cb,&dwNumPrinters))
    {
        VERBOSE( SETUP_ERR,TEXT("EnumPrinters succeeded with zero buffer, probably no printers."));
        goto exit;
    }

    dwRet = GetLastError();
    if (dwRet!=ERROR_INSUFFICIENT_BUFFER)
    {
        VERBOSE( SETUP_ERR,TEXT("EnumPrinters failed (ec: %ld)"),dwRet);
        goto exit;
    }

    dwRet = ERROR_SUCCESS;

    pbPrinterInfo = (BYTE*)MemAlloc(cb);
    if (!pbPrinterInfo)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        VERBOSE( SETUP_ERR,TEXT("MemAlloc failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // Get all existing printers into pbPrinterInfo
    if (!EnumPrinters(PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS,NULL,2,pbPrinterInfo,cb,&cb,&dwNumPrinters))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("EnumPrinters failed (ec: %ld)"),dwRet);
        goto exit;
    }

    if (dwNumPrinters==0)
    {
        VERBOSE( SETUP_ERR,TEXT("No printers to store"));
        goto exit;
    }

    // fix up pointers in the PRINTER_INFO_2 structure to become relative.
    for ( dwIndex=0 ; dwIndex<dwNumPrinters ; dwIndex++ ) 
    {
        PPRINTER_INFO_2 pInfo = &((PPRINTER_INFO_2)pbPrinterInfo)[dwIndex];

        VERBOSE(DBG_MSG,_T("Printer ' %s ' will be saved"), pInfo->pPrinterName);

        pInfo->pServerName          = LPTSTR(MAKE_RELATIVE(pInfo->pServerName,pInfo));
        pInfo->pPrinterName         = LPTSTR(MAKE_RELATIVE(pInfo->pPrinterName,pInfo));
        pInfo->pShareName           = LPTSTR(MAKE_RELATIVE(pInfo->pShareName,pInfo));
        pInfo->pPortName            = LPTSTR(MAKE_RELATIVE(pInfo->pPortName,pInfo));
        pInfo->pDriverName          = LPTSTR(MAKE_RELATIVE(pInfo->pDriverName,pInfo));
        pInfo->pComment             = LPTSTR(MAKE_RELATIVE(pInfo->pComment,pInfo));
        pInfo->pLocation            = LPTSTR(MAKE_RELATIVE(pInfo->pLocation,pInfo));
        pInfo->pSepFile             = LPTSTR(MAKE_RELATIVE(pInfo->pSepFile,pInfo));
        pInfo->pPrintProcessor      = LPTSTR(MAKE_RELATIVE(pInfo->pPrintProcessor,pInfo));
        pInfo->pDatatype            = LPTSTR(MAKE_RELATIVE(pInfo->pDatatype,pInfo));
        pInfo->pParameters          = LPTSTR(MAKE_RELATIVE(pInfo->pParameters,pInfo));
        pInfo->pDevMode             = LPDEVMODE(MAKE_RELATIVE(pInfo->pDevMode,pInfo));
        pInfo->pSecurityDescriptor  = PSECURITY_DESCRIPTOR(MAKE_RELATIVE(pInfo->pSecurityDescriptor,pInfo));
    }

    // open HKLM\\Software\\Microsoft\\SharedFax\\Setup\\Upgrade
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP_UPGRADE,TRUE,KEY_WRITE);
    if (!hKey)
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("OpenRegistryKey failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // store pbPrinterInfo to the registry.
    if (!SetRegistryBinary(hKey,REGVAL_STORED_PRINTERS,pbPrinterInfo,cb))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("SetRegistryBinary failed (ec: %ld)"),dwRet);
        goto exit;
    }

    if (!SetRegistryDword(hKey,REGVAL_STORED_PRINTERS_COUNT,dwNumPrinters))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("SetRegistryDword failed (ec: %ld)"),dwRet);
        goto exit;
    }

exit:
    if (pbPrinterInfo)
    {
        MemFree(pbPrinterInfo);
    }
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return dwRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  RestorePrinters
//
//  Purpose:        
//                  This function reads the list of printers from the registry and restores them
//                  the list was stored by a prior call to FindExistingPrinters and what was
//                  stored was the the result of a call to EnumPrinters which is an array of
//                  PRINTER_INFO_2. this array is scanned now for fax printers and they are
//                  restored. this data is kept in the registry during fax client setup since
//                  it's practically impossible to transfer large chunks of binary data between
//                  two deferred custom actions.
//
//  Params:
//                  MSIHANDLE hInstall - handle to the instllation package
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 28-Oct-2001
///////////////////////////////////////////////////////////////////////////////////////
DLL_API UINT __stdcall RestorePrinters(MSIHANDLE hInstall)
{
    HKEY            hKey            = NULL;
    BYTE*           pPrinterInfo    = NULL;
    DWORD           cb              = 0;
    DWORD           dwIndex         = 0;
    DWORD           dwNumPrinters   = 0;
    HANDLE          hPrinter        = NULL;
    DWORD           dwRet           = ERROR_SUCCESS;
    BOOL            fIsW9X          = FALSE;
    OSVERSIONINFO   osv;

    DBG_ENTER(TEXT("RestorePrinters"), dwRet);

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("GetVersionEx failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // If NT4/W2K, use AddPrinterConnection. if W9X, use AddPrinter.
    if (osv.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        fIsW9X = TRUE;
    }

    // open HKLM\\Software\\Microsoft\\SharedFax\\Setup\\Upgrade
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP_UPGRADE,TRUE,KEY_READ);
    if (!hKey)
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("OpenRegistryKey failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // get the array of PRINTER_INFO_2
    pPrinterInfo = GetRegistryBinary(hKey,REGVAL_STORED_PRINTERS,&cb);
    if (!pPrinterInfo)
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("GetRegistryBinary failed (ec: %ld)"),dwRet);
        goto exit;
    }
    if (cb==1)
    {
        // Data wasn't found in the registry.
        // Current implementation of GetRegistryBinary returns a 1-byte buffer of 0 in that case.
        // We know for sure that data must be longer than 10 bytes.
        //
        dwRet = ERROR_FILE_NOT_FOUND;
        VERBOSE( SETUP_ERR,TEXT("GetRegistryBinary failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // get the number of stored printers
    dwNumPrinters = GetRegistryDword(hKey,REGVAL_STORED_PRINTERS_COUNT);
    if (dwNumPrinters==0)
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("GetRegistryDword failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // for each printer check if this is a fax printer
    for (dwIndex=0;dwIndex<dwNumPrinters;dwIndex++) 
    {
        PPRINTER_INFO_2 pInfo = &((PPRINTER_INFO_2)pPrinterInfo)[dwIndex];

        // fixup pointers to become absulute again.
        pInfo->pServerName          = LPTSTR(MAKE_ABSOLUTE(pInfo->pServerName,pInfo));
        pInfo->pPrinterName         = LPTSTR(MAKE_ABSOLUTE(pInfo->pPrinterName,pInfo));
        pInfo->pShareName           = LPTSTR(MAKE_ABSOLUTE(pInfo->pShareName,pInfo));
        pInfo->pPortName            = LPTSTR(MAKE_ABSOLUTE(pInfo->pPortName,pInfo));
        pInfo->pDriverName          = LPTSTR(MAKE_ABSOLUTE(pInfo->pDriverName,pInfo));
        pInfo->pComment             = LPTSTR(MAKE_ABSOLUTE(pInfo->pComment,pInfo));
        pInfo->pLocation            = LPTSTR(MAKE_ABSOLUTE(pInfo->pLocation,pInfo));
        pInfo->pSepFile             = LPTSTR(MAKE_ABSOLUTE(pInfo->pSepFile,pInfo));
        pInfo->pPrintProcessor      = LPTSTR(MAKE_ABSOLUTE(pInfo->pPrintProcessor,pInfo));
        pInfo->pDatatype            = LPTSTR(MAKE_ABSOLUTE(pInfo->pDatatype,pInfo));
        pInfo->pParameters          = LPTSTR(MAKE_ABSOLUTE(pInfo->pParameters,pInfo));
        pInfo->pDevMode             = LPDEVMODE(MAKE_ABSOLUTE(pInfo->pDevMode,pInfo));
        pInfo->pSecurityDescriptor  = PSECURITY_DESCRIPTOR(MAKE_ABSOLUTE(pInfo->pSecurityDescriptor,pInfo));

        if ( _tcsicmp(pInfo->pDriverName,FAX_DRIVER_NAME))
        {
            VERBOSE( DBG_MSG,TEXT("Printer %s is not a fax printer "),pInfo->pDriverName);
            continue;
        }

        //  This is SBS 5.0 or .NET SB3/RC1 Server Fax Printer Connections.
        //		During the upgrade, Uninstall removed them from the system. 
		//		We need to put them back.
		//
        if (fIsW9X)
        {
            hPrinter = AddPrinter(NULL,2,LPBYTE(pInfo));
            if (!hPrinter)
            {
                //  Failed to add printer
                dwRet = GetLastError();
                VERBOSE( SETUP_ERR,TEXT("AddPrinter failed (ec: %ld)"),dwRet);
                continue;
            }
            ClosePrinter(hPrinter);
            hPrinter = NULL;

            VERBOSE(DBG_MSG, _T("Printer ' %s ' is restored"), pInfo->pPrinterName);
        }
        else
        {
            if (!AddPrinterConnection(pInfo->pPrinterName))
            {
                //  Failed to add printer connection
                dwRet = GetLastError();
                VERBOSE( SETUP_ERR,TEXT("AddPrinterConnection failed (ec: %ld)"),dwRet);
                continue;
            }
        }
    }

exit:
    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    // finally, remove the stored printers key from the registry
    if (!DeleteRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP_UPGRADE))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("DeleteRegistryKey failed (ec: %ld)"),dwRet);
        goto exit;
    }
    return dwRet;

}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  DetectSBSServer
//
//  Purpose:        
//                  This function detects if SBS2000 Fax service is installed
//                  If it is, it sets a property in the MSI installation and
//                  causes the LaunchCondition to block the installation of
//                  the client on such machines.
//
//  Params:
//                  MSIHANDLE hInstall - handle to the instllation package
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 23-Jan-2002
///////////////////////////////////////////////////////////////////////////////////////
DLL_API UINT __stdcall DetectSBSServer(MSIHANDLE hInstall)
{
	DWORD	dwRet = NO_ERROR;
	DWORD	dwFaxInstalled = FXSTATE_NONE;
	
    DBG_ENTER(TEXT("DetectSBSServer"),dwRet);

	if (CheckInstalledFax(FXSTATE_SBS5_SERVER, &dwFaxInstalled) != ERROR_SUCCESS)
	{
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("CheckInstalledFaxClient failed (ec: %ld)"),dwRet);
		return dwRet;
	}

	if (dwFaxInstalled != FXSTATE_NONE)
	{
		VERBOSE( DBG_MSG,TEXT("SBS2000 Fax service is installed, set SBSSERVERDETECTED in MSI"));
		if (MsiSetProperty(hInstall,_T("SBSSERVERDETECTED"),_T("1"))!=ERROR_SUCCESS)
		{
			dwRet = GetLastError();
			VERBOSE( SETUP_ERR,TEXT("MsiSetProperty failed (ec: %ld)"),dwRet);
			return dwRet;
		}
	}
	return dwRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SecureFxsTmpFolder
//
//  Purpose:        
//                  This function secures the FxsTmp folder we create under 
//                  %systemroot%\system32.
//                  This folder needs special security since it holds the preview
//                  file of the sent TIFF and can potentially expose all 
//                  outgoing faxes.
//                  The security applied to this folder is as follows:
//
//                  BUILTIN\Administrators:(OI)(CI)F    - Full control, folder and files
//                  NT AUTHORITY\SYSTEM:(OI)(CI)F       - Full control, folder and files
//                  CREATOR OWNER:(OI)(CI)(IO)F         - Full control, files only
//                  BUILTIN\Users:(special access:)     - SYNCHRONIZE
//                                                      - FILE_READ_DATA
//                                                      - FILE_WRITE_DATA
//
//  Params:
//                  MSIHANDLE hInstall - handle to the instllation package
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 09-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DLL_API UINT __stdcall SecureFxsTmpFolder(MSIHANDLE hInstall)
{
    DWORD                       dwRet                       = 0;
    DWORD                       dwFileAttributes            = 0;
    SID_IDENTIFIER_AUTHORITY    NtAuthority                 = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorSidAuthority         = SECURITY_CREATOR_SID_AUTHORITY;
    PSID                        pSidAliasAdmins             = NULL;
    PSID                        pSidAliasUsers              = NULL;
    PSID                        pSidAliasSystem             = NULL;
    PSID                        pSidCreatorOwner            = NULL;
    TCHAR                       szFolderToSecure[MAX_PATH]  = {0};
    PACL                        pNewAcl                     = NULL;
    EXPLICIT_ACCESS             ExplicitAccess[4];
    SECURITY_DESCRIPTOR         NewSecurityDescriptor;
	BOOL						bNT4OS;
	OSVERSIONINFO				osv;

    DBG_ENTER(TEXT("SecureFxsTmpFolder"), dwRet);
	
	// What version of Windows are you running?
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
		dwRet = GetLastError();
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                dwRet);        
        goto exit;
    }
    
    if (osv.dwMajorVersion >= 5) // Windows 2000 or later...
    {
		bNT4OS = FALSE;        
    }
	else
	{
		//
		// On NT4, SetEntriesInAcl() does not seem to work with CREATOR OWNER SID.
		// Adding the CREATOR OWNER ACE using AddAccessAllowedAce()
		//
		bNT4OS = TRUE;
	}

    if (GetSystemDirectory(szFolderToSecure,MAX_PATH-_tcslen(FAX_PREVIEW_TMP_DIR)-2))
    {
        VERBOSE( DBG_MSG,TEXT("GetSystemDirectory succeeded (%s)"),szFolderToSecure);
    }
    else
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("GetSystemDirectory failed (ec: %ld)"),dwRet);
        goto exit;
    }
    
    _tcscat(szFolderToSecure,FAX_PREVIEW_TMP_DIR);
    VERBOSE( DBG_MSG,TEXT("Folder to secure is %s"),szFolderToSecure);

    // Allocate and initialize the local admins SID
    if (!AllocateAndInitializeSid( &NtAuthority,
                                   2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0,0,0,0,0,0,
                                   &pSidAliasAdmins
                                  ))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("AllocateAndInitializeSid failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // Allocate and initialize the local users SID
    if (!AllocateAndInitializeSid( &NtAuthority,
                                   2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_USERS,
                                   0,0,0,0,0,0,
                                   &pSidAliasUsers
                                  ))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("AllocateAndInitializeSid failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // Allocate and initialize the system SID
    if (!AllocateAndInitializeSid( &NtAuthority,
                                   1,
                                   SECURITY_LOCAL_SYSTEM_RID,
                                   0,0,0,0,0,0,0,
                                   &pSidAliasSystem
                                  ))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("AllocateAndInitializeSid failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // Allocate and initialize the creator owner SID
    if (!AllocateAndInitializeSid( &CreatorSidAuthority,
                                   1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0,0,0,0,0,0,0,
                                   &pSidCreatorOwner
                                  ))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("AllocateAndInitializeSid failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // Admins have full control 
    ExplicitAccess[0].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[0].grfAccessMode = SET_ACCESS;
    ExplicitAccess[0].grfInheritance= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    ExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ExplicitAccess[0].Trustee.ptstrName  = (LPTSTR) pSidAliasAdmins;

    // System has full control
    ExplicitAccess[1].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[1].grfAccessMode = SET_ACCESS;
    ExplicitAccess[1].grfInheritance= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    ExplicitAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ExplicitAccess[1].Trustee.ptstrName  = (LPTSTR) pSidAliasSystem;

    // Users have SYNCHRONIZE, FILE_READ_DATA, FILE_WRITE_DATA - this folder only
    ExplicitAccess[2].grfAccessPermissions = FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE;
    ExplicitAccess[2].grfAccessMode = SET_ACCESS;
    ExplicitAccess[2].grfInheritance= NO_INHERITANCE;
    ExplicitAccess[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ExplicitAccess[2].Trustee.ptstrName  = (LPTSTR) pSidAliasUsers;

	if (FALSE == bNT4OS)
	{
		//
		// SetEntriesInAcl works fine with CREATOR OWNER
		//
		 
		// Creator Owner - full control - subfolders and files only
		ExplicitAccess[3].grfAccessPermissions = GENERIC_ALL;
		ExplicitAccess[3].grfAccessMode = SET_ACCESS;
		ExplicitAccess[3].grfInheritance= INHERIT_ONLY_ACE | SUB_OBJECTS_ONLY_INHERIT | SUB_CONTAINERS_ONLY_INHERIT;
		ExplicitAccess[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ExplicitAccess[3].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ExplicitAccess[3].Trustee.ptstrName  = (LPTSTR) pSidCreatorOwner;
	}

    // make an ACL from the admins only
    dwRet = SetEntriesInAcl(
		bNT4OS ? 3 : 4,
		ExplicitAccess,
		NULL,
		&pNewAcl);
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE( SETUP_ERR,TEXT("SetEntriesInAcl failed (ec: %ld)"),dwRet);
        goto exit;
    }

	if (TRUE == bNT4OS)
	{
		//
		// We are running on NT4, add the CREATOR OWNER ACE using AddAccessAllowedAce()
		//
		ACL_SIZE_INFORMATION		AclSizeInfo;
		PACL                        pFullNewAcl                 = NULL;
		WORD						wFullAclSize				= 0;
		ACCESS_ALLOWED_ACE*			pAce						= NULL;

		//
		// Get the current ACL size
		//
		if (!GetAclInformation(pNewAcl, &AclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		{
			dwRet = GetLastError();
			VERBOSE( SETUP_ERR, TEXT("GetAclInformation failed (ec: %ld)"), dwRet);
			goto exit;
		}

		wFullAclSize = (WORD)(AclSizeInfo.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE) 
				+ GetLengthSid(pSidCreatorOwner));      

		//
		// Re-allocate big enough ACL
		//
		pFullNewAcl = (PACL)LocalAlloc(0, wFullAclSize);
		if (NULL == pFullNewAcl)
		{
			VERBOSE( SETUP_ERR,TEXT("LocalAlloc failed (ec: %ld)"),GetLastError());
			goto exit;
		}	
		CopyMemory(pFullNewAcl, pNewAcl, AclSizeInfo.AclBytesInUse);
		LocalFree(pNewAcl);
		pNewAcl = pFullNewAcl;

		//
		// Set the correct ACL size
		//
		pNewAcl->AclSize = wFullAclSize;	
		if (!AddAccessAllowedAce(
			pNewAcl, 
			ACL_REVISION, 
			GENERIC_ALL, 		
			pSidCreatorOwner))
		{
			dwRet = GetLastError();
			VERBOSE( SETUP_ERR, TEXT("AddAccessAllowedAce failed (ec: %ld)"), dwRet);
			goto exit;
		}

		//
		// Change the last ACE flags, so it will be inherited to child objects.
		//
		if (!GetAce(
			pNewAcl, 
			3, 
			(VOID**)&pAce
			))
		{
			dwRet = GetLastError();
			VERBOSE( SETUP_ERR, TEXT("GetAce failed (ec: %ld)"),dwRet);
			goto exit;
		}
		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE;
	}

    if (!InitializeSecurityDescriptor(&NewSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("InitializeSecurityDescriptor failed (ec: %ld)"),dwRet);
        goto exit;
    }

    //
    // Add the ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(&NewSecurityDescriptor, TRUE, pNewAcl, FALSE))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("SetSecurityDescriptorDacl failed (ec: %ld)"),dwRet);
        goto exit;
    }

    // set security so only admins can access
    if (!SetFileSecurity(   szFolderToSecure,
                            DACL_SECURITY_INFORMATION,
                            &NewSecurityDescriptor))
    {
        dwRet = GetLastError();
        VERBOSE( SETUP_ERR,TEXT("SetFileSecurity failed (ec: %ld)"),dwRet);
        goto exit;
    }


exit:

    if (pSidAliasUsers)
    {
        FreeSid(pSidAliasUsers);
    }
    if (pSidAliasAdmins)
    {
        FreeSid(pSidAliasAdmins);
    }
    if (pSidAliasSystem)
    {
        FreeSid(pSidAliasSystem);
    }
    if (pSidCreatorOwner)
    {
        FreeSid(pSidCreatorOwner);
    }
    if (pNewAcl)
    {
        LocalFree(pNewAcl);
    }
    return dwRet;
}


/*
Function:	
			CreateFaxPrinterName
Purpose:
			This function extracts Server Name from the Port Name and concatenates to it
				the FAX_PRINTER_NAME. This is used when adding a fax printer connection in
				the W9x systems.

			This function takes the '\\server-name\fax-printer-name' port name and returns
				'fax-printer-name (server-name)' fax printer name.

			This is done to prevent clashing between fax printer names for different servers.

			The caller must free the *ptzFaxPrinterName.
Params:

	IN LPCTSTR tzPortName			- the port name, of format "\\server-name\fax-printer-name"
	OUT LPTSTR* ptzFaxPrinterName	- the resulting buffer

Return Value:

	NO_ERROR - everything was ok.
	Win32 Error code in case if failure.

Author:
		Iv Vakaluk, 28-May-2002
*/

DWORD CreateFaxPrinterName(
	IN LPCTSTR tzPortName,
	OUT LPTSTR* ptzPrinterName
)
{
	DWORD	dwRet = NO_ERROR;
	TCHAR	tzFaxServerName[MAX_PATH];
	TCHAR	tzFaxPrinterName[MAX_PATH];
	LPTSTR	lptstrResult = NULL;
	DWORD	dwSize = 0;

    DBG_ENTER(_T("CreateFaxPrinterName"), dwRet);

	if ((!tzPortName) || ((_tcslen(tzPortName)) == 0))
	{
        VERBOSE(SETUP_ERR, _T("Port Name is empty."));
		dwRet = ERROR_INVALID_PARAMETER;
		return dwRet;
	}

	//
	//	delimiter scanf uses by default is white-space characters ( ' ', '\t', '\n' )
	//	i need that '\\' will be delimiter.
	//	this is done by specifiing the [^\\] for scanf.
	//	[x] instructs scanf to read only 'x' and stop at any other input.
	//	[^x] instructs scanf to read anything until 'x' is reached. 
	//
	if (_stscanf(tzPortName, _T("\\\\%[^\\] \\ %[^\0]"), tzFaxServerName, tzFaxPrinterName) != 2)
	{
		VERBOSE(SETUP_ERR, _T("sscanf() failed. Should be wrong tzPortName='%s'."), tzPortName);
		dwRet = ERROR_INVALID_PARAMETER;
		return dwRet;
	}

	//
	//	size(result name) = size(server name) + size(FAX_PRINTER_NAME) + size(space + 2 parentesis + NULL)
	//
	dwSize = _tcslen(tzFaxServerName) + _tcslen(tzFaxPrinterName) + 4;

	lptstrResult = LPTSTR(MemAlloc(dwSize * sizeof TCHAR));
	if (!lptstrResult)
	{
		VERBOSE (GENERAL_ERR, _T("Not enough memory"));
		dwRet = ERROR_NOT_ENOUGH_MEMORY;
		return dwRet;
	}

	_sntprintf(lptstrResult, dwSize, _T("%s (%s)"), tzFaxPrinterName, tzFaxServerName);
	VERBOSE(DBG_MSG, _T("Printer Name is : '%s'"), lptstrResult);

	*ptzPrinterName = lptstrResult;
	return dwRet;
}

/*
Function:	
			SetBOSProgramFolder
Purpose:
			This function does the following :
				a) creates path from the given CSIDL of the system path and given folder name.
				b) verifyes that the path is valid.
				c) optionally writes the valid path in the MSI property called 'BOSProgramFolder'.

			Called from FindBOSProgramFolder custom action.

Params:

	IN MSIHANDLE	hInstall		-	the MSI handle 
	IN int			nFolder			-	A CSIDL value that identifies the folder whose path is to be retrieved
	LPCTSTR			tzProgramName	-	localized name of the BOS Fax Client Program Menu Entry

Return Value:

	NO_ERROR - everything was ok.
	Win32 Error code in case if failure.

Author:
		Iv Vakaluk, 01-July-2002
*/
DWORD	SetBOSProgramFolder(MSIHANDLE hInstall, int nFolder, LPCTSTR tzProgramName)
{
	DWORD		dwRes							= ERROR_SUCCESS;
	HRESULT		hr								= ERROR_SUCCESS;
	TCHAR		tzFullProgramPath[MAX_PATH*2]	= {0};

	DBG_ENTER(_T("SetBOSProgramFolder"), dwRes);

	//
	//	Get the path to the given CSIDL system folder
	//
    hr = SHGetFolderPath (NULL, nFolder, NULL, SHGFP_TYPE_CURRENT, (LPTSTR)tzFullProgramPath);
    if (FAILED(hr))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SHGetFolderPath()"), hr);
        return (dwRes = ERROR_PATH_NOT_FOUND);
    }
	VERBOSE(DBG_MSG, _T("The system folder to look in : %s"), tzFullProgramPath);

	//
	//	add the program name to the path 
	//
    _tcsncat(tzFullProgramPath, _T("\\"), (ARR_SIZE(tzFullProgramPath) - _tcslen(tzFullProgramPath) - 1));
    _tcsncat(tzFullProgramPath, tzProgramName, (ARR_SIZE(tzFullProgramPath) - _tcslen(tzFullProgramPath) -1));
	VERBOSE(DBG_MSG, _T("The full path to look for : %s"), tzFullProgramPath);

	//
	//	check that this path is valid
	//
	if (INVALID_FILE_ATTRIBUTES == GetFileAttributes(tzFullProgramPath))
	{
		VERBOSE(DBG_MSG, _T("The full path is not found."));
		return (dwRes = ERROR_PATH_NOT_FOUND);
	}

	VERBOSE(DBG_MSG, _T("The full path is OK ==> write it into MSI property."));

	//
	//	write it into the MSI
	//
	if (hInstall)
	{
		UINT	uiRes = ERROR_SUCCESS;

        uiRes = MsiSetProperty(hInstall, _T("BOSProgramFolder"), tzFullProgramPath);
		if (uiRes != ERROR_SUCCESS)
		{
			VERBOSE(SETUP_ERR, _T("MSISetProperty(BOSProgramFolder) is failed."));
			return (dwRes = ERROR_FUNCTION_FAILED);
		}
	}

	return dwRes;
}


/*
Function:	
			FindBOSProgramFolder
Purpose:
			This custom action is used to set the MSI property called 'BOSProgramFolder' 
				to the name of the folder of BOS Fax Client on NT4 machines.
			This is because the shortcuts of BOS Fax Client is not removed during the upgrade to .NET Fax Client.
			And we must remove them manually.
			We are using RemoveFile table for this, and we must know the folder where these shortcuts reside.

			The function does following :
				a)	reads from the MSI the name of the BOS Fax Client Program Menu Entry.
				b)	calls SetBOSProgramFolder to look for this program first in the 
						COMMON PROGRAMS and if not successfull, then in the CURRENT USER PROGRAMS profiles.
				c) SetBOSProgramFolder checks for the path validity	and writes it into the MSI. 
Params:

	IN MSIHANDLE	hInstall	-	the MSI handle 

Return Value:

	NO_ERROR - everything was ok.
	Win32 Error code in case if failure.

Author:
		Iv Vakaluk, 30-June-2002
*/

DLL_API UINT __stdcall FindBOSProgramFolder(MSIHANDLE hInstall)
{
    UINT	rc						= ERROR_INSTALL_FAILURE;    
	TCHAR	tzProgramName[MAX_PATH] = {0};

    DBG_ENTER(TEXT("FindBOSProgramFolder"), rc);

	//
	//	Get from MSI the localized name of the program menu entry that we are looking for
	//
    if (!PrivateMsiGetProperty(hInstall, _T("BOSProgramName"), tzProgramName))
    {
        VERBOSE (SETUP_ERR, _T("PrivateMsiGetProperty(BOSProgramName) failed (ec: %ld)"), GetLastError());
        return rc;
    }

	//
	//	Look in the COMMON PROGRAMS
	//
	rc = SetBOSProgramFolder(hInstall, CSIDL_COMMON_PROGRAMS, tzProgramName);
	if (rc == ERROR_PATH_NOT_FOUND)
	{
		//
		//	Look in the CURRENT USER PROGRAMS
		//
		rc = SetBOSProgramFolder(hInstall, CSIDL_PROGRAMS, tzProgramName);
	}

	if (rc != ERROR_SUCCESS)
	{
		VERBOSE(SETUP_ERR, _T("Failed to find a program path / to set MSI property."));
		rc = ERROR_INSTALL_FAILURE;
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\bootstrap\setup.cpp ===
// setup.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

#define REBOOT_EQUALS_REALLY_SUPPRESS   _T("REBOOT=ReallySuppress")


DWORD LaunchInstallation(LPSTR lpCmdLine);


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    OSVERSIONINFO       osv;
	HMODULE				hModule							= NULL;
    int                 iRes                            = 1;
    LPCTSTR             lpctstrMsiDllName               = _T("MSI.DLL");
    HKEY                hKey                            = NULL;
    LONG                lRes                            = ERROR_SUCCESS;
    DWORD               dwData                          = 1;

    DBG_ENTER(TEXT("WinMain"),iRes);

    // Check if this is Win98
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        VERBOSE(GENERAL_ERR,_T("GetVersionEx failed: (ec=%d)"),GetLastError());
        iRes = 0;
        goto exit;
    }

    if ((osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
        (osv.dwMinorVersion > 0))
    {
        VERBOSE (DBG_MSG,TEXT("This is Win98 OS"));
    }
    else
    {
        VERBOSE (DBG_MSG,TEXT("This is not Win98 OS, no need to force reboot"));
        iRes = 0;
        goto exit;
    }

    // check if msi.dll exists
	hModule = LoadLibrary(lpctstrMsiDllName);
	if (hModule)
    {
        VERBOSE (DBG_MSG,TEXT("Msi.dll found, no need to force reboot"));

        FreeLibrary(hModule);
		hModule = NULL;
        iRes = 0;
        goto exit;
    }

    // write registry DeferredBoot value
    lRes = RegCreateKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP,&hKey);
    if (!((lRes==ERROR_SUCCESS) || (lRes==ERROR_ALREADY_EXISTS)))
    {
        VERBOSE(GENERAL_ERR,_T("RegCreateKey failed: (ec=%d)"),GetLastError());
        iRes = 0;
        goto exit;
    }

    lRes = RegSetValueEx(   hKey,
                            DEFERRED_BOOT,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwData,
                            sizeof(DWORD)
                        );
    if (lRes!=ERROR_SUCCESS)
    {
        VERBOSE(GENERAL_ERR,_T("RegSetValueEx failed: (ec=%d)"),GetLastError());
        iRes = 0;
        goto exit;
    }

exit:

	if (hKey)
	{
        RegCloseKey(hKey);
	}

    // launch Install Shield's setup.exe
	iRes = LaunchInstallation(lpCmdLine);

    return iRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  LaunchInstallation
//
//  Purpose:        
//                  This function launches the MSI client installation
//					it waits for the installation to complete and writes
//					to the registry in case a reboot was reqeuired.
//
//  Params:
//                  LPSTR lpCmdLine - command line passed in to setup.exe
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 31-Jan-2002
///////////////////////////////////////////////////////////////////////////////////////
DWORD LaunchInstallation(LPSTR lpCmdLine)
{
	DWORD				dwRet							= ERROR_SUCCESS;
    TCHAR				szSystemDirectory[MAX_PATH]		= {0};
    CHAR*               pcRebootPropInCmdLine           = NULL;
	SHELLEXECUTEINFO    executeInfo                     = {0};
    BOOL                bCheckExitCode                  = FALSE;
    DWORD               dwWaitRes                       = 0;
    DWORD               dwExitCode                      = 0;
    HKEY                hKey                            = NULL;
    LONG                lRes                            = ERROR_SUCCESS;
    DWORD               dwData                          = 1;
    TCHAR*              tpBuf                           = NULL;
	HRESULT				hr								= ERROR_SUCCESS;

    DBG_ENTER(TEXT("LaunchInstallation"),dwRet);

    // launch Install Shield's setup.exe
    if (GetModuleFileName(NULL,szSystemDirectory,MAX_PATH)==0)
    {
        VERBOSE(GENERAL_ERR,_T("GetModuleFileName failed: (ec=%d)"),GetLastError());
        return 0;
    }

    if ((tpBuf = _tcsrchr(szSystemDirectory,_T('\\')))==NULL)
    {
        VERBOSE(GENERAL_ERR,_T("_tcsrchr failed"));
        return 0;
    }

    _tcscpy(_tcsinc(tpBuf),_T("fxssetup.exe"));
    VERBOSE (DBG_MSG,TEXT("Running %s"),szSystemDirectory);

    // if the command line contains REBOOT=ReallySuppress we will check 
    // the return value of the Installer
    pcRebootPropInCmdLine = strstr(lpCmdLine,REBOOT_EQUALS_REALLY_SUPPRESS);
    if (pcRebootPropInCmdLine)
    {
        VERBOSE (DBG_MSG,TEXT("REBOOT=ReallySuppress is included in the command line, checking for reboot after setup"));
        bCheckExitCode = TRUE;
    }
    else
    {
        VERBOSE (DBG_MSG,TEXT("REBOOT=ReallySuppress is not included in the command line, ignoring exit code of setup"));
    }

	executeInfo.cbSize = sizeof(executeInfo);
	executeInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
	executeInfo.lpVerb = TEXT("open");
	executeInfo.lpFile = szSystemDirectory;
    executeInfo.lpParameters = lpCmdLine;
	executeInfo.nShow  = SW_RESTORE;
	//
	// Execute an aplication
	//
	if (!ShellExecuteEx(&executeInfo))
	{
        VERBOSE(GENERAL_ERR,_T("ShellExecuteEx failed: (ec=%d)"),GetLastError());
		return 0;
	}

	if (executeInfo.hProcess==NULL)
	{
        VERBOSE(GENERAL_ERR, _T("hProcess in NULL, can't wait"),GetLastError());
		return 1;
	}

    if ((dwWaitRes=WaitForSingleObject(executeInfo.hProcess, INFINITE))==WAIT_FAILED)
    {
        VERBOSE(GENERAL_ERR,_T("WaitForSingleObject failed: (ec=%d)"),GetLastError());
    }
    else if (dwWaitRes==WAIT_OBJECT_0)
    {
        VERBOSE(DBG_MSG, _T("fxssetup.exe terminated"));

        // now let's get the process's return code, see if we need a reboot.
        if (!GetExitCodeProcess( executeInfo.hProcess, &dwExitCode ))
        {
            VERBOSE (GENERAL_ERR,TEXT("GetExitCodeProcess failed! (err=%ld)"),GetLastError());
        }
        else
        {
            VERBOSE (DBG_MSG,TEXT("GetExitCodeProcess returned %ld."),dwExitCode);

            if ( bCheckExitCode && (dwExitCode==ERROR_SUCCESS_REBOOT_REQUIRED))
            {
                VERBOSE (DBG_MSG,TEXT("Installation requires reboot, notify AppLauncher"));

                // notify AppLauncher that we need a reboot...
                lRes = RegCreateKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP,&hKey);
                if ((lRes==ERROR_SUCCESS) || (lRes==ERROR_ALREADY_EXISTS))
                {
                    lRes = RegSetValueEx(   hKey,
                                            DEFERRED_BOOT,
                                            0,
                                            REG_DWORD,
                                            (LPBYTE) &dwData,
                                            sizeof(DWORD)
                                        );
                    if (lRes!=ERROR_SUCCESS)
                    {
                        VERBOSE(GENERAL_ERR,_T("RegSetValueEx failed: (ec=%d)"),GetLastError());
                        dwRet = ERROR_SUCCESS;
                    }

                    RegCloseKey(hKey);
                }
                else
                {
                    VERBOSE(GENERAL_ERR,_T("RegCreateKey failed: (ec=%d)"),GetLastError());
                    dwRet = ERROR_SUCCESS;
                }
            }
            else if (dwExitCode!=ERROR_SUCCESS)
            {
                VERBOSE (GENERAL_ERR,TEXT("Installation failed"));
            }
        }
    }
    else
    {
        VERBOSE(GENERAL_ERR,_T("WaitForSingleObject returned unexpected result: (ec=%d)"),dwWaitRes);
    }

    if(!CloseHandle(executeInfo.hProcess))
    {
        VERBOSE(GENERAL_ERR,_T("CloseHandle failed: (ec=%d)"),GetLastError());
    }

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\customactions\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//#if _MSC_VER > 1000
#pragma once
//#endif // _MSC_VER > 1000

#include <windows.h>
#include <stdio.h>    // printf/wprintf
#include <shellapi.h>
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <crtdbg.h>
#include <shlobj.h>
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "faxreg.h"
#include "WinSpool.h"
#include "faxutil.h"
#include "stdlib.h"
#include "resource.h"

#include "migration.h"
#include "setuputil.h"
#include "debugex.h"

#define DLL_API __declspec(dllexport)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\customactions\sources.inc ===
!IF 0
Copyright (c) 1996  Microsoft Corporation

!ENDIF


!include ..\..\..\..\faxsrc.inc

INCLUDES=$(INCLUDES);.\..\;$(FAXROOT)\setup\inc;

C_DEFINES=$(C_DEFINES) -DDLL_EXPORTS=1
USECXX_FLAG=/Tp

TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=MSIClientCustomActions.DEF
UMTYPE= windows
DLLENTRY=_DllMainCRTStartup
!IF 0
NTPROFILEINPUT=yes
!ENDIF

USE_LIBCMT=1
NTKEEPRESOURCETMPFILES=1

PRECOMPILED_INCLUDE=..\StdAfx.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

INCLUDES=\
  $(INCLUDES); \

TARGETLIBS=\
  $(BASEDIR)\public\sdk\lib\*\msi.lib 	      \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib       \
  $(BASEDIR)\public\sdk\lib\*\user32.lib      \
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\shfolder.lib     \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(FAXROOT)\util\$(ANSII_UNICODE)\obj\*\faxutil.lib \
  $(FAXROOT)\setup\util\$(ANSII_UNICODE)\obj\*\setuputil.lib \
  $(FAXROOT)\util\debugex\$(ANSII_UNICODE)\obj\*\debugex.lib \

C_DEFINES= $(C_DEFINES) -DENABLE_FRE_LOGGING

SOURCES=\
  ..\MSIClientCustomActions.cpp   \
  ..\MSIClientCustomActions.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\ism\makefile.inc ===
all: ISM2MSI
ISM2MSI: ClientSetup.ism 
!ifdef LINKONLY
	ism2msi.cmd
!else
	ech Pass 1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\msi\makefile.inc ===
all: UPDATEMSI
UPDATEMSI: 
!ifdef LINKONLY
	UPDATEMSI.cmd
!else
	ech Pass 1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inc\setuputil.h ===
//File: setuputil.h
#include <TCHAR.h>
#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <Msi.h>
#include <DebugEx.h>

#define MIGRATION_KEY                   TEXT("Software\\Microsoft\\Fax\\Migration")
#define SETUP_KEY                       TEXT("Software\\Microsoft\\Fax\\Setup")
#define MIGRATION_COVER_PAGES           TEXT("CoverPagesDirectory")
#define NEW_COVER_PAGES                 TEXT("CoverPageDir")
#define REGKEY_SBS45_W9X_ARP            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\FaxWizardDeinstKey")
#define REGKEY_SBS45_W9X_CLIENT         TEXT("SOFTWARE\\Microsoft\\Microsoft Fax Server Client")

#define ADDINS_DIRECTORY                    _T("Addins\\")
#define FXSEXT_ECF_FILE                     _T("FXSEXT.ecf")
#define DEFERRED_BOOT                       _T("DeferredBoot")
#define REGKEY_SBS2000_FAX                  _T("Software\\Microsoft\\SharedFax")
#define REGKEY_SBS2000_FAX_SETUP            REGKEY_SBS2000_FAX _T("\\Setup")
#define REGKEY_SBS2000_FAX_SETUP_UPGRADE    REGKEY_SBS2000_FAX_SETUP _T("\\Upgrade")

#define REGKEY_SBS2000_FAX_BACKUP           TEXT("Software\\Microsoft\\SharedFaxBackup")

#define REGVAL_STORED_PRINTERS          TEXT("StoredPrinters")
#define REGVAL_STORED_PRINTERS_COUNT    TEXT("StoredPrintersCount")

#define W9X_PRINT_ENV               _T("Windows 4.0")
#define NT4_PRINT_ENV               _T("Windows NT x86")


//
// fax common setup routines
//

BOOL PrivateMsiGetProperty
(
    MSIHANDLE hInstall,    // installer handle
    LPCTSTR szName,        // property identifier, case-sensitive
    LPTSTR szValueBuf      // buffer for returned property value
);


BOOL
DeleteFaxPrinter(
    LPCTSTR lptstrFaxPrinterName    // name of the printer to delete
);


BOOL FillDriverInfo(DRIVER_INFO_3* pDriverInfo3,LPCTSTR pEnvironment);

DWORD   IsMSIProductInstalled(LPCTSTR pProductGUID,BOOL* pbProductInstalled);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inc\faxsetup.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    faxSetup.h

Abstract:

    Header file for definitions common for the setup

Author:

    Iv Garber (IvG) Mar, 2001

Revision History:

--*/

#ifndef _FXSETUP_H_
#define _FXSETUP_H_

#include "msi.h"

typedef INSTALLSTATE (WINAPI *PF_MSIQUERYPRODUCTSTATE) (LPCTSTR szProduct);


#define PRODCODE_SBS5_CLIENT	_T("{E0ED877D-EA6A-4274-B0CB-99CD929A92C1}")	//	SBS 5.0 Client
#define PRODCODE_BETA3_CLIENT	_T("{BCF670F5-3034-4D11-9D7C-6092572EFD1E}")	//	.NET Server Beta 3 Client
#define PRODCODE_SBS5_SERVER	_T("{A41E15DA-AD35-43EF-B9CC-FE948F1F04C0}")	//	SBS 5.0 Server
#define PRODCODE_DOTNET_CLIENT	_T("{01E8D7EF-756B-4ABA-827B-36E63DD7CE1D}")	//	.NET RC1 Client


#define FAX_INF_NAME        _T("FXSOCM.INF")
#define WINDOWS_INF_DIR     _T("INF")
#define FAX_INF_PATH        _T("\\") WINDOWS_INF_DIR _T("\\") FAX_INF_NAME


#define REGKEY_ACTIVE_SETUP_NT                      _T("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{8b15971b-5355-4c82-8c07-7e181ea07608}")
#define REGVAL_ACTIVE_SETUP_PER_USER_APP_UPGRADE    _T(".AppUpgrade")

//
//  Unattended Answer File Section and Keys
//
#define     UNATTEND_FAX_SECTION            _T("Fax")

//
//  Used in Migrate.DLL to write the fax applications that were installed before the upgrade blocked them.
//  Then used in OCM to know what was installed before the Upgrade and behave accordingly ( Where Did My Fax Go )
//
#define     UNINSTALLEDFAX_INFKEY           _T("UninstalledFaxApps")


//
//  Typedef used during the Migration and OCM parts of Upgrade to define which Fax Applications are/were installed
//
typedef enum fxState_UpgradeApp_e
{
    FXSTATE_NONE			= 0x00,
    FXSTATE_SBS5_CLIENT		= 0x01,		//	SBS 5.0 Client
    FXSTATE_SBS5_SERVER		= 0x02,		//	SBS 5.0 Server
    FXSTATE_BETA3_CLIENT	= 0x04,		//	.NET SB3 Client
	FXSTATE_DOTNET_CLIENT	= 0x08		//	.NET RC1 Client
};

DWORD CheckInstalledFax(IN DWORD dwFaxToCheck, OUT DWORD* pdwFaxInstalled);
DWORD WasSBS2000FaxServerInstalled(bool *pbSBSServer);

DWORD InstallFaxUnattended();
DWORD GetDllVersion(LPCTSTR lpszDllName);

#define PACKVERSION(major,minor) MAKELONG(minor,major)

#endif  // _FXSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\sources.inc ===
TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=LIBRARY

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=makeinf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\makefile.inc ===
PREFLAGS= /EP

PERINF=$(O)\per
PROINF=$(O)\pro
SRVINF=$(O)\srv
ENTINF=$(O)\ent
DTCINF=$(O)\dtc
SBSINF=$(O)\sbs
BLAINF=$(O)\bla

PRO_BINPLACE_CMD=$(BINPLACE_CMD)
PER_BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
SRV_BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
ENT_BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
DTC_BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf)
SBS_BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b sbsinf)
BLA_BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b blainf)

makeinf: $(O)\fxsocm.inx \
	 $(O)\per\fxsocm.inf \
	 $(O)\pro\fxsocm.inf \
	 $(O)\srv\fxsocm.inf \
	 $(O)\ent\fxsocm.inf \
	 $(O)\dtc\fxsocm.inf \
	 $(O)\sbs\fxsocm.inf \
	 $(O)\bla\fxsocm.inf 

$(O)\fxsocm.inx: ..\fxsocm.inx
	$(CC) $(PREFLAGS) $** > $@
!if "$(LNG)"=="USA"
	copy $(PRINTSCAN_INC_PATH)\mednames.txt ..\$(LNG)\mednames.txt
!else
	if not exist ..\$(LNG)\mednames.txt copy $(PRINTSCAN_INC_PATH)\mednames.txt ..\$(LNG)\mednames.txt
	if not exist ..\$(LNG)\fxsocm.txt seterror 1
!endif

$(PERINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +p
	prodfilt $(O)\fxsocm.tmp2 $(PERINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(PER_BINPLACE_CMD)

$(PROINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +w
	prodfilt $(O)\fxsocm.tmp2 $(PROINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(PRO_BINPLACE_CMD)

$(SRVINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +s
	prodfilt $(O)\fxsocm.tmp2 $(SRVINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(SRV_BINPLACE_CMD)

$(ENTINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +e
	prodfilt $(O)\fxsocm.tmp2 $(ENTINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(ENT_BINPLACE_CMD)

$(DTCINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +d
	prodfilt $(O)\fxsocm.tmp2 $(DTCINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(DTC_BINPLACE_CMD)

$(SBSINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +l
	prodfilt $(O)\fxsocm.tmp2 $(SBSINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(SBS_BINPLACE_CMD)

$(BLAINF)\fxsocm.inf: $(O)\fxsocm.inx
	copy $(O)\fxsocm.inx+..\$(LNG)\fxsocm.txt+..\$(LNG)\mednames.txt $(O)\fxsocm.tmp1
	prodfilt $(O)\fxsocm.tmp1 $(O)\fxsocm.tmp2 +b
	prodfilt $(O)\fxsocm.tmp2 $(BLAINF)\fxsocm.inf +i
	del $(O)\fxsocm.tmp*
	$(BLA_BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\arainf\makefile.inc ===
LNG=ARA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\brinf\makefile.inc ===
LNG=BR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\chhinf\makefile.inc ===
LNG=CHH
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\chpinf\makefile.inc ===
LNG=CHP
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\chsinf\makefile.inc ===
LNG=CHS
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\chtinf\makefile.inc ===
LNG=CHT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\dainf\makefile.inc ===
LNG=DA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\csinf\makefile.inc ===
LNG=CS
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\elinf\makefile.inc ===
LNG=EL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\esinf\makefile.inc ===
LNG=ES
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\fiinf\makefile.inc ===
LNG=FI
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\frinf\makefile.inc ===
LNG=FR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\gbinf\makefile.inc ===
LNG=GB
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\gerinf\makefile.inc ===
LNG=GER
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\hebinf\makefile.inc ===
LNG=HEB
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\huinf\makefile.inc ===
LNG=HU
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\itinf\makefile.inc ===
LNG=IT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\jpninf\makefile.inc ===
LNG=JPN
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\korinf\makefile.inc ===
LNG=KOR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\nlinf\makefile.inc ===
LNG=NL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\noinf\makefile.inc ===
LNG=NO
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\plinf\makefile.inc ===
LNG=PL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\ptinf\makefile.inc ===
LNG=PT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\ruinf\makefile.inc ===
LNG=RU
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\skinf\makefile.inc ===
LNG=SK
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\slinf\makefile.inc ===
LNG=SL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\trinf\makefile.inc ===
LNG=TR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\svinf\makefile.inc ===
LNG=SV
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\inf\usainf\makefile.inc ===
LNG=USA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\install_script\placefil.inc ===
Setup.cmd                faxsetup
ChkDbg.exe               faxsetup
faxoc.inf                faxsetup
faxocbla.inf             faxsetup
faxocdtc.inf             faxsetup
faxocent.inf             faxsetup
faxocper.inf             faxsetup
faxocsbs.inf             faxsetup
faxocsrv.inf             faxsetup
FaxOff.reg               faxsetup
install.inf              faxsetup
uninstall.inf            faxsetup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\faxcontrol.cpp ===
// FaxControl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f FaxControlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "FaxControl.h"

#include "FaxControl_i.c"
#include "IFaxControl.h"
#include "Faxutil.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FaxControl, CFaxControl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL FaxControl_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_FAXCONTROLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        HeapCleanup();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\faxocm.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       faxocm.h
//
// Abstract:        Header file used by Faxocm source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FAXOCM_H_
#define _FAXOCM_H_

#include <windows.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <winspool.h>
#include <tapi.h>
#include <shlobj.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <sddl.h>
#include <advpub.h>

#include "fxsapip.h"

#define NO_FAX_LIST
#include "faxutil.h"
#include "faxreg.h"
#include "debugex.h"
#include "routemapi.h"

#include "resource.h"

// submodule include files
#include "fxconst.h"
#include "fxocDbg.h"
#include "fxocFile.h"
#include "fxocLink.h"
#include "fxState.h"
#include "fxocMapi.h"
#include "fxocPrnt.h"
#include "fxocReg.h"
#include "fxocSvc.h"
#include "fxocUtil.h"
#include "fxUnatnd.h"
#include "fxocUpgrade.h"

// some useful macros
#define SecToNano(_sec)             (DWORDLONG)((_sec) * 1000 * 1000 * 10)
#define MinToNano(_min)             SecToNano((_min)*60)


BOOL                faxocm_IsInited(void);
HINSTANCE           faxocm_GetAppInstance(void);
DWORD               faxocm_GetComponentID(TCHAR     *pszComponentID,
                                          DWORD     dwNumBufChars);
HINF                faxocm_GetComponentInf(void);
BOOL                faxocm_GetComponentInfName(TCHAR* szInfFileName);
HSPFILEQ            faxocm_GetComponentFileQueue(void);
DWORD               faxocm_GetComponentSetupMode(void);
DWORDLONG           faxocm_GetComponentFlags(void);
UINT                faxocm_GetComponentLangID(void);
DWORD               faxocm_GetComponentSourcePath(TCHAR *pszSourcePath,
                                                  DWORD dwNumBufChars);
DWORD               faxocm_GetComponentUnattendFile(TCHAR *pszUnattendFile,
                                                  DWORD dwNumBufChars);
DWORD               faxocm_GetProductType(void);
OCMANAGER_ROUTINES* faxocm_GetComponentHelperRoutines(void);
EXTRA_ROUTINES*     faxocm_GetComponentExtraRoutines(void);
void faxocm_GetVersionInfo(DWORD *pdwExpectedOCManagerVersion,
                           DWORD *pCurrentOCManagerVersion);

void faxocm_GetProductInfo(PRODUCT_SKU_TYPE* pInstalledProductSKU,
						   DWORD* dwInstalledProductBuild);

DWORD faxocm_HasSelectionStateChanged(LPCTSTR pszSubcomponentId,
                                      BOOL    *pbSelectionStateChanged,
                                      BOOL    *pbCurrentlySelected,
                                      BOOL    *pbOriginallySelected);

typedef enum
{
    REPORT_FAX_INSTALLED,       // Report fax is installed
    REPORT_FAX_UNINSTALLED,     // Report fax is uninstalled
    REPORT_FAX_DETECT           // Detect fax installation state and report it
} FaxInstallationReportType;

extern FaxInstallationReportType g_InstallReportType /* = REPORT_FAX_DETECT*/;

#endif  // _FAXOCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxconst.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxconst.cpp
//
// Abstract:        File containing constants used by Fax OCM.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"

// used for determining the fax service's name
LPCTSTR INF_KEYWORD_ADDSERVICE                = _T("AddService");
LPCTSTR INF_KEYWORD_DELSERVICE                = _T("DelService");

// used for creating the Inbox and SentItems archive directories
LPCTSTR INF_KEYWORD_CREATEDIR                 = _T("CreateDir");
LPCTSTR INF_KEYWORD_DELDIR                    = _T("DelDir");

LPCTSTR INF_KEYWORD_CREATESHARE               = _T("CreateShare");
LPCTSTR INF_KEYWORD_DELSHARE                  = _T("DelShare");

LPCTSTR INF_KEYWORD_PATH                      = _T("Path");
LPCTSTR INF_KEYWORD_NAME                      = _T("Name");
LPCTSTR INF_KEYWORD_COMMENT                   = _T("Comment");
LPCTSTR INF_KEYWORD_PLATFORM                  = _T("Platform");
LPCTSTR INF_KEYWORD_ATTRIBUTES                = _T("Attributes");
LPCTSTR INF_KEYWORD_SECURITY                  = _T("Security");

LPCTSTR INF_KEYWORD_PROFILEITEMS_PLATFORM     = _T("ProfileItems_Platform");
LPCTSTR INF_KEYWORD_REGISTER_DLL_PLATFORM     = _T("RegisterDlls_Platform");
LPCTSTR INF_KEYWORD_UNREGISTER_DLL_PLATFORM   = _T("UnregisterDlls_Platform");
LPCTSTR INF_KEYWORD_ADDREG_PLATFORM           = _T("AddReg_Platform");
LPCTSTR INF_KEYWORD_COPYFILES_PLATFORM        = _T("CopyFiles_Platform");

// Returned by "GetInstallType"
// once the type of install has been determined, we search for 
// the appropriate section below to begin the type of install we need.
LPCTSTR INF_KEYWORD_INSTALLTYPE_UNINSTALL			= _T("FaxUninstall");
LPCTSTR INF_KEYWORD_INSTALLTYPE_CLEAN				= _T("FaxCleanInstall");
LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN9X		= _T("FaxUpgradeFromWin9x");
LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN2K		= _T("FaxUpgradeFromWin2K");
LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMXPDOTNET		= _T("FaxUpgradeFromXpDotNet");
LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT				= _T("FaxClientInstall");
LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT_UNINSTALL	= _T("FaxClientUninstall");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\infsize\fxsinfsize.cpp ===
// fxsinfsize.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <setupapi.h>
#include <stdlib.h>
#include <stdio.h>

void GetFileSizeAsString(LPCSTR FilePath,LPCSTR FileName,LPSTR FileSizeString);
DWORD ParseCommandLine(int argc, char* argv[],LPSTR* lpstrInfFile,LPSTR* lpstrPathToBinaries);

struct BinaryMapping
{
	LPCSTR FileNameInInf;
	LPCSTR FileNameInDrop;
};

BinaryMapping FileNameList[] = 
{
	{"fxsadmin.msc",		"\\fxsadmin.msc"},
	{"fxsadmin.dll",		"\\fxsadmin.dll"},
	{"fxsrtmtd.dll",		"\\fxsrtmtd.dll"},
	{"fxst30p.dll",			"\\fxst30p.dll"},
	{"fxsapi.dll",			"\\fxsapi.dll"},
	{"fxscfgwz.dll",		"\\fxscfgwz.dll"},
	{"fxscom.dll",			"\\fxscom.dll"},
	{"fxscomex.dll",		"\\fxscomex.dll"},
	{"fxsclntR.dll",		"\\fxsclntR.dll"},
	{"fxsclnt.exe",			"\\fxsclnt.exe"},
	{"fxscount.h",			"\\fxscount.h"},
	{"fxscover.exe",		"\\fxscover.exe"},
	{"fxsdrv.dll",			"\\fxsdrv.dll"},
	{"fxsevent.dll",		"\\fxsevent.dll"},
	{"fxsext32.dll",		"\\fxsext32.dll"},
	{"fxsmon.dll",			"\\fxsmon.dll"},
	{"fxsperf.dll",			"\\fxsperf.dll"},
	{"fxsperf.ini",			"\\fxsperf.ini"},
	{"fxsres.dll",			"\\fxsres.dll"},
	{"fxsroute.dll",		"\\fxsroute.dll"},
	{"fxssend.exe",			"\\fxssend.exe"},
	{"fxsst.dll",			"\\fxsst.dll"},
	{"fxssvc.exe",			"\\fxssvc.exe"},
	{"fxst30.dll",			"\\fxst30.dll"},
	{"fxstiff.dll",			"\\fxstiff.dll"},
	{"fxsui.dll",			"\\fxsui.dll"},
	{"fxswzrd.dll",			"\\fxswzrd.dll"},
	{"fxsxp32.dll",			"\\fxsxp32.dll"},
	{"fxsext.ecf",			"\\fxsext.ecf"},
	{"fxsclnt.msi",			"\\fxsclnt.msi"},
	{"confdent.cov",		"\\confdent.cov"},
	{"fyi.cov",				"\\fyi.cov"},
	{"generic.cov",			"\\generic.cov"},
	{"urgent.cov",			"\\urgent.cov"},
	{"fxscl_s.hlp",			"\\fxscl_s.hlp"},
	{"instmsia.exe",		"\\instmsia.exe"},
	{"instmsiw.exe",		"\\instmsiw.exe"},
	{"mfc42.dll",			"\\mfc42.dll"},
	{"mfc42u.dll",			"\\mfc42u.dll"},
	{"msvcp60.dll",			"\\msvcp60.dll"},
	{"NT4_fxsdrv4.dll",		"\\fxsdrv4.dll"},
	{"NT4_fxsapi.dll",		"\\faxclients\\nt4\\fxsapi.dll"},
	{"W95_iconlib.dll",		"\\faxclients\\win9x\\win95\\iconlib.dll"},
	{"W95_unidrv.dll",		"\\faxclients\\win9x\\win95\\unidrv.hlp"},
	{"W95_unidrv.hlp",		"\\faxclients\\win9x\\win95\\unidrv.hlp"},
	{"W98_iconlib.dll",		"\\faxclients\\win9x\\win98\\iconlib.dll"},
	{"W98_unidrv.dll",		"\\faxclients\\win9x\\win98\\unidrv.dll"},
	{"W98_unidrv.hlp",		"\\faxclients\\win9x\\win98\\unidrv.dll"},
	{"W9X_fxsapi.dll",		"\\faxclients\\win9x\\fxsapi.dll"},
	{"W9X_fxsclnt.exe",		"\\faxclients\\win9x\\fxsclnt.exe"},
	{"W9X_fxsclntr.dll",	"\\faxclients\\win9x\\fxsclntr.dll"},
	{"W9X_fxscover.exe",	"\\faxclients\\win9x\\fxscover.exe"},
	{"W9X_fxsdrv16.drv",	"\\faxclients\\win9x\\fxsdrv16.drv"},
	{"W9X_fxsdrv32.dll",	"\\faxclients\\win9x\\fxsdrv32.dll"},
	{"W9X_fxsext32.dll",	"\\faxclients\\win9x\\fxsext32.dll"},
	{"W9X_fxstiff.dll",		"\\faxclients\\win9x\\fxstiff.dll"},
	{"W9X_fxssend.exe",		"\\faxclients\\win9x\\fxssend.exe"},
	{"W9X_fxsxp32.dll",		"\\faxclients\\win9x\\fxsxp32.dll"},
	{"W9X_fxswzrd.dll",		"\\faxclients\\win9x\\fxswzrd.dll"},
	{"FXS_fxsclnt.chm",		"\\faxclients\\win9x\\fxscldwn.chm"},
	{"FXS_fxscover.chm",	"\\faxclients\\win9x\\fxscov_d.chm"},
	{"FXS_setup.exe",		"\\faxclients\\fxssetup.exe"},
	{"FXS_strap.exe",		"\\faxclients\\fxsstrap.exe"},
	{"FXS_setup.ini",		"\\faxclients\\setup.ini"},
	{"FXS_msvcrt.dll",		"\\faxclients\\fxsmsvcrt.dll"}
};

int cFileName = sizeof(FileNameList)/sizeof(FileNameList[0]);

int __cdecl main(int argc, char* argv[])
{
	LPSTR lpstrInfFile = NULL;
	LPSTR lpstrPathToBinaries = NULL;
	LPSTR lpstrLastComma = NULL;
	CHAR lpstrInputLine[MAX_PATH] = {0};
	CHAR lpstrFileSize[MAX_PATH] = {0};
	
	// parse command line parameters
	if (ParseCommandLine(argc,argv,&lpstrInfFile,&lpstrPathToBinaries)!=ERROR_SUCCESS)
	{
		printf("ERROR Running FXSINFSIZE.EXE\n\n");
		printf("Usage:\n");
		printf("fxsinfsize.exe /i:<inf file name> /p:<path to binaries>\n");
		printf("<inf file name>    - full path to FXSOCM.INF being processed\n");
		printf("<path to binaries> - location of the drop in which the fax binaries are\n\n");
		printf("Example: fxsinfsize.exe /i fxsocm.inf /p %%_NTPOSTBLD%%\n");
		goto exit;
	}

	printf("Input INF file is: %s\n",lpstrInfFile);
	printf("Input path to binaries is: %s\n",lpstrPathToBinaries);
	printf("parsing %d files\n",cFileName);
	for (int iIndex=0; iIndex<cFileName; iIndex++)
	{
		GetPrivateProfileString("SourceDisksFiles",
								FileNameList[iIndex].FileNameInInf,
								"",
								lpstrInputLine,
								MAX_PATH,
								lpstrInfFile);
		if (strlen(lpstrInputLine)==0)
		{
			// lookup for this entry failed, let's loop for the next.
			printf("failed to lookup %s in %s\n",FileNameList[iIndex].FileNameInInf,lpstrInfFile);
			continue;
		}

		// get the file size as a string representation
		GetFileSizeAsString(lpstrPathToBinaries,FileNameList[iIndex].FileNameInDrop,lpstrFileSize);
		if (strlen(lpstrFileSize)==0)
		{
			// getting the file size failed.
			// we have to write something to the INF otherwise the 
			// SetupAddInstallSectionToDiskSpaceList API fails
			// so, we fake a size.
			strncpy(lpstrFileSize,"100000",MAX_PATH);
			printf("failed to get size for %s\n",FileNameList[iIndex].FileNameInDrop);
		}

		// create the complete line.
		lpstrLastComma = strrchr(lpstrInputLine,',');
		if (lpstrLastComma==NULL)
		{
			printf("No comma in input string\n");
			continue;
		}
		*(++lpstrLastComma)=0;
		strncat(lpstrInputLine,lpstrFileSize,MAX_PATH-strlen(lpstrInputLine)-1);
		printf("writing to %s: %s\n",FileNameList[iIndex].FileNameInInf,lpstrInputLine);
		// write it back to the INF
		if (!WritePrivateProfileString(	"SourceDisksFiles",
										FileNameList[iIndex].FileNameInInf,
										lpstrInputLine,								
										lpstrInfFile))
		{
			// writing the updated string failed, loop for the next
			printf("WritePrivateProfileString %s failed, ec=%d\n",FileNameList[iIndex].FileNameInInf,GetLastError());
		}

	}

exit:

	return 0;
}

void GetFileSizeAsString(LPCSTR FilePath,LPCSTR FileName,LPSTR FileSizeString)
{
	WIN32_FILE_ATTRIBUTE_DATA FileAttributeData;
	CHAR szPathToFile[MAX_PATH] = {0};

	strncpy(szPathToFile,FilePath,MAX_PATH-1);
	strncat(szPathToFile,FileName,MAX_PATH-strlen(szPathToFile)-1);

	if (!GetFileAttributesEx(szPathToFile,GetFileExInfoStandard,&FileAttributeData))
	{
		printf("GetFileAttributesEx %s failed, ec=%d\n",szPathToFile,GetLastError());
		// fake some size so we get a count anyway.
		FileAttributeData.nFileSizeLow = 100000;
	}

	_itoa(FileAttributeData.nFileSizeLow,FileSizeString,10);
}

DWORD ParseCommandLine(int argc, char* argv[],LPSTR* lpstrInfFile,LPSTR* lpstrPathToBinaries)
{
	if (argc!=3)
	{
		return ERROR_INVALID_PARAMETER;
	}

	for (int i = 1; i < argc; i++)
	{
		if ((_strnicmp("/i:",argv[i],3)==0) && (strlen(argv[i])>3))
		{
			(*lpstrInfFile) = argv[i]+3;
			if (strlen((*lpstrInfFile))==0)
			{
				return ERROR_INVALID_PARAMETER;
			}
		}
		else if ((!_strnicmp("/p:",argv[i],3)) && (strlen(argv[i])>3))
		{
			(*lpstrPathToBinaries) = argv[i]+3;
			if (strlen((*lpstrPathToBinaries))==0)
			{
				return ERROR_INVALID_PARAMETER;
			}
		}
		else
		{
			return ERROR_INVALID_PARAMETER;
		}
	}
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\faxocm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       faxocm.cpp
//
// Abstract:        This file implements the OCM setup for fax.
//
// Environment:     windows XP / User Mode
//
// Coding Style:    Any function, variable, or typedef preceded with the 
//                  "prv_" prefix (short for "local"), implies that 
//                  it is visible only within the scope of this file.
//                  For functions and variables, it implies they are 
//                  static.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created from old faxocm.cpp by wesx
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"

#pragma hdrstop

#include <shellapi.h>
#include <systrayp.h>
/////////////////////////////// Local Defines ////////////////////////////

#define prv_TOTAL_NUM_PROGRESS_BAR_TICKS    12

// These two are defined in %SDXROOT%\SHELL\EXT\SYSTRAY\DLL\systray.h too.
// This is a duplicate definition that has to remain in sync.
// We don't use the systray.h because we have local builds and we're
// not enlisted on the whole project.
#define FAX_STARTUP_TIMER_ID            7
#define FAX_SHUTDOWN_TIMER_ID          99


///////////////////////////////
// prv_Component_t
//
// Stores the information we 
// get from the OC Manager 
// for use by the rest of the
// faxocm.dll. 
//
typedef struct prv_Component_t
{
    DWORD                   dwExpectedOCManagerVersion;
    TCHAR                   szComponentID[255 + 1];
    TCHAR                   szSubComponentID[255 + 1];  // Needed for prv_dlgOcmWizardPage
    HINF                    hInf;
    DWORD                   dwSetupMode;
    DWORDLONG               dwlFlags;
    UINT                    uiLanguageID;
    TCHAR                   szSourcePath[_MAX_PATH + _MAX_FNAME + 1];
    TCHAR                   szUnattendFile[_MAX_PATH + _MAX_FNAME + 1];
    OCMANAGER_ROUTINES      Helpers;
    EXTRA_ROUTINES          Extras;
    HSPFILEQ                hQueue;
    DWORD                   dwProductType;
	PRODUCT_SKU_TYPE		InstalledProductSKU;
	DWORD					InstalledProductBuild;
} prv_Component_t;

///////////////////////////////
// prv_GVAR
//
// Global variables visible
// only within this file
// scope.
//
static struct prv_GVAR
{
    BOOL                    bInited;
    HINSTANCE               hInstance;
    DWORD                   dwCurrentOCManagerVersion;
    prv_Component_t         Component;
} prv_GVAR = 
{
    FALSE,          //  bInited
    NULL           //  hInstance
};

//
// Delay Load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

//////////////////// Static Function Prototypes //////////////////////////////

static void prv_UpdateProgressBar(DWORD dwNumTicks);
static DWORD prv_GetSectionToProcess(const TCHAR *pszCurrentSection,
                                     TCHAR       *pszSectionToProcess,
                                     DWORD       dwNumBufChars);

static DWORD prv_ValidateVersion(SETUP_INIT_COMPONENT *pSetupInit);

static DWORD prv_SetSetupData(const TCHAR          *pszComponentId,
                              SETUP_INIT_COMPONENT *pSetupInit);

static DWORD prv_OnPreinitialize(void);
static DWORD prv_OnInitComponent(LPCTSTR               pszComponentId, 
                                 SETUP_INIT_COMPONENT  *pSetupInitComponent);
static DWORD prv_OnExtraRoutines(LPCTSTR            pszComponentId, 
                                 EXTRA_ROUTINES    *pExtraRoutines);
static DWORD prv_OnSetLanguage(UINT uiLanguageID);
static DWORD_PTR prv_OnQueryImage(void);
static DWORD prv_OnSetupRequestPages(LPCTSTR pszComponentId,
                                     WizardPagesType uiType, 
                                     PSETUP_REQUEST_PAGES pSetupRequestPages);
static DWORD prv_OnWizardCreated(void);
static DWORD prv_OnQuerySkipPage(void);
static DWORD prv_OnQuerySelStateChange(LPCTSTR pszComponentId,
                                       LPCTSTR pszSubcomponentId,
                                       UINT    uiState,
                                       UINT    uiFlags);
static DWORD prv_OnCalcDiskSpace(LPCTSTR   pszComponentId,
                                 LPCTSTR   pszSubcomponentId,
                                 DWORD     addComponent,
                                 HDSKSPC   dspace);
static DWORD prv_OnQueueFileOps(LPCTSTR    pszComponentId, 
                                LPCTSTR    pszSubcomponentId, 
                                HSPFILEQ   hQueue);
static DWORD prv_OnNotificationFromQueue(void);

static DWORD prv_OnQueryStepCount(LPCTSTR pszComponentId,
                                  LPCTSTR pszSubcomponentId);

static DWORD prv_OnCompleteInstallation(LPCTSTR pszComponentId, 
                                        LPCTSTR pszSubcomponentId);
static DWORD prv_OnCleanup(void);
static DWORD prv_OnQueryState(LPCTSTR pszComponentId,
                              LPCTSTR pszSubcomponentId,
                              UINT    uiState);
static DWORD prv_OnNeedMedia(void);
static DWORD prv_OnAboutToCommitQueue(LPCTSTR pszComponentId, 
                                      LPCTSTR pszSubcomponentId);
static DWORD prv_RunExternalProgram(LPCTSTR pszComponent,
                                    DWORD   state);
static DWORD prv_EnumSections(HINF          hInf,
                              const TCHAR   *component,
                              const TCHAR   *key,
                              DWORD         index,
                              INFCONTEXT    *pic,
                              TCHAR         *name);

static DWORD prv_CleanupNetShares(LPCTSTR   pszComponent,
                                  DWORD     state);

static DWORD prv_CompleteFaxInstall(const TCHAR *pszSubcomponentId,
                                    const TCHAR *pszInstallSection);

static DWORD prv_CompleteFaxUninstall(const TCHAR *pszSubcomponentId,
                                      const TCHAR *pszUninstallSection);

static DWORD prv_UninstallFax(const TCHAR *pszSubcomponentId,
                              const TCHAR *pszUninstallSection);

static DWORD prv_NotifyStatusMonitor(WPARAM wParam);

static DWORD prv_ShowUninstalledFaxShortcut(void);

static INT_PTR CALLBACK prv_dlgOcmWizardPage(HWND hwndDlg,   
                                             UINT uMsg,     
                                             WPARAM wParam, 
                                             LPARAM lParam);


///////////////////////////////
// faxocm_IsInited
//
// Returns TRUE if OCM is
// initialized, FALSE, otherwise
//
// Params:
//      - void
// Returns:
//      - TRUE if initialized.
//      - FALSE otherwise.
//
BOOL faxocm_IsInited(void)
{
    return prv_GVAR.bInited;
}

///////////////////////////////
// faxocm_GetAppInstance
//
// Returns the hInstance of
// this DLL.
//
// Params:
//      - void
// Returns:
//      - Instance of this DLL.
//
HINSTANCE faxocm_GetAppInstance(void)
{
    return prv_GVAR.hInstance;
}

///////////////////////////////
// faxocm_GetComponentID
//
// Returns the Component ID 
// passed to us via the OC
// Manager
//
// Params:
//      - pszComponentID - ID of top level component
//      - dwNumBufChars  - # chars pszComponentID can hold
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise
//
DWORD faxocm_GetComponentID(TCHAR     *pszComponentID,
                            DWORD     dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;

    if ((pszComponentID == NULL) ||
        (dwNumBufChars  == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    _tcsncpy(pszComponentID, prv_GVAR.Component.szComponentID, dwNumBufChars);

    return dwReturn;
}

///////////////////////////////
// faxocm_GetComponentFileQueue
//
// Returns the file queue 
// given to us by the OC Manager
//
// The file queue is used by
// the Setup API functions for
// copying/deleting files.
//
// Params:
//      - void
// Returns:
//      - Handle to file queue
//
HSPFILEQ faxocm_GetComponentFileQueue(void)
{
    return prv_GVAR.Component.hQueue;
}

///////////////////////////////
// faxocm_GetComponentInfName
//
// Returns the full path to the
// faxsetup.inf file.
//
// Params:
//      - buffer to fill with path, must be at least MAX_PATH long
// Returns:
//      - NO_ERROR - in case of success
//      - Win32 Error code - otherwise
//
BOOL faxocm_GetComponentInfName(TCHAR* szInfFileName)
{
    BOOL bRes = TRUE;

    DBG_ENTER(_T("faxocm_GetComponentInfName"),bRes);

    (*szInfFileName) = NULL;

    if (GetWindowsDirectory(szInfFileName,MAX_PATH)==0)
    {
        CALL_FAIL(SETUP_ERR,TEXT("GetWindowsDirectory"),GetLastError());
        bRes = FALSE;
        goto exit;
    }

    if (_tcslen(szInfFileName)+_tcslen(FAX_INF_PATH)>(MAX_PATH-1))
    {
        VERBOSE(SETUP_ERR,_T("MAX_PATH too short to create INF path"));
        bRes = FALSE;
        goto exit;
    }
    _tcscat(szInfFileName,FAX_INF_PATH);

exit:
    return bRes;
}

///////////////////////////////
// faxocm_GetComponentInf
//
// Returns the handle to the
// faxsetup.inf file.
//
// Params:
//      - void
// Returns:
//      - Handle to faxsetup.inf file
//
HINF faxocm_GetComponentInf(void)
{
    return prv_GVAR.Component.hInf;
}

///////////////////////////////
// faxocm_GetComponentSetupMode
//
// Returns the setup mode as 
// given to us by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Setup mode as given to us by OC Manager
//
DWORD faxocm_GetComponentSetupMode(void)
{
    return prv_GVAR.Component.dwSetupMode;
}

///////////////////////////////
// faxocm_GetComponentFlags
//
// Returns the flags as 
// given to us by OC Manager.
//
// Params:
//      - void
// Returns:
//      - Flags as given to us by OC Manager
//
DWORDLONG faxocm_GetComponentFlags(void)
{
    return prv_GVAR.Component.dwlFlags;
}

///////////////////////////////
// faxocm_GetComponentLangID
//
// Returns the Language ID
// given to us by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Language ID as given to us by OC Manager
//
UINT faxocm_GetComponentLangID(void)
{
    return prv_GVAR.Component.uiLanguageID;
}

///////////////////////////////
// faxocm_GetComponentSourcePath
//
// Returns the Source Path
// given to us by OC Manager.
//
// Params:
//      - pszSourcePath - OUT - buffer to hold source path
//      - dwNumBufChars - # of characters pszSourcePath can hold.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD faxocm_GetComponentSourcePath(TCHAR *pszSourcePath,
                                    DWORD dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;

    if ((pszSourcePath == NULL) ||
        (dwNumBufChars == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    _tcsncpy(pszSourcePath, prv_GVAR.Component.szSourcePath, dwNumBufChars);

    return dwReturn;
}

///////////////////////////////
// faxocm_GetComponentUnattendFile
//
// Returns the Unattend Path
// given to us by OC Manager.
//
// Params:
//      - pszUnattendFile - OUT - buffer to hold unattend path
//      - dwNumBufChars - # of characters pszSourcePath can hold.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD faxocm_GetComponentUnattendFile(TCHAR *pszUnattendFile,
                                      DWORD dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;

    if ((pszUnattendFile == NULL) ||
        (dwNumBufChars == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    _tcsncpy(pszUnattendFile, prv_GVAR.Component.szUnattendFile, dwNumBufChars);

    return dwReturn;
}

////////////////////////////////////
// faxocm_GetComponentHelperRoutines
//
// Returns the pointer to the Helper
// data and functions as given to us
// by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Ptr to helper routines as given to us by OC Manager.
//
OCMANAGER_ROUTINES* faxocm_GetComponentHelperRoutines(void)
{
    return &prv_GVAR.Component.Helpers;
}

////////////////////////////////////
// faxocm_GetComponentExtraRoutines
//
// Returns the pointer to the Helper
// data and functions as given to us
// by OC Manager.
//
// Params:
//      - void
// Returns:
//      - Ptr to extra info as given to us by OC Manager.
//
EXTRA_ROUTINES* faxocm_GetComponentExtraRoutines(void)
{
    return &prv_GVAR.Component.Extras;
}

////////////////////////////////////
// faxocm_GetProductType
//
// Returns the product type as given
// to us by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Product type as given to us by OC Manager.
//
DWORD faxocm_GetProductType(void)
{
    return prv_GVAR.Component.dwProductType;
}

////////////////////////////////////
// faxocm_GetVersionInfo
//
// Returns the version # as given
// to us by OC Manager.
//
// Params:
//      - pdwExpectedOCManagerVersion - OUT - self explanatory.
//      - pdwCurrentOCManagerVersion - OUT - self explanatory.
// Returns:
//      - void.
//
void faxocm_GetVersionInfo(DWORD *pdwExpectedOCManagerVersion,
                           DWORD *pdwCurrentOCManagerVersion)
{
    if (pdwExpectedOCManagerVersion)
    {
        *pdwExpectedOCManagerVersion = 
                            prv_GVAR.Component.dwExpectedOCManagerVersion;
    }

    if (pdwCurrentOCManagerVersion)
    {
        *pdwCurrentOCManagerVersion = prv_GVAR.dwCurrentOCManagerVersion;
    }

    return;
}

void faxocm_GetProductInfo(PRODUCT_SKU_TYPE* pInstalledProductSKU,
						   DWORD* dwInstalledProductBuild)
{
	if (pInstalledProductSKU)
	{
		*pInstalledProductSKU = prv_GVAR.Component.InstalledProductSKU;
	}

	if (dwInstalledProductBuild)
	{
		*dwInstalledProductBuild = prv_GVAR.Component.InstalledProductBuild;
	}
}


extern "C"
BOOL FaxControl_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

///////////////////////////////
// DllMain
//
// DLL Entry Point
//
// Params:
//      hInstance   - Instance handle
//      Reason      - Reason for the entrypoint being called
//      Context     - Context record
//
// Returns:
//      TRUE        - Initialization succeeded
//      FALSE       - Initialization failed
//
extern "C"
DWORD DllMain(HINSTANCE     hInst,
              DWORD         Reason,
              LPVOID        Context)
{
    DBG_ENTER(_T("DllMain"));
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            // initialize our global variables
            memset(&prv_GVAR, 0, sizeof(prv_GVAR));

            prv_GVAR.hInstance = hInst;

            // Initialize Debug Support
            //
            VERBOSE(DBG_MSG,_T("FxsOcm.dll loaded - DLL_PROCESS_ATTACH"));
            DisableThreadLibraryCalls(hInst);
        break;

        case DLL_PROCESS_DETACH:

            // terminate Debug Support
            VERBOSE(DBG_MSG,_T("FxsOcm.dll unloaded - DLL_PROCESS_DETACH"));
        break;

        default:
            VERBOSE(DBG_MSG,_T("DllMain, received some weird 'Reason' ")
                            _T("for this fn, Reason = %lu"), Reason);
        break;
    }
    //
    // Pass DllMain call to ATL supplied DllMain
    //
    return FaxControl_DllMain (hInst, Reason, Context);
}


///////////////////////////////
// FaxOcmSetupProc
//
// Entry point for OC Manager.
// 
// The OC Manager calls this function
// to drive this DLL.
//
// Params:
//      - pszComponentId - major component 
//      - pszSubcomponentId - component found if user presses "Details"
//      - uiFunction - what stage of setup we are in.
//      - uiParam1 - dependent on uiFunction - could be anything.
//      - pParam2  - dependent on uiFunction - could be anything.
//
// Returns:
//      DWORD indicating error or success.
//
//
DWORD_PTR FaxOcmSetupProc(IN LPWSTR     pszComponentId,
                          IN LPWSTR     pszSubcomponentId,
                          IN UINT       uiFunction,
                          IN UINT       uiParam1,
                          IN OUT PVOID  pParam2)
{
    DWORD_PTR rc = 0;
    DBG_ENTER(  _T("FaxOcmSetupProc"),
                _T("%s - %s"),
                pszComponentId,
                pszSubcomponentId);

    VERBOSE(DBG_MSG,    _T("FaxOcmSetup proc called with function '%s'"), 
                        fxocDbg_GetOcFunction(uiFunction));

    switch(uiFunction) 
    {
        case OC_PREINITIALIZE:
            rc = prv_OnPreinitialize();
        break;

        case OC_INIT_COMPONENT:
            rc = prv_OnInitComponent(pszComponentId, 
                                     (PSETUP_INIT_COMPONENT) pParam2);
        break;

        case OC_EXTRA_ROUTINES:
            rc = prv_OnExtraRoutines(pszComponentId, (PEXTRA_ROUTINES)pParam2);
        break;

        case OC_SET_LANGUAGE:
            rc = prv_OnSetLanguage(uiParam1);
        break;

        case OC_QUERY_IMAGE:
            // Argh!  I hate casting handles to DWORDs
            rc = prv_OnQueryImage();
        break;

        case OC_REQUEST_PAGES:
            rc = prv_OnSetupRequestPages(pszComponentId, 
                (WizardPagesType)uiParam1, (PSETUP_REQUEST_PAGES)pParam2);
        break;

        case OC_QUERY_CHANGE_SEL_STATE:
            rc = prv_OnQuerySelStateChange(pszComponentId, 
                                           pszSubcomponentId, 
                                           uiParam1, 
                                           (UINT)((UINT_PTR)pParam2));
        break;

        case OC_CALC_DISK_SPACE:
            rc = prv_OnCalcDiskSpace(pszComponentId, 
                                     pszSubcomponentId, 
                                     uiParam1, 
                                     pParam2);

            // sometimes the OC Manager gives us NULL subcomponent IDs,
            // so just ignore them.
            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_QUEUE_FILE_OPS:
            SET_DEBUG_FLUSH(TRUE);
            rc = prv_OnQueueFileOps(pszComponentId, 
                                    pszSubcomponentId, 
                                    (HSPFILEQ)pParam2);
            SET_DEBUG_FLUSH(FALSE);

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_NOTIFICATION_FROM_QUEUE:
            rc = prv_OnNotificationFromQueue();
        break;

        case OC_QUERY_STEP_COUNT:
            rc = prv_OnQueryStepCount(pszComponentId, pszSubcomponentId);

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_COMPLETE_INSTALLATION:
            SET_DEBUG_FLUSH(TRUE);
            rc = prv_OnCompleteInstallation(pszComponentId, pszSubcomponentId);
            SET_DEBUG_FLUSH(FALSE);

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_CLEANUP:
            rc = prv_OnCleanup();

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_QUERY_STATE:
            rc = prv_OnQueryState(pszComponentId, pszSubcomponentId, uiParam1);
        break;

        case OC_NEED_MEDIA:
            rc = prv_OnNeedMedia();
        break;

        case OC_ABOUT_TO_COMMIT_QUEUE:
            rc = prv_OnAboutToCommitQueue(pszComponentId, pszSubcomponentId);
        break;

        case OC_QUERY_SKIP_PAGE:
            rc = prv_OnQuerySkipPage();
        break;

        case OC_WIZARD_CREATED:
            rc = prv_OnWizardCreated();
        break;

        default:
            rc = NO_ERROR;
        break;
    }

    return rc;
}

///////////////////////////////
// prv_ValidateVersion
//
// Validates that the version
// of OC Manager this DLL was written
// for is compatible with the version
// of OC Manager that is currently
// driving us.
//
// Params:
//      - pSetupInit - setup info as given to us by OC Manager.
//
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_ValidateVersion(SETUP_INIT_COMPONENT *pSetupInit)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(TEXT("prv_ValidateVersion"), dwReturn);

    if (OCMANAGER_VERSION <= pSetupInit->OCManagerVersion) 
    {
        // the version we expect is lower or the same than the version
        // than OC Manager understands.  This means that a newer OC 
        // Manager should still be able to drive older components, so 
        // return the version we support to OC Manager, and it will decide
        // if it can drive this component or not.

        VERBOSE(    DBG_MSG, 
                    _T("OC Manager version: 0x%x, ")
                    _T("FaxOcm Expected Version: 0x%x, seems OK"),
                    pSetupInit->OCManagerVersion,
                    OCMANAGER_VERSION);

        pSetupInit->ComponentVersion = OCMANAGER_VERSION;
    } 
    else 
    {
        // we were written for a newer version of OC Manager than the 
        // OC Manager driving this component.  Fail.

        VERBOSE(    SETUP_ERR, 
                    _T("OC Manager version: 0x%x, ")
                    _T("FaxOcm Expected Version: 0x%x, unsupported, abort."),
                    pSetupInit->OCManagerVersion,
                    OCMANAGER_VERSION);

        dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return dwReturn;
}


///////////////////////////////
// prv_SetSetupData
//
// Initialize our global variable containing
// the prv_Component_t information.
//
// Params:
//      - pszComponentId - id as it appears in SysOc.inf
//      - pSetupInit - OC Manager setup info.
// 
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_SetSetupData(const TCHAR          *pszComponentId,
                              SETUP_INIT_COMPONENT *pSetupInit)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(TEXT("prv_SetSetupData"), dwReturn, TEXT("%s"), pszComponentId);

    if ((pszComponentId == NULL) ||
        (pSetupInit     == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwReturn == NO_ERROR)
    {
        memset(&prv_GVAR.Component, 0, sizeof(prv_GVAR.Component));

        prv_GVAR.dwCurrentOCManagerVersion = pSetupInit->OCManagerVersion;
        
        _tcsncpy(prv_GVAR.Component.szComponentID, 
                 pszComponentId,
                 sizeof(prv_GVAR.Component.szComponentID) / sizeof(TCHAR));
        // szSubComponentID will be set in OC_QUERY_STATE, because
        // we don't have it now

        _tcsncpy(prv_GVAR.Component.szSourcePath, 
                 pSetupInit->SetupData.SourcePath,
                 sizeof(prv_GVAR.Component.szSourcePath) / sizeof(TCHAR));

        _tcsncpy(prv_GVAR.Component.szUnattendFile, 
                 pSetupInit->SetupData.UnattendFile,
                 sizeof(prv_GVAR.Component.szUnattendFile) / sizeof(TCHAR));

        prv_GVAR.Component.hInf          = pSetupInit->ComponentInfHandle;
        prv_GVAR.Component.dwlFlags      = pSetupInit->SetupData.OperationFlags;
        prv_GVAR.Component.dwProductType = pSetupInit->SetupData.ProductType;
        prv_GVAR.Component.dwSetupMode   = pSetupInit->SetupData.SetupMode;
        prv_GVAR.Component.dwExpectedOCManagerVersion = OCMANAGER_VERSION;

        memcpy(&prv_GVAR.Component.Helpers, 
               &pSetupInit->HelperRoutines, 
               sizeof(prv_GVAR.Component.Helpers));
    }

    return dwReturn;
}

///////////////////////////////
// prv_GetSectionToProcess
//
// This determines if we are 
// clean installing, upgrading,
// uninstalling, etc, and returns
// the correct install section in the
// faxsetup.inf to process.
//
// Params:
//      - pszCurrentSection
//      - pszSectionToProcess - OUT 
//      - dwNumBufChars - # of characters pszSectionToProcess can hold.
//
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_GetSectionToProcess(const TCHAR *pszCurrentSection,
                                     TCHAR       *pszSectionToProcess,
                                     DWORD       dwNumBufChars)
{
    DWORD dwReturn          = NO_ERROR;
    BOOL  bInstall          = TRUE;
    DBG_ENTER(  TEXT("prv_GetSectionToProcess"), 
                dwReturn,
                TEXT("%s"),
                pszCurrentSection);

    if ((pszCurrentSection   == NULL) ||
        (pszSectionToProcess == NULL) ||
        (dwNumBufChars       == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    const TCHAR *pszInfKeyword = fxState_GetInstallType(pszCurrentSection);

    // okay, get that section's value, which will be an install/uninstall
    // section in the INF.
    if (pszInfKeyword)
    {
        dwReturn = fxocUtil_GetKeywordValue(pszCurrentSection,
                                            pszInfKeyword,
                                            pszSectionToProcess,
                                            dwNumBufChars);
    }
    else
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR, 
                _T("fxState_GetInstallType failed, rc = 0x%lx"),
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// prv_UpdateProgressBar
//
// Update the progress bar displayed in the
// OC Manager dialog.  This simply tells
// the OC Manager to increment the dialog by
// the specified # of ticks.
//
// Params:
//      - dwNumTicks - # of ticks to increment by.
// 
// Returns:
//      - void
//
static void prv_UpdateProgressBar(DWORD dwNumTicks)
{
    // update the progress bar based on the number of ticks the caller
    // would like to set.
    DBG_ENTER(TEXT("prv_UpdateProgressBar"), TEXT("%d"), dwNumTicks);
    if (prv_GVAR.Component.Helpers.TickGauge)
    {
        for (DWORD i = 0; i < dwNumTicks; i++)
        {
            prv_GVAR.Component.Helpers.TickGauge(
                                 prv_GVAR.Component.Helpers.OcManagerContext);
        }
    }
}

///////////////////////////////
// prv_OnPreinitialize()
//
// Handler for OC_PREINITIALIZE
// 
// Params:
// Returns:
//      - Either OCFLAG_UNICODE or
//        OCFLAG_ANSI, depending on
//        what this DLL supports.
//        This DLL supports both.

static DWORD prv_OnPreinitialize(VOID)
{
    return OCFLAG_UNICODE;
}

///////////////////////////////
// prv_OnInitComponent()
//
// Handler for OC_INIT_COMPONENT
//
// Params:
//      - pszComponentId - ID specified in SysOc.inf (probably "Fax")
//      - pSetupInitComponent - OC Manager Setup info 
//
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnInitComponent(LPCTSTR               pszComponentId, 
                                 SETUP_INIT_COMPONENT  *pSetupInitComponent)
{
    BOOL  bSuccess              = FALSE;
    DWORD dwReturn              = NO_ERROR;
    UINT  uiErrorAtLineNumber   = 0;

    DBG_ENTER(TEXT("prv_OnInitComponent"), dwReturn, TEXT("%s"), pszComponentId);

    if ((pszComponentId         == NULL) ||
        (pSetupInitComponent    == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // save the setup data.
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_SetSetupData(pszComponentId, pSetupInitComponent);
    }

    // Initialize debug so that we can get the debug settings specified
    // in the faxocm.inf file.
    fxocDbg_Init((faxocm_GetComponentInf()));

    // Validate the version of OC Manager against the version we expect
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_ValidateVersion(pSetupInitComponent);
    }

    // Notice we do NOT need to call 'SetupOpenAppendInfFile'
    // since OC Manager already appends the layout.inf to the hInf
    // for us.

    bSuccess = ::SetupOpenAppendInfFile(NULL, prv_GVAR.Component.hInf, NULL);

    if (!bSuccess)
    {
        dwReturn = ::GetLastError();
        VERBOSE(    DBG_MSG,
                    _T("SetupOpenAppendInfFile failed to append ")
                    _T("the layout inf to the component Inf"));
    }

    //
    // initialize all the subsystems and Upgrade
    //
    if (dwReturn == NO_ERROR)
    {
        fxState_Init();
        fxocUtil_Init();
        fxocFile_Init();
        fxocMapi_Init();
        fxocPrnt_Init();
        fxocReg_Init();
        fxocSvc_Init();
        fxUnatnd_Init();
        fxocUpg_Init();
    }

    // set our initialized flag.
    if (dwReturn == NO_ERROR)
    {
        prv_GVAR.bInited = TRUE;

        VERBOSE(    DBG_MSG,
                    _T("OnInitComponent, ComponentID: '%s', ")
                    _T("SourcePath: '%s', Component Inf Handle: 0x%0x"),
                    prv_GVAR.Component.szComponentID,
                    prv_GVAR.Component.szSourcePath,
                    prv_GVAR.Component.hInf);
    }
    else
    {
        // XXX - OrenR - 03/23/2000
        // We should probably clean up here

        prv_GVAR.bInited = FALSE;

        VERBOSE(    SETUP_ERR,
                    _T("OnInitComponent, ComponentID: '%s'")
                    _T("SourcePath: '%s', Component Inf Handle: 0x%0x ")
                    _T("Failed to Append Layout.inf file, dwReturn = %lu"),
                    prv_GVAR.Component.szComponentID,
                    prv_GVAR.Component.szSourcePath,
                    prv_GVAR.Component.hInf,
                    dwReturn);
    }

	// Load product SKU and Version (if exists)
	HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP,FALSE,KEY_READ);
	if (hKey)
	{
		// write the SKU into the registry
		prv_GVAR.Component.InstalledProductSKU = PRODUCT_SKU_TYPE(GetRegistryDword(hKey,REGVAL_PRODUCT_SKU));
		prv_GVAR.Component.InstalledProductBuild = GetRegistryDword(hKey,REGVAL_PRODUCT_BUILD);

		RegCloseKey(hKey);
	}
	else
	{
        VERBOSE(DBG_MSG,_T("Failed to open fax setup registry, dwReturn = 0x%lx"),GetLastError());
	}

    // Output to debug our current setup state.
    fxState_DumpSetupState();

    return dwReturn;
}

///////////////////////////////
// prv_OnCleanup
//
// Called just before this
// DLL is unloaded
//
// Params:
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnCleanup(void)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(TEXT("prv_OnCleanup"), dwReturn);

    // terminate the subsystems in reverse order from which they we 
    // intialized.

    fxUnatnd_Term();
    fxocSvc_Term();
    fxocReg_Term();
    fxocPrnt_Term();
    fxocMapi_Term();
    fxocFile_Term();
    fxocUtil_Term();
    fxState_Term();
    // this closes the log file, so do this last...
    fxocDbg_Term();

    return dwReturn;
}

///////////////////////////////
// prv_OnCalcDiskSpace
//
// Handler for OC_CALC_DISK_SPACE
// OC Manager calls this function 
// so that it can determine how 
// much disk space we require.
//
// Params:
//      - pszComponentId - From SysOc.inf (usually "fax")
//      - pszSubcomponentId - 
//      - addComponent - non-zero if installing, 0 if uninstalling
//      - dspace - handle to disk space abstraction.
// 
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnCalcDiskSpace(LPCTSTR   pszComponentId,
                                 LPCTSTR   pszSubcomponentId,
                                 DWORD     addComponent,
                                 HDSKSPC   dspace)
{
    DWORD dwReturn          = NO_ERROR;
    DBG_ENTER(  TEXT("prv_OnCalcDiskSpace"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);

    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocFile_CalcDiskSpace(pszSubcomponentId,
                                          addComponent,
                                          dspace);
    }

    return dwReturn;
}


///////////////////////////////
// prv_OnQueueFileOps
//
// Handler for OC_QUEUE_FILE_OPS
// This fn will queue all the files
// specified for copying and deleting
// in the INF install section.
//
// Params:
//      - pszCompnentId
//      - pszSubcomponentId
//      - hQueue - Handle to queue abstraction.
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnQueueFileOps(LPCTSTR    pszComponentId, 
                                LPCTSTR    pszSubcomponentId, 
                                HSPFILEQ   hQueue)
{
    DWORD   dwReturn                = NO_ERROR;
    BOOL    bInstallSelected        = FALSE;
    BOOL    bSelectionStateChanged  = FALSE;

    DBG_ENTER(  TEXT("prv_OnQueueFileOps"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);

    if ((pszComponentId     == NULL) || 
        (pszSubcomponentId  == NULL) ||
        (hQueue             == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // save our Queue Handle.
    prv_GVAR.Component.hQueue = hQueue;

    dwReturn = faxocm_HasSelectionStateChanged(pszSubcomponentId,
                                               &bSelectionStateChanged,
                                               &bInstallSelected,
                                               NULL);

    if (dwReturn != NO_ERROR)
    {
        VERBOSE(    SETUP_ERR,
                    _T("HasSelectionStateChanged failed, rc = 0x%lx"),
                    dwReturn);

        return dwReturn;
    }

    // our selection state has changed, install or uninstall based on
    // the current selection state.
    if (bSelectionStateChanged == TRUE)
    {
        TCHAR szSectionToProcess[255 + 1] = {0};

        VERBOSE(    DBG_MSG,
                    _T("Beginning Queuing of Files: ComponentID: '%s', ")
                    _T("SubComponentID: '%s', Selection State has ")
                    _T("changed to %lu ==> Installing/Uninstalling"),
                    pszComponentId, pszSubcomponentId, 
                    bInstallSelected);

        if (dwReturn == NO_ERROR)
        {
            dwReturn = prv_GetSectionToProcess(
                                   pszSubcomponentId, 
                                   szSectionToProcess,
                                   sizeof(szSectionToProcess) / sizeof(TCHAR));

            if (dwReturn != NO_ERROR)
            {
                VERBOSE(SETUP_ERR, 
                        _T("Failed to get section to process ")
                        _T("rc = 0x%lx"),
                        dwReturn);
            }
        }

        if (dwReturn == NO_ERROR)
        {
            if (bInstallSelected)
            {
                // 
                // Install
                //

                //
                //  Prepare for the Upgrade : Save different Settings 
                //
                dwReturn = fxocUpg_SaveSettings();
                if (dwReturn != NO_ERROR)
                {
                    VERBOSE(DBG_WARNING,
                            _T("Failed to prepare for the Upgrade : save settings during upgrade to Windows-XP Fax. ")
                            _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                            dwReturn);
                    dwReturn = NO_ERROR;
                }

                // install files
                dwReturn = fxocFile_Install(pszSubcomponentId,
                                            szSectionToProcess);

                if (dwReturn != NO_ERROR)
                {
                    VERBOSE(DBG_MSG,
                            _T("Failed Fax File operations, ")
                            _T("for subcomponent '%s', section '%s', ")
                            _T("rc = 0x%lx"), pszSubcomponentId, 
                            szSectionToProcess, dwReturn);
                }
            }
            else
            {
                // 
                // Uninstall
                //
                dwReturn = prv_UninstallFax(pszSubcomponentId,
                                            szSectionToProcess);
            }
        }
    }
    else
    {
        VERBOSE(DBG_MSG,
                _T("End Queuing of Files, ComponentID: '%s', ")
                _T("SubComponentID: '%s', Selection State has NOT ")
                _T("changed, doing nothing, bInstallSelected=%lu"),
                pszComponentId, pszSubcomponentId, 
                bInstallSelected);

    }

    return dwReturn;
}

///////////////////////////////
// prv_OnCompleteInstallation
//
// Handler for OC_COMPLETE_INSTALLATION.
// This is called after the queue is 
// committed.  It is here that we
// make our registery changes, add 
// fax service, and create the fax printer.                                
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId.
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnCompleteInstallation(LPCTSTR pszComponentId, 
                                        LPCTSTR pszSubcomponentId)
{
    BOOL  bSelectionStateChanged = FALSE;
    BOOL  bInstallSelected       = FALSE;
    DWORD dwReturn               = NO_ERROR;

    DBG_ENTER(  TEXT("prv_OnCompleteInstallation"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);
    // Do post-installation processing in the cleanup section.
    // This way we know all components queued for installation
    // have beein installed before we do our stuff.

    if (!pszSubcomponentId || !*pszSubcomponentId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwReturn = faxocm_HasSelectionStateChanged(pszSubcomponentId,
                                               &bSelectionStateChanged,
                                               &bInstallSelected,
                                               NULL);

    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR, 
                _T("HasSelectionStateChanged failed, rc = 0x%lx"),
                dwReturn);

        return dwReturn;
    }

    // if our selection state has changed, then install/uninstall
    if (bSelectionStateChanged)
    {
        TCHAR szSectionToProcess[255 + 1] = {0};

        //
        // Fake report to prevent re-entrancy
        //
        g_InstallReportType = bInstallSelected ? REPORT_FAX_UNINSTALLED : REPORT_FAX_INSTALLED;

        dwReturn = prv_GetSectionToProcess(
                                   pszSubcomponentId, 
                                   szSectionToProcess,
                                   sizeof(szSectionToProcess) / sizeof(TCHAR));


        if (dwReturn == NO_ERROR)
        {
            // if the Install checkbox is selected, then install
            if (bInstallSelected) 
            { 
                dwReturn = prv_CompleteFaxInstall(pszSubcomponentId,
                                                  szSectionToProcess);
            } 
            else 
            { 
                // if the install checkbox is not selected, then uninstall.
                dwReturn = prv_CompleteFaxUninstall(pszSubcomponentId,
                                                    szSectionToProcess);
            }
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to get section to process ")
                    _T("rc = 0x%lx"), dwReturn);
        }
        //
        // Report real installation state in case someone asks
        //
        g_InstallReportType = REPORT_FAX_DETECT;
        if (ERROR_SUCCESS == dwReturn)
        {
            //
            // Installation / Uninstallation is successfully complete.
            // Notify the 'Printers and Faxes' folder it should refresh itself.
            //
            RefreshPrintersAndFaxesFolder();
        }
    }
    return dwReturn;
}   // prv_OnCompleteInstallation

///////////////////////////////
// prv_CompleteFaxInstall
//
// Called by prv_OnCompleteInstallation
// this function creates the program
// groups/shortcuts, registry entries,
// fax service, fax printer, etc.
//
// Params:
//      - pszSubcomponentId
//      - pszSectionToProcess
//
static DWORD prv_CompleteFaxInstall(const TCHAR *pszSubcomponentId,
                                    const TCHAR *pszSectionToProcess)
{
    DWORD                       dwReturn	= NO_ERROR;
    fxState_UpgradeType_e       UpgradeType = FXSTATE_UPGRADE_TYPE_NONE;

    DBG_ENTER(  TEXT("prv_CompleteFaxInstall"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszSubcomponentId, 
                pszSectionToProcess);

    if ((pszSubcomponentId   == NULL) ||
        (pszSectionToProcess == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    UpgradeType = fxState_IsUpgrade();

    // Create Program Group/Shortcuts
    // We create the shortcuts first because at the very worst case, if we
    // fail everything else, the applications should be somewhat robust enough
    // to be able to correct or notify the user of problems that could not
    // be notified during install.
    VERBOSE(DBG_MSG,_T("Creating program groups and shortcuts..."));

    dwReturn = fxocLink_Install(pszSubcomponentId,pszSectionToProcess);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to create program ")
                _T("groups/shortcuts for fax.  This is a non-fatal ")
                _T("error, continuing fax install...rc=0x%lx"),
                dwReturn);

        dwReturn = NO_ERROR;
    }

    prv_UpdateProgressBar(1);

    // Load the unattended data if applicable
    if ((fxState_IsUnattended()) || (UpgradeType == FXSTATE_UPGRADE_TYPE_WIN9X))
    {
        VERBOSE(DBG_MSG,
                _T("CompleteInstall, state is unattended ")
                _T("or we are upgrading from Win9X, ")
                _T("caching unattended data from INF file"));

        // load our unattended data
        dwReturn = fxUnatnd_LoadUnattendedData();
        if (dwReturn == NO_ERROR)
        {
            // set up the fax printer name
            fxocPrnt_SetFaxPrinterName(fxUnatnd_GetPrinterName());
            fxocPrnt_SetFaxPrinterShared(fxUnatnd_GetIsPrinterShared());
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to load unattended data, ")
                    _T("non-fatal error, continuing anyway...")
                    _T("rc = 0x%lx"), dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    prv_UpdateProgressBar(1);

    // install the registry settings as specified in the INF file
    VERBOSE(DBG_MSG,_T("Installing Registry..."));

    dwReturn = fxocReg_Install(pszSubcomponentId,pszSectionToProcess);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install registry settings ")
                _T("for fax installation.  This is a fatal ")
                _T("error, abandoning fax install...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    prv_UpdateProgressBar(1);

    // migrate existing SBS registry
    if (UpgradeType == FXSTATE_UPGRADE_TYPE_W2K)
    {
        VERBOSE(DBG_MSG,_T("Migrating existing registry..."));

        dwReturn = fxocUpg_MoveRegistry();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to migrate existing registry.")
                    _T("This is a non-fatal ")
                    _T("error, continuing fax install...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    prv_UpdateProgressBar(1);

    // Install Fax Printer/Monitor support
    // Create a fax printer and monitor

    VERBOSE(DBG_MSG,_T("Installing Fax Monitor and printer drivers..."));
    dwReturn = fxocPrnt_Install(pszSubcomponentId,pszSectionToProcess);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install fax printer drivers and ")
                _T("fax monitor.  This is a fatal ")
                _T("error, abandoning fax installation...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    VERBOSE(DBG_MSG,_T("Installing Fax printer..."));
    dwReturn = fxocPrnt_InstallPrinter();
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install fax printer. This is a fatal ")
                _T("error, abandoning fax installation...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    prv_UpdateProgressBar(1);
    
    // Create fax directories
    dwReturn = fxocFile_ProcessDirectories(pszSectionToProcess,INF_KEYWORD_CREATEDIR);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install create directories ")
                _T("for fax.  This is a fatal ")
                _T("error, abandoning fax installation...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    prv_UpdateProgressBar(1);

    // Install Services 
    // Install any services as specified in the section of the INF file

    VERBOSE(DBG_MSG,_T("Installing Fax Service..."));

    dwReturn = fxocSvc_Install(pszSubcomponentId,pszSectionToProcess);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install fax service. ")
                _T("This is a fatal ")
                _T("error, abandoning fax install...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    // Try installing the fax printer another time.
    // If first attempt succeeded, this will return without doing anything.
    // This is because BrookTrout TSP exposes TAPI devices only when it sees the Fax
    // service installed.
    VERBOSE(DBG_MSG,_T("Installing Fax printer..."));
    dwReturn = fxocPrnt_InstallPrinter();
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install fax printer. This is a fatal ")
                _T("error, abandoning fax installation...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }
    
    prv_UpdateProgressBar(1);

    // Install Exchange Support
    VERBOSE(DBG_MSG,_T("Installing Fax MAPI extension..."));

    dwReturn = fxocMapi_Install(pszSubcomponentId,pszSectionToProcess);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install exchange support for ")
                _T("fax.  This is a fatal ")
                _T("error, abandoning fax installation...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    prv_UpdateProgressBar(1);

    // Delete Directories at upgrade
    VERBOSE(DBG_MSG, _T("Creating directories..."));

    //
    //  At upgrade, before deleting of directories, take care of their content
    //
    dwReturn = fxocUpg_MoveFiles();
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_WARNING,
                _T("Failed to clear previous fax directories. ")
                _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                dwReturn);
        dwReturn = NO_ERROR;
    }

    dwReturn = fxocFile_ProcessDirectories(pszSectionToProcess,INF_KEYWORD_DELDIR);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_WARNING,
                _T("Failed to delete directories. ")
                _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                dwReturn);
        dwReturn = NO_ERROR;
    }

    prv_UpdateProgressBar(1);

    // create/delete the Shares
    VERBOSE(DBG_MSG, _T("Create shares..."));

    dwReturn = fxocFile_ProcessShares(pszSectionToProcess);

    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install shares ")
                _T("for fax.  This is a fatal ")
                _T("error, abandoning fax installation...rc=0x%lx"),
                dwReturn);
		goto cleanup;
    }

    if ((fxState_IsUnattended()) || (UpgradeType == FXSTATE_UPGRADE_TYPE_WIN9X))
    {
        VERBOSE(DBG_MSG, _T("Saving unattended data to registry"));

        //
        //  this will read from the unattended file list of the uninstalled fax applications
        //  and update the fxocUpg.prvData, which is used later, in fxocUpg_GetUpgradeApp()
        //  to decide whether or not to show the "Where Did My Fax Go" shortcut.
        //
        dwReturn = fxUnatnd_SaveUnattendedData();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to save unattended data")
                    _T("to the registry. This is a non-fatal ")
                    _T("error, continuing fax install...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    prv_ShowUninstalledFaxShortcut();

	prv_UpdateProgressBar(1);

    dwReturn = prv_NotifyStatusMonitor(FAX_STARTUP_TIMER_ID);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to notify Status Monitor.")
                _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                dwReturn);

        dwReturn = NO_ERROR;
    }

    prv_UpdateProgressBar(1);
    
    //
    //  Complete the Upgrade : Restore settings that were saved at Preparation stage
    //
    dwReturn = fxocUpg_RestoreSettings();
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_WARNING,
                _T("Failed to restore previous fax applications settings after their uninstall. ")
                _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                dwReturn);

        dwReturn = NO_ERROR;
    }

	prv_UpdateProgressBar(1);

cleanup:
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Complete Fax Install failed, rc = 0x%lx"),
                dwReturn);

        // now we attemp a rollback, if we're here, things are quite bad as it is.
        // we'll try to remove shortcuts, remove the service, etc.
        // the files will remain on the machine.
        TCHAR szUninstallSection[MAX_PATH] = {0};
        if( fxocUtil_GetUninstallSection(pszSubcomponentId,szUninstallSection,MAX_PATH)==NO_ERROR)
        {
            VERBOSE(DBG_MSG,_T("Performing rollback, using section %s."),szUninstallSection);
            if (prv_UninstallFax(pszSubcomponentId,szUninstallSection)==NO_ERROR)
            {
                VERBOSE(DBG_MSG,_T("Rollback (prv_UninstallFax) successful..."));
            }
            else
            {
                // not setting dwReturn explicitly to preserve to original cause for failure.
                VERBOSE(SETUP_ERR,_T("Rollback (prv_UninstallFax) failed, rc = 0x%lx"),GetLastError());
            }
            if (prv_CompleteFaxUninstall(pszSubcomponentId,szUninstallSection)==NO_ERROR)
            {
                VERBOSE(DBG_MSG,_T("Rollback (prv_CompleteFaxUninstall) successful..."));
            }
            else
            {
                // not setting dwReturn explicitly to preserve to original cause for failure.
                VERBOSE(SETUP_ERR,_T("Rollback (prv_CompleteFaxUninstall) failed, rc = 0x%lx"),GetLastError());
            }
        }
        else
        {
            // not setting dwReturn explicitly to preserve to original cause for failure.
            VERBOSE(SETUP_ERR,_T("fxocUtil_GetUninstallSection failed, rc = 0x%lx"),GetLastError());
        }
    }
    return dwReturn;
}   // prv_CompleteFaxInstall

///////////////////////////////
// prv_CompleteFaxUninstall
//
// Called by prv_OnCompleteInstallation
// to uninstall the fax.  Since most
// of the work is done before we even
// queue our files to delete, the only
// thing we really do here is remove the
// program group/shortcuts.
//
// Params:
//      - pszSubcomponentId
//      - pszSectionToProcess
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
// 
static DWORD prv_CompleteFaxUninstall(const TCHAR *pszSubcomponentId,
                                      const TCHAR *pszSectionToProcess)
{
    DWORD dwReturn = NO_ERROR;

    DBG_ENTER(  TEXT("prv_CompleteFaxUninstall"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszSubcomponentId, 
                pszSectionToProcess);

    if ((pszSubcomponentId == NULL) ||
        (pszSectionToProcess == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Uninstall directories
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocFile_ProcessDirectories(pszSectionToProcess,INF_KEYWORD_DELDIR);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall directories ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }


    // uninstall subsystems in the reverse order they were installed in.
    if (dwReturn == NO_ERROR)
    {
        // notice we ignore the return codes, we will attempt to completely
        // uninstall even if something fails to uninstall.

        // Remove Program Group/Shortcuts
        dwReturn = fxocLink_Uninstall(pszSubcomponentId,
                                      pszSectionToProcess);
    }
    return dwReturn;
}   // prv_CompleteFaxUninstall

///////////////////////////////
// prv_UninstallFax
//
// Uninstalls fax from the user's
// computer.  This does everything
// except the program group delete.  It 
// will remove the fax printer,
// fax service, exchange updates,
// registry, and file deletion.

static DWORD prv_UninstallFax(const TCHAR *pszSubcomponentId,
                              const TCHAR *pszUninstallSection)
{
    DWORD dwReturn = NO_ERROR;

    DBG_ENTER(  TEXT("prv_UninstallFax"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszSubcomponentId, 
                pszUninstallSection);

    if ((pszSubcomponentId      == NULL) ||
        (pszUninstallSection    == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Notice when we uninstall our files, we want to clean up
    // everything else first, to ensure that we can successfully
    // remove the files.

    // Uninstall shares
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocFile_ProcessShares(pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall shares ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    // Uninstall Fax Printer/Monitor support
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocPrnt_Uninstall(pszSubcomponentId,
                                      pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax printer ")
                    _T("and monitor.  This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    // Uninstall Exchange Support
    if (dwReturn == NO_ERROR)
    {
        fxocMapi_Uninstall(pszSubcomponentId,pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax exchange support")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    // we have to tell the status monitor to shut itself down before
    // we shut down the service, since it calls FaxUnregisterEvents...
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_NotifyStatusMonitor(FAX_SHUTDOWN_TIMER_ID);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to notify Status Monitor.")
                    _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                    dwReturn);
            dwReturn = NO_ERROR;
        }
    }

    // Notice we uninstall our service first before uninstalling
    // the files.
    if (dwReturn == NO_ERROR)
    {
        fxocSvc_Uninstall(pszSubcomponentId,
                          pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax service.  ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    if (dwReturn == NO_ERROR)
    {
        // Uninstall Registry
        fxocReg_Uninstall(pszSubcomponentId,
                          pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax registry.  ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    if (dwReturn == NO_ERROR)
    {
        // uninstall files
        dwReturn = fxocFile_Uninstall(pszSubcomponentId,
                                      pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax files.  ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    return dwReturn;
}


///////////////////////////////
// prv_OnNotificationFromQueue
//
// Handler for OC_NOTIFICATION_FROM_QUEUE
// 
// NOTE: although this notification is defined,
// it is currently unimplemented in oc manager
//

static DWORD prv_OnNotificationFromQueue(void)
{
    return NO_ERROR;
}

///////////////////////////////
// prv_OnQueryStepCount
//
// This query by the OC Manager
// determines how many "ticks"
// on the progress bar we would
// like shown.  
//
// We only update the progress
// bar during an install (for 
// no good reason!).  It seems
// that all OC components do this.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
static DWORD prv_OnQueryStepCount(LPCTSTR pszComponentId,
                                  LPCTSTR pszSubcomponentId)
{
    DWORD dwErr                  = 0;
    DWORD dwNumSteps             = 0;
    BOOL  bInstallSelected       = FALSE;
    BOOL  bSelectionStateChanged = FALSE;

    DBG_ENTER(  TEXT("prv_OnQueryStepCount"),
                dwNumSteps, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);

    if (!pszSubcomponentId || !*pszSubcomponentId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = faxocm_HasSelectionStateChanged(pszSubcomponentId,
                                            &bSelectionStateChanged,
                                            &bInstallSelected,
                                            NULL);

    if (dwErr != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("HasSelectionStateChanged failed, rc = 0x%lx"),
                dwErr);

        return 0;
    }

    if (bSelectionStateChanged)
    {
        if (bInstallSelected)
        {
            dwNumSteps = prv_TOTAL_NUM_PROGRESS_BAR_TICKS;
        }
    }

    return dwNumSteps;
}

///////////////////////////////
// prv_OnExtraRoutines
//
// OC Manager giving us some
// extra routines.  Save them.
//
// Params:
//      - pszComponentId
//      - pExtraRoutines - pointer to extra OC Manager fns.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise
//
static DWORD prv_OnExtraRoutines(LPCTSTR            pszComponentId, 
                                 EXTRA_ROUTINES    *pExtraRoutines)
{
    DWORD dwResult = NO_ERROR;
    DBG_ENTER(  TEXT("prv_OnExtraRoutines"),
                dwResult, 
                TEXT("%s"), 
                pszComponentId);

    if ((pszComponentId == NULL) ||
        (pExtraRoutines == NULL))
    {
        dwResult = ERROR_INVALID_PARAMETER;
        return dwResult;
    }

    memcpy(&prv_GVAR.Component.Extras, 
           pExtraRoutines, 
           sizeof(prv_GVAR.Component.Extras));

    dwResult = NO_ERROR;
    return dwResult;
}


///////////////////////////////
// prv_OnSetLanguage
//
// Handler for OC_SET_LANGUAGE
// the OC Manager is requesting
// we change to the specified language.
// Since there is no GUI, this is not
// an issue.
//
// Params:
// Return:
//      - TRUE indicating successfully
//        changed language.
//
static DWORD prv_OnSetLanguage(UINT uiLanguageID)
{
//    return false;  // this is what OCGEN returns

    prv_GVAR.Component.uiLanguageID = uiLanguageID;

    return TRUE;
}

///////////////////////////////
// prv_OnQueryImage
//
// Handler for OC_QUERY_IMAGE
// this returns the handle to the
// loaded icon for displaying in the
// Add/Remove dialog.
// 
// Params:
// Returns:
//      - HBITMAP - handle to loaded bitmap
//
static DWORD_PTR prv_OnQueryImage(void)
{
    DWORD_PTR dwResult = (DWORD_PTR)INVALID_HANDLE_VALUE;
    DBG_ENTER(TEXT("prv_OnQueryImage"));

    dwResult = (DWORD_PTR) LoadBitmap(faxocm_GetAppInstance(),
                                  MAKEINTRESOURCE(IDI_FAX_ICON));  
    return dwResult;
}

///////////////////////////////
// prv_OnSetupRequestPages
//
// Handler for OC_REQUEST_PAGES.
// We don't have a GUI, so we
// return 0 pages.
//
// Params:
//      - uiType - specifies a type from the
//        WizardPagesType enumerator.
//      - Pointer to SETUP_REQUEST_PAGES 
//        structure.
// Returns:
//      - 0, no pages to display
//        
//
static DWORD prv_OnSetupRequestPages(
    LPCTSTR pszComponentId,
    WizardPagesType uiType, 
    PSETUP_REQUEST_PAGES pSetupRequestPages)
{
    DWORD           dwReturn     = 0;
    PROPSHEETPAGE   psp          = {0};

    DBG_ENTER(  _T("prv_OnSetupRequestPages"),
                dwReturn,
                _T("%s - %d"),
                pszComponentId, 
                uiType);

    // Don't show pages if it's unattended
    if (fxState_IsUnattended())
    {
        dwReturn = 0;
        goto exit;
    }

    // Only show pages in WizPagesEarly 
    if (uiType != WizPagesEarly)
    {
        dwReturn = 0;
        goto exit;
    }

    if (!IsFaxShared())
    {
        VERBOSE(DBG_MSG, _T("Sharing not supported in this SKU, don't show wizard page"));
        dwReturn = 0;
        goto exit;
    }

    if (pSetupRequestPages->MaxPages < 1)
    {
        dwReturn = 1;
        goto exit;
    }

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance = faxocm_GetAppInstance();
    psp.pszTemplate = MAKEINTRESOURCE(IDD_OCM_WIZARD_PAGE);
    psp.pfnDlgProc = prv_dlgOcmWizardPage;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_WIZARD_PAGE_TITLE);
    psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_WIZARD_PAGE_SUBTITLE);

    pSetupRequestPages->Pages[0] = CreatePropertySheetPage(&psp);
    if (!pSetupRequestPages->Pages[0])
    {
        VERBOSE(SETUP_ERR,_T("CreatePropertySheetPage failed, ec=%d"), GetLastError());
        dwReturn = 0;
        goto exit;
    }

    dwReturn = 1;

exit:
    return dwReturn;
}

///////////////////////////////
// prv_OnWizardCreated
//
// Handler for OC_WIZARD_CREATED
// Do nothing.
//
static DWORD prv_OnWizardCreated(void)
{
    return NO_ERROR;
}

///////////////////////////////
// prv_OnQuerySelStateChange
//
// Handle for OC_QUERY_CHANGE_SEL_STATE
// OC Manager is asking us if it is
// okay for the user to select/unselect
// this component from the Add/Remove 
// list.  We want to allow the user
// to NOT install this as well, so 
// always allow the user to change the
// selection state.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId
//      - uiState - Specifies proposed new selection
//        state.  0 => not selected, 1 => selected.
//      - uiFlags - Could be OCQ_ACTUAL_SELECTION or 0.
//        If it is OCQ_ACTUAL_SELECTION then the user
//        actually selected/deselected the pszSubcomponentId.
//        If it is 0, it is being turned on or off
//        because the parent needs that subcomponent.
//        
// Returns:
//      - TRUE - allow selection change
// 
//
static DWORD prv_OnQuerySelStateChange(LPCTSTR pszComponentId,
                                       LPCTSTR pszSubcomponentId,
                                       UINT    uiState,
                                       UINT    uiFlags)
{
    // always allow the user to change the selection state of the component.
    return TRUE;
}

///////////////////////////////
// prv_OnQueryState
//
// Handler for OC_QUERY_STATE
// OC Manager is asking us if the 
// given subcomponent is installed or 
// not.  Since the OC Manager keeps a 
// record of this for itself, we rely
// on it to keep track of our installed
// state.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId
//      - uiState - Install state OC Manager thinks we are in.
// Returns:
//      - SubcompUseOCManagerDefault - use whatever state
//        OC Manager thinks we are in.
//

static DWORD prv_OnQueryState(LPCTSTR pszComponentId,
                              LPCTSTR pszSubcomponentId,
                              UINT    uiState)
{
    DWORD dwState = SubcompOff;

    DBG_ENTER(_T("prv_OnQueryState"));

    // szSubComponentID should've been set during OC_INIT_COMPONENT, but
    // we don't have it there. So set it here.
    _tcsncpy(prv_GVAR.Component.szSubComponentID, 
             pszComponentId,
             ARR_SIZE(prv_GVAR.Component.szSubComponentID));


    if (uiState==OCSELSTATETYPE_CURRENT)
    {
        // when asking about the current state, use the default (either user initiated or from answer file)
        dwState = SubcompUseOcManagerDefault;
    }
    else
    {
        HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP, FALSE,KEY_READ);
        if (hKey)
        {
            DWORD dwInstalled = 0;
            if (GetRegistryDwordEx(hKey,REGVAL_FAXINSTALLED,&dwInstalled)==NO_ERROR)
            {
                if (dwInstalled)
                {
                    VERBOSE(DBG_MSG,_T("REG_DWORD 'Installed' is set, assume component is installed"));
                    dwState = SubcompOn;
                }
                else
                {
                    VERBOSE(DBG_MSG,_T("REG_DWORD 'Installed' is zero, assume component is not installed"));
                }
            }
            else
            {
                VERBOSE(DBG_MSG,_T("REG_DWORD 'Installed' does not exist, assume component is not installed"));
            }
        }
        else
        {
            VERBOSE(DBG_MSG,_T("HKLM\\Software\\Microsoft\\Fax\\Setup does not exist, assume component is not installed"));
        }
        if (hKey)
        {
            RegCloseKey(hKey);
        }
    }
    return dwState;
}

///////////////////////////////
// prv_OnNeedMedia
//
// Handler for OC_NEED_MEDIA
// Allows us to fetch our own
// media - for example, from the 
// Internet.  We don't need anything
// so just move on.
//
// Params:
// Returns:
//      - FALSE - don't need any media
//      
//
static DWORD prv_OnNeedMedia(void)
{
    return FALSE;
}

///////////////////////////////
// prv_OnAboutToCommitQueue
//
// Handler for OC_ABOUT_TO_COMMIT_QUEUE
// Tells us that OC Manager is about
// to commit to queue.  We don't really
// care, do nothing.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//

static DWORD prv_OnAboutToCommitQueue(LPCTSTR pszComponentId, 
                                      LPCTSTR pszSubcomponentId)
{
    DWORD dwReturn                  = NO_ERROR;

    // don't think we need to do anything here yet.

    return dwReturn;
}

///////////////////////////////
// prv_OnQuerySkipPage
//
// Handler for OC_QUERY_SKIP_PAGE
// 
// Params:
// Returns:
// 
//
static DWORD prv_OnQuerySkipPage(void)
{
    return FALSE;
}

///////////////////////////////
// faxocm_HasSelectionStateChanged
//
// This fn tells us if our selection
// state in the Add/Remove programs
// dialog box has changed since it
// was started, and it also tells us
// our current selection state.
//
// Params:
//      - pszSubcomponentId
//      - pbCurrentSelected - OUT
//      - pbOriginallySelected - OUT
// Returns:
//      - TRUE if selection state has changed
//      - FALSE otherwise.
//
DWORD faxocm_HasSelectionStateChanged(LPCTSTR pszSubcomponentId,
                                      BOOL    *pbSelectionStateChanged,
                                      BOOL    *pbCurrentlySelected,
                                      BOOL    *pbOriginallySelected)
{
    DWORD dwReturn              = NO_ERROR;
    BOOL bCurrentlySelected     = FALSE;
    BOOL bOriginallySelected    = FALSE;
    BOOL bSelectionChanged      = TRUE;
    PQUERYSELECTIONSTATE_ROUTINEW   pQuerySelectionState = NULL;

    DBG_ENTER(  TEXT("faxocm_HasSelectionStateChanged"),
                dwReturn, 
                TEXT("%s"), 
                pszSubcomponentId);

    // if pszSubcomponentId == NULL, we are hosed.
    Assert(pszSubcomponentId != NULL);
    Assert(pbSelectionStateChanged != NULL);

    if ((pszSubcomponentId          == NULL) ||
        (pbSelectionStateChanged    == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return dwReturn=ERROR_INVALID_PARAMETER;
    }

    pQuerySelectionState = prv_GVAR.Component.Helpers.QuerySelectionState;

    if (pQuerySelectionState)
    {
        // are we currently selected.

        bCurrentlySelected = pQuerySelectionState(
                        prv_GVAR.Component.Helpers.OcManagerContext,
                        pszSubcomponentId,
                        OCSELSTATETYPE_CURRENT);

        bOriginallySelected = pQuerySelectionState(
                        prv_GVAR.Component.Helpers.OcManagerContext,
                        pszSubcomponentId,
                        OCSELSTATETYPE_ORIGINAL);

        if (bOriginallySelected == bCurrentlySelected)
        {
            bSelectionChanged = FALSE;
        }
        else
        {
            bSelectionChanged = TRUE;
        }
    }

    // if we are not in stand alone mode, and we are upgrading the OS, then assume that
    // the selection state has changed.  We do this because we would like to force an 
    // install of fax during an upgrade from NT or W2K.  Currently (as of 05/02/2000)
    // OC Manager reports an upgrade type of WINNT when upgrading from W2K.  This is valid
    // because fax is always installed in W2K (the user could not uninstall it), and therefore
    // whenever we upgrade, bSelectionChanged will always be FALSE, which will prevent
    // the new fax from being installed.  NOT GOOD.  This fixes that.

    if ( (fxState_IsStandAlone() == FALSE) && 
         ((fxState_IsUpgrade()   == FXSTATE_UPGRADE_TYPE_W2K)		||
		  (fxState_IsUpgrade()   == FXSTATE_UPGRADE_TYPE_REPAIR)	||
		  (fxState_IsUpgrade()   == FXSTATE_UPGRADE_TYPE_XP_DOT_NET)))
    {
        if (bOriginallySelected && bCurrentlySelected)
        {
            // only if Fax was installed and is now marked for installation during OS upgrade
            // we force re-installation.
            // If both were false, this can't return true because it'll cause an uninstall
            // going and we'll try to uninstall a non existing Fax.
            // This happens when upgrading XP build without Fax to another.
            // This causes many setup error (in setupapi logs) and disturbes setup people.
            // this condition takes care of this problem.
            bSelectionChanged = TRUE;
        }
    }

    if (pbCurrentlySelected)
    {
        *pbCurrentlySelected = bCurrentlySelected;
    }

    if (pbOriginallySelected)
    {
        *pbOriginallySelected = bOriginallySelected;
    }

    *pbSelectionStateChanged = bSelectionChanged;

    return dwReturn;
}

///////////////////////////////
// prv_NotifyStatusMonitor
//
// This function notifies the shell
// to load FXSST.DLL (Status Monitor)
// It is done by sending a private message
// to STOBJECT.DLL window.
// 
//
// Params:
//      - WPARAM wParam - 
//              either  FAX_STARTUP_TIMER_ID or 
//                      FAX_SHUTDOWN_TIMER_ID
//      
// Returns:
//      - NO_ERROR if notification succeeded
//      - Win32 Error code otherwise.
//
static DWORD prv_NotifyStatusMonitor(WPARAM wParam)
{
    DWORD dwRet = NO_ERROR;
    HWND hWnd = NULL;
    DBG_ENTER(TEXT("prv_NotifyStatusMonitor"),dwRet);

    // We need to send a WM_TIMER to a window identified by the class name SYSTRAY_CLASSNAME
    // The timer ID should be FAX_STARTUP_TIMER_ID

    hWnd = FindWindow(SYSTRAY_CLASSNAME,NULL);
    if (hWnd==NULL)
    {
        dwRet = GetLastError();
        CALL_FAIL(SETUP_ERR,TEXT("FindWindow"),dwRet);
        goto exit;
    }

    SendMessage(hWnd,WM_TIMER,wParam,0);

exit:
    return dwRet;
}

static INT_PTR CALLBACK prv_dlgWhereDidMyFaxGoQuestion
(
  HWND hwndDlg,   
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  
)
/*++

Routine name : prv_dlgWhereDidMyFaxGoQuestion

Routine description:

    Dialogs procedure for "Where did my fax go" dialog

Author:

    Mooly Beery (MoolyB),   Mar, 2001

Arguments:

    hwndDlg                       [in]    - Handle to dialog box
    uMsg                          [in]    - Message
    wParam                        [in]    - First message parameter
    parameter                     [in]    - Second message parameter

Return Value:

    Standard dialog return value

--*/
{
    INT_PTR iRes = IDIGNORE;
    DBG_ENTER(_T("prv_dlgWhereDidMyFaxGoQuestion"));

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            SetFocus(hwndDlg);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) 
            {
                case IDOK:
                    if (BST_CHECKED == ::SendMessage (::GetDlgItem (hwndDlg, IDC_REMOVE_LINK), BM_GETCHECK, 0, 0))
                    {
                        // we should remove the link.
                        // we do this by processing our INF in the section that deals
                        // with this link. This way we're sure it can be localized at will
                        // and we'll always remove the correct link.
                        TCHAR szInfFileName[2*MAX_PATH] = {0};
                        if (faxocm_GetComponentInfName(szInfFileName))
                        {
                            _tcscat(szInfFileName,_T(",Fax.UnInstall.PerUser.WhereDidMyFaxGo"));
                            if (LPSTR pszInfCommandLine = UnicodeStringToAnsiString(szInfFileName))
                            {
                                LaunchINFSection(hwndDlg,prv_GVAR.hInstance,pszInfCommandLine,1);
                                MemFree(pszInfCommandLine);
                            }
                        }
                    }
                    EndDialog (hwndDlg, iRes);
                    return TRUE;
            }
            break;
    }
    return FALSE;
}   // prv_dlgWhereDidMyFaxGoQuestion

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  WhereDidMyFaxGo
//
//  Purpose:        
//                  When a machine running SBS5.0 client was upgraded to Windows-XP
//                  We show a link called 'Where did my Fax go' in the start menu
//                  at the same location where the SBS5.0 shortcuts used to be.
//                  When clicking this link it calls this function that raises
//                  a dialog to explain to the user where the Windows-XP Fax's
//                  shortcuts are, and asks the user whether to delete this link.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD WhereDidMyFaxGo(void)
{
    DWORD dwRet = NO_ERROR;
    DBG_ENTER(TEXT("WhereDidMyFaxGo"),dwRet);

    HMODULE hFaxRes = LoadLibraryEx(FAX_RES_FILE, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if(!hFaxRes)
    {
        dwRet = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadLibraryEx(FxsRes.dll)"), dwRet);
        return dwRet;
    }
    
    INT_PTR iResult = DialogBox (hFaxRes,
                                 MAKEINTRESOURCE(IDD_WHERE_DID_MY_FAX_GO),
                                 NULL,
                                 prv_dlgWhereDidMyFaxGoQuestion);
    if (iResult==-1)
    {
        dwRet = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("DialogBox(IDD_WHERE_DID_MY_FAX_GO)"), dwRet);
    }

    FreeLibrary(hFaxRes);

    return dwRet;
}

DWORD prv_ShowUninstalledFaxShortcut(void)
/*++

Routine name : prv_ShowUninstalledFaxShortcut

Routine description:

    Show Shortcut of "Where Did My Fax Go ? " in the All Programs.

Author:

    Iv Garber (IvG),    Jun, 2001

Return Value:

    Standard Win32 error code

--*/
{
    DBG_ENTER(_T("prv_ShowUninstalledFaxShortcut"));

    //
    // In cases we upgraded from a machine running SBS2000 Client/Server or XP Client and we want to 
    // add a 'Where did my Fax go' shortcut.
    // we want to add it to the current user as well as every user.
    //
    if (fxocUpg_GetUpgradeApp() != FXSTATE_NONE)
    {
        //
        // first add the shortcut to the current user.
        //
        TCHAR szInfFileName[2*MAX_PATH] = {0};
        if (faxocm_GetComponentInfName(szInfFileName))
        {
            _tcscat(szInfFileName,_T(",Fax.Install.PerUser.AppUpgrade"));
            if (LPSTR pszInfCommandLine = UnicodeStringToAnsiString(szInfFileName))
            {
                LaunchINFSection(NULL,prv_GVAR.hInstance,pszInfCommandLine,1);
                MemFree(pszInfCommandLine);
            }
        }
        else
        {
            CALL_FAIL(SETUP_ERR,TEXT("faxocm_GetComponentInfName"),GetLastError());
        }

        //
        // now change the PerUserStub to point to the section that creates the link for every user.
        //
        HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_ACTIVE_SETUP_NT, FALSE,KEY_ALL_ACCESS);
        if (hKey)
        {
            if (LPTSTR lptstrPerUser = GetRegistryString(hKey,_T("StubPath"),NULL))
            {
                TCHAR szLocalPerUserStub[MAX_PATH*2] = {0};
                _tcscpy(szLocalPerUserStub,lptstrPerUser);
                _tcscat(szLocalPerUserStub,REGVAL_ACTIVE_SETUP_PER_USER_APP_UPGRADE);
                if (!SetRegistryString(hKey,_T("StubPath"),szLocalPerUserStub))
                {
                    CALL_FAIL(SETUP_ERR,TEXT("SetRegistryString"),GetLastError());
                }
                MemFree(lptstrPerUser);
            }
            else
            {
                CALL_FAIL(SETUP_ERR,TEXT("GetRegistryString"),GetLastError());
            }
            RegCloseKey(hKey);
        }
        else
        {
            CALL_FAIL(SETUP_ERR,TEXT("OpenRegistryKey"),GetLastError());
        }
    }

    return NO_ERROR;
}


BOOL prv_ShouldShowPage()
/*++
Routine name : prv_ShouldShowPage
Routine description: Checks whether the OCM wizard page should be shown
Author: Jonathan Barner (jobarner), May 2002
Arguments: none
Return value: TRUE - show, FALSE - don't show
--*/
{
    BOOL  bSelectionStateChanged = FALSE;
    BOOL  bInstallSelected       = FALSE;

    if (faxocm_HasSelectionStateChanged(prv_GVAR.Component.szSubComponentID,
                                        &bSelectionStateChanged,
                                        &bInstallSelected,
                                        NULL) != NO_ERROR)
    {
        return FALSE;
    }

    return (bSelectionStateChanged && bInstallSelected);
}

static INT_PTR CALLBACK prv_dlgOcmWizardPage(HWND hwndDlg,   
                                             UINT uMsg,     
                                             WPARAM wParam, 
                                             LPARAM lParam)
/*++
Routine name : prv_dlgOcmWizardPage
Routine description: Dialog procedure for OCM Wizard page dialog
Author: Jonathan Barner (jobarner), May 2002
Arguments and return values: Standard dialog return value
--*/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Set default to "do not share printer"
            CheckRadioButton(hwndDlg, IDC_SHARE_PRINTER, IDC_DO_NOT_SHARE_PRINTER,
                 IDC_DO_NOT_SHARE_PRINTER);
            break;

        case WM_NOTIFY:
            switch(((NMHDR FAR*)lParam)->code)
            {
                case PSN_SETACTIVE:
                    {
                        LONG_PTR lReturn = prv_ShouldShowPage() ? 0 : -1;
                        if (lReturn == 0)
                        {
                            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
                        }
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, lReturn);
                        return TRUE;
                    }
                    break;
                    
                case PSN_WIZNEXT:
                    BOOL fShouldShare = (IsDlgButtonChecked(hwndDlg, IDC_SHARE_PRINTER) == BST_CHECKED);
                    fxocPrnt_SetFaxPrinterShared(fShouldShare);
                    break;
            }
            break;
    }
    return FALSE;
}   // prv_dlgOcmWizardPage



LPCTSTR lplpszFaxFolder[][2] = {
    {FAX_QUEUE_DIR,            SD_FAX_FOLDERS},
    {FAX_INBOX_DIR,            SD_FAX_FOLDERS},
    {FAX_SENTITEMS_DIR,        SD_FAX_FOLDERS},
    {FAX_ACTIVITYLOG_DIR,      SD_FAX_FOLDERS},
    {FAX_COMMONCOVERPAGES_DIR, SD_COMMON_COVERPAGES}};

/*++
Routine description:
    Sets security info on Fax directories under "Documents and settings" tree

Arguments:
    lpszCommonAppData [in]  - name of Common App directory, for example
                              C:\Documents and Settings\All Users\Application Data
Return Value: Win32 Error code

Notes:
    This function is called after converting the file system from FAT to NTFS
    (during the call to SecureUserProfiles()).
    The security of folders under system32 are handled by convert.exe itself.

Written by:  jobarner, 08/2002    
--*/

HRESULT SecureFaxServiceDirectories(LPCTSTR lpszCommonAppData)
{
    DWORD dwRet;
    DWORD ec = ERROR_SUCCESS;
    BOOL  bFaxInstalled = FALSE;

    TCHAR szDir[MAX_PATH] = {'\0'};
    int iResult;
    int i;

    DBG_ENTER(  _T("SecureFaxServiceDirectories"), ec);

    ec = IsFaxInstalled (&bFaxInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("SetDirSecurity() failed, ec = %ld."), ec);
        return ec;
    }
    if (!bFaxInstalled)
    {
        VERBOSE(DBG_MSG, _T("Fax is not installed, quitting"));
        return ERROR_SUCCESS;
    }

    for (i=0; i<ARR_SIZE(lplpszFaxFolder); i++)
    {
        iResult = _sntprintf(szDir, 
                    ARR_SIZE(szDir) -1,
                    TEXT("%s\\%s"),
                    lpszCommonAppData,
                    lplpszFaxFolder[i][0]);
        if (iResult<0)
        {
            VERBOSE(DBG_WARNING, _T("SetDirSecurity() failed, ec = %ld."), dwRet);
            ec = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            dwRet = SetDirSecurity(szDir, lplpszFaxFolder[i][1]);
            if (dwRet!=ERROR_SUCCESS)
            {
                VERBOSE(DBG_WARNING, _T("SetDirSecurity() failed, ec = %ld."), dwRet);
                ec = dwRet;
            }
        }
    }

    return ec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocdbg.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocDbg.h
//
// Abstract:        Header file used by Debug source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCDBG_H_
#define _FXOCDBG_H_

///////////////////////////////
// fxocDbg_Init
//
// Initialize debug subsystem,
// call at start of app
//
void fxocDbg_Init(HINF hInf = NULL);

///////////////////////////////
// fxocDbg_Term
//
// Terminate debug subsystem
// Call on app shutdown.
//
void fxocDbg_Term(void);

///////////////////////////////
// fxocDbg_GetOcFunction
//
// Returns pointer to string
// equivalent of uiFunction
//
const TCHAR* fxocDbg_GetOcFunction(UINT uiFunction);

#endif  // _FXOCDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocdbg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocDbg.cpp
//
// Abstract:        This provides the debug routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"
#pragma hdrstop

#define prv_SECTION_FAXOCMDEBUG     _T("FaxOcmDebug")
#define prv_KEY_DEBUGLEVEL          _T("DebugLevel")
#define prv_KEY_DEBUGFORMAT         _T("DebugFormat")

#define prv_DEBUG_FILE_NAME         _T("%windir%\\FaxSetup.log")

///////////////////////////////
// prv_OC_Function
//
// Type containing text description
// of stage of OC Manager
// setup.
//
typedef struct prv_OC_Function
{
    UINT        uiFunction;
    TCHAR       *pszFunctionDesc;
} prv_OC_Function;

///////////////////////////////
// prv_OC_FunctionTable
//
// This table contains the various
// stages of the OC Manager setup,
// and their text equivalent.  This
// allows us to output to debug the
// stage of setup, rather than the 
// numerical equivalent.
// 
//
static prv_OC_Function prv_OC_FunctionTable[] = 
{
    {OC_PREINITIALIZE,              _T("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,             _T("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,               _T("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,                _T("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,              _T("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE,     _T("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,            _T("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,             _T("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,    _T("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,           _T("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,      _T("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                    _T("OC_CLEANUP")},
    {OC_QUERY_STATE,                _T("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,                 _T("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,      _T("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,            _T("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,             _T("OC_WIZARD_CREATED")},
    {OC_FILE_BUSY,                  _T("OC_FILE_BUSY")},
    {OC_EXTRA_ROUTINES,             _T("OC_EXTRA_ROUTINES")}
};
#define NUM_OC_FUNCTIONS (sizeof(prv_OC_FunctionTable) / sizeof(prv_OC_FunctionTable[0]))

////////////////////////////////
// fxocDbg_InitDebug
//
// Initialize the FaxOcm
// debug subsystem.
// 
// We can be turned on either
// via the [FaxOcmDebug] section
// in the faxsetup.inf, or via the 
// the "DebugLevelEx" and "DebugFormatEx"
// under HKLM\Software\Microsoft\Fax
// If both are specified, the registry wins.
//
// In faxocm.inf, we look for
// [FaxOcmDebug]
// ============================
// [DebugLevel] can be one of the following:
//	0 - no debug output
//	1 - see errors only
//	2 - see errors & warnings
//	3 - see all the debug output 
//
// [DebugFormat] can be one of the following:
//	0 - print to std output
//	1 - print to file ("FaxSetup.log" in %windir%\system32 directory)
//	2 - print to both
// ============================
//
// Params:
//      - hFaxSetupInfHandle - handle to faxsetup.inf 
//        if applicable.
// Returns:
//      - void.
//
void fxocDbg_Init(HINF hFaxSetupInfHandle)
{
    BOOL bSuccess = FALSE;
    INFCONTEXT Context;
    INT iDebugLevel = 0;
    INT iDebugFormat = 0;

    DBG_ENTER(_T("fxocDbg_Init"),bSuccess);
    memset(&Context, 0, sizeof(Context));

    if (hFaxSetupInfHandle)
    {
        // initialize via the INF file.

        // We are looking for:
        // [FaxOcmDebug]
        // DebugLevel = x (0 -> no debug, up to and including 3->full debug)

        // find the section in the INF file and the DebugLevel key.
        bSuccess = ::SetupFindFirstLine(hFaxSetupInfHandle, 
                                        prv_SECTION_FAXOCMDEBUG, 
                                        prv_KEY_DEBUGLEVEL,
                                        &Context);

        if (bSuccess)
        {
            // we found the DebugLevel key, so get its value.
            bSuccess = ::SetupGetIntField(&Context, 1, &iDebugLevel);
            if (bSuccess)
            {
                iDebugLevel = max(iDebugLevel,0);
                iDebugLevel = min(iDebugLevel,3);
                if (!IS_DEBUG_SESSION_FROM_REG)
                {
                    switch (iDebugLevel)
                    {
                    case 0: SET_DEBUG_MASK(ASSERTION_FAILED);
                            break;
                    case 1: SET_DEBUG_MASK(DBG_ERRORS_ONLY);
                            break;
                    case 2: SET_DEBUG_MASK(DBG_ERRORS_WARNINGS);
                            break;
                    case 3: SET_DEBUG_MASK(DBG_ALL);
                            break;
                    }
                }
            }
        }

        memset(&Context, 0, sizeof(Context));
        // find the section in the INF file and the DebugFormat key.
        bSuccess = ::SetupFindFirstLine(hFaxSetupInfHandle, 
                                        prv_SECTION_FAXOCMDEBUG, 
                                        prv_KEY_DEBUGFORMAT,
                                        &Context);

        if (bSuccess)
        {
            // we found the DebugLevel key, so get its value.
            bSuccess = ::SetupGetIntField(&Context, 1, &iDebugFormat);
            if (bSuccess)
            {
                iDebugLevel = max(iDebugFormat,0);
                iDebugLevel = min(iDebugFormat,2);
                if (!IS_DEBUG_SESSION_FROM_REG)
                {
                    switch (iDebugFormat)
                    {
                    case 0: SET_FORMAT_MASK(DBG_PRNT_ALL_TO_STD);
                            break;
                    case 1: SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
                            OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
                            SET_DEBUG_FLUSH(FALSE);
                            break;
                    case 2: SET_FORMAT_MASK(DBG_PRNT_ALL);
                            OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
                            SET_DEBUG_FLUSH(FALSE);
                            break;
                    }
                }
            }
        }
    }
}

////////////////////////////////
// fxocDbg_TermDebug
//
// Terminate the debug subsystem
// 
// Params:
//      - void.
// Returns:
//      - void.
//
void fxocDbg_Term(void)
{
    DBG_ENTER(_T("fxocDbg_Term"));
    CLOSE_DEBUG_LOG_FILE;
}

///////////////////////////////
// fxocDbg_GetOcFunction
//
// This looks up the uiFunction
// in the prv_OC_Function table
// defined above and returns a
// pointer to the text equivalent.
// 
// Params:
//      - uiFunction - function OC Manager wants us to perform.
// Returns:
//      - text equivalent of uiFunction.
// 
//
const TCHAR* fxocDbg_GetOcFunction(UINT uiFunction)
{
    TCHAR   *pszString = _T("");

    // NOTE:  This function assumes that the table above contains a 
    //        numerically sorted array with the numerical value of 
    //        "uiFunction" equal to its index position in the 
    //        prv_OC_FunctionTable array.  We assume this for performance
    //        purposes.

    if (uiFunction < NUM_OC_FUNCTIONS)
    {
        pszString = prv_OC_FunctionTable[uiFunction].pszFunctionDesc;
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxoclink.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocLink.h
//
// Abstract:        Header file used to create Program Groups/Shortcuts
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCLINK_H_
#define _FXOCLINK_H_


DWORD fxocLink_Init(void);
DWORD fxocLink_Term(void);
DWORD fxocLink_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocLink_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

#endif  // _FXOCLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxconst.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxconst.h
//
// Abstract:        Contains extern'd constants for use by faxocm
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXCONST_H_
#define _FXCONST_H_

// used for determining the fax service's name
extern LPCTSTR INF_KEYWORD_ADDSERVICE;
extern LPCTSTR INF_KEYWORD_DELSERVICE;

// used for creating the Inbox and SentItems archive directories
extern LPCTSTR INF_KEYWORD_CREATEDIR;
extern LPCTSTR INF_KEYWORD_DELDIR;

extern LPCTSTR INF_KEYWORD_CREATESHARE;
extern LPCTSTR INF_KEYWORD_DELSHARE;

extern LPCTSTR INF_KEYWORD_PATH;
extern LPCTSTR INF_KEYWORD_NAME;
extern LPCTSTR INF_KEYWORD_COMMENT;
extern LPCTSTR INF_KEYWORD_PLATFORM;
extern LPCTSTR INF_KEYWORD_ATTRIBUTES;
extern LPCTSTR INF_KEYWORD_SECURITY;

extern LPCTSTR INF_KEYWORD_PROFILEITEMS_PLATFORM;
extern LPCTSTR INF_KEYWORD_REGISTER_DLL_PLATFORM;
extern LPCTSTR INF_KEYWORD_UNREGISTER_DLL_PLATFORM;
extern LPCTSTR INF_KEYWORD_ADDREG_PLATFORM;
extern LPCTSTR INF_KEYWORD_COPYFILES_PLATFORM;

// once the type of install has been determined, we search for 
// the appropriate section below to begin the type of install we need.
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UNINSTALL;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_CLEAN;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN9X;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN2K;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMXPDOTNET;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT_UNINSTALL;


#endif  // _FXCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocfile.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocFile.h
//
// Abstract:        Header file used by Fax File source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCFILE_H_
#define _FXOCFILE_H_

struct FAX_SHARE_Description
{
    TCHAR                   szPath[MAX_PATH];       // <path to folder on which share is created>
    TCHAR                   szName[MAX_PATH];       // <name of share as it appears to the user>
    TCHAR                   szComment[MAX_PATH];    // <share comment as it appears to the user>
    INT                     iPlatform;              // <platform on which share should be created>
    PSECURITY_DESCRIPTOR    pSD;                    // <Security Descriptor to apply to share>

    FAX_SHARE_Description();
    ~FAX_SHARE_Description();
};

struct FAX_FOLDER_Description
{
    TCHAR                   szPath[MAX_PATH];       // <path to folder to create>
    INT                     iPlatform;              // <platform on which share should be created>
    PSECURITY_DESCRIPTOR    pSD;                    // <Security Descriptor to apply to share>
    INT                     iAttributes;            // <attributes to apply to the folder - optional>

    FAX_FOLDER_Description();
    ~FAX_FOLDER_Description();
};


DWORD fxocFile_Init(void);
DWORD fxocFile_Term(void);

DWORD fxocFile_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocFile_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

DWORD fxocFile_CalcDiskSpace(const TCHAR  *pszSubcomponentId,
                             BOOL         bIsBeingAdded,
                             HDSKSPC      DiskSpace);

DWORD fxocFile_ProcessDirectories(const TCHAR  *pszSection,
                                  LPCTSTR pszINFKeyword);

DWORD fxocFile_ProcessShares(const TCHAR  *pszSection);

#endif  // _FAXOCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocfile.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocFile.cpp
//
// Abstract:        This provides the file/directory routines used in the 
//                  FaxOCM code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

#include <aclapi.h>
#define MAX_NUM_CHARS_INF_VALUE     255

//////////////////////// Static Function Prototypes //////////////////////////

static BOOL prv_ProcessDirectories(const TCHAR *pszSection,const TCHAR *pszDirAction);
static BOOL prv_ProcessShares(const TCHAR *pszSection,const TCHAR *pszShareAction);
static BOOL prv_SetFileSecurity(const FAX_FOLDER_Description& ffdFolder);

static DWORD prv_DoSetup(const TCHAR *pszSection,
                         BOOL        bInstall,
                         const TCHAR *pszFnName,
                         HINF        hInf,
                         const TCHAR *pszSourceRootPath,
                         HSPFILEQ     hQueue,
                         DWORD       dwFlags);



FAX_SHARE_Description::FAX_SHARE_Description() 
:   iPlatform(PRODUCT_SKU_UNKNOWN),
    pSD(NULL)
{
}

FAX_SHARE_Description::~FAX_SHARE_Description()
{
    if (pSD)
    {
        LocalFree(pSD);
    }
}

FAX_FOLDER_Description::FAX_FOLDER_Description() 
:   iPlatform(PRODUCT_SKU_UNKNOWN),
    pSD(NULL),
    iAttributes(FILE_ATTRIBUTE_NORMAL)
{
}

FAX_FOLDER_Description::~FAX_FOLDER_Description()
{
    if (pSD)
    {
        LocalFree(pSD);
    }
}


///////////////////////////////
// fxocFile_Init
//
// Initialize this File queuing
// subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocFile_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init File Module"), dwRes);

    return dwRes;
}

///////////////////////////////
// fxocFile_Term
//
// Terminate this file queuing subsystem.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocFile_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term File Module"), dwRes);

    return dwRes;
}


///////////////////////////////
// fxocFile_Install
//
// Installs files listed in
// the INF setup file into their
// specified location.
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection - install section in INF file (e.g. Fax.CleanInstall)
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocFile_Install(const TCHAR  *pszSubcomponentId,
                       const TCHAR  *pszInstallSection)
                       
{
    HINF        hInf     = NULL;
    HSPFILEQ    hQueue   = NULL;
    DWORD       dwReturn = NO_ERROR;
    BOOL        bSuccess = FALSE;

    DBG_ENTER(  _T("fxocFile_Install"), 
                dwReturn,   
                _T("%s - %s"), 
                pszSubcomponentId, 
                pszInstallSection);

    if (pszInstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // get the INF handle for our component inf file
    hInf = faxocm_GetComponentInf();

    // get the file queue handle 
    hQueue = faxocm_GetComponentFileQueue();

    // unregister DLLs first, before a file might be deleted by the file copy below.
    if (::SetupInstallFromInfSection(NULL,hInf,pszInstallSection,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL))
    {
        VERBOSE(DBG_MSG,
                _T("Successfully processed SPINST_UNREGSVR from INF file, section '%s'"),
                pszInstallSection);
    }
    else
    {
        dwReturn = GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to process SPINST_UNREGSVR, section '%s', dwReturn = 0x%lx"),
                pszInstallSection, 
                dwReturn);
    }
    // unregister platform specific DLLs first - this can happen during an upgrade from XP Beta -> XP RC1 and XP RTM
    dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_UNREGISTER_DLL_PLATFORM,SPINST_UNREGSVR,NULL);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully Unregistered Fax DLLs - platform dependent")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to Unregister Fax DLLs - platform dependent")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    dwReturn = prv_DoSetup(pszInstallSection,
                           TRUE,
                           _T("fxocFile_Install"),
                           hInf,
                           NULL,
                           hQueue,
                           SP_COPY_NEWER);

    // now attemp to install platform specific files
    dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_COPYFILES_PLATFORM,SP_COPY_NEWER,hQueue);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully Queued Files - platform dependent")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to Queued Files  - platform dependent")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocFile_Uninstall
//
// Uninstalls files listed in
// the INF setup file.
//
// Params:
//      - pszSubcomponentId
//      - pszUninstallSection - section in INF (e.g. Fax.Uninstall)
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocFile_Uninstall(const TCHAR    *pszSubcomponentId,
                         const TCHAR    *pszUninstallSection)
{
    HINF        hInf     = NULL;
    HSPFILEQ    hQueue   = NULL;
    DWORD       dwReturn = NO_ERROR;
    BOOL        bSuccess = FALSE;

    DBG_ENTER(  _T("fxocFile_Install"), 
                dwReturn,   
                _T("%s - %s"), 
                pszSubcomponentId, 
                pszUninstallSection);

    if (pszUninstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // get the INF handle for our component inf file
    hInf = faxocm_GetComponentInf();

    // get the file queue handle 
    hQueue = faxocm_GetComponentFileQueue();

    // unregister all our DLLs first
    if (::SetupInstallFromInfSection(NULL,hInf,pszUninstallSection,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL))
    {
        VERBOSE(DBG_MSG,
                _T("Successfully processed SPINST_UNREGSVR from INF file, section '%s'"),
                pszUninstallSection);
    }
    else
    {
        dwReturn = GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to process SPINST_UNREGSVR, section '%s', dwReturn = 0x%lx"),
                pszUninstallSection, 
                dwReturn);
    }

    // Now delete the files.
    // this function will uninstall if the section retrieved above
    // contains the 'DelFiles' keyword.
    dwReturn = prv_DoSetup(pszUninstallSection,
                           FALSE,
                           _T("fxocFile_Uninstall"),
                           hInf,
                           NULL,
                           hQueue,
                           0);
    return dwReturn;
}

///////////////////////////////
// prv_DoSetup
//
// Generic routine to call the appropriate
// Setup API fn, depending on if we are installing
// or uninstalling.
//
// Params:
//      - pszSection - section we are processing
//      - bInstall   - TRUE if installing, FALSE if uninstalling
//      - pszFnName  - name of calling fn (for debug)
//      - hInf       - handle to faxsetup.inf.
//      - pszSourceRootPath - path we are installing from.
//      - hQueue     - handle to file queue given to us by OC Manager
//      - dwFlags    - flags to pass to setup API.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_DoSetup(const TCHAR  *pszSection,
                         BOOL         bInstall,
                         const TCHAR  *pszFnName,
                         HINF         hInf,
                         const TCHAR  *pszSourceRootPath,
                         HSPFILEQ     hQueue,
                         DWORD        dwFlags)
{
    DWORD dwReturn = NO_ERROR;
    BOOL  bSuccess = FALSE;

    DBG_ENTER(  _T("prv_DoSetup"), 
                dwReturn,   
                _T("%s - %s - %s"), 
                pszSection, 
                pszFnName,
                pszSourceRootPath);
    // this function will search the INF for the 'CopyFiles' keyword
    // and copy all files referenced by it.
    bSuccess = ::SetupInstallFilesFromInfSection(hInf,
                                                 NULL,
                                                 hQueue,
                                                 pszSection,
                                                 pszSourceRootPath,
                                                 dwFlags);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("%s, Successfully queued files ")
                _T("from Section: '%s'"), 
                pszFnName, 
                pszSection);
    }
    else
    {
        dwReturn = GetLastError();

        VERBOSE(DBG_MSG,
                _T("%s, Failed to queue files ")
                _T("from Section: '%s', Error Code = 0x%lx"), 
                pszFnName, 
                pszSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocFile_CalcDiskSpace
//
// Calculate the disk space requirements
// of fax.  This is done by the Setup APIs
// based on the files we are copying and
// deleting as specified in faxsetup.inf.
//
// Params:
//      - pszSubcomponentId
//      - bIsBeingAdded - are we installing or uninstalling.
//      - hDiskSpace - handle to diskspace abstraction.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise                             
//
DWORD fxocFile_CalcDiskSpace(const TCHAR  *pszSubcomponentId,
                             BOOL         bIsBeingAdded,
                             HDSKSPC      hDiskSpace)
{
    HINF  hInf     = faxocm_GetComponentInf();
    DWORD dwReturn = NO_ERROR;
    BOOL  bSuccess = FALSE;
    TCHAR szSectionToProcess[255 + 1];

    DBG_ENTER(  _T("fxocFile_CalcDiskSpace"), 
                dwReturn,   
                _T("%s"), 
                pszSubcomponentId);

    if ((hInf              == NULL) ||
        (pszSubcomponentId == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // since disk space calc needs to be consistent, select the clean install
    // section for the disk space calculation section.  This is a good
    // estimate.
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocUtil_GetKeywordValue(pszSubcomponentId,
                                   INF_KEYWORD_INSTALLTYPE_CLEAN,
                                   szSectionToProcess,
                                   sizeof(szSectionToProcess) / sizeof(TCHAR));
    }


    if (dwReturn == NO_ERROR)
    {
        if (bIsBeingAdded)
        {
            bSuccess = ::SetupAddInstallSectionToDiskSpaceList(
                                                    hDiskSpace, 
                                                    hInf,
                                                    NULL, 
                                                    szSectionToProcess,
                                                    0,
                                                    0);
        }
        else
        {
            bSuccess = ::SetupRemoveInstallSectionFromDiskSpaceList(
                                                    hDiskSpace,
                                                    hInf,
                                                    NULL,
                                                    szSectionToProcess,
                                                    0,
                                                    0);
        }

        if (!bSuccess)
        {
            dwReturn = GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("fxocFile_CalcDiskSpace, failed to calculate ")
                    _T("disk space, error code = 0x%lx"), dwReturn);
        }
        else
        {
            VERBOSE(DBG_MSG,
                    _T("fxocFile_CalcDiskSpace, ")
                    _T("SubComponentID: '%s', Section: '%s', ")
                    _T("bIsBeingAdded: '%lu', ")
                    _T("rc=0x%lx"), pszSubcomponentId, szSectionToProcess,
                    bIsBeingAdded, 
                    dwReturn);
        }
    }

    return dwReturn;
}

///////////////////////////////
// fxocFile_ProcessDirectories
//
// Create or Delete the directories
// in the given section, 
//
// pszINFKeyword - INF_KEYWORD_DELDIR       to delete the directories
//                 INF_KEYWORD_CREATEDIR    to create the directories
//
DWORD fxocFile_ProcessDirectories(const TCHAR  *pszSection, LPCTSTR pszINFKeyword)
{
    DWORD dwReturn                                    = NO_ERROR;

    DBG_ENTER(  _T("fxocFile_ProcessDirectories"), 
                dwReturn,   
                _T("%s"), 
                pszSection);

    // delete or create (according to pszINFKeyword) all the shares specified in the 
    // INF section.
    if (!prv_ProcessDirectories(pszSection,pszINFKeyword))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING,_T("Problems deleting/creating directories.... [%s]"),pszINFKeyword);
    }

    return dwReturn;
}


///////////////////////////////
// fxocFile_ProcessShares
//
// Create and/or Delete shares 
// directories/printers specfiied
// in the given section.
// 
// Params:
//      - pszSection - section containing the 'CreateShare'/'DelShare'
//        keyword
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocFile_ProcessShares(const TCHAR  *pszSection)
{
    DWORD dwReturn                                    = NO_ERROR;

    DBG_ENTER(  _T("fxocFile_ProcessShares"), 
                dwReturn,   
                _T("%s"), 
                pszSection);

    // first, delete all the shares specified in the 
    // INF section.
    if (!prv_ProcessShares(pszSection,INF_KEYWORD_DELSHARE))
    {
        VERBOSE(DBG_WARNING,_T("Problems deleting shares...."));
    }


    // next, create all the shares specified in the 
    // INF section.
    if (!prv_ProcessShares(pszSection,INF_KEYWORD_CREATESHARE))
    {
        VERBOSE(DBG_WARNING,_T("Problems creating shares...."));
    }

    return dwReturn;
}


static BOOL prv_FillFolderDescriptionFromInf(const TCHAR *pszFolderSection,FAX_FOLDER_Description& fsdFolder)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    TCHAR       szStringSd[MAX_PATH*3]      = {0};

    DBG_ENTER(  _T("prv_FillFolderDescriptionFromInf"), 
                bSuccess,   
                _T("%s"), 
                pszFolderSection);

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));

    // get the Path line in the section.
    if (!::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_PATH,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdFolder.szPath,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }

    // get the Platform line in the section.
    if (!::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_PLATFORM,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetIntField(&Context, 1, &fsdFolder.iPlatform);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }

    // get the attributes line if it exists.
    if (::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_ATTRIBUTES,&Context))
    {
        bSuccess = ::SetupGetIntField(&Context, 1, &fsdFolder.iAttributes);
        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
            return FALSE;
        }
    }
    else
    {
        VERBOSE(    DBG_MSG,
                    _T("SetupFindFirstLine failed (%s) (ec=%d), ")
                    _T("this is an optional field assuming non-existant"),
                    INF_KEYWORD_ATTRIBUTES,
                    GetLastError());
    }
    // get the Security line in the section.
    if (!::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_SECURITY,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,szStringSd,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(szStringSd,SDDL_REVISION_1,&fsdFolder.pSD,NULL))
    {
        VERBOSE(SETUP_ERR,_T("ConvertStringSecurityDescriptorToSecurityDescriptor failed (%s) (ec=%d)"),szStringSd,GetLastError());
        return FALSE;
    }

    return TRUE; 
}

static BOOL prv_FillShareDescriptionFromInf(const TCHAR *pszShareSection,FAX_SHARE_Description& fsdShare)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    TCHAR       szStringSd[MAX_PATH*3]      = {0};

    DBG_ENTER(  _T("prv_FillShareDescriptionFromInf"), 
                bSuccess,   
                _T("%s"), 
                pszShareSection);

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));

    // get the Path line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_PATH,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdShare.szPath,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }

    // get the Name line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_NAME,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_NAME,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdShare.szName,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_NAME,GetLastError());
        return FALSE;
    }

    // get the Comment line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_COMMENT,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_COMMENT,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdShare.szComment,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_COMMENT,GetLastError());
        return FALSE;
    }

    // get the Platform line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_PLATFORM,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetIntField(&Context, 1, &fsdShare.iPlatform);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }

    // get the Security line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_SECURITY,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,szStringSd,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(szStringSd,SDDL_REVISION_1,&fsdShare.pSD,NULL))
    {
        VERBOSE(SETUP_ERR,_T("ConvertStringSecurityDescriptorToSecurityDescriptor failed (%s) (ec=%d)"),szStringSd,GetLastError());
        return FALSE;
    }

    return TRUE; 
}

///////////////////////////////
// prv_ProcessDirectories
//
// Enumerates through the specified
// INF file in the specified section
// and gets the value of the next
// keyword 'CreateDir', or 'DelDir'
//
// This function looks for the following lines
// in the INF section
//
// CreateDir    = [1st dir section],[2nd dir section],...
// or
// DelDir       = [1st dir section],[2nd dir section],...
//
// [dir section]      - is built in the following format:
//                          Path = <path to folder to create>
//                          Platform = <one of the PRODUCT_SKU_* below>
//                          Security = <DACL in string format>
// 
// Params:
//      - pszSection - section in the file to iterate through.
//      - pszShareAction - one of INF_KEYWORD_CREATEDIR, INF_KEYWORD_DELDIR
//
// Returns:
//      - TRUE if folders were processed successfully
//      - FALSE otherwise
//
static BOOL prv_ProcessDirectories(const TCHAR *pszSection,const TCHAR *pszDirAction)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    DWORD       dwFieldCount                = 0;
    DWORD       dwIndex                     = 0;
    DWORD       dwNumChars                  = MAX_PATH;
    DWORD       dwNumRequiredChars          = 0;
    TCHAR       pszFolderSection[MAX_PATH]  = {0};

    DBG_ENTER(  _T("prv_ProcessDirectories"), 
                bSuccess,   
                _T("%s - %s"), 
                pszSection,
                pszDirAction);

    if  ((pszDirAction != INF_KEYWORD_CREATEDIR) && 
         (pszDirAction != INF_KEYWORD_DELDIR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pszSection == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));
    
    // get the first CreateDir or DelDir in the section.
    bSuccess = ::SetupFindFirstLine(hInf,
                                    pszSection, 
                                    pszDirAction,
                                    &Context);

    if (!bSuccess)
    {
        VERBOSE(DBG_WARNING,
                _T("Did not find '%s' keyword in ")
                _T("section '%s'.  No action will be taken."),
                pszDirAction, 
                pszSection);

        return FALSE;
    }
    
    // Found the CreateDir or DelDir
    // now let's see how many dirs to create/delete
    dwFieldCount = SetupGetFieldCount(&Context);
    if (dwFieldCount==0)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetFieldCount failed (ec=%d)"),GetLastError());
        return FALSE;
    }

    for (dwIndex=0; dwIndex<dwFieldCount; dwIndex++)
    {
        FAX_FOLDER_Description ffdFolder;
        // iterate through fields, get the share section and process it.
        bSuccess = ::SetupGetStringField(&Context, dwIndex+1, pszFolderSection, dwNumChars, &dwNumRequiredChars);
        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),GetLastError());
            return FALSE;
        }
        // we have the share name in pszShareSection, fill out the FAX_SHARE_Description structure
        if (!prv_FillFolderDescriptionFromInf(pszFolderSection,ffdFolder))
        {
            VERBOSE(SETUP_ERR,_T("prv_FillFolderDescriptionFromInf failed (ec=%d)"),GetLastError());
            return FALSE;
        }

        // now we have all the data
        // check if we should act on this platform...
        if (!(ffdFolder.iPlatform & GetProductSKU()))
        {
            VERBOSE(DBG_MSG,_T("Folder should not be processed on this Platform, skipping..."));
            continue;
        }

        if (pszDirAction == INF_KEYWORD_CREATEDIR)
        {
            // create the folder
            bSuccess = MakeDirectory(ffdFolder.szPath);
            if (!bSuccess)
            {
                DWORD dwReturn = ::GetLastError();
                if (dwReturn != ERROR_ALREADY_EXISTS)
                {
                    VERBOSE(SETUP_ERR,_T("MakeDirectory failed (ec=%d)"),dwReturn);
                }
            }
            // set the folder's security and the files in it
            if (!prv_SetFileSecurity(ffdFolder))
            {
                VERBOSE(SETUP_ERR, _T("prv_SetFileSecurity"), GetLastError());
            }
            
            // set the folder's attributes
            if (ffdFolder.iAttributes!=FILE_ATTRIBUTE_NORMAL)
            {
                // no sense in setting normal attributes, since this is the default
                // the attributes member is initialized to FILE_ATTRIBUTE_NORMAL so
                // if we failed to read it from the INF it's still the same
                // and if someone specifies it in the INF it'll be set by default.
                DWORD dwFileAttributes = GetFileAttributes(ffdFolder.szPath);
                if (dwFileAttributes!=-1)
                {
                    dwFileAttributes |= ffdFolder.iAttributes;

                    if (!SetFileAttributes(ffdFolder.szPath,dwFileAttributes))
                    {
                        VERBOSE(SETUP_ERR, TEXT("SetFileAttributes"), GetLastError());
                    }
                }
                else
                {
                    VERBOSE(SETUP_ERR, TEXT("GetFileAttributes"), GetLastError());
                }
            }
        }
        else
        {
            // delete the directory
            DeleteDirectory(ffdFolder.szPath);
        }
    }

    return TRUE;
}

///////////////////////////////
// prv_ProcessShares
//
// Enumerates through the specified
// INF file in the specified section
// and gets the value of the next
// keyword 'CreateShare', or 'DelShare'
//
// This function looks for the following lines
// in the INF section
//
// CreateShare  = [1st share section],[2nd share section],...
// or
// DelShare     = [1st share section],[2nd share section],...
//
// [share section] - is built in the following format:
//                      Path = <path to folder on which share is created>
//                      Name = <name of share as it appears to the user>
//                      Comment = <share comment as it appears to the user>
//                      Platform = <one of the below platform specifiers>
//                      Security = <DACL in string format>
// 
// Params:
//      - pszSection - section in the file to iterate through.
//      - pszShareAction - one of INF_KEYWORD_CREATESHARE, INF_KEYWORD_DELSHARE
//
// Returns:
//      - TRUE if shares were processed successfully
//      - FALSE otherwise
//
static BOOL prv_ProcessShares(const TCHAR *pszSection,const TCHAR *pszShareAction)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    DWORD       dwFieldCount                = 0;
    DWORD       dwIndex                     = 0;
    DWORD       dwNumChars                  = MAX_PATH;
    DWORD       dwNumRequiredChars          = 0;
    TCHAR       pszShareSection[MAX_PATH]   = {0};

    DBG_ENTER(  _T("prv_ProcessShares"), 
                bSuccess,   
                _T("%s - %s"), 
                pszSection,
                pszShareAction);

    if  ((pszShareAction != INF_KEYWORD_CREATESHARE) && 
         (pszShareAction != INF_KEYWORD_DELSHARE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pszSection == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));
    
    // get the first CreateShare or DelShare in the section.
    bSuccess = ::SetupFindFirstLine(hInf,
                                    pszSection, 
                                    pszShareAction,
                                    &Context);

    if (!bSuccess)
    {
        VERBOSE(DBG_WARNING,
                _T("Did not find '%s' keyword in ")
                _T("section '%s'.  No action will be taken."),
                pszShareAction, 
                pszSection);

        return FALSE;
    }
    
    // Found the CreateShare or DelShare.
    // now let's see how many shares to create/delete
    dwFieldCount = SetupGetFieldCount(&Context);
    if (dwFieldCount==0)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetFieldCount failed (ec=%d)"),GetLastError());
        return FALSE;
    }

    for (dwIndex=0; dwIndex<dwFieldCount; dwIndex++)
    {
        FAX_SHARE_Description fsdShare;
        // iterate through fields, get the share section and process it.
        bSuccess = ::SetupGetStringField(&Context, dwIndex+1, pszShareSection, dwNumChars, &dwNumRequiredChars);
        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),GetLastError());
            return FALSE;
        }
        // we have the share name in pszShareSection, fill out the FAX_SHARE_Description structure
        if (!prv_FillShareDescriptionFromInf(pszShareSection,fsdShare))
        {
            VERBOSE(SETUP_ERR,_T("prv_FillShareDescriptionFromInf failed (ec=%d)"),GetLastError());
            return FALSE;
        }

        // now we have all the data
        // check if we should act on this platform...
        if (!(fsdShare.iPlatform & GetProductSKU()))
        {
            VERBOSE(DBG_MSG,_T("Share should not be processed on this Platform, skipping..."));
            continue;
        }

        if (pszShareAction == INF_KEYWORD_CREATESHARE)
        {
            // create the share...
            bSuccess = fxocUtil_CreateNetworkShare(&fsdShare);
            if (!bSuccess)
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to create share name '%s', path '%s', ")
                        _T("comment '%s', rc=0x%lx"), 
                        fsdShare.szName, 
                        fsdShare.szPath, 
                        fsdShare.szComment,
                        GetLastError());
            }
        }
        else
        {
            // delete the share..
            bSuccess = fxocUtil_DeleteNetworkShare(fsdShare.szName);
            if (!bSuccess)
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to delete share name '%s', ")
                        _T("rc=0x%lx"), 
                        fsdShare.szPath, 
                        GetLastError());
            }
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  prv_SetFileSecurity
//
//  Purpose:        
//					Secure a folder and set the ACL on all the files contained in it
//                  
//  Params:
//                  FAX_FOLDER_Description ffdFolder - folder to secure
//
//  Return Value:
//                  TRUE - in case of success
//                  FALSE - otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 22-May-2002
///////////////////////////////////////////////////////////////////////////////////////
static BOOL prv_SetFileSecurity(const FAX_FOLDER_Description& ffFolder)
{
	BOOL	bRet			= TRUE;
    BOOL	bDaclPresent	= TRUE;
	BOOL	bDaclDefaulted	= TRUE;
	PACL	pDacl			= NULL;
	DWORD	dwRet			= ERROR_SUCCESS;
	HANDLE  hFolder			= INVALID_HANDLE_VALUE;
	DBG_ENTER(_T("prv_SetFileSecurity"),bRet);

	hFolder = CreateFile(	ffFolder.szPath,
							GENERIC_WRITE | WRITE_DAC,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_BACKUP_SEMANTICS,
							NULL);
	if (hFolder==INVALID_HANDLE_VALUE)
	{
        VERBOSE(SETUP_ERR,_T("CreateFile failed (ec=%d)"),GetLastError());
        bRet = FALSE;
		goto exit;
	}

	bRet = GetSecurityDescriptorDacl(	ffFolder.pSD,
										&bDaclPresent,
										&pDacl,
										&bDaclDefaulted);
	if (!bRet)
	{
        VERBOSE(SETUP_ERR,_T("GetSecurityDescriptorDacl failed (ec=%d)"),GetLastError());
        bRet = FALSE;
		goto exit;
	}

	if (!bDaclPresent)
	{
        VERBOSE(SETUP_ERR,_T("Security Descriptor does not contain a DACL"));
        bRet = FALSE;
		goto exit;
	}
	dwRet = SetSecurityInfo(hFolder,
							SE_FILE_OBJECT,
							DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
							NULL,
							NULL,
							pDacl,
							NULL);
	if (dwRet!=ERROR_SUCCESS)
	{
        VERBOSE(SETUP_ERR,_T("SetSecurityInfo failed (ec=%d)"),GetLastError());
        bRet = FALSE;
		goto exit;
	}

exit:
	if (hFolder)
	{
		CloseHandle(hFolder);
	}
	return bRet;
}
// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxoclink.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocLink.cpp
//
// Abstract:        This code install the program groups and shortcut links
//                  to the fax executables.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created file, cleanup routines
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"
#pragma hdrstop

///////////////////////// Static Function Prototypes ////////////////////////

///////////////////////////////
// fxocLink_Init
//
// Initialize the link subsystem
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Link Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocLink_Term
//
// Terminate the link subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Link Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocLink_Install
//
// Creates the program group and 
// shortcuts as specified in the
// ProfileItem keyword in the given
// install section
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection - section containing link creation/deletion info.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Install(const TCHAR     *pszSubcomponentId,
                       const TCHAR     *pszInstallSection)
{
    DWORD       dwReturn = NO_ERROR;
    BOOL        bNextCreateShortcutFound = TRUE;
    HINF        hInf     = faxocm_GetComponentInf();
 
    DBG_ENTER(  _T("fxocLink_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    if ((hInf              == NULL) ||
        (pszInstallSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // first let's process all the ProfileItems in the section...
    dwReturn = fxocUtil_DoSetup(hInf, 
                                pszInstallSection, 
                                TRUE, 
                                SPINST_PROFILEITEMS,
                                _T("fxocLink_Install"));

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed Fax Shortcuts ")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install Fax Shortcuts ")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    // now let's look for CreateShortcuts directives which are shortcuts with a platform specification
    dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_PROFILEITEMS_PLATFORM,SPINST_PROFILEITEMS,NULL);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed Fax Shortcuts - platform dependent")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install Fax Shortcuts - platform dependent")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocLink_Uninstall
//
// Deletes the program group and 
// shortcuts as specified in the
// ProfileItem keyword in the given
// install section
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection - section containing link creation/deletion info.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Uninstall(const TCHAR     *pszSubcomponentId,
                         const TCHAR     *pszUninstallSection)
{
    DWORD dwReturn = NO_ERROR;
    HINF  hInf     = faxocm_GetComponentInf();

    DBG_ENTER(  _T("fxocLink_Uninstall"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    if ((hInf                == NULL) ||
        (pszUninstallSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwReturn = fxocUtil_DoSetup(hInf, 
                                pszUninstallSection, 
                                FALSE, 
                                SPINST_PROFILEITEMS,
                                _T("fxocLink_Uninstall"));

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully uninstalled Fax Shortcuts ")
                _T("from INF file, section '%s'"), 
                pszUninstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to uninstall Fax Shortcuts ")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszUninstallSection, 
                dwReturn);
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocmapi.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocMapi.h
//
// Abstract:        Header file used by Mapi source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCMAPI_H_
#define _FXOCMAPI_H_

BOOL fxocMapi_Init(void);
DWORD fxocMapi_Term(void);

DWORD fxocMapi_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocMapi_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

#endif  // _FXOCMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocmapi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocMapi.cpp
//
// Abstract:        This file implements wrappers for all mapi apis.
//                  The wrappers are necessary because mapi does not
//                  implement unicode and this code must be non-unicode.
//
// Environment:     WIN32 User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 7-Aug-1996   Wesley Witt (wesw)        Created (used to be mapi.c)
// 23-Mar-2000  Oren Rosenbloom (orenr)   Minimal cleanup, no change in logic
//
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"

#pragma warning (disable : 4200)

#include <mapiwin.h>
#include <mapix.h>
#include <stdio.h>

#pragma warning (default : 4200)


///////////////////////// Static Function Prototypes //////////////////////
static DWORD RemoveTransportProvider(LPSTR lpstrMessageServiceName,LPCTSTR lpctstrProcessName);

#define SYSOCMGR_IMAGE_NAME     _T("sysocmgr.exe")
#define RUNDLL_IMAGE_NAME       _T("rundll32.exe")

///////////////////////////////
// fxocMapi_Init
//
// Initialize the exchange update
// subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
BOOL fxocMapi_Init(void)
{
    BOOL bRslt = TRUE;
    DBG_ENTER(_T("Init MAPI Module"), bRslt);

    return bRslt;
}

///////////////////////////////
// fxocMapi_Term
//
// Terminate the exchange update
// subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
// 
DWORD fxocMapi_Term(void)
{
    BOOL bRslt = TRUE;
    DBG_ENTER(_T("Term MAPI Module"),bRslt);

    return bRslt;
}

/*
HOWTO: Find the Correct Path to MAPISVC.INF Under Outlook 2000 

Q229700


SUMMARY
Outlook exposes a function, FGetComponentPath(), in the Mapistub.dll file that helps us find the path to the Mapisvc.inf file. 
This article contains a code sample demonstrating how to do this.

Prior to Outlook 2000, the Mapisvc.inf file was always installed under the system directory (as returned by the Win32 API GetSystemDirectory()). 

Note that the following code sample is also backward compatible with all prior versions of Outlook. 
It will find the path to the Mapisvc.inf file whether it exists under the system directory or not. 
*/

typedef BOOL (STDAPICALLTYPE FGETCOMPONENTPATH)
    (LPSTR szComponent,
    LPSTR szQualifier,
    LPSTR szDllPath,
    DWORD cchBufferSize,
    BOOL fInstall);
typedef FGETCOMPONENTPATH FAR * LPFGETCOMPONENTPATH;

static CHAR s_szMSIApplicationLCID[]   =    "Microsoft\\Office\\9.0\\Outlook\0LastUILanguage\0";
static CHAR s_szMSIOfficeLCID[]        =    "Microsoft\\Office\\9.0\\Common\\LanguageResources\0UILanguage\0InstallLanguage\0";

/////////////////////////////////////////////////////////////////////////////// 
// Function name    : GetMapiSvcInfPath
// Description      : For Outlook 2000 compliance. This will get the correct path to the
//       :              MAPISVC.INF file.
// Return type      : void 
// Argument         : LPSTR szMAPIDir - Buffer to hold the path to the MAPISVC file.
void GetMapiSvcInfPath(LPTSTR szINIFileName)
{
    // Get the mapisvc.inf filename.  
    // The MAPISVC.INF file can live in the system directory.
    // and/or "\Program Files\Common Files\SYSTEM\Mapi"
    UINT                cchT;
    static const TCHAR  szMapiSvcInf[] = TEXT("\\mapisvc.inf");
    LPFGETCOMPONENTPATH pfnFGetComponentPath;

    DBG_ENTER(_T("GetMapiSvcInfPath"));

    // Char array for private mapisvc.inf.
    CHAR szPrivateMAPIDir[MAX_PATH] = {0};

    HINSTANCE hinstStub = NULL;

    // Get Windows System Directory.
    if(!(cchT = GetSystemDirectory(szINIFileName, MAX_PATH)))
        goto Done; //return MAPI_E_CALL_FAILED;

    // Append Filename to the Path.
    _tcscat(szINIFileName, szMapiSvcInf);

    // Call common code in mapistub.dll.
    hinstStub = LoadLibrary(_T("mapistub.dll"));
    if (!hinstStub)
    {
        VERBOSE (DBG_WARNING,_T("LoadLibrary MAPISTUB.DLL failed (ec: %ld)."),GetLastError());
        // Try stub mapi32.dll if mapistub.dll missing.
        hinstStub = LoadLibrary(_T("mapi32.dll"));
        if (!hinstStub)
        {
            VERBOSE (DBG_WARNING,_T("LoadLibrary MAPI32.DLL failed (ec: %ld)."),GetLastError());
            goto Done;
        }
    }

    if(hinstStub)
    {
        pfnFGetComponentPath = (LPFGETCOMPONENTPATH)GetProcAddress(hinstStub, "FGetComponentPath");

        if (!pfnFGetComponentPath)
        {
            VERBOSE (DBG_WARNING,_T("GetProcAddress FGetComponentPath failed (ec: %ld)."),GetLastError());
            goto Done;
        }

        if ((pfnFGetComponentPath("{FF1D0740-D227-11D1-A4B0-006008AF820E}",
                s_szMSIApplicationLCID, szPrivateMAPIDir, MAX_PATH, TRUE) ||
            pfnFGetComponentPath("{FF1D0740-D227-11D1-A4B0-006008AF820E}",
                s_szMSIOfficeLCID, szPrivateMAPIDir, MAX_PATH, TRUE) ||
            pfnFGetComponentPath("{FF1D0740-D227-11D1-A4B0-006008AF820E}",
                NULL, szPrivateMAPIDir, MAX_PATH, TRUE)) &&
                szPrivateMAPIDir[0] != '\0')
        {
            szPrivateMAPIDir[strlen(szPrivateMAPIDir) - 13] = 0;    // Strip "\msmapi32.dll"
        }
        else
        {
            szPrivateMAPIDir[0] = '\0'; // Terminate String at pos 0.
        }

        // Write private mapisvc.inf in szINIFileName if it exists
        if (*szPrivateMAPIDir)
        {
            CHAR szPathToIni[MAX_PATH];
            strcpy(szPathToIni, szPrivateMAPIDir);
            if (MultiByteToWideChar(CP_ACP,
                                    MB_PRECOMPOSED,
                                    szPathToIni,
                                    -1,
                                    szINIFileName,
                                    MAX_PATH)==0)
            {
                VERBOSE (DBG_WARNING,_T("MultiByteToWideChar failed (ec: %ld)."),GetLastError());
                goto Done;
            }
            _tcscat(szINIFileName, szMapiSvcInf);
        }
    }

Done:
    VERBOSE (DBG_MSG,_T("Path to MAPISVC.INF is %s"),szINIFileName);

    if (hinstStub) 
    {
        FreeLibrary(hinstStub);
    }
}
 
///////////////////////////////
// fxocMapi_Install
//
// Make changes to exchange to
// allow for integration with fax.
// 
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF to install from
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocMapi_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection)
{
    BOOL  bSuccess                      = FALSE;
    DWORD dwReturn                      = NO_ERROR;
    TCHAR szPathToMapiSvcInf[MAX_PATH]  = {0};

    DBG_ENTER(  _T("fxocMapi_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    // we have to find the 'real' MAPISVC.INF somewhere on the system
    GetMapiSvcInfPath(szPathToMapiSvcInf);

    // following section is done to fix the W2K transport provider in MAPISVC.INF
    
    // Under [MSFAX XP] section change PR_SERVICE_DLL_NAME from FAXXP.DLL to FXSXP.DLL
    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_T,
                                    _T("PR_SERVICE_DLL_NAME"),
                                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
                                    szPathToMapiSvcInf))
    {
        VERBOSE (   GENERAL_ERR, 
                    _T("WritePrivateProfileString (%s %s) failed (ec: %ld)."),
                    _T("PR_SERVICE_DLL_NAME"),
                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,                    
                    GetLastError());
    }
    // Under [MSFAX XP] section change PR_SERVICE_SUPPORT_FILES from FAXXP.DLL to FXSXP.DLL
    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_T,
                                    _T("PR_SERVICE_SUPPORT_FILES"),
                                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
                                    szPathToMapiSvcInf))
    {
        VERBOSE (   GENERAL_ERR, 
                    _T("WritePrivateProfileString (%s %s) failed (ec: %ld)."),
                    _T("PR_SERVICE_SUPPORT_FILES"),
                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,                    
                    GetLastError());
    }
    // Under [MSFAX XPP] section change PR_PROVIDER_DLL_NAME from FAXXP.DLL to FXSXP.DLL
    if (!WritePrivateProfileString( FAX_MESSAGE_PROVIDER_NAME_T,
                                    _T("PR_PROVIDER_DLL_NAME"),
                                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
                                    szPathToMapiSvcInf))
    {
        VERBOSE (   GENERAL_ERR, 
                    _T("WritePrivateProfileString (%s %s) failed (ec: %ld)."),
                    _T("PR_PROVIDER_DLL_NAME"),
                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,                    
                    GetLastError());
    }

    // following section is done to remove SBS2000 transport provider from MAPISVC.INF

    if (!WritePrivateProfileString( TEXT("Default Services"), 
                                    FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
                                    NULL, 
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    if (!WritePrivateProfileString( TEXT("Services"),
                                    FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
                                    NULL, 
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_SBS50_T,         
                                    NULL,
                                    NULL,
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
                                    NULL,
                                    NULL, 
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    return dwReturn;
}

///////////////////////////////
// fxocMapi_Uninstall
//
// Used to be "DeleteFaxMsgServices"
// in old FaxOCM.dll, it was in
// "mapi.c" file
//
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF to install from
//
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocMapi_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection)
{    
    DWORD               dwReturn   = NO_ERROR;

    DBG_ENTER(  _T("fxocMapi_Uninstall"),
                dwReturn,
                _T("%s - %s %d"),
                pszSubcomponentId,
                pszUninstallSection);

    VERBOSE(DBG_MSG,_T("Removing the MSFAX XP51 service provider"));
    if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME,SYSOCMGR_IMAGE_NAME)!=NO_ERROR)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING,_T("Cannot delete XP Transport Provider %d"),dwReturn);
    }

    return dwReturn;
}



///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  RemoveTransportProviderFromProfile
//
//  Purpose:        removes the Trasnport Provider from a specific MAPI profile
//
//  Params:
//                  LPSERVICEADMIN lpServiceAdmin - profile to remove the provider from
//                  LPSTR lpstrMessageServiceName - service name to remove
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
HRESULT RemoveTransportProviderFromProfile(LPSERVICEADMIN lpServiceAdmin,LPSTR lpstrMessageServiceName)
{
    static SRestriction sres;
    static SizedSPropTagArray(2, Columns) =   {2,{PR_DISPLAY_NAME_A,PR_SERVICE_UID}};

    HRESULT         hr                          = S_OK;
    LPMAPITABLE     lpMapiTable                 = NULL;
    LPSRowSet       lpSRowSet                   = NULL;
    LPSPropValue    lpProp                      = NULL;
    ULONG           Count                       = 0;
    BOOL            bMapiInitialized            = FALSE;
    SPropValue      spv;
    MAPIUID         ServiceUID;
    
    DBG_ENTER(TEXT("RemoveTransportProviderFromProfile"), hr);
    // get message service table
    hr = lpServiceAdmin->GetMsgServiceTable(0,&lpMapiTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetMsgServiceTable failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // notify MAPI that we want PR_DISPLAY_NAME_A & PR_SERVICE_UID
    hr = lpMapiTable->SetColumns((LPSPropTagArray)&Columns, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("SetColumns failed (ec: %ld)."),
                 hr);
        goto exit;
    }
 
    // restrict the search to our service provider
    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = PR_SERVICE_NAME_A;
    sres.res.resProperty.lpProp = &spv;

    spv.ulPropTag = PR_SERVICE_NAME_A;
    spv.Value.lpszA = lpstrMessageServiceName;

    // find it
    hr = lpMapiTable->FindRow(&sres, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("FindRow failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // get our service provider's row
    hr = lpMapiTable->QueryRows(1, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    if (lpSRowSet->cRows != 1)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows returned %d rows, there should be only one."),
                 lpSRowSet->cRows);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // get the MAPIUID of our service
    lpProp = &lpSRowSet->aRow[0].lpProps[1];

    if (lpProp->ulPropTag != PR_SERVICE_UID)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Property is %d, should be PR_SERVICE_UID."),
                 lpProp->ulPropTag);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // Copy the UID into our member.
    memcpy(&ServiceUID.ab, lpProp->Value.bin.lpb,lpProp->Value.bin.cb);

    // finally, delete our service provider
    hr = lpServiceAdmin->DeleteMsgService(&ServiceUID);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("DeleteMsgService failed (ec: %ld)."),
                 hr);
        goto exit;
    }

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  RemoveTransportProvider
//
//  Purpose:        removes the Trasnport Provider from MAPI profiles
//
//  Params:
//                  LPSTR lpstrMessageServiceName - service name to remove
//                  LPCTSTR lpctstrProcessName - process for which MAPI calls are routed
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
DWORD RemoveTransportProvider(LPSTR lpstrMessageServiceName,LPCTSTR lpctstrProcessName)
{
    DWORD           err                             = 0;
    DWORD           rc                              = ERROR_SUCCESS;
    HRESULT         hr                              = S_OK;
    LPSERVICEADMIN  lpServiceAdmin                  = NULL;
    LPMAPITABLE     lpMapiTable                     = NULL;
    LPPROFADMIN     lpProfAdmin                     = NULL;
    LPMAPITABLE     lpTable                         = NULL;
    LPSRowSet       lpSRowSet                       = NULL;
    LPSPropValue    lpProp                          = NULL;
    ULONG           Count                           = 0;
    int             iIndex                          = 0;
    BOOL            bMapiInitialized                = FALSE;
    HINSTANCE       hMapiDll                        = NULL;
                                                    
    LPMAPIINITIALIZE      fnMapiInitialize          = NULL;
    LPMAPIADMINPROFILES   fnMapiAdminProfiles       = NULL;
    LPMAPIUNINITIALIZE    fnMapiUninitialize        = NULL;

    DBG_ENTER(TEXT("RemoveTransportProvider"), rc);

    CRouteMAPICalls rmcRouteMapiCalls;

    
    // now remove the MAPI Service provider
    rc = rmcRouteMapiCalls.Init(lpctstrProcessName);
    if (rc!=ERROR_SUCCESS)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CRouteMAPICalls::Init failed (ec: %ld)."), rc);
        goto exit;
    }
    
    hMapiDll = LoadLibrary(_T("MAPI32.DLL"));
    if (NULL == hMapiDll)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadLibrary"), GetLastError()); 
        goto exit;
    }

    fnMapiInitialize = (LPMAPIINITIALIZE)GetProcAddress(hMapiDll, "MAPIInitialize");
    if (NULL == fnMapiInitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIInitialize)"), GetLastError());  
        goto exit;
    }

    fnMapiAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(hMapiDll, "MAPIAdminProfiles");
    if (NULL == fnMapiAdminProfiles)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(fnMapiAdminProfiles)"), GetLastError());  
        goto exit;
    }

    fnMapiUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(hMapiDll, "MAPIUninitialize");
    if (NULL == fnMapiUninitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIUninitialize)"), GetLastError());  
        goto exit;
    }

    // get access to MAPI functinality
    hr = fnMapiInitialize(NULL);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIInitialize failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    bMapiInitialized = TRUE;

    // get admin profile object
    hr = fnMapiAdminProfiles(0,&lpProfAdmin);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIAdminProfiles failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile table
    hr = lpProfAdmin->GetProfileTable(0,&lpTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetProfileTable failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile rows
    hr = lpTable->QueryRows(4000, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    for (iIndex=0; iIndex<(int)lpSRowSet->cRows; iIndex++)
    {
        lpProp = &lpSRowSet->aRow[iIndex].lpProps[0];

        if (lpProp->ulPropTag != PR_DISPLAY_NAME_A)
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("Property is %d, should be PR_DISPLAY_NAME_A."),
                     lpProp->ulPropTag);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_TABLE);
            goto exit;
        }

        hr = lpProfAdmin->AdminServices(LPTSTR(lpProp->Value.lpszA),NULL,0,0,&lpServiceAdmin);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("AdminServices failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
         
        hr = RemoveTransportProviderFromProfile(lpServiceAdmin,lpstrMessageServiceName);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("RemoveTransportProviderFromProfile failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
    }

exit:

    if (bMapiInitialized)
    {
        fnMapiUninitialize();
    }

    if (hMapiDll)
    {
        FreeLibrary(hMapiDll);
        hMapiDll = NULL;
    }

    return rc;
}

#define prv_DEBUG_FILE_NAME         _T("%windir%\\FaxSetup.log")

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  AWF_UninstallProvider
//
//  Purpose:        removes the AWF Trasnport Provider from MAPI profiles
//                  called from Active Setup key for every new user once.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 01-Jun-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD AWF_UninstallProvider()
{    
    DWORD dwReturn = NO_ERROR;
    SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
    SET_DEBUG_MASK(DBG_ALL);
    OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
    {
        DBG_ENTER(_T("AWF_UninstallProvider"),dwReturn);

        // this is an upgrade from W9X, we should remove the AWF transport.
        VERBOSE(DBG_MSG,_T("Removing the AWFAX service provider"));
        if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME_W9X,RUNDLL_IMAGE_NAME)!=NO_ERROR)
        {
            VERBOSE(DBG_WARNING,_T("Cannot delete W9X Transport Provider %d"),GetLastError());
        }
    }
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  PFW_UninstallProvider
//
//  Purpose:        removes the PFW Trasnport Provider from MAPI profiles
//                  called from Active Setup key for every new user once.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 01-Jun-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD PFW_UninstallProvider()
{    
    DWORD dwReturn = NO_ERROR;

    SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
    SET_DEBUG_MASK(DBG_ALL);
    OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
    {
        DBG_ENTER(_T("PFW_UninstallProvider"),dwReturn);

        // this is an upgrade from W2K, we should remove the PFW transport.
        VERBOSE(DBG_MSG,_T("Removing the MSFAX XP service provider"));
        if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME_W2K,RUNDLL_IMAGE_NAME)!=NO_ERROR)
        {
            VERBOSE(DBG_WARNING,_T("Cannot delete W2K Transport Provider %d"),GetLastError());
        }
    }
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  XP_UninstallProvider
//
//  Purpose:        removes the Windows XP Trasnport Provider from MAPI profiles
//                  called from Active Setup key for every new user once.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 01-Jun-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD XP_UninstallProvider()
{    
    DWORD dwReturn = NO_ERROR;

    SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
    SET_DEBUG_MASK(DBG_ALL);
    OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
    {
        DBG_ENTER(_T("XP_UninstallProvider"),dwReturn);

        VERBOSE(DBG_MSG,_T("Removing the MSFAX XP service provider"));
        if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME,RUNDLL_IMAGE_NAME)!=NO_ERROR)
        {
            VERBOSE(DBG_WARNING,_T("Cannot delete XP Transport Provider %d"),GetLastError());
        }
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocreg.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       FXOCREG.h
//
// Abstract:        Header file used by Registry source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCREG_H_
#define _FXOCREG_H_

DWORD fxocReg_Init(void);
DWORD fxocReg_Term(void);
DWORD fxocReg_Install(const TCHAR   *pszSubcomponentId,
                      const TCHAR   *pszInstallSection);
DWORD fxocReg_Uninstall(const TCHAR *pszSubcomponentId,
                        const TCHAR *pszUninstallSection);


#endif  // _FXOCREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocreg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocReg.cpp
//
// Abstract:        This provides the registry routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

#include <Loadperf.h>

//////////////////////// Static Function Prototypes ////////////////////////
static DWORD prv_InstallDynamicRegistry(const TCHAR     *pszSection);
static DWORD prv_UninstallDynamicRegistry(const TCHAR     *pszSection);

static DWORD prv_CreatePerformanceCounters(void);
static DWORD prv_DeletePerformanceCounters(void);

void prv_AddSecurityPrefix(void);
///////////////////////////////
// fxocReg_Init
//
// Initialize registry handling
// subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//
DWORD fxocReg_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Registry Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocReg_Term
//
// Terminate the registry handling
// subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//

DWORD fxocReg_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Registry Module"),dwRes);

    return dwRes;
}


///////////////////////////////
// fxocReg_Install
//
// Create registry settings as 
// specified in INF file, as well
// as dynamic settings that can only
// be done at run time (such as 
// performance counter setup, etc).
// 
// Params:
//      - pszSubcomponentId
//      - pszInstallSection
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//
DWORD fxocReg_Install(const TCHAR     *pszSubcomponentId,
                      const TCHAR     *pszInstallSection)
{
    DWORD       dwReturn        = NO_ERROR;
    DWORD       dwNumDevices    = 0;
    HINF        hInf            = faxocm_GetComponentInf();

    DBG_ENTER(  _T("fxocReg_Install"),
                dwReturn,   
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    if (pszInstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Set up the static registry data found in the INF file

    // This will perform all necessary install steps as specified
    // by the SPINST_* flags below.  Since we already queued up our
    // files to be copied, we are using this API only to setup our 
    // registry settings as specified in the FAX install section in 
    // the INF file.

    // Notice that this function works both for installing and uninstalling.
    // It determines whether to install or uninstall based on the "pszSection"
    // parameter passed in from the INF file.  The INF file will be structured
    // such that the install sections will have 'AddReg', etc, while the 
    // uninstall sections will have 'DelReg', etc.

    // Lastly, notice the SPINST_* flags specified.  We tell it to install
    // everything (via SPINST_ALL) with the exception of FILES since they
    // were copied over by the QUEUE_OPS operation before, and with the 
    // exception of PROFILEITEMS (shortcut link creation) because we want
    // to do that only after we have confirmed everything has succeeded.
    // Shortcut links are explictely created/deleted in faxocm.cpp (via 
    // fxocLink_Install/fxocLink_Uninstall functions)


    dwReturn = fxocUtil_DoSetup(
                             hInf, 
                             pszInstallSection, 
                             TRUE, 
                             SPINST_ALL & ~(SPINST_FILES | SPINST_PROFILEITEMS),
                             _T("fxocReg_Install"));

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed static registry ")
                _T("settings as specified in INF file"));

        // Place any dynamic registry data you need to create on the fly
        // here.
        //
        dwReturn = prv_InstallDynamicRegistry(pszInstallSection);
    }

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Registry Install, installing performance ")
                _T("counters..."));

        // first delete any performance counters we have before
        prv_DeletePerformanceCounters();

        // install performance counters
        prv_CreatePerformanceCounters();
    }

    // now do RegSvr for platform dependent DLLs
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Registry Install, Doing REGSVR"));

        dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_REGISTER_DLL_PLATFORM,SPINST_REGSVR,NULL);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully Registered Fax DLLs - platform dependent")
                    _T("from INF file, section '%s'"), 
                    pszInstallSection);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to Registered Fax DLLs - platform dependent")
                    _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                    pszInstallSection, 
                    dwReturn);
        }
    }

    // now do AddReg for platform dependent registry settings
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Registry Install, Doing AddReg_Platform"));

        dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_ADDREG_PLATFORM,SPINST_REGISTRY,NULL);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully Installed Registry- platform dependent")
                    _T("from INF file, section '%s'"), 
                    pszInstallSection);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to Install Registry- platform dependent")
                    _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                    pszInstallSection, 
                    dwReturn);
        }
    }

    // When upgrading from SB3 to >=RC1, need to pre-pend FAX_REG_SECURITY_PREFIX
    // to all encripted data
    if (dwReturn == NO_ERROR && 
        fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_XP_DOT_NET)
    {
        prv_AddSecurityPrefix();
    }

    // now write the version and SKU into the registry
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Registry Install, Doing SKU and Version"));

		HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP,FALSE,KEY_WRITE);
		if (hKey==NULL)
		{
			dwReturn = GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("Failed to open fax setup registry, dwReturn = 0x%lx"),                    
                    dwReturn);
			return dwReturn;
		}

		// write the SKU into the registry
		if (!SetRegistryDword(hKey,REGVAL_PRODUCT_SKU,GetProductSKU()))
		{
			dwReturn = GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("SetRegistryDword REGVAL_PRODUCT_SKU failed , dwReturn = 0x%lx"),                    
                    dwReturn);
		}

		// write the fax version into the registry
		if (!SetRegistryDword(hKey,REGVAL_PRODUCT_BUILD,GetProductBuild()))
		{
			dwReturn = GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("SetRegistryDword REGVAL_PRODUCT_VERSION failed , dwReturn = 0x%lx"),                    
                    dwReturn);
		}

		RegCloseKey(hKey);
    }

    return dwReturn;
}

///////////////////////////////
// fxocReg_Uninstall
//
// Delete registry settings as 
// specified in INF file, as well
// as dynamic settings that can only
// be done at run time (such as 
// performance counter setup, etc).
// 
// Params:
//      - pszSubcomponentId
//      - pszUninstallSection
// Returns:
//      - NO_ERROR on success
//      - error code otherwise
//
DWORD fxocReg_Uninstall(const TCHAR     *pszSubcomponentId,
                        const TCHAR     *pszUninstallSection)
{
    DWORD dwReturn  = NO_ERROR;
    HINF  hInf      = faxocm_GetComponentInf();

    DBG_ENTER(  _T("fxocReg_Uninstall"),
                dwReturn,   
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    if (pszUninstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // try to cleanup regardless of the return value.
    prv_UninstallDynamicRegistry(pszUninstallSection);

    // remove any performance counters related to fax.
    prv_DeletePerformanceCounters();

    // remove the static registry settings specified in the INF file    
    fxocUtil_DoSetup(hInf, 
                     pszUninstallSection, 
                     FALSE, 
                     SPINST_ALL & ~(SPINST_FILES | SPINST_PROFILEITEMS),
                     _T("fxocReg_Uninstall"));

    return dwReturn;
}

///////////////////////////////
// prv_InstallDynamicRegistry
//
// Installs dynamic registry 
// settings that can only be 
// done at run time (as opposed
// to via the faxsetup.inf file)
//
// Params:
//      - pszSection -
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_InstallDynamicRegistry(const TCHAR     *pszSection)
{
    DWORD   dwReturn          = NO_ERROR;
    LONG    lResult           = ERROR_SUCCESS;
    HKEY    hKey              = NULL;
    BOOL    bIsServerInstall  = FALSE;
    DWORD   dwProductType     = 0;

    DBG_ENTER(  _T("prv_InstallDynamicRegistry"),
                dwReturn,   
                _T("%s"),
                pszSection);

    if (pszSection == NULL) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    // open the install type registry key.
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, 
                           REGKEY_FAX_SETUP, 
                           0, 
                           KEY_ALL_ACCESS, 
                           &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        bIsServerInstall = fxState_IsOsServerBeingInstalled();

        if (bIsServerInstall)
        {
            dwProductType = FAX_INSTALL_SERVER;
        }
        else
        {
            dwProductType = FAX_INSTALL_WORKSTATION;
        }

        lResult = ::RegSetValueEx(hKey, 
                                  REGVAL_FAXINSTALL_TYPE, 
                                  0, 
                                  REG_DWORD, 
                                  (BYTE*) &dwProductType, 
                                  sizeof(dwProductType));

        if (lResult != ERROR_SUCCESS)
        {
            dwReturn = (DWORD) lResult;
            VERBOSE(SETUP_ERR,
                    _T("Failed to set InstallType, ")
                    _T("rc = 0x%lx"), 
                    lResult);
        }
    }

    if (hKey)
    {
        ::RegCloseKey(hKey);
        hKey = NULL;
    }

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed dynamic Registry ")
                _T("settings from INF file, section '%s'"), 
                pszSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install dynamic Registry ")
                _T("settings from INF file, section '%s', ")
                _T("rc = 0x%lx"), 
                pszSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// prv_UninstallDynamicRegistry
//
// Uninstall dynamic registry.
//
// Params:
//      - pszSection.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_UninstallDynamicRegistry(const TCHAR     *pszSection)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(  _T("prv_InstallDynamicRegistry"),
                dwRes,   
                _T("%s"),
                pszSection);

    return dwRes;
}

  
///////////////////////////////
// CreatePerformanceCounters
//
// Create the performance counters 
// for fax in the registry.
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
// Author: Mooly Beery (MoolyB) 17-Aug-2000
//
static DWORD prv_CreatePerformanceCounters()
{
    DWORD               dwRet							= ERROR_SUCCESS;
    TCHAR               szInstallDir[MAX_PATH]			= {0};
    TCHAR               szInstallCmdLine[MAX_PATH+20]	= {0};

    DBG_ENTER(_T("CreatePerformanceCounters"),dwRet);

    // get the install location of fxsperf.dll from Windows Installer
    if (!GetSystemDirectory(szInstallDir,ARR_SIZE(szInstallDir)))
    {
        dwRet = GetLastError();
        VERBOSE (GENERAL_ERR,_T("GetSystemDirectory failed (ec: %ld)."),dwRet);
        goto exit;
    }

	_sntprintf(szInstallCmdLine,ARR_SIZE(szInstallCmdLine)-1,_T("x \"%s%s\""),szInstallDir,FAX_FILENAME_FAXPERF_INI);

    VERBOSE(DBG_MSG,_T("Calling LoadPerfCounterTextStrings with %s "),szInstallCmdLine);

    dwRet = LoadPerfCounterTextStrings(szInstallCmdLine,TRUE);
    if (dwRet==ERROR_SUCCESS)
    {
        VERBOSE(DBG_MSG,_T("LoadPerfCounterTextStrings success"));
    }
    else
    {
        VERBOSE(GENERAL_ERR,_T("LoadPerfCounterTextStrings failed (ec=%d)"),dwRet);
    }

exit:

    return dwRet;
}

///////////////////////////////
// DeletePerformanceCounters
//
// Delete the performance counters 
// for fax in the registry.
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//      
// Author: Mooly Beery (MoolyB) 17-Aug-2000
//
static DWORD prv_DeletePerformanceCounters()
{
    DWORD dwRet = ERROR_SUCCESS;

    DBG_ENTER(_T("DeletePerformanceCounters"));

    dwRet = UnloadPerfCounterTextStrings(_T("x ") FAX_SERVICE_NAME,TRUE);
    if (dwRet==ERROR_SUCCESS)
    {
        VERBOSE(DBG_MSG,_T("UnloadPerfCounterTextStrings success"));
    }
    else
    {
        VERBOSE(GENERAL_ERR,_T("UnloadPerfCounterTextStrings failed (ec=%d)"),dwRet);
    }

    return dwRet;
}


/*++
Routine description:
    Pre-pends FAX_REG_SECURITY_PREFIX to a value

Arguments: 
    hKey        [in]        - handle of a key
    lpszValueName [in]      - name of value to work on

Return Value: none

Note: This function is sometimes used as a callback of EnumerateRegistryKeys(), 
    therefore its signature must be compatible with PREGENUMCALLBACK
--*/
void prv_AddSecurityPrefixToValue(HKEY hKey, LPCTSTR lpszValueName)
{
    LPBYTE pData = NULL;
    DWORD dwSize = 0;
    DWORD dwPrefixSize = sizeof (TCHAR) * wcslen (FAX_REG_SECURITY_PREFIX);

    DBG_ENTER(_T("prv_AddSecurityPrefixToValue"), _T("%s"), lpszValueName);
    
    pData = GetRegistryBinary(hKey, lpszValueName, &dwSize);
    if (pData)
    {
        if (dwSize <=1)
        {
            VERBOSE(DBG_MSG, _T("Size=%d, not real data"), dwSize);
        }
        else if ((dwSize>dwPrefixSize) && (memcmp(pData, FAX_REG_SECURITY_PREFIX, dwPrefixSize)==0))
        {
            VERBOSE(DBG_MSG, _T("Size=%d, data already has prefix"), dwSize);
        }
        else 
        {
            LPBYTE pNewData = NULL;

            VERBOSE(DBG_MSG, _T("Size=%d, adding prefix..."), dwSize);
            pNewData = (LPBYTE)MemAlloc(dwSize+dwPrefixSize);
            if (pNewData)
            {
                memcpy(pNewData, FAX_REG_SECURITY_PREFIX, dwPrefixSize);
                memcpy(&(pNewData[dwPrefixSize]), pData, dwSize);
                if (!SetRegistryBinary(hKey, lpszValueName, pNewData, dwSize+dwPrefixSize))
                {
                    VERBOSE(DBG_WARNING, _T("SetRegistryBinary failed, ec=%x"), GetLastError());
                }
                MemFree(pNewData);
            }
        }

        MemFree(pData);
    }
}


/*++
Routine description:
    Pre-pends FAX_REG_SECURITY_PREFIX to all binary values in a specified key 

Arguments: 
    hKey        [in]        - handle of a key
    lpszKeyName [in]        - If NULL, the function does nothing
    (DWORD)                 - unused
    lpContextData [in]      - (LPTSTR) name of subkey under hKey in which to work
                              if NULL, function will work on hKey itself  

Return Value: Always returns true

Note: This function is sometimes used as a callback of EnumerateRegistryKeys(), 
    therefore its signature must be compatible with PREGENUMCALLBACK
--*/
BOOL prv_AddSecurityPrefixToKey(
    HKEY hKey, LPWSTR lpszKeyName, DWORD, LPVOID lpContextData)
{
    LPTSTR lpszSubkey = (LPTSTR) lpContextData;
    HKEY hSubKey = NULL;

    int i;
    DWORD dwRet = NO_ERROR;
    DWORD dwType;
    DWORD dwValueNameSize;
    TCHAR szValueName[256] = {_T('\0')};
    
    DBG_ENTER(_T("prv_AddSecurityPrefixToKey"), _T("%s \\ %s"),
        lpszKeyName ? lpszKeyName : _T(""),
        lpContextData ? lpContextData : _T(""));

    // EnumerateRegistryKeys calls here once with the subkey - don't need that
    if (!lpszKeyName)
    {
        return TRUE;
    }

    if (lpContextData)
    {
        hSubKey = OpenRegistryKey(hKey, lpszSubkey, FALSE, KEY_READ | KEY_WRITE);
        if (!hSubKey)
        {
            return TRUE;
        }
    }

    for (i=0; ; i++)
    {
        dwValueNameSize = ARR_SIZE(szValueName);
        dwRet = RegEnumValue(
            lpContextData ? hSubKey : hKey,
            i,
            szValueName,
            &dwValueNameSize,
            NULL,                  // reserved
            &dwType,
            NULL,                  // data buffer
            NULL);                 // size of data buffer
        if (dwRet ==  ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        else if (dwRet != ERROR_SUCCESS)
        {
            VERBOSE(SETUP_ERR, _T("RegEnumValue failed, ec=%x"), dwRet);
            break;
        }

        if (dwType == REG_BINARY)
        {
            prv_AddSecurityPrefixToValue(lpContextData ? hSubKey : hKey, szValueName);
        }
    }

    if (hSubKey)
    {
        RegCloseKey(hSubKey);
    }
    
    return TRUE;
}


/*++
Routine description:
    Pre-pends FAX_REG_SECURITY_PREFIX to all encrypted registry values. 

Arguments: none
Return Value: none

Note: Encrypted registry values are located at: 
    Fax\TAPIDevices\<deviceID>
    Fax\Devices Cache\<deviceID>\TAPI Data
    Fax\Devices\UnassociatedExtensionData
    Fax\Receipts (Password value only)
--*/
void prv_AddSecurityPrefix(void)
{
    HKEY  hKey = NULL;
    DBG_ENTER(_T("prv_AddSecurityPrefix"));

    // Add prefixes to all values under TAPIDevices\<deviceID>
    EnumerateRegistryKeys(
        HKEY_LOCAL_MACHINE,
        REGKEY_TAPIDEVICES,
        TRUE, 
        prv_AddSecurityPrefixToKey,
        NULL);
    // EnumerateRegistryKeys returns the number of enumerated subkeys - we don't care about it

    // Add prefixes to all values under Devices Cache\<deviceID>\TAPI Data
    EnumerateRegistryKeys(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_DEVICES_CACHE,
        TRUE, 
        prv_AddSecurityPrefixToKey,
        (LPVOID)REGKEY_TAPI_DATA);
    // EnumerateRegistryKeys returns the number of enumerated subkeys - we don't care about it

    // Add prefixes to all values under Devices\UnassociatedExtensionData
    prv_AddSecurityPrefixToKey(HKEY_LOCAL_MACHINE, _T(""), 0, REGKEY_FAX_UNASS_DATA);

    // Add prefix to Receipts\Password
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_RECEIPTS, FALSE, KEY_READ | KEY_WRITE);
    if (hKey)
    {
        prv_AddSecurityPrefixToValue(hKey, REGVAL_RECEIPTS_PASSWORD);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocsvc.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocSvc.h
//
// Abstract:        Header file used by Service source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCSVC_H_
#define _FXOCSVC_H_


DWORD fxocSvc_Init(void);
DWORD fxocSvc_Term(void);
DWORD fxocSvc_Install(const TCHAR   *pszSubcomponentId,
                      const TCHAR   *pszInstallSection);
DWORD fxocSvc_Uninstall(const TCHAR *pszSubcomponentId,
                        const TCHAR *pszUninstallSection);

DWORD fxocSvc_StartService(const TCHAR *pszServiceName);
DWORD fxocSvc_StartFaxService();
DWORD fxocSvc_StopFaxService(HINF hInf,
                             const TCHAR *pszSection);

#endif  // _FXOCSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocprnt.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocPrnt.h
//
// Abstract:        Header file used by Fax Printer source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCPRNT_H_
#define _FXOCPRNT_H_

DWORD fxocPrnt_Init(void);
DWORD fxocPrnt_Term(void);
DWORD fxocPrnt_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocPrnt_InstallPrinter();
DWORD fxocPrnt_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

DWORD fxocPrnt_CreateLocalFaxPrinter(TCHAR   *pszFaxPrinterName);

void fxocPrnt_SetFaxPrinterName(const TCHAR* pszFaxPrinterName);
void fxocPrnt_SetFaxPrinterShared(BOOL IsFaxPrinterShared);
DWORD fxocPrnt_GetFaxPrinterName(TCHAR* pszFaxPrinterName,
                                 DWORD  dwNumBufChars);


#endif  // _FXOCPRNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocprnt.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocPrnt.cpp
//
// Abstract:        This provides the printer routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 17-Feb-1996  Wesley Witt (wesw)        Created routines originally from util.cpp
// 21-Mar-2000  Oren Rosenbloom (orenr)   Cleaned up, renamed, re-organized fns
// 17-Jul-2000  Eran Yariv (erany)        Added CoClassInstalled code
// 08-Jan-2001  Mooly Beery (moolyb)      Modified CoClassInstaller (wizard integration)
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"
#pragma hdrstop
#include <shellapi.h> 
#include <winsprlp.h>
#include <setuputil.h>
  

// W2K Printer defines
#define prv_W2K_FAX_PORT_NAME           _T("MSFAX:")                        // Win2K Fax printer port name
#define prv_W2K_FAX_DRIVER_NAME         _T("Windows NT Fax Driver")         // Win2K Fax printer driver name
#define prv_W2K_FAX_MONITOR_NAME        _T("Windows NT Fax Monitor")        // Win2K Fax printer monitor name

#define prv_W9X_PRINTER_DRIVER_FOLDER   _T("\\clients\\faxclient\\drivers\\W9X")
#define prv_NT4_PRINTER_DRIVER_FOLDER   _T("\\clients\\faxclient\\drivers\\NT4")
#define prv_PRINTER_DRIVER_FOLDER       _T("\\clients\\faxclient\\drivers")

#define prv_SYSTEM32_PATH               _T("%windir%\\system32")
#define prv_SERVER_SERVICE_NAME         _T("LanmanServer")
#define prv_SPOOLER_SERVICE_NAME        _T("Spooler")

//////////////////////// Static Function Prototypes /////////////////////////
static DWORD prv_DeleteFaxPrinter(LPCTSTR lpctstrDriverName, LPCTSTR lpctstrPortName);

static DWORD prv_CreatePrintMonitor(const TCHAR   *pszMonitorName,
                                    const TCHAR   *pszMonitorFile);

static DWORD prv_DeletePrintMonitor(const TCHAR   *pszMonitorName);

static DWORD prv_DeleteFaxPrinterDriver(LPTSTR lptstrDriverName,
                                        LPTSTR pEnviroment,
                                        DWORD dwVersionFlag);

static DWORD prv_AddFaxPrinterDriver(LPCTSTR lpctstrDriverSourcePath,LPCTSTR pEnvironment=NULL);

DWORD IsFaxInstalled (LPBOOL lpbInstalled);

static INT_PTR CALLBACK prv_dlgInstallFaxQuestion(HWND, UINT, WPARAM, LPARAM);

///////////////////////////////
// prv_GVAR
//
//
static struct prv_GVAR
{
    TCHAR szFaxPrinterName[255 + 1];
} prv_GVAR;

static bool bIsPnpInstallation = true;

///////////////////////////////
// fxocPrnt_Init
//
// Initialize the fax printer
// subsystem.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Print Module"),dwRes);
    return dwRes;
}

///////////////////////////////
// fxocPrnt_Term
//
// Terminate the fax printer
// subsystem.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Print Module"),dwRes);
    return dwRes;
}


///////////////////////////////
// fxocPrnt_Install
//
// Install fax printer monitor and driver(s) 
// Note: Doesn't install the actual printer!
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_Install(const TCHAR  *pszSubcomponentId,
                       const TCHAR  *pszInstallSection)
{
    DWORD           dwReturn      = NO_ERROR;

    DBG_ENTER(  _T("fxocPrnt_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);
    //
    // Before we do anything related to the printer, make sure that the 'LanManServer'
    // service is started.
    // The AddPrinter() code in the spooler service requires the LanManServer (SMB file sharing service)
    // service to be running.  
    // For some reason LanManServer is not running yet when doing a system install (GUI mode) of 
    // Windows XP Professional (in Server it does).
    //

    // it's possible that LanmanServer is not installed on Desktop SKUs
    if (!IsDesktopSKU())
    {
        dwReturn = fxocSvc_StartService(prv_SERVER_SERVICE_NAME);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully started '%s' service, continuing Printer Install"),
                    prv_SERVER_SERVICE_NAME);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                    _T("fax printer installation"),
                    prv_SERVER_SERVICE_NAME,
                    dwReturn);

            return dwReturn;
        }
    }

    // verify that the spooler is up
    dwReturn = fxocSvc_StartService(prv_SPOOLER_SERVICE_NAME);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully started '%s' service, continuing Printer Install"),
                prv_SPOOLER_SERVICE_NAME);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                _T("fax printer installation"),
                prv_SPOOLER_SERVICE_NAME,
                dwReturn);

        return dwReturn;
    }
    //
    // always attemp to remove W2K fax printer 
    dwReturn = prv_DeleteFaxPrinter(prv_W2K_FAX_DRIVER_NAME, prv_W2K_FAX_PORT_NAME);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Failed to delete W2K fax printer, rc = 0x%lx"),
                dwReturn);

        dwReturn = NO_ERROR;
    }
    //
    // delete the W2K printer driver files
    //
    dwReturn = prv_DeleteFaxPrinterDriver(prv_W2K_FAX_DRIVER_NAME, NULL, 3);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Failed to delete W2K fax drivers, rc = 0x%lx"),
                dwReturn);
        dwReturn = NO_ERROR;
    }
    //
    // delete the W2K fax print monitor.
    //
    dwReturn = prv_DeletePrintMonitor(prv_W2K_FAX_MONITOR_NAME);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Failed to delete W2K fax monitor, rc = 0x%lx"),
                dwReturn);
        dwReturn = NO_ERROR;
    }
    //
    // okay lets go and create a fax printer monitor.
    //
    if (dwReturn == NO_ERROR)
    {
        // create the print monitor
        dwReturn = prv_CreatePrintMonitor(FAX_MONITOR_NAME,
                                          FAX_MONITOR_FILE);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Fax Printer Install, ")
                    _T("failed to create fax printer monitor, rc=0x%lx"),
                    dwReturn);

        }
    }
    //
    // Copy the fax printer driver files
    //
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_AddFaxPrinterDriver(prv_SYSTEM32_PATH prv_PRINTER_DRIVER_FOLDER);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to copy Fax Printer Drivers from '%s', ")
                    _T("attempting to install fax printer anyway..., rc=0x%lx"),
                    prv_SYSTEM32_PATH,
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    if (IsFaxShared())
    {
        //
        // For SKUs which support fax sharing, let's add the printer drivers for W9X and NT4 too.
        //
        dwReturn = prv_AddFaxPrinterDriver(prv_SYSTEM32_PATH prv_W9X_PRINTER_DRIVER_FOLDER,W9X_PRINT_ENV);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to copy Fax Printer Drivers for W9X, rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
        dwReturn = prv_AddFaxPrinterDriver(prv_SYSTEM32_PATH prv_NT4_PRINTER_DRIVER_FOLDER,NT4_PRINT_ENV);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to copy Fax Printer Drivers for NT4, rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    return dwReturn;
}


///////////////////////////////
// fxocPrnt_InstallPrinter
//
// Checks whether there are any Fax-capable TAPI devices
// If there are, installs the Fax printer.
//
// Params:
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_InstallPrinter()
{
    DWORD           dwReturn      = NO_ERROR;
    DWORD           dwFaxDevicesCount = 0;

    DBG_ENTER(  _T("fxocPrnt_InstallPrinter"), dwReturn);
    //
    // Count the number of Fax-capable modems the system has
    //
    dwReturn = GetFaxCapableTapiLinesCount(&dwFaxDevicesCount, FAX_MODEM_PROVIDER_NAME);
    if (ERROR_SUCCESS != dwReturn)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetFaxCapableTapiLinesCount"), dwReturn);
        //
        // Assume no fax-capable devices exist
        //
        dwFaxDevicesCount = 0;
        dwReturn = NO_ERROR;
    }
    //
    // We do not create the printer by default unless;
    //    1. There are now fax-capable modems in the system or
    //    2. a fax printer was already there.
    //
    // Otherwise, only the monitor and drivers are installed.
    // The printer itself will be added either when an FSP / EFSP is registered or 
    // when a modem is installed.
    //
    if (dwFaxDevicesCount && (dwReturn == NO_ERROR))
    {
        TCHAR szFaxPrinterName[255 + 1] = {0};

        dwReturn = fxocPrnt_GetFaxPrinterName(szFaxPrinterName, 
                                              sizeof(szFaxPrinterName) / sizeof(TCHAR));
        if (ERROR_SUCCESS != dwReturn)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("fxocPrnt_GetFaxPrinterName"), dwReturn);
            return dwReturn;
        }
        //    
        // Create the fax printer.
        //
        dwReturn = AddLocalFaxPrinter (szFaxPrinterName, NULL);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Fax Printer Install, created fax printer ")
                    _T("Name = '%s', Driver Name = '%s'"),
                    szFaxPrinterName, 
                    FAX_DRIVER_NAME);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("fxocPrnt_Install, ")
                    _T("failed to create fax printer, rc = 0x%lx"),
                    dwReturn);
        }
    }
    return dwReturn;
}

///////////////////////////////
// fxocPrnt_Uninstall
//
// Remove all fax printers on this
// machine.
//
// Params:
//      - pszSubcomponentId
//      - pszUninstallSection.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
// 
//
DWORD fxocPrnt_Uninstall(const TCHAR  *pszSubcomponentId,
                         const TCHAR  *pszUninstallSection)
{
    DWORD dwReturn = NO_ERROR;

    // before we do anything related to the printer, make sure that the 'Server'
    // service is started.
    DBG_ENTER(  _T("fxocPrnt_Uninstall"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    // it's possible that LanmanServer is not installed on Desktop SKUs
    if (!IsDesktopSKU())
    {
        dwReturn = fxocSvc_StartService(prv_SERVER_SERVICE_NAME);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully started '%s' service, continuing Printer uninstall"),
                    prv_SERVER_SERVICE_NAME);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                    _T("fax printer uninstall"),
                    prv_SERVER_SERVICE_NAME,
                    dwReturn);

            return dwReturn;
        }
    }
    // verify that the spooler is up
    dwReturn = fxocSvc_StartService(prv_SPOOLER_SERVICE_NAME);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully started '%s' service, continuing Printer Install"),
                prv_SPOOLER_SERVICE_NAME);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                _T("fax printer installation"),
                prv_SPOOLER_SERVICE_NAME,
                dwReturn);

        return dwReturn;
    }

    // remove the fax printer
    prv_DeleteFaxPrinter(FAX_DRIVER_NAME, FAX_MONITOR_PORT_NAME);

    // remove fax printer monitor
    prv_DeletePrintMonitor(FAX_MONITOR_NAME);

    // remove all fax printer drivers
    prv_DeleteFaxPrinterDriver(FAX_DRIVER_NAME, NULL, 3);
    //
    // For SKUs which support fax sharing, remove down-level drivers as well.
    //
    if (IsFaxShared())
    {
        prv_DeleteFaxPrinterDriver(FAX_DRIVER_NAME, NT4_PRINT_ENV, 2);
        prv_DeleteFaxPrinterDriver(FAX_DRIVER_NAME, W9X_PRINT_ENV, 0);
    }
    return dwReturn;
}

///////////////////////////////
// fxocPrnt_SetFaxPrinterName
//
// Sets the name of the fax printer.
// This must be called prior to the
// creation of the fax printer via
// fxocPrnt_Install.
// 
// Params:
//      - pszFaxPrinterName - new name for fax printer.
// Returns:
//      - void.
//
void fxocPrnt_SetFaxPrinterName(const TCHAR* pszFaxPrinterName)
{
    DBG_ENTER(  _T("fxocPrnt_SetFaxPrinterName"),
                _T("%s"),
                pszFaxPrinterName);

    if (pszFaxPrinterName)
    {
        _tcsncpy(prv_GVAR.szFaxPrinterName, 
                 pszFaxPrinterName,
                 sizeof(prv_GVAR.szFaxPrinterName) / sizeof(TCHAR));
    }
    else
    {
        memset(prv_GVAR.szFaxPrinterName, 
               0, 
               sizeof(prv_GVAR.szFaxPrinterName));
    }

    return;
}

void fxocPrnt_SetFaxPrinterShared(BOOL IsFaxPrinterShared)
{
    DBG_ENTER(  _T("fxocPrnt_SetFaxPrinterShared"),
                _T("%d"),
                IsFaxPrinterShared);

    HKEY hFaxKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP,TRUE,KEY_WRITE);
    if (hFaxKey)
    {
        if (SetRegistryDword(hFaxKey,REGVAL_IS_SHARED_FAX_PRINTER,(IsFaxPrinterShared ? 1 : 0)))
        {
            VERBOSE(DBG_MSG, TEXT("Fax is installed in a mode that enables sharing"));
        }
        else
        {
            VERBOSE(DBG_MSG, TEXT("SetRegistryDword failed (ec=%d)"),GetLastError());
        }
        RegCloseKey(hFaxKey);
    }
    else
    {
        VERBOSE(SETUP_ERR, TEXT("Failed to create REGKEY_FAX_SETUP, printer won't be shared (ec=%d)"),GetLastError());
    }

}

///////////////////////////////
// fxocPrnt_GetFaxPrinterName
//
// Returns the current name of the 
// fax printer.
//
// Params:
//      - pszFaxPrinterName - OUT 
//      - dwNumBufChars
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocPrnt_GetFaxPrinterName(TCHAR* pszFaxPrinterName,
                                 DWORD  dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(  _T("fxocPrnt_GetFaxPrinterName"), dwReturn);

    if ((pszFaxPrinterName == NULL) ||
        (dwNumBufChars     == 0))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    if (prv_GVAR.szFaxPrinterName[0] != 0)
    {
        _tcsncpy(pszFaxPrinterName, 
                 prv_GVAR.szFaxPrinterName,
                 dwNumBufChars);
    }
    else
    {
        //
        // nobody set the fax printer name, so return the default
        // table.
        _tcsncpy(pszFaxPrinterName, 
                 FAX_PRINTER_NAME,
                 dwNumBufChars);
    }

    return dwReturn;
}   // fxocPrnt_GetFaxPrinterName

LPCTSTR lpctstrDriverFilesW2KandXP[] = 
{
    FAX_UI_MODULE_NAME,             // FXSUI.DLL
    FAX_DRV_MODULE_NAME,            // FXSDRV.DLL
    FAX_WZRD_MODULE_NAME,           // FXSWZRD.DLL
    FAX_TIFF_MODULE_NAME,           // FXSTIFF.DLL
    FAX_API_MODULE_NAME,            // FXSAPI.DLL
    FAX_RES_FILE
};

LPCTSTR lpctstrDriverFilesNT4[] = 
{
    FAX_NT4_DRV_MODULE_NAME,        // FXSDRV4.DLL
    FAX_UI_MODULE_NAME,             // FXSUI.DLL
    FAX_WZRD_MODULE_NAME,           // FXSWZRD.DLL
    FAX_API_MODULE_NAME,            // FXSAPI.DLL        
    FAX_TIFF_FILE,                  // FXSTIFF.DLL               
    FAX_RES_FILE
};

LPCTSTR lpctstrDriverFilesW9X[] = 
{
    FAX_DRV_WIN9X_32_MODULE_NAME,   // FXSDRV32.DLL
    FAX_DRV_WIN9X_16_MODULE_NAME,   // FXSDRV16.DRV
    FAX_API_MODULE_NAME,            // FXSAPI.DLL
    FAX_DRV_UNIDRV_MODULE_NAME,     // UNIDRV.DLL
    FAX_DRV_UNIDRV_HELP,            // UNIDRV.HLP
    FAX_DRV_ICONLIB,                // ICONLIB.DLL
    FAX_WZRD_MODULE_NAME,           // FXSWZRD.DLL
    FAX_TIFF_FILE,                  // FXSTIFF.DLL
    FAX_RES_FILE
};

///////////////////////////////////
// prv_AddFaxPrinterDriver
//
// Add printer driver to the server machine.
// In case of failure, do clean-up and returns FALSE.
// Temp files are deleted allways.
//              
// Params:
//      - lpctstrDriverSourcePath  : The directory where the printer's driver files 
//                                   are located (put there by the setup)
//      - pEnvironment             : for which platform are the drivers added
//
static DWORD prv_AddFaxPrinterDriver(LPCTSTR lpctstrDriverSourcePath,LPCTSTR pEnvironment)
{
    DWORD       dwReturn                           = NO_ERROR;
    BOOL        bSuccess                           = FALSE;
    LPCTSTR*    filesToCopy                        = NULL;
    DWORD       dwFileCount                        = 0;
    DWORD       dwNeededSize                       = 0;
    TCHAR       szPrinterDriverDirectory[MAX_PATH] = {0};
    TCHAR       szSourceDir[MAX_PATH]              = {0};
    DWORD       dwNumChars                         = 0;

    DBG_ENTER(  _T("prv_AddFaxPrinterDriver"),
                dwReturn,
                _T("%s - %s"),
                lpctstrDriverSourcePath,
                pEnvironment);

    if (!GetPrinterDriverDirectory(NULL,
                                   (LPTSTR)pEnvironment,
                                   1,
                                   (LPBYTE)szPrinterDriverDirectory,
                                   sizeof(szPrinterDriverDirectory),
                                   &dwNeededSize))
    {
        dwReturn = GetLastError();
        VERBOSE(SETUP_ERR,
                TEXT("GetPrinterDriverDirectory failed - %d."),
                dwReturn);
        return dwReturn;
    }

    bSuccess = TRUE;

    VERBOSE(DBG_MSG,
            _T("Printer driver directory is %s\n"),
            szPrinterDriverDirectory);

    if (pEnvironment==NULL)
    {
        filesToCopy = lpctstrDriverFilesW2KandXP;
        dwFileCount = sizeof(lpctstrDriverFilesW2KandXP)/sizeof(LPCTSTR);
    }
    else if (_tcsicmp(pEnvironment,NT4_PRINT_ENV)==0)
    {
        filesToCopy = lpctstrDriverFilesNT4;
        dwFileCount = sizeof(lpctstrDriverFilesNT4)/sizeof(LPCTSTR);
    }
    else if (_tcsicmp(pEnvironment,W9X_PRINT_ENV)==0)
    {
        filesToCopy = lpctstrDriverFilesW9X;
        dwFileCount = sizeof(lpctstrDriverFilesW9X)/sizeof(LPCTSTR);
    }

    if (bSuccess)
    {
        dwNumChars = ExpandEnvironmentStrings(lpctstrDriverSourcePath,
                                              szSourceDir,
                                              sizeof(szSourceDir) / sizeof(TCHAR));
        if (dwNumChars == 0)
        {
            VERBOSE(SETUP_ERR,
                     _T("ExpandEnvironmentStrings failed, rc = 0x%lx"),
                     ::GetLastError());

            bSuccess = FALSE;
        }
    }

    if (bSuccess)
    {
        bSuccess = MultiFileCopy(dwFileCount,
                                 filesToCopy,
                                 szSourceDir,
                                 szPrinterDriverDirectory);

        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,
                    _T("MultiFileCopy failed (ec: %ld)"),
                    GetLastError());
        }
    }

    if (bSuccess)
    {

        DRIVER_INFO_3 DriverInfo3;
        ZeroMemory(&DriverInfo3,sizeof(DRIVER_INFO_3));

        // fill DRIVER_INFO_3 depending on pEnv...
        bSuccess = FillDriverInfo(&DriverInfo3,pEnvironment);
        if (bSuccess)
        {
            bSuccess = AddPrinterDriverEx(NULL,
                                          3,
                                          (LPBYTE)&DriverInfo3,
                                          APD_COPY_NEW_FILES|APD_DONT_SET_CHECKPOINT);
            if (bSuccess)
            {
                VERBOSE(DBG_MSG,_T("Successfully added new fax printer drivers"));
            }
            else
            {
                VERBOSE(SETUP_ERR,_T("AddPrinterDriverEx failed (ec: %ld)"),GetLastError());
            }
        }
        else
        {
            VERBOSE(SETUP_ERR,_T("FillDriverInfo failed, try to continue"));
        }
    }

    //
    // Delete the temporary fax DLL files.
    //
    if (!MultiFileDelete(dwFileCount,
                         filesToCopy,
                         szPrinterDriverDirectory))
    {
        VERBOSE(SETUP_ERR,
                _T("MultiFileDelete() failed (ec: %ld)"),
                GetLastError());
    }

    if (!bSuccess)
    {
        dwReturn = ::GetLastError();
    }

    return dwReturn;
}



///////////////////////////////
// prv_DeletePrinter
//
// Delete printer by name. The driver name and the port name are just for debug print.
//
// Params:
//      - pszPrinterName - name of printer to delete
//      - pszFaxDriver   - name of associated driver 
//      - pszPortName    - name of associated port.
//
static DWORD prv_DeletePrinter(const TCHAR   *pszPrinterName,
                               const TCHAR   *pszFaxDriver,
                               const TCHAR   *pszPortName)
{
    DWORD   dwReturn = NO_ERROR;
    BOOL    bSuccess = FALSE;
    HANDLE  hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = 
    {
        NULL,
        NULL,
        PRINTER_ALL_ACCESS
    };

    DBG_ENTER(  _T("prv_DeletePrinter"),
                dwReturn,
                _T("%s - %s - %s"),
                pszPrinterName,
                pszFaxDriver,
                pszPortName);

    if ((pszPrinterName == NULL) ||
        (pszFaxDriver   == NULL) ||
        (pszPortName    == NULL))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    bSuccess = ::OpenPrinter((TCHAR*) pszPrinterName,
                             &hPrinter,
                             &PrinterDefaults);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("prv_DeletePrinter, deleting ")
                _T("printer '%s' with Driver Name = '%s', ")
                _T("Port Name = '%s'"), 
                pszPrinterName,
                pszFaxDriver, 
                pszPortName);

        if (!SetPrinter(hPrinter,0,NULL,PRINTER_CONTROL_PURGE))
        {
            // Don't let a failure here keep us from attempting the delete
            VERBOSE(PRINT_ERR,TEXT("SetPrinter failed (purge jobs before uninstall) ec=%d"),GetLastError());
        }

        bSuccess = ::DeletePrinter(hPrinter);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("prv_DeletePrinter, failed to delete ")
                    _T("fax printer '%s', rc = 0x%lx"),
                    pszPrinterName,
                    dwReturn);
        }

        bSuccess = ::ClosePrinter(hPrinter);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("prv_DeletePrinter, failed to Close ")
                    _T("fax printer '%s', rc = 0x%lx"),
                    pszPrinterName,
                    dwReturn);
        }

        hPrinter = NULL;
    }

    return dwReturn;
}

///////////////////////////////
// prv_DeleteFaxPrinter
//
// Delete fax printer with driver name and port as passed in params
//
// Params: 
//              LPCTSTR lpctstrDriverName   - printer driver name to delete
//              LPCTSTR lpctstrPortName     - printer port name

//
//
//
static DWORD prv_DeleteFaxPrinter(LPCTSTR lpctstrDriverName, LPCTSTR lpctstrPortName)
{
    BOOL            bSuccess        = FALSE;
    DWORD           dwReturn        = NO_ERROR;
    DWORD           dwCount         = 0;
    DWORD           i               = 0;
    PPRINTER_INFO_2 pPrinterInfo    = NULL;

    DBG_ENTER(_T("prv_DeleteFaxPrinter"),dwReturn);

    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL, 
                                                    2, 
                                                    &dwCount, 
                                                    PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);

    VERBOSE(DBG_MSG,
            _T("DeleteFaxPrinter, found %lu printers installed ")
            _T("on this computer"), 
            dwCount);

    if (pPrinterInfo)
    {
        for (i=0; i < dwCount; i++) 
        {
            // Check if printer has same driver same port name
            if (_tcsicmp(pPrinterInfo[i].pDriverName, lpctstrDriverName)    == 0  &&
                _tcsicmp(pPrinterInfo[i].pPortName,   lpctstrPortName)   == 0)
                 
            {
                // We can have a Local printer here or a Printer connection.
                // we differentiate between the two by the ServerName field of
                // PRINTER_INFO_2
                if (pPrinterInfo[i].pServerName==NULL)
                {
                    // this is a local printer.
                    dwReturn = prv_DeletePrinter(pPrinterInfo[i].pPrinterName,
                                                 lpctstrDriverName,
                                                 lpctstrPortName);
                    if (dwReturn != NO_ERROR)
                    {
                        VERBOSE(SETUP_ERR,
                                _T("Failed to delete printer '%s', rc = 0x%lx, ")
                                _T("continuing anyway..."),
                                pPrinterInfo[i].pPrinterName,
                                dwReturn);

                        dwReturn = NO_ERROR;
                    }
                }
                else
                {
                    // this is a printer connection
                    if (!DeletePrinterConnection(pPrinterInfo[i].pPrinterName))
                    {
                        dwReturn = GetLastError();
                        VERBOSE(SETUP_ERR,
                                _T("Failed to delete printer connection '%s', rc = 0x%lx, ")
                                _T("continuing anyway..."),
                                pPrinterInfo[i].pPrinterName,
                                dwReturn);

                        dwReturn = NO_ERROR;
                    }
                }
            }
        }

        MemFree(pPrinterInfo);
    }

    return dwReturn;
}

///////////////////////////////
// prv_CreatePrintMonitor
//
// Create the printer monitor
//
// Params:
//      - pszMonitorName - name of printer monitor
//      - pszMonitorFile - name of print monitor file
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
static DWORD prv_CreatePrintMonitor(const TCHAR   *pszMonitorName,
                                    const TCHAR   *pszMonitorFile)
{
    BOOL            bSuccess = TRUE;
    DWORD           dwReturn = NO_ERROR;
    MONITOR_INFO_2  MonitorInfo;

    DBG_ENTER(  _T("prv_CreatePrintMonitor"),
                dwReturn,
                _T("%s - %s"),
                pszMonitorName,
                pszMonitorFile);

    if ((pszMonitorName == NULL) ||
        (pszMonitorFile == NULL))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    MonitorInfo.pName         = (TCHAR*) pszMonitorName;
    MonitorInfo.pDLLName      = (TCHAR*) pszMonitorFile;
    MonitorInfo.pEnvironment  = NULL;

    bSuccess = ::AddMonitor(NULL, 2, (LPBYTE) &MonitorInfo);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully created fax monitor '%s', ")
                _T("File Name '%s'"), 
                pszMonitorName,
                pszMonitorFile);
    }
    else
    {
        dwReturn = ::GetLastError();

        if (dwReturn == ERROR_PRINT_MONITOR_ALREADY_INSTALLED)
        {
            VERBOSE(DBG_MSG,
                    _T("AddMonitor, failed because '%s' monitor already ")
                    _T("exists.  This is fine, let's continue..."),
                    pszMonitorName);

            dwReturn = NO_ERROR;

        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("CreatePrinterMonitor, failed to ")
                    _T("add new print monitor '%s', rc = 0x%lx"), 
                    pszMonitorName, 
                    dwReturn);
        }
    }

    return dwReturn;
}


///////////////////////////////
// prv_DeletePrintMonitor
//
// Delete the printer monitor
//
// Params:
//      - pszMonitorName - name of print monitor to delete
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
static DWORD prv_DeletePrintMonitor(const TCHAR   *pszMonitorName)
                                    
{
    BOOL            bSuccess = TRUE;
    DWORD           dwReturn = NO_ERROR;
    DBG_ENTER(  _T("prv_DeletePrintMonitor"),
                dwReturn,
                _T("%s"),
                pszMonitorName);

    if (pszMonitorName == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    bSuccess = ::DeleteMonitor(NULL, NULL, (LPTSTR) pszMonitorName);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("DeletePrinterMonitor, successfully ")
                _T("deleted print monitor name '%s'"), 
                pszMonitorName);
    }
    else
    {
        dwReturn = ::GetLastError();

        if (dwReturn != ERROR_UNKNOWN_PRINT_MONITOR)
        {
            VERBOSE(SETUP_ERR,
                    _T("DeletePrinterMonitor, failed to ")
                    _T("remove print monitor '%s', rc = 0x%lx"), 
                    pszMonitorName, 
                    dwReturn);
        }
        else
        {
            dwReturn = NO_ERROR;
        }
    }

    return dwReturn;
}

////////////////////////////
// prv_DeleteFaxPrinterDriver
//
// Delete fax printer driver from current machine
// In case of failure, log it and returns FALSE.
//
// Params:
//      - LPTSTR lptstrDriverName   -   Driver name to delete
//      - pEnvironment              -   for which platform are the drivers deleted
//      - DWORD dwVersionFlag       -   The version of the driver that should be deleted. 
//                                      Valid valuse {0,1,2,3} only.
// Returns;
//      - Returns ERROR_SUCCESS on success, on failue retuen the error code. 
//
static DWORD prv_DeleteFaxPrinterDriver(LPTSTR lptstrDriverName,
                                        LPTSTR pEnviroment,
                                        DWORD dwVersionFlag)
{
    BOOL    bSuccess = TRUE;
    DWORD   ec       = ERROR_SUCCESS;

    DBG_ENTER(_T("prv_DeleteFaxPrinterDriver"),ec);

    ASSERTION(dwVersionFlag<=3);

    // delete driver.
    bSuccess = DeletePrinterDriverEx(NULL,
                                     pEnviroment,
                                     lptstrDriverName,
                                     DPD_DELETE_SPECIFIC_VERSION|DPD_DELETE_ALL_FILES,
                                     dwVersionFlag);
    if (!bSuccess)
    {
        ec = GetLastError();
        VERBOSE(DBG_MSG,
                TEXT("DeletePrinterDriverEx() for driver %s, version %ld failed (ec: %ld)"),
                lptstrDriverName,
                dwVersionFlag,
                ec);
    } 
    else
    {
        VERBOSE(DBG_MSG,
                TEXT("DeletePrinterDriverEx() for driver %s, version %ld succeeded"),
                lptstrDriverName,
                dwVersionFlag);
    }

    return ec;
}



/***************************************************************************************
**                                                                                    **
**              C o C l a s s I n s t a l l e r   s e c t i o n                       **
**                                                                                    **
***************************************************************************************/


#ifdef ENABLE_LOGGING

typedef struct _DIF_DEBUG {
    DWORD DifValue;
    LPTSTR DifString;
} DIF_DEBUG, *PDIF_DEBUG;

DIF_DEBUG DifDebug[] =
{
    { 0,                                    L""                                     },  //  0x00000000
    { DIF_SELECTDEVICE,                     L"DIF_SELECTDEVICE"                     },  //  0x00000001
    { DIF_INSTALLDEVICE,                    L"DIF_INSTALLDEVICE"                    },  //  0x00000002
    { DIF_ASSIGNRESOURCES,                  L"DIF_ASSIGNRESOURCES"                  },  //  0x00000003
    { DIF_PROPERTIES,                       L"DIF_PROPERTIES"                       },  //  0x00000004
    { DIF_REMOVE,                           L"DIF_REMOVE"                           },  //  0x00000005
    { DIF_FIRSTTIMESETUP,                   L"DIF_FIRSTTIMESETUP"                   },  //  0x00000006
    { DIF_FOUNDDEVICE,                      L"DIF_FOUNDDEVICE"                      },  //  0x00000007
    { DIF_SELECTCLASSDRIVERS,               L"DIF_SELECTCLASSDRIVERS"               },  //  0x00000008
    { DIF_VALIDATECLASSDRIVERS,             L"DIF_VALIDATECLASSDRIVERS"             },  //  0x00000009
    { DIF_INSTALLCLASSDRIVERS,              L"DIF_INSTALLCLASSDRIVERS"              },  //  0x0000000A
    { DIF_CALCDISKSPACE,                    L"DIF_CALCDISKSPACE"                    },  //  0x0000000B
    { DIF_DESTROYPRIVATEDATA,               L"DIF_DESTROYPRIVATEDATA"               },  //  0x0000000C
    { DIF_VALIDATEDRIVER,                   L"DIF_VALIDATEDRIVER"                   },  //  0x0000000D
    { DIF_MOVEDEVICE,                       L"DIF_MOVEDEVICE"                       },  //  0x0000000E
    { DIF_DETECT,                           L"DIF_DETECT"                           },  //  0x0000000F
    { DIF_INSTALLWIZARD,                    L"DIF_INSTALLWIZARD"                    },  //  0x00000010
    { DIF_DESTROYWIZARDDATA,                L"DIF_DESTROYWIZARDDATA"                },  //  0x00000011
    { DIF_PROPERTYCHANGE,                   L"DIF_PROPERTYCHANGE"                   },  //  0x00000012
    { DIF_ENABLECLASS,                      L"DIF_ENABLECLASS"                      },  //  0x00000013
    { DIF_DETECTVERIFY,                     L"DIF_DETECTVERIFY"                     },  //  0x00000014
    { DIF_INSTALLDEVICEFILES,               L"DIF_INSTALLDEVICEFILES"               },  //  0x00000015
    { DIF_UNREMOVE,                         L"DIF_UNREMOVE"                         },  //  0x00000016
    { DIF_SELECTBESTCOMPATDRV,              L"DIF_SELECTBESTCOMPATDRV"              },  //  0x00000017
    { DIF_ALLOW_INSTALL,                    L"DIF_ALLOW_INSTALL"                    },  //  0x00000018
    { DIF_REGISTERDEVICE,                   L"DIF_REGISTERDEVICE"                   },  //  0x00000019
    { DIF_NEWDEVICEWIZARD_PRESELECT,        L"DIF_NEWDEVICEWIZARD_PRESELECT"        },  //  0x0000001A
    { DIF_NEWDEVICEWIZARD_SELECT,           L"DIF_NEWDEVICEWIZARD_SELECT"           },  //  0x0000001B
    { DIF_NEWDEVICEWIZARD_PREANALYZE,       L"DIF_NEWDEVICEWIZARD_PREANALYZE"       },  //  0x0000001C
    { DIF_NEWDEVICEWIZARD_POSTANALYZE,      L"DIF_NEWDEVICEWIZARD_POSTANALYZE"      },  //  0x0000001D
    { DIF_NEWDEVICEWIZARD_FINISHINSTALL,    L"DIF_NEWDEVICEWIZARD_FINISHINSTALL"    },  //  0x0000001E
    { DIF_UNUSED1,                          L"DIF_UNUSED1"                          },  //  0x0000001F
    { DIF_INSTALLINTERFACES,                L"DIF_INSTALLINTERFACES"                },  //  0x00000020
    { DIF_DETECTCANCEL,                     L"DIF_DETECTCANCEL"                     },  //  0x00000021
    { DIF_REGISTER_COINSTALLERS,            L"DIF_REGISTER_COINSTALLERS"            },  //  0x00000022
    { DIF_ADDPROPERTYPAGE_ADVANCED,         L"DIF_ADDPROPERTYPAGE_ADVANCED"         },  //  0x00000023
    { DIF_ADDPROPERTYPAGE_BASIC,            L"DIF_ADDPROPERTYPAGE_BASIC"            },  //  0x00000024
    { DIF_RESERVED1,                        L"DIF_RESERVED1"                        },  //  0x00000025
    { DIF_TROUBLESHOOTER,                   L"DIF_TROUBLESHOOTER"                   },  //  0x00000026
    { DIF_POWERMESSAGEWAKE,                 L"DIF_POWERMESSAGEWAKE"                 },  //  0x00000027
    { DIF_ADDREMOTEPROPERTYPAGE_ADVANCED,   L"DIF_ADDREMOTEPROPERTYPAGE_ADVANCED"   }   //  0x00000028
};

#endif



/*
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SaveDontShowMeThisAgain
//
//  Purpose:        
//                  Check if the user checked the 'Don't show me this again'
//                  If he did, set the registry key
//                  
//  Params:
//                  Handle to window
//
//  Return Value:
//                  None
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
void SaveDontShowMeThisAgain(HWND hwndDlg)
{
   DBG_ENTER(_T("SaveDontShowMeThisAgain"));

    //
    // let's save the "Don't show me again" state
    //
    if (BST_CHECKED == ::SendMessage (::GetDlgItem (hwndDlg, IDC_DONT_SHOW), BM_GETCHECK, 0, 0))
    {
        //
        // User pressed the "Don't show me again" checkbox
        //
        HKEY hFaxKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                        REGKEY_FAX_SETUP,
                                        TRUE,
                                        KEY_WRITE);
        if (!hFaxKey)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("OpenRegistryKey(REGKEY_FAX_SETUP)"), GetLastError());
        }
        else
        {
            if (!SetRegistryDword (hFaxKey,
                                   REGVAL_DONT_UNATTEND_INSTALL,
                                   1))
            {
                CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryDword(REGVAL_DONT_UNATTEND_INSTALL)"), GetLastError());
            }
            RegCloseKey (hFaxKey);
        }
    }
}
*/

/*
static
INT_PTR 
CALLBACK 
prv_dlgInstallFaxQuestionPropPage(
  HWND hwndDlg,   
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  
)
/*++

Routine name : prv_dlgInstallFaxQuestionPropPage

Routine description:

    Dialogs procedure for "Install fax" dialog

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    hwndDlg                       [in]    - Handle to dialog box
    uMsg                          [in]    - Message
    wParam                        [in]    - First message parameter
    parameter                     [in]    - Second message parameter

Return Value:

    Standard dialog return value

--*/
/*
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("prv_dlgInstallFaxQuestionPropPage"));

    switch (uMsg) 
    {
        case WM_INITDIALOG: 
            // no return value here.
            PropSheet_SetWizButtons(GetParent(hwndDlg),PSWIZB_NEXT);
                
            SetFocus(hwndDlg);
            if (!CheckDlgButton(hwndDlg,IDC_INSTALL_FAX_NOW,BST_CHECKED))
            {
                dwRes = GetLastError();
                CALL_FAIL (GENERAL_ERR, TEXT("CheckDlgButton"), dwRes);
            }
            break;
        
        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
            case PSN_WIZNEXT:
                SaveDontShowMeThisAgain(hwndDlg);
                //
                // let's get the "Install Fax Now" state
                //
                if (BST_CHECKED == ::SendMessage (::GetDlgItem (hwndDlg, IDC_INSTALL_FAX_NOW), BM_GETCHECK, 0, 0))
                {
                    //
                    // User pressed the "Install Fax Now" checkbox
                    //
                    dwRes = InstallFaxUnattended();
                    if (dwRes!=ERROR_SUCCESS)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("InstallFaxUnattended"), dwRes);
                    }
                }
                return TRUE;
            }
            break;

    }
    return FALSE;
}   // prv_dlgInstallFaxQuestionPropPage
*/

/*
static
INT_PTR 
CALLBACK 
prv_dlgInstallFaxQuestion(
  HWND hwndDlg,   
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  
)
/*++

Routine name : prv_dlgInstallFaxQuestion

Routine description:

    Dialogs procedure for "Install fax" dialog

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    hwndDlg                       [in]    - Handle to dialog box
    uMsg                          [in]    - Message
    wParam                        [in]    - First message parameter
    parameter                     [in]    - Second message parameter

Return Value:

    Standard dialog return value

--*/
/*
{
    INT_PTR iRes = IDIGNORE;
    DBG_ENTER(_T("prv_dlgInstallFaxQuestion"));

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            SetFocus(hwndDlg);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) 
            {
                case IDC_ANSWER_YES:
                    iRes = IDYES;
                    break;

                case IDC_ANSWER_NO:
                    iRes = IDNO;
                    break;
            }
            if (IDIGNORE != iRes)
            {
                SaveDontShowMeThisAgain(hwndDlg);
                EndDialog (hwndDlg, iRes);
                return TRUE;
            }
            break;
    }
    return FALSE;
}   // prv_dlgInstallFaxQuestion
*/


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  AllowInstallationProposal
//
//  Purpose:        
//                  Verify we can propose to the user to install Fax 
//                  Check if Fax is installed
//                  Check if the user has marked the 'don't show this again'
//                  
//  Params:
//                  None
//
//  Return Value:
//                  true - ok to propose the installation of Fax
//                  false - do not propose the Fax installation
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
bool AllowInstallationProposal()
{
    DWORD   ec            = NO_ERROR;
    BOOL    bFaxInstalled = FALSE;

    DBG_ENTER(_T("AllowInstallationProposal"));
    
    ec = IsFaxInstalled (&bFaxInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("IsFaxInstalled"), ec);
        return false;
    }
    if (bFaxInstalled)
    {
        VERBOSE(DBG_MSG,TEXT("Fax is already installed"));
        return false;
    }
    //
    // Let's find out if we're allowed to add a property page 
    //
    BOOL bDontShowThisAgain = FALSE;
    HKEY hFaxKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                    REGKEY_FAX_SETUP,
                                    FALSE,
                                    KEY_READ);
    if (!hFaxKey)
    {
        //
        // No value there
        //
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("OpenRegistryKey(REGKEY_FAX_SETUP)"), ec);
        // let's go on.
    }
    else
    {
        bDontShowThisAgain = GetRegistryDword (hFaxKey,REGVAL_DONT_UNATTEND_INSTALL);
        RegCloseKey (hFaxKey);
    }
    if (bDontShowThisAgain)
    {
        //
        // User previously checked the "Don't ask me again" checkbox
        //
        VERBOSE (DBG_MSG, TEXT("Used previously checked the \"Don't ask me again\" checkbox"));
        return false;
    }

    return true;
}

/*
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  HandleNonPnpDevices
//
//  Purpose:        
//                  Handles DIF_INSTALLDEVICE
//                  A new device has finished installing and we check if this is a non PnP device
//                  if it is we propose the user to install Fax using a message box.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD HandleNonPnpDevices()
{
    DWORD ec = NO_ERROR;
    DBG_ENTER(_T("HandleNonPnpDevices"), ec);

    // if this is a PnP installation don't do anything here
    if (bIsPnpInstallation)
    {
        VERBOSE(DBG_MSG,_T("This is a PnP device installation, exiting"));
        goto exit;
    }

    // if Fax is installed or the user has checked the 'Don't show me this again' do not propose
    if (!AllowInstallationProposal())
    {
        VERBOSE(DBG_MSG,TEXT("Not allowed to install, exit"));
        goto exit;
    }

    //
    // Let's ask the user if he wishes to install a fax now
    //
    INT_PTR iResult = DialogBox (faxocm_GetAppInstance(),
                                 MAKEINTRESOURCE(IDD_INSTALL_FAX),
                                 NULL,
                                 prv_dlgInstallFaxQuestion);
    if (iResult==-1)
    {
        ec = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("DialogBox(IDD_INSTALL_FAX)"), ec);
        goto exit;
    }

    if (iResult==IDYES)
    {
        //
        // User wishes to install the fax now - do so.
        //
        ec = InstallFaxUnattended();
        if (ec!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("InstallFaxUnattended"), ec);
        }
    }

exit:
    return ec;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  GetModemDriverInfo
//
//  Purpose:        
//                  Gets the modem's selected driver and retrieves the modem's INF 
//                  filename and section within the INF file
//
//  Params:
//                  IN HDEVINFO hDeviceInfoSet                        - passed from CoDevice Installer
//                  IN PSP_DEVINFO_DATA pDeviceInfoData               - passed from CoDevice Installer
//                  OUT PSP_DRVINFO_DETAIL_DATA pspDrvInfoDetailData  - passes out the driver details
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//                  Caller must call MemFree on returned pointer.
//
//  Author:
//                  Mooly Beery (MoolyB) 28-Mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD GetModemDriverInfo
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA pspDrvInfoDetailData
)
{
    DWORD                   ec                      = NO_ERROR;
    DWORD                   dwRequiredSize          = 0;
    SP_DRVINFO_DATA         spDrvInfoData;

    DBG_ENTER(_T("GetModemDriverInfo"), ec);

    pspDrvInfoDetailData = NULL;
    spDrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (SetupDiGetSelectedDriver(hDeviceInfoSet,pDeviceInfoData,&spDrvInfoData))
    {
        if (!SetupDiGetDriverInfoDetail(hDeviceInfoSet,pDeviceInfoData,&spDrvInfoData,NULL,0,&dwRequiredSize))
        {
            ec = GetLastError(); 
            if (ec==ERROR_INSUFFICIENT_BUFFER)
            {
                ec = NO_ERROR;
                if (pspDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA)MemAlloc(dwRequiredSize))
                {
                    pspDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                    if (SetupDiGetDriverInfoDetail(hDeviceInfoSet,pDeviceInfoData,&spDrvInfoData,pspDrvInfoDetailData,dwRequiredSize,NULL))
                    {
                        VERBOSE(DBG_MSG,_T("Driver Inf Name is: %s"),pspDrvInfoDetailData->InfFileName);
                        VERBOSE(DBG_MSG,_T("Driver Section Name is: %s"),pspDrvInfoDetailData->SectionName);
                        VERBOSE(DBG_MSG,_T("Driver Description is: %s"),pspDrvInfoDetailData->DrvDescription);
                        VERBOSE(DBG_MSG,_T("Driver Hardware ID is: %s"),pspDrvInfoDetailData->HardwareID);
                    }
                    else
                    {
                        ec = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetDriverInfoDetail"), ec);
                    }
                }
                else
                {
                    ec = ERROR_NOT_ENOUGH_MEMORY;
                    VERBOSE(GENERAL_ERR, TEXT("MemAlloc failed"));
                }
            }
            else
            {
                ec = GetLastError();
                CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetDriverInfoDetail"), ec);
            }
        }
        else
        {
            ec = ERROR_INVALID_PARAMETER;
            VERBOSE(GENERAL_ERR, TEXT("SetupDiGetDriverInfoDetail should have failed"));
        }
    }
    else
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetSelectedDriver"), ec);
    }

    return ec;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SearchModemInfFaxSection
//
//  Purpose:        
//                  Search the modem's INF to find if a Fax section exists.
//                  If a Fax section exists, try to find the InstallFax key
//                  If it's there, install Fax unattended.
//                  
//  Params:
//                  IN HDEVINFO hDeviceInfoSet              - passed from CoDevice Installer
//                  IN PSP_DEVINFO_DATA pDeviceInfoData     - passed from CoDevice Installer
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 28-Mar-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD SearchModemInfFaxSection
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData
)
{
    DWORD                   ec                      = NO_ERROR;
    DWORD                   Size                    = sizeof(DWORD);
    DWORD                   Type                    = 0;
    DWORD                   Value                   = 0;
    HKEY                    hDeviceKey              = NULL;
    HKEY                    hFaxKey                 = NULL;
    LPTSTR                  lptstrInstallFax        = NULL;

    DBG_ENTER(_T("SearchModemInfFaxSection"), ec);

    // get the device key under HKLM\SYSTEM\CurrentControlSet\Control\Class\ClassGUID\InstanceID
    hDeviceKey = SetupDiOpenDevRegKey(hDeviceInfoSet,pDeviceInfoData,DICS_FLAG_GLOBAL,0,DIREG_DRV,KEY_READ);
    if (hDeviceKey==NULL)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiOpenDevRegKey"), ec);
        goto exit;
    }
    // check if the Fax subkey exists.
    hFaxKey = OpenRegistryKey(hDeviceKey,_T("Fax"),FALSE,KEY_READ);
    if (hFaxKey==NULL)
    {
        VERBOSE(DBG_MSG, TEXT("This modem does not have a Fax section, exit..."));
        ec = NO_ERROR;
        goto exit;
    }
    // this modem has a Fax section.
    // let's check if it uses the 'InstallFax' REG_SZ
    lptstrInstallFax = GetRegistryString(hFaxKey,_T("InstallFax"),NULL);
    if (lptstrInstallFax==NULL)
    {
        VERBOSE(DBG_MSG, TEXT("This modem does not have an InstallFax REG_SZ in the Fax section, exit..."));
        ec = NO_ERROR;
        goto exit;
    }
    // check if the InstallFax is 0 (unlikely, but...)
    if (_tcsicmp(lptstrInstallFax,_T("0"))==0)
    {
        VERBOSE(DBG_MSG, TEXT("This modem does has an InstallFax=0 REG_SZ in the Fax section, exit..."));
        ec = NO_ERROR;
        goto exit;
    }
    //if (InSystemSetup(hDeviceInfoSet,pDeviceInfoData))
    {
        // if we're in system setup, we should just notify our component that it should install.
    }
    //else
    {
        // finally, Install Fax.
        ec = InstallFaxUnattended();
        if (ec!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("InstallFaxUnattended"), ec);
        }
    }

exit:

    if (hDeviceKey)
    {
        RegCloseKey(hDeviceKey);
    }
    if (hFaxKey)
    {
        RegCloseKey(hFaxKey);
    }
    return ec;
}

*/

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  HandleInstallDevice
//
//  Purpose:        
//                  Handles DIF_INSTALLDEVICE
//                  A new device has finished installing and we're allowed to install a printer
//                  if Fax is already on the box
//                  In this case we do the following:
//                  
//                  1. Check if Fax is installed, it it's not then attemp to install Fax based on INF
//                  2. Check if there's a Fax printer, if there is leave
//                  3. Install a Fax printer
//                  4. Ensure the service is up
//                  5. Leave
//                  
//  Params:
//                  IN HDEVINFO hDeviceInfoSet              - passed from CoDevice Installer
//                  IN PSP_DEVINFO_DATA pDeviceInfoData     - passed from CoDevice Installer
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Eran Yariv  (EranY)  17-Jul-2000
//                  Mooly Beery (MoolyB) 08-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD HandleInstallDevice
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData
)
{
    DWORD ec = NO_ERROR;
    BOOL  bFaxInstalled;
    BOOL  bLocalFaxPrinterInstalled;

    DBG_ENTER(_T("HandleInstallDevice"), ec);

    // Now we know a new modem installation succeeded.
    // Let's check if our component is installed.
    //

    ec = IsFaxInstalled(&bFaxInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("IsFaxInstalled"), ec);
        goto exit;
    }
    if (!bFaxInstalled)
    {
        VERBOSE(DBG_MSG,TEXT("Fax is not installed, search modem's INF for Fax section..."));
/*
        ec = SearchModemInfFaxSection(hDeviceInfoSet,pDeviceInfoData);
        if (ec!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("SearchModemInfFaxSection"), ec);
        }*/
        goto exit;
    }
    //
    // Let's see if we have a local fax printer
    //
    ec = IsLocalFaxPrinterInstalled (&bLocalFaxPrinterInstalled);
    if (ec!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("IsLocalFaxPrinterInstalled"), ec);
        goto exit;
    }
    if (bLocalFaxPrinterInstalled)
    {
        VERBOSE(DBG_MSG,TEXT("Fax Printer is installed, exit"));
        goto exit;
    }
    //
    // This is the time to install a local fax printer.
    //
    ec = AddLocalFaxPrinter (FAX_PRINTER_NAME, NULL);
    if (ERROR_SUCCESS != ec)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AddLocalFaxPrinter"), ec);
        goto exit;
    }
    //
    // Make sure the service is running.
    // This is important because there may have been jobs in the queue that now, when we have
    // a new modem device, can finally be executed.
    //
    if (!EnsureFaxServiceIsStarted (NULL))
    {
        ec = GetLastError ();
        CALL_FAIL (GENERAL_ERR, TEXT("EnsureFaxServiceIsStarted"), ec);
        goto exit;
    }

exit:
    return ec;
}   

/*
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  HandleNewDeviceWizardFinishInstall
//
//  Purpose:        
//                  Handles DIF_NEWDEVICEWIZARD_FINISHINSTALL
//                  A new device has finished installing and we're allowed to add a property page
//                  asking the user to install Fax
//                  In this case we do the following:
//                  
//                  1. Check if Fax is installed, if it is leave
//                  2. Check if we're allowed to add a property page, if not leave
//                  3. Add a property page to the wizard.
//                  4. Leave
//                  
//  Params:
//                  See CoClassInstaller documentation in DDK
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Eran Yariv  (EranY)  17-Jul-2000
//                  Mooly Beery (MoolyB) 08-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD HandleNewDeviceWizardFinishInstall
(
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
)
{
    DWORD                   ec                          = NO_ERROR;
    BOOL                    bFaxInstalled               = FALSE;
    TCHAR*                  WizardTitle                 = NULL;
    TCHAR*                  WizardSubTitle              = NULL;
    SP_NEWDEVICEWIZARD_DATA nddClassInstallParams       = {0};
    DWORD                   dwClassInstallParamsSize    = sizeof(SP_NEWDEVICEWIZARD_DATA);
    HPROPSHEETPAGE          hPsp                        = NULL;
    PROPSHEETPAGE           psp                         = {0};

    DBG_ENTER(_T("HandleNewDeviceWizardFinishInstall"), ec);

    if (!AllowInstallationProposal())
    {
        VERBOSE(DBG_MSG,TEXT("Not allowed to install, exit"));
        goto exit;
    }

    nddClassInstallParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

    // get the class install parameters by calling SetupDiGetClassInstallParams 
    if (!SetupDiGetClassInstallParams(  hDeviceInfoSet,
                                        pDeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&nddClassInstallParams,
                                        dwClassInstallParamsSize,
                                        NULL))
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("SetupDiGetClassInstallParams"), ec);
        goto exit;
    }

    // check whether NumDynamicPages has reached the max
    if (nddClassInstallParams.NumDynamicPages>=MAX_INSTALLWIZARD_DYNAPAGES)
    {
        VERBOSE (GENERAL_ERR, TEXT("Too many property pages, can't add another one"));
        ec = ERROR_BUFFER_OVERFLOW;
        goto exit;
    }
    // fill in the PROPSHEETPAGE structure
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance = faxocm_GetAppInstance();
    psp.pszTemplate = MAKEINTRESOURCE(IDD_INSTALL_FAX_PROP);
    psp.pfnDlgProc = prv_dlgInstallFaxQuestionPropPage;

    WizardTitle = (TCHAR*)MemAlloc(MAX_PATH * sizeof(TCHAR) );
    if(WizardTitle)
    {
        if (!LoadString(psp.hInstance, IDS_NEW_DEVICE_TITLE, WizardTitle, MAX_PATH))
        {
            ec = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ec);
            WizardTitle[0] = 0;
        }
        else
        {
            psp.pszHeaderTitle = WizardTitle;
        }
    }

    WizardSubTitle = (TCHAR*)MemAlloc(MAX_PATH * sizeof(TCHAR) );
    if(WizardSubTitle)
    {
        if (!LoadString(psp.hInstance, IDS_NEW_DEVICE_SUBTITLE, WizardSubTitle, MAX_PATH))
        {
            ec = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ec);
            WizardSubTitle[0] = 0;
        }
        else
        {
            psp.pszHeaderSubTitle = WizardSubTitle;
        }
    }
    // add the page and increment the NumDynamicPages counter
    hPsp = CreatePropertySheetPage(&psp);
    if (hPsp==NULL)
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("CreatePropertySheetPage"), ec);
        goto exit;
    }

    nddClassInstallParams.DynamicPages[nddClassInstallParams.NumDynamicPages++] = hPsp;

    // apply the modified params by calling SetupDiSetClassInstallParams
    if (!SetupDiSetClassInstallParams(  hDeviceInfoSet,
                                        pDeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&nddClassInstallParams,
                                        dwClassInstallParamsSize))
    {
        ec = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ec);
        goto exit;
    }

exit:

    return ec;
}   
*/
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FaxModemCoClassInstaller
//
//  Purpose:        
//                  Our Fax CoClassInstaller, handles newly discovered modems
//
//  Params:
//                  See CoClassInstaller documentation in DDK
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Eran Yariv  (EranY)  17-Jul-2000
//                  Mooly Beery (MoolyB) 08-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD CALLBACK FaxModemCoClassInstaller
(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO hDeviceInfoSet,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
)
{
    DWORD ec = NO_ERROR;

    DBG_ENTER(_T("FaxModemCoClassInstaller"), ec, TEXT("Processing %s request"), DifDebug[InstallFunction].DifString);

    //  We handle two events:
    //
    //  DIF_INSTALLDEVICE
    //  A new device has finished installing and we're allowed to install a printer
    //  if Fax is already on the box
    //  In this case we do the following:
    //
    //  1. Check if Fax is installed, if it's not leave
    //  2. Check if there's a Fax printer, if there is leave
    //  3. Install a Fax printer
    //  4. Ensure the service is up
    //  5. Leave
    //
    //  DIF_NEWDEVICEWIZARD_FINISHINSTALL
    //  A new device has finished installing and we're allowed to add a property page
    //  asking the user to install Fax
    //  In this case we do the following:
    //
    //  1. Check if Fax is installed, if it is leave
    //  2. Check if we're allowed to add a property page, if not leave
    //  3. Add a property page to the wizard.
    //  4. Leave
    switch (InstallFunction)
    {
        case DIF_INSTALLWIZARD:
            VERBOSE (DBG_MSG, L"Marking installation as potential non PnP");
            bIsPnpInstallation = false;
            break;

        case DIF_INSTALLDEVICE:                     
            if (!Context->PostProcessing) 
            {
                //
                // The modem device is not installed yet
                //
                VERBOSE (DBG_MSG, L"Pre-installation, waiting for post-installation call");
                ec = ERROR_DI_POSTPROCESSING_REQUIRED;
                return ec;
            }
            if (Context->InstallResult!=NO_ERROR) 
            {
                //
                // The modem device had some problems during installation
                //
                VERBOSE (DBG_MSG, L"Previous error causing installation failure, 0x%08x", Context->InstallResult);
                ec = Context->InstallResult;
                return ec;
            }
            if (HandleInstallDevice(hDeviceInfoSet,pDeviceInfoData)!=NO_ERROR)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("HandleInstallDevice"), GetLastError());
                // do not fail the CoClassInstaller
            }
            /* No UI until futher notice
            if (HandleNonPnpDevices()!=NO_ERROR)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("HandleNonPnpDevices"), GetLastError());
                // do not fail the CoClassInstaller
            }
            */
            break;

        case DIF_NEWDEVICEWIZARD_FINISHINSTALL:
            /* No UI until futher notice
            Assert(bIsPnpInstallation);
            if (HandleNewDeviceWizardFinishInstall(hDeviceInfoSet,pDeviceInfoData)!=NO_ERROR)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("HandleNewDeviceWizardFinishInstall"), GetLastError());
                // do not fail the CoClassInstaller
            }
            */
            break;

        default:
            VERBOSE(DBG_MSG,TEXT("We do not handle %s"),DifDebug[InstallFunction].DifString);
            break;
    }

    return ec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocsvc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocSvc.cpp
//
// Abstract:        This provides the Service routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

#include <Accctrl.h>
#include <Aclapi.h>

/////////////////////// Static Function Prototypes /////////////////////////

///////////////////////////////
// fxocSvc_Init
//
// Initialize the fax service
// setup subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Service Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocSvc_Term
//
// Terminate the fax service
// setup subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Service Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocSvc_Install
//
// Create/delete the fax service as
// specified in the INF file
// 
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF we are installing from
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Install(const TCHAR  *pszSubcomponentId,
                      const TCHAR  *pszInstallSection)
{
    DWORD                 dwReturn  = NO_ERROR;
    BOOL                  bSuccess  = FALSE;
    HINF                  hInf      = faxocm_GetComponentInf();
    OCMANAGER_ROUTINES    *pHelpers = faxocm_GetComponentHelperRoutines();

    DBG_ENTER(  _T("fxocSvc_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    if ((hInf               == NULL) ||
        (pszInstallSection  == NULL) ||
        (pHelpers           == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // attempt to install any Services specified in the Fax
    // install section in the INF file.  

    bSuccess = ::SetupInstallServicesFromInfSection(hInf, 
                                                    pszInstallSection,
                                                    0);
    if (bSuccess)
    {
        SC_ACTION Actions[] = 
            {
                {SC_ACTION_RESTART, 1000 * 60},  // Restart the service 1 minute after 1st failure
                {SC_ACTION_RESTART, 1000 * 60},  // Restart the service 1 minute after 2nd failure
                {SC_ACTION_NONE,    0}           // Do nothing for 3rd, 4th, ... failures
            };
            
        SERVICE_FAILURE_ACTIONS sfa = 
            {
                60 * 5,             // After 5 minutes, reset failures count
                NULL,               // Reboot message is unchanged
                NULL,               // No change in the run command
                ARR_SIZE (Actions), // Number of actions
                Actions             // Actions array
            };
                
        VERBOSE(DBG_MSG, 
                _T("Successfully installed fax service from ")
                _T("section '%s'"), 
                pszInstallSection);
        
        dwReturn = SetServiceFailureActions (NULL, FAX_SERVICE_NAME, &sfa);
        if (NO_ERROR == dwReturn)
        {
            VERBOSE(DBG_MSG,_T("Successfully set fax service failure actions..."));
            //
            // if this install is being done through the control panel via the 
            // Add/Remove Windows Components dialog (i.e. NOT a clean/upgrade install
            // of the OS), then start the service if a reboot is not required.

            // If this is not a stand alone install, then the machine will be rebooted
            // anyway so the fax service will auto-start.
            //
            if (fxState_IsStandAlone())
            {
                dwReturn = fxocSvc_StartFaxService();

                if (dwReturn == NO_ERROR)
                {
                    VERBOSE(DBG_MSG,_T("Successfully started fax service..."));
                }
                else
                {
                    VERBOSE(SETUP_ERR,
                            _T("Failed to start fax service, rc = 0x%lx"),
                            dwReturn);
                }
            }
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to set fax service failure actions, rc = 0x%lx"),
                    dwReturn);
        }
    }
    else
    {
        dwReturn = ::GetLastError();

        VERBOSE(SETUP_ERR,
                _T("Failed to install the services section in ")
                _T("section '%s', rc = 0x%lx"), 
                pszInstallSection,
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocSvc_Uninstall
//
// Delete the fax service as
// specified in the INF file
// 
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF we are installing from
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocSvc_Uninstall(const TCHAR  *pszSubcomponentId,
                        const TCHAR  *pszUninstallSection)
{
    DWORD dwReturn  = NO_ERROR;
    HINF  hInf      = faxocm_GetComponentInf();
    BOOL  bSuccess  = FALSE;

    DBG_ENTER(  _T("fxocSvc_Uninstall"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    if ((hInf                == NULL) ||
        (pszUninstallSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwReturn == NO_ERROR)
    {
        bSuccess = StopService(NULL, FAX_SERVICE_NAME, TRUE);

        if (!bSuccess)
        {
			dwReturn = GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("Uninstall failed to stop fax service, ec = 0x%lx, ")
                    _T("attempting to uninstall fax service anyway"),
                    dwReturn);
        }

        bSuccess = ::SetupInstallServicesFromInfSection(hInf, 
                                                        pszUninstallSection,
                                                        0);

        if (bSuccess)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully uninstalled service ")
                    _T("from section '%s'"), 
                    pszUninstallSection);
        }
        else
        {
            dwReturn = ::GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall ")
                    _T("service, SubcomponentId = '%s', ")
                    _T("uninstall Section = '%s', rc = 0x%lx"),
                    pszSubcomponentId,
                    pszUninstallSection,
                    dwReturn);
        }
    }

    return dwReturn;
}

///////////////////////////////
// fxocSvc_StartFaxService
//
// Start the fax service 
// specified in the given
// INF file's section.
//
// Params:
//      None
//
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocSvc_StartFaxService()
{
    DWORD               dwReturn                    = NO_ERROR;

    DBG_ENTER(  _T("fxocSvc_StartFaxService"),
                dwReturn);

    if (!EnsureFaxServiceIsStarted (NULL))
    {
        dwReturn = GetLastError ();
    }
    return dwReturn;
}


///////////////////////////////
// fxocSvc_StartService
//
// Start the specified service 
//
// Params:
//      - pszServiceName
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocSvc_StartService(const TCHAR *pszServiceName)
{
    BOOL                bSuccess    = FALSE;
    DWORD               dwReturn    = NO_ERROR;
    SC_HANDLE           hSvcMgr     = NULL;
    SC_HANDLE           hService    = NULL;

    DBG_ENTER(  _T("fxocSvc_StartService"),
                dwReturn,
                _T("%s"),
                pszServiceName);

    // open the service manager
    hSvcMgr = ::OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_ALL_ACCESS);

    if (hSvcMgr == NULL)
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to open the service manager, rc = 0x%lx"),
                dwReturn);
    }

    if (dwReturn == NO_ERROR)
    {
        hService = ::OpenService(hSvcMgr,
                                 pszServiceName,
                                 SERVICE_ALL_ACCESS);

        if (hService == NULL)
        {
            dwReturn = ::GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("fxocSvc_StartService, Failed to open service ")
                    _T("'%s', rc = 0x%lx"), 
                    pszServiceName,
                    dwReturn);
        }
    }

    // Start the fax service.
    if (dwReturn == NO_ERROR)
    {
        bSuccess = StartService(hService, 0, NULL);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();
            if (dwReturn == ERROR_SERVICE_ALREADY_RUNNING)
            {
                dwReturn = NO_ERROR;
            }
            else
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to start service '%s', ")
                        _T("rc = 0x%lx"), 
                        pszServiceName, 
                        dwReturn);
            }
        }
    }

    if (dwReturn == NO_ERROR)
    {
        SERVICE_STATUS Status;
        int i = 0;

        do 
        {
            QueryServiceStatus(hService, &Status);
            i++;

            if (Status.dwCurrentState != SERVICE_RUNNING)
            {
                Sleep(1000);
            }

        } while ((i < 60) && (Status.dwCurrentState != SERVICE_RUNNING));

        if (Status.dwCurrentState != SERVICE_RUNNING)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start '%s' service"),
                    pszServiceName);
        }
    }

    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hSvcMgr)
    {
        CloseServiceHandle(hSvcMgr);
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocupgrade.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	fxocUpgrade.h

Abstract:

	Header file for Upgrade process

Author:

	Iv Garber (IvG)	Mar, 2001

Revision History:

--*/

#ifndef _FXOCUPGRADE_H_
#define _FXOCUPGRADE_H_

//
//  MSI DLL is used for checking the SBS 5.0 Client presence on the system
//
#include "faxSetup.h"


/**
    Following functions are used at OS Upgrade, where Windows XP Fax should replace other 
        installed Fax applications.

    The process is as following :
        fxocUpg_Init() will check which Fax applications are installed.

        fxocUpg_SaveSettings() will save different settings of these old Fax applications. 

        fxocUpg_MoveFiles() will move files of these old Fax applications to new places.

        fxocUpg_RestoreSettings() will restore back the settings that were stored at the SaveSettings().

		fxocUpg_MoveRegistry() will migrate existing registry to the fax service
**/


DWORD   fxocUpg_Init(void);
DWORD   fxocUpg_MoveFiles(void);
DWORD   fxocUpg_SaveSettings(void);
DWORD   fxocUpg_RestoreSettings(void);          
DWORD   fxocUpg_WhichFaxWasUninstalled(DWORD dwFaxAppList);
DWORD   fxocUpg_GetUpgradeApp(void);
DWORD   fxocUpg_MoveRegistry(void);

#define UNINSTALL_TIMEOUT           5 * 60 * 1000       //  5 minutes in milliseconds
#define MAX_SETUP_STRING_LEN        256


#define CP_PREFIX_W2K               _T("Win2K")
#define CP_PREFIX_SBS               _T("SBS")


#define FAXOCM_NAME                 _T("FAXOCM.DLL")
#define CPDIR_RESOURCE_ID           627


#define REGKEY_PFW_ROUTING          _T("Routing")
#define REGKEY_SBS50SERVER          _T("Software\\Microsoft\\SharedFax")


#define REGVAL_PFW_OUTBOXDIR        _T("ArchiveDirectory")
#define REGVAL_PFW_INBOXDIR         _T("Store Directory")


#endif  // _FXOCUPGRADE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocupgrade.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    fxocUpgrade.cpp

Abstract:

    Implementation of the Upgrade process

Author:

    Iv Garber (IvG) Mar, 2001

Revision History:

--*/

#include "faxocm.h"
#pragma hdrstop

#include <setuputil.h>
#include <shlwapi.h>  // For SHCopyKey

DWORD g_LastUniqueLineId = 0;
//
//  EnumDevicesType is used to call prv_StoreDevices() callback function during the Enumeration of
//      Devices in the Registry.
//
typedef enum prv_EnumDevicesType
{
    edt_None        =   0x00,
    edt_PFWDevices  =   0x02,       //  Enumerate W2K Fax Devices
    edt_Inbox       =   0x04        //  Find List of Inbox Folders for W2K Fax
};


//
//  Local Static Variable, to store data between OS Manager calls
//
static struct prv_Data
{
	DWORD	dwFaxInstalledPriorUpgrade;	//	bit-wise combination of fxState_UpgradeApp_e values to define
										//	which fax clients were installed on the machine prior to upgrade
    //
    //  data for PFW
    //
    TCHAR   tszCommonCPDir[MAX_PATH];   //  Folder for Common Cover Pages 
    LPTSTR  *plptstrInboxFolders;       //  Array of different Inbox Folders 
    DWORD   dwInboxFoldersCount;        //  number of Inbox Folders in the plptstrInboxFolders array

} prv_Data = 
{
	FXSTATE_NONE,	//	no fax client applications is installed by default
    {0},            //  tszCommonCPDir
    NULL,           //  plptstrInboxFolders
    0               //  dwInboxFoldersCount
};

//
//  Internal assisting functions
//

BOOL prv_StoreDevices(HKEY hKey, LPWSTR lpwstrKeyName, DWORD dwIndex, LPVOID lpContext);

static DWORD prv_MoveCoverPages(LPTSTR lptstrSourceDir, LPTSTR lptstrDestDir, LPTSTR lptstrPrefix);

static DWORD prv_GetPFWCommonCPDir(void);
static DWORD prv_GetSBSServerCPDir(LPTSTR lptstrCPDir) {return NO_ERROR; };

static DWORD prv_SaveArchives(void);


DWORD fxocUpg_WhichFaxWasUninstalled(
    DWORD   dwFaxAppList
)
/*++

Routine name : fxocUpg_WhichFaxWasUninstalled

Routine description:

    Set flags regarding fax applications installed before upgrade. Called from SaveUnattendedData() if 
    the corresponding data is found in the Answer File.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    FaxApp      [in]    - the combination of the applications that were installed before the upgrade

Return Value:

    Standard Win32 error code

--*/
{
    DWORD   dwReturn = NO_ERROR;

    DBG_ENTER(_T("fxocUpg_WhichFaxWasUninstalled"), dwReturn);

	prv_Data.dwFaxInstalledPriorUpgrade = dwFaxAppList;

    return dwReturn;
}


DWORD fxocUpg_GetUpgradeApp(void)
/*++

Routine name : fxocUpg_GetUpgradeApp

Routine description:

    Return type of the upgrade, which indicates which fax applications were installed before the upgrade.

Author:

    Iv Garber (IvG),    May, 2001

Return Value:

    The type of the upgrade

--*/
{
    DBG_ENTER(_T("fxocUpg_GetUpgradeApp"), prv_Data.dwFaxInstalledPriorUpgrade);
	return prv_Data.dwFaxInstalledPriorUpgrade;
}


DWORD fxocUpg_Init(void)
/*++

Routine name : fxocUpg_Init

Routine description:

    checks which Fax applications are installed on the machine, 
    and set global flags in prv_Data.

Author:

    Iv Garber (IvG),    May, 2001

Return Value:

    DWORD - failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;
	bool	bInstalled = false; 
                                                  
    DBG_ENTER(_T("fxocUpg_Init"), dwReturn);

    //
    //  Clear the SBS 5.0 Server flag
    //
	prv_Data.dwFaxInstalledPriorUpgrade = FXSTATE_NONE;

    //
    //  Check presence of the SBS 5.0 Server 
    //
    dwReturn = WasSBS2000FaxServerInstalled(&bInstalled);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_WARNING, _T("CheckInstalledFax() failed, ec=%ld."), dwReturn);
    }

	if (bInstalled)
	{
        prv_Data.dwFaxInstalledPriorUpgrade |= FXSTATE_SBS5_SERVER;
	}

    return dwReturn;
}


DWORD fxocUpg_SaveSettings(void)
/*++

Routine name : fxocUpg_SaveSettings

Routine description:

    Save settings of SBS 5.0 Server to allow smooth migration to the Windows XP Fax.

    Device Settings should be stored BEFORE handling of the Registry ( which deletes the Devices key )
        and BEFORE the Service Start ( which creates new devices and uses settings that are stored here ).

Author:

    Iv Garber (IvG),    May, 2001

Return Value:

    DWORD   -   failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;
    DWORD   dwEnumType  = edt_None;

    DBG_ENTER(_T("fxocUpg_SaveSettings"), dwReturn);

    //
    //  Handle Upgrade from W2K/PFW Fax
    //
    if (fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_W2K)
    {
        //
        //  Save its Common CP Dir. This should be done BEFORE Copy/Delete Files of Windows XPFax.
        //
        dwReturn = prv_GetPFWCommonCPDir();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_GetPFWCommonCPDir() failed, ec=%ld."), dwReturn);
        }

        //
        //  Store Device Settings of PFW -- if SBS 5.0 Server is not present on the machine.
        //  Also, find Inbox Folders List of the PFW Devices.
        //
        HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ);
        if (!hKey)
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to open Registry for Fax, ec = %ld."), dwReturn);
            return dwReturn;
        }

        if (prv_Data.dwFaxInstalledPriorUpgrade & FXSTATE_SBS5_SERVER)
        {
            //
            //  Devices already enumerated, through SBS 5.0 Server
            //  Enumerate only Inbox Folders
            //
            dwEnumType = edt_Inbox;
        }
        else
        {
            //
            //  Full Enumeration for PFW Devices : Devices Settings + Inbox Folders
            //
            dwEnumType = edt_PFWDevices | edt_Inbox;
        }
        
        dwReturn = EnumerateRegistryKeys(hKey, REGKEY_DEVICES, FALSE, prv_StoreDevices, &dwEnumType);
        VERBOSE(DBG_MSG, _T("For PFW, enumerated %ld devices."), dwReturn);

        RegCloseKey(hKey);

        //
        //  prv_StoreDevices stored list of PFW's Inbox Folders in prv_Data.
        //  Now save the Inbox Folders List and SentItems Folder
        //
        dwReturn = prv_SaveArchives();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_SaveArchives() failed, ec=%ld."), dwReturn);
        }

        dwReturn = NO_ERROR;
    }

    return dwReturn;
}
 
BOOL
prv_StoreDevices(HKEY hDeviceKey,
                LPWSTR lpwstrKeyName,
                DWORD dwIndex,
                LPVOID lpContextData
)
/*++

Routine name : prv_StoreDevices

Routine description:

    Callback function used in enumeration of devices in the registry.

    Stores device's data in the Registry, under Setup/Original Setup Data.
    Creates List of Inbox Folders ( used for PFW ) and saves it in the prv_Data.

    Used when upgrading from PFW/SBS 5.0 Server to Windows XP Fax.

Author:

    Iv Garber (IvG),    Mar, 2001

Arguments:

    hKey            [in]    - current key
    lpwstrKeyName   [in]    - name of the current key, if exists
    dwIndex         [in]    - count of all the subkeys for the given key / index of the current key
    lpContextData   [in]    - NULL, not used

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    HKEY    hSetupKey = NULL;
    DWORD   dwReturn = NO_ERROR;
    DWORD   dwNumber = 0;
    TCHAR   tszNewKeyName[MAX_PATH] = {0};
    LPTSTR  lptstrString = NULL;
    DWORD   *pdwEnumType = NULL;

    DBG_ENTER(_T("prv_StoreDevices"));

    if (lpwstrKeyName == NULL) 
    {
        //
        //  This is the SubKey we started at ( i.e. Devices )
        //  
        //  If InboxFolders should be stored, then allocate 
        //      enough memory for prv_Data.plptstrInboxFolders.
        //  dwIndex contains TOTAL number of subkeys ( Devices ).
        //
        pdwEnumType = (DWORD *)lpContextData;

        if ( (*pdwEnumType & edt_Inbox) == edt_Inbox )
        {
            prv_Data.plptstrInboxFolders = (LPTSTR *)MemAlloc(sizeof(LPTSTR) * dwIndex);
            if (prv_Data.plptstrInboxFolders)
            {
                ZeroMemory(prv_Data.plptstrInboxFolders, sizeof(LPTSTR) * dwIndex);
            }
            else
            {
                //
                //  Not enough memory
                //
                VERBOSE(DBG_WARNING, _T("Not enough memory to store the Inbox Folders."));
            }
        }

        return TRUE;
    }

    //
    //  The per Device section
    //

    //
    //  Store Device's Inbox Folder
    //
    if (prv_Data.plptstrInboxFolders)
    {
        //
        //  we are here only when lpContextData contains edt_InboxFolders
        //      and the memory allocation succeded.
        //

        //
        //  Open Routing SubKey 
        //
        hSetupKey = OpenRegistryKey(hDeviceKey, REGKEY_PFW_ROUTING, FALSE, KEY_READ);
        if (!hSetupKey)
        {
            //
            //  Failed to open Routing Subkey
            //
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to open 'Registry' Key for Device #ld, ec = %ld."), dwIndex, dwReturn);
            goto ContinueStoreDevice;
        }

        //
        //  Take 'Store Directory' Value
        //
        lptstrString = GetRegistryString(hSetupKey, REGVAL_PFW_INBOXDIR, EMPTY_STRING);
        if ((!lptstrString) || (_tcslen(lptstrString) == 0))
        {
            //
            //  Failed to take the value
            //
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("Failed to get StoreDirectory value for Device #ld, ec = %ld."), dwIndex, dwReturn);
            goto ContinueStoreDevice;
        }

        //
        //  Check if it is already present
        //
        DWORD dwI;
        for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
        {
            if (prv_Data.plptstrInboxFolders[dwI])
            {
                if (_tcscmp(prv_Data.plptstrInboxFolders[dwI], lptstrString) == 0)
                {
                    //
                    //  String found
                    //
                    goto ContinueStoreDevice;
                }
            }
        }

        //
        //  String was NOT found between all already registered string, so add it
        //
        prv_Data.plptstrInboxFolders[dwI] = LPTSTR(MemAlloc(sizeof(TCHAR) * (_tcslen(lptstrString) + 1)));
        if (prv_Data.plptstrInboxFolders[dwI])
        {
            //
            //  copy string & update the counter
            //
            _tcscpy(prv_Data.plptstrInboxFolders[dwI], lptstrString);
            prv_Data.dwInboxFoldersCount++;
        }
        else
        {
            //
            //  Not enough memory
            //
            VERBOSE(DBG_WARNING, _T("Not enough memory to store the Inbox Folders."));
        }

ContinueStoreDevice:

        if (hSetupKey)
        {
            RegCloseKey(hSetupKey);
            hSetupKey = NULL;
        }

        MemFree(lptstrString);
        lptstrString = NULL;
    }

    //
    //  Check whether to store Device's Data and how
    //
    pdwEnumType = (DWORD *)lpContextData;

    if ((*pdwEnumType & edt_PFWDevices) == edt_PFWDevices)
    {
        //
        //  Store PFW Devices Data
        //
        lptstrString = REGVAL_PERMANENT_LINEID;
    }
    else
    {
        //
        //  no need to save any Device Data
        //
        return TRUE;
    }

    //
    //  Take Device's Permanent Line Id
    //
    dwReturn = GetRegistryDwordEx(hDeviceKey, lptstrString, &dwNumber);
    if (dwReturn != ERROR_SUCCESS)
    {
        //
        //  Cannot find TAPI Permanent LineId --> This is invalid Device Registry
        //
        return TRUE;
    }

    VERBOSE(DBG_MSG, _T("Current Tapi Line Id = %ld"), dwNumber);

    //
    //  Create a SubKey Name from it
    //
    _sntprintf(
		tszNewKeyName, 
		ARR_SIZE(tszNewKeyName) -1, 
		TEXT("%s\\%010d"), 
		REGKEY_FAX_SETUP_ORIG, 
		dwNumber);
    hSetupKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, tszNewKeyName, TRUE, 0);
    if (!hSetupKey)
    {
        //
        //  Failed to create registry key
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, 
            _T("Failed to create a SubKey for the Original Setup Data of the Device, ec = %ld."), 
            dwReturn);

        //
        //  Continue to the next device
        //
        return TRUE;
    }

    //
    //  Set the Flags for the newly created key
    //
    dwNumber = GetRegistryDword(hDeviceKey, REGVAL_FLAGS);
    SetRegistryDword(hSetupKey, REGVAL_FLAGS, dwNumber);
    VERBOSE(DBG_MSG, _T("Flags are : %ld"), dwNumber);

    //
    //  Set the Rings for the newly created key
    //
    dwNumber = GetRegistryDword(hDeviceKey, REGVAL_RINGS);
    SetRegistryDword(hSetupKey, REGVAL_RINGS, dwNumber);
    VERBOSE(DBG_MSG, _T("Rings are : %ld"), dwNumber);

    //
    //  Set the TSID for the newly created key
    //
    lptstrString = GetRegistryString(hDeviceKey, REGVAL_ROUTING_TSID, REGVAL_DEFAULT_TSID);
    SetRegistryString(hSetupKey, REGVAL_ROUTING_TSID, lptstrString);
    VERBOSE(DBG_MSG, _T("TSID is : %s"), lptstrString);
    MemFree(lptstrString);

    //
    //  Set the CSID for the newly created key
    //
    lptstrString = GetRegistryString(hDeviceKey, REGVAL_ROUTING_CSID, REGVAL_DEFAULT_CSID);
    SetRegistryString(hSetupKey, REGVAL_ROUTING_CSID, lptstrString);
    VERBOSE(DBG_MSG, _T("CSID is : %s"), lptstrString);
    MemFree(lptstrString);

    RegCloseKey(hSetupKey);
    return TRUE;
}


DWORD fxocUpg_RestoreSettings(void) 
/*++

Routine name : fxocUpg_RestoreSettings

Routine description:

    Restore settings that were stored at the SaveSettings().

Author:

    Iv Garber (IvG),    Feb, 2001

Return Value:

    DWORD - failure or success

--*/
{ 
    DWORD   dwReturn = NO_ERROR;
    HANDLE  hPrinter = NULL;

    DBG_ENTER(_T("fxocUpg_RestoreSettings"), dwReturn);

    return dwReturn;
}



DWORD fxocUpg_MoveFiles(void)
/*++

Routine name : fxocUpg_MoveFiles

Routine description:

    Move files from the folders that should be deleted.
    Should be called BEFORE directories delete.

Author:

    Iv Garber (IvG),    Feb, 2001

Return Value:

    DWORD - failure or success

--*/
{
    DWORD   dwReturn = NO_ERROR;
    TCHAR   tszDestination[MAX_PATH] = {0};
    LPTSTR  lptstrCPDir = NULL;

    DBG_ENTER(_T("fxocUpg_MoveFiles"), dwReturn);

    if ( (fxState_IsUpgrade() != FXSTATE_UPGRADE_TYPE_W2K) && 
		 !(prv_Data.dwFaxInstalledPriorUpgrade & FXSTATE_SBS5_SERVER) )
    {
        //
        //  This is not PFW / SBS 5.0 Server upgrade. Do nothing
        //
        VERBOSE(DBG_MSG, _T("No need to Move any Files from any Folders."));
        return dwReturn;
    }

    //
    //  Find Destination Folder : COMMON APP DATA + ServiceCPDir from the Registry
    //
    if (!GetServerCpDir(NULL, tszDestination, MAX_PATH))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("GetServerCPDir() failed, ec=%ld."), dwReturn);
        return dwReturn;
    }

    if (fxState_IsUpgrade() == FXSTATE_UPGRADE_TYPE_W2K)
    {
        //
        //  PFW Server CP Dir is stored at SaveSettings() in prv_Data.lptstrPFWCommonCPDir
        //
        dwReturn = prv_MoveCoverPages(prv_Data.tszCommonCPDir, tszDestination, CP_PREFIX_W2K);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_MoveCoverPages() for Win2K failed, ec = %ld"), dwReturn);
        }
    }

    if (prv_Data.dwFaxInstalledPriorUpgrade & FXSTATE_SBS5_SERVER)
    {
        //
        //  Get SBS Server CP Dir
        //
        dwReturn = prv_GetSBSServerCPDir(lptstrCPDir);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_GetSBSServerCPDir() failed, ec=%ld"), dwReturn);
            return dwReturn;
        }

        //
        //  Move Cover Pages
        //
        dwReturn = prv_MoveCoverPages(lptstrCPDir, tszDestination, CP_PREFIX_SBS);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING, _T("prv_MoveCoverPages() for SBS failed, ec = %ld"), dwReturn);
        }

        MemFree(lptstrCPDir);
    }

    return dwReturn;
}


static DWORD
prv_MoveCoverPages(
    LPTSTR lptstrSourceDir,
    LPTSTR lptstrDestDir,
    LPTSTR lptstrPrefix
)
/*++

Routine name : prv_MoveCoverPages

Routine description:

    Move all the Cover Pages from Source folder to Destination folder
    and add a prefix to all the Cover Page names.

Author:

    Iv Garber (IvG),    Mar, 2001

Arguments:

    lptstrSourceDir              [IN]    - Source Directory where Cover Pages are reside before the upgrade
    lptstrDestDir                [IN]    - where the Cover Pages should reside after the upgrade
    lptstrPrefix                 [IN]    - prefix that should be added to the Cover Page file names

Return Value:

    Success or Failure Error Code.

--*/
{
    DWORD           dwReturn            = ERROR_SUCCESS;
    TCHAR           szSearch[MAX_PATH]  = {0};
    HANDLE          hFind               = NULL;
    WIN32_FIND_DATA FindFileData        = {0};
    TCHAR           szFrom[MAX_PATH]    = {0};
    TCHAR           szTo[MAX_PATH]      = {0};

    DBG_ENTER(_T("prv_MoveCoverPages"), dwReturn);

    if ((!lptstrSourceDir) || (_tcslen(lptstrSourceDir) == 0))
    {
        //
        //  we do not know from where to take Cover Pages 
        //
        dwReturn = ERROR_INVALID_PARAMETER;
        VERBOSE(DBG_WARNING, _T("SourceDir is NULL. Cannot move Cover Pages. Exiting..."));
        return dwReturn;
    }

    if ((!lptstrDestDir) || (_tcslen(lptstrDestDir) == 0))
    {
        //
        //  we do not know where to put the Cover Pages
        //
        dwReturn = ERROR_INVALID_PARAMETER;
        VERBOSE(DBG_WARNING, _T("DestDir is NULL. Cannot move Cover Pages. Exiting..."));
        return dwReturn;
    }

    //
    //  Find all Cover Page files in the given Source Directory
    //
    _sntprintf(
		szSearch, 
		ARR_SIZE(szSearch) -1, 
		_T("%s\\*.cov"), 
		lptstrSourceDir);

    hFind = FindFirstFile(szSearch, &FindFileData);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, 
            _T("FindFirstFile() on %s folder for Cover Pages is failed, ec = %ld"), 
            lptstrSourceDir,
            dwReturn);
        return dwReturn;
    }

    //
    //  Go for each Cover Page 
    //
    do
    {
        //
        //  This is full current Cover Page file name
        //
        _sntprintf(szFrom, ARR_SIZE(szFrom) -1, _T("%s\\%s"), lptstrSourceDir, FindFileData.cFileName);

        //
        //  This is full new Cover Page file name
        //
        _sntprintf(szTo, ARR_SIZE(szTo) -1, _T("%s\\%s_%s"), lptstrDestDir, lptstrPrefix, FindFileData.cFileName);

        //
        //  Move the file
        //
        if (!MoveFile(szFrom, szTo))
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("MoveFile() for %s Cover Page failed, ec=%ld"), szFrom, dwReturn);
        }

    } while(FindNextFile(hFind, &FindFileData));

    VERBOSE(DBG_MSG, _T("last call to FindNextFile() returns %ld."), GetLastError());

    //
    //  Close Handle
    //
    FindClose(hFind);

    return dwReturn;
}


static DWORD prv_GetPFWCommonCPDir(
) 
/*++

Routine name : prv_GetPFWCommonCPDir

Routine description:

    Return Folder for Common Cover Pages used for PFW.

    This Folder is equal to : CSIDL_COMMON_DOCUMENTS + Localized Dir
    This Localized Dir name we can take from the Resource of Win2K's FaxOcm.Dll.
    So, this function should be called BEFORE Copy/Delete Files of Install that will remove old FaxOcm.Dll.
    Currently it is called at SaveSettings(), which IS called before CopyFiles.

Author:

    Iv Garber (IvG),    Mar, 2001

Return Value:

    static DWORD    --  failure or success

--*/
{
    DWORD   dwReturn            = NO_ERROR;
    HMODULE hModule             = NULL;
    TCHAR   tszName[MAX_PATH]   = {0};

    DBG_ENTER(_T("prv_GetPFWCommonCPDir"), dwReturn);

    //
    //  find full path to FaxOcm.Dll
    //
    if (!GetSpecialPath(CSIDL_SYSTEM, tszName, ARR_SIZE(tszName)))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("GetSpecialPath(CSIDL_SYSTEM) failed, ec = %ld"), dwReturn);
        return dwReturn;
    }

    if ((_tcslen(tszName) + _tcslen(FAXOCM_NAME) + 1 ) >= ARR_SIZE(tszName))  // 1 for '\'
    {
        //
        //  not enough place
        //
        dwReturn = ERROR_OUTOFMEMORY;
        VERBOSE(DBG_WARNING, _T("FaxOcm.Dll path is too long, ec = %ld"), dwReturn);
        return dwReturn;
    }

    _tcscat(tszName, _T("\\"));
    _tcscat(tszName, FAXOCM_NAME);

    VERBOSE(DBG_MSG, _T("Full Name of FaxOcm is %s"), tszName);

    hModule = LoadLibraryEx(tszName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (!hModule)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("LoadLibrary(%s) failed, ec = %ld."), tszName, dwReturn);
        return dwReturn;
    }

    dwReturn = LoadString(hModule, CPDIR_RESOURCE_ID, tszName, MAX_PATH);
    if (dwReturn == 0)
    {
        //
        //  Resource string is not found
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("LoadString() failed, ec = %ld."), dwReturn);
        goto Exit;
    }

    VERBOSE(DBG_MSG, _T("FaxOcm returned '%s'"), tszName);

    //
    //  Take the Base part of the Folder name
    //
    if (!GetSpecialPath(CSIDL_COMMON_DOCUMENTS, prv_Data.tszCommonCPDir,ARR_SIZE(prv_Data.tszCommonCPDir)))
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("GetSpecialPath(CSIDL_COMMON_DOCUMENTS) failed, ec = %ld"), dwReturn);
        prv_Data.tszCommonCPDir[0] = _T('\0');
        goto Exit;
    }

    //
    //  Combine the full Folder name
    //
    if ((_tcslen(tszName) + _tcslen(prv_Data.tszCommonCPDir) + 1) >= ARR_SIZE(prv_Data.tszCommonCPDir)) // 1 for '\'
    {
        //
        //  not enough place
        //
        dwReturn = ERROR_OUTOFMEMORY;
        VERBOSE(DBG_WARNING, _T("Full path to the Common CP dir for PFW is too long, ec = %ld"), dwReturn);
        goto Exit;
    }

    _tcscat(prv_Data.tszCommonCPDir,_T("\\"));
    _tcscat(prv_Data.tszCommonCPDir, tszName);

    VERBOSE(DBG_MSG, _T("Full path for Common PFW Cover Pages is '%s'"), prv_Data.tszCommonCPDir);

Exit:
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return dwReturn; 
}

static DWORD prv_SaveArchives(
) 
/*++

Routine name : prv_SaveArchives

Routine description:

    Store PFW SentItems & Inbox Archive Folder. 

    SentItems is taken from Registry : under Fax/Archive Directory.

    Inbox Folders List is created by prv_StoreDevices(), that should be called before and that fills
        prv_Data.plptstrInboxFolder with an array of Inbox Folders.
    This function transforms the data in prv_Data.plptstrInboxFolders into the required format,
        and stores in the Registry.

    Frees the prv_Data.plptstrInboxFolders.

Author:

    Iv Garber (IvG),    Mar, 2001

Return Value:

    static DWORD    --  failure or success

--*/
{
    DWORD   dwReturn        = NO_ERROR;
    DWORD   dwListLen       = 0;
    DWORD   dwI             = 0;
    HKEY    hFromKey        = NULL;
    HKEY    hToKey          = NULL;
    LPTSTR  lptstrFolder    = NULL;
    LPTSTR  lptstrCursor    = NULL;

    DBG_ENTER(_T("prv_SaveArchives"), dwReturn);

    //
    //  Open Registry Key to read the ArchiveDirectory value
    //
    hFromKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ);
    if (!hFromKey)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to open Registry for Fax, ec = %ld."), dwReturn);
        goto Exit;
    }

    //
    //  Open Registry Key to write the Archive values
    //
    hToKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, FALSE, KEY_SET_VALUE);
    if (!hToKey)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to open Registry for Fax/Setup, ec = %ld."), dwReturn);
        goto Exit;
    }

    //
    //  Read & Write Outgoing Archive Folder
    //
    lptstrFolder = GetRegistryString(hFromKey, REGVAL_PFW_OUTBOXDIR, EMPTY_STRING);
    VERBOSE(DBG_MSG, _T("Outgoing Archive Folder is : %s"), lptstrFolder);
    SetRegistryString(hToKey, REGVAL_W2K_SENT_ITEMS, lptstrFolder);
    MemFree(lptstrFolder);
    lptstrFolder = NULL;

    //
    //  Create valid REG_MULTI_SZ string from List of Inbox Folders 
    //
    if (!prv_Data.plptstrInboxFolders || prv_Data.dwInboxFoldersCount == 0)
    {
        //
        //  no Inbox Folders found
        //
        goto Exit;
    }

    //
    //  Calculate the length of the string 
    //
    for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
    {
        dwListLen += _tcslen(prv_Data.plptstrInboxFolders[dwI]) + 1;
    }

    //
    //  Allocate that string
    //
    lptstrFolder = LPTSTR(MemAlloc((dwListLen + 1) * sizeof(TCHAR)));
    if (!lptstrFolder)
    {
        //
        //  Not enough memory
        //
        VERBOSE(DBG_WARNING, _T("Not enough memory to store the Inbox Folders."));
        goto Exit;
    }
    
    ZeroMemory(lptstrFolder, ((dwListLen + 1) * sizeof(TCHAR)));

    lptstrCursor = lptstrFolder;

    //
    //  Fill with the Inbox Folders
    //
    for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
    {
        if (prv_Data.plptstrInboxFolders[dwI])
        {
            _tcscpy(lptstrCursor, prv_Data.plptstrInboxFolders[dwI]);
            lptstrCursor += _tcslen(prv_Data.plptstrInboxFolders[dwI]) + 1;
            MemFree(prv_Data.plptstrInboxFolders[dwI]);
        }
    }
    MemFree(prv_Data.plptstrInboxFolders);
    prv_Data.plptstrInboxFolders = NULL;
    prv_Data.dwInboxFoldersCount = 0;

    //
    //  Additional NULL at the end
    //
    *lptstrCursor = _T('\0');

    if (!SetRegistryStringMultiSz(hToKey, REGVAL_W2K_INBOX, lptstrFolder, ((dwListLen + 1) * sizeof(TCHAR))))
    {
        //
        //  Failed to store Inbox Folders
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("Failed to SetRegistryStringMultiSz() for W2K_Inbox, ec = %ld."), dwReturn);
    }

Exit:

    if (hFromKey)
    {
        RegCloseKey(hFromKey);
    }

    if (hToKey)
    {
        RegCloseKey(hToKey);
    }

    MemFree(lptstrFolder);

    if (prv_Data.plptstrInboxFolders)
    {
        for ( dwI = 0 ; dwI < prv_Data.dwInboxFoldersCount ; dwI++ )
        {
            MemFree(prv_Data.plptstrInboxFolders[dwI]);
        }

        MemFree(prv_Data.plptstrInboxFolders);
        prv_Data.plptstrInboxFolders = NULL;
    }

    prv_Data.dwInboxFoldersCount = 0;

    return dwReturn;
}


/*++
Routine description:
    Copy a content of one registry key into another, using shlwapi.dll

Arguments:
    hkeyDest    [in]        - handle for destination registry key
    lpszDestSubKeyName [in] - name of destination subkey
    hkeySrc     [in]        - handle for source registry key
    lpszSrcSubKeyName [in]  - name of source subkey

Return Value: Win32 Error code

Note:
    If you already have an open handle to the source\dest, you can provide
    them are hKeySrc/hKeyDest, and set the approriate name to "".
--*/
DWORD
CopyRegistrySubkeys2(
    HKEY    hKeyDest,
    LPCTSTR lpszDestSubKeyName,
    HKEY    hKeySrc,
    LPCTSTR lpszSrcSubKeyName
    )
{
    DWORD   ec = ERROR_SUCCESS;
    HKEY    hKeyDestReal = NULL;

    //  Create destination Key
    hKeyDestReal = OpenRegistryKey( 
                    hKeyDest, 
                    lpszDestSubKeyName, 
                    TRUE,                  // create
                    KEY_WRITE);
    if (!hKeyDestReal)
    {
        ec = GetLastError();
        goto exit;
    }

    //
    //  copy subkeys recursively
    //
    ec = SHCopyKey(hKeySrc, lpszSrcSubKeyName, hKeyDestReal, 0);
    if (ERROR_SUCCESS != ec)
    {
        goto exit;
    }

exit:
    if (NULL != hKeyDestReal)
    {
        RegCloseKey(hKeyDestReal);
    }
    return ec;
} // FaxCopyRegSubkeys

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FixupDevice
//
//  Purpose:        
//                  This functions handles the adaptation of a device
//                  in the registry from the format used in SBS2000 to the format
//                  used by Server 2003 fax.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 18-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL FixupDevice(HKEY hKey, LPWSTR lpwstrKeyName, DWORD dwIndex, LPVOID lpContext)
{
    WCHAR   wszDeviceId[32]     = {0};
    DWORD   dwRet               = ERROR_SUCCESS;
    BOOL    bRet                = TRUE;
    DWORD   dwDeviceId          = 0;
    HKEY    hDevices            = NULL;
    HKEY    hDevice             = NULL;

    DBG_ENTER(_T("FixupDevice"),dwRet);

    if (lpwstrKeyName==NULL)
    {
        goto exit;
    }

    if (wcscmp(lpwstrKeyName,REGKEY_UNASSOC_EXTENSION_DATA)==0)
    {
        VERBOSE(DBG_MSG, _T("No migration for UnassociatedExtensionData"));
        goto exit;
    }
    
    VERBOSE(DBG_MSG, _T("Migrating the %s device"),lpwstrKeyName);

    // convert the key name from Hex to Decimal
    dwDeviceId = wcstol(lpwstrKeyName,NULL,16);
	if (dwDeviceId==0)
	{
        VERBOSE(SETUP_ERR, _T("converting the device ID to decimal failed"));
        bRet = FALSE;
        goto exit;
	}
    if (dwDeviceId>g_LastUniqueLineId)
    {
        g_LastUniqueLineId = dwDeviceId;
    }
    if (wsprintf(wszDeviceId,L"%010d",dwDeviceId)==0)
    {
        VERBOSE(SETUP_ERR, _T("wsprintf failed"));
        bRet = FALSE;
        goto exit;
    }

    // create the new device key
    hDevices = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_DEVICES,TRUE,KEY_WRITE);
    if (hDevices==NULL)
    {
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey REGKEY_FAX_DEVICES failed (ec=%ld)"),GetLastError());
        bRet = FALSE;
        goto exit;
    }

    // create a key under HKLM\Sw\Ms\Fax\Devices\wszDeviceId
    hDevice = OpenRegistryKey(hDevices,wszDeviceId,TRUE,KEY_WRITE);
    if (hDevice==NULL)
    {
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey %s failed (ec=%ld)"),wszDeviceId,GetLastError());
        bRet = FALSE;
        goto exit;
    }

    // set the 'Permanent Lineid' REG_DWORD
    if (!SetRegistryDword(hDevice,REGVAL_PERMANENT_LINEID,dwDeviceId))
    {
        VERBOSE(SETUP_ERR, _T("SetRegistryDword REGVAL_PERMANENT_LINEID failed (ec=%ld)"),GetLastError());
        bRet = FALSE;
        goto exit;
    }

    // create an entry under the service GUID for the device.
    // and copy the rest of the setting to the new location
    dwRet = CopyRegistrySubkeys2(hDevice, REGKEY_FAXSVC_DEVICE_GUID ,hKey,_T(""));
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("CopyRegistrySubkeys() failed, ec = %ld."), dwRet);
        goto exit;
    }

exit:
    if (hDevices)
    {
        RegCloseKey(hDevices);
    }
    if (hDevice)
    {
        RegCloseKey(hDevice);
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FixupDevicesNode
//
//  Purpose:        
//                  This functions handles the adaptation of the devices
//                  in the registry from the format used in SBS2000 to the format
//                  used by Server 2003 fax.
//                  Each device is copied but the structure in the registry in
//                  a little different. specifically, the device data is kept 
//                  under a GUID.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 18-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD FixupDevicesNode()
{
    HKEY    hFax    = NULL;
    DWORD   dwRet   = ERROR_SUCCESS;

    DBG_ENTER(_T("FixupDevicesNode"),dwRet);

    // enumerate all the devices, and for each, move its key under its GUID
    dwRet = EnumerateRegistryKeys(  HKEY_LOCAL_MACHINE, 
                                    REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_DEVICES, 
                                    FALSE, 
                                    FixupDevice,
                                    NULL);

    VERBOSE(DBG_MSG, _T("For SBS 5.0 Server, enumerated %ld devices."), dwRet);

    // write the LastUniqueLineId to HKLM\Sw\Ms\Fax.
    hFax = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAXSERVER,TRUE,KEY_WRITE);
    if (hFax==NULL)
    {
        dwRet = GetLastError();
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey REGKEY_FAXSERVER failed (ec=%ld)"),dwRet);
        return dwRet;
    }

    if (!SetRegistryDword(hFax,REGVAL_LAST_UNIQUE_LINE_ID,g_LastUniqueLineId+1))
    {
        dwRet = GetLastError();
        VERBOSE(SETUP_ERR, _T("SetRegistryDword REGVAL_LAST_UNIQUE_LINE_ID failed (ec=%ld)"),dwRet);
        return dwRet;
    }

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FixupDeviceProvider
//
//  Purpose:        
//                  This functions handles the adaptation of a device provider
//                  in the registry from the format used in SBS2000 to the format
//                  used by Server 2003 fax.
//                  The 'Microsoft Modem Device Provider' is not copied.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 18-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL FixupDeviceProvider(HKEY hKey, LPWSTR lpwstrKeyName, DWORD dwIndex, LPVOID lpContext)
{
    DWORD   dwRet               = ERROR_SUCCESS;
    BOOL    bRet                = TRUE;
    HKEY    hDeviceProviders	= NULL;

    DBG_ENTER(_T("FixupDeviceProvider"),dwRet);

    if (lpwstrKeyName==NULL)
    {
        goto exit;
    }

    if (wcscmp(lpwstrKeyName,REGKEY_MODEM_PROVIDER)==0)
    {
        VERBOSE(DBG_MSG, _T("No migration for the Microsoft Modem Device Provider"));
        goto exit;
    }

    VERBOSE(DBG_MSG, _T("Migrating the %s Device provider"),lpwstrKeyName);

    // create a key under HKLM\Sw\Ms\Fax\Device Providers
    hDeviceProviders = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_DEVICE_PROVIDER_KEY,TRUE,KEY_WRITE);
    if (hDeviceProviders==NULL)
    {
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey REGKEY_DEVICE_PROVIDER_KEY failed (ec=%ld)"),GetLastError());
        bRet = FALSE;
        goto exit;
    }

    // create a key under HKLM\Sw\Ms\Fax\Device Providers\name
    dwRet = CopyRegistrySubkeys2(hDeviceProviders,lpwstrKeyName,hKey,_T(""));
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("CopyRegistrySubkeys() failed, ec = %ld."), dwRet);
        goto exit;
    }

exit:
    if (hDeviceProviders)
    {
        RegCloseKey(hDeviceProviders);
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FixupDeviceProvidersNode
//
//  Purpose:        
//                  This functions handles the adaptation of the device providers
//                  in the registry from the format used in SBS2000 to the format
//                  used by Server 2003 fax.
//                  The 'Microsoft Modem Device Provider' is not copied and as for 
//                  other FSPs, the key under which they are registered is changed
//                  to hold the GUID of the FSP.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 18-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD FixupDeviceProvidersNode()
{
    DWORD dwRet = ERROR_SUCCESS;

    DBG_ENTER(_T("FixupDeviceProvidersNode"),dwRet);

    // enumerate the rest of the FSPs, and for each, move its key under its GUID
    dwRet = EnumerateRegistryKeys(  HKEY_LOCAL_MACHINE, 
                                    REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_DEVICE_PROVIDERS, 
                                    FALSE, 
                                    FixupDeviceProvider,
                                    NULL);

    VERBOSE(DBG_MSG, _T("For SBS 5.0 Server, enumerated %ld device providers."), dwRet);

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FixupRoutingExtension
//
//  Purpose:        
//                  This functions handles the adaptation of a routing extension
//                  in the registry from the format used in SBS2000 to the format
//                  used by Server 2003 fax.
//                  The 'Microsoft Routing Extension' is not copied and as for 
//                  other Routing extensions, they're copied as is.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 18-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL FixupRoutingExtension(HKEY hKey, LPWSTR lpwstrKeyName, DWORD dwIndex, LPVOID lpContext)
{
    DWORD   dwRet               = ERROR_SUCCESS;
    BOOL    bRet                = TRUE;
    HKEY    hRoutingExtensions  = NULL;

    DBG_ENTER(_T("FixupRoutingExtension"),dwRet);

    if (lpwstrKeyName==NULL)
    {
        goto exit;
    }

    if (wcscmp(lpwstrKeyName,REGKEY_ROUTING_EXTENSION)==0)
    {
        VERBOSE(DBG_MSG, _T("No migration for the Microsoft Routing Extension"));
        goto exit;
    }

    VERBOSE(DBG_MSG, _T("Migrating the %s Routing extension"),lpwstrKeyName);

    // create a key under HKLM\Sw\Ms\Fax\Routing Extensions
    hRoutingExtensions = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_ROUTING_EXTENSION_KEY,TRUE,KEY_WRITE);
    if (hRoutingExtensions==NULL)
    {
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey REGKEY_ROUTING_EXTENSIONS failed (ec=%ld)"),GetLastError());
        bRet = FALSE;
        goto exit;
    }

    // create a key under HKLM\Sw\Ms\Fax\Routing Extensions\name
    dwRet = CopyRegistrySubkeys2(hRoutingExtensions,lpwstrKeyName,hKey,_T(""));
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("CopyRegistrySubkeys() failed, ec = %ld."), dwRet);
        goto exit;
    }

exit:
    if (hRoutingExtensions)
    {
        RegCloseKey(hRoutingExtensions);
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FixupRoutingExtensionsNode
//
//  Purpose:        
//                  This functions handles the adaptation of the routing extension
//                  in the registry from the format used in SBS2000 to the format
//                  used by Server 2003 fax.
//                  The 'Microsoft Routing Extension' is not copied to the destination.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 18-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD FixupRoutingExtensionsNode()
{
    DWORD dwRet = ERROR_SUCCESS;

    DBG_ENTER(_T("FixupRoutingExtensionsNode"),dwRet);

    // enumerate the rest of the Routing Extension, and for each decide whether to copy or not.
    dwRet = EnumerateRegistryKeys(  HKEY_LOCAL_MACHINE, 
                                    REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_ROUTING_EXTENSIONS, 
                                    FALSE, 
                                    FixupRoutingExtension,
                                    NULL);

    VERBOSE(DBG_MSG, _T("For SBS 5.0 Server, enumerated %ld routing extensions."), dwRet);

    return ERROR_SUCCESS;
}


struct REG_KEY_PAIR
{
    LPCTSTR lpctstrSourceKey;
    LPCTSTR lpctstrDestinationKey;
} g_RegKeyPairs[] =
{
    {   REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_ACTIVITY_LOG_CONFIG,                              
        REGKEY_FAXSERVER _T("\\") REGKEY_ACTIVITY_LOG_CONFIG
    },
    {   REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_DEVICES _T("\\") REGKEY_UNASSOC_EXTENSION_DATA,       
        REGKEY_FAXSERVER _T("\\") REGKEY_DEVICES _T("\\") REGKEY_UNASSOC_EXTENSION_DATA
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_LOGGING,
        REGKEY_FAXSERVER _T("\\") REGKEY_LOGGING
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_ARCHIVE_INBOX_CONFIG,
        REGKEY_FAXSERVER _T("\\") REGKEY_ARCHIVE_INBOX_CONFIG
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_OUTBOUND_ROUTING,
        REGKEY_FAXSERVER _T("\\") REGKEY_OUTBOUND_ROUTING
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_RECEIPTS_CONFIG,
        REGKEY_FAXSERVER _T("\\") REGKEY_RECEIPTS_CONFIG
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_SECURITY_CONFIG,
        REGKEY_FAXSERVER _T("\\") REGKEY_SECURITY_CONFIG
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_ARCHIVE_SENTITEMS_CONFIG,
        REGKEY_FAXSERVER _T("\\") REGKEY_ARCHIVE_SENTITEMS_CONFIG
    },
    {
        REGKEY_SBS2000_FAX_BACKUP _T("\\") REGKEY_TAPIDEVICES_CONFIG,
        REGKEY_FAXSERVER _T("\\") REGKEY_TAPIDEVICES_CONFIG
    }
};

const INT iCopyKeys = sizeof(g_RegKeyPairs)/sizeof(g_RegKeyPairs[0]);

LPCTSTR lpctstrValuesToCopy[] = 
{
	REGVAL_BRANDING,
	REGVAL_DIRTYDAYS,
	REGVAL_RETRIES,
	REGVAL_RETRYDELAY,
	REGVAL_SERVERCP,
	REGVAL_STARTCHEAP,
	REGVAL_STOPCHEAP,
	REGVAL_USE_DEVICE_TSID
};

const INT iCopyValues = sizeof(lpctstrValuesToCopy)/sizeof(lpctstrValuesToCopy[0]);
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  fxocUpg_MoveRegistry
//
//  Purpose:        
//                  When a machine running SBS2000 server was upgraded to Windows Server 2003
//                  we migrate the existing registry from SBS to the fax service.
//                  For most registry entries, the existing format is still compatible with
//                  the format used by SBS2000 so we just 'move' the registry around from
//                  one place to the other.
//                  This function is responsible for moving the following subkeys under Fax:
//                      ActivityLogging
//                      Device Providers\<any other than 'Microsoft Modem Device Provider'>
//                      Devices\UnassociatedExtensionData
//                      Logging
//                      Inbox
//                      Outbound Routing
//                      Receipts
//                      Routing Extensions\<any other than 'Microsoft Routing Extension'>
//                      Security
//                      SentItems
//                      TAPIDevices
//
//                  After moving the registry, some fixup to the registry takes place in order 
//                  to make modifications from the format used in SBS2000 to the one used
//                  in Server 2003 Fax.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD fxocUpg_MoveRegistry(void)
{
    INT iCount	    = 0;
    DWORD dwRet	    = NO_ERROR;
	HKEY hDotNetFax = NULL;
	HKEY hSbsFax	= NULL;

    DBG_ENTER(_T("fxocUpg_MoveRegistry"),dwRet);

	if ( !(prv_Data.dwFaxInstalledPriorUpgrade & FXSTATE_SBS5_SERVER) )
    {
        VERBOSE(DBG_MSG, _T("SBS2000 was not installed, nothing to migrate"));
        goto exit;
    }

    // Share the printer (unless printer sharing rule was specified in unattended file)
    if (IsFaxShared() && !fxUnatnd_IsPrinterRuleDefined())
    {
        VERBOSE(DBG_MSG, _T("SBS2000 was installed, sharing printer"));
        fxocPrnt_SetFaxPrinterShared(TRUE);
    }

    // first, we copy all the above mentioned registry from HKLM\\Sw\\Ms\\SharedFax to HKLM\\Sw\\Ms\\Fax
    for (iCount=0; iCount<iCopyKeys; iCount++)
    {
        VERBOSE(DBG_MSG, 
                _T("Copying %s from %s."),
                g_RegKeyPairs[iCount].lpctstrDestinationKey,
                g_RegKeyPairs[iCount].lpctstrSourceKey );

        dwRet = CopyRegistrySubkeys2(
            HKEY_LOCAL_MACHINE, g_RegKeyPairs[iCount].lpctstrDestinationKey,
            HKEY_LOCAL_MACHINE, g_RegKeyPairs[iCount].lpctstrSourceKey);
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            // Some reg keys may not exist. For example, TAPIDevices is created
            // after first use only. So, don't fail on this error.
            VERBOSE(DBG_WARNING, _T("g_RegKeyPairs[iCount].lpctstrSourceKey was not found, continuing"), g_RegKeyPairs[iCount].lpctstrSourceKey);
        }
        else if (dwRet!=ERROR_SUCCESS)
        {
            VERBOSE(DBG_WARNING, _T("CopyRegistrySubkeys() failed, ec = %ld."), dwRet);
            goto exit;
        }
    }

    // second, copy specific values
	hDotNetFax = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAXSERVER,TRUE,KEY_WRITE);
	if (hDotNetFax==NULL)
    {
    	dwRet = GetLastError();
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey REGKEY_FAXSERVER failed (ec=%ld)"),dwRet);
        goto exit;
    }

	hSbsFax = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_BACKUP,TRUE,KEY_READ);
	if (hSbsFax==NULL)
    {
    	dwRet = GetLastError();
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey REGKEY_SBS2000_FAX_BACKUP failed (ec=%ld)"),dwRet);
        goto exit;
    }

	for (iCount=0; iCount<iCopyValues; iCount++)
    {
    	DWORD dwVal = 0;

    	VERBOSE(DBG_MSG,_T("Copying %s."),lpctstrValuesToCopy[iCount]);
        
    	dwVal = GetRegistryDword(hSbsFax,lpctstrValuesToCopy[iCount]);

    	if (!SetRegistryDword(hDotNetFax,lpctstrValuesToCopy[iCount],dwVal))
        {
        	dwRet = GetLastError();
        	VERBOSE(SETUP_ERR, _T("SetRegistryDword %s failed (ec=%ld)"),lpctstrValuesToCopy[iCount],dwRet);
        	goto exit;
        }
    }

    // now, we have to fixup items that are not compatible
    dwRet = FixupDeviceProvidersNode();
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("FixupDeviceProvidersNode() failed, ec = %ld."), dwRet);
        goto exit;
    }

    dwRet = FixupDevicesNode();
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("FixupDevicesNode() failed, ec = %ld."), dwRet);
        goto exit;
    }

    dwRet = FixupRoutingExtensionsNode();
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("FixupRoutingExtensionsNode() failed, ec = %ld."), dwRet);
        goto exit;
    }


    // Set security on Inbox, SentItems and ActivityLog dirs
    dwRet = SetDirSecurityFromReg(REGKEY_SOFTWARE TEXT("\\") REGKEY_ACTIVITY_LOG_CONFIG, REGVAL_ACTIVITY_LOG_DB, SD_FAX_FOLDERS);
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("SetDirSecurity() failed, ec = %ld."), dwRet);
        goto exit;
    }
    dwRet = SetDirSecurityFromReg(REGKEY_SOFTWARE TEXT("\\") REGKEY_ARCHIVE_SENTITEMS_CONFIG, REGVAL_ARCHIVE_FOLDER, SD_FAX_FOLDERS);
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("SetDirSecurity() failed, ec = %ld."), dwRet);
        goto exit;
    }
    dwRet = SetDirSecurityFromReg(REGKEY_SOFTWARE TEXT("\\") REGKEY_ARCHIVE_INBOX_CONFIG, REGVAL_ARCHIVE_FOLDER, SD_FAX_FOLDERS);
    if (dwRet!=ERROR_SUCCESS)
    {
        VERBOSE(DBG_WARNING, _T("SetDirSecurity() failed, ec = %ld."), dwRet);
        goto exit;
    }


    // last, let's delete the SharedFaxBackup key from the registry.
	if (!DeleteRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_BACKUP))
    {
    	dwRet = GetLastError();
        VERBOSE(DBG_WARNING, _T("DeleteRegistryKey() failed, ec = %ld."), dwRet);
        goto exit;
    }

exit:
	if (hSbsFax)
    {
    	RegCloseKey(hSbsFax);
    }
	if (hDotNetFax)
    {
    	RegCloseKey(hDotNetFax);
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocutil.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocUtil.h
//
// Abstract:        Header file used by Utility source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCUTIL_H_
#define _FXOCUTIL_H_

DWORD fxocUtil_Init(void);
DWORD fxocUtil_Term(void);

DWORD fxocUtil_GetUninstallSection(const TCHAR *pszSection,
                                   TCHAR       *pszValue,
                                   DWORD       dwNumBufChars);

DWORD fxocUtil_GetKeywordValue(const TCHAR *pszSection,
                               const TCHAR *pszKeyword,
                               TCHAR       *pszValue,
                               DWORD       dwNumBufChars);

DWORD fxocUtil_DoSetup(HINF            hInf,
                       const TCHAR     *pszSection,
                       BOOL            bInstall,
                       DWORD           dwFlags,
                       const TCHAR     *pszFnName);

BOOL fxocUtil_CreateNetworkShare(const FAX_SHARE_Description* fsdShare);

BOOL fxocUtil_DeleteNetworkShare(LPCWSTR lpcwstrShareName);

DWORD fxocUtil_SearchAndExecute
(
    const TCHAR*    pszInstallSection,
    const TCHAR*    pszSearchKey,
    UINT            Flags,
    HSPFILEQ        hQueue
);

DWORD SetDirSecurity(LPTSTR lpszFolder, LPCTSTR lpszSD);
DWORD SetDirSecurityFromReg(LPCTSTR lpszKey, LPCTSTR lpszVal, LPCTSTR lpszSD);


#endif  // _FXOCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxstate.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxState.h
//
// Abstract:        Header file used by Faxocm source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXSTATE_H_
#define _FXSTATE_H_

typedef enum fxState_UpgradeType_e
{
    FXSTATE_UPGRADE_TYPE_NONE		= 0,
    FXSTATE_UPGRADE_TYPE_WIN31		= 1,
    FXSTATE_UPGRADE_TYPE_WIN9X		= 2,
    FXSTATE_UPGRADE_TYPE_W2K		= 3,
	FXSTATE_UPGRADE_TYPE_XP_DOT_NET	= 4,
	FXSTATE_UPGRADE_TYPE_REPAIR     = 5
};

DWORD                   fxState_Init(void);
DWORD                   fxState_Term(void);
BOOL                    fxState_IsCleanInstall(void);
fxState_UpgradeType_e   fxState_IsUpgrade(void);
BOOL                    fxState_IsUnattended(void);
BOOL                    fxState_IsStandAlone(void);
void                    fxState_DumpSetupState(void);
BOOL                    fxState_IsOsServerBeingInstalled(void);

///////////////////////////////
// fxState_GetInstallType
//
// This function returns one
// of the INF_KEYWORD_INSTALLTYPE_*
// constants found in 
// fxconst.h/fxconst.cpp
//
//
const TCHAR* fxState_GetInstallType(const TCHAR* pszCurrentSection);


#endif  // _FXSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxocutil.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocUtil.cpp
//
// Abstract:        This provides the utility routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////

// Project Includes
#include "faxocm.h"

// System Includes
#include <lmshare.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <Aclapi.h>   // For SetSecurityInfo

#pragma hdrstop

//////////////////////// Static Function Prototypes //////////////////////////

///////////////////////////////
// fxocUtil_Init
//
// Initialize the misc. utilities
// required by faxocm.dll.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise
//
DWORD fxocUtil_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Util module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocUtil_Term
//
// Terminate the misc. utilities
// required by faxocm.dll
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocUtil_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Util module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocUtil_GetUninstallSection
//
// Get field value in the INF 
// pointed to by the INF_KEYWORD_INSTALLTYPE_UNINSTALL
// keyword.
//
// Params:
//      - pszSection - section to search for keyword in.
//      - pszValue - IN - buffer returning the value of the keyword
//      - dwNumBufChars - # of chars the pszValue buffer can hold
//
DWORD fxocUtil_GetUninstallSection(const TCHAR *pszSection,
                                   TCHAR       *pszValue,
                                   DWORD       dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(_T("fxocUtil_GetUninstallSection"),dwReturn,_T("%s"),pszSection);

    if ((pszSection    == NULL) ||
        (pszValue      == NULL) ||
        (dwNumBufChars == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwReturn = fxocUtil_GetKeywordValue(pszSection, 
                                        INF_KEYWORD_INSTALLTYPE_UNINSTALL,
                                        pszValue,
                                        dwNumBufChars);
    return dwReturn;
}


///////////////////////////////
// fxocUtil_GetKeywordValue
//
// This is used for getting the 
// various Install/Uninstall
// sections, dependent on if we
// are a clean install, upgrade,
// etc.
//
// The format in the INF will look like this:
//
// [Section]
// Keyword = Value
//
// Params:
//      - pszSection - section to search for the keyword in.
//      - pszKeyword - keyword to get the value for.
//      - pszValue   - OUT - buffer that will hold the keyword's value
//      - dwNumBufChars - # of characters the pszValue buffer can hold.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocUtil_GetKeywordValue(const TCHAR *pszSection,
                               const TCHAR *pszKeyword,
                               TCHAR       *pszValue,
                               DWORD       dwNumBufChars)
{
    HINF        hInf     = faxocm_GetComponentInf();
    DWORD       dwReturn = NO_ERROR;
    BOOL        bSuccess = FALSE;
    INFCONTEXT  Context;

    DBG_ENTER(  _T("fxocUtil_GetKeywordValue"),
                dwReturn,
                _T("%s - %s "),
                pszSection,
                pszKeyword);

    if ((pszSection     == NULL) ||
        (pszKeyword     == NULL) ||
        (pszValue       == NULL) ||
        (dwNumBufChars  == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }


    bSuccess = ::SetupFindFirstLine(hInf,
                                    pszSection,
                                    pszKeyword,
                                    &Context);

    if (bSuccess)
    {
        bSuccess = ::SetupGetStringField(&Context,
                                         1,
                                         pszValue,
                                         dwNumBufChars,
                                         NULL);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();
            VERBOSE(SETUP_ERR,
                    _T("faxocm_GetKeywordValue, failed to get ")
                    _T("keyword value for section '%s', ")
                    _T("keyword '%s', rc = 0x%lx"),
                    pszSection, 
                    pszKeyword, 
                    dwReturn);
        }
    }
    else
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("faxocm_GetKeywordValue, failed to get ")
                _T("keyword value for component '%s', rc = 0x%lx"),
                pszSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocUtil_DoSetup
//
// Generic fn to create/delete program links
// 
// Params:
//      - hInf - handle to INF file
//      - pszSection - section to install/uninstall from
//      - bInstall   - TRUE if installing, FALSE if uninstalling
//      - pszFnName  - name of calling fn (for debug).
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocUtil_DoSetup(HINF            hInf,
                       const TCHAR     *pszSection,
                       BOOL            bInstall,
                       DWORD           dwFlags,
                       const TCHAR     *pszFnName)
{
    DWORD       dwReturn        = NO_ERROR;
    BOOL        bSuccess        = FALSE;

    DBG_ENTER(  _T("fxocUtil_DoSetup"),
                dwReturn,
                _T("%s - %s "),
                pszSection,
                pszFnName);

    if ((hInf == NULL) || 
        (pszSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // This function call will install or uninstall the shortcuts depending
    // on the value of the "pszSection" parameter.  If the section references
    // the install section, then the shortcuts will be installed, otherwise
    // they will be uninstalled.

    bSuccess = ::SetupInstallFromInfSection(NULL,                                
                                    hInf,
                                    pszSection,
                                    dwFlags,
                                    NULL,   // relative key root
                                    NULL,   // source root path
                                    0,      // copy flags
                                    NULL,   // callback routine
                                    NULL,   // callback routine context
                                    NULL,   // device info set
                                    NULL);  // device info struct

    if (!bSuccess)
    {
        dwReturn = ::GetLastError();

        VERBOSE(SETUP_ERR,
                _T("SetupInstallFromInfSection failed, rc = 0x%lx"),
                dwReturn);
    }

    return dwReturn;
}

//////////////////////////////////
// fxocUtil_CreateNetworkShare
// 
//
// Create share on the current machine.
// If the share name is already exist, 
// then the function will try to erase the share
// and then create new one to lpctstrPath 
// 
// Params:
//      - const FAX_SHARE_Description* fsdShare - share description
// Returns:
//      - Returns TRUE on success
//      - FALSE otherwise
//
BOOL fxocUtil_CreateNetworkShare(const FAX_SHARE_Description* fsdShare)
{
    SHARE_INFO_502  ShareInfo502;
    NET_API_STATUS  rVal        = 0;
    DWORD           dwShareType = 0;
    DWORD           dwNumChars  = 0;

    WCHAR szExpandedPath[MAX_PATH*2];

    DBG_ENTER(_T("fxocUtil_CreateNetworkShare"));

    ZeroMemory(&ShareInfo502, sizeof(SHARE_INFO_502));

    dwNumChars = ExpandEnvironmentStrings(fsdShare->szPath, szExpandedPath, sizeof(szExpandedPath)/sizeof(szExpandedPath[0]));
    if (dwNumChars == 0)
    {
        VERBOSE(SETUP_ERR,
                _T("ExpandEnvironmentStrings failed, rc = 0x%lx"),
                ::GetLastError());

        return FALSE;
    }

    ShareInfo502.shi502_netname        = (LPTSTR)fsdShare->szName;
    ShareInfo502.shi502_type           = STYPE_DISKTREE;
    ShareInfo502.shi502_remark         = (LPTSTR)fsdShare->szComment;
    ShareInfo502.shi502_permissions    = ACCESS_ALL;
    ShareInfo502.shi502_max_uses       = (DWORD) -1,
    ShareInfo502.shi502_current_uses   = (DWORD) -1;
    ShareInfo502.shi502_path           = szExpandedPath;
    ShareInfo502.shi502_passwd         = NULL;
    ShareInfo502.shi502_security_descriptor = fsdShare->pSD;

    rVal = ::NetShareAdd(NULL,
                         502,
                         (LPBYTE) &ShareInfo502,
                         NULL);

    if (rVal == NERR_Success)
    {
        VERBOSE(DBG_MSG, _T("Successfully added '%s' share."), fsdShare->szName);
    }
    else if (rVal == NERR_DuplicateShare)
    {
        // share by the same name was found, attempt to delete it, and re-add it.

        VERBOSE(SETUP_ERR,
                _T("The share %s already exist, (err=%ld) ")
                _T("CreateNetworkShare will try to remove the share and ")
                _T("re-create it."),
                fsdShare->szName,
                GetLastError());

        // delete duplicate share.
        rVal = ::NetShareDel(NULL,
                             (LPTSTR) fsdShare->szName,
                             0);

        VERBOSE(DBG_MSG,
                _T("NetShareDel returned 0x%lx"),
                rVal);

        if (rVal != NERR_Success)
        {
            // failed to delete duplicate share.
            VERBOSE(SETUP_ERR,
                    _T("NetShareDel failed to delete '%s' share, rc = 0x%lx,")
                    _T("attempting to recreate it anyway"),
                    fsdShare->szName,
                    rVal);
        }

        // attempt to add new share, even if we failed to delete the duplicate share.  
        // Hopefully this will work regardless of the delete failure.
        rVal = ::NetShareAdd(NULL,
                             502,
                             (LPBYTE) &ShareInfo502,
                             NULL);

        if (rVal == NERR_Success)
        {
            VERBOSE(DBG_MSG, _T("Successfully added '%s' share."), fsdShare->szName);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to add '%s' share on second attempt, ")
                    _T("rc = 0x%lx"),
                    rVal);

            ::SetLastError(rVal);
        }
    }
    else
    {
        ::SetLastError(rVal);
    }

    return (rVal == NERR_Success);
}

//////////////////////////////////
// fxocUtil_DeleteNetworkShare
//
// Delete a share on the current machine.
// Returns TRUE on success, FALSE otherwise
//
// Params:
//      - LPCWSTR lpcwstrShareName :    : share name to delete
// Returns:
//      - TRUE on Success
//      - FALSE otherwise
//

BOOL fxocUtil_DeleteNetworkShare(LPCWSTR pszShareName)
{
    NET_API_STATUS rVal;

    DBG_ENTER(  _T("fxocUtil_DeleteNetworkShare"),
                _T("%s"),
                pszShareName);

    rVal = NetShareDel(NULL,                      // Local computer's share
                       (LPTSTR) pszShareName, // Name of the share to delete.
                       0);

    return (rVal == NERR_Success);
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  fxocUtil_SearchAndExecute
//
//  Purpose:        
//                  Searches a specified INF section for keywords of the type 'pszSearchKey'
//                  Each keyword should be in the format 'pszSearchKey' = platform, section to process.
//                  If the platform matches, then the section is processed according to Flags
//                  passed to SetupInstallFromInfSection                  
//
//  Params:
//                  const TCHAR*    pszInstallSection  - section to search in
//                  const TCHAR*    pszSearchKey       - keyword to find
//                  UINT            Flags              - flags to pass to SetupInstallFromInfSection
//                  HSPFILEQ        hQueue             - handle to file queue, if specified, this function
//                                                       will attemp to install files using the 
//                                                       SetupInstallFilesFromInfSection API
//                  
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code - otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 02-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD fxocUtil_SearchAndExecute
(
    const TCHAR*    pszInstallSection,
    const TCHAR*    pszSearchKey,
    UINT            Flags,
    HSPFILEQ        hQueue
)
{
    DWORD       dwReturn = NO_ERROR;
    INFCONTEXT  Context;
    BOOL        bNextSearchKeyFound = TRUE;
    HINF        hInf     = faxocm_GetComponentInf();
 
    DBG_ENTER(_T("fxocUtil_SearchAndExecute"),dwReturn,_T("%s - %s"),pszInstallSection,pszSearchKey);

    // let's look for 'pszSearchKey' directives
    bNextSearchKeyFound = ::SetupFindFirstLine( hInf,
                                                pszInstallSection, 
                                                pszSearchKey,
                                                &Context);
    if (!bNextSearchKeyFound)
    {
        VERBOSE(DBG_WARNING,
                _T("Did not find '%s' keyword in ")
                _T("section '%s'.  No action will be taken."),
                pszSearchKey, 
                pszInstallSection);

        goto exit;
    }

    while (bNextSearchKeyFound)
    {
        // we have a CreateShortcut section.
        DWORD dwCount = ::SetupGetFieldCount(&Context);
        if (dwCount!=2)
        {
            VERBOSE(SETUP_ERR,_T("Invalid %s section, has %d param instead of 2"),pszSearchKey,dwCount);
            goto exit;
        }
        // get the platform specifier
        INT iPlatform = 0;
        if (!::SetupGetIntField(&Context, 1, &iPlatform))
        {
            dwReturn = GetLastError();
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),dwReturn);
            goto exit;
        }
        // check the platform we read against the specifier
        if (iPlatform & GetProductSKU())
        {
            // we should process this section, get the section name
            TCHAR szSectionName[MAX_PATH] = {0};
            if (!::SetupGetStringField(&Context,2,szSectionName,MAX_PATH,NULL))
            {
                dwReturn = GetLastError();
                VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),dwReturn);
                goto exit;
            }
            // check if a file operation was requested
            if (hQueue)
            {
                if (::SetupInstallFilesFromInfSection(hInf,NULL,hQueue,szSectionName,NULL,Flags))
                {
                    VERBOSE(DBG_MSG,
                            _T("Successfully queued files from Section: '%s'"),
                            szSectionName);
                }
                else
                {
                    dwReturn = GetLastError();
                    VERBOSE(DBG_MSG,
                            _T("Failed to queue files from Section: '%s', Error Code = 0x%lx"),
                            szSectionName, 
                            dwReturn);
                }
            }
            else
            {
                if (::SetupInstallFromInfSection(NULL,hInf,szSectionName,Flags,NULL,NULL,0,NULL,NULL,NULL,NULL))
                {
                    VERBOSE(DBG_MSG,
                            _T("Successfully installed from INF file, section '%s'"),
                            szSectionName);
                }
                else
                {
                    dwReturn = GetLastError();
                    VERBOSE(SETUP_ERR,
                            _T("Failed to install from INF file, section '%s', dwReturn = 0x%lx"),
                            szSectionName, 
                            dwReturn);
                }
            }
        }
        
        // get the next section.
        bNextSearchKeyFound = ::SetupFindNextMatchLine( &Context,
                                                        pszSearchKey,
                                                        &Context);
        if (!bNextSearchKeyFound)
        {
            VERBOSE(DBG_MSG,
                    _T("Did not find '%s' keyword in ")
                    _T("section '%s'.  No action will be taken."),
                    pszSearchKey, 
                    pszInstallSection);
        }
    }
exit:
    return dwReturn;
}


/*++
Routine description:
    Sets security info on a directory

Arguments:
    lpszFolder [in]         - name of directory
    lpszSD [in]             - Desired security descriptor in SDDL format

Return Value: Win32 Error code

Written by:  jobarner, 08/2002    
--*/
DWORD SetDirSecurity(LPTSTR lpszFolder, LPCTSTR lpszSD)
{
    PSECURITY_DESCRIPTOR pSD        = NULL;
    DWORD                ec         = ERROR_SUCCESS;
    DBG_ENTER(_T("SetDirSecurity"),ec);

    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
                         lpszSD, SDDL_REVISION_1, &pSD, NULL))
    {
        ec = GetLastError();
        VERBOSE(SETUP_ERR, _T("ConvertStringSecurityDescriptorToSecurityDescriptor Failed, ec=%x"), ec);
        goto exit;
    }

    //
    // Apply the security descriptor recursively to the files. 
    //
    BOOL    bDaclPresent    = TRUE;
    BOOL    bDaclDefaulted  = TRUE;
    PACL    pDacl           = NULL;

    if(!GetSecurityDescriptorDacl(pSD,
                                  &bDaclPresent,
                                  &pDacl,
                                  &bDaclDefaulted) || 
       !bDaclPresent)
    {
        ec = GetLastError();
        VERBOSE(SETUP_ERR, _T("GetSecurityDescriptorDacl Failed, ec=%x"), ec);
        goto exit;
    }

    ec = SetNamedSecurityInfo(lpszFolder,
                        SE_FILE_OBJECT,
                        DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                        NULL,
                        NULL,
                        pDacl,
                        NULL);
    if (ec != ERROR_SUCCESS)
    {
        VERBOSE(SETUP_ERR, _T("SetSecurityInfo Failed, ec=%x"), ec);
    }

exit:
    if (pSD)
    {
        LocalFree(pSD);
    }
    
    return ec;
}

/*++
Routine description:
    Read dir name from registry and set security info on it

Arguments:
    lpszKey [in]            - name of subkey under HKLM
    lpszVal [in]            - name of value that stores directory name
    lpszSD [in]             - Desired security descriptor in SDDL format

Return Value: Win32 Error code

Written by:  jobarner, 08/2002    
--*/
DWORD SetDirSecurityFromReg(LPCTSTR lpszKey, LPCTSTR lpszVal, LPCTSTR lpszSD)
{
    HKEY                 hKey       = NULL;
    LPTSTR               lpszFolder = NULL;
    DWORD                ec         = ERROR_SUCCESS;

    DBG_ENTER(_T("SetDirSecurityFromReg"),ec);

    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, lpszKey, FALSE, KEY_READ);
    if (!hKey)
    {
        ec = GetLastError();
        VERBOSE(SETUP_ERR, _T("OpenRegistryKey Failed, ec=%x"), ec);
        goto exit;
    }

    lpszFolder = GetRegistryString(hKey, lpszVal, NULL);
    if (!lpszFolder)
    {
        ec = GetLastError();
        VERBOSE(SETUP_ERR, _T("GetRegistryString Failed, ec=%x"), ec);
        goto exit;
    }

    ec = SetDirSecurity(lpszFolder, lpszSD);

exit:
    if (lpszFolder)
    {
        MemFree(lpszFolder);
    }
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return ec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxstate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxState.cpp
//
// Abstract:        This provides the state routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created file, cleanup routines
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  prv_IsXPOrDotNetUpgrade
//
//  Purpose:        
//                  This function searches for FXSAPI.DLL in %system32% and if
//                  it exists the function returns TRUE, indicating that this is an
//                  upgrade from XP or .NET Server.
//  Params:
//                  None
//
//  Return Value:
//                  TRUE - This is a XP or .NET upgrade
//                  FALSE - This is W2K, or a failure occured.
//
//  Author:
//                  Mooly Beery (MoolyB) 26-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL prv_IsXPOrDotNetUpgrade()
{
    BOOL            bRet                        = FALSE;
    HANDLE          hFind                       = NULL;
    WIN32_FIND_DATA FindFileData                = {0};
    TCHAR           szSystemDirectory[MAX_PATH] = {0};

    DBG_ENTER(TEXT("prv_IsXPOrDotNetUpgrade"),bRet);

    // get the system directory
    if (GetSystemDirectory(szSystemDirectory,MAX_PATH-_tcslen(FAX_API_MODULE_NAME)-1)==0)
    {
        VERBOSE( SETUP_ERR,TEXT("GetSystemDirectory failed (ec: %ld)"),GetLastError());
        goto exit;
    }

    // append
    _tcscat(szSystemDirectory,_T("\\"));
    _tcscat(szSystemDirectory,FAX_API_MODULE_NAME);

    // search for FXSAPI.DLL in the system folder
    hFind = FindFirstFile(szSystemDirectory, &FindFileData);
    if (hFind==INVALID_HANDLE_VALUE) 
    {
        VERBOSE( DBG_WARNING, 
                 TEXT("FindFirstFile %s failed (ec: %ld)"),
                 szSystemDirectory,
                 GetLastError());
        goto exit;
    }

    // found it.
    bRet = TRUE;
    FindClose(hFind);

exit:
    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  prv_IsRepair
//
//  Purpose:        
//                  This function determines whether this is a 'same build' upgrade
//                  which means the user wants to perform a 'repair' operation.
//                  This is done by comparing the values for SKU and Version we
//					write each setup with current values.
//					A 'repair' is an upgrade from same build to itself without
//					the SKU changing.
//
//  Params:
//                  None
//
//  Return Value:
//                  TRUE - Upgrading from same build to itself and SKU didn't change.
//                  FALSE - Otherwise.
//
//  Author:
//                  Mooly Beery (MoolyB) 06-Jan-2002
///////////////////////////////////////////////////////////////////////////////////////
BOOL prv_IsRepair()
{
    BOOL				bRet                    = FALSE;
	PRODUCT_SKU_TYPE	InstalledProductSKU		= PRODUCT_SKU_UNKNOWN;
	DWORD				InstalledProductBuild  = 0;

    DBG_ENTER(TEXT("prv_IsXPOrDotNetUpgrade"),bRet);

	faxocm_GetProductInfo(&InstalledProductSKU,&InstalledProductBuild);

	if (InstalledProductSKU!=GetProductSKU())
	{
		VERBOSE(DBG_MSG,_T("Different SKU upgrade, this is not repair"));
		return FALSE;
	}

	if (InstalledProductBuild!=GetProductBuild())
	{
		VERBOSE(DBG_MSG,_T("Different build upgrade, this is not repair"));
		return FALSE;
	}

	return TRUE;
}
///////////////////////////////
// fxState_Init
//
// Initialize the state handling
// module for Faxocm.
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxState_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init State module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxState_Term
//
// Terminate the state handling module
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxState_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term State module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxState_IsUnattended
//
// Determines if this is an unattended install
// It interprets flags given to us
// by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - TRUE if unattended install.
//      - FALSE if not.
//
BOOL fxState_IsUnattended(void)
{
    DWORDLONG   dwlFlags = 0;

    // get the setup flags.
    dwlFlags = faxocm_GetComponentFlags();

    // if SETOP_BATCH flag is set, then we are in unattended mode.
    return (dwlFlags & SETUPOP_BATCH) ? TRUE : FALSE;
}

///////////////////////////////
// fxState_IsCleanInstall
//
// Determines if this a clean install.
// A clean install is when we are 
// NOT upgrading, and we are not 
// running in stand alone mode (see below for def'n).
//
// Params:
//      - void.
// Returns:
//      - TRUE if clean install.
//      - FALSE if not.
//
BOOL fxState_IsCleanInstall(void)
{
    BOOL        bClean   = FALSE;    

    // a clean install is if we are NOT upgrading AND we are not in
    // stand alone mode.
    if (!fxState_IsUpgrade() && !fxState_IsStandAlone())
    {
        bClean = TRUE;
    }

    return bClean;
}

///////////////////////////////
// fxState_IsStandAlone
//
// Determines if we are running in
// standalone mode or not.  We are
// in this mode if the user started 
// us up via "sysocmgr.exe" found
// in %systemroot%\system32, as opposed
// to via the install setup, or the
// Add/Remove Windows Components.
//
// Params:
//      - void.
// Returns: 
//      - TRUE if we are in stand alone mode.
//      - FALSE if we are not.
//
BOOL fxState_IsStandAlone(void)
{
    DWORDLONG dwlFlags = 0;

    dwlFlags = faxocm_GetComponentFlags();

    return ((dwlFlags & SETUPOP_STANDALONE) ? TRUE : FALSE);
}

///////////////////////////////
// fxState_IsUpgrade
//
// Determines if we are upgrading
// the OS, as opposed to a clean
// installation.
//
// Params:
//      - void.
// Returns:
//      - fxState_UpgradeType_e enumerated
//        type indicating the type of upgrade.
//        (i.e. are we upgrading from Win9X,
//         W2K, etc).
//
fxState_UpgradeType_e fxState_IsUpgrade(void)
{
    fxState_UpgradeType_e   eUpgradeType = FXSTATE_UPGRADE_TYPE_NONE;
    DWORDLONG               dwlFlags     = 0;
	static BOOL				bXpDotNetUpgrade = prv_IsXPOrDotNetUpgrade();
	static BOOL             bIsRepair = prv_IsRepair();

    dwlFlags = faxocm_GetComponentFlags();

    if ((dwlFlags & SETUPOP_WIN31UPGRADE) == SETUPOP_WIN31UPGRADE)
    {
        eUpgradeType = FXSTATE_UPGRADE_TYPE_WIN31;
    }
    else if ((dwlFlags & SETUPOP_WIN95UPGRADE) == SETUPOP_WIN95UPGRADE)
    {
        eUpgradeType = FXSTATE_UPGRADE_TYPE_WIN9X;
    }
    else if ((dwlFlags & SETUPOP_NTUPGRADE) == SETUPOP_NTUPGRADE)
    {
        if (bXpDotNetUpgrade)
        {
			if (bIsRepair)
			{
				eUpgradeType = FXSTATE_UPGRADE_TYPE_REPAIR;
			}
			else
			{
				eUpgradeType = FXSTATE_UPGRADE_TYPE_XP_DOT_NET;
			}
        }
        else
        {
            eUpgradeType = FXSTATE_UPGRADE_TYPE_W2K;
        }
    }

    return eUpgradeType;
}

///////////////////////////////
// fxState_IsOsServerBeingInstalled
//
// Are we installing the Server
// version of the OS, or a workstation
// or personal version.
//
// Params:
//      - void.
// Returns:
//      - TRUE if we are installing a server version.
//      - FALSE if we are not.

BOOL fxState_IsOsServerBeingInstalled(void)
{
    BOOL  bIsServerInstall  = FALSE;
    DWORD dwProductType     = 0;

    dwProductType = faxocm_GetProductType();

    if (dwProductType == PRODUCT_WORKSTATION)
    {
        bIsServerInstall = FALSE;
    }
    else
    {
        bIsServerInstall = TRUE;
    }

    return bIsServerInstall;
}

///////////////////////////////
// fxState_GetInstallType
//
// This function returns one
// of the INF_KEYWORD_INSTALLTYPE_*
// constants found in 
// fxconst.h/fxconst.cpp
//
// Params:
//      - pszCurrentSection - section we are installing from
// Returns:
//      - ptr to one of INF_KEYWORD_INSTALLTYPE_* constants.
//
const TCHAR* fxState_GetInstallType(const TCHAR* pszCurrentSection)
{
    DWORD dwErr                 = NO_ERROR;
    BOOL  bInstall              = TRUE;
    BOOL  bSelectionHasChanged  = FALSE;

    DBG_ENTER(_T("fxState_GetInstallType"),_T("%s"),pszCurrentSection);

    if (pszCurrentSection == NULL)
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // determine if we are installing or uninstalling
    dwErr = faxocm_HasSelectionStateChanged(pszCurrentSection, 
                                            &bSelectionHasChanged,
                                            &bInstall, 
                                            NULL);

    if (dwErr != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("faxocm_HasSelectionStateChanged failed, rc = 0x%lx"),
                dwErr);

        return NULL;
    }

    // we expect the INF to look something like this:
    // [Fax]
    //
    // FaxCleanInstall     = Fax.CleanInstall
    // FaxUpgradeFromWin9x = Fax.UpgradeFromWin9x
    // FaxUninstall        = Fax.Uninstall
    //
    // [Fax.CleanInstall]
    // CopyFiles = ...
    // etc.
    //
    // Thus the goal of this function is to determine if we are
    // clean installing, upgrading, etc., and then get the section
    // name pointed to by one of 'FaxCleanInstall', 'FaxUpgradeFromWin9x'
    // , or 'FaxUninstall'.
    //
    // So for example, if we determined we are clean installing, then
    // this function will find the "FaxCleanInstall" keyword, and then
    // return "Fax.CleanInstall" in the 'pszSectionToProcess' buffer.

    if (bInstall)
    {
        fxState_UpgradeType_e eUpgrade = FXSTATE_UPGRADE_TYPE_NONE;

        if (fxState_IsCleanInstall())
        {
            // we are a clean install of the OS, user is not upgrading from
            // another OS, they are installing a clean version of the OS.
            return INF_KEYWORD_INSTALLTYPE_CLEAN;
        }
        else if (fxState_IsUpgrade())
        {
            // We are installing as an Upgrade to another OS.
            // Determine which OS we are upgrading, then determine
            // the type of install to perform.

            eUpgrade = fxState_IsUpgrade();

            switch (eUpgrade)
            {
                case FXSTATE_UPGRADE_TYPE_NONE:
                    return INF_KEYWORD_INSTALLTYPE_CLEAN;
                break;

                case FXSTATE_UPGRADE_TYPE_WIN9X:
                    return INF_KEYWORD_INSTALLTYPE_UPGFROMWIN9X;
                break;

                case FXSTATE_UPGRADE_TYPE_W2K:
                    return INF_KEYWORD_INSTALLTYPE_UPGFROMWIN2K;
                break;

                case FXSTATE_UPGRADE_TYPE_XP_DOT_NET:
                    return INF_KEYWORD_INSTALLTYPE_UPGFROMXPDOTNET;

				case FXSTATE_UPGRADE_TYPE_REPAIR:
					return INF_KEYWORD_INSTALLTYPE_CLEAN;

                default:
                    VERBOSE(SETUP_ERR, 
                            _T("Failed to get section to process "),
                            _T("for install.  Upgrade Type = %lu"),
                            eUpgrade);
                break;
            }
        }
        else if (fxState_IsStandAlone())
        {
            // we are being run from SysOcMgr.exe.
            // SysOcMgr.exe is either invoked from the command line 
            // (usually as a way to test new OCM components - not really in 
            // the retail world), or it is invoked by the Add/Remove 
            // Windows Components in control panel.  In either case, 
            // treat it as a clean install.

            return INF_KEYWORD_INSTALLTYPE_CLEAN;
        }
    }
    else
    {
        return INF_KEYWORD_INSTALLTYPE_UNINSTALL;
    }

    return NULL;
}


///////////////////////////////
// fxState_DumpSetupState
//
// Dumps to debug the state we
// are running in.
//
// Params:
//      void
// Returns:
//      void
//
//
void fxState_DumpSetupState(void)
{
    DWORD				dwExpectedOCManagerVersion		= 0;
    DWORD				dwCurrentOCManagerVersion		= 0;
    TCHAR				szComponentID[255 + 1]			= {0};
    TCHAR				szSourcePath[_MAX_PATH + 1]		= {0};
    TCHAR				szUnattendFile[_MAX_PATH + 1]	= {0};
	PRODUCT_SKU_TYPE	InstalledProductSKU				= PRODUCT_SKU_UNKNOWN;
	DWORD				InstalledProductBuild			= 0;

    DBG_ENTER(_T("fxState_DumpSetupState"));

    faxocm_GetComponentID(szComponentID, 
                          sizeof(szComponentID) / sizeof(TCHAR));

    faxocm_GetComponentSourcePath(szSourcePath, 
                                  sizeof(szSourcePath) / sizeof(TCHAR));

    faxocm_GetComponentUnattendFile(szUnattendFile, 
                                  sizeof(szUnattendFile) / sizeof(TCHAR));

    faxocm_GetVersionInfo(&dwExpectedOCManagerVersion,
                          &dwCurrentOCManagerVersion);

	faxocm_GetProductInfo(&InstalledProductSKU,&InstalledProductBuild);

    VERBOSE(DBG_MSG,
            _T("IsCleanInstall: '%lu'"), 
            fxState_IsCleanInstall());

    VERBOSE(DBG_MSG,
            _T("IsStandAlone: '%lu'"), 
            fxState_IsStandAlone());

    VERBOSE(DBG_MSG,
            _T("IsUpgrade (0 = No, 1 = Win31, 2 = Win9X, 3 = Win2K, 4 = XP/.NET, 5=Repair: '%lu'"), 
            fxState_IsUpgrade());

	if ((fxState_IsUpgrade()==FXSTATE_UPGRADE_TYPE_XP_DOT_NET) ||
		(fxState_IsUpgrade()==FXSTATE_UPGRADE_TYPE_REPAIR))
	{
		VERBOSE(DBG_MSG,
				_T("Upgrading from Fax build %d"), 
				InstalledProductBuild);

		VERBOSE(DBG_MSG,
				_T("Upgrading from OS SKU %s"), 
				StringFromSKU(InstalledProductSKU));

	}

    VERBOSE(DBG_MSG,
            _T("IsUnattended: '%lu'"), 
            fxState_IsUnattended());

    VERBOSE(DBG_MSG, _T("ComponentID: '%s'"), szComponentID);
    VERBOSE(DBG_MSG, _T("Source Path: '%s'"), szSourcePath);
    VERBOSE(DBG_MSG, _T("Unattend File: '%s'"), szUnattendFile);

    VERBOSE(DBG_MSG,
            _T("Expected OC Manager Version: 0x%lx"),
            dwExpectedOCManagerVersion);

    VERBOSE(DBG_MSG,
            _T("Current OC Manager Version:  0x%lx"),
            dwCurrentOCManagerVersion);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxunatnd.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxUnatnd.h
//
// Abstract:        Fax OCM Unattend file processing
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 27-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXUNATND_H_
#define _FXUNATND_H_

///////////////////////////////
// fxUnatnd_UnattendedData_t
//
// This type is used to store
// the unattended data retrieved
// from the unattend.txt file
// and update the registry with
// these values.
//
typedef struct fxUnatnd_UnattendedData_t
{
    TCHAR   szFaxPrinterName[_MAX_PATH + 1];
	DWORD   dwIsFaxPrinterShared;

    TCHAR   szCSID[_MAX_PATH + 1];
    TCHAR   szTSID[_MAX_PATH + 1];
    DWORD   dwRings;

    DWORD   dwSendFaxes;
    DWORD   dwReceiveFaxes;

    // should we run the configuration wizard for this unattended installation.
    DWORD   dwSuppressConfigurationWizard;

    // SMTP configuration
    TCHAR   szFaxUserName[_MAX_PATH + 1];
    TCHAR   szFaxUserPassword[_MAX_PATH + 1];
    BOOL    bSmtpNotificationsEnabled;
    TCHAR   szSmtpSenderAddress[_MAX_PATH + 1];
    TCHAR   szSmptServerAddress[_MAX_PATH + 1];
    DWORD   dwSmtpServerPort;
    TCHAR   szSmtpServerAuthenticationMechanism[_MAX_PATH + 1];

    // route incoming faxes to printer?
    BOOL    bRouteToPrinter;
    TCHAR   szRoutePrinterName[_MAX_PATH + 1];

    // route incoming faxes to email?
    BOOL    bRouteToEmail;
    TCHAR   szRouteEmailName[_MAX_PATH + 1];

    // Inbox configuration
    BOOL    bArchiveIncoming;
    TCHAR   szArchiveIncomingDir[_MAX_PATH + 1];

    // route incoming faxes to a specific directory.
    BOOL    bRouteToDir;
    TCHAR   szRouteDir[_MAX_PATH + 1];

    // archive outgoing faxes in a specific directory.
    BOOL    bArchiveOutgoing;
    TCHAR   szArchiveOutgoingDir[_MAX_PATH + 1];

    //  Fax Applicaitons uninstalled during Upgrade
    DWORD   dwUninstalledFaxApps;

} fxUnatnd_UnattendedData_t;


DWORD fxUnatnd_Init(void);
DWORD fxUnatnd_Term(void);
DWORD fxUnatnd_LoadUnattendedData();
DWORD fxUnatnd_SaveUnattendedData();

TCHAR* fxUnatnd_GetPrinterName();
BOOL fxUnatnd_IsPrinterRuleDefined();
BOOL fxUnatnd_GetIsPrinterShared();


#endif  // _FXUNATND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E4E8FEF0_0119_40AB_9A5D_97A47C81205A__INCLUDED_)
#define AFX_STDAFX_H__E4E8FEF0_0119_40AB_9A5D_97A47C81205A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E4E8FEF0_0119_40AB_9A5D_97A47C81205A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\ifaxcontrol.cpp ===
// IFaxControl.cpp : Implementation of CFaxControl
#include "stdafx.h"
#include "FaxControl.h"
#include "IFaxControl.h"
#include "faxocm.h"
#include "faxres.h"
#include <faxsetup.h>

/////////////////////////////////////////////////////////////////////////////
// CFaxControl

FaxInstallationReportType g_InstallReportType = REPORT_FAX_DETECT;

//
// IsFaxInstalled and InstallFaxUnattended are implemented in fxocprnt.cpp
//
DWORD
IsFaxInstalled (
    LPBOOL lpbInstalled
    );

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT GetCurrentThreadLastPopup(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;

    if( phwnd )
    {
        hr = E_FAIL;

        if( NULL == *phwnd )
        {
            // if *phwnd is NULL then get the current thread active window
            GUITHREADINFO ti = {0};
            ti.cbSize = sizeof(ti);
            if( GetGUIThreadInfo(GetCurrentThreadId(), &ti) && ti.hwndActive )
            {
                *phwnd = ti.hwndActive;
            }
        }

        if( *phwnd )
        {
            HWND hwndOwner, hwndParent;

            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner of the top level parent window
            *phwnd = GetLastActivePopup(*phwnd);
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  DisplayErrorMessage
//
//  Purpose:        
//                  Load FXSRES.DLL and load an error message string from it
//                  Display this string in a message box
//                  Ideally, we would have added the error message dialog to this module
//                  but this is added in a time of UI freeze (close to RTM) and the only
//                  place we have such a dialog is FXSRES.DLL
//
//  Params:
//                  Error code
//
//  Return Value:
//                  NO_ERROR - everything was ok.
//                  Win32 Error code in case if failure.
//
//  Author:
//                  Mooly Beery (MoolyB) 19-Jul-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD DisplayErrorMessage(DWORD ec)
{
    DWORD                       dwReturn                = NO_ERROR;
    HMODULE                     hModule                 = NULL;
    HWND                        hWnd                    = NULL;
    TCHAR                       tszMessage[MAX_PATH]    = {0};
    UINT                        uResourceId             = 0;

    DBG_ENTER(_T("DisplayErrorMessage"), dwReturn);

    hModule = GetResInstance(NULL); 
    if (!hModule)
    {
        return dwReturn;
    }

    // get the string id
    uResourceId = GetErrorStringId(ec);

    dwReturn = LoadString(hModule,uResourceId,tszMessage,MAX_PATH);
    if (dwReturn==0)
    {
        //
        //  Resource string is not found
        //
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING, _T("LoadString() failed, ec = %ld."), dwReturn);
        goto exit;
    }
   
    // try to get the windows handle for the current thread.
    if (FAILED(GetCurrentThreadLastPopup(&hWnd)))
    {
        CALL_FAIL(GENERAL_ERR,TEXT("GetCurrentThreadLastPopup"), GetLastError());
        hWnd = NULL;
    }
    
    // show the message
    MessageBox(hWnd,tszMessage,NULL,MB_OK | MB_ICONERROR | MB_TOPMOST);

exit:
    FreeResInstance();

    return dwReturn; 
}


STDMETHODIMP CFaxControl::get_IsFaxServiceInstalled(VARIANT_BOOL *pbResult)
{
    HRESULT hr;
    BOOL bRes;
    DBG_ENTER(_T("CFaxControl::get_IsFaxServiceInstalled"), hr);

    DWORD dwRes = ERROR_SUCCESS;
    
    switch (g_InstallReportType)
    {
        case REPORT_FAX_INSTALLED:
            bRes = TRUE;
            break;

        case REPORT_FAX_UNINSTALLED:
            bRes = FALSE;
            break;

        case REPORT_FAX_DETECT:
            dwRes = IsFaxInstalled (&bRes);
            break;

        default:
            ASSERTION_FAILURE;
            bRes = FALSE;
            break;
    }
    if (ERROR_SUCCESS == dwRes)
    {
        *pbResult = bRes ? VARIANT_TRUE : VARIANT_FALSE;
    }            
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}

STDMETHODIMP CFaxControl::get_IsLocalFaxPrinterInstalled(VARIANT_BOOL *pbResult)
{
    HRESULT hr;
    BOOL bRes;
    DBG_ENTER(_T("CFaxControl::get_IsLocalFaxPrinterInstalled"), hr);

    DWORD dwRes = ::IsLocalFaxPrinterInstalled (&bRes);
    if (ERROR_SUCCESS == dwRes)
    {
        *pbResult = bRes ? VARIANT_TRUE : VARIANT_FALSE;
    }            
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}

STDMETHODIMP CFaxControl::InstallFaxService()
{
    HRESULT hr;
    DBG_ENTER(_T("CFaxControl::InstallFaxService"), hr);

    DWORD dwRes = InstallFaxUnattended ();
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}

STDMETHODIMP CFaxControl::InstallLocalFaxPrinter()
{
    HRESULT hr;
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(_T("CFaxControl::InstallLocalFaxPrinter"), hr);

    dwRes = AddLocalFaxPrinter (FAX_PRINTER_NAME, NULL);
    if (dwRes!=ERROR_SUCCESS)
    {
        // fail to add the local fax printer
        // display an error message
        if (DisplayErrorMessage(dwRes)!=ERROR_SUCCESS)
        {
            CALL_FAIL(GENERAL_ERR,TEXT("DisplayErrorMessage"), GetLastError());
        }
    }
	hr = HRESULT_FROM_WIN32 (dwRes);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\fxunatnd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxUnatnd.cpp
//
// Abstract:        Fax OCM Setup unattended file processing
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 27-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

static DWORD SaveSettingsFromAnswerFile();

#define prv_VALID_BOOL_VALUE_YES        _T("yes")
#define prv_VALID_BOOL_VALUE_NO         _T("no")
#define prv_VALID_BOOL_VALUE_TRUE       _T("true")
#define prv_VALID_BOOL_VALUE_FALSE      _T("false")

#define prv_HKLM                        HKEY_LOCAL_MACHINE
#define prv_HKCU                        HKEY_CURRENT_USER


///////////////////////////////
// prv_GVAR
//
// This is used as temporary
// storage so that we can
// reference the individual
// fields in the prv_UnattendedRules
// table below.
//
static struct prv_GVAR
{
    fxUnatnd_UnattendedData_t   UnattendedData;
} prv_GVAR;

///////////////////////////////
// prv_UnattendedRule_t
//
// Structure used as a table
// entry below.
//
typedef struct prv_UnattendedRule_t
{
    DWORD           dwType;
    const TCHAR     *pszFromInfKeyName;
    HKEY            hKeyTo;
    const TCHAR     *pszToRegPath;
    const TCHAR     *pszToRegKey;
    void            *pData;
    BOOL            bValid;
} prv_UnattendedRule_t;

#define RULE_CSID                               _T("Csid")
#define RULE_TSID                               _T("Tsid")
#define RULE_RINGS                              _T("Rings")
#define RULE_SENDFAXES                          _T("SendFaxes")
#define RULE_RECEIVEFAXES                       _T("ReceiveFaxes")
#define RULE_SUPPRESSCONFIGURATIONWIZARD        _T("SkipConfigWizardDeviceSettings")
// this is added here since this was the rule's name at the time we shipped XP.
#define RULE_SUPPRESSCONFIGWIZARD_LEGACY        _T("SuppressConfigurationWizard")
// 
#define RULE_ARCHIVEINCOMING                    _T("ArchiveIncoming")
#define RULE_ARCHIVEINCOMINGFOLDERNAME          _T("ArchiveIncomingFolderName")
#define RULE_ARCHIVEOUTGOING                    _T("ArchiveOutgoing")
#define RULE_ARCHIVEFOLDERNAME                  _T("ArchiveFolderName")
#define RULE_ARCHIVEOUTGOINGFOLDERNAME          _T("ArchiveOutgoingFolderName")
#define RULE_FAXUSERNAME                        _T("FaxUserName")
#define RULE_FAXUSERPASSWORD                    _T("FaxUserPassword")
#define RULE_SMTPNOTIFICATIONSENABLED           _T("SmtpNotificationsEnabled")
#define RULE_SMTPSENDERADDRESS                  _T("SmtpSenderAddress")
#define RULE_SMTPSERVERADDRESS                  _T("SmtpServerAddress")
#define RULE_SMTPSERVERPORT                     _T("SmtpServerPort")
#define RULE_SMTPSERVERAUTHENTICATIONMECHANISM  _T("SmtpServerAuthenticationMechanism")
#define RULE_FAXPRINTERNAME                     _T("FaxPrinterName")
#define RULE_FAXPRINTERSHARED                   _T("FaxPrinterIsShared")
#define RULE_ROUTETOPRINTER                     _T("RouteToPrinter")
#define RULE_ROUTEPRINTERNAME                   _T("RoutePrinterName")
#define RULE_ROUTETOEMAIL                       _T("RouteToEmail")
#define RULE_ROUTETOEMAILRECIPIENT              _T("RouteToEmailRecipient")
#define RULE_ROUTETOFOLDER                      _T("RouteToFolder")
#define RULE_ROUTEFOLDERNAME                    _T("RouteFolderName")

#define ANSWER_ANONYMOUS                        _T("Anonymous")
#define ANSWER_BASIC                            _T("Basic")
#define ANSWER_WINDOWSSECURITY                  _T("WindowsSecurity")

///////////////////////////////
// prv_UnattendedRules
//
// Simply put, these rules describe
// what registry values to set
// based on keywords found in an
// unattended file.
//
// The format of these rules is
// self explanatory after looking
// at the structure definition above.
// Basically, we read in a value from
// the unattended file which is specified
// in the 'pszFromInfKeyName'.  This is
// then stored in 'pData'.  Once
// "SaveUnattendedData" is called, 'pData'
// is committed to the registry location
// specified by 'hKeyTo' and 'pszToRegPath'
// and 'pszToRegKey'.
//
static prv_UnattendedRule_t prv_UnattendedRules[] =
{
    {REG_SZ,	 RULE_CSID,                              prv_HKLM,   REGKEY_FAX_SETUP_ORIG,  REGVAL_ROUTING_CSID,			prv_GVAR.UnattendedData.szCSID,                                 FALSE},
    {REG_SZ,     RULE_TSID,                              prv_HKLM,   REGKEY_FAX_SETUP_ORIG,  REGVAL_ROUTING_TSID,			prv_GVAR.UnattendedData.szTSID,                                 FALSE},
    {REG_DWORD,  RULE_RINGS,                             prv_HKLM,   REGKEY_FAX_SETUP_ORIG,  REGVAL_RINGS,					&prv_GVAR.UnattendedData.dwRings,                               FALSE},
    {REG_DWORD,  RULE_SENDFAXES,                         NULL,       NULL,                   NULL,							&prv_GVAR.UnattendedData.dwSendFaxes,                           FALSE},
    {REG_DWORD,  RULE_RECEIVEFAXES,                      NULL,       NULL,                   NULL,							&prv_GVAR.UnattendedData.dwReceiveFaxes,                        FALSE},
    // should we run the configuration wizard for this unattended installation
    {REG_DWORD,  RULE_SUPPRESSCONFIGURATIONWIZARD,       prv_HKLM,   REGKEY_FAX_CLIENT,      REGVAL_CFGWZRD_DEVICE,		    &prv_GVAR.UnattendedData.dwSuppressConfigurationWizard,         TRUE},
	{REG_DWORD,  RULE_SUPPRESSCONFIGWIZARD_LEGACY,       prv_HKLM,   REGKEY_FAX_CLIENT,      REGVAL_CFGWZRD_DEVICE,		    &prv_GVAR.UnattendedData.dwSuppressConfigurationWizard,         FALSE},
    // Inbox configuration.
    {REG_DWORD,  RULE_ARCHIVEINCOMING,                   prv_HKLM,   REGKEY_FAX_INBOX,       REGVAL_ARCHIVE_USE,			&prv_GVAR.UnattendedData.bArchiveIncoming,                      FALSE},
    {REG_SZ,     RULE_ARCHIVEINCOMINGFOLDERNAME,         prv_HKLM,   REGKEY_FAX_INBOX,       REGVAL_ARCHIVE_FOLDER,			prv_GVAR.UnattendedData.szArchiveIncomingDir,                   FALSE},
    // save outgoing faxes in a directory.
    {REG_DWORD,  RULE_ARCHIVEOUTGOING,                   prv_HKLM,   REGKEY_FAX_SENTITEMS,   REGVAL_ARCHIVE_USE,			&prv_GVAR.UnattendedData.bArchiveOutgoing,                      FALSE},
    {REG_SZ,     RULE_ARCHIVEFOLDERNAME,                 prv_HKLM,   REGKEY_FAX_SENTITEMS,   REGVAL_ARCHIVE_FOLDER,			prv_GVAR.UnattendedData.szArchiveOutgoingDir,                   FALSE},
    {REG_SZ,     RULE_ARCHIVEOUTGOINGFOLDERNAME,         prv_HKLM,   REGKEY_FAX_SENTITEMS,   REGVAL_ARCHIVE_FOLDER,			prv_GVAR.UnattendedData.szArchiveOutgoingDir,                   FALSE},
    // SMTP receipts and server configuration
    {REG_SZ,     RULE_FAXUSERNAME,                       prv_HKLM,   REGKEY_FAX_RECEIPTS,    REGVAL_RECEIPTS_USER,	   		prv_GVAR.UnattendedData.szFaxUserName,                          FALSE},              
    {REG_BINARY, RULE_FAXUSERPASSWORD,                   prv_HKLM,   REGKEY_FAX_RECEIPTS,    REGVAL_RECEIPTS_PASSWORD,		prv_GVAR.UnattendedData.szFaxUserPassword,                      FALSE},              
    {REG_DWORD,  RULE_SMTPNOTIFICATIONSENABLED,          NULL,       NULL,                   NULL,							&prv_GVAR.UnattendedData.bSmtpNotificationsEnabled,             FALSE},              
    {REG_SZ,     RULE_SMTPSENDERADDRESS,                 prv_HKLM,   REGKEY_FAX_RECEIPTS,    REGVAL_RECEIPTS_FROM,			prv_GVAR.UnattendedData.szSmtpSenderAddress,                    FALSE},              
    {REG_SZ,     RULE_SMTPSERVERADDRESS,                 prv_HKLM,   REGKEY_FAX_RECEIPTS,    REGVAL_RECEIPTS_SERVER,		prv_GVAR.UnattendedData.szSmptServerAddress,                    FALSE},              
    {REG_DWORD,  RULE_SMTPSERVERPORT,                    prv_HKLM,   REGKEY_FAX_RECEIPTS,    REGVAL_RECEIPTS_PORT,  		&prv_GVAR.UnattendedData.dwSmtpServerPort,                      FALSE},              
    {REG_SZ,     RULE_SMTPSERVERAUTHENTICATIONMECHANISM, NULL,       NULL,                   NULL,							prv_GVAR.UnattendedData.szSmtpServerAuthenticationMechanism,    FALSE},              
    // user information.                                                                                            
    {REG_SZ,     RULE_FAXPRINTERNAME,                    NULL,       NULL,                   NULL,							prv_GVAR.UnattendedData.szFaxPrinterName,                       FALSE},
	{REG_DWORD,  RULE_FAXPRINTERSHARED,                  prv_HKLM,   REGKEY_FAX_SETUP,		 REGVAL_IS_SHARED_FAX_PRINTER,  &prv_GVAR.UnattendedData.dwIsFaxPrinterShared,					FALSE},
    // route to printer information.                                                                                
    {REG_DWORD,  RULE_ROUTETOPRINTER,                    NULL,       NULL,                   NULL,							&prv_GVAR.UnattendedData.bRouteToPrinter,                       FALSE},
    {REG_BINARY, RULE_ROUTEPRINTERNAME,                  prv_HKLM,   REGKEY_FAX_UNASS_DATA,	 REGVAL_RM_PRINTING_GUID,		prv_GVAR.UnattendedData.szRoutePrinterName,                     FALSE},
    // route to email information.                                                                                  
    {REG_DWORD,  RULE_ROUTETOEMAIL,                      NULL,       NULL,                   NULL,							&prv_GVAR.UnattendedData.bRouteToEmail,                         FALSE},
    {REG_BINARY, RULE_ROUTETOEMAILRECIPIENT,             prv_HKLM,   REGKEY_FAX_UNASS_DATA,  REGVAL_RM_EMAIL_GUID,			prv_GVAR.UnattendedData.szRouteEmailName,                       FALSE},
    // route to a specific directory                                                                                
    {REG_DWORD,  RULE_ROUTETOFOLDER,                     NULL,       NULL,                   NULL,							&prv_GVAR.UnattendedData.bRouteToDir,                           FALSE},
    {REG_BINARY, RULE_ROUTEFOLDERNAME,                   prv_HKLM,   REGKEY_FAX_UNASS_DATA,  REGVAL_RM_FOLDER_GUID,			prv_GVAR.UnattendedData.szRouteDir,                             FALSE},

	//   Fax Applications uninstalled during Upgrade
	{REG_DWORD,   UNINSTALLEDFAX_INFKEY,				NULL,		 NULL,					 NULL,							&prv_GVAR.UnattendedData.dwUninstalledFaxApps, FALSE}

};
#define prv_NUM_UNATTENDED_RULES sizeof(prv_UnattendedRules) / sizeof(prv_UnattendedRules[0])

///////////////////////// Static Function Prototypes ///////////////////////

static BOOL prv_FindKeyName(const TCHAR             *pszID,
                            prv_UnattendedRule_t    **ppUnattendedKey);

static BOOL prv_SaveKeyValue(prv_UnattendedRule_t  *pUnattendedKey,
                             TCHAR                 *pszValue);

///////////////////////////////
// fxUnatnd_Init
//
// Initialize the unattended
// subsystem
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_Init(void)
{
    prv_UnattendedRule_t  *pUnattendedKey = NULL;
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Unattended module"),dwRes);

    memset(&prv_GVAR, 0, sizeof(prv_GVAR));

    // this is always valid, and defaults to false.
    if (prv_FindKeyName(RULE_SUPPRESSCONFIGURATIONWIZARD, &pUnattendedKey))
    {
        if (!prv_SaveKeyValue(pUnattendedKey,_T("1")))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("prv_SaveKeyValue"), GetLastError());
            pUnattendedKey->bValid = FALSE;
        }
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("prv_FindKeyName RULE_SUPPRESSCONFIGURATIONWIZARD"), GetLastError());
    }
    return dwRes;
}

///////////////////////////////
// fxUnatnd_Term
//
// Terminate the unattended subsystem
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Unattended module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxUnatnd_LoadUnattendedData
//
// Load the unattended data found
// in the unattended file according
// to the rules table above.
//
// Basically we look in the unattended
// file for the keywords in the rule
// table above, and read them into the
// passed in parameter.
//
// Params:
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_LoadUnattendedData()
{
    DWORD                   dwReturn        = NO_ERROR;
    BOOL                    bSuccess        = TRUE;
    HINF                    hInf            = faxocm_GetComponentInf();
    HINF                    hUnattendInf    = INVALID_HANDLE_VALUE;
    OCMANAGER_ROUTINES      *pHelpers       = faxocm_GetComponentHelperRoutines();
    INFCONTEXT              Context;
    prv_UnattendedRule_t    *pUnattendedKey = NULL;
    TCHAR                   szKeyName[255 + 1];
    TCHAR                   szValue[255 + 1];
    TCHAR                   szUnattendFile[MAX_PATH] = {0};

    DBG_ENTER(_T("fxUnatnd_LoadUnattendedData"),dwReturn);

    if ((hInf == NULL) || (hInf == INVALID_HANDLE_VALUE) || (pHelpers == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    faxocm_GetComponentUnattendFile(szUnattendFile,sizeof(szUnattendFile)/sizeof(szUnattendFile[0]));
    
    hUnattendInf = SetupOpenInfFile (szUnattendFile, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
    if (hUnattendInf == INVALID_HANDLE_VALUE)
    {
        VERBOSE(SETUP_ERR,
                _T("LoadUnattendData, Unattended ")
                _T("mode, but could not get Unattended file INF ")
                _T("handle. ec=%d"), GetLastError());

        return NO_ERROR;
    }

    VERBOSE(DBG_MSG, _T("Succeded to open setup unattended mode file."));
        
    if (dwReturn == NO_ERROR)
    {
        bSuccess = ::SetupFindFirstLine(hUnattendInf,
                                        UNATTEND_FAX_SECTION,
                                        NULL,
                                        &Context);

        if (bSuccess)
        {
            VERBOSE(DBG_MSG,
                    _T("Found '%s' section in unattended file, ")
                    _T("beginning unattended file processing"),
                    UNATTEND_FAX_SECTION);

            while (bSuccess)
            {
                // get the keyname of the first line in the fax section of the
                // INF file.  (Note index #0 specified in the
                // 'SetupGetStringField' API will actually get us the key name.
                // Index 1 will be the first value found after the '=' sign.

                memset(szKeyName, 0, sizeof(szKeyName));

                bSuccess = ::SetupGetStringField(
                                            &Context,
                                            0,
                                            szKeyName,
                                            sizeof(szKeyName)/sizeof(TCHAR),
                                            NULL);
                if (bSuccess)
                {
                    // find the key in our unattended table above.
                    pUnattendedKey = NULL;
                    bSuccess = prv_FindKeyName(szKeyName, &pUnattendedKey);
                }

                if (bSuccess)
                {
                    VERBOSE(DBG_MSG, _T("Found '%s' key in 'Fax' section."), szKeyName);

                    //
                    // get the keyname's value.  Notice now we get index #1
                    // which is the first value found after the '=' sign.
                    //

                    memset(szValue, 0, sizeof(szValue));

                    bSuccess = ::SetupGetStringField(
                                                 &Context,
                                                 1,
                                                 szValue,
                                                 sizeof(szValue)/sizeof(TCHAR),
                                                 NULL);

                    VERBOSE(DBG_MSG, _T("The value we read is : %s."), szValue);
                }

                if (bSuccess)
                {
                    //
                    // save the keyname's value in the dataptr
                    //
                    bSuccess = prv_SaveKeyValue(pUnattendedKey, szValue);
                }

                // move to the next line in the unattended file fax section.
                bSuccess = ::SetupFindNextLine(&Context, &Context);
            }
        }
        else
        {
            dwReturn = GetLastError();
            VERBOSE(DBG_WARNING, _T("::SetupFindFirstLine() failed, ec = %ld"), dwReturn);
        }
    }

    SetupCloseInfFile(hUnattendInf);

    return dwReturn;
}

///////////////////////////////
// fxUnatnd_SaveUnattendedData
//
// Commit the unattended data
// we read from the file to the
// registry.
//
// Params:
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxUnatnd_SaveUnattendedData()
{
    DWORD   dwReturn    = NO_ERROR;
    DWORD   i           = 0;
    HKEY    hKey        = NULL;
    DWORD   dwDataSize  = 0;
    LRESULT lResult     = ERROR_SUCCESS;
    prv_UnattendedRule_t    *pRule = NULL;
	DWORD				dwDisposition;

    DBG_ENTER(_T("fxUnatnd_SaveUnattendedData"),dwReturn);

    // Iterate through each unattended rule.
    // If the hKeyTo is not NULL, then write the value of pData to the
    // specified registry location.

    for (i = 0; i < prv_NUM_UNATTENDED_RULES; i++)
    {
        pRule = &prv_UnattendedRules[i];

        if ((pRule->hKeyTo != NULL) && (pRule->bValid))
        {
            lResult = ::RegCreateKeyEx(
				pRule->hKeyTo,                                  // handle to open key
				pRule->pszToRegPath,                           // subkey name
				0,                             // reserved
				NULL,                             // class string
				REG_OPTION_NON_VOLATILE,                            // special options
				KEY_WRITE,                          // desired security access
				NULL, // inheritance
				&hKey,                            // key handle 
				&dwDisposition                     // disposition value buffer
				);

            if (lResult == ERROR_SUCCESS)
            {
                dwDataSize = 0;

                if (pRule->dwType == REG_SZ ||
					pRule->dwType == REG_BINARY)  // Binary data must be NULL terminated.
                {
                    dwDataSize = sizeof(TCHAR) * (StringSize((TCHAR*) pRule->pData));
                    // write the value to the registry.
                    lResult = ::RegSetValueEx(hKey,
                                              pRule->pszToRegKey,
                                              0,
                                              pRule->dwType,
                                              (BYTE*) pRule->pData,
                                              dwDataSize);					
                }
                else if (pRule->dwType == REG_DWORD)
                {
                    dwDataSize = sizeof(DWORD);
                    // write the value to the registry.
                    lResult = ::RegSetValueEx(hKey,
                                              pRule->pszToRegKey,
                                              0,
                                              pRule->dwType,
                                              (BYTE*) &(pRule->pData),
                                              dwDataSize);					
                }				
                else
                {
                    VERBOSE(SETUP_ERR,
                            _T("SaveUnattendedData ")
                            _T("do not recognize data type = '%lu'"),
                            pRule->dwType);
                }

				if (ERROR_SUCCESS != lResult)
				{
					VERBOSE(SETUP_ERR,_T("RegSetValueEx failed (ec=%d). value name :%s"),lResult, pRule->pszToRegKey);
				}
            }
			else
			{
				VERBOSE(SETUP_ERR,_T("RegCreateKeyEx failed (ec=%d). Key:%s"),lResult, pRule->pszToRegPath);
			}

            if (hKey)
            {
                ::RegCloseKey(hKey);
            }
        }
    }

    // now save dynamic data...
    lResult = SaveSettingsFromAnswerFile();
    if (lResult!=ERROR_SUCCESS)
    {
        VERBOSE(SETUP_ERR,_T("SaveSettingsFromAnswerFile failed (ec=%d)"),GetLastError());
    }

    //
    //  Mark which Fax Applications were installed before the upgrade
    //
    prv_UnattendedRule_t* pUnattendedKey = NULL;
    if ((prv_FindKeyName(UNINSTALLEDFAX_INFKEY, &pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        fxocUpg_WhichFaxWasUninstalled((DWORD)(PtrToUlong(pUnattendedKey->pData)));
    }

    return dwReturn;
}

TCHAR* fxUnatnd_GetPrinterName()
{
    TCHAR* retValue = NULL;
    prv_UnattendedRule_t* pUnattendedKey = NULL;
    if (prv_FindKeyName(
        RULE_FAXPRINTERNAME,
        &pUnattendedKey))
    {
        retValue = (TCHAR *) (pUnattendedKey->pData);
    }
    return retValue;    
}

/*++
Return value:
  TRUE - FaxPrinterIsShared was defined in answer file
  FALSE - FaxPrinterIsShared was not defined in answer file
--*/
BOOL fxUnatnd_IsPrinterRuleDefined()
{
    prv_UnattendedRule_t* pUnattendedKey = NULL;
    return (prv_FindKeyName(RULE_FAXPRINTERSHARED,&pUnattendedKey) && (pUnattendedKey->bValid));
}

/*++
Return value:
  TRUE - Printer should be shared (because FaxPrinterIsShared was defined 
         in answer file as true/etc.)
  FALSE - Printer should not be shared (because FaxPrinterIsShared was defined in answer
         file as false/etc., or because FaxPrinterIsShared was not defined at all)
--*/
BOOL fxUnatnd_GetIsPrinterShared()
{
    prv_UnattendedRule_t* pUnattendedKey = NULL;
    if (prv_FindKeyName(RULE_FAXPRINTERSHARED,&pUnattendedKey) && (pUnattendedKey->bValid))
    {
        return (BOOL)PtrToUlong(pUnattendedKey->pData);
    }
    return FALSE;    
}

///////////////////////////////
// prv_FindKeyName
//
// Find specified key name in our table
//
// Params:
//      - pszKeyName - key name to search for.
//      - ppUnattendedKey - OUT - rule we found.
// Returns:
//      - TRUE if we found the keyname
//      - FALSE otherwise.
//
static BOOL prv_FindKeyName(const TCHAR              *pszKeyName,
                            prv_UnattendedRule_t     **ppUnattendedKey)
{
    BOOL  bFound   = FALSE;
    DWORD i        = 0;

    if ((pszKeyName     == NULL) ||
        (ppUnattendedKey == NULL))

    {
        return FALSE;
    }

    for (i = 0; (i < prv_NUM_UNATTENDED_RULES) && (!bFound); i++)
    {
        if (_tcsicmp(pszKeyName, prv_UnattendedRules[i].pszFromInfKeyName) == 0)
        {
            bFound = TRUE;
            *ppUnattendedKey = &prv_UnattendedRules[i];
        }
    }

    return bFound;
}

///////////////////////////////
// prv_SaveKeyValue
//
// Store the specified value
// with the specified rule
//
// Params:
//      - pUnattendedKey - rule where the value will be stored
//      - pszValue       - value to store.
// Returns:
//      - TRUE on success.
//      - FALSE otherwise.
//
static BOOL prv_SaveKeyValue(prv_UnattendedRule_t  *pUnattendedKey,
                             TCHAR                 *pszValue)
{
    BOOL    bSuccess     = TRUE;
    //DWORD dwBufferSize = 0;

    DBG_ENTER(_T("prv_SaveKeyValue"), bSuccess);

    if ((pUnattendedKey == NULL) ||
        (pszValue       == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (bSuccess)
    {
        switch (pUnattendedKey->dwType)
        {
            case REG_SZ:
			case REG_BINARY:  // binary data must be NULL terminated.
                _tcsncpy((TCHAR*) pUnattendedKey->pData,
                         pszValue,
                         _MAX_PATH
                         );
            break;

            case REG_DWORD:
                // check if we got a true/false, or yes/no.
                if ((!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_YES)) ||
                    (!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_TRUE)))
                {
                    pUnattendedKey->pData = (void*) TRUE;
                }
                else if ((!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_NO)) ||
                         (!_tcsicmp(pszValue, prv_VALID_BOOL_VALUE_FALSE)))
                {
                    pUnattendedKey->pData = (void*) FALSE;
                }
                else
                {
                    // assume the value if an integer.
                    pUnattendedKey->pData = ULongToPtr(_tcstoul(pszValue, NULL, 10));
                }

            break;
        }
    }
    pUnattendedKey->bValid = TRUE;
    return bSuccess;
}




///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  ConfigureSMTPFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for SMTP
//                  receipts and try to set the server configuration
//
//  Params:
//                  HANDLE hFaxHandle - handle from FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 22-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL ConfigureSMTPFromAnswerFile(HANDLE hFaxHandle)
{
    BOOL                    bRet                = TRUE;
    DWORD                   dwErr               = NO_ERROR;
    PFAX_RECEIPTS_CONFIGW   pFaxReceiptsConfigW = NULL;
    prv_UnattendedRule_t*   pUnattendedKey      = NULL;
	DWORD					dwSMTPAuthOption	= 0xffffffff;
	BOOL					bAllowEmail			= FALSE;	
	HKEY					hKey				= NULL;

    DBG_ENTER(_T("ConfigureSMTPFromAnswerFile"),bRet);

	// get SmtpServerAuthenticationMechanism
	if ((prv_FindKeyName(RULE_SMTPSERVERAUTHENTICATIONMECHANISM,&pUnattendedKey)) && (pUnattendedKey->bValid))
	{
		if (_tcsicmp((TCHAR*)pUnattendedKey->pData,ANSWER_ANONYMOUS)==0)
		{
			dwSMTPAuthOption = FAX_SMTP_AUTH_ANONYMOUS;
		}
		else if (_tcsicmp((TCHAR*)pUnattendedKey->pData,ANSWER_BASIC)==0)
		{
			dwSMTPAuthOption = FAX_SMTP_AUTH_BASIC;			
		}
		else if (_tcsicmp((TCHAR*)pUnattendedKey->pData,ANSWER_WINDOWSSECURITY)==0)
		{
			dwSMTPAuthOption = FAX_SMTP_AUTH_NTLM;
		}		
	}

	// get SmtpNotificationsEnabled
	if ((prv_FindKeyName(RULE_SMTPNOTIFICATIONSENABLED,&pUnattendedKey)) && (pUnattendedKey->bValid))
	{
		bAllowEmail = TRUE;		
	}  

	if (NULL == hFaxHandle)
	{
		//
		// No connection to the fax service.
		// The unattended data is stored directly in the registry.
		// Just add the data that could not be written in the general section of fxUnatnd_SaveUnattendedData()		 
		// Open the Receipts registry key
		hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_RECEIPTS, FALSE, KEY_READ | KEY_WRITE);
		if (NULL == hKey)
		{			
			VERBOSE(SETUP_ERR,_T("OpenRegistryKey failed (ec=%d)"),GetLastError());
			goto exit;
		}

		// write the values to the registry
		if (0xffffffff != dwSMTPAuthOption)
		{
			// write the value to the registry.
			if (!SetRegistryDword(hKey,
				REGVAL_RECEIPTS_SMTP_AUTH_TYPE,				
				dwSMTPAuthOption))		                    			
			{
				VERBOSE(SETUP_ERR,_T("SetRegistryDword failed (ec=%d)"),GetLastError());
				goto exit;
			}
		}

		if (TRUE == bAllowEmail)
		{
			DWORD dwReceiptType;			
			//
			// Add DRT_EMAIL to the current settings
			//
			dwErr = GetRegistryDwordEx(hKey,
				REGVAL_RECEIPTS_TYPE,				
				&dwReceiptType);
			if (ERROR_SUCCESS != dwErr)
			{
				VERBOSE(SETUP_ERR,_T("GetRegistryDwordEx failed (ec=%d)"),dwErr);
				goto exit;
			}

			dwReceiptType |= DRT_EMAIL;
			// write the value to the registry.
			if (!SetRegistryDword(hKey,
				REGVAL_RECEIPTS_TYPE,				
				dwReceiptType)) 			                    			
			{
				VERBOSE(SETUP_ERR,_T("SetRegistryDword failed (ec=%d)"),dwErr);
				goto exit;
			}
		}	
	}     
	else
	{
		//
		// We have a connection to the fax service.
        // Use it to configure the server.
		//

		// call FaxGetReceiptsConfiguration
		if (!FaxGetReceiptsConfiguration(hFaxHandle,&pFaxReceiptsConfigW))
		{
			dwErr = GetLastError();
			VERBOSE(SETUP_ERR,_T("FaxGetReceiptsConfigurationW failed (ec=%d)"),dwErr);
			goto exit;
		}
		// get FaxUserName, this is the lptstrSMTPUserName member of PFAX_RECEIPTS_CONFIGW
		if ((prv_FindKeyName(RULE_FAXUSERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
		{
			pFaxReceiptsConfigW->lptstrSMTPUserName = (TCHAR*)pUnattendedKey->pData;
		}
		// get FaxUserPassword, this is the lptstrSMTPPassword member of PFAX_RECEIPTS_CONFIGW
		if ((prv_FindKeyName(RULE_FAXUSERPASSWORD,&pUnattendedKey)) && (pUnattendedKey->bValid))
		{
			pFaxReceiptsConfigW->lptstrSMTPPassword = (TCHAR*)pUnattendedKey->pData;
		}
		// get SmtpNotificationsEnabled, this is part of dwAllowedReceipts member of PFAX_RECEIPTS_CONFIGW
		if (TRUE == bAllowEmail)
		{
			pFaxReceiptsConfigW->dwAllowedReceipts |= DRT_EMAIL;
		}
		// get SmtpSenderAddress, this is the lptstrSMTPFrom member of PFAX_RECEIPTS_CONFIGW
		if ((prv_FindKeyName(RULE_SMTPSENDERADDRESS,&pUnattendedKey)) && (pUnattendedKey->bValid))
		{
			pFaxReceiptsConfigW->lptstrSMTPFrom = (TCHAR*)pUnattendedKey->pData;
		}
		// get SmptServerAddress, this is the lptstrSMTPServer member of PFAX_RECEIPTS_CONFIGW
		if ((prv_FindKeyName(RULE_SMTPSERVERADDRESS,&pUnattendedKey)) && (pUnattendedKey->bValid))
		{
			pFaxReceiptsConfigW->lptstrSMTPServer = (TCHAR*)pUnattendedKey->pData;
		}
		// get SmtpServerPort, this is the dwSMTPPort member of PFAX_RECEIPTS_CONFIGW
		if ((prv_FindKeyName(RULE_SMTPSERVERPORT,&pUnattendedKey)) && (pUnattendedKey->bValid))
		{
			pFaxReceiptsConfigW->dwSMTPPort = (DWORD)(PtrToUlong(pUnattendedKey->pData));
		}
		// get SmtpServerAuthenticationMechanism, this is the SMTPAuthOption member of PFAX_RECEIPTS_CONFIGW
		if (0xffffffff != dwSMTPAuthOption)
		{			
			pFaxReceiptsConfigW->SMTPAuthOption = (FAX_ENUM_SMTP_AUTH_OPTIONS)dwSMTPAuthOption;			
		}

		// now set the new configuration
		if (!FaxSetReceiptsConfiguration(hFaxHandle,pFaxReceiptsConfigW))
		{
			dwErr = GetLastError();
			VERBOSE(SETUP_ERR,_T("FaxSetReceiptsConfigurationW failed (ec=%d)"),dwErr);
			goto exit;
		}
	}

exit:
    if (pFaxReceiptsConfigW)
    {
        FaxFreeBuffer(pFaxReceiptsConfigW);
    }

	if (hKey)
	{
		::RegCloseKey(hKey);
	}

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  ConfigureArchivesFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for Archives
//                  and try to set the server configuration
//
//  Params:
//                  HANDLE hFaxHandle - handle from FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 22-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL ConfigureArchivesFromAnswerFile(HANDLE hFaxHandle)
{
    BOOL                    bRet                        = TRUE;
    DWORD                   dwErr                       = NO_ERROR;
    PFAX_ARCHIVE_CONFIGW    pFaxInboxArchiveConfigW     = NULL;
    PFAX_ARCHIVE_CONFIGW    pFaxSentItemsArchiveConfigW = NULL;
    prv_UnattendedRule_t*   pUnattendedKey              = NULL;

    DBG_ENTER(_T("ConfigureArchivesFromAnswerFile"),bRet);

	if (NULL == hFaxHandle)
	{
		return bRet; // All data is conifigured directly to the registry. 
	}

    // call FaxGetArchiveConfiguration to get the inbox configuration
    if (FaxGetArchiveConfiguration(hFaxHandle,FAX_MESSAGE_FOLDER_INBOX,&pFaxInboxArchiveConfigW))
    {
        // Inbox enable
        if ((prv_FindKeyName(RULE_ARCHIVEINCOMING,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxInboxArchiveConfigW->bUseArchive= (BOOL)PtrToUlong(pUnattendedKey->pData);
        }
        // Inbox folder
        if ((prv_FindKeyName(RULE_ARCHIVEINCOMINGFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxInboxArchiveConfigW->lpcstrFolder= (TCHAR*)(pUnattendedKey->pData);
        }
        // now set the new configuration
        if (FaxSetArchiveConfiguration(hFaxHandle,FAX_MESSAGE_FOLDER_INBOX,pFaxInboxArchiveConfigW))
        {
            dwErr = GetLastError();
            VERBOSE(DBG_WARNING,_T("FaxSetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
        }
    }
    else
    {
        dwErr = GetLastError();
        VERBOSE(DBG_WARNING,_T("FaxGetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
    }

    // call FaxGetArchiveConfiguration to get the SentItems configuration
    if (FaxGetArchiveConfiguration(hFaxHandle,FAX_MESSAGE_FOLDER_SENTITEMS,&pFaxSentItemsArchiveConfigW))
    {
        // SentItems enable
        if ((prv_FindKeyName(RULE_ARCHIVEOUTGOING,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxSentItemsArchiveConfigW->bUseArchive= (BOOL)PtrToUlong(pUnattendedKey->pData);
        }
        // SentItems folder
        if ((prv_FindKeyName(RULE_ARCHIVEFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxSentItemsArchiveConfigW->lpcstrFolder= (TCHAR*)(pUnattendedKey->pData);
        }
        // SentItems folder could also come from this rule
        if ((prv_FindKeyName(RULE_ARCHIVEOUTGOINGFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            pFaxSentItemsArchiveConfigW->lpcstrFolder= (TCHAR*)(pUnattendedKey->pData);
        }
        // now set the new configuration
        if (FaxSetArchiveConfiguration(hFaxHandle,FAX_MESSAGE_FOLDER_SENTITEMS,pFaxSentItemsArchiveConfigW))
        {
            dwErr = GetLastError();
            VERBOSE(DBG_WARNING,_T("FaxSetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
        }
    }
    else
    {
        dwErr = GetLastError();
        VERBOSE(DBG_WARNING,_T("FaxGetArchiveConfigurationW FAX_MESSAGE_FOLDER_INBOX failed (ec=%d)"),dwErr);
    }

    if (pFaxInboxArchiveConfigW)
    {
        FaxFreeBuffer(pFaxInboxArchiveConfigW);
    }
    if (pFaxSentItemsArchiveConfigW)
    {
        FaxFreeBuffer(pFaxSentItemsArchiveConfigW);
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetPerDeviceConfigFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for device
//                  settings and routing extension settings
//                  and set all the existing devices.
//
//  Params:
//                  HANDLE hFaxHandle - handle from FaxConnectFaxServer
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 12-mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD SetPerDeviceConfigFromAnswerFile(HANDLE hFaxHandle)
{
    DWORD                           dwErr                           = ERROR_SUCCESS;
    PFAX_PORT_INFO_EXW              pFaxPortInfoExW                 = NULL;
    DWORD                           dwNumPorts                      = 0;
    DWORD                           dwIndex                         = 0;
    DWORD                           dwFlags                         = 0;
    prv_UnattendedRule_t*           pUnattendedKey                  = NULL;
	HKEY							hKey							= NULL;

    DBG_ENTER(_T("SetPerDeviceConfigFromAnswerFile"),dwErr);

	// handle Route to Folder, printer and Email- enable
    if ((prv_FindKeyName(RULE_ROUTETOPRINTER,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        dwFlags |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? LR_PRINT : 0;
    }
    if ((prv_FindKeyName(RULE_ROUTETOFOLDER,&pUnattendedKey)) && (pUnattendedKey->bValid))
    {
        dwFlags |= ((BOOL) PtrToUlong(pUnattendedKey->pData)) ? LR_STORE : 0;
    }
    if (!IsDesktopSKU())
    {
        if ((prv_FindKeyName(RULE_ROUTETOEMAIL,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL) PtrToUlong(pUnattendedKey->pData)) ? LR_EMAIL : 0;
        }
    }

	if (NULL == hFaxHandle)
	{
		//
		// No connection to the fax service.
		// The unattended data is stored directly in the registry.
		// Just add the data that could not be written in the general section of fxUnatnd_SaveUnattendedData()		 
		// Open the Receipts registry key
		hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_UNASS_DATA, FALSE, KEY_WRITE);
		if (NULL == hKey)
		{			
			VERBOSE(SETUP_ERR,_T("OpenRegistryKey failed (ec=%d)"),GetLastError());
			goto exit;
		}

		// write the values to the registry
		if (0 != dwFlags)
		{
			// write the value to the registry.
			if (!SetRegistryBinary(hKey,
				REGVAL_RM_FLAGS_GUID,				
				(BYTE*)&dwFlags,
				sizeof(dwFlags)))		                    			
			{
				VERBOSE(SETUP_ERR,_T("SetRegistryBinary failed (ec=%d)"),GetLastError());
				goto exit;
			}
		}		
	}
	else
	{
		// call EnumPortsEx
		if (!FaxEnumPortsEx(hFaxHandle,&pFaxPortInfoExW,&dwNumPorts))
		{
			dwErr = GetLastError();
			VERBOSE(SETUP_ERR,_T("FaxEnumPortsEx failed (ec=%d)"),dwErr);
			goto exit;
		}

		for (dwIndex=0; dwIndex<dwNumPorts; dwIndex++)
		{
			// handle CSID
			if ((prv_FindKeyName(RULE_CSID,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				pFaxPortInfoExW[dwIndex].lptstrCsid = (TCHAR*)pUnattendedKey->pData;
			}

			// handle TSID
			if ((prv_FindKeyName(RULE_TSID,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				pFaxPortInfoExW[dwIndex].lptstrTsid = (TCHAR*)pUnattendedKey->pData;
			}

			// handle Rings
			if ((prv_FindKeyName(RULE_RINGS,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				pFaxPortInfoExW[dwIndex].dwRings = (DWORD)(PtrToUlong(pUnattendedKey->pData));
			}

			// handle Flags
			if ((prv_FindKeyName(RULE_SENDFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				pFaxPortInfoExW[dwIndex].bSend = ((BOOL)PtrToUlong(pUnattendedKey->pData));
			}
			if ((prv_FindKeyName(RULE_RECEIVEFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				pFaxPortInfoExW[dwIndex].ReceiveMode = ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF;
			}

			// Set CSID, TSID and Rings
			if(!FaxSetPortEx(hFaxHandle, pFaxPortInfoExW[dwIndex].dwDeviceID, &pFaxPortInfoExW[dwIndex]))
			{
				dwErr = GetLastError();
				VERBOSE(SETUP_ERR,_T("Can't save fax port data. Error code is %d."),dwErr);
				// nothing to worry about, let's try some other answers...
				dwErr = ERROR_SUCCESS;
			}

			// handle Route to Folder - folder name
			if ((prv_FindKeyName(RULE_ROUTEFOLDERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				if(!FaxSetExtensionData(hFaxHandle, 
										pFaxPortInfoExW[dwIndex].dwDeviceID, 
										REGVAL_RM_FOLDER_GUID, 
										(LPBYTE)pUnattendedKey->pData, 
										StringSize((TCHAR*)(pUnattendedKey->pData))) )
				{
					dwErr = GetLastError();
					VERBOSE(SETUP_ERR, 
								_T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
								pFaxPortInfoExW[dwIndex].dwDeviceID, 
								REGVAL_RM_FOLDER_GUID,
								dwErr);
					// nothing to worry about, let's try some other answers...
					dwErr = ERROR_SUCCESS;
				}
			}

			// handle Route to Printer - printer name
			if ((prv_FindKeyName(RULE_ROUTEPRINTERNAME,&pUnattendedKey)) && (pUnattendedKey->bValid))
			{
				if(!FaxSetExtensionData(hFaxHandle, 
										pFaxPortInfoExW[dwIndex].dwDeviceID, 
										REGVAL_RM_PRINTING_GUID, 
										(LPBYTE)pUnattendedKey->pData, 
										StringSize((TCHAR*)(pUnattendedKey->pData))) )
				{
					dwErr = GetLastError();
					VERBOSE(SETUP_ERR, 
								_T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
								pFaxPortInfoExW[dwIndex].dwDeviceID, 
								REGVAL_RM_FOLDER_GUID,
								dwErr);
					// nothing to worry about, let's try some other answers...
					dwErr = ERROR_SUCCESS;
				}
			}
			if (!IsDesktopSKU())
			{
				// handle Route to Email - email name
				if ((prv_FindKeyName(RULE_ROUTETOEMAILRECIPIENT,&pUnattendedKey)) && (pUnattendedKey->bValid))
				{
					if(!FaxSetExtensionData(hFaxHandle, 
											pFaxPortInfoExW[dwIndex].dwDeviceID, 
											REGVAL_RM_EMAIL_GUID, 
											(LPBYTE)pUnattendedKey->pData, 
											StringSize((TCHAR*)(pUnattendedKey->pData))) )
					{
						dwErr = GetLastError();
						VERBOSE(SETUP_ERR, 
									_T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
									pFaxPortInfoExW[dwIndex].dwDeviceID, 
									REGVAL_RM_EMAIL_GUID,
									dwErr);
						// nothing to worry about, let's try some other answers...
						dwErr = ERROR_SUCCESS;
					}
				}
			}
			// handle Route to Folder, printer and Email- enable			
			if(!FaxSetExtensionData(hFaxHandle, 
									pFaxPortInfoExW[dwIndex].dwDeviceID, 
									REGVAL_RM_FLAGS_GUID, 
									(LPBYTE)&dwFlags, 
									sizeof(DWORD)) )
			{
				dwErr = GetLastError();
				VERBOSE(SETUP_ERR, 
							_T("FaxSetExtensionData failed: Device Id=%d, routing GUID=%s, error=%d."), 
							pFaxPortInfoExW[dwIndex].dwDeviceID, 
							REGVAL_RM_FOLDER_GUID,
							dwErr);
				// nothing to worry about, let's try some other answers...
				dwErr = ERROR_SUCCESS;
			}
		}
	}

exit:
    if (pFaxPortInfoExW)
    {
        FaxFreeBuffer(pFaxPortInfoExW);
    }
	
	if(hKey)
	{
		::RegCloseKey (hKey);
	}

    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SaveSettingsFromAnswerFile
//
//  Purpose:        Get all the answers that are applicable for device
//                  settings and routing extension settings
//                  and set all the existing devices.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 12-mar-2001
///////////////////////////////////////////////////////////////////////////////////////
static DWORD SaveSettingsFromAnswerFile()
{
    DWORD                           dwErr                           = ERROR_SUCCESS;
    HANDLE                          hFaxHandle                      = NULL;
    prv_UnattendedRule_t*           pUnattendedKey                  = NULL;

    DBG_ENTER(_T("SaveSettingsFromAnswerFile"),dwErr);

	if (fxState_IsStandAlone())
	{
		//
		// This is a stand alone installation. Connect to the fax service and use it to configure the dynamic data.
		//
		if (!FaxConnectFaxServer(NULL,&hFaxHandle))
		{
			dwErr = GetLastError();
			VERBOSE(SETUP_ERR,_T("FaxConnectFaxServer failed (ec=%d)"),dwErr);
			goto exit;
		}
	}
	else
	{
		//
		// We are in GUI mode setup, and we should not start the service as not all system resources are available.
		// Use the registry to configure the fax service.
		// The fax service will read the data when it is first started after reboot (at the end of GUI mode).
		//
	}

	// set the SMTP server configuration, on Server SKUs only
	if (!IsDesktopSKU())
	{
		if (!ConfigureSMTPFromAnswerFile(hFaxHandle))
		{
			dwErr = GetLastError();
			VERBOSE(DBG_WARNING,_T("ConfigureSMTPFromAnswerFile failed (ec=%d)"),dwErr);
			// this is not fatal, continue...
		}
	}

	if (!ConfigureArchivesFromAnswerFile(hFaxHandle))
	{
		dwErr = GetLastError();
		VERBOSE(DBG_WARNING,_T("ConfigureArchivesFromAnswerFile failed (ec=%d)"),dwErr);
		// this is not fatal, continue...
	}

	if (SetPerDeviceConfigFromAnswerFile(hFaxHandle)!=NO_ERROR)
	{
		dwErr = GetLastError();
		VERBOSE(DBG_WARNING,_T("SetPerDeviceConfigFromAnswerFile failed (ec=%d)"),dwErr);
		// this is not fatal, continue...
	}

    // finally set HKLM... Fax\Setup\Original Setup Data REG_DWORD Flags to configure any future device.
    HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP_ORIG,FALSE,KEY_WRITE);
    if (hKey)
    {
        BOOL bFound = FALSE;
        DWORD dwFlags = 0;
        if ((prv_FindKeyName(RULE_SENDFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? FPF_SEND : 0;
            bFound = TRUE;
        }
        if ((prv_FindKeyName(RULE_RECEIVEFAXES,&pUnattendedKey)) && (pUnattendedKey->bValid))
        {
            dwFlags |= ((BOOL)PtrToUlong(pUnattendedKey->pData)) ? FPF_RECEIVE : 0;
            bFound = TRUE;
        }
        if (bFound)
        {
            if (!SetRegistryDword(hKey,REGVAL_FLAGS,dwFlags))
            {
                CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryDword(REGVAL_FLAGS)"), GetLastError());
            }
        }
        RegCloseKey(hKey);
    }
    else
    {
        CALL_FAIL(SETUP_ERR,TEXT("OpenRegistryKey"),GetLastError());
    }

exit:
    if (hFaxHandle)
    {
        FaxClose(hFaxHandle);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Setup OCM resource ID file                   //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [14500 - 14999]                                  //
//                                                  //
//////////////////////////////////////////////////////

#ifndef _OCM_RESOURCE_H_
#define _OCM_RESOURCE_H_

#define IDD_WHERE_DID_MY_FAX_GO         14500
#define IDC_WHERE_DID_MY_FAX_GO_TXT     14501
#define IDC_WHERE_DID_MY_FAX_GO_ICON    14502
#define IDC_REMOVE_LINK                 14503
#define IDI_FAX_ICON                    14504
#define IDR_IFAXCONTROL                 14505

#define IDS_CLIENT_NOT_INSTALLED_TITLE  14506
#define IDS_CLIENT_NOT_INSTALLED        14507

//////////////////////////////////////////////////////
//                                                  //
// Fax Setup OCM resource ID file                   //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [14500 - 14999]                                  //
//                                                  //
//////////////////////////////////////////////////////


//////////////////////////////////////////////////////
//                                                  //
// Fax Setup OCM resource ID file                   //
// Compiles into fxsocm.dll                         //
// Still, all the IDs should be in range            //
//                                                  //
// [14500 - 14999]                                  //
//                                                  //
//////////////////////////////////////////////////////

#define IDD_OCM_WIZARD_PAGE             14508
#define IDC_SHARE_PRINTER               14509
#define IDC_DO_NOT_SHARE_PRINTER        14510

#define IDS_WIZARD_PAGE_TITLE           14511
#define IDS_WIZARD_PAGE_SUBTITLE        14512

#define IDC_TEXT1                       14513
#define IDC_TEXT2                       14514
#define IDC_TEXT3                       14515

#endif // _OCM_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\ifaxcontrol.h ===
// IFaxControl.h : Declaration of the CFaxControl

#ifndef __IFAXCONTROL_H_
#define __IFAXCONTROL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFaxControl
class ATL_NO_VTABLE CFaxControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxControl, &CLSID_FaxControl>,
	public IDispatchImpl<IFaxControl, &IID_IFaxControl, &LIBID_FAXCONTROLLib>
{
public:
	CFaxControl()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IFAXCONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxControl)
	COM_INTERFACE_ENTRY(IFaxControl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxControl
public:
	STDMETHOD(get_IsLocalFaxPrinterInstalled)(/*[out, retval]*/ VARIANT_BOOL *pbVal);
	STDMETHOD(get_IsFaxServiceInstalled)(/*[out, retval]*/ VARIANT_BOOL *pbVal);
	STDMETHOD(InstallLocalFaxPrinter)();
	STDMETHOD(InstallFaxService)();
};

#endif //__IFAXCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\ocm\test\faxcontroltest.cpp ===
// This sample demonstrates how to use the IFaxControl COM interface.

#include <conio.h>
#include <iostream>

// Import the fax service fxsocm.dll file so that fax service COM object can be used.
// The typical path to fxsocm.dll is shown. 
// If this path is not correct, search for fxsocm.dll and replace with the right path.
// The path below will be used during compile-time only. At run-time, the path is never used.
#import "c:\Windows\System32\setup\fxsocm.dll" no_namespace

using namespace std;

int main (int argc, char *argv[])
{
    try
    {
        HRESULT hr;
        //    
        // Define variables.
        //
        IFaxControlPtr sipFaxControl;
        //
        // Initialize the COM library on the current thread.
        //
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //
        // Create the object.
        //
        hr = sipFaxControl.CreateInstance("FaxControl.FaxControl.1");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //
        // Test for the existance of the Fax component
		//
		if (!sipFaxControl->IsFaxServiceInstalled)
		{
		    //
		    // Fax isn't installed
		    //
		    printf ("Fax is NOT installed.\n");
		    if (2 == argc && !stricmp ("install", argv[1]))
		    {
		        //
		        // Use asked us to install fax
		        //
		        printf ("Installing fax...\n");
		        sipFaxControl->InstallFaxService();
		        return 0;
		    }
		    else
		    {   
		        printf ("Run this tool again with 'install' command line argument to install fax.\n");
		        return 0;
		    }
		}
		else
		{
		    //
		    // Fax is installed
		    //
		    printf ("Fax is installed.\n");
		}
        //
        // Test for the existance of a local Fax Printer
		//
		if (!sipFaxControl->IsLocalFaxPrinterInstalled)
		{
		    //
		    // Fax printer isn't installed
		    //
		    printf ("Fax printer is NOT installed.\n");
		    if (2 == argc && !stricmp ("install", argv[1]))
		    {
		        //
		        // Use asked us to install fax
		        //
		        printf ("Installing fax printer...\n");
		        sipFaxControl->InstallLocalFaxPrinter();
		        return 0;
		    }
		    else
		    {   
		        printf ("Run this tool again with 'install' command line argument to install a fax printer.\n");
		        return 0;
		    }
		}
		else
		{
		    //
		    // Fax printer is installed
		    //
		    printf ("Fax printer is installed.\n");
		}
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\util\setup.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    product.c

Abstract:

    This file implements common setup routines for fax.

Author:

    Mooly Beery (MoolyB) 16-Aug-2000

Environment:

    User Mode

--*/
#include <SetupUtil.h>
#include <MsiQuery.h>

// 
//
// Function:    PrivateMsiGetProperty
// Description: Gets a property from Windows Installer API 
//              In case of failure , returns FALSE
//              In case of success , returns TRUE
//              GetLastError() to get the error code in case of failure.
//
// Remarks:     
//
//
// Author:      MoolyB
BOOL PrivateMsiGetProperty
(
    MSIHANDLE hInstall,    // installer handle
    LPCTSTR szName,        // property identifier, case-sensitive
    LPTSTR szValueBuf      // buffer for returned property value
)
{
    UINT    uiRet   = ERROR_SUCCESS;
    int     iCount  = 0;
    DWORD   cchValue = MAX_PATH;

    DBG_ENTER(TEXT("PrivateMsiGetProperty"));

    uiRet = MsiGetProperty(hInstall,szName,szValueBuf,&cchValue);
    if (uiRet==ERROR_SUCCESS && (iCount=_tcslen(szValueBuf)))
    {
        VERBOSE(    DBG_MSG,
                    _T("MsiGetProperty:%s returned %s."),
                    szName,
                    szValueBuf);
    }
    else if (iCount==0)
    {
        VERBOSE(GENERAL_ERR, 
                _T("MsiGetProperty:%s returned an empty string."),
                szName);

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    else
    {
        VERBOSE(GENERAL_ERR, 
                _T("MsiGetProperty:%s failed (ec: %ld)."),
                szName,
                uiRet);

        SetLastError(uiRet);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\util\install.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    install.c

Abstract:

    This file contains common setup routines for fax.

Author:

    Iv Garber (ivg) May-2001

Environment:

    User Mode

--*/
#include "SetupUtil.h"
#include "FaxSetup.h"
#include "FaxUtil.h"

DWORD CheckInstalledFax(
	IN	DWORD	dwFaxToCheck,
	OUT	DWORD*	pdwFaxInstalled
)
/*++

Routine name : CheckInstalledFax

Routine description:

    Checks whether SBS 5.0 / .NET SB3 / .NET RC1 client or SBS 5.0 Server are installed 

Arguments:

	IN	DWORD dwFaxToCheck		-	input parameter, bit-wise combination of fxState_UpgradeApp_e values to define
									the fax applications to check for presence
	OUT	DWORD *pdwFaxInstalled	-	output parameter, bit-wise combination of fxState_UpgradeApp_e values to define
									the fax applications that are present on the machine

Author:

    Iv Vakaluk (IvG),    May, 2002

Return Value:

    DWORD - failure or success code

--*/
{
    DWORD                   dwReturn = NO_ERROR;
    HMODULE                 hMsiModule = NULL;
    PF_MSIQUERYPRODUCTSTATE pFunc = NULL;

#ifdef UNICODE
    LPCSTR                  lpcstrFunctionName = "MsiQueryProductStateW";
#else
    LPCSTR                  lpcstrFunctionName = "MsiQueryProductStateA";
#endif

    DEBUG_FUNCTION_NAME(_T("CheckInstalledFaxClient"));

	*pdwFaxInstalled = FXSTATE_NONE;

    //
    //  check that dwFaxToCheck is not empty
    //
    if (dwFaxToCheck == FXSTATE_NONE)
    {
        DebugPrintEx(DEBUG_MSG, _T("No Fax Application to check for its presence is given."));
        return dwReturn;
    }

	//
    //  Load MSI DLL
    //
    hMsiModule = LoadLibrary(_T("msi.dll"));
    if (!hMsiModule)
    {
		//
		//	MSI is not found ==> nothing is installed
		//
        DebugPrintEx(DEBUG_WRN, _T("Failed to LoadLibrary(msi.dll), ec=%ld."), GetLastError());

        return dwReturn;
    }

    pFunc = (PF_MSIQUERYPRODUCTSTATE)GetProcAddress(hMsiModule, lpcstrFunctionName);
    if (!pFunc)
    {
        dwReturn = GetLastError();
        DebugPrintEx(DEBUG_WRN, _T("Failed to GetProcAddress( ' %s ' ) on Msi, ec=%ld."), lpcstrFunctionName, dwReturn);
        goto FreeLibrary;
    }

    if (dwFaxToCheck & FXSTATE_SBS5_CLIENT)
    {
		//
		//	check for the SBS 5.0 Client
		//
		if (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_SBS5_CLIENT))
        {
            DebugPrintEx(DEBUG_MSG, _T("SBS 5.0 Client is installed on this machine."));
			*pdwFaxInstalled |= FXSTATE_SBS5_CLIENT;
        }
    }

    if (dwFaxToCheck & FXSTATE_SBS5_SERVER)
    {
		//
		//	check for the SBS 5.0 Server
		//
		if (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_SBS5_SERVER))
        {
            DebugPrintEx(DEBUG_MSG, _T("SBS 5.0 Server is installed on this machine."));
			*pdwFaxInstalled |= FXSTATE_SBS5_SERVER;
        }
    }

    if (dwFaxToCheck & FXSTATE_BETA3_CLIENT)
    {
		//
		//	check for the .NET SB3 Client
		//
		if (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_BETA3_CLIENT))
        {
            DebugPrintEx(DEBUG_MSG, _T(".NET SB3 Client is installed on this machine."));
			*pdwFaxInstalled |= FXSTATE_BETA3_CLIENT;
        }
    }

    if (dwFaxToCheck & FXSTATE_DOTNET_CLIENT)
    {
		//
		//	check for the .NET RC1 Client
		//
		if (INSTALLSTATE_DEFAULT == pFunc(PRODCODE_DOTNET_CLIENT))
        {
            DebugPrintEx(DEBUG_MSG, _T(".NET RC1 Client is installed on this machine."));
			*pdwFaxInstalled |= FXSTATE_DOTNET_CLIENT;
        }
    }

FreeLibrary:

    if (!FreeLibrary(hMsiModule))
    {
        dwReturn = GetLastError();
        DebugPrintEx(DEBUG_WRN, _T("Failed to FreeLibrary() for Msi, ec=%ld."), dwReturn);
    }

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  WasSBS2000FaxServerInstalled
//
//  Purpose:        
//                  This function checks if the SBS2000 fax service was installed
//                  before the upgrade to .NET Server/Bobcat happened.
//
//  Params:
//                  BOOL* pbSBSServer   - out param to report to the caller
//                                        if the fax server was installed
//
//  Return Value:
//                  ERROR_SUCCESS - in case of success
//                  Win32 Error code - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 13-Dec-2001
//////////////////////////////////////////////////////////////////////////////////////
DWORD WasSBS2000FaxServerInstalled(bool *pbSBSServer)
{
    DWORD   dwRes       = ERROR_SUCCESS;
    HKEY    hKey        = NULL;
    DWORD   dwInstalled = 0;

    DEBUG_FUNCTION_NAME(TEXT("WasSBS2000FaxServerInstalled"))

    (*pbSBSServer) = FALSE;

    // try to open HKLM\\Software\\Microsoft\\SharedFaxBackup
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_BACKUP,FALSE,KEY_READ);
    if (hKey==NULL)
    {
        DebugPrintEx(DEBUG_MSG,_T("HKLM\\Software\\Microsoft\\SharedFax does not exist, SBS2000 server was not installed"));
        goto exit;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,_T("HKLM\\Software\\Microsoft\\SharedFax does exists, SBS2000 server was installed"));
        (*pbSBSServer) = TRUE;
        goto exit;
    }

exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return dwRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\util\pointprint.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    setup.c

Abstract:

    This file implements point and print setup logic

Author:

    Mooly Beeri (MoolyB) 28-Nov-2001

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <winspool.h>
#include <msi.h>
#include <shellapi.h>
#include <shlwapi.h>

#include <faxsetup.h>
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <resource.h>
#include <setuputil.h>

typedef INSTALLSTATE (WINAPI *PF_MSIQUERYPRODUCTSTATE) (LPCTSTR szProduct);

DWORD   IsFaxClientInstalled(BOOL* pbFaxClientInstalled,BOOL* pbDownLevelPlatform);
DWORD   IsDownLevelPlatform(BOOL* pbDownLevelPlatform);
DWORD   IsFaxClientInstalledMSI(BOOL* pbFaxClientInstalled);
DWORD   IsFaxClientInstalledOCM(BOOL* pbFaxClientInstalled);
DWORD   GetPermissionToInstallFaxClient(BOOL* pbOkToInstallClient, HINSTANCE hModule);
BOOL    InstallFaxClient(LPCTSTR pPrinterName,BOOL fDownLevelPlatform);
BOOL    InstallFaxClientMSI(LPCTSTR pPrinterName);
BOOL    InstallFaxClientOCM();
BOOL    DownLevelClientSetupInProgress();
BOOL    VerifyFaxClientShareExists(LPCTSTR pPrinterName,BOOL* fFaxClientShareExists);

#define INSTALL_PARAMS _T("/V\"/qb ADDLOCAL=ALL PRINTER_EXISTS=1 ALLUSERS=1\" /wait")
#define INSTALL_IMAGE  _T("\\faxclient\\setup.exe")

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FaxPointAndPrintSetup
//
//  Purpose:        
//                  Main entry point to point and print setup
//                  This is called from the various printer drivers
//                  This function checks if the fax client is installed, and if it's not
//                  this function handles the installation of the fax client.
//
//  Params:
//                  LPCTSTR pPrinterName    - printer name, formatted as \\<server name>\printer name.
//                  BOOL bSilentInstall     - can we install the client automatically, or should we ask the user?
//
//  Return Value:
//                  TRUE    - in case of success
//                  FALSE   - in case of failure (this function sets last error)
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL FaxPointAndPrintSetup(LPCTSTR pPrinterName,BOOL bSilentInstall, HINSTANCE hModule)
{
    DWORD   dwRes					= ERROR_SUCCESS;
    BOOL    fFaxClientInstalled		= FALSE;
    BOOL    fDownLevelPlatform		= FALSE;
    BOOL    fOkToInstallClient		= TRUE;
	BOOL    fFaxClientShareExists	= FALSE;

    DEBUG_FUNCTION_NAME(TEXT("FaxPointAndPrintSetup"))

    // check if the fax client is already installed.
    dwRes = IsFaxClientInstalled(&fFaxClientInstalled,&fDownLevelPlatform);
    if (dwRes!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("IsFaxClientInstalled failed with %ld."),dwRes);
        return FALSE;
    }

    // if the fax client is already installed, nothing more to do.
    if (fFaxClientInstalled)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Fax client is already installed, nothing to do."));
        return TRUE;
    }

	// for down level clients, can we find the client share over the network?
	if (fDownLevelPlatform)
	{
		if (!VerifyFaxClientShareExists(pPrinterName,&fFaxClientShareExists))
		{
			DebugPrintEx(DEBUG_ERR,TEXT("VerifyFaxClientShareExists failed with %ld."), GetLastError());
			return FALSE;
		}

		// if the share does not exist, we should not propose to install anything
		if (!fFaxClientShareExists)
		{
			DebugPrintEx(DEBUG_MSG,TEXT("Fax client share does not exist on this server, exit."));
			return TRUE;
		}
	}
    // do we have to ask for permission to install the client?
    if (bSilentInstall)
	{
		// check if down level client setup is now in progress
		if (fDownLevelPlatform && DownLevelClientSetupInProgress())
		{
			DebugPrintEx(DEBUG_MSG,TEXT("Down level client is currently installing, nothing to do."));
			return TRUE;
		}
	}
	else
    {
        dwRes = GetPermissionToInstallFaxClient(&fOkToInstallClient, hModule);
        if (dwRes!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("GetPermissionToInstallFaxClient failed with %ld."),dwRes);
            return FALSE;
        }
    }

    // if the user chose not to install the fax client, we have to exit.
    if (!fOkToInstallClient)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("User chose not to install fax, nothing to do."));
        return TRUE;
    }

    // Install the fax client
    if (!InstallFaxClient(pPrinterName,fDownLevelPlatform))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("InstallFaxClient failed with %ld."), GetLastError());
        return FALSE;
    }

    return TRUE;    
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsFaxClientInstalled
//
//  Purpose:        
//                  This function checks if the fax client is installed.
//                  If this setup is running on W9X/NT4/W2K the function checks
//                  for the client's installation via MSI.
//                  If this setup is running on XP/.NET and above the function
//                  checks for the client's installation via OCM
//
//  Params:
//                  BOOL* pbFaxClientInstalled -    out param to report to the caller 
//                                                  if the client is installed
//                  BOOL* pbDownLevelPlatform  -    out param to report to the caller
//                                                  if we're running down level
//
//  Return Value:
//                  ERROR_SUCCESS - in case of success
//                  Win32 Error code - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD IsFaxClientInstalled(BOOL* pbFaxClientInstalled,BOOL* pbDownLevelPlatform)
{
    DWORD   dwRes               = ERROR_SUCCESS;
    BOOL    fDownLevelPlatform  = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("IsFaxClientInstalled"))

    (*pbFaxClientInstalled) = FALSE;

    // check if this is down level platform (W9X/NT4/W2K)
    dwRes = IsDownLevelPlatform(pbDownLevelPlatform);
    if (dwRes!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("IsDownLevelPlatform failed with %ld."),dwRes);
        return dwRes;
    }

    if (*pbDownLevelPlatform)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Running on down level platform"));

        // check for installed fax client using MSI API.
        dwRes = IsFaxClientInstalledMSI(pbFaxClientInstalled);
        if (dwRes!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("IsFaxClientInstalledMSI failed with %ld."),dwRes);
            (*pbFaxClientInstalled) = FALSE;
            return dwRes;
        }
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Running on XP/.NET platform"));

        // check for installed fax as part of the OS.
        dwRes = IsFaxClientInstalledOCM(pbFaxClientInstalled);
        if (dwRes!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("IsFaxClientInstalledOCM failed with %ld."),dwRes);
            (*pbFaxClientInstalled) = FALSE;
            return dwRes;
        }
    }

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsDownLevelPlatform
//
//  Purpose:        
//                  This function checks if this setup is running
//                  on W9X/NT4/W2K or on XP/.NET and above.
//
//  Params:
//                  BOOL* pbDownLevelPlatform  -    out param to report to the caller
//                                                  if we're running down level
//
//  Return Value:
//                  ERROR_SUCCESS - in case of success
//                  Win32 Error code - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD IsDownLevelPlatform(BOOL* pbDownLevelPlatform)
{
    DWORD           dwRes = ERROR_SUCCESS;
    OSVERSIONINFO   osv;

    DEBUG_FUNCTION_NAME(TEXT("IsDownLevelPlatform"))

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetVersionEx failed with %ld."),dwRes);
        return dwRes;
    }

    if (osv.dwPlatformId==VER_PLATFORM_WIN32_NT)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("This is a NT platform"));
        if ((osv.dwMajorVersion >= 5) && (osv.dwMinorVersion >= 1))
        {
            DebugPrintEx(DEBUG_MSG,TEXT("This is XP/.NET platform"));
            (*pbDownLevelPlatform) = FALSE;
        }
        else
        {
            DebugPrintEx(DEBUG_MSG,TEXT("This is NT4/W2K platform"));
            (*pbDownLevelPlatform) = TRUE;
        }
    }
    else if (osv.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("This is W9X platform"));
        (*pbDownLevelPlatform) = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Running an unknown platform"));
        dwRes = ERROR_BAD_CONFIGURATION;
    }

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsFaxClientInstalledMSI
//
//  Purpose:        
//                  This function checks if a certain MSI package is installed on this machine
//
//  Params:
//                  BOOL* pbProductInstalled    - out param to report to the caller
//                                                if the product is installed
//
//  Return Value:
//                  ERROR_SUCCESS - in case of success
//                  Win32 Error code - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD IsFaxClientInstalledMSI(BOOL* pbFaxClientInstalled)
{
	DWORD	dwRet = ERROR_SUCCESS;
	DWORD	dwFaxInstalled = FXSTATE_NONE;	

    DEBUG_FUNCTION_NAME(TEXT("IsFaxClientInstalledMSI"))

	(*pbFaxClientInstalled) = FALSE;

	//
	//	If either .NET SB3 / .NET RC1 down-level client or SBS 5.0 Server is installed,
	//		stop the point-and-print install
	//
	dwRet = CheckInstalledFax((FXSTATE_BETA3_CLIENT | FXSTATE_DOTNET_CLIENT | FXSTATE_SBS5_SERVER), 
							  &dwFaxInstalled);

	if (dwRet!=ERROR_SUCCESS)
	{
		DebugPrintEx(DEBUG_ERR,TEXT("CheckInstalledFaxClient failed ec=%d"),dwRet);
		return dwRet;
	}

	if (dwFaxInstalled != FXSTATE_NONE)
	{
		//
		//	some of the requested applications are installed
		//
		(*pbFaxClientInstalled) = TRUE;
	}

	return dwRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsFaxClientInstalledOCM
//
//  Purpose:        
//                  This function checks if the fax component is installed
//                  as part of the OS on XP/.NET and above.
//
//  Params:
//                  BOOL* pbFaxClientInstalled  - out param to report to the caller
//                                                if the fax component is installed
//
//  Return Value:
//                  ERROR_SUCCESS - in case of success
//                  Win32 Error code - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
//////////////////////////////////////////////////////////////////////////////////////
DWORD IsFaxClientInstalledOCM(BOOL* pbFaxClientInstalled)
{
    DWORD   dwRes       = ERROR_SUCCESS;
    HKEY    hKey        = NULL;
    DWORD   dwInstalled = 0;

    DEBUG_FUNCTION_NAME(TEXT("IsFaxClientInstalledOCM"))

    (*pbFaxClientInstalled) = FALSE;

    // try to open HKLM\\Software\\Microsoft\\Fax\\Setup
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP,FALSE,KEY_READ);
    if (hKey==NULL)
    {
        DebugPrintEx(DEBUG_MSG,_T("HKLM\\Software\\Microsoft\\Fax\\Setup does not exist, assume component is not installed"));
        goto exit;
    }

    // get the 'Installed' value from the above key
    dwRes = GetRegistryDwordEx(hKey,REGVAL_FAXINSTALLED,&dwInstalled);
    if (dwRes!=ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,_T("REG_DWORD 'Installed' does not exist, assume component is not installed"));
        dwRes = ERROR_SUCCESS;
        goto exit;
    }

    if (dwInstalled)
    {
        DebugPrintEx(DEBUG_MSG,_T("REG_DWORD 'Installed' is set, assume component is installed"));
        (*pbFaxClientInstalled) = TRUE;
        goto exit;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,_T("REG_DWORD 'Installed' is zero, assume component is not installed"));
    }

exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  GetPermissionToInstallFaxClient
//
//  Purpose:        
//                  This function tells the user that the fax client is not installed
//                  and asks permission to install the client software
//
//  Params:
//                  BOOL* pbOkToInstallClient   - out param to report to the caller
//                                                if the user grants permission to
//                                                install the fax client
//
//  Return Value:
//                  ERROR_SUCCESS - in case of success
//                  Win32 Error code - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
//////////////////////////////////////////////////////////////////////////////////////
DWORD GetPermissionToInstallFaxClient(BOOL* pbOkToInstallClient, HINSTANCE hModule)
{
    DWORD       dwRes                                   = ERROR_SUCCESS;
    HINSTANCE   hInst                                   = NULL;
    int         iRes                                    = 0;
    INT         iStringID                               = 0;
    TCHAR       szClientNotInstalledMessage[MAX_PATH]   = {0};
    TCHAR       szClientNotInstalledTitle[MAX_PATH]     = {0};


    DEBUG_FUNCTION_NAME(TEXT("GetPermissionToInstallFaxClient"))

    (*pbOkToInstallClient) = FALSE;

    hInst = GetResInstance(hModule);
    if(!hInst)
    {
        return GetLastError();
    }

    // Load Message 
    if (!LoadString(hInst, IDS_CLIENT_NOT_INSTALLED, szClientNotInstalledMessage, MAX_PATH))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("LoadString IDS_CLIENT_NOT_INSTALLED failed with %ld."),dwRes);
        goto exit;
    }

    // Load Message title
    if (!LoadString(hInst, IDS_CLIENT_NOT_INSTALLED_TITLE, szClientNotInstalledTitle, MAX_PATH))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("LoadString IDS_CLIENT_NOT_INSTALLED_TITLE failed with %ld."),dwRes);
        goto exit;
    }

    iRes = MessageBox(NULL,szClientNotInstalledMessage,szClientNotInstalledTitle,MB_YESNO);
    if (iRes==IDYES)
    {
        DebugPrintEx(DEBUG_MSG,_T("User pressed 'Yes', ok to install client"));
        (*pbOkToInstallClient) = TRUE;
    }

exit:
    FreeResInstance();

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  InstallFaxClient
//
//  Purpose:        
//                  This function handles the installation of the fax client
//                  If running on down level platform, this function calls the 
//                  MSI install function.
//                  If running on XP/.NET this function calls the OCM installation.
//
//  Params:
//                  LPCTSTR pPrinterName    - printer name, formatted as \\<server name>\printer name.
//                  BOOL fDownLevelPlatform - are we running on down level platform?
//
//  Return Value:
//                  TRUE  - in case of success
//                  FALSE - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
//////////////////////////////////////////////////////////////////////////////////////
BOOL InstallFaxClient(LPCTSTR pPrinterName,BOOL fDownLevelPlatform)
{
    DEBUG_FUNCTION_NAME(TEXT("InstallFaxClient"))

    if (fDownLevelPlatform)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Installing on down level platform"));

        // Install fax client using MSI
        if (!InstallFaxClientMSI(pPrinterName))
        {
            DebugPrintEx(DEBUG_ERR,TEXT("InstallFaxClientMSI failed with %ld."),GetLastError());
            return FALSE;
        }
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Installing on XP/.NET platform"));

        // Install fax client using OCM
        if (!InstallFaxClientOCM())
        {
            DebugPrintEx(DEBUG_ERR,TEXT("InstallFaxClientOCM failed with %ld."),GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}

#define MSI_11 PACKVERSION (1,1)
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  WaitForInstallationToComplete
//
//  Purpose:        
//                  This function checks if the MSI service is installed, and if it is
//                  the function checks if the MSI version is less than 1.1 that we're
//                  about to install. If the service is not installed or the version
//                  is less than 1.1, this function returns FALSE.
//
//  Params:
//                  None
//
//  Return Value:
//                  TRUE - MSI service is installed and is of appropriate version.
//                  FALSE - otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 27-Dec-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL WaitForInstallationToComplete()
{
    TCHAR           szSystemDirectory[MAX_PATH] ={0};
    LPCTSTR         lpctstrMsiDllName           = _T("\\MSI.DLL");
    HANDLE          hFind                       = INVALID_HANDLE_VALUE;
    DWORD           dwVer                       = 0;
    WIN32_FIND_DATA FindFileData;

    DEBUG_FUNCTION_NAME(TEXT("WaitForInstallationToComplete"))

    // check if msi.dll exists
    if (GetSystemDirectory(szSystemDirectory,MAX_PATH-_tcslen(lpctstrMsiDllName))==0)
    {
        DebugPrintEx(DEBUG_ERR,_T("GetSystemDirectory failed: (ec=%d)"),GetLastError());
        return FALSE;
    }

    _tcscat(szSystemDirectory,lpctstrMsiDllName);

    DebugPrintEx(DEBUG_MSG,TEXT("Looking for %s"),szSystemDirectory);

    hFind = FindFirstFile(szSystemDirectory, &FindFileData);
    if (hFind==INVALID_HANDLE_VALUE) 
    {
        DebugPrintEx(DEBUG_MSG, TEXT("Msi.dll not found"));
        return FALSE;
    }

    FindClose(hFind);

    // get the MSI.DLL version
    dwVer = GetDllVersion(TEXT("msi.dll"));

    if (dwVer < MSI_11)
    {
        DebugPrintEx(DEBUG_MSG, TEXT("MSI.DLL requires update."));
        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  InstallFaxClientMSI
//
//  Purpose:        
//                  This function handles the installation of the fax client 
//                  on down level clients.
//                  This is done by creating a process that runs \\servername\faxclient\setup.exe
//                  and waiting for it to terminate.
//
//  Params:
//                  LPCTSTR pPrinterName    - printer name, formatted as \\<server name>\printer name.
//
//  Return Value:
//                  TRUE  - in case of success
//                  FALSE - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
//////////////////////////////////////////////////////////////////////////////////////
BOOL InstallFaxClientMSI(LPCTSTR pPrinterName)
{
    SHELLEXECUTEINFO    executeInfo                 = {0};
    TCHAR               szExecutablePath[MAX_PATH]  = {0};
    TCHAR*              pLastBackslash              = NULL;
    DWORD               dwWaitRes                   = 0;
    DWORD               dwExitCode                  = 0;
    BOOL                fWaitForInstallComplete     = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("InstallFaxClientMSI"))

    // if the MSI service is not installed at all on the machine
    // we will launch the installation and won't wait for it
    // to terminate since we want the user's app to regain focus
    // so the user will be able to save the data before the reboot.
    fWaitForInstallComplete = WaitForInstallationToComplete();

    _tcsncpy(szExecutablePath,pPrinterName,MAX_PATH-_tcslen(INSTALL_IMAGE)-1);
    pLastBackslash = _tcsrchr(szExecutablePath,_T('\\'));
    if (pLastBackslash==NULL)
    {
        // no server name was found???
        DebugPrintEx(DEBUG_ERR,TEXT("didn't find server name in pPrinterName (%s)"),pPrinterName);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    // put a NULL after the last backslash
    _tcsinc(pLastBackslash);
    _tcsset(pLastBackslash,'\0');

    // construct the command line to install the client.
    _tcscat(szExecutablePath,INSTALL_IMAGE);
    DebugPrintEx(DEBUG_MSG,TEXT("Running fax client setup from (%s)"),szExecutablePath);

    // create a process that runs setup.
    executeInfo.cbSize = sizeof(executeInfo);
    executeInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
    executeInfo.lpVerb = TEXT("open");
    executeInfo.lpFile = szExecutablePath;
    executeInfo.lpParameters = INSTALL_PARAMS;
    executeInfo.lpDirectory  = NULL;
    executeInfo.nShow  = SW_RESTORE;

    //
    // Execute client setup
    //
    if(!ShellExecuteEx(&executeInfo))
    {
        return FALSE;
    }

    if (executeInfo.hProcess==NULL)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("executeInfo.hProcess is NULL, exit without wait"));
        return FALSE;
    }

    if (!fWaitForInstallComplete)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("MSI srvice does not exist, exit without waiting"));
        goto exit;
    }

    dwWaitRes = WaitForSingleObject(executeInfo.hProcess,INFINITE);
    switch(dwWaitRes)
    {
    case WAIT_OBJECT_0:
        // setup's done
        DebugPrintEx(DEBUG_MSG,TEXT("fax client setup completed."));
        break;

    default:
        DebugPrintEx(DEBUG_ERR,TEXT("WaitForSingleObject failed with %ld."),GetLastError());
        break;
    }

    // Log the process info and close the handles
    if (!GetExitCodeProcess(executeInfo.hProcess,&dwExitCode))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("GetExitCodeProcess failed with %ld."),GetLastError());
        goto exit;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("GetExitCodeProcess returned %ld."),dwExitCode);

        if (dwExitCode==ERROR_SUCCESS_REBOOT_REQUIRED)
        {
            DebugPrintEx(DEBUG_MSG,TEXT("Installation requires reboot"));
        }
        else if (dwExitCode!=ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("Installation failed"));
        }
    }

exit:
    if (executeInfo.hProcess)
    {
        CloseHandle(executeInfo.hProcess);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  InstallFaxClientOCM
//
//  Purpose:        
//                  This function handles the installation of the fax client 
//                  on XP/.NET
//                  This is done by activating SYSOCMGR.EXE to install the fax component
//                  and waiting for it to terminate.
//
//  Params:
//                  none
//
//  Return Value:
//                  TRUE  - in case of success
//                  FALSE - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Dec-2001
//////////////////////////////////////////////////////////////////////////////////////
BOOL InstallFaxClientOCM()
{
    BOOL bRet = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("InstallFaxClientOCM"))

#ifdef UNICODE
    if (InstallFaxUnattended()==ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Installation succeeded"));
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Installation failed with %ld."),GetLastError());
        bRet = FALSE;
    }
#endif

    return bRet;
}

#ifdef UNICODE

DWORD
InstallFaxUnattended ()
/*++

Routine name : InstallFaxUnattended

Routine description:

    Performs an unattended installation of fax and waits for it to end

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    struct _InfInfo
    {   
        LPCWSTR     lpcwstrName;
        LPCSTR      lpcstrContents;
    } Infs[2];

    Infs[0].lpcwstrName = L"FaxOc.inf";
    Infs[0].lpcstrContents = "[Version]\n"
                             "Signature=\"$Windows NT$\"\n"
                             "[Components]\n"
                             "Fax=fxsocm.dll,FaxOcmSetupProc,fxsocm.inf\n";
    Infs[1].lpcwstrName = L"FaxUnattend.inf";
    Infs[1].lpcstrContents = "[Components]\n"
                             "Fax=on\n";

    DEBUG_FUNCTION_NAME(_T("InstallFaxUnattended"));
    //
    // Get temp directory path
    //
    WCHAR wszTempDir[MAX_PATH+1];
    dwRes = GetTempPath (sizeof (wszTempDir) / sizeof (wszTempDir[0]), wszTempDir);
    if (!dwRes || dwRes > sizeof (wszTempDir) / sizeof (wszTempDir[0]))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("GetTempPath failed with %ld"), dwRes);
        return dwRes;
    }
    //
    // Create the files needed for unattended fax setup
    //
    for (DWORD dw = 0; dw < sizeof (Infs) / sizeof (Infs[0]); dw++)
    {
        WCHAR wszFileName[MAX_PATH * 2];
        DWORD dwBytesWritten;
        swprintf (wszFileName, TEXT("%s%s"), wszTempDir, Infs[dw].lpcwstrName);
        HANDLE hFile = CreateFile ( wszFileName,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            dwRes = GetLastError ();
            DebugPrintEx(DEBUG_ERR, TEXT("CreateFile failed with %ld"), dwRes);
            return dwRes;
        }
        if (!WriteFile (hFile,
                        (LPVOID)Infs[dw].lpcstrContents,
                        strlen (Infs[dw].lpcstrContents),
                        &dwBytesWritten,
                        NULL))
        {
            dwRes = GetLastError ();
            DebugPrintEx(DEBUG_ERR, TEXT("WriteFile failed with %ld"), dwRes);
            CloseHandle (hFile);
            return dwRes;
        }
        CloseHandle (hFile);
    }
    //
    // Compose the command line parameters
    //
	WCHAR wszCmdLineParams[MAX_PATH * 3] = {0};
    if (0 >= _sntprintf (wszCmdLineParams, 
                         ARR_SIZE(wszCmdLineParams) -1,
                         TEXT("/y /i:%s%s /unattend:%s%s"),
                         wszTempDir,
                         Infs[0].lpcwstrName,
                         wszTempDir,
                         Infs[1].lpcwstrName))
    {
        dwRes = ERROR_BUFFER_OVERFLOW;
        DebugPrintEx(DEBUG_ERR, TEXT("_sntprintf failed with %ld"), dwRes);
        return dwRes;
    }

    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof (SHELLEXECUTEINFO);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;

    sei.lpVerb = TEXT("open");
    sei.lpFile = TEXT("SysOcMgr.exe");
    sei.lpParameters = wszCmdLineParams;
    sei.lpDirectory  = TEXT(".");
    sei.nShow  = SW_SHOWNORMAL;

    //
    // Execute SysOcMgr.exe and wait for it to end
    //
    if(!ShellExecuteEx(&sei))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("ShellExecuteEx failed with %ld"), dwRes);
        return dwRes;
    }
    //
    // Set hourglass cursor and wait for setup to finish
    //
    HCURSOR hOldCursor = ::SetCursor (::LoadCursor(NULL, IDC_WAIT));
    
    dwRes = WaitForSingleObject(sei.hProcess, INFINITE);
    switch(dwRes)
    {
        case WAIT_OBJECT_0:
            //
            // Shell execute completed successfully
            //
            dwRes = ERROR_SUCCESS;
            break;

        default:
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForSingleObject failed with %ld"), dwRes);
            break;
    }
    //
    // Restore previous cursor
    //
    ::SetCursor (hOldCursor);
    return dwRes;
}   // InstallFaxUnattended

#endif // UNICODE

/*++

Routine Description:
    Returns the version information for a DLL exporting "DllGetVersion".
    DllGetVersion is exported by the shell DLLs (specifically COMCTRL32.DLL).

Arguments:

    lpszDllName - The name of the DLL to get version information from.

Return Value:

    The version is retuned as DWORD where:
    HIWORD ( version DWORD  ) = Major Version
    LOWORD ( version DWORD  ) = Minor Version
    Use the macro PACKVERSION to comapre versions.
    If the DLL does not export "DllGetVersion" the function returns 0.

--*/
DWORD GetDllVersion(LPCTSTR lpszDllName)
{

    HINSTANCE hinstDll;
    DWORD dwVersion = 0;

    hinstDll = LoadLibrary(lpszDllName);

    if(hinstDll)
    {
        DLLGETVERSIONPROC pDllGetVersion;

        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");

    // Because some DLLs may not implement this function, you
    // must test for it explicitly. Depending on the particular
    // DLL, the lack of a DllGetVersion function may
    // be a useful indicator of the version.

        if(pDllGetVersion)
        {
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }

        FreeLibrary(hinstDll);
    }
    return dwVersion;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  DownLevelClientSetupInProgress
//
//  Purpose:        
//                  This function checks to see if a down level installation
//                  is currently in progress. the down level client installation
//                  creates a printer connection which might lead to another install
//                  being launched from this module since the printer connection will 
//					triger an install. the bootstrap we use writes a 'setup in progress'
//					key and we check and delete it here. if it is set, we skip the install.
//
//  Params:
//                  none
//
//  Return Value:
//                  TRUE  - in case the down leve client install is in progress
//                  FALSE - otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 09-Jan-2002
//////////////////////////////////////////////////////////////////////////////////////
BOOL DownLevelClientSetupInProgress()
{
	HKEY hFaxKey = NULL;
	DWORD dwVal = 0;
	BOOL bRes = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("DownLevelClientSetupInProgress"))

	hFaxKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SBS2000_FAX_SETUP,FALSE,KEY_READ);
	if (hFaxKey)
	{
		dwVal = GetRegistryDword(hFaxKey,REGVAL_SETUP_IN_PROGRESS);
		if (dwVal)
		{
			DebugPrintEx(DEBUG_MSG, TEXT("down leve client setup is in progress"));
			bRes = TRUE;
		}
		RegCloseKey(hFaxKey);
	}
	else
	{
		DebugPrintEx(DEBUG_MSG, TEXT("down leve client setup is not in progress"));
	}
	return bRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  VerifyFaxClientShareExists
//
//  Purpose:        
//					this function checks whether the current printer used for 
//					the print operation is located on a .NET Server that has
//					the faxclient share available on it for installation attempts.
//					It could be, for instance, that the server we're trying to print to
//					is a BOS server and we can't and don't want to install
//					the client of it.
//
//  Params:
//                  LPCTSTR pPrinterName		- printer name, formatted as \\<server name>\printer name.
//					BOOL* fFaxClientShareExists - out param, does the share exist?
//
//  Return Value:
//                  TRUE  - in case of success
//                  FALSE - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 19-Jun-2002
//////////////////////////////////////////////////////////////////////////////////////
BOOL VerifyFaxClientShareExists(LPCTSTR pPrinterName,BOOL* fFaxClientShareExists)
{
    TCHAR               szExecutablePath[MAX_PATH]  = {0};
    TCHAR*              pLastBackslash              = NULL;
	DWORD				dwRes						= ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("VerifyFaxClientShareExists"))

	(*fFaxClientShareExists) = FALSE;
	_tcsncpy(szExecutablePath,pPrinterName,MAX_PATH-_tcslen(INSTALL_IMAGE)-1);
    pLastBackslash = _tcsrchr(szExecutablePath,_T('\\'));
    if (pLastBackslash==NULL)
    {
        // no server name was found???
        DebugPrintEx(DEBUG_ERR,TEXT("didn't find server name in pPrinterName (%s)"),pPrinterName);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    // put a NULL after the last backslash
    _tcsinc(pLastBackslash);
    _tcsset(pLastBackslash,'\0');

    // construct the command line to install the client.
    _tcscat(szExecutablePath,INSTALL_IMAGE);
    DebugPrintEx(DEBUG_MSG,TEXT("Checking fax client setup at (%s)"),szExecutablePath);

	dwRes = GetFileAttributes(szExecutablePath);
	if (dwRes!=INVALID_FILE_ATTRIBUTES)
	{
		DebugPrintEx(DEBUG_MSG,TEXT("File exists"));
		(*fFaxClientShareExists) = TRUE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\util\shortcuts.cpp ===
#include <setuputil.h>
#include <debugex.h>

// 
// Function:    CompleteToFullPathInSystemDirectory
// Description: Get file name and a buffer. Return in the given buffer the full path to the file name in the 
//				system directory
// Returns:		TRUE for success, FALSE otherwise
//
// Remarks: It is possible that the file name is in the given buffer.
//
// Args:
// LPTSTR  lptstrFullPath (OUT) : Buffer that will have the full path
// LPTCSTR lptstrFileName (IN)  : File name
//
// Author:      AsafS

BOOL
CompleteToFullPathInSystemDirectory(
	LPTSTR  lptstrFullPath,
	LPCTSTR lptstrFileName
	)
{
	DBG_ENTER(TEXT("CompleteToFullPathInSystemDirectory"));
	TCHAR szFileName[MAX_PATH+1] = {0};
	DWORD dwSize = 0;
	
	_tcsncpy(szFileName, lptstrFileName, MAX_PATH);

	if (!GetSystemDirectory(lptstrFullPath, MAX_PATH))
	{
		CALL_FAIL(
			GENERAL_ERR,
			TEXT("GetSystemDirectory"),
			GetLastError()
			);
		return FALSE;
	}

	dwSize = _tcslen(lptstrFullPath);

	_tcsncat(
		lptstrFullPath, 
		TEXT("\\"),
		(MAX_PATH - dwSize)
		);
	dwSize++;

	_tcsncat(
		lptstrFullPath, 
		szFileName, 
		(MAX_PATH - dwSize)
		);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\util\printers.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    printers.cpp

Abstract:

    This file implements printer manipulation common setup routines

Author:

    Asaf Shaar (AsafS) 7-Nov-2000

Environment:

    User Mode

--*/
#include <windows.h>
#include <Winspool.h>
#include <SetupUtil.h>
#include <faxreg.h>


//
//
// Function:    DeleteFaxPrinter
// Description: Delete fax printer driver for win2k from current machine
//              In case of failure, log it and returns FALSE.
//              Returns TRUE on success
//              
// Args:        lpctstrFaxPrinterName (LPTSTR): Fax printer name
//
//
// Author:      AsafS

BOOL
DeleteFaxPrinter(
    LPCTSTR lpctstrFaxPrinterName  // printer name
    )
{
    BOOL fSuccess = TRUE;
    DBG_ENTER(TEXT("DeleteFaxPrinter"), fSuccess, TEXT("%s"), lpctstrFaxPrinterName);

    HANDLE hPrinter = NULL;
    
    DWORD ec = ERROR_SUCCESS;

    PRINTER_DEFAULTS Default;

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = PRINTER_ACCESS_ADMINISTER|DELETE;
    
    if (!OpenPrinter(
        (LPTSTR) lpctstrFaxPrinterName,
        &hPrinter,
        &Default)
        )
    {
        ec = GetLastError();
        ASSERTION(!hPrinter); 
        VERBOSE (PRINT_ERR,
                 TEXT("OpenPrinter() for %s failed (ec: %ld)"),
                 lpctstrFaxPrinterName,
                 ec);
        goto Exit;
    }
    
    ASSERTION(hPrinter); // be sure that we got valid printer handle

    // purge all the print jobs -- can't delete a printer with jobs in queue (printed or not)
    if (!SetPrinter(
        hPrinter, 
        0, 
        NULL, 
        PRINTER_CONTROL_PURGE)
        )
    {
        // Don't let a failure here keep us from attempting the delete
        VERBOSE(PRINT_ERR,
                TEXT("SetPrinter failed (purge jobs before uninstall %s)!")
                TEXT("Last error: %d"),
                lpctstrFaxPrinterName,
                GetLastError());
    }

    if (!DeletePrinter(hPrinter))
    {
        ec = GetLastError();
        VERBOSE (PRINT_ERR,
                 TEXT("Delete Printer %s failed (ec: %ld)"),
                 lpctstrFaxPrinterName,
                 ec);
        goto Exit;
    }
    
    VERBOSE (DBG_MSG,
             TEXT("DeletePrinter() for %s succeeded"),
             lpctstrFaxPrinterName);
Exit:
    if (hPrinter)
    {
        ClosePrinter(hPrinter);
    }
    SetLastError(ec);
    fSuccess = (ERROR_SUCCESS == ec);
    return fSuccess;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FillDriverInfo
//
//  Purpose:        
//                  Fill a DRIVER_INFO_3 structure depending on the environment.
//
//  Params:
//                  DRIVER_INFO_3* pDriverInfo3 - the DRIVER_INFO_3 structure to fill out
//                  LPCTSTR pEnvironment        - the print environment for which the driver info is filled.
//                                                this corresponds to the printer env. in AddPrinterDriverEx API.
//
//  Return Value:
//                  TRUE - everything was ok.
//                  FALSE - invalid params passed in
//
//  Author:
//                  Mooly Beery (MoolyB) 12-Aug-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL FillDriverInfo(DRIVER_INFO_3* pDriverInfo3,LPCTSTR pEnvironment)
{
    DBG_ENTER(_T("FillDriverInfo"));

    if (pDriverInfo3==NULL)
    {
        VERBOSE(SETUP_ERR,_T("called with a NULL pDriverInfo3..."));
        return FALSE;
    }

    if (pEnvironment==NULL)
    {
        VERBOSE(DBG_MSG,_T("Filling DRIVER_INFO_3 for W2K/XP"));
        pDriverInfo3->cVersion          = 3;
        pDriverInfo3->pName             = FAX_DRIVER_NAME;
        pDriverInfo3->pEnvironment      = NULL;
        pDriverInfo3->pDriverPath       = FAX_DRV_MODULE_NAME;
        pDriverInfo3->pDataFile         = FAX_UI_MODULE_NAME;
        pDriverInfo3->pConfigFile       = FAX_UI_MODULE_NAME;
        pDriverInfo3->pDependentFiles   = FAX_WZRD_MODULE_NAME TEXT("\0") 
                                          FAX_TIFF_MODULE_NAME TEXT("\0")
                                          FAX_RES_FILE TEXT("\0")
                                          FAX_API_MODULE_NAME TEXT("\0");
        pDriverInfo3->pMonitorName      = NULL;
        pDriverInfo3->pHelpFile         = NULL;
        pDriverInfo3->pDefaultDataType  = TEXT("RAW");
    }
    else if (_tcsicmp(pEnvironment,NT4_PRINT_ENV)==0)
    {
        VERBOSE(DBG_MSG,_T("Filling DRIVER_INFO_3 for NT4"));
        pDriverInfo3->cVersion          = 2;
        pDriverInfo3->pName             = FAX_DRIVER_NAME;
        pDriverInfo3->pEnvironment      = NT4_PRINT_ENV;
        pDriverInfo3->pDriverPath       = FAX_NT4_DRV_MODULE_NAME;
        pDriverInfo3->pDataFile         = FAX_UI_MODULE_NAME;
        pDriverInfo3->pConfigFile       = FAX_UI_MODULE_NAME;
        pDriverInfo3->pDependentFiles   = FAX_DRV_DEPEND_FILE TEXT("\0")
                                          FAX_API_MODULE_NAME TEXT("\0")
                                          FAX_NT4_DRV_MODULE_NAME TEXT("\0")
                                          FAX_TIFF_FILE TEXT("\0")
                                          FAX_RES_FILE TEXT("\0")
                                          FAX_UI_MODULE_NAME TEXT("\0");
        pDriverInfo3->pMonitorName      = NULL;
        pDriverInfo3->pHelpFile         = NULL;
        pDriverInfo3->pDefaultDataType  = TEXT("RAW");
    }
    else if (_tcsicmp(pEnvironment,W9X_PRINT_ENV)==0)
    {
        VERBOSE(DBG_MSG,_T("Filling DRIVER_INFO_3 for W9X"));
        pDriverInfo3->cVersion          = 0;
        pDriverInfo3->pName             = FAX_DRIVER_NAME;
        pDriverInfo3->pEnvironment      = W9X_PRINT_ENV;
        pDriverInfo3->pDriverPath       = FAX_DRV_WIN9X_16_MODULE_NAME;
        pDriverInfo3->pDataFile         = FAX_DRV_WIN9X_16_MODULE_NAME;
        pDriverInfo3->pConfigFile       = FAX_DRV_WIN9X_16_MODULE_NAME;      
        pDriverInfo3->pDependentFiles   = FAX_DRV_WIN9X_16_MODULE_NAME TEXT("\0")
                                          FAX_DRV_WIN9X_32_MODULE_NAME TEXT("\0")
                                          FAX_WZRD_MODULE_NAME TEXT("\0")         
                                          FAX_API_MODULE_NAME TEXT("\0")         
                                          FAX_TIFF_FILE TEXT("\0")               
                                          FAX_DRV_ICONLIB TEXT("\0")             
                                          FAX_RES_FILE TEXT("\0")
                                          FAX_DRV_UNIDRV_MODULE_NAME TEXT("\0");
        pDriverInfo3->pMonitorName      = NULL;
        pDriverInfo3->pHelpFile         = FAX_DRV_UNIDRV_HELP;       
        pDriverInfo3->pDefaultDataType  = TEXT("RAW");
    }
    else
    {
        VERBOSE(SETUP_ERR,_T("called with a weird pEnv..., do nothing"));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\util\sources.inc ===
!ifndef FAXROOT
FAXROOT=$(BASEDIR)\printscan\faxsrv
!endif
USECXX_FLAG=/Tp

!include $(FAXROOT)\faxsrc.inc

TARGETNAME=setuputil
TARGETPATH=obj
TARGETTYPE=LIBRARY

UMTYPE=windows

INCLUDES=   $(INCLUDES); \
            ..\..\ocm;   \
            ..\..\inc;   \

C_DEFINES= $(C_DEFINES) -DENABLE_FRE_LOGGING

SOURCES=\
  ..\shortcuts.cpp      \
  ..\setup.cpp          \
  ..\printers.cpp       \
  ..\pointprint.c       \
  ..\install.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\awdlib\awdlib.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

awd library

Routines for reading from an AWD file.

Author:
  Brian Dewey (t-briand) 1997-7-2
--*/

#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>		// AWD is an OLE compound document.
#include <assert.h>

#include <awdlib.h>		// Header file for this library.

// ------------------------------------------------------------
// Auxiliary routines

// OpenAWDFile
//
// Opens an AWD file and fills in the psStorages structure.
//
// Parameters:
//	pwcsFilename		name of file to open (UNICODE)
//	psStorages		Pointer to structure that will hold
//				the major storages used in an AWD file.
//
// Returns:
//	TRUE on success, FALSE on failure.  One or more storages may be
//	NULL even when the routine returns TRUE.  The client needs to
//	check for this.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-30
BOOL
OpenAWDFile(const WCHAR *pwcsFilename, AWD_FILE *psStorages)
{
    HRESULT hStatus;		// Status indicator for reporting errors.

    hStatus = StgOpenStorage(pwcsFilename,
			     NULL,
			     STGM_READ | STGM_SHARE_EXCLUSIVE,
			     NULL,
			     0,
			     &psStorages->psAWDFile);
    if(FAILED(hStatus)) {
	return FALSE;
    }
	// If we get here, we've succeeded.  Now open the related storages.
    psStorages->psDocuments = OpenAWDSubStorage(psStorages->psAWDFile,
						L"Documents");
    psStorages->psPersistInfo = OpenAWDSubStorage(psStorages->psAWDFile,
						  L"Persistent Information");
    psStorages->psDocInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
					      L"Document Information");
    psStorages->psPageInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
					       L"Page Information");
    psStorages->psGlobalInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
						 L"Global Information");
    return TRUE;
}

// CloseAWDFile
//
// Closes an AWD file.
//
// Parameters:
//	psStorages		Pointer to the AWD file.
//	
// Returns:
// 	TRUE on success, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
BOOL
CloseAWDFile(AWD_FILE *psStorages)
{
	// This should probably use some exception mechanism.
    BOOL success = TRUE;
    if(FAILED(psStorages->psGlobalInfo->lpVtbl->Release(psStorages->psGlobalInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psPageInfo->lpVtbl->Release(psStorages->psPageInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psDocInfo->lpVtbl->Release(psStorages->psDocInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psPersistInfo->lpVtbl->Release(psStorages->psPersistInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psDocuments->lpVtbl->Release(psStorages->psDocuments))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psAWDFile->lpVtbl->Release(psStorages->psAWDFile))) {
	success = FALSE;
    }
    return success;
}

// OpenAWDSubStorage
//
// Get a substorage from a parent storage.  Checks for errors
// and exits on error conditions.  Note that it's not an error if
// the substorage doesn't exist, so the caller should still check for NULL.
//
// Parameters:
//	psParent		Pointer to the parent storage.
//	pwcsStorageName		Name of the substorage (UNICODE).
//
// Returns:
//	A pointer to the substorage, or NULL if the substorage doesn't exist.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
IStorage *
OpenAWDSubStorage(IStorage *psParent, const WCHAR *pwcsStorageName)
{
    IStorage *psSubStorage;	    // The substorage.
    HRESULT hStatus;		    // Status of the call.

    if(psParent == NULL) return NULL;
    hStatus = psParent->lpVtbl->OpenStorage(psParent,
					    pwcsStorageName,
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    NULL,
					    0,
					    &psSubStorage);
    if(FAILED(hStatus)) {
	if(hStatus == STG_E_FILENOTFOUND) {
	    fwprintf(stderr, L"OpenAWDSubStorage:No such substorage '%s'.\n",
		     pwcsStorageName);
	    return NULL;
	}
	    // use the wide-printf() to get the UNICODE filename.
	fwprintf(stderr, L"OpenAWDSubStorage:Unable to open substorage %s.\n",
		pwcsStorageName);
	exit(1);
    }
    return psSubStorage;
}

// OpenAWDStream
//
// This function opens an AWD stream for exclusive read access.  It
// checks for errors and exits on an error condition.  Not found is
// not considered a fatal error.
//
// Parameters:
// 	psStorage		Pointer to the storage holding the stream.
//	pwcsStreamName		Name of the stream (UNICODE).
//
// Returns:
// 	A pointer to the stream.  If no such stream exists, returns NULL.
// 	It will abort on any other error.
//
// Author:
// 	Brian Dewey (t-briand)	1997-6-27
IStream *
OpenAWDStream(IStorage *psStorage, const WCHAR *pwcsStreamName)
{
    HRESULT hStatus;
    IStream *psStream;

    assert(psStorage != NULL);		    // Sanity check.
    fwprintf(stderr, L"OpenAWDStream:Opening stream '%s'.\n", pwcsStreamName);
    hStatus = psStorage->lpVtbl->OpenStream(psStorage,
					    pwcsStreamName,
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    0,
					    &psStream);
    if(FAILED(hStatus)) {
	if(hStatus == STG_E_FILENOTFOUND) return NULL;
	fwprintf(stderr, L"OpenAWDStream:Error %x when opening stream %s.\n",
		 hStatus, pwcsStreamName);
	exit(1);
    }
    return psStream;
}

// AWDViewed
//
// This function tests if the AWD file has previously been viewed by
// a viewer.  It does this by checking for the presence of a stream
// called "BeenViewed."  See AWD specs.
//
// Parameters:
//	psStorage		Pointer to the "Persistent Information"
//				substorage.
//
// Returns:
//	TRUE if the file has been viewed, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
BOOL
AWDViewed(AWD_FILE *psStorages)
{
    IStream *psStream;		    // Pointer to the been-viewed stream.
    HRESULT hStatus;		    // Holds the status of the call.

	// Attempt to open the BeenViewed stream.
    hStatus = psStorages->psPersistInfo->lpVtbl->OpenStream(psStorages->psPersistInfo,
					    L"BeenViewed",
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    0,
					    &psStream);
	// If succeeded, then definately found.
    if(SUCCEEDED(hStatus)) return TRUE;
	// If not found, then definately hasn't been viewed.
    if(hStatus == STG_E_FILENOTFOUND) return FALSE;
    fprintf(stderr, "AWDViewed:Unexpected status %x.\n", hStatus);
	// Assume that we've been viewed.
    return TRUE;
}

// DumpAWDDocuments
//
// This function prints out the name of the fax documents contained in the
// file in their display order.  Output is to stdout.
//
// New AWD files have a "Display Order" stream in the psGlobalInfo that defines
// all of the documents.  Old AWD files need to enumerate through the
// "Documents" substorage.  
//
// Parameters:
//	psStorages		Pointer to the storages of an AWD file.
//
// Returns:
//	Nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-27
void
DumpAWDDocuments(AWD_FILE *psStorages)
{
    printf("Document list:\n");
    printf("-------- -----\n");
    EnumDocuments(psStorages, DisplayDocNames);

}

// EnumDocuments
//
// This function enumerates through all of the things in the "Documents"
// substorage and prints their names.  It's a helper routine to DumpAWDDocuments().
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pfnDocProc			Pointer to function that should be called
//					with the names of the documents in the
//					AWD file.
//
// Returns:
//	TRUE if all iterations succeeded, FALSE otherwise.
//
// Author:
// 	Brian Dewey (t-briand)  1997-6-30
BOOL
EnumDocuments(AWD_FILE *psStorages, AWD_DOC_PROCESSOR pfnDocProc)
{
    IEnumSTATSTG *psEnum;
    STATSTG      sData;
    WCHAR        awcNameBuf[MAX_AWD_NAME]; // 32 == longest possible name.
    UINT         uiNameOffset;
    IStream      *psDisplayOrder;	   // Points to the display order stream.
    char         chData;		   // A single byte of data.
    ULONG        cbRead;		   // Count of bytes read.

    //[RB]assert(psGlobalInfo != NULL);   // Sanity check.
    psDisplayOrder = OpenAWDStream(psStorages->psGlobalInfo, L"Display Order");
    if(psDisplayOrder == NULL) {
	fprintf(stderr, "There is no 'Display Order' stream.  This is an old AWD file.\n");
	if(FAILED(psStorages->psDocuments->lpVtbl->EnumElements(psStorages->psDocuments,
								0,
								NULL,
								0,
								&psEnum))) {
	    return FALSE;
	}
	sData.pwcsName = awcNameBuf;
	
	while(psEnum->lpVtbl->Next(psEnum, 1, &sData, NULL) == S_OK) {
		// We succeeded!
	    if(!(*pfnDocProc)(psStorages, sData.pwcsName))
		return FALSE;	// The enumeration has been aborted.
	}
	psEnum->lpVtbl->Release(psEnum);
	return TRUE;
    }

	// The display order list is a stream of document names.  Each
	// name is null-terminated, and a second null ends the stream.
	// The document names are ANSI characters.
	//
	// The easy way to read this, which is what I do, is to read
	// the stream a byte at a time.  For efficiency, this should be
	// changed to reading larger blocks.

	// Prime the loop by reading the first character.
    psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
    while(chData) {		    // Until I've read a null...
	    // This inner loop prints out a single string.
	uiNameOffset = 0;
	while(chData) {
	    awcNameBuf[uiNameOffset++] = chData;
	    psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
	};
	awcNameBuf[uiNameOffset] = 0;
	    // We've now read & printed a whole string.  Call the enumerator.
	if(!(*pfnDocProc)(psStorages, awcNameBuf)) {
	    psDisplayOrder->lpVtbl->Release(psDisplayOrder);
	    return FALSE;	// The enumeration has been aborted.
	}
	    // And re-prime the engine.
	psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
    }

    psDisplayOrder->lpVtbl->Release(psDisplayOrder);
    return TRUE;
}

// DisplayDocNames
//
// This is a simple little routine that prints out the names of all of the
// documents in an AWD file.  Used in conjunction w/ EnumDocuments.
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pwcsDocName			Name of a document (UNICODE).
//
// Returns:
//	TRUE.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30
BOOL
DisplayDocNames(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    wprintf(L"Document '%s'.\n", pwcsDocName);
    return TRUE;
}

// DetailedDocDump
//
// This function displays lots of information about a particular document.
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pwcsDocName			Name of a document (UNICODE).
//
// Returns:
//	TRUE on success; FALSE on error.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30
BOOL
DetailedDocDump(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    IStream *psDocInfoStream;		    // Stream containing doc information.
    DOCUMENT_INFORMATION sDocInfo;	    // Document information.
    ULONG cbRead;			    // Count of bytes read.
    
    wprintf(L"Information for document '%s' --\n", pwcsDocName);
    psDocInfoStream = OpenAWDStream(psStorages->psDocInfo,
				    pwcsDocName);
    if(psDocInfoStream == NULL) {
	fprintf(stderr, "DetailedDocDump:No document info stream.\n");
	    // This is not a fatal error, so don't exit.
    } else {
	psDocInfoStream->lpVtbl->Read(psDocInfoStream,
				      &sDocInfo,
				      sizeof(sDocInfo),
				      &cbRead);
	if(sizeof(sDocInfo) != cbRead) {
	    fwprintf(stderr, L"DetailedDocDump:Error reading document information "
		     L"for %s.\n", pwcsDocName);
	} else {
	    printf("\tDocument signature = %x.\n", sDocInfo.Signature);
	    printf("\tDocument version = %x.\n", sDocInfo.Version);
	}
    }
    PrintPageInfo(&sDocInfo.PageInformation);
    return TRUE;
}

// PrintPageInfo
//
// This function displays the fields of a PAGE_INFORMATION structure to standard
// output.
//
// Parameters:
//	psPageInfo			The PAGE_INFORMATION structure to display.
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30

void
PrintPageInfo(PAGE_INFORMATION *psPageInfo)
{
    printf("\tStructure signature = %x\n", psPageInfo->Signature);
    printf("\tStructure version   = %x\n", psPageInfo->Version);

    if(psPageInfo->awdFlags & AWD_FIT_WIDTH)
	printf("\tAWD_FIT_WIDTH flag is set.\n");
    if(psPageInfo->awdFlags & AWD_FIT_HEIGHT)
	printf("\tAWD_FIT_HEIGHT flag is set.\n");
    if(psPageInfo->awdFlags & AWD_INVERT)
	printf("\tAWD_INVERT flag is set.\n");
    if(psPageInfo->awdFlags & AWD_IGNORE)
	printf("\tAWD_IGNORE flag is set.\n");

    printf("\tRotation = %d degrees counterclockwise.\n", psPageInfo->Rotation);
    printf("\tScaleX = %d.\n", psPageInfo->ScaleX);
    printf("\tScaleY = %d.\n", psPageInfo->ScaleY);
}

// DumpData
//
// A simple utility function that will write the specified data to a file
// for post-mortem examining.
//
// Parameters
//	pszFileName		Name of the output file.
//	pbData			Pointer to the data.
//	cbCount			Number of bytes to write.
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-7
void
DumpData(LPTSTR pszFileName, LPBYTE pbData, DWORD cbCount)
{
    HANDLE hFile;
    DWORD  cbWritten;

    hFile = CreateFile(
	pszFileName,		// Open this file...
	GENERIC_WRITE,		// We want to write.
	0,			// Don't share.
	NULL,			// No need to inherit.
	CREATE_ALWAYS,		// Always create a new file.
	FILE_ATTRIBUTE_COMPRESSED, // Save disk space... might want to change this later.
	NULL);			// No template file.
    if(hFile != INVALID_HANDLE_VALUE) {
	WriteFile(hFile,
		  pbData,
		  cbCount,
		  &cbWritten,
		  NULL);
	CloseHandle(hFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\awdlib\awd_tiff.c ===
/*++
  Copyright (c) 1997  Microsoft Corporation

  This file contains the parts of the AWD library that are also TIFF-aware
  (i.e., conversion routines).

  Author:
  Brian Dewey (t-briand)  1997-7-16
--*/

#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>		// AWD is an OLE compound document.
#include <assert.h>

#include "awdlib.h"		// Header file for this library.
#include "viewrend.h"		// AWD rendering library.
#include "tifflibp.h"		// Need this for the stolen compression routines.

// ------------------------------------------------------------
// Defines
#define FAX_IMAGE_WIDTH		(1728)

// ------------------------------------------------------------
// Global variables
HANDLE hTiffDest;		// Used in the internal OutputPage()
				// and ConvertAWDToTiff().

// ------------------------------------------------------------
// Internal prototypes
BOOL
CompressBitmapStrip(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    );				// Routine stolen from tiff library.
				// Used to be EncodeMmrBranding().

void
ConvertWidth(const LPBYTE lpSrc, DWORD dwSrcWidth,
	     LPBYTE lpDest, DWORD dwDestWidth,
	     DWORD dwHeight);

BOOL OutputPage(AWD_FILE *psStorages, const WCHAR *pwcsDocName);

// ------------------------------------------------------------
// Routines

// ConvertAWDToTiff
//
// This function does exactly what it says.  Given the name of an AWD file, it
// attempts to convert it to a tiff file.
//
// Parameters:
//	pwcsAwdFile		name of the AWD file.
//	pwcsTiffFile		name of the TIFF file.
//
// Returns:
//	TRUE on successful conversion, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-14
BOOL
ConvertAWDToTiff(const WCHAR *pwcsAwdFile, WCHAR *pwcsTiffFile)
{
    BOOL bRetVal;		// Holds our return value.
    AWD_FILE sAWDStorages;	// Holds the main storages of the AWD file.
    
	// Initialization.
    HeapInitialize(NULL, NULL, NULL, NULL);

	// Open the source.
    if(!OpenAWDFile(pwcsAwdFile, &sAWDStorages)) {
	return FALSE;		
    }

	// Open the destination
    hTiffDest = TiffCreate(pwcsTiffFile,
			   TIFF_COMPRESSION_MMR,
			   FAX_IMAGE_WIDTH,
			   2,	// Fill order 2 == LSB2MSB (I think).
			   1);	// HIRES
    if(hTiffDest == NULL) {
	CloseAWDFile(&sAWDStorages);
	return FALSE;
    }
    bRetVal = EnumDocuments(&sAWDStorages, OutputPage);
    CloseAWDFile(&sAWDStorages);
    TiffClose(hTiffDest);
    return bRetVal;
}

// CompressBitmapStrip
//
// Stolen from Tiff library, where it's called EncodeMmrBranding().
//
// Author: ???
BOOL
CompressBitmapStrip(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    )

/*++

Routine Description:

   Encode an MMR branding from uncompressed branding bits.
   I don't have enough time to write an optimized
   Uncompressed -> MMR convertor, so the compromise is
   to use the existing Uncompressed Decoder (fast enough)
   and use the optimized MMR Encoder.
   Since we only convert few lines for Branding, it's OK.

--*/

{
    INT         a0, a1, a2, b1, b2, distance;
    LPBYTE      prefline;
    BYTE        pZeroline[1728/8];
    INT         delta = BrandWidth / BYTEBITS;
    INT         Lines = 0;
    LPDWORD     lpdwOut = pMmrBrandBits;
    BYTE        BitOut = 0;



#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif


    // set first all white reference line

    prefline = pZeroline;

    ZeroMemory(pZeroline, BrandWidth/8);

    // loop til all lines done

    do {

        a0 = 0;
        a1 = GetBit( pBrandBits, 0) ? 0 : NextChangingElement(pBrandBits, 0, BrandWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, BrandWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= BrandWidth) ? BrandWidth :
                    NextChangingElement( prefline, b1, BrandWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                //OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
                (*lpdwOut) += ( ((DWORD) (PASSCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + PASSCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (PASSCODE_REVERSED) ) >> (PASSCODE_LENGTH - BitOut);
                }


#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                // OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
                (*lpdwOut) += ( ( (DWORD) VertCodesReversed[distance+3].code) << BitOut);
                if ( (BitOut = BitOut + VertCodesReversed[distance+3].length ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (VertCodesReversed[distance+3].code) ) >> (VertCodesReversed[distance+3].length - BitOut);
                }

#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= BrandWidth) ? BrandWidth :
                        NextChangingElement( pBrandBits, a1, BrandWidth, GetBit( pBrandBits, a1 ) );

                // OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
                (*lpdwOut) += ( ((DWORD) (HORZCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + HORZCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (HORZCODE_REVERSED) ) >> (HORZCODE_LENGTH - BitOut);
                }



#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( pBrandBits, a0 )) {

                    //OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    //OutputRun( TiffInstance, a2-a1, WhiteRunCodes );
                    OutputRunFastReversed(a1-a0, BLACK, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, WHITE, &lpdwOut, &BitOut);

                } else {

                    //OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    //OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                    OutputRunFastReversed(a1-a0, WHITE, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, BLACK, &lpdwOut, &BitOut);

                }

                a0 = a2;
            }

            if (a0 >= BrandWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( pBrandBits, a0, BrandWidth, GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, a0, BrandWidth, !GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, b1, BrandWidth, GetBit( pBrandBits, a0 ) );
        }

        prefline = pBrandBits;
        pBrandBits += (BrandWidth / 8);

    } while (Lines < BrandHeight);

    *DwordsOut = (DWORD)(lpdwOut - pMmrBrandBits);
    *BitsOut  = BitOut;

    return TRUE;
}

// ConvertWidth
//
// Changes the width of a bitmap.  If the desired width is smaller than the current
// width, this is accomplished by truncating lines.  If the desired width is greater
// than the current width, data will be copied up from the next line.
//
// Parameters:
//	lpSrc			Bitmap source.
//	dwSrcWidth		Its width.
//	lpDest			Pointer to destination.
//	dwDestWidth		Desired width of destination
//	dwHeight		Height of image (won't change).
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-10
void
ConvertWidth(const LPBYTE lpSrc, DWORD dwSrcWidth,
	     LPBYTE lpDest, DWORD dwDestWidth,
	     DWORD dwHeight)
{
    LPBYTE lpSrcCur, lpDestCur;
    DWORD  dwCurLine;

    for(lpSrcCur = lpSrc, lpDestCur = lpDest, dwCurLine = 0;
	dwCurLine < dwHeight;
	lpSrcCur += dwSrcWidth, lpDestCur += dwDestWidth, dwCurLine++) {
	memcpy(lpDestCur, lpSrcCur, dwDestWidth);
    }
}

// OutputPage
//
// This is the core of the converter; it takes a single AWD page and writes it
// to the TIFF file.
//
// Parameters:
//	psStorages		Pointer to the AWD file from which we read.
//	pwcsDocName		Name of the page.
//
// Returns:
//	TRUE on success, FALSE on failure.
//
// Author:
//	Brian Dewey (t-briand)  1997-7-2
BOOL
OutputPage(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    BITMAP bmBand;		// A band of image data.
    LPBYTE lpOutBuf;		// Output bitmap (resized).
    LPBYTE lpOutCur;		// Used to write one line at a time.
    LPDWORD lpdwOutCompressed;	// Compressed output.
    DWORD dwDwordsOut,		// Number of DWORDS in compressed output...
	dwBitsOut = 0;		// Number of bits in compressed output.
    DWORD dwBitsOutOld = 0;	// BitsOut from the *previous* band compression.
    LPVOID lpViewerContext;	// The viewer context; used by viewrend library.
    VIEWINFO sViewInfo;		// Information about the image.
    WORD awResolution[2],	// Holds X & Y resolutions
	wBandSize = 256;	// Desired band size; will be reset by ViewerOpen.
    IStream *psDocument;	// Our document stream.
    BOOL bRet = FALSE;		// Return value; FALSE by default.
    UINT iCurPage;		// Current page.
    const DWORD dwMagicHeight = 3000; // FIXBKD

    if((psDocument = OpenAWDStream(psStorages->psDocuments, pwcsDocName)) == NULL) {
	fwprintf(stderr, L"OutputPage:Unable to open stream '%s'.\n",
		pwcsDocName);
	return FALSE;		// We failed.
    }
	// Now, open a viewer context and start reading bands of the image.
    if((lpViewerContext = ViewerOpen(psDocument,
				     HRAW_DATA,
				     awResolution,
				     &wBandSize,
				     &sViewInfo)) == NULL) {
	fprintf(stderr, "OutputPage:Unable to open viewer context.\n");
	return FALSE;
    }

    iCurPage = 0;		// Initialize our counter.

    bmBand.bmBits = malloc(wBandSize);	// Allocate memory to hold the band.
    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
	fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
	return FALSE;
    }
	// lpOutBuf = malloc(bmBand.bmHeight * (FAX_IMAGE_WIDTH / 8));
    lpOutBuf = malloc(dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	// Provided compression actually *compresses*, we should have more than
	// enough memory allocated.
    lpdwOutCompressed = malloc(dwMagicHeight * (FAX_IMAGE_WIDTH / 8));

    if(!lpOutBuf || !lpdwOutCompressed) {
		// check whether we are short in memory
		TiffEndPage(hTiffDest);
		if(lpOutBuf) free(lpOutBuf);
		if(lpdwOutCompressed) free(lpdwOutCompressed);
		return FALSE;		// This will stop the conversion process.
    }

	memset(lpOutBuf, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
    memset(lpdwOutCompressed, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));


	// Main loop
    while(iCurPage < sViewInfo.cPage) {
	lpOutCur = lpOutBuf;
	while(bmBand.bmHeight) {
		// Make sure our bitmap has FAX_IMAGE_WIDTH as its width.
	    ConvertWidth(bmBand.bmBits, bmBand.bmWidth / 8,
			 lpOutCur, FAX_IMAGE_WIDTH / 8,
			 bmBand.bmHeight);
	    lpOutCur += (bmBand.bmHeight * (FAX_IMAGE_WIDTH / 8));
	    
	    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
		fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
		goto output_exit;	// Will return FALSE by default.
	    }
	} // while (wasn't that easy?)

	memset(lpdwOutCompressed, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	CompressBitmapStrip(lpOutBuf,
			    lpdwOutCompressed,
			    (ULONG)((lpOutCur - lpOutBuf) / (FAX_IMAGE_WIDTH / 8)),
			    FAX_IMAGE_WIDTH,
			    &dwDwordsOut,
			    &dwBitsOut);
	memset(lpOutBuf, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	fprintf(stderr, "OutputPage:Compressed image to %d dwords, %d bits.\n",
		dwDwordsOut, dwBitsOut);
			
	if(!TiffStartPage(hTiffDest)) {
	    fprintf(stderr, "OutputPage:Unable to open output page.\n");
	    return FALSE;	// We can't begin a page for some reason.
	    if(lpOutBuf) free(lpOutBuf);
	    if(lpdwOutCompressed) free(lpdwOutCompressed);
	}
	TiffWriteRaw(hTiffDest, (LPBYTE)lpdwOutCompressed,
		     (dwDwordsOut + 1) * sizeof(DWORD));
	((PTIFF_INSTANCE_DATA)hTiffDest)->Lines =
	    (ULONG)((lpOutCur - lpOutBuf) / (FAX_IMAGE_WIDTH / 8));
	if(sViewInfo.yRes <= 100)
	    ((PTIFF_INSTANCE_DATA)hTiffDest)->YResolution = 98;
	else
	    ((PTIFF_INSTANCE_DATA)hTiffDest)->YResolution = 196;
	TiffEndPage(hTiffDest);

	    // Now, move to a new page of the data.
	iCurPage++;
	if(iCurPage < sViewInfo.cPage) {
	    ViewerSetPage(lpViewerContext, iCurPage);
	    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
		fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
		goto output_exit;	// Will return FALSE by default.
	    }
	}
    }

	// Free memory.
    bRet = TRUE;
  output_exit:
    free(lpdwOutCompressed);
    free(lpOutBuf);
    free(bmBand.bmBits);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\awdlib\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains utilitarian functions for
    the FAX TIFF library.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((DWORD_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}


INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((DWORD_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\awdvstub\resource.h ===
// resource.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// This file contains the resource constants for the AWD viewer stub.
//
// Author:
//	Brian Dewey (t-briand)	1997-8-18

#define IDS_USEAGE	200
#define IDS_TITLE	201
#define IDS_NOVIEW	202
#define IDS_ERRCONV	203
#define IDS_NOTEMPPATH  204
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\dcxcodec\dcxcodec.cpp ===
/*==============================================================================
This code module handles HRAW<==>DCX conversions.

DATE       NAME      COMMENTS
13-Apr-93  RajeevD   Adapted to C++ from WFW.
05-Oct-93  RajeevD   Moved out of faxcodec.dll
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include <dcxcodec.h>

#ifdef DEBUG
DBGPARAM dpCurSettings = {"DCXCODEC"};
#endif

// Context Object
typedef struct FAR DCX : public FC_PARAM
{
	LPBYTE lpbSave;
	UINT   cbSave;
	LPBYTE lpbIn, lpbOut;
	UINT   cbIn,  cbOut;
	UINT   ibLine;
	BYTE   bVal, bRun;
	
	void Init (LPFC_PARAM lpfcParam)
	{
			_fmemcpy (this, lpfcParam, sizeof(FC_PARAM));
			ibLine = 0;
			bRun = 0;
			cbSave = 0;
			lpbSave = (LPBYTE) (this + 1);
	}

	FC_STATUS Convert (LPBUFFER, LPBUFFER);
	void RawToDcx (void);
	void DcxToRaw (void);
}
	FAR *LPDCX;

//==============================================================================
FC_STATUS DCX::Convert
	(LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	// Trap end of page.
	if (!lpbufIn || lpbufIn->dwMetaData == END_OF_PAGE)
		return FC_INPUT_EMPTY;

	// Get buffer parameters.
	lpbIn = lpbufIn->lpbBegData;		
	cbIn = lpbufIn->wLengthData;
	lpbOut = lpbufOut->EndData();

  // Restore raw overflow.
	if (cbSave)
	{
		DEBUGCHK (nTypeOut == HRAW_DATA);
		_fmemcpy (lpbOut, lpbSave, cbSave);
		lpbOut += cbSave;
	}

  // Calculate output buffer.
	cbOut = (UINT)(lpbufOut->EndBuf() - lpbOut);

	// Execute the conversion.
	nTypeOut == DCX_DATA ? RawToDcx() : DcxToRaw();

	// Adjust buffers.
	lpbufIn->lpbBegData = lpbIn;
	lpbufIn->wLengthData = (USHORT)cbIn;
	lpbufOut->wLengthData = (USHORT)(lpbOut - lpbufOut->lpbBegData);

	// Save raw overflow.
	if (nTypeOut == HRAW_DATA)
 	{
		cbSave = lpbufOut->wLengthData % cbLine;
		lpbufOut->wLengthData -= (USHORT)cbSave;
		_fmemcpy (lpbSave, lpbufOut->EndData(), cbSave);
	}

	// Return status.
	return cbIn? FC_OUTPUT_FULL : FC_INPUT_EMPTY;
}

/*==============================================================================
This procedure decodes HRAW bitmaps from DCX.  In a DCX encoding, if the two 
high bits of a byte are set, the remainder of the byte indicates the number of 
times the following byte is to be repeated.  The procedure returns when either 
the input is empty, or the output is full.  Unlike the consumers and producers 
in the t4core.asm, it does not automatically return at the first EOL.
==============================================================================*/
void DCX::DcxToRaw (void)
{
  // Loop until input is empty or output is full.
	while (1)
	{
		if (bRun >= 0xC0)		    // Has the run been decoded?
		{
			if (!cbIn) return;    // Check if input is empty.
			if (ibLine >= cbLine) // If at end of line,
				ibLine = 0;         //   wrap the position.
			bVal = ~(*lpbIn++);   // Fetch the value of the run.
			cbIn--;
			bRun -= 0xC0;         // Decode the run length.
		}

#if 0 // transparent version

    // Write out the run.
		while (bRun) 
		{	
			*lpbOut++ = bVal;
	 		cbOut--;
	 		ibLine++;
			bRun--;
		}

#else // optimized version

		if (bRun)
		{
			// Write out the run.
			BYTE bLen = min (bRun, cbOut);
			_fmemset (lpbOut, bVal, bLen);

			// Adjust the output parameters.
			bRun -= bLen;
			lpbOut += bLen;
			cbOut -= bLen;
			ibLine += bLen;
											
			// Check if output is full.
			if (!cbOut) return;
		}

#endif // optimize switch

		if (!cbIn) return;    // Fetch the next byte.
		if (ibLine >= cbLine)	// If at end of line,
			ibLine = 0;         //   wrap the position.
		if (*lpbIn >= 0xC0)		// If the byte is a run length, set up.
			bRun = *lpbIn++;

		else                  // Otherwise the byte is a single value.
			{ bRun = 1; bVal = ~(*lpbIn++);}
		cbIn--;

	} // while (1)
	
}
 
/*==============================================================================
This procedure encodes HRAW bitmaps for DCX.  In a DCX encoding, if the two 
high bits of a byte are set, the remainder of the byte indicates the number of 
times the following byte is to be repeated.  The procedure returns when either 
the input is empty or the output is full.  Unlike its brethren in T4, it does 
not return automatically at EOL.
==============================================================================*/
void DCX::RawToDcx (void)
{
	BYTE bVal, bRun;

	// Convert until input is empty or output is full.
	// The output is full if only one byte is available
	// because one input byte may produce two output bytes.
	while (cbIn && cbOut > 1)
	{
		if (ibLine >= cbLine) ibLine = 0;	// If EOL, wrap the position.
			
		// Get an input byte.
		bVal = *lpbIn++;
		cbIn--;
		bRun = 1;
		ibLine++;
		
		// Scan for a run until one of the following occurs:
		// (1) There are no more input bytes to be consumed.
		// (2) The end of the current line has been reached.
		// (3) The run length has reached the maximum of 63.
		// (4) The first byte does not match the current one.

#if 0 // Transparent Version.	

		while (/*1*/ cbIn	// Check first to avoid GP faults!
				&& /*4*/ bVal == *lpbIn
				&& /*2*/ ibLine < cbLine
				&& /*3*/ bRun < 63
					)
		{ lpbIn++; cbIn--; bRun++; ibLine++; }

#else // Optimized Version
	
	// If the next byte matches, scan for a run.
	// This test has been unrolled from the loop.
 	if (cbIn && bVal == *lpbIn)
	{
		BYTE ubMaxRest, ubRest;
		
		// Calculate the maximum number of bytes remaining.
		ubMaxRest = min (cbIn, 62);
		ubMaxRest = min (ubMaxRest, cbLine - ibLine);

		// Scan for a run.
		ubRest = 0;
		while (bVal == *lpbIn && ubRest < ubMaxRest)
			{lpbIn++; ubRest++;}

		// Adjust state.
		cbIn -= ubRest;
		ibLine += ubRest;
		bRun = ++ubRest;
	}

#endif // End of Compile Switch
 			
		bVal = ~bVal;		// Flip black and white.

		// Does the value need to be escaped,
		// or is there non-trival run of bytes?
		if (bVal >= 0xC0 || bRun>1)
		{ // Yes, encode the run length.
		  // (Possibly 1 for bVal>=0xC0).
			*lpbOut++ = bRun + 0xC0;
			cbOut--;
		}	

		*lpbOut++ = bVal;		// Encode the value.
		cbOut--;

	} // while (1)
}

//==============================================================================
// C Export Wrappers
//==============================================================================

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
UINT WINAPI DcxCodecInit
	(LPVOID lpContext, LPFC_PARAM lpfcParam)
{
	UINT cbContext = sizeof(DCX);
	if (lpfcParam->nTypeOut == HRAW_DATA)
		cbContext += lpfcParam->cbLine;

	if (lpContext)
		((LPDCX) lpContext)->Init (lpfcParam);
	return cbContext;
}
 
//==============================================================================
FC_STATUS WINAPI DcxCodecConvert
	(LPVOID lpContext, LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	return ((LPDCX) lpContext)->Convert (lpbufIn, lpbufOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\awdvstub\awdvstub.c ===
/*++
  awdvstub.c

  Copyright (c) 1997  Microsoft Corporation


  This program is a stub AWD viewer... it will first convert an awd file named
  on the command line to a tiff file in the temp directory, then it will launch
  the tiff viewer on that file.

  Also, when used with the '/c' switch, it's an AWD converter.  Two programs in one!

  Author:
  Brian Dewey (t-briand)    1997-7-15
--*/

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "awdlib.h"     // Gives access to the AWD routines.
#include "tifflib.h"        // TIFF routines.
#include "tifflibp.h"       // I need access to the private TIFF definitions.
#include "faxutil.h"        // not sure why I need this...
#include "viewrend.h"       // win95 viewer library.
#include "resource.h"       // resource constants

// ------------------------------------------------------------
// Prototypes
void Useage(HINSTANCE hInst);
void PopupError(UINT uID, HINSTANCE hModule);

// ------------------------------------------------------------
// WinMain

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
    )
{
    LPWSTR *argv;
    DWORD   argc;
    UINT    uiCurrentArg;   // Used for iterating through arguments.
    UINT    uiNumFiles=0;   // This is the number of files we've gotten
                // from the command line.
    WCHAR   szTempPath[MAX_PATH]; // Holds the temporary path.
    WCHAR   szTempFile[MAX_PATH]; // Holds the temporary file name.
    WCHAR   szAwdFile[MAX_PATH]; // Holds the name of the AWD file we're viewing or converting.
    int     iStrLen;
    BOOL    bConvert = FALSE;   // TRUE if we're to do a permanent conversion.
                // If FALSE, we do a conversion to a temporary file &
                // launch the viewer.
    BOOL    bTempProvided = FALSE;// If TRUE, then the user provided the destination file.
    UINT    uiHackPosition = 0; // Oh, this is part of some awful code below...


    argv = CommandLineToArgvW( GetCommandLine(), &argc );
    if(NULL == argv)
    {
        return 1;
    }
    if(argc < 2)
    {
        Useage(hInstance);
        return 1;
    }
    
    
    for(uiCurrentArg = 1; uiCurrentArg < argc; uiCurrentArg++) 
    {
        if((argv[uiCurrentArg][0] == L'-') ||
           (argv[uiCurrentArg][0] == L'/')) 
        {
                switch(argv[uiCurrentArg][1]) 
                {
                    // We're doing a switch based on the character after the
                    // command-argument specifier ('-' or '/').  Put additional
                    // arguments here as needed.
                  case L'c':
                  case L'C':
                if (argc<3)
                {
                    Useage(hInstance);
                    return 1;
                }
                bConvert = TRUE; // We're meant to do a permanent conversion.
                break;
                  default:
                    // Should an invalid parameter be an error?
                Useage(hInstance);
                return 1;
                } // Switch
        } else 
            {
            switch(uiNumFiles) {
              case 0:
                // If we haven't encountered any files before, then
                // this is the name of the AWD file.
            wcscpy(szAwdFile, argv[uiCurrentArg]);
            break;
              case 1:
                // Now, we're reading the name of the TIF file for permanent conversion.
            bTempProvided = TRUE;
            wcscpy(szTempFile, argv[uiCurrentArg]);
            break;
              default:
                // Too many parameters!
            Useage(hInstance);
            return 1;
            }
            uiNumFiles++;
        }
    } // For

    if(!bTempProvided) {
    if(!bConvert) {
        // If the user didn't give a temp file name, we provide one.
        if(!GetTempPath(MAX_PATH, szTempPath)) {
        PopupError(IDS_NOTEMPPATH, hInstance);
        return 1;       // Failed to get the path. 
        }
        GetTempFileName(
        szTempPath,     // put the file in this directory.
        TEXT("avs"),        // prefix -- "awd viewer stub"
        0,          // Generate a unique name.
        szTempFile      // Will hold the new name
        );
        DeleteFile(szTempFile); // Get rid of that file name.
                    // (created when obtained.)
    } else {
        // The user requested permanent conversion, but didn't
        // supply a name.  In this case, change the extention of
        // the file to TIF instead of generating a temp file name.
        wcscpy(szTempFile, szAwdFile);
    }
        // Make sure the file has the TIF extension.
    iStrLen = wcslen(szTempFile);
    szTempFile[iStrLen-3] = L't';
    szTempFile[iStrLen-2] = L'i';
    szTempFile[iStrLen-1] = L'f';
    } // if(bTempProvided)...
    
    if(ConvertAWDToTiff(szAwdFile, szTempFile)) 
    {
        SHELLEXECUTEINFO sei = {0};
        if(bConvert) 
        {
            return 0;      // We're done!
        }
        // now we have to tiff in szTempFile.
        // let's run ShellExecute on it to open it.
        // and wait for the viewer to close.
        sei.cbSize = sizeof (SHELLEXECUTEINFO);
        sei.fMask = SEE_MASK_NOCLOSEPROCESS;

        sei.lpVerb = TEXT("open");
        sei.lpFile = szTempFile;
        sei.lpParameters = NULL;
        sei.lpDirectory  = TEXT(".");
        sei.nShow  = SW_MAXIMIZE;

        if(!ShellExecuteEx(&sei))
        {
            PopupError(IDS_NOVIEW, hInstance);
        }
    
        WaitForSingleObject(sei.hProcess, INFINITE);
        // When we get here, the viewer has terminated.
        DeleteFile(szTempFile); // Erase our tracks.
    } 
    else
    {
        PopupError(IDS_ERRCONV, hInstance);
    }
    return 0;
}

// Useage
//
// Displays command useage.
//
// Parameters:
//  hInst           Current module instance.
//
// Returns:
//  Nothing.
//
// Author:
//  Brian Dewey (t-briand)  1997-8-7
void
Useage(HINSTANCE hInst)
{
    PopupError(IDS_USEAGE, hInst);
}

// PopupError
//
// Displays a message box with an error message.
//
// Parameters:
//  uID     String resource ID
//  hModule     Module instance.
//
// Returns:
//  Nothing.
//
// Author:
//  Brian Dewey (t-briand)  1997-8-19
void
PopupError(UINT uID, HINSTANCE hModule)
{
    TCHAR szTitle[512], szMsg[512];

    if(!LoadString(hModule,
           IDS_TITLE,
           szTitle,
           sizeof(szTitle)/sizeof(TCHAR))) 
    {
        return;
    }
    if(!LoadString(hModule,
           uID,
           szMsg,
           sizeof(szMsg)/sizeof(TCHAR))) 
    {
        return;
    }
    AlignedMessageBox(NULL, szMsg, szTitle, MB_OK | MB_ICONSTOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\faxcodec\bitrev.c ===
#include <ifaxos.h>
#include <faxcodec.h>

//==============================================================================
const BYTE BitRev[256] = // bit reversal of index
{
	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

//==============================================================================
void WINAPI BitReverseBuf (LPBUFFER lpbuf)
{
	LPBYTE lpb; 
	USHORT cb; 

	DEBUGCHK (lpbuf && lpbuf->wLengthData % 4 == 0);

	switch (lpbuf->dwMetaData)
	{
		case LRAW_DATA:	lpbuf->dwMetaData = HRAW_DATA; break;
		case HRAW_DATA:	lpbuf->dwMetaData = LRAW_DATA; break;
		default:
			DEBUGMSG (1, ("FaxCodecRevBuf invalid metadata %d\r\n",lpbuf->dwMetaData));
	}

	lpb = lpbuf->lpbBegData;
	cb = lpbuf->wLengthData;
	while (cb--)
		*lpb++ =  BitRev[*lpb];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\faxcodec\client.c ===
/*==============================================================================
This source file is an example of a faxcodec.dll client.
          
DATE				NAME			COMMENT
13-Apr-93		rajeevd		Moved out of faxcodec.dll
18-Nov-93   rajeevd   Updated to new faxcodec API.
==============================================================================*/
#include <windows.h>
#include <buffers.h>
#include <faxcodec.h>

/*==============================================================================
This procedure performs any conversion indicated by a star in the table below:

                            Output

                 HRAW   LRAW   MH   MR    MMR

          HRAW                 *     *     *

          LRAW		             *     *     *

  Input   MH       *     *           *     *

          MR       *     *     *           *

          MMR      *     *     *     *      

The input and output are assumed to be in non-overlapping memory buffers.
==============================================================================*/

UINT MemConvert      // returns output data size (0 on failure)
	(
		LPBYTE lpbIn,    // input data pointer
		UINT   cbIn,     // input data size
		DWORD  nTypeIn,  // input data encoding
		
		LPBYTE lpbOut,   // output buffer pointer
		UINT   cbOut,    // output buffer size
		DWORD  nTypeOut, // output data encoding
		
		UINT   cbLine,   // scan line width
		UINT   nKFactor  // K factor (significant if nTypeOut==MR_DATA)
	)
{
	UINT cbRet = 0; 
	
	BUFFER bufIn, bufOut, bufEOP;
	BOOL fRevIn, fRevOut;

	HANDLE hContext;
	LPVOID lpContext;
	UINT cbContext;

	FC_PARAM  fcp;
	FC_STATUS fcs;
	
	// Set up input buffer.
	bufIn.lpbBegBuf = lpbIn;	
	bufIn.wLengthBuf  = cbIn;  
	bufIn.lpbBegData  = lpbIn;
	bufIn.wLengthData = cbIn;
	bufIn.dwMetaData   = nTypeIn;
	
	// Set up output buffer.
	bufOut.lpbBegBuf   = lpbOut;
	bufOut.lpbBegData  = lpbOut;
	bufOut.wLengthBuf  = cbOut;
	bufOut.wLengthData = 0;
	bufOut.dwMetaData   = nTypeOut;
	
	// Initialize EOP buffer
	bufEOP.dwMetaData = END_OF_PAGE;

	// Handle input bit reversal.
	if (nTypeIn == HRAW_DATA)
	{
		fRevIn = TRUE;
		BitReverseBuf (&bufIn);
	}	
	else fRevIn = FALSE;
	
	// Detect output bit reversal.
	if (nTypeOut == HRAW_DATA)
	{
		fRevOut = TRUE;
		nTypeOut = LRAW_DATA;
	}
	else fRevOut = FALSE;

	// Initialize parameters.
	fcp.nTypeIn  = nTypeIn;
	fcp.nTypeOut = nTypeOut;
	fcp.cbLine   = cbLine;
	fcp.nKFactor = nKFactor;

	// Query for size of context.
	cbContext = FaxCodecInit (NULL, &fcp);
	if (!cbContext)
		goto err;

	// Allocate context memory.
	hContext = GlobalAlloc (GMEM_FIXED, cbContext);
	if (!hContext)
		goto err;
	lpContext = GlobalLock (hContext);

	// Initialize context.
	FaxCodecInit (lpContext, &fcp); 

	// Convert data in single pass.
	fcs = FaxCodecConvert (lpContext, &bufIn,  &bufOut); 

	// Flush EOFB for nTypeOut == MMR_DATA
	FaxCodecConvert (lpContext, &bufEOP, &bufOut);

	// Free context memory.
	GlobalUnlock (hContext);
	GlobalFree (hContext);
	
	// Undo input bit reversal.
	if (fRevIn)
	{
		bufIn.lpbBegData = lpbIn;
		bufIn.wLengthData = cbIn;
		BitReverseBuf (&bufIn);
	}

	// Handle output bit reversal.
	if (fRevOut)
		BitReverseBuf (&bufOut);
	
	if (fcs == FC_INPUT_EMPTY)
		cbRet = bufOut.wLengthData;

err:
	return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\dcxcodec\raw2dcx.c ===
/*==============================================================================
This procedure converts HRAW to DCX in memory.

ASSUMES
1) Input buffer contains a single scan line.
2) Output buffer is twice as large as input.

29-Apr-94    RajeevD    Adapted from dcxcodec.dll
==============================================================================*/
#include <windows.h>

UINT              // output data size
DCXEncode
(
	LPBYTE lpbIn,   // raw input buffer
  LPBYTE lpbOut,  // dcx output buffer
	UINT cbIn       // input data size
)
{
	UINT cbOut = 0;
	BYTE bVal, bRun;

  while (cbIn)
  {
		// Get an input byte.
		bVal = *lpbIn++;
		cbIn--;
		bRun = 1;
	
		// Scan for a run until one of the following occurs:
		// (1) There are no more input bytes to be consumed.
		// (2) The run length has reached the maximum of 63.
		// (3) The first byte does not match the current one.

	 	if (cbIn && bVal == *lpbIn)
		{
			BYTE cbMax, cbRest;
			
			// Calculate the maximum number of bytes remaining.
			cbMax = min (cbIn, 62);

			// Scan for a run.
			cbRest = 0;
			while (bVal == *lpbIn && cbRest < cbMax)
				{lpbIn++; cbRest++;}

			// Adjust state.
			cbIn -= cbRest;
			bRun = ++cbRest;
		}	
		
	  // Flip black and white.
		bVal = ~bVal;	

		// Does the value need to be escaped,
		// or is there non-trival run of bytes?
		if (bVal >= 0xC0 || bRun>1)
		{
			// Yes, encode the run length.
		  // (possibly 1 for bVal>=0xC0).
			*lpbOut++ = bRun + 0xC0;
			cbOut++;
		}	

		// Encode the value.
		*lpbOut++ = bVal;		
		cbOut++;
	
	} // while (cbIn)

	return cbOut;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\faxcodec\convert.cpp ===
/*==============================================================================
This code module handles T4 conversion instances.

DATE        NAME       COMMENTS
12-Apr-93   RajeevD    Adapted to C++ from WFW.
20-Apr-93   RajeevD    Overhauled buffer handling.
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include <faxcodec.h>
#include "context.hpp"

#define RTC_EOL 5

#define VALIDATE_CHANGE

typedef short FAR *LPSHORT;

//==============================================================================
#pragma warning(disable:4704)

#ifdef WIN32

UINT // size of change vector (0 if invalid)
ValidChangeVector
(
	LPSHORT lpsChange,   // change vector buffer
	SHORT   xExt         // pixel width of line
)
{
	SHORT sPrev = -1;

	SHORT cChange = xExt;

	while (cChange--)
	{
		// Check monotonicity.
		if (*lpsChange <= sPrev)
			return 0;
		sPrev = *lpsChange++;

		if (sPrev == xExt)
		{
			// Check EOL termination.
			if
			(   *lpsChange++ == xExt
			 && *lpsChange++ == xExt
			 && *lpsChange++ == xExt
			 && *lpsChange++ == -1
			 && *lpsChange++ == -1
		  )
			return sizeof(WORD) * (xExt - cChange) ;
		else
			return 0;
		}
		
	} // while (cChange--)

	return 0; // Hit end of change vector buffer.
}

#else // ifndef WIN32

UINT // size of change vector (0 if invalid)
ValidChangeVector
(
	LPSHORT lpsChange,   // change vector buffer
	SHORT   xExt         // pixel width of line
)
{
	UINT uRet;

	_asm
	{
		push	ds
		push	si

		lds		si, DWORD PTR [lpsChange]	; lpsChange
		mov		dx, -1						; sPrev
		mov		cx, xExt					; cChange
		mov		bx, cx						; xExt
		jmp		enterloop

	fooie:
		lodsw
		cmp		ax, dx
		jle		error		; need SIGNED compare
		mov		dx, ax
		cmp		dx, bx
		je		goteol
	enterloop:
		loop	fooie
	error:
		xor		ax, ax
		jmp		done

	goteol:
		lodsw
		cmp		ax, bx		; bx == xExt
		jne		error
		lodsw
		cmp		ax, bx
		jne		error
		lodsw
		cmp		ax, bx
		jne		error

		xor		bx, bx
		not		bx			; bx == -1
		lodsw
		cmp		ax, bx
		jne		error
		lodsw
		cmp		ax, bx
		jne		error

    // uRet = sizeof(WORD) * (xExt - cChange) ;
		mov   ax, xExt
		sub   ax, cx
		inc   ax
		shl   ax, 1
    
	done:
		pop		si
		pop		ds
		mov		uRet, ax
	}
	return uRet;
}

#endif // WIN32

//==============================================================================
void CODEC::ResetBad (void)
{
	DEBUGMSG (1,("FAXCODEC: decoded %d bad line(s)\r\n", wBad));
	if (fcCount.cMaxRunBad < wBad)
		fcCount.cMaxRunBad = wBad;
	wBad = 0;
}

//==============================================================================
void CODEC::SwapChange (void)
{
	LPBYTE lpbTemp;
	lpbTemp = lpbChange;
	lpbChange = lpbRef;
	lpbRef = lpbTemp;
}

//==============================================================================
void CODEC::EndLine (void)
{
	if (f2D)
	{
		// Reset consumer and producer.
		t4C.lpbRef =    lpbRef;
		t4C.lpbBegRef = lpbRef;
		t4P.lpbRef =    lpbRef;
		t4P.lpbBegRef = lpbRef;

		// Increment K Factor
		t4P.iKFactor++;
		if (t4P.iKFactor == nKFactor)
			t4P.iKFactor = 0;
	}

	// Clear change vector buffer (debug only).
	DEBUGSTMT (_fmemset (lpbChange, 0xCD, sizeof(WORD) * xExt + CHANGE_SLACK));

	// Reset consumer.
	t4C.wColumn = 0;
	t4C.wColor = 0;
	t4C.lpbOut = lpbChange;
	t4C.wOffset = LOWORD(lpbChange);
	t4C.wToggle = 0;

	// Reset producer.	
	t4P.wColumn = 0;
	t4P.wColor = 0;
	t4P.lpbIn = lpbChange;
}

//==============================================================================
void CODEC::StartPage (void)
{
	if (wBad) ResetBad();
	cSpurious = 0;
	EndLine ();

	// Reset consumer.
	t4C.wWord = 0;
	t4C.wBit = 0;
	t4C.wRet = RET_BEG_OF_PAGE;

	// Reset producer.
	t4P.wWord = 0;
	t4P.wBit = 0;
	t4P.wRet = RET_BEG_OF_PAGE;

	// Blank buffered output line.
	_fmemset (lpbLine, 0, cbLine);

	if (f2D)
	{
		// Blank reference vector.
		LPWORD lpwRef = (LPWORD) lpbRef;

		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = 0xFFFF;
		*lpwRef++ = 0xFFFF;

		t4C.wMode = 0;
		t4P.wMode = 0;
		t4P.iKFactor = 0;
	}
}

//==============================================================================
void CODEC::EndPage (LPBUFFER lpbufOut)
{
	// Flush last byte and end-of-block code.
	switch (nTypeOut)
	{
		case LRAW_DATA:
		case NULL_DATA:
			return;
			
		case MH_DATA:
		case MR_DATA:
#ifndef WIN32
			return;
#endif		
		case MMR_DATA:
		{
			LPBYTE lpbBeg = lpbufOut->EndData();
    	t4P.lpbOut = lpbBeg;
    	t4P.cbOut = (WORD)(lpbufOut->EndBuf() - t4P.lpbOut);
    	t4P.wRet = RET_END_OF_PAGE;
    	Producer (&t4P);
    	lpbufOut->wLengthData += (WORD)(t4P.lpbOut - lpbBeg);
    	return;
		}
		
    default: DEBUGCHK (FALSE);
	}
}

/*==============================================================================
This method initializes a CODEC context.
==============================================================================*/
void CODEC::Init (LPFC_PARAM lpParam, BOOL f2DInit)
{
		DEBUGMSG (1, ("FAXCODEC: nTypeIn  = %lx\n\r", lpParam->nTypeIn));
		DEBUGMSG (1, ("FAXCODEC: nTypeOut = %lx\n\r", lpParam->nTypeOut));
		DEBUGMSG (1, ("FAXCODEC: cbLine   = %d\n\r", lpParam->cbLine));
		DEBUGMSG (1, ("FAXCODEC: nKFactor = %d\n\r", lpParam->nKFactor));
	
		// Initialize constants.
		_fmemcpy (this, lpParam, sizeof(FC_PARAM));
		xExt = 8 * cbLine;
		f2D = f2DInit;

		switch (nTypeIn)        // Determine the consumer.
		{
			case LRAW_DATA:   Consumer = RawToChange;	break;
			case MH_DATA:			Consumer = MHToChange;	break;
    	case MR_DATA:			Consumer = MRToChange;  break;
			case MMR_DATA:		Consumer = MMRToChange;	break;
			default:					DEBUGCHK (FALSE);
		}
		
		switch (nTypeOut)       // Determine the producer.
		{
			case NULL_DATA:   Producer = NULL;         break;		
			case LRAW_DATA:   Producer = ChangeToRaw;  break;
		  case MH_DATA:     Producer = ChangeToMH;   break;
		  case MR_DATA:     Producer = ChangeToMR;   break;
		  case MMR_DATA:    Producer = ChangeToMMR;  break;
			default:          DEBUGCHK (FALSE);
		}

	 	// Initialize memory buffers.
		lpbLine = (LPBYTE) (this + 1);
		lpbChange = lpbLine + cbLine + RAWBUF_SLACK;
		lpbRef = lpbChange;
		if (f2D)
			lpbRef += xExt * sizeof(USHORT) + CHANGE_SLACK;
 
		// Initialize consumer state.
		t4C.cbSlack = CHANGE_SLACK;
		t4C.cbLine  = (WORD)cbLine;
		t4C.nType   = nTypeIn;
		
		// Initialize producer state.
		t4P.cbSlack = OUTBUF_SLACK;
		t4P.cbLine  = (WORD)cbLine;
		t4P.nType   = nTypeOut;
		
		// Initialize error counts.
		_fmemset (&fcCount, 0, sizeof(fcCount));
		wBad = 0;
		
		// Reset for beginning of page.
		StartPage();
}

/*==============================================================================
This method executes a CODEC conversion.
==============================================================================*/
FC_STATUS CODEC::Convert (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	FC_STATUS ret;

	// A null input buffer is flag for end of page.
	if (!lpbufIn || lpbufIn->dwMetaData == END_OF_PAGE)
	{
	  DEBUGMSG (1,("FAXCODEC: got EOP\r\n"));
		EndPage (lpbufOut);
		StartPage ();
		return FC_INPUT_EMPTY;
	}

  // Ignore input after RTC but before end of page.
	if (cSpurious == RTC_EOL)
	{
	  DEBUGMSG (1,("FAXCODEC: ignoring input after RTC or EOFB\r\n"));
		return FC_INPUT_EMPTY;
  }
  
#ifndef WIN32

	if (t4C.wRet == RET_BEG_OF_PAGE)
	{
		if (nTypeOut == MH_DATA || nTypeOut == MR_DATA)
		{
		  // Start page with EOL.
			if (lpbufOut->EndBuf() - lpbufOut->EndData() < OUTBUF_SLACK)
				return FC_OUTPUT_FULL;
			*((LPWORD) lpbufOut->EndData()) = 0x8000;
			lpbufOut->wLengthData += 2;
		}
	}
	
#endif // WIN32
		
	// Initialize input buffer of consumer.
	t4C.lpbIn = lpbufIn->lpbBegData;
	t4C.cbIn = lpbufIn->wLengthData;

	// Dispatch to 2 or 3 phase conversion.
	if (nTypeOut == LRAW_DATA || nTypeOut == NULL_DATA)
		ret = ConvertToRaw (lpbufIn, lpbufOut);
	else
		ret = ConvertToT4 (lpbufIn, lpbufOut);

	// Adjust input buffer header.
	lpbufIn->lpbBegData = t4C.lpbIn;
	lpbufIn->wLengthData = t4C.cbIn;

	return ret;
}

//==============================================================================
FC_STATUS CODEC::ConvertToRaw (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	LPBYTE lpbOut = lpbufOut->EndData();
	UINT cbOut = (UINT)(lpbufOut->EndBuf() - lpbOut);

	if (t4P.wRet == RET_OUTPUT_FULL)
		goto copy_phase;

	while (1)
	{
		Consumer (&t4C); // generate change vector

		switch (t4C.wRet)
		{		
			case RET_INPUT_EMPTY1:
			case RET_INPUT_EMPTY2:
				return FC_INPUT_EMPTY;

			case RET_SPURIOUS_EOL:
				if (++cSpurious == RTC_EOL)
					return FC_INPUT_EMPTY;
				EndLine();
				continue;

		 	case RET_DECODE_ERR:
		 		break; // handle it later
	 		
			case RET_END_OF_PAGE:
				if (wBad) ResetBad();
				cSpurious = RTC_EOL;
				return FC_INPUT_EMPTY;
				
			case RET_END_OF_LINE:
			  t4P.cbIn = (USHORT)ValidChangeVector ((LPSHORT) lpbChange, (SHORT)xExt);
        if (!t4P.cbIn)
        	t4C.wRet = RET_DECODE_ERR; // consumer lied!
        else
        {
          // Adjust counters.
					fcCount.cTotalGood++;
					if (wBad) ResetBad();
					cSpurious = 0;
				}
				break;
				
			default: DEBUGCHK (FALSE);
		}

    // Handle decode errors.
		if (t4C.wRet == RET_DECODE_ERR)
		{
			if (nTypeIn == MMR_DATA)
	 			return FC_DECODE_ERR;
			wBad++;
			fcCount.cTotalBad++;

#ifdef DEBUG
      _fmemset (lpbLine, 0xFF, cbLine); // emit black line
#endif

			if (f2D)
			{
			  // Replicate change vector.
			  t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbRef, (WORD)xExt);
			  DEBUGCHK (t4P.cbIn);
			  _fmemcpy (lpbChange, lpbRef, t4P.cbIn + CHANGE_SLACK);
			}
		
		  if (nTypeOut == NULL_DATA)
				goto EOL;

			if (!f2D)
				goto copy_phase;
    }

    // Optimize validation.
		if (nTypeOut == NULL_DATA)
			goto EOL;

	  // Run the producer.
		t4P.lpbOut = lpbLine;
		t4P.cbOut = (WORD)cbLine;
		ChangeToRaw (&t4P);

copy_phase:

		if (cbOut < cbLine)
		{
			t4P.wRet = RET_OUTPUT_FULL;
			return FC_OUTPUT_FULL;
		}

		// Append buffered line to output.
		t4P.wRet = RET_END_OF_LINE;
		_fmemcpy (lpbOut, lpbLine, cbLine);
		lpbufOut->wLengthData += (WORD)cbLine;
		lpbOut += cbLine;
		cbOut -= cbLine;

EOL:
		SwapChange ();
		EndLine ();

	} // while (1)

	// C8 thinks we can get here, but I know better.
	DEBUGCHK (FALSE);
	return FC_DECODE_ERR;
}

//==============================================================================
FC_STATUS CODEC::ConvertToT4 (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	LPBYTE lpbBegOut;
	
	t4P.lpbOut = lpbufOut->EndData();
	t4P.cbOut = (WORD)(lpbufOut->EndBuf() - t4P.lpbOut);

	if (t4P.wRet == RET_OUTPUT_FULL)
  	goto producer_phase;

	while (1)  // Loop until input is empty or output is full.
	{
		Consumer (&t4C);

		switch (t4C.wRet)
		{
			case RET_INPUT_EMPTY1:
			case RET_INPUT_EMPTY2:
				return FC_INPUT_EMPTY;

			case RET_SPURIOUS_EOL:
				if (++cSpurious == RTC_EOL)
					return FC_INPUT_EMPTY;
				EndLine();
				continue;

		 	case RET_DECODE_ERR:
		 		break; // handle it later
	 		
			case RET_END_OF_PAGE:
				if (wBad) ResetBad();
				cSpurious = RTC_EOL;
				return FC_INPUT_EMPTY;
				
			case RET_END_OF_LINE:
			  t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbChange, (WORD)xExt);
        if (!t4P.cbIn)
        	t4C.wRet = RET_DECODE_ERR; // consumer lied!
        else
        {
          // Adjust counters.
					fcCount.cTotalGood++;
					if (wBad) ResetBad();
					cSpurious = 0;
				}
				break;
				
			default: DEBUGCHK (FALSE);
		}

		if (t4C.wRet == RET_DECODE_ERR)
		{
			DEBUGCHK (f2D && nTypeIn != LRAW_DATA);
			if (nTypeIn == MMR_DATA)
				return FC_DECODE_ERR;
			wBad++;
			fcCount.cTotalBad++;

#ifdef DEBUG
      {
      	// Substitute all black line.
	     	LPWORD lpwChange = (LPWORD) lpbChange;
			  *lpwChange++ = 0;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = 0xFFFF;
			  *lpwChange++ = 0xFFFF;
			  t4P.cbIn = 4;
			 }
#else
	    // Replicate previous line
	    t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbRef, (WORD)xExt);   
	   	DEBUGCHK (t4P.cbIn);
	    _fmemcpy (lpbChange, lpbRef, t4P.cbIn + CHANGE_SLACK);
#endif

		}

producer_phase:

    lpbBegOut = t4P.lpbOut;
		Producer (&t4P);
		lpbufOut->wLengthData += (WORD)(t4P.lpbOut - lpbBegOut);

		// Check if output is full.
		if (t4P.wRet == RET_OUTPUT_FULL)
			return FC_OUTPUT_FULL;

// EOL:
		SwapChange();
		EndLine ();
		
	} // while (1)

	// C8 thinks we can get here, but I know better.
	DEBUGCHK (FALSE); 
	return FC_DECODE_ERR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\faxcodec\context.hpp ===
/*==============================================================================
This include file defines C++ objects for each type of instance.
==============================================================================*/
#include <ifaxos.h>
#include <faxcodec.h>

#ifdef DEBUG
extern DBGPARAM dpCurSettings;
#endif

//==============================================================================
typedef struct T4STATE   // keep in sync with t4core.asm!
{
	LPBYTE lpbIn;          // read-only input buffer 
	LPBYTE lpbOut;         // output buffer
	WORD wOffset;					 // segment offset of change vector buffer (for consumers)
	WORD cbIn;             // input data size
	WORD cbOut;            // output buffer size
	WORD cbLine;           // width of line in bytes
	WORD wColumn;          // current position in bits
	WORD wColor;           // current color
	WORD wWord;            // current word
	WORD wBit;             // bit modulus
	WORD cbSlack;
	LPBYTE lpbRef;         // read-only reference change vector
	LPBYTE lpbBegRef;      // for client
	WORD wRet;             // return status
	WORD wToggle;
	WORD iKFactor;         // K counter
	WORD wMode;            // for MR
	short a0;	             // for MMR
	DWORD nType;           // type of data being produced/consumed
}
	FAR* LPT4STATE;

// Values for wRet
#define RET_INPUT_EMPTY1   1
#define RET_INPUT_EMPTY2   2
#define RET_OUTPUT_FULL    3
#define RET_END_OF_LINE    4
#define RET_SPURIOUS_EOL   5
#define RET_BEG_OF_PAGE    6
#define RET_END_OF_PAGE		10
#define RET_DECODE_ERR   253

#ifdef __cplusplus
extern "C" { 
#endif

	// ASM methods
	void ChangeToRaw (LPT4STATE);
	void RawToChange (LPT4STATE);
	void ChangeToMH  (LPT4STATE);
	void MHToChange  (LPT4STATE);
	void ChangeToMR  (LPT4STATE);
	void MRToChange  (LPT4STATE);
	void ChangeToMMR (LPT4STATE);
	void MMRToChange (LPT4STATE);

#ifdef __cplusplus
} // extern "C"
#endif

//==============================================================================

#ifdef __cplusplus

typedef class FAR CODEC : FC_PARAM
{
	LPBYTE lpbLine;
	UINT xExt;
	UINT cSpurious;
	LPBYTE lpbChange;
	LPBYTE lpbRef;
	BOOL f2D;
	T4STATE t4C, t4P;
	void (*Consumer)(LPT4STATE);
	void (*Producer)(LPT4STATE);
	WORD wBad;

public:
	FC_COUNT fcCount;

	void Init (LPFC_PARAM, BOOL f2DInit);
	FC_STATUS Convert (LPBUFFER, LPBUFFER);

private:
	void SwapChange (void);
	void ResetBad (void);
	void EndLine (void);
	void StartPage (void);
	void EndPage (LPBUFFER lpbufOut);
	FC_STATUS ConvertToT4  (LPBUFFER lpbufIn, LPBUFFER lpbufOut);
	FC_STATUS ConvertToRaw (LPBUFFER lpbufIn, LPBUFFER lpbufOut);

}
	FAR *LPCODEC;

#endif // C++
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\faxcodec\faxcodec.cpp ===
/*=============================================================================
This code module dispatches external C calls to internal C++ calls.

DATE        NAME      COMMENTS
12-Apr-93   RajeevD   Adapted to C++ from WFW.
==============================================================================*/
#include <ifaxos.h>
#include <faxcodec.h>
#include <memory.h>
#include "context.hpp"

#ifdef DEBUG
#ifdef WIN32
DBGPARAM dpCurSettings = {"AWCODC32"};
#else
DBGPARAM dpCurSettings = {"FAXCODEC"};
#endif
#endif

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

#define CONTEXT_SLACK (RAWBUF_SLACK + 2*CHANGE_SLACK)

//==============================================================================
UINT WINAPI FaxCodecInit (LPVOID lpContext, LPFC_PARAM lpParam)
{
	// Do we need double buffered change vector?
	BOOL f2DInit = 
		  lpParam->nTypeIn  ==  MR_DATA
   || lpParam->nTypeIn  == MMR_DATA
	 || lpParam->nTypeOut ==  MR_DATA 
	 || lpParam->nTypeOut == MMR_DATA;

	// Enforce 64K limit on size of context.
	DEBUGCHK (!(lpParam->cbLine > (f2DInit? 1875U : 3750U)));
	if (lpParam->cbLine > (f2DInit? 1875U : 3750U)) return 0;

	// Enforce nonzero K factor if encoding MR.
	DEBUGCHK (lpParam->nKFactor || lpParam->nTypeOut != MR_DATA);

	if (lpContext)
		((LPCODEC) lpContext)->Init (lpParam, f2DInit);
	return sizeof(CODEC) + CONTEXT_SLACK + (f2DInit ? 33:17) * lpParam->cbLine;
}

//==============================================================================
UINT WINAPI FaxCodecConvert
	(LPVOID lpContext, LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	return ((LPCODEC) lpContext)->Convert (lpbufIn, lpbufOut);
}

//==============================================================================
void WINAPI FaxCodecCount (LPVOID lpContext, LPFC_COUNT lpCountOut)
{
	LPFC_COUNT lpCountIn = &((LPCODEC) lpContext)->fcCount;
	DEBUGMSG(1,("FaxCodecCount: good=%ld bad=%ld\n consec=%ld",
		lpCountIn->cTotalGood, lpCountIn->cTotalBad, lpCountIn->cMaxRunBad));
	_fmemcpy (lpCountOut, lpCountIn, sizeof(FC_COUNT));
	_fmemset (lpCountIn, 0, sizeof(FC_COUNT));
}	

//==============================================================================
void WINAPI InvertBuf (LPBUFFER lpbuf)
{
	LPBYTE lpb = lpbuf->lpbBegData;
	WORD    cb = lpbuf->wLengthData;
	DEBUGCHK (lpbuf && lpbuf->wLengthData % 4 == 0);
	while (cb--) *lpb++ = ~*lpb;
}

//==============================================================================
void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,      // input LRAW scan line
	UINT    cbLine,       // scan line byte width
  LPSHORT lpsChange     // output change vector
)
{
	T4STATE t4;

	t4.lpbIn   = lpbLine;
	t4.lpbOut  = (LPBYTE) lpsChange;
	t4.cbIn    = (WORD)cbLine;
	t4.cbOut   = cbLine * 16;
	t4.cbLine  = (WORD)cbLine;
	t4.wColumn = 0;
	t4.wColor  = 0;
	t4.wWord   = 0;
	t4.wBit    = 0;
	t4.cbSlack = CHANGE_SLACK;
	t4.wRet    = RET_BEG_OF_PAGE;

	RawToChange (&t4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\resexec\bmrotate.c ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/

/*============================================================================
// FILE                     RPBMVER.C
//
// MODULE                   Jumbo Cartridge Code
//
// PURPOSE                  This file contains Vertical Bitmap Code
//
// DESCRIBED IN             This module is described in jumbo .
//
// MNEMONICS                Standard Hungarian
//
// HISTORY
//
// 05/26/92  RodneyK        Original implimentation:
// 05/11/94  RajeevD        Adapted for unified.
//==========================================================================*/

#include <windows.h>
#include "jtypes.h"         /* Jumbo type definitions.                */

/*--------------------------------------------------------------------------*/

USHORT WINAPI RP_BITMAPV
(
   USHORT  usRow,             /* Row to start Bitmap             */
   USHORT  usCol,             /* Column to Start Bitmap          */
   UBYTE   ubTopPadBits,      /* Bits to skip in the data stream */
   USHORT  usHeight,          /* Number of bits to draw          */
   UBYTE FAR  *ubBitmapData,  /* Data to draw                    */
   LPBYTE  lpbOut,            // output band buffer
   UINT    cbLine             // bytes per scan line
)
/*
//
//  PURPOSE               This function draws vertical bitmaps in source
//                        copy mode.
//
//
// ASSUMPTIONS &          The code assumes nothing other than it gets valid
// ASSERTIONS             input data.
//
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
// UNRESOLVED ISSUES      None
//
//
//--------------------------------------------------------------------------*/
{
   UBYTE     *pubDest;
   SHORT     sIterations;
   USHORT    usReturnVal;
   USHORT    us1stByte;
   UBYTE     ubMask;
   UBYTE     ubNotMask;
   UBYTE     ubRotator;
   UBYTE     ubCurByte;


   usReturnVal = (ubTopPadBits + usHeight + 7) >> 3;

   pubDest = (UBYTE *) lpbOut + (usRow * cbLine) + (usCol >> 3);
   ubMask  = 0x80 >> (usCol & 7);
   ubNotMask = ~ubMask;

   ubCurByte = *ubBitmapData++;
   us1stByte = 8-ubTopPadBits;

   ubRotator = 0x80 >> ubTopPadBits;
   switch (us1stByte)
   {
      case 8 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;  
      case 7 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;  
      case 6 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 5 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 4 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 3 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 2 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 1 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               --usHeight;
      default:
               break;
   }

   ubCurByte = *ubBitmapData++;
   sIterations = usHeight >> 3;

   while (--sIterations >= 0)
   {
      /* 1 */
      *pubDest = (0x80 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 2 */
      *pubDest = (0x40 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 3 */
      *pubDest = (0x20 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 4 */
      *pubDest = (0x10 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 5 */
      *pubDest = (0x08 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 6 */
      *pubDest = (0x04 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 7 */
      *pubDest = (0x02 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 8 */
      *pubDest = (0x01 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;

      ubCurByte = *ubBitmapData++;
   }

   ubRotator = 0x80;
   switch (usHeight & 0x07)
   {
      case 7 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 6 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 5 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 4 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 3 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 2 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 1 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      default:
               break;
   }

   return (usReturnVal); /* Return the number of byte in the list */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\win9xupg\awd\faxcodec\t4core.c ===
/* Copyright Microsoft Corp 1993, 1994
 *
 *      t4core.c
 *
 *      MH/MR/MMR/LRAW conversion utilities
 *
 *      Created:        12/06/93
 *      Author:         mikegins
 *      Reviewer:       rajeevd
 */

/* WARNING: This code may not be machine byte order independent, since it uses
   WORD manipulations
 */

/* On Change->X, need to return correct lpbOut */
/* On X->Change, need to return correct lpbOut, lpbIn, cbIn */

/*  Change->LRAW : Takes change vectors, outputs LRAW.
    LRAW->Change : Takes LRAW, outputs change vectors.
    Change->MMR  : Takes change vectors, generates MMR.  On END_OF_PAGE,
	flushes and appends EOFB.
    MMR->Change  : Takes MMR, generates change vectors.  On EOFB, returns
	END_OF_PAGE.
    MH->Change   : Takes change vectors, generates EOL/MH/EOL/MH/etc.  On
	END_OF_PAGE, flushes output.
    Change->MH   : Takes <optional garbage>/EOL/MH/EOL/MH/etc.  Returns EOL
	after MH line decoded.
    MR->Change   : Takes change vectors, generates EOL/MR/EOL/MR/etc.  On
	END_OF_PAGE, flushes output.
    Change->MR   : Takes <optional garbage>/EOL/MR/EOL/MR/etc.  Returns EOL
	after MR line decoded.
 */
#include <ifaxos.h>
#include "context.hpp"

#define  MH_OUTPUT_SLACK 32 // Enough bytes for anything to be output!
#define MMR_OUTPUT_SLACK 32 // Enough bytes for anything to be output!

#define SIZE_MKUP 0x8000
#define SIZE_SPEC 0x4000 /* size -> special instruction */
#define S_ZERO    0x4000
#define S_ERR     0x4001
#define S_EOL     0x4002
#define SIZE_MASK 0x3fff

static WORD dbg=0;

typedef struct
{
	WORD data;
  WORD bitsused;
}
	RUNINFO, FAR *LPRUNINFO;

RUNINFO EOFB = {0x0800,12}; /* Must repeat twice */
RUNINFO PASS = {0x0008,4};
RUNINFO HORIZ = {0x0004,3};

RUNINFO VERT[7] =
{
	{0x0060, 0x07}, {0x0030, 0x06}, {0x0006, 0x03}, {0x0001, 0x01},
  {0x0002, 0x03}, {0x0010, 0x06}, {0x0020, 0x07}
};

RUNINFO WhiteMkup[40] =
{
    {0x001B, 0x05}, {0x0009, 0x05}, {0x003A, 0x06}, {0x0076, 0x07},
    {0x006C, 0x08}, {0x00EC, 0x08}, {0x0026, 0x08}, {0x00A6, 0x08},
    {0x0016, 0x08}, {0x00E6, 0x08}, {0x0066, 0x09}, {0x0166, 0x09},
    {0x0096, 0x09}, {0x0196, 0x09}, {0x0056, 0x09}, {0x0156, 0x09},
    {0x00D6, 0x09}, {0x01D6, 0x09}, {0x0036, 0x09}, {0x0136, 0x09},
    {0x00B6, 0x09}, {0x01B6, 0x09}, {0x0032, 0x09}, {0x0132, 0x09},
    {0x00B2, 0x09}, {0x0006, 0x06}, {0x01B2, 0x09}, {0x0080, 0x0B},
    {0x0180, 0x0B}, {0x0580, 0x0B}, {0x0480, 0x0C}, {0x0C80, 0x0C},
    {0x0280, 0x0C}, {0x0A80, 0x0C}, {0x0680, 0x0C}, {0x0E80, 0x0C},
    {0x0380, 0x0C}, {0x0B80, 0x0C}, {0x0780, 0x0C}, {0x0F80, 0x0C}
};

RUNINFO WhiteTCode[64] =
{
    {0x00AC, 0x08}, {0x0038, 0x06}, {0x000E, 0x04}, {0x0001, 0x04},
    {0x000D, 0x04}, {0x0003, 0x04}, {0x0007, 0x04}, {0x000F, 0x04},
    {0x0019, 0x05}, {0x0005, 0x05}, {0x001C, 0x05}, {0x0002, 0x05},
    {0x0004, 0x06}, {0x0030, 0x06}, {0x000B, 0x06}, {0x002B, 0x06},
    {0x0015, 0x06}, {0x0035, 0x06}, {0x0072, 0x07}, {0x0018, 0x07},
    {0x0008, 0x07}, {0x0074, 0x07}, {0x0060, 0x07}, {0x0010, 0x07},
    {0x000A, 0x07}, {0x006A, 0x07}, {0x0064, 0x07}, {0x0012, 0x07},
    {0x000C, 0x07}, {0x0040, 0x08}, {0x00C0, 0x08}, {0x0058, 0x08},
    {0x00D8, 0x08}, {0x0048, 0x08}, {0x00C8, 0x08}, {0x0028, 0x08},
    {0x00A8, 0x08}, {0x0068, 0x08}, {0x00E8, 0x08}, {0x0014, 0x08},
    {0x0094, 0x08}, {0x0054, 0x08}, {0x00D4, 0x08}, {0x0034, 0x08},
    {0x00B4, 0x08}, {0x0020, 0x08}, {0x00A0, 0x08}, {0x0050, 0x08},
    {0x00D0, 0x08}, {0x004A, 0x08}, {0x00CA, 0x08}, {0x002A, 0x08},
    {0x00AA, 0x08}, {0x0024, 0x08}, {0x00A4, 0x08}, {0x001A, 0x08},
    {0x009A, 0x08}, {0x005A, 0x08}, {0x00DA, 0x08}, {0x0052, 0x08},
    {0x00D2, 0x08}, {0x004C, 0x08}, {0x00CC, 0x08}, {0x002C, 0x08}, 
};

RUNINFO BlackMkup[40] =
{
    {0x03C0, 0x0A}, {0x0130, 0x0C}, {0x0930, 0x0C}, {0x0DA0, 0x0C},
    {0x0CC0, 0x0C}, {0x02C0, 0x0C}, {0x0AC0, 0x0C}, {0x06C0, 0x0D},
    {0x16C0, 0x0D}, {0x0A40, 0x0D}, {0x1A40, 0x0D}, {0x0640, 0x0D},
    {0x1640, 0x0D}, {0x09C0, 0x0D}, {0x19C0, 0x0D}, {0x05C0, 0x0D},
    {0x15C0, 0x0D}, {0x0DC0, 0x0D}, {0x1DC0, 0x0D}, {0x0940, 0x0D},
    {0x1940, 0x0D}, {0x0540, 0x0D}, {0x1540, 0x0D}, {0x0B40, 0x0D},
    {0x1B40, 0x0D}, {0x04C0, 0x0D}, {0x14C0, 0x0D}, {0x0080, 0x0B},
    {0x0180, 0x0B}, {0x0580, 0x0B}, {0x0480, 0x0C}, {0x0C80, 0x0C},
    {0x0280, 0x0C}, {0x0A80, 0x0C}, {0x0680, 0x0C}, {0x0E80, 0x0C},
    {0x0380, 0x0C}, {0x0B80, 0x0C}, {0x0780, 0x0C}, {0x0F80, 0x0C}
};

RUNINFO BlackTCode[64] =
{
    {0x03B0, 0x0A}, {0x0002, 0x03}, {0x0003, 0x02}, {0x0001, 0x02},
    {0x0006, 0x03}, {0x000C, 0x04}, {0x0004, 0x04}, {0x0018, 0x05},
    {0x0028, 0x06}, {0x0008, 0x06}, {0x0010, 0x07}, {0x0050, 0x07},
    {0x0070, 0x07}, {0x0020, 0x08}, {0x00E0, 0x08}, {0x0030, 0x09},
    {0x03A0, 0x0A}, {0x0060, 0x0A}, {0x0040, 0x0A}, {0x0730, 0x0B},
    {0x00B0, 0x0B}, {0x01B0, 0x0B}, {0x0760, 0x0B}, {0x00A0, 0x0B},
    {0x0740, 0x0B}, {0x00C0, 0x0B}, {0x0530, 0x0C}, {0x0D30, 0x0C},
    {0x0330, 0x0C}, {0x0B30, 0x0C}, {0x0160, 0x0C}, {0x0960, 0x0C},
    {0x0560, 0x0C}, {0x0D60, 0x0C}, {0x04B0, 0x0C}, {0x0CB0, 0x0C},
    {0x02B0, 0x0C}, {0x0AB0, 0x0C}, {0x06B0, 0x0C}, {0x0EB0, 0x0C},
    {0x0360, 0x0C}, {0x0B60, 0x0C}, {0x05B0, 0x0C}, {0x0DB0, 0x0C},
    {0x02A0, 0x0C}, {0x0AA0, 0x0C}, {0x06A0, 0x0C}, {0x0EA0, 0x0C},
    {0x0260, 0x0C}, {0x0A60, 0x0C}, {0x04A0, 0x0C}, {0x0CA0, 0x0C},
    {0x0240, 0x0C}, {0x0EC0, 0x0C}, {0x01C0, 0x0C}, {0x0E40, 0x0C},
    {0x0140, 0x0C}, {0x01A0, 0x0C}, {0x09A0, 0x0C}, {0x0D40, 0x0C},
    {0x0340, 0x0C}, {0x05A0, 0x0C}, {0x0660, 0x0C}, {0x0E60, 0x0C}
};

// Common States
#define W    0
#define W0  50
#define W1  51
#define B  108
#define B0 109
#define B1 110

#define M SIZE_MKUP

typedef struct
{
	WORD nextstate;
  WORD size;
}
	nextinfo_t;

typedef struct
{
	nextinfo_t nextinf[4];
}
	State;

State MHStates[229] = {
/*   0 : W               */ {  1,     0,   2,     0,   3,     0,   4,     0}, 
/*   1 : W00             */ {  5,     0,   6,     0,   7,     0,   8,     0}, 
/*   2 : W10             */ {  B,     3,   9,     0,  10,     0,   B,     4}, 
/*   3 : W01             */ { 11,     0,  12,     0,  13,     0,   B,     2}, 
/*   4 : W11             */ {  B,     5,   B,     6,  14,     0,   B,     7}, 
/*   5 : W0000           */ { 15,     0,  16,     0,  17,     0,   B,    13}, 
/*   6 : W0010           */ {  B,    12,  18,     0,  19,     0,  20,     0}, 
/*   7 : W0001           */ { 21,     0,  22,     0,  23,     0,   B,     1}, 
/*   8 : W0011           */ { 24,     0,  B0,    10,  25,     0,  B1,    10}, 
/*   9 : W1010           */ { B0,     9,   B,    16,  B1,     9,   B,    17}, 
/*  10 : W1001           */ { W0, M|128,  B0,     8,  W1, M|128,  B1,     8}, 
/*  11 : W0100           */ { B0,    11,  26,     0,  B1,    11,  27,     0}, 
/*  12 : W0110           */ {  W,M|1664,  28,     0,  29,     0,  30,     0}, 
/*  13 : W0101           */ { 31,     W,  32,     0,  33,     0,   W, M|192}, 
/*  14 : W1101           */ {  B,    14,  W0,  M|64,   B,    15,  W1,  M|64}, 
/*  15 : W000000         */ { 34,     0,   B,    29,  35,     0,   B,    30}, 
/*  16 : W000010         */ { B0,    23,   B,    47,  B1,    23,   B,    48}, 
/*  17 : W000001         */ {  B,    45,  B0,    22,   B,    46,  B1,    22}, 
/*  18 : W001010         */ {  B,    39,   B,    41,   B,    40,   B,    42}, 
/*  19 : W001001         */ {  B,    53,  B0,    26,   B,    54,  B1,    26}, 
/*  20 : W001011         */ {  B,    43,  B0,    21,   B,    44,  B1,    21}, 
/*  21 : W000100         */ { B0,    20,   B,    33,  B1,    20,   B,    34}, 
/*  22 : W000110         */ { B0,    19,   B,    31,  B1,    19,   B,    32}, 
/*  23 : W000101         */ {  B,    35,   B,    37,   B,    36,   B,    38}, 
/*  24 : W001100         */ { B0,    28,   B,    61,  B1,    28,   B,    62}, 
/*  25 : W001101         */ {  B,    63,   W, M|320,   B,S_ZERO,   W, M|384}, 
/*  26 : W010010         */ { B0,    27,   B,    59,  B1,    27,   B,    60}, 
/*  27 : W010011         */ { 36,     0,  B0,    18,  37,     0,  B1,    18}, 
/*  28 : W011010         */ {  W, M|576,  38,     0,  39,     0,  40,     0}, 
/*  29 : W011001         */ {  W, M|448,  41,     0,   W, M|512,   W, M|640}, 
/*  30 : W011011         */ { 42,     0,  W0, M|256,  43,     0,  W1, M|256}, 
/*  31 : W010100         */ { B0,    24,   B,    49,  B1,    24,   B,    50}, 
/*  32 : W010110         */ {  B,    55,   B,    57,   B,    56,   B,    58}, 
/*  33 : W010101         */ {  B,    51,  B0,    25,   B,    52,  B1,    25}, 
/*  34 : W00000000       */ { 44,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/*  35 : W00000001       */ { 46,     0,  47,     0,  48,     0,  49,     0}, 
/*  36 : W01001100       */ { W0,M|1472,  W0,M|1536,  W1,M|1472,  W1,M|1536}, 
/*  37 : W01001101       */ { W0,M|1600,  W0,M|1728,  W1,M|1600,  W1,M|1728}, 
/*  38 : W01101010       */ { W0, M|960,  W0,M|1024,  W1, M|960,  W1,M|1024}, 
/*  39 : W01101001       */ { W0, M|832,  W0, M|896,  W1, M|832,  W1, M|896}, 
/*  40 : W01101011       */ { W0,M|1088,  W0,M|1152,  W1,M|1088,  W1,M|1152}, 
/*  41 : W01100110       */ { W0, M|704,  W0, M|768,  W1, M|704,  W1, M|768}, 
/*  42 : W01101100       */ { W0,M|1216,  W0,M|1280,  W1,M|1216,  W1,M|1280}, 
/*  43 : W01101101       */ { W0,M|1344,  W0,M|1408,  W1,M|1344,  W1,M|1408}, 
/*  44 : W0000000000     */ { 45,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/*  45 : W00000000000    */ { 45,     0,   W, S_EOL,   W, S_EOL,   W, S_EOL}, 
/*  46 : W0000000100     */ { W0,M|1792,   W,M|1984,  W1,M|1792,   W,M|2048}, 
/*  47 : W0000000110     */ { W0,M|1856,  W0,M|1920,  W1,M|1856,  W1,M|1920}, 
/*  48 : W0000000101     */ {  W,M|2112,   W,M|2240,   W,M|2176,   W,M|2304}, 
/*  49 : W0000000111     */ {  W,M|2368,   W,M|2496,   W,M|2432,   W,M|2560}, 
/*  50 : W0              */ { 52,     0,  53,     0,  54,     0,  55,     0}, 
/*  51 : W1              */ { 56,     0,  57,     0,  58,     0,  59,     0}, 
/*  52 : W000            */ { 60,     0,  61,     0,  62,     0,  63,     0}, 
/*  53 : W010            */ {  B,    11,  64,     0,  65,     0,  66,     0}, 
/*  54 : W001            */ { 67,     0,  68,     0,  69,     0,   B,    10}, 
/*  55 : W011            */ { 70,     0,  B0,     2,  71,     0,  B1,     2}, 
/*  56 : W100            */ { B0,     3,   W, M|128,  B1,     3,   B,     8}, 
/*  57 : W110            */ { B0,     5,  72,     0,  B1,     5,   W,  M|64}, 
/*  58 : W101            */ {  B,     9,  B0,     4,  73,     0,  B1,     4}, 
/*  59 : W111            */ { B0,     6,  B0,     7,  B1,     6,  B1,     7}, 
/*  60 : W00000          */ { 74,     0,  75,     0,  76,     0,   B,    22}, 
/*  61 : W00010          */ {  B,    20,  77,     0,  78,     0,  79,     0}, 
/*  62 : W00001          */ {  B,    23,  B0,    13,  80,     0,  B1,    13}, 
/*  63 : W00011          */ {  B,    19,  B0,     1,  81,     0,  B1,     1}, 
/*  64 : W01010          */ {  B,    24,  82,     0,  83,     0,   B,    25}, 
/*  65 : W01001          */ {  B,    27,  84,     0,  85,     0,   B,    18}, 
/*  66 : W01011          */ { 86,     0,  W0, M|192,  87,     0,  W1, M|192}, 
/*  67 : W00100          */ { B0,    12,  88,     0,  B1,    12,   B,    26}, 
/*  68 : W00110          */ {  B,    28,  89,     0,  90,     0,  91,     0}, 
/*  69 : W00101          */ { 92,     0,  93,     0,  94,     0,   B,    21}, 
/*  70 : W01100          */ { W0,M|1664,  95,     0,  W1,M|1664,  96,     0}, 
/*  71 : W01101          */ { 97,     0,  98,     0,  99,     0,   0, M|256}, 
/*  72 : W11010          */ { B0,    14,  B0,    15,  B1,    14,  B1,    15}, 
/*  73 : W10101          */ { B0,    16,  B0,    17,  B1,    16,  B1,    17}, 
/*  74 : W0000000        */ {100,     0, 101,     0, 216, S_ERR, 102,     0}, 
/*  75 : W0000010        */ { B0,    45,  B0,    46,  B1,    45,  B1,    46}, 
/*  76 : W0000001        */ { B0,    29,  B0,    30,  B1,    29,  B1,    30}, 
/*  77 : W0001010        */ { B0,    35,  B0,    36,  B1,    35,  B1,    36}, 
/*  78 : W0001001        */ { B0,    33,  B0,    34,  B1,    33,  B1,    34}, 
/*  79 : W0001011        */ { B0,    37,  B0,    38,  B1,    37,  B1,    38}, 
/*  80 : W0000101        */ { B0,    47,  B0,    48,  B1,    47,  B1,    48}, 
/*  81 : W0001101        */ { B0,    31,  B0,    32,  B1,    31,  B1,    32}, 
/*  82 : W0101010        */ { B0,    51,  B0,    52,  B1,    W1,  B1,    52}, 
/*  83 : W0101001        */ { B0,    49,  B0,    W0,  B1,    49,  B1,    W0}, 
/*  84 : W0100110        */ {  W,M|1472,   W,M|1600,   W,M|1536,   W,M|1728}, 
/*  85 : W0100101        */ { B0,    59,  B0,    60,  B1,    59,  B1,    60}, 
/*  86 : W0101100        */ { B0,    55,  B0,    56,  B1,    55,  B1,    56}, 
/*  87 : W0101101        */ { B0,    57,  B0,    58,  B1,    57,  B1,    58}, 
/*  88 : W0010010        */ { B0,    53,  B0,    54,  B1,    53,  B1,    54}, 
/*  89 : W0011010        */ { B0,    63,  B0,S_ZERO,  B1,    63,  B1,S_ZERO}, 
/*  90 : W0011001        */ { B0,    61,  B0,    62,  B1,    61,  B1,    62}, 
/*  91 : W0011011        */ { W0, M|320,  W0, M|384,  W1, M|320,  W1, M|384}, 
/*  92 : W0010100        */ { B0,    39,  B0,    40,  B1,    39,  B1,    40}, 
/*  93 : W0010110        */ { B0,    43,  B0,    44,  B1,    43,  B1,    44}, 
/*  94 : W0010101        */ { B0,    41,  B0,    42,  B1,    41,  B1,    42}, 
/*  95 : W0110010        */ { W0, M|448,  W0, M|512,  W1, M|448,  W1, M|512}, 
/*  96 : W0110011        */ {  W, M|704,  W0, M|640,   W, M|768,  W1, M|640}, 
/*  97 : W0110100        */ { W0, M|576,   W, M|832,  W1, M|576,   W, M|896}, 
/*  98 : W0110110        */ {  W,M|1216,   W,M|1344,   W,M|1280,   W,M|1408}, 
/*  99 : W0110101        */ {  W, M|960,   W,M|1088,   W,M|1024,   W,M|1152}, 
/* 100 : W000000000      */ { 45,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 101 : W000000010      */ {  W,M|1792, 103,     0, 104,     0, 105,     0}, 
/* 102 : W000000011      */ {  W,M|1856, 106,     0,   W,M|1920, 107,     0}, 
/* 103 : W00000001010    */ { W0,M|2112,  W0,M|2176,  W1,M|2112,  W1,M|2176}, 
/* 104 : W00000001001    */ { W0,M|1984,  W0,M|2048,  W1,M|1984,  W1,M|2048}, 
/* 105 : W00000001011    */ { W0,M|2240,  W0,M|2304,  W1,M|2240,  W1,M|2304}, 
/* 106 : W00000001110    */ { W0,M|2368,  W0,M|2432,  W1,M|2368,  W1,M|2432}, 
/* 107 : W00000001111    */ { W0,M|2496,  W0,M|2560,  W1,M|2496,  W1,M|2560}, 
/* 108 : B               */ {111,     0,   W,     3, 112,     0,   W,     2}, 
/* 109 : B0              */ {113,     0,   W,     1, 114,     0,   W,     4}, 
/* 110 : B1              */ { W0,     3,  W0,     2,  W1,     3,  W1,     2}, 
/* 111 : B00             */ {115,     0,   W,     6, 116,     0,   W,     5}, 
/* 112 : B01             */ { W0,     1,  W0,     4,  W1,     1,  W1,     4}, 
/* 113 : B000            */ {117,     0, 118,     0, 119,     0,   W,     7}, 
/* 114 : B001            */ { W0,     6,  W0,     5,  W1,     6,  W1,     5}, 
/* 115 : B0000           */ {120,     0, 121,     0, 122,     0, 123,     0}, 
/* 116 : B0001           */ {  W,     9,  W0,     7,   W,     8,  W1,     7}, 
/* 117 : B00000          */ {124,     0, 125,     0, 126,     0, 127,     0}, 
/* 118 : B00010          */ { W0,     9,  W0,     8,  W1,     9,  W1,     8}, 
/* 119 : B00001          */ {  W,    10, 128,     0,   W,    11,   W,    12}, 
/* 120 : B000000         */ {129,     0, 130,     0, 131,     0, 132,     0}, 
/* 121 : B000010         */ { W0,    10,  W0,    11,  W1,    10,  W1,    11}, 
/* 122 : B000001         */ {  W,    13, 133,     0, 134,     0,   W,    14}, 
/* 123 : B000011         */ {135,     0,  W0,    12, 136,     0,  W1,    12}, 
/* 124 : B0000000        */ {137,     0, 138,     0, 216, S_ERR, 139,     0}, 
/* 125 : B0000010        */ { W0,    13, 140,     0,  W1,    13, 141,     0}, 
/* 126 : B0000001        */ {142,     0, 143,     0, 144,     0, 145,     0}, 
/* 127 : B0000011        */ {146,     0,  W0,    14, 147,     0,  W1,    14}, 
/* 128 : B0000110        */ {  W,    15, 148,     0, 149,     0, 150,     0}, 
/* 129 : B00000000       */ {151,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 130 : B00000010       */ {  W,    18, 152,     0, 153,     0, 154,     0}, 
/* 131 : B00000001       */ {155,     0, 156,     0, 157,     0, 158,     0}, 
/* 132 : B00000011       */ {159,     0, 160,     0, 161,     0,   B,  M|64}, 
/* 133 : B00000110       */ {  W,    17, 162,     0, 163,     0, 164,     0}, 
/* 134 : B00000101       */ {165,     0, 166,     0, 167,     0,   W,    16}, 
/* 135 : B00001100       */ { W0,    15, 168,     0,  W1,    15, 169,     0},  
/* 136 : B00001101       */ {170,     0, 171,     0, 172,     0,   W,S_ZERO}, 
/* 137 : B000000000      */ {173,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 138 : B000000010      */ {  B,M|1792, 174,     0, 175,     0, 176,     0}, 
/* 139 : B000000011      */ {  B,M|1856, 177,     0,   B,M|1920, 178,     0}, 
/* 140 : B000001010      */ {  W,    23, 179,     0, 180,     0, 181,     0}, 
/* 141 : B000001011      */ {182,     0,  W0,    16, 183,     0,  W1,    16}, 
/* 142 : B000000100      */ { W0,    18, 184,     0,  W1,    18, 185,     0}, 
/* 143 : B000000110      */ {  W,    25, 186,     0, 187,     0, 188,     0}, 
/* 144 : B000000101      */ {189,     0, 190,     0, 191,     0,   W,    24}, 
/* 145 : B000000111      */ {192,     0,  B0,  M|64, 193,     0,  B1,  M|64}, 
/* 146 : B000001100      */ { W0,    17, 194,     0,  W1,    17, 195,     0}, 
/* 147 : B000001101      */ {196,     0, 197,     0, 198,     0,   W,    22}, 
/* 148 : B000011010      */ {  W,    20, 199,     0, 200,     0, 201,     0}, 
/* 149 : B000011001      */ {202,     0, 203,     0, 204,     0,   W,    19}, 
/* 150 : B000011011      */ {  W,    21,  W0,S_ZERO, 205,     0,  W1,S_ZERO}, 
/* 151 : B0000000000     */ {173,     0, 216, S_ERR,   W, S_EOL, 216, S_ERR}, 
/* 152 : B0000001010     */ {  W,    56, 206,     0, 207,     0,   W,    59}, 
/* 153 : B0000001001     */ {  W,    52, 208,     0, 209,     0,   W,    55}, 
/* 154 : B0000001011     */ {  W,    60,  W0,    24, 210,     0,  W1,    24}, 
/* 155 : B0000000100     */ { B0,M|1792,   B,M|1984,  B1,M|1792,   B,M|2048}, 
/* 156 : B0000000110     */ { B0,M|1856,  B0,M|1920,  B1,M|1856,  B1,M|1920}, 
/* 157 : B0000000101     */ {  B,M|2112,   B,M|2240,   B,M|2176,   B,M|2304}, 
/* 158 : B0000000111     */ {  B,M|2368,   B,M|2496,   B,M|2432,   B,M|2560}, 
/* 159 : B0000001100     */ { W0,    25, 211,     0,  W1,    25,   B, M|320}, 
/* 160 : B0000001110     */ {  W,    54, 212,     0, 213,     0, 214,     0}, 
/* 161 : B0000001101     */ {  B, M|384, 215,     0,   B, M|448,   W,    53}, 
/* 162 : B0000011010     */ {  W,    30,   W,    32,   W,    31,   W,    33}, 
/* 163 : B0000011001     */ {  W,    48,   W,    62,   W,    49,   W,    63}, 
/* 164 : B0000011011     */ {  W,    40,  W0,    22,   W,    41,  W1,    22}, 
/* 165 : B0000010100     */ { W0,    23,   W,    W0,  51,    23,   W,    51}, 
/* 166 : B0000010110     */ {  W,    57,   W,    61,   W,    58,   B, M|256}, 
/* 167 : B0000010101     */ {  W,    44,   W,    46,   W,    45,   W,    47}, 
/* 168 : B0000110010     */ {  B, M|128,   W,    26,   B, M|192,   W,    27}, 
/* 169 : B0000110011     */ {  W,    28,  W0,    19,   W,    29,  W1,    19}, 
/* 170 : B0000110100     */ { W0,    20,   W,    34,  W1,    20,   W,    35}, 
/* 171 : B0000110110     */ { W0,    21,   W,    42,  W1,    21,   W,    43}, 
/* 172 : B0000110101     */ {  W,    36,   W,    38,   W,    37,   W,    39}, 
/* 173 : B00000000000    */ {173,     0,   W, S_EOL,   W, S_EOL,   W, S_EOL}, 
/* 174 : B00000001010    */ { B0,M|2112,  B0,M|2176,  B1,M|2112,  B1,M|2176}, 
/* 175 : B00000001001    */ { B0,M|1984,  B0,M|2048,  B1,M|1984,  B1,M|2048}, 
/* 176 : B00000001011    */ { B0,M|2240,  B0,M|2304,  B1,M|2240,  B1,M|2304}, 
/* 177 : B00000001110    */ { B0,M|2368,  B0,M|2432,  B1,M|2368,  B1,M|2432}, 
/* 178 : B00000001111    */ { B0,M|2496,  B0,M|2560,  B1,M|2496,  B1,M|2560}, 
/* 179 : B00000101010    */ { W0,    44,  W0,    45,  W1,    44,  W1,    45}, 
/* 180 : B00000101001    */ { W0,    50,  W0,    51,  W1,    50,  W1,    51}, 
/* 181 : B00000101011    */ { W0,    46,  W0,    47,  W1,    46,  W1,    47}, 
/* 182 : B00000101100    */ { W0,    57,  W0,    58,  W1,    57,  W1,    58}, 
/* 183 : B00000101101    */ { W0,    61,  B0, M|256,  W1,    61,  B1, M|256}, 
/* 184 : B00000010010    */ { W0,    52,   B, M|640,  W1,    52,   B, M|704}, 
/* 185 : B00000010011    */ {  B, M|768,  W0,    55,   B, M|832,  W1,    55}, 
/* 186 : B00000011010    */ { B0, M|384,  B0, M|448,  B1, M|384,  B1, M|448}, 
/* 187 : B00000011001    */ {  B,M|1664,  B0, M|320,   B,M|1728,  B1, M|320}, 
/* 188 : B00000011011    */ {  B, M|512,  W0,    53,   B, M|576,  W1,    53}, 
/* 189 : B00000010100    */ { W0,    56,   B,M|1280,  W1,    56,   B,M|1344}, 
/* 190 : B00000010110    */ { W0,    60,   B,M|1536,  W1,    60,   B,M|1600}, 
/* 191 : B00000010101    */ {  B,M|1408,  W0,    59,   B,M|1472,  W1,    59}, 
/* 192 : B00000011100    */ { W0,    54,   B, M|896,  W1,    54,   B, M|960}, 
/* 193 : B00000011101    */ {  B,M|1024,   B,M|1152,   B,M|1088,   B,M|1216}, 
/* 194 : B00000110010    */ { W0,    48,  W0,    49,  W1,    48,  W1,    49}, 
/* 195 : B00000110011    */ { W0,    62,  W0,    63,  W1,    62,  W1,    63}, 
/* 196 : B00000110100    */ { W0,    30,  W0,    31,  W1,    30,  W1,    31}, 
/* 197 : B00000110110    */ { W0,    40,  W0,    41,  W1,    40,  W1,    41}, 
/* 198 : B00000110101    */ { W0,    32,  W0,    33,  W1,    32,  W1,    33}, 
/* 199 : B00001101010    */ { W0,    36,  W0,    37,  W1,    36,  W1,    37}, 
/* 200 : B00001101001    */ { W0,    34,  W0,    35,  W1,    34,  W1,    35}, 
/* 201 : B00001101011    */ { W0,    38,  W0,    39,  W1,    38,  W1,    39}, 
/* 202 : B00001100100    */ { B0, M|128,  B0, M|192,  B1, M|128,  B1, M|192}, 
/* 203 : B00001100110    */ { W0,    28,  W0,    29,  W1,    28,  W1,    29}, 
/* 204 : B00001100101    */ { W0,    26,  W0,    27,  W1,    26,  W1,    27}, 
/* 205 : B00001101101    */ { W0,    42,  W0,    43,  W1,    42,  W1,    43}, 
/* 206 : B000000101010   */ { B0,M|1408,  B0,M|1472,  B1,M|1408,  B1,M|1472}, 
/* 207 : B000000101001   */ { B0,M|1280,  B0,M|1344,  B1,M|1280,  B1,M|1344}, 
/* 208 : B000000100110   */ { B0, M|768,  B0, M|832,  B1, M|768,  B1, M|832}, 
/* 209 : B000000100101   */ { B0, M|640,  B0, M|704,  B1, M|640,  B1, M|704}, 
/* 210 : B000000101101   */ { B0,M|1536,  B0,M|1600,  B1,M|1536,  B1,M|1600}, 
/* 211 : B000000110010   */ { B0,M|1664,  B0,M|1728,  B1,M|1664,  B1,M|1728}, 
/* 212 : B000000111010   */ { B0,M|1024,  B0,M|1088,  B1,M|1024,  B1,M|1088}, 
/* 213 : B000000111001   */ { B0, M|896,  B0, M|960,  B1, M|896,  B1, M|960}, 
/* 214 : B000000111011   */ { B0,M|1152,  B0,M|1216,  B1,M|1152,  B1,M|1216}, 
/* 215 : B000000110110   */ { B0, M|512,  B0, M|576,  B1, M|512,  B1, M|576}, 
/* 216 : error state     */ {216,     0, 216,     0, 216,     0, 216,     0}, 
/* 217 : KillEol (0)     */ {219,     0, 218,     0, 217,     0, 217,     0}, 
/* 218 : KillEol (1)     */ {220,     0, 218,     0, 217,     0, 217,     0}, 
/* 219 : KillEol (2)     */ {221,     0, 218,     0, 217,     0, 217,     0}, 
/* 220 : KillEol (3)     */ {222,     0, 218,     0, 217,     0, 217,     0}, 
/* 221 : KillEol (4)     */ {223,     0, 218,     0, 217,     0, 217,     0}, 
/* 222 : KillEol (5)     */ {224,     0, 218,     0, 217,     0, 217,     0}, 
/* 223 : KillEol (6)     */ {225,     0, 218,     0, 217,     0, 217,     0}, 
/* 224 : KillEol (7)     */ {226,     0, 218,     0, 217,     0, 217,     0}, 
/* 225 : KillEol (8)     */ {227,     0, 218,     0, 217,     0, 217,     0}, 
/* 226 : KillEol (9)     */ {228,     0, 218,     0, 217,     0, 217,     0}, 
/* 227 : KillEol (10)    */ {228,     0, 218,     0,   0,     0, 217,     0}, 
/* 228 : KillEol (11)    */ {228,     0,  W0,     0,   0,     0,  W1,     0}
};

#define HIGHSET 0xff00
#define LOWSET  0x00ff
#define HIGHSHIFT 8
#define P       0x0100
#define VL3     0x0200
#define VL2     0x0300
#define VL1     0x0400
#define V0      0x0500
#define VR1     0x0600
#define VR2     0x0700
#define VR3     0x0800
#define H       0x0900
#define H0      0x0a00
#define H1      0x0b00
#define EOFB6   0x0c00
#define EOFB7   0x0d00
    
#define ERR     0x0f00

#define VL3V0   (VL3|(V0>>HIGHSHIFT))
#define VL2V0   (VL2|(V0>>HIGHSHIFT))
#define VL1V0   (VL1|(V0>>HIGHSHIFT))
#define V0V0    (V0|(V0>