*******************************/


HRESULT CCoreServices  :: DeliverEvent (

	ULONG a_EventClassID,
	LPCWSTR a_StrParam1,
	LPCWSTR a_StrParam2,
	ULONG a_NumericValue
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: StopEventDelivery ()
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: StartEventDelivery ()
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: UpdateCounter (

	ULONG a_ClassID,
	LPCWSTR a_InstanceName,
	ULONG a_CounterID,
	ULONG a_Param1,
	ULONG a_Flags,
	unsigned __int64 a_Param2
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: GetSystemObjects ( 

    ULONG a_Flags,
    ULONG *a_ArraySize,
    _IWmiObject **a_Objects

)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: GetSystemClass (

    LPCWSTR a_ClassName,
    _IWmiObject **a_Class

)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: GetConfigObject ( 

    ULONG a_ID,
    _IWmiObject **a_CfgObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: RegisterWriteHook ( 

	ULONG a_Flags ,
	_IWmiCoreWriteHook *a_Hook
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: UnregisterWriteHook (

	_IWmiCoreWriteHook *a_Hook
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: CreateCache (

    ULONG a_Flags ,
    _IWmiCache **a_Cache

)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: CreateFinalizer (

	ULONG a_Flags,
	_IWmiFinalizer **a_Finalizer	
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: CreatePathParser (
   
    ULONG a_Flags,
    IWbemPath **a_Parser
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: CreateQueryParser (

	ULONG a_Flags,
    _IWmiQuery **a_Query
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\include\cthread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _CThread_H
#define _CThread_H

#include <Thread.h>

class ClientThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ClientThread ( 

		WmiAllocator & a_Allocator
	) ;

    ~ClientThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

};

#endif // _CThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <objbase.h>
#include <initguid.h>

extern "C"
{
#include <windows.h>
#include <winnls.h>
#include <stdio.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\task.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <wmiutils.h>

#include "Globals.h"
#include "Task.h"

#if 1
#define SAMPLE_NAMESPACE L"Root\\Cimv2"
//#define SAMPLE_CLASS L"RecursiveSample"
//#define SAMPLE_CLASS L"Sample"
#define SAMPLE_CLASS L"Win32_Process"
#else
#define SAMPLE_NAMESPACE L"Root\\Default"
#define SAMPLE_CLASS L"Sample"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: Task_Execute (

	WmiAllocator &a_Allocator ,
	ULONG a_Count ,
	_IWmiProvSS *a_SubSystem ,
	IWbemServices *a_WmiService 

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_SubSystem ( a_SubSystem ) ,
	m_WmiService ( a_WmiService ) ,
	m_Count ( a_Count ) ,
	m_Result ( S_OK ) 
{
	if ( m_SubSystem )
	{
		m_SubSystem->AddRef () ;
	}

	if ( m_WmiService )
	{
		m_WmiService->AddRef () ;
	}

}

Task_Execute :: ~Task_Execute ()
{
	if ( m_SubSystem ) 
	{
		m_SubSystem->Release () ;
	}

	if ( m_WmiService ) 
	{
		m_WmiService->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: GetClass (

	IWbemServices *a_Repository , 
	BSTR a_Class , 
	IWbemClassObject *&a_ClassObject
)
{

	GetAllocator ().Validate () ;

	HRESULT t_Result = S_OK ;

	LPWSTR t_ObjectPath = NULL ;

	t_Result = WmiHelper :: ConcatenateStrings ( 

		4 , 
		& t_ObjectPath , 
		L"\\\\.\\" ,
		SAMPLE_NAMESPACE,
		":" , 
		a_Class
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		GetAllocator ().Validate () ;

		t_Result = a_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			NULL , 
			& a_ClassObject , 
			NULL 
		) ;

		GetAllocator ().Validate () ;

		SysFreeString ( t_ObjectPath ) ;
	
		GetAllocator ().Validate () ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: GetInstance (

	IWbemServices *a_Repository , 
	BSTR a_Instance , 
	IWbemClassObject *&a_ClassObject
)
{

	GetAllocator ().Validate () ;

	HRESULT t_Result = S_OK ;

	LPWSTR t_ObjectPath = NULL ;

	t_Result = WmiHelper :: ConcatenateStrings ( 

		4 , 
		& t_ObjectPath , 
		L"\\\\.\\" ,
		SAMPLE_NAMESPACE,
		":" , 
		a_Instance
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		GetAllocator ().Validate () ;

		t_Result = a_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			NULL , 
			& a_ClassObject , 
			NULL 
		) ;

		GetAllocator ().Validate () ;

		SysFreeString ( t_ObjectPath ) ;
	
		GetAllocator ().Validate () ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Execute (

	IWbemServices *a_ProviderService ,
	BSTR a_Class
)
{

	HRESULT t_Result = S_OK ;

	CProviderSink *t_ProviderSink = new CProviderSink ;
	if ( t_ProviderSink )
	{
		t_ProviderSink->AddRef () ;

#if 1
		t_Result = a_ProviderService->CreateInstanceEnumAsync (

			a_Class ,
			0 ,
			NULL ,
			t_ProviderSink
		) ;
#else
		BSTR t_Query = SysAllocString ( L"Select * from win32_process" ) ;
		BSTR t_QueryLanguage = SysAllocString ( L"WQL" ) ;

		t_Result = a_ProviderService->ExecQueryAsync (

			t_QueryLanguage ,
			t_Query ,
			0 ,
			NULL ,
			t_ProviderSink
		) ;

		SysFreeString ( t_Query ) ;
		SysFreeString ( t_QueryLanguage ) ;

#endif

		if ( SUCCEEDED ( t_Result ) )
		{
			t_ProviderSink->Wait () ;
			if ( FAILED( t_ProviderSink->GetResult () ) )
			{
				OutputDebugString ( L"FAILED" ) ;
			}
		}

		t_ProviderSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: ExecutePropertyProvider (

	IWbemServices *a_WmiService , 
	_IWmiDynamicPropertyResolver *a_DynamicResolver ,
	BSTR a_Class ,
	BSTR a_Instance
)
{
	IWbemClassObject *t_Class = NULL ;

	HRESULT t_Result = GetClass ( 

		a_WmiService ,
		a_Class , 
		t_Class 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Instance = NULL ;

		HRESULT t_Result = GetInstance ( 

			a_WmiService ,
			a_Instance , 
			t_Instance
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = a_DynamicResolver->Read (

				NULL ,
				t_Class ,
				& t_Instance
			) ;

			t_Instance->Release () ;
		}

		t_Class->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: InitializeProvider (

	IWbemServices *a_WmiService , 
	_IWmiProviderFactory *a_Factory ,
	BSTR a_Class ,
	IWbemServices *&a_ProviderService
)
{
	a_ProviderService = NULL ;

	IWbemClassObject *t_Class = NULL ;

	HRESULT t_Result = GetClass ( 

		a_WmiService ,
		a_Class , 
		t_Class 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemContext *t_Context = NULL ;
		t_Result = CoCreateInstance (

			CLSID_WbemContext ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
			IID_IWbemContext ,
			( void ** )  & t_Context
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = a_Factory->GetInstanceProvider ( 

				0 ,
				t_Context ,
				GUID_NULL ,
				NULL ,
				NULL ,
				L"//./root/cimv2" ,
				t_Class ,
				IID_IWbemServices , 
				( void ** ) & a_ProviderService 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			}

			t_Context->Release () ;
		}

		t_Class->Release () ;

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: InitializeDynamicResolver (

	IWbemServices *a_WmiService , 
	_IWmiProviderFactory *a_Factory ,
	_IWmiDynamicPropertyResolver *&a_DynamicResolver
)
{
	a_DynamicResolver = NULL ;

	HRESULT t_Result = a_Factory->GetDynamicPropertyResolver ( 

		0 ,
		NULL ,
		NULL ,
		NULL ,
		IID__IWmiDynamicPropertyResolver , 
		( void ** ) & a_DynamicResolver 
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: InitializeFactory (	

	IWbemServices *a_WmiService , 
	_IWmiProvSS *a_SubSystem , 
	_IWmiProviderFactory *& a_Factory
) 
{
	a_Factory = NULL ;

	HRESULT t_Result = a_SubSystem->Create (
						
		0 ,
		NULL ,
		L"//./root/cimv2" ,
		IID__IWmiProviderFactory , 
		( void ** ) & a_Factory
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function ()
{
#if 0

	_IWmiDynamicPropertyResolver *t_DynamicResolver = NULL ;

	_IWmiProviderFactory *t_Factory = NULL ;

	HRESULT t_Result = InitializeFactory ( m_WmiService , m_SubSystem , t_Factory ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = InitializeDynamicResolver ( m_WmiService , t_Factory , t_DynamicResolver ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BSTR t_Class = SysAllocString ( L"SamplePropertyProvider" ) ;
			BSTR t_Instance = SysAllocString ( L"SamplePropertyProvider=@" ) ;
			if ( t_Class && t_Instance )	
			{
				t_Result = ExecutePropertyProvider ( m_WmiService , t_DynamicResolver , t_Class , t_Instance ) ;

				t_DynamicResolver->Release () ;
			}

			if ( t_Class )
			{
				SysFreeString ( t_Class ) ;
			}

			if ( t_Instance ) 
			{
				SysFreeString ( t_Instance ) ;
			}

		}

		t_Factory->Release () ;
	}

#else

	IWbemServices *t_Provider = NULL ;
	_IWmiProviderFactory *t_Factory = NULL ;

	HRESULT t_Result = InitializeFactory ( m_WmiService , m_SubSystem , t_Factory ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		BSTR t_Class = SysAllocString ( SAMPLE_CLASS ) ;
		if ( t_Class )	
		{
			t_Result = InitializeProvider ( m_WmiService , t_Factory , t_Class , t_Provider  ) ;
			if ( SUCCEEDED ( t_Result ) )
			{

				t_Result = Execute ( t_Provider , t_Class ) ;

				t_Provider->Release () ;
			}

			SysFreeString ( t_Class ) ;
		}

		t_Factory->Release () ;
	}

#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Process ( WmiThread <ULONG > &a_Thread )
{
	m_Result = S_OK ;

	if ( SUCCEEDED ( m_Result ) )
	{
		m_Result = Function () ;
	}

	m_Count -- ;
	if ( m_Count )
	{
		return e_StatusCode_EnQueue ;
	}
	else
	{
		Complete () ;
	}

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\include\core.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Core_H
#define _Core_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCoreServices : public _IWmiCoreServices
{
private:

	LONG m_ReferenceCount ;

	IWbemLocator *m_Locator ;

public:

	CCoreServices () ;
	~CCoreServices () ;

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Initialize () ;

	HRESULT STDMETHODCALLTYPE GetObjFactory (

		long a_Flags,
		_IWmiObjectFactory **a_Factory
	) ;

	HRESULT STDMETHODCALLTYPE GetServices (

		LPCWSTR a_Namespace,
		long a_Flags,
		REFIID a_Riid,
		void **a_Services
	) ;

	HRESULT STDMETHODCALLTYPE GetRepositoryDriver (

		long a_Flags,
		REFIID a_Riid,
		void **a_Driver
	) ;

	HRESULT STDMETHODCALLTYPE GetCallSec (

		long a_Flags,
		_IWmiCallSec **pCallSec
	) ;

	HRESULT STDMETHODCALLTYPE GetProviderSubsystem (

		long a_Flags,
		_IWmiProvSS **a_ProvSS
	) ;

	HRESULT STDMETHODCALLTYPE GetLogonManager () ;

	HRESULT STDMETHODCALLTYPE DeliverEvent (

		ULONG a_EventClassID,
		LPCWSTR a_StrParam1,
		LPCWSTR a_StrParam2,
		ULONG a_NumericValue
	);

	HRESULT STDMETHODCALLTYPE StopEventDelivery () ;

	HRESULT STDMETHODCALLTYPE StartEventDelivery () ;

	HRESULT STDMETHODCALLTYPE UpdateCounter (

		ULONG a_ClassID,
		LPCWSTR a_InstanceName,
		ULONG a_CounterID,
		ULONG a_Param1,
		ULONG a_Flags,
		unsigned __int64 a_Param2
	) ;

    HRESULT STDMETHODCALLTYPE GetSystemObjects ( 

        ULONG a_Flags,
        ULONG *a_ArraySize,
        _IWmiObject **a_Objects

	) ;
    
    HRESULT STDMETHODCALLTYPE GetSystemClass (

        LPCWSTR a_ClassName,
        _IWmiObject **a_Class

	) ;
    
    HRESULT STDMETHODCALLTYPE GetConfigObject ( 

        ULONG a_ID,
        _IWmiObject **a_CfgObject
	) ;
    
    HRESULT STDMETHODCALLTYPE RegisterWriteHook ( 

		ULONG a_Flags ,
		_IWmiCoreWriteHook *a_Hook
	) ;
    
    HRESULT STDMETHODCALLTYPE UnregisterWriteHook (

	    _IWmiCoreWriteHook *a_Hook
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateCache (

        ULONG a_Flags ,
        _IWmiCache **a_Cache

	) ;

    HRESULT STDMETHODCALLTYPE CreateFinalizer (

		ULONG a_Flags,
		_IWmiFinalizer **a_Finalizer	
	) ;

    HRESULT STDMETHODCALLTYPE CreatePathParser (

        ULONG a_Flags,
        IWbemPath **a_Parser
	) ;

    HRESULT STDMETHODCALLTYPE CreateQueryParser (

        ULONG a_Flags,
        _IWmiQuery **a_Query
	);

} ;

#endif _Core_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\cthread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: UnInitialize_Callback () 
{
	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread :: ClientThread (

	WmiAllocator &a_Allocator	

) : WmiThread < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread::~ClientThread ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\include\task.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Task_H
#define _Task_H

#include <Thread.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProviderInitSink : public IWbemProviderInitSink 
{
private:

	HRESULT m_Result ;

	LONG m_ReferenceCount ;

	HANDLE m_Event ;

protected:

public:

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG lStatus,
        LONG lFlags 
	)
	{
		m_Result = lStatus ;

		SetEvent ( m_Event ) ;
		return S_OK ;
	}

	CProviderInitSink () : m_ReferenceCount ( 0 ) , m_Event ( NULL ) , m_Result ( S_OK )
	{
		m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	}

	~CProviderInitSink () 
	{
		if ( m_Event ) 
		{
			CloseHandle ( m_Event ) ;
		}
	}

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) 
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemProviderInitSink )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}

	STDMETHODIMP_(ULONG) Release ()
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}

	void Wait () 
	{
		WaitForSingleObject ( m_Event , INFINITE ) ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProviderSink : public IWbemObjectSink 
{
private:

	HRESULT m_Result ;
	LONG m_ReferenceCount ;

	HANDLE m_Event ;

protected:

public:

    HRESULT STDMETHODCALLTYPE SetStatus (
        long lFlags,
        HRESULT hResult,
        BSTR strParam,
        IWbemClassObject *pObjParam
	)
	{
		m_Result = hResult ;

		SetEvent ( m_Event ) ;

		return S_OK ;
	}

    HRESULT STDMETHODCALLTYPE Indicate (

        LONG lObjectCount,
        IWbemClassObject **apObjArray
	)
	{
#if 1
		for ( LONG t_Index = 0 ; t_Index < lObjectCount ; t_Index ++ )
		{
			IWbemClassObject *t_Object = apObjArray [ t_Index ] ;

			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			wprintf ( L"\n" ) ;

			HRESULT t_Result = t_Object->Get ( L"Handle" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				wprintf ( L"%s", t_Variant.bstrVal ) ;

				VariantClear ( & t_Variant ) ;
			}

			t_Result = t_Object->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				wprintf ( L"\t%s", t_Variant.bstrVal ) ;

				VariantClear ( & t_Variant ) ;
			}
		}
#endif

		return S_OK ;
	}

	CProviderSink () : m_ReferenceCount ( 0 ) , m_Event ( NULL ) , m_Result ( S_OK ) 
	{
		m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	}

	~CProviderSink () 
	{
		if ( m_Event ) 
		{
			CloseHandle ( m_Event ) ;
		}
	}

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) 
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemObjectSink )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}

	STDMETHODIMP_(ULONG) Release ()
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}

	void Wait () 
	{
		WaitForSingleObject ( m_Event , INFINITE ) ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

class Task_Execute : public WmiTask < ULONG > 
{
private:

	ULONG m_Count ;

	HRESULT m_Result ;

	_IWmiProvSS *m_SubSystem ;
	IWbemServices *m_WmiService ;

	HRESULT GetClass (

		IWbemServices *a_Repository , 
		BSTR a_Class , 
		IWbemClassObject *&a_ClassObject
	) ;

	HRESULT GetInstance (

		IWbemServices *a_Repository , 
		BSTR a_Instance , 
		IWbemClassObject *&a_ClassObject
	) ;

	HRESULT InitializeDynamicResolver (

		IWbemServices *a_WmiService , 
		_IWmiProviderFactory *a_Factory ,
		_IWmiDynamicPropertyResolver *&a_DynamicResolver
	) ;

	HRESULT ExecutePropertyProvider (

		IWbemServices *a_WmiService , 
		_IWmiDynamicPropertyResolver *a_DynamicResolver ,
		BSTR a_Class ,
		BSTR a_Instance
	) ;

	HRESULT Execute (

		IWbemServices *a_ProviderService ,
		BSTR a_Class
	) ;

	HRESULT InitializeProvider (

		IWbemServices *a_WmiService , 
		_IWmiProviderFactory *a_Factory ,
		BSTR a_Class ,
		IWbemServices *& a_ProviderService
	) ;

	HRESULT InitializeFactory (	

		IWbemServices *a_WmiService , 
		_IWmiProvSS *a_SubSystem , 
		_IWmiProviderFactory *& a_Factory
	) ;

	HRESULT Function () ;

protected:

public:	/* Internal */

    Task_Execute ( WmiAllocator & a_Allocator , ULONG a_Count , _IWmiProvSS *a_SubSystem , IWbemServices *a_WmiService ) ;
    ~Task_Execute () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	HRESULT GetResultCode () { return m_Result ; }
};

#endif // _Task_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED
#ifndef POLARITY
#if 1
#define POLARITY __declspec( dllimport )
#else
#define POLARITY 
#endif
#endif

#ifndef COREPROX_POLARITY
#if 1
#define COREPROX_POLARITY __declspec( dllimport )
#else
#define COREPROX_POLARITY 
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\cglobals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <sddl.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <wbemcomn.h>
#include <callsec.h>
#include <cominit.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>
#include <PSSException.h>
#include <Cache.h>

#include "DateTime.h"
#include "CGlobals.h"

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <ReaderWriter.cpp>
#include <Logging.cpp>

#include <Cache.cpp>

#include <CallSec.h>
#include <OS.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR ProviderSubSystem_Common_Globals :: s_Wql = L"Wql" ;
LPCWSTR ProviderSubSystem_Common_Globals :: s_Provider = L"Provider" ;

WORD ProviderSubSystem_Common_Globals :: s_System_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalAdmins_ACESize = 0 ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalAdmins_ACE = NULL ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalAdmins_ACE = NULL ;

SECURITY_DESCRIPTOR *ProviderSubSystem_Common_Globals :: s_MethodSecurityDescriptor = NULL ;
SECURITY_DESCRIPTOR *ProviderSubSystem_Common_Globals :: s_DefaultDecoupledSD = NULL ;

ULONG ProviderSubSystem_Common_Globals :: s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;
ULONG ProviderSubSystem_Common_Globals :: s_DefaultStackSize = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateInstance ( 

	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateRemoteInstance ( 

	LPCWSTR a_Server ,
	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = ( LPWSTR ) a_Server ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespaceServerPath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_ServerNamespacePath
)
{
	a_ServerNamespacePath = NULL ;

	wchar_t *t_Server = NULL ;
	ULONG t_ServerLength = 0 ;

	HRESULT t_Result = a_Namespace->GetServer (

		& t_ServerLength , 
		t_Server
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Server = new wchar_t [ t_ServerLength + 1 ] ;

		t_Result = a_Namespace->GetServer (

			& t_ServerLength , 
			t_Server
		) ;

		if ( FAILED ( t_Result ) )
		{
			delete [] t_Server ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_ConcatString = NULL ;

		WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

			2 , 
			& t_ConcatString ,
			L"\\\\" ,
			t_Server
		) ;

		delete [] t_Server ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_ServerNamespacePath = t_ConcatString ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_NamespaceCount = 0 ;

        t_Result = a_Namespace->GetNamespaceCount (

            & t_NamespaceCount 
		) ;

		if ( t_NamespaceCount )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
			{
				wchar_t *t_Namespace = NULL ;
				ULONG t_NamespaceLength = 0 ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

    				t_Result = a_Namespace->GetNamespaceAt (

						t_Index ,
						& t_NamespaceLength ,
						t_Namespace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						wchar_t *t_ConcatString = NULL ;

						WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

							3 , 
							& t_ConcatString ,
							a_ServerNamespacePath ,
							L"\\" ,
							t_Namespace
						) ;

						delete [] t_Namespace ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							delete [] a_ServerNamespacePath ;
							a_ServerNamespacePath = t_ConcatString ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_NAMESPACE ;
		}
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_ServerNamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespacePath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_NamespacePath
)
{
	a_NamespacePath = NULL ;

	ULONG t_NamespaceCount = 0 ;

    HRESULT t_Result = a_Namespace->GetNamespaceCount (

        & t_NamespaceCount 
	) ;

	if ( t_NamespaceCount )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
		{
			wchar_t *t_Namespace = NULL ;
			ULONG t_NamespaceLength = 0 ;

    		t_Result = a_Namespace->GetNamespaceAt (

				t_Index ,
				& t_NamespaceLength ,
				t_Namespace 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_ConcatString = NULL ;

					WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

						3 , 
						& t_ConcatString ,
						a_NamespacePath ,
						t_Index ? L"\\" : NULL ,
						t_Namespace
					) ;

					delete [] t_Namespace ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						delete [] a_NamespacePath ;
						a_NamespacePath = t_ConcatString ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
				break ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_NamespacePath ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetPathText (

	IWbemPath *a_Path ,
	wchar_t *&a_ObjectPath
)
{
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Path->GetText ( 

		0 ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		a_ObjectPath = new wchar_t [ t_ObjectPathLength + 1 ] ;
		if ( a_ObjectPath )
		{
			t_Result = a_Path->GetText ( 

				0 ,
				& t_ObjectPathLength ,
				a_ObjectPath
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating ,
	DWORD *a_AuthenticationLevel
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD | WMI_ORIGIN_EXISTING | WMI_ORIGIN_RPC ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_AuthenticationLevel )
					{
						t_Result = t_ThreadSecurity->GetAuthentication ( a_AuthenticationLevel  ) ;
					}

					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EndImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_ClientSecurity->CopyProxy (

				a_Interface ,
				( IUnknown ** ) & a_Proxy
			) ;

			t_ClientSecurity->Release () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

			WmiStatusCode t_StatusCode = a_Container.Top ( a_Proxy , a_ProxyIndex ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = a_Container.Reserve ( a_ProxyIndex ) ;
			}
			else
			{
				if ( a_Container.GetCurrentSize () < a_Container.GetTopSize () )
				{
					t_Result = t_ClientSecurity->CopyProxy (

						a_Interface ,
						( IUnknown ** ) & a_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						a_Container.SetCurrentSize ( a_Container.GetCurrentSize () + 1 ) ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

			t_ClientSecurity->Release () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown ,
	DWORD a_AuthenticationLevel ,
	DWORD a_ImpersonationLevel
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			a_AuthenticationLevel ,
			a_ImpersonationLevel ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			RPC_C_AUTHN_LEVEL_DEFAULT ,
			RPC_C_IMP_LEVEL_DEFAULT ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ProviderSubSystem_Common_Globals :: IsProxy ( IUnknown *a_Unknown )
{
	BOOL t_IsProxy ;

    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_IsProxy = TRUE ;
		t_ClientSecurity->Release () ;
	}
	else
	{
		t_IsProxy = FALSE ;
	}

	return t_IsProxy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE ,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ( HANDLE a_Token )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ReturnedLength = 0 ;

	BOOL t_Status = GetTokenInformation (

		a_Token , 
		TokenPrivileges , 
		NULL , 
		0 , 
		& t_ReturnedLength
	) ;

	UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
	if ( t_Buffer )
	{
		t_Status = GetTokenInformation (

			a_Token , 
			TokenPrivileges , 
			t_Buffer , 
			t_ReturnedLength , 
			& t_ReturnedLength
		) ;

		if ( t_Status )
		{
			TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;

			for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
			{
				t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
			}

			t_Status = AdjustTokenPrivileges (

				a_Token, 
				FALSE, 
				t_Privileges , 
				0, 
				NULL, 
				NULL
			) ;

			if ( t_Status == FALSE )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Status = WBEM_E_ACCESS_DENIED ;
		}

		delete [] t_Buffer ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ()
{
	HRESULT t_Result = S_OK ;

    HANDLE t_Token = NULL ;

    BOOL t_Status = TRUE ;

	t_Status = OpenThreadToken (

		GetCurrentThread (), 
		TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES ,
		FALSE, 
		&t_Token
	) ;

    if ( t_Status )
	{
		DWORD t_ReturnedLength = 0 ;

		t_Status = GetTokenInformation (

			t_Token , 
			TokenPrivileges , 
			NULL , 
			0 , 
			& t_ReturnedLength
		) ;
    
		UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
		if ( t_Buffer )
		{
			t_Status = GetTokenInformation (

				t_Token , 
				TokenPrivileges , 
				t_Buffer , 
				t_ReturnedLength , 
				& t_ReturnedLength
			) ;

			if ( t_Status )
			{
				TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;

				for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
				{
					t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
				}

				t_Status = AdjustTokenPrivileges (

					t_Token, 
					FALSE, 
					t_Privileges , 
					0, 
					NULL, 
					NULL
				) ;

				if ( t_Status == FALSE )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			else
			{
				t_Status = WBEM_E_ACCESS_DENIED ;
			}

			delete [] t_Buffer ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		CloseHandle ( t_Token ) ;
	}
	else
	{
		DWORD t_LastError = GetLastError () ;
        t_Result = WBEM_E_ACCESS_DENIED;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetAnonymous ( IUnknown *a_Proxy )
{
	HRESULT t_Result = SetInterfaceSecurity (

		a_Proxy ,
		NULL ,
		NULL ,
		NULL ,
                DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
		RPC_C_IMP_LEVEL_ANONYMOUS
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_SvcHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		HANDLE t_AdjustedThreadToken = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) SecurityIdentification ,
												TokenImpersonation ,
												& t_AdjustedThreadToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_ProcessHandle = OpenProcess (

				MAXIMUM_ALLOWED ,
				FALSE ,
				a_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				t_Status = DuplicateHandle (

					GetCurrentProcess () ,
					t_AdjustedThreadToken ,
					t_ProcessHandle ,
					& a_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{

				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		if ( t_AdjustedThreadToken )
		{
			CloseHandle ( t_AdjustedThreadToken ) ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_PrvHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) SecurityIdentification ,
												TokenImpersonation ,
												& a_IdentifyToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCallState ( 

	IUnknown *a_Interface , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = S_OK ;
	
	if ( IsProxy ( a_Interface ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			t_Result = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				CoRevertToSelf () ;

				a_Revert = FALSE ;

				t_Result = WBEM_E_ACCESS_DENIED ;

#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }
	}
	else 
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT ProviderSubSystem_Common_Globals :: RevertCallState (

	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState ( IUnknown *a_Proxy , BOOL a_Revert )
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	a_Proxy->Release () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_Data = 0 ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_DWORD ) )
	{
		a_Value = t_Data ;
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_SZ ) )
	{
		t_Data = new wchar_t [ t_DataSize / sizeof ( wchar_t ) ] ;
		if ( t_Data )
		{
			t_RegResult = OS::RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = SysAllocString ( t_Data ) ;
				if ( a_Value == NULL )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] t_Data ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;
	BYTE *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_BINARY ) )
	{
		t_Data = new BYTE [ t_DataSize ] ;
		if ( t_Data )
		{
			t_RegResult = OS::RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = t_Data ;
				a_ValueLength = t_DataSize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
				DebugBreak () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( & a_Value ) ,
	  t_DataSize 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	DWORD t_DataSize = wcslen ( a_Value ) + 1 ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  t_DataSize * sizeof ( wchar_t ) 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  a_ValueLength 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: UnMarshalRegistration (

	IUnknown **a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoUnmarshalInterface (

				t_Stream ,
				IID_IUnknown ,
				( void ** ) a_Unknown
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ReleaseRegistration (

	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoReleaseMarshalData (

				t_Stream
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: MarshalRegistration (

	IUnknown *a_Unknown ,
	BYTE *&a_MarshaledProxy ,
	DWORD &a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	t_Result = CoGetMarshalSizeMax (

		& a_MarshaledProxyLength ,
		IID_IUnknown ,
		a_Unknown ,
		MSHCTX_LOCAL ,
		NULL ,
		MSHLFLAGS_TABLEWEAK
	) ;
 
	if ( SUCCEEDED ( t_Result ) ) 
	{
		IStream *t_Stream = NULL ;

		HGLOBAL t_Global = GlobalAlloc (

			GHND ,
			a_MarshaledProxyLength
		) ;

		if ( t_Global ) 
		{
			t_Result = CreateStreamOnHGlobal (

			  t_Global ,
			  TRUE ,
			  & t_Stream 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoMarshalInterface (

					t_Stream ,
					IID_IUnknown ,
					a_Unknown ,
					MSHCTX_LOCAL ,
					NULL ,
					MSHLFLAGS_TABLESTRONG
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					a_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
					if ( a_MarshaledProxy )
					{
						void *t_Memory = GlobalLock ( t_Global ) ;

						CopyMemory ( a_MarshaledProxy , t_Memory , a_MarshaledProxyLength ) ;

						GlobalUnlock ( t_Global ) ;

					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ; 
					}
				}
				t_Stream->Release();
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ; 
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: IsDependantCall ( IWbemContext *a_ParentContext , IWbemContext *a_ChildContext , BOOL &a_DependantCall )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( a_ParentContext )
	{
		if ( a_ChildContext )
		{
			IWbemCausalityAccess *t_ParentCausality = NULL ;
			t_Result = a_ParentContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ParentCausality ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemCausalityAccess *t_ChildCausality = NULL ;
				t_Result = a_ChildContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ChildCausality ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					REQUESTID t_ParentId ;

					t_Result = t_ParentCausality->GetRequestId ( & t_ParentId ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ChildCausality->IsChildOf ( t_ParentId ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							a_DependantCall = ( t_Result == S_FALSE ) ? FALSE : TRUE ;
						}
					}

					t_ChildCausality->Release () ;		
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}

				t_ParentCausality->Release () ;		
			}
		}
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	const UINT64 &a_Uint64
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		0 ,
		CIM_UINT64 ,
		( void * ) & a_Uint64
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint16 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const WORD &a_Uint16
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		0 ,
		CIM_UINT16 ,
		( void * ) & a_Uint16
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Bool ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const BOOL &a_Bool
)
{
	WORD t_Word = ( WORD ) a_Bool ;

	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		0 ,
		CIM_BOOLEAN ,
		( void * ) & t_Word
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME a_Time
)
{
	CWbemDateTime t_Time ;
	t_Time.SetFileTimeDate ( a_Time , VARIANT_FALSE ) ;

	BSTR t_String ;
	HRESULT t_Result = t_Time.GetValue ( & t_String ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_BSTR ;
		t_Variant.bstrVal = t_String ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , CIM_DATETIME ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Byte_Array  ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	BYTE *a_Bytes ,
	WORD a_BytesCount 
)
{
	HRESULT t_Result = S_OK ;
 
	LONG t_Dimension = 1 ; 

	SAFEARRAYBOUND t_ArrayBounds ;
	t_ArrayBounds.cElements = a_BytesCount ; 
	t_ArrayBounds.lLbound = 0 ;

	SAFEARRAY *t_Array = SafeArrayCreate ( 

		VT_I1 , 
		t_Dimension ,
		& t_ArrayBounds
	) ;

	if ( t_Array )
	{
		for ( LONG t_Index = 0 ; t_Index <= a_BytesCount ; t_Index ++ )
		{
			if ( SUCCEEDED ( SafeArrayPutElement ( t_Array , & t_Index , & a_Bytes [ t_Index ] ) ) )
			{
			}
			else
			{
				SafeArrayDestroy ( t_Array ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;

				break ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_ARRAY | VT_I1  ;
		t_Variant.parray = t_Array ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	UINT64 &a_Uint64 ,
	BOOL &a_Null
)
{
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		& t_Type ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Uint64
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_UINT64 )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	DWORD &a_Uint32 ,
	BOOL &a_Null
)
{
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		& t_Type  ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Uint32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_UINT32 )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Uint16 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	WORD &a_Uint16 ,
	BOOL &a_Null 
)
{
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		& t_Type  ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Uint16
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_UINT16 )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Bool ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	BOOL &a_Bool ,
	BOOL &a_Null
)
{
	WORD t_Word = 0 ;
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		& t_Type ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Bool
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_BOOLEAN )
		{
			a_Bool = t_Word ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *&a_String ,
	BOOL &a_Null
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
					
	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Instance->Get ( a_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ( t_VarType == CIM_STRING ) && ( t_Variant.vt == VT_BSTR ) )
		{
			a_String = new wchar_t [ wcslen ( t_Variant.bstrVal ) + 1 ] ;
			if ( a_String )
			{
				wcscpy ( a_String , t_Variant.bstrVal ) ;

				a_Null = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( ( t_VarType == CIM_STRING ) && ( t_Variant.vt == VT_NULL ) )
		{
			a_Null = TRUE ;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME &a_Time ,
	BOOL &a_Null
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
					
	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Instance->Get ( a_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ( t_VarType == CIM_DATETIME ) && ( t_Variant.vt == VT_BSTR ) )
		{
			CWbemDateTime t_Time ;
			t_Result = t_Time.PutValue ( t_Variant.bstrVal ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Time.GetFileTimeDate ( a_Time ) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROPERTY ;
			}

			a_Null = FALSE ;
		}
		else if ( ( t_VarType == CIM_DATETIME ) && ( t_Variant.vt == VT_NULL ) )
		{
			a_Null = TRUE ;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity ( 
	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping,	
	SECURITY_DESCRIPTOR * defaultSD 
	)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR *t_SecurityDescriptor = a_SecurityDescriptor ? a_SecurityDescriptor : defaultSD ;

	HANDLE t_Token = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY ,
		TRUE ,
		& t_Token 										
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		HANDLE t_ProcessToken = NULL ;
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
			TOKEN_QUERY | TOKEN_DUPLICATE ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			t_Status = ImpersonateLoggedOnUser ( t_ProcessToken ) ;
			if ( t_Status )
			{
				BOOL t_Status = OpenThreadToken (

					GetCurrentThread () ,
					TOKEN_QUERY ,
					TRUE ,
					& t_Token 										
				) ;

				if ( ! t_Status )
				{
					DWORD t_LastError = GetLastError () ;

					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				RevertToSelf () ;
			}
			else
			{
				DWORD t_LastError = GetLastError () ;

				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		DWORD t_Access = 0 ;
		BOOL t_AccessStatus = FALSE ;
		PRIVILEGE_SET *t_PrivilegeSet = NULL ;
		DWORD t_PrivilegeSetSize = 0 ;
	
		MapGenericMask (

			& a_Access ,
			a_Mapping
		) ;

		t_Status = AccessCheck (

			t_SecurityDescriptor ,
			t_Token,
			a_Access ,
			a_Mapping ,
			NULL ,
			& t_PrivilegeSetSize ,
			& t_Access ,
			& t_AccessStatus
		) ;

		if ( t_Status && t_AccessStatus )
		{
		}
		else
		{
			DWORD t_LastError = GetLastError () ;
			if ( t_LastError == ERROR_INSUFFICIENT_BUFFER )
			{
				t_PrivilegeSet = ( PRIVILEGE_SET * ) new BYTE [ t_PrivilegeSetSize ] ;
				if ( t_PrivilegeSet )
				{
					t_Status = AccessCheck (
						t_SecurityDescriptor ,
						t_Token,
						a_Access ,
						a_Mapping ,
						t_PrivilegeSet ,
						& t_PrivilegeSetSize ,
						& t_Access ,
						& t_AccessStatus
					) ;

					if ( t_Status && t_AccessStatus )
					{
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					delete [] ( BYTE * ) t_PrivilegeSet ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}
		}

		CloseHandle ( t_Token ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void DumpThreadTokenSecurityDescriptor ()
{
    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

    if ( t_Status ) 
	{
		PSECURITY_DESCRIPTOR t_SecurityDescriptor = NULL ;
		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( PSECURITY_DESCRIPTOR ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				delete [] t_SecurityDescriptor ;
			}
		}

		CloseHandle ( t_ThreadToken ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

	SID *a_OwnerSid , 
	SID *a_GroupSid , 
	DWORD a_Access ,
	SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
	SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR t_CreatedSecurityDescriptor ;
	SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

	PACL t_Dacl = NULL ;
	PACL t_Sacl = NULL ;
	PSID t_Owner = NULL ;
	PSID t_PrimaryGroup = NULL ;
	SECURITY_DESCRIPTOR *t_AlteredSecurityDescriptor = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SecurityDescriptor )
		{
			DWORD t_AlteredSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;
			DWORD t_DaclSize = 0 ;
			DWORD t_SaclSize = 0 ;
			DWORD t_OwnerSize = 0 ;
			DWORD t_PrimaryGroupSize = 0 ;

			BOOL t_Status = MakeAbsoluteSD (

			  a_SecurityDescriptor ,
			  t_AlteredSecurityDescriptor ,
			  & t_AlteredSecurityDescriptorSize ,
			  t_Dacl,
			  & t_DaclSize,
			  t_Sacl,
			  & t_SaclSize,
			  t_Owner,
			  & t_OwnerSize,
			  t_PrimaryGroup,
			  & t_PrimaryGroupSize
			) ;

			if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
				DWORD t_ExtraSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

				t_Dacl = ( PACL ) new BYTE [ t_DaclSize + t_ExtraSize ] ;
				t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
				t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
				t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;

				t_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AlteredSecurityDescriptorSize ] ;

				if ( t_AlteredSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
				{
					BOOL t_Status = InitializeSecurityDescriptor ( t_AlteredSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
					if ( t_Status )
					{
						t_Status = MakeAbsoluteSD (

							a_SecurityDescriptor ,
							t_AlteredSecurityDescriptor ,
							& t_AlteredSecurityDescriptorSize ,
							t_Dacl,
							& t_DaclSize,
							t_Sacl,
							& t_SaclSize,
							t_Owner,
							& t_OwnerSize,
							t_PrimaryGroup,
							& t_PrimaryGroupSize
						) ;

						if ( t_Status )
						{
							t_SecurityDescriptor = t_AlteredSecurityDescriptor ;

							if ( t_OwnerSize == 0 )
							{
								t_Status = SetSecurityDescriptorOwner (

									t_SecurityDescriptor ,
									a_OwnerSid ,
									FALSE 
								) ;

								if ( ! t_Status )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_PrimaryGroupSize == 0 )
								{
									t_Status = SetSecurityDescriptorGroup (

										t_SecurityDescriptor ,
										a_GroupSid ,
										FALSE 
									) ;

									if ( ! t_Status )
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			BOOL t_Status = InitializeSecurityDescriptor ( & t_CreatedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_Status )
			{
				t_Status = SetSecurityDescriptorOwner (

					& t_CreatedSecurityDescriptor ,
					a_OwnerSid ,
					FALSE 
				) ;

				if ( ! t_Status )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Status = SetSecurityDescriptorGroup (

						& t_CreatedSecurityDescriptor ,
						a_GroupSid ,
						FALSE 
					) ;

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_SecurityDescriptor = & t_CreatedSecurityDescriptor ;
		}
	}


	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;
	DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;

	PACL t_ExtraDacl = NULL ;
	ACCESS_ALLOWED_ACE *t_Ace = NULL ;
	DWORD t_AceSize = 0 ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
		if ( t_Ace )
		{
			CopySid ( t_SidLength, (PSID) & t_Ace->SidStart, a_OwnerSid ) ;
			t_Ace->Mask = a_Access ;
			t_Ace->Header.AceType = 0 ;
			t_Ace->Header.AceFlags = 0 ;
			t_Ace->Header.AceSize = t_AceSize ;

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ACL_SIZE_INFORMATION t_Size ;

		if ( t_Dacl )
		{
			BOOL t_Status = GetAclInformation (

				t_Dacl ,
				& t_Size ,
				sizeof ( t_Size ) ,
				AclSizeInformation
			);

			if ( t_Status )
			{
				DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
				t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

				t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
				if ( t_ExtraDacl )
				{
					CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
					t_ExtraDacl->AclSize = t_ExtraSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
			DWORD t_ExtraSize = sizeof ( ACL ) + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
			t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

			t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
			if ( t_ExtraDacl )
			{
				BOOL t_Status = InitializeAcl (

					t_ExtraDacl ,
					t_ExtraSize ,
					ACL_REVISION 
				) ;

				if ( t_Status )
				{
					BOOL t_Status = GetAclInformation (

						t_ExtraDacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		DWORD t_AceIndex = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , t_Ace , t_AceSize ) ;
			if ( t_Status )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_System_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_System_ACE , s_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalService_ACE , s_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_NetworkService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_NetworkService_ACE , s_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalAdmins_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalAdmins_ACE , s_LocalAdmins_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			


		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetSecurityDescriptorDacl (

				  t_SecurityDescriptor ,
				  TRUE ,
				  t_ExtraDacl ,
				  FALSE 
			) ;

			if ( t_Status )
			{
				DWORD t_FinalLength = 0 ;

				t_Status = MakeSelfRelativeSD (

					t_SecurityDescriptor ,
					a_AlteredSecurityDescriptor ,
					& t_FinalLength 
				) ;

				if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
				{
					a_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
					if ( a_AlteredSecurityDescriptor )
					{
						t_Status = MakeSelfRelativeSD (

							t_SecurityDescriptor ,
							a_AlteredSecurityDescriptor ,
							& t_FinalLength 
						) ;

						if ( t_Status == FALSE )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;									
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		delete [] t_Ace ;
		delete [] t_ExtraDacl ;
	}

	delete [] ( BYTE * ) t_Dacl ;
	delete [] ( BYTE * ) t_Sacl ;
	delete [] ( BYTE * ) t_Owner ;
	delete [] ( BYTE * ) t_PrimaryGroup ;
	delete [] ( BYTE * ) t_AlteredSecurityDescriptor ;

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateSystemAces ()
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_System_Sid = NULL ;
	PSID t_LocalService_Sid = NULL ;
	PSID t_NetworkService_Sid = NULL ;
	PSID t_LocalAdmins_Sid = NULL ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		s_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

		s_Provider_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
		if ( s_Provider_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & s_Provider_System_ACE->SidStart, t_System_Sid ) ;
			s_Provider_System_ACE->Mask =  MASK_PROVIDER_BINDING_BIND  ;
			s_Provider_System_ACE->Header.AceType = 0 ;
			s_Provider_System_ACE->Header.AceFlags = 3 ;
			s_Provider_System_ACE->Header.AceSize = s_System_ACESize ;

			s_Token_All_Access_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
			if ( s_Token_All_Access_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Token_All_Access_System_ACE->SidStart, t_System_Sid ) ;
				s_Token_All_Access_System_ACE->Mask = TOKEN_ALL_ACCESS ;
				s_Token_All_Access_System_ACE->Header.AceType = 0 ;
				s_Token_All_Access_System_ACE->Header.AceFlags = 3 ;
				s_Token_All_Access_System_ACE->Header.AceSize = s_System_ACESize ;
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
			s_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
			if ( s_Provider_LocalService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
				s_Provider_LocalService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalService_ACE->Header.AceType = 0 ;
				s_Provider_LocalService_ACE->Header.AceFlags = 3 ;
				s_Provider_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;

				s_Token_All_Access_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
				if ( s_Token_All_Access_LocalService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
					s_Token_All_Access_LocalService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalService_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_NETWORK_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_NetworkService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
			s_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
			if ( s_Provider_NetworkService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
				s_Provider_NetworkService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_NetworkService_ACE->Header.AceType = 0 ;
				s_Provider_NetworkService_ACE->Header.AceFlags = 3 ;
				s_Provider_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;

				s_Token_All_Access_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
				if ( s_Token_All_Access_NetworkService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
					s_Token_All_Access_NetworkService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_NetworkService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			2 ,
			SECURITY_BUILTIN_DOMAIN_RID ,
			DOMAIN_ALIAS_RID_ADMINS ,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalAdmins_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalAdmins_Sid );
			s_LocalAdmins_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
			if ( s_Provider_LocalAdmins_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
				s_Provider_LocalAdmins_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalAdmins_ACE->Header.AceType = 0 ;
				s_Provider_LocalAdmins_ACE->Header.AceFlags = 3 ;
				s_Provider_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;

				s_Token_All_Access_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
				if ( s_Token_All_Access_LocalAdmins_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
					s_Token_All_Access_LocalAdmins_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( t_LocalAdmins_Sid )
	{
		FreeSid ( t_LocalAdmins_Sid ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_LocalService_Sid )
	{
		FreeSid ( t_LocalService_Sid ) ;
	}

	if ( t_NetworkService_Sid )
	{
		FreeSid ( t_NetworkService_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteSystemAces ()
{
	if ( s_Provider_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_System_ACE ) ;
	}

	if ( s_Provider_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalService_ACE ) ;
	}

	if ( s_Provider_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_NetworkService_ACE ) ;
	}

	if ( s_Provider_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalAdmins_ACE ) ;
	}

	if ( s_Token_All_Access_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_System_ACE ) ;
	}

	if ( s_Token_All_Access_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalService_ACE ) ;
	}

	if ( s_Token_All_Access_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_NetworkService_ACE ) ;
	}

	if ( s_Token_All_Access_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalAdmins_ACE ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CheckAccess ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping
)
{
	HRESULT t_Result = S_OK ;

	if ( a_SecurityDescriptor )	
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) || t_Result == RPC_E_CALL_COMPLETE )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

				a_SecurityDescriptor , 
				a_Access ,
				a_Mapping
			) ;

			CoRevertToSelf () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenUser )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenUser ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenUser ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetGroupSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_PRIMARY_GROUP *t_TokenGroup = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenPrimaryGroup ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenGroup ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenGroup = ( TOKEN_PRIMARY_GROUP * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenGroup )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenGroup ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenGroup->PrimaryGroup ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenGroup->PrimaryGroup , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenGroup ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
					
	DWORD a_ProcessIdentifier ,
	WORD &a_AceSize ,
	ACCESS_ALLOWED_ACE *&a_Ace 
)
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

	HANDLE t_ProcessHandle = OpenProcess (

		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		HANDLE t_ProcessToken = NULL ;
		BOOL t_Status = OpenProcessToken (

			t_ProcessHandle  ,
			TOKEN_QUERY ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_ProcessToken ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) ) 
			{
				ACCESS_ALLOWED_ACE *t_Ace = NULL ;
				DWORD t_AceSize = 0 ;

				t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_OwnerSize - sizeof(DWORD) ) ;
				t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
				if ( t_Ace )
				{
					CopySid ( t_OwnerSize, (PSID) & t_Ace->SidStart, t_OwnerSid ) ;
					t_Ace->Mask = TOKEN_ALL_ACCESS ;
					t_Ace->Header.AceType = 0 ;
					t_Ace->Header.AceFlags = 0 ;
					t_Ace->Header.AceSize = t_AceSize ;

					a_Ace = t_Ace ;
					a_AceSize = t_AceSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}

		CloseHandle ( t_ProcessHandle ) ;
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SinkAccessInitialize (

	SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
	SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
)
{
	HRESULT t_Result = CoImpersonateClient () ;
        HANDLE t_Token = NULL ;
        BOOL t_Status = FALSE;
        DWORD t_LastError = NO_ERROR;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			&t_Token
		) ;

                if (!t_Status)
                {
	 	 	t_LastError = GetLastError();	

  		        CoRevertToSelf () ;

			if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN ||
				t_LastError == ERROR_NO_TOKEN )
                       	{
                		t_Status = OpenProcessToken(

		                 	GetCurrentProcess () ,
 					TOKEN_QUERY,
					&t_Token
				);

				if ( !t_Status )
				{
					t_Result = WBEM_E_ACCESS_DENIED;
				}
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}
                }
		else
		{
			CoRevertToSelf ();
		}
        }
        else if ( t_Result == RPC_E_CALL_COMPLETE )
        {
        	t_Status = OpenProcessToken(

                	GetCurrentProcess () ,
 			TOKEN_QUERY,
			&t_Token
		);

		if ( !t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
        }

	if ( t_Status )
	{
		DWORD t_OwnerSize = 0 ; 
		PSID t_OwnerSid = NULL ;
		BOOL t_OwnerDefaulted = FALSE ;

		t_Result = GetUserSid (

			t_Token ,
			& t_OwnerSize , 
			t_OwnerSid 
		) ; 

		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_GroupSize = 0 ; 
			PSID t_GroupSid = NULL ;
			BOOL t_GroupDefaulted = FALSE ;

			t_Result = GetGroupSid (

				t_Token ,
				& t_GroupSize , 
				t_GroupSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

					( SID * ) t_OwnerSid ,
					( SID * ) t_GroupSid ,
					MASK_PROVIDER_BINDING_BIND ,
					a_RegistrationSecurityDescriptor , 
					a_SinkSecurityDescriptor
				) ;

				delete [] ( BYTE * ) t_GroupSid ;
			}

			delete [] ( BYTE * ) t_OwnerSid ;
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		CloseHandle ( t_Token ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor ()
{
	HRESULT t_Result = S_OK ;

	BOOL t_Status = ConvertStringSecurityDescriptorToSecurityDescriptor (

		L"O:BAG:BAD:(A;;0x10000001;;;BA)(A;;0x10000001;;;SY)(A;;0x10000001;;;LA)(A;;0x10000001;;;S-1-5-20)(A;;0x10000001;;;S-1-5-19)" ,
		SDDL_REVISION_1 ,
		( PSECURITY_DESCRIPTOR * ) & s_MethodSecurityDescriptor ,
		NULL 
	) ;

	if ( t_Status )
	{
		t_Status = ConvertStringSecurityDescriptorToSecurityDescriptor (

			L"O:BAG:BAD:(A;;0x10000001;;;BA)(A;;0x10000001;;;SY)(A;;0x10000001;;;LA)(A;;0x10000001;;;S-1-5-20)(A;;0x10000001;;;S-1-5-19)"
			L"(A;;0x10000001;;;S-1-5-3) (A;;0x10000001;;;S-1-5-6)",
			SDDL_REVISION_1 ,
			( PSECURITY_DESCRIPTOR * ) & s_DefaultDecoupledSD ,
			NULL 
		) ;
		if ( t_Status )
		{
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}			
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor ()
{
	if ( s_MethodSecurityDescriptor	)
	{
		LocalFree ( s_MethodSecurityDescriptor ) ;
		s_MethodSecurityDescriptor = NULL;
	}
	if ( s_DefaultDecoupledSD)
	{
		LocalFree ( s_DefaultDecoupledSD ) ;
		s_DefaultDecoupledSD = NULL;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: InitializeTransmitSize ()
{	
	s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		L"Software\\Microsoft\\WBEM\\CIMOM" ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_DataSize = sizeof ( s_TransmitBufferSize ) ;

		t_RegResult = OS::RegQueryValueEx (

		  t_ConfigRoot ,
		  L"Sink Transmit Buffer Size" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & s_TransmitBufferSize ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return s_TransmitBufferSize ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#ifdef IA64
#define RPC_STACK_COMMIT_SIZE 8192 * 8
#else
#define RPC_STACK_COMMIT_SIZE 4096 * 8
#endif

#define REGSTR_PATH_SVCHOST     TEXT("Software\\Microsoft\\Wbem\\Cimom")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: InitializeDefaultStackSize ()
{	
	s_DefaultStackSize = RPC_STACK_COMMIT_SIZE ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		REGSTR_PATH_SVCHOST ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_Value = 0 ;
		DWORD t_DataSize = sizeof ( t_Value ) ;

		t_RegResult = RegQueryValueEx (

		  t_ConfigRoot ,
		  L"DefaultRpcStackSize" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & t_Value ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
			s_DefaultStackSize = t_Value * 1024 ;
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return s_DefaultStackSize ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provregdecoupled.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#undef POLARITY

#include <typeinfo.h>
#include <stdio.h>
#include <Aclapi.h>

#include <wbemint.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvRegDeCoupled.h"
#include "DateTime.h"
#include "OS.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetSecurity ( HKEY a_Key , DWORD a_Access ) 
{
	if (!OS::secureOS_)
		return ERROR_SUCCESS;

	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	DWORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	DWORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_PowerUsers_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_PowerUsers_ACE = NULL ;
	DWORD t_PowerUsers_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_POWER_USERS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_PowerUsers_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_PowerUsers_Sid );
		t_PowerUsers_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_PowerUsers_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_PowerUsers_ACESize ] ;
		if ( t_PowerUsers_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_PowerUsers_ACE->SidStart, t_PowerUsers_Sid ) ;
			t_PowerUsers_ACE->Mask = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE ;
			t_PowerUsers_ACE->Header.AceType = 0 ;
			t_PowerUsers_ACE->Header.AceFlags = 3 ;
			t_PowerUsers_ACE->Header.AceSize = t_PowerUsers_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

	PSID t_Everyone_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
	DWORD t_Everyone_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_WorldAuthoritySid ,
		1 ,
		SECURITY_WORLD_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Everyone_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
		if ( t_Everyone_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
			t_Everyone_ACE->Mask = a_Access ;
			t_Everyone_ACE->Header.AceType = 0 ;
			t_Everyone_ACE->Header.AceFlags = 3 ;
			t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_System_ACESize + t_Everyone_ACESize ;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					LONG t_SetStatus = RegSetKeySecurity (

					  a_Key ,
					  t_SecurityInfo ,
					  & t_SecurityDescriptor
					) ;

					if ( t_SetStatus != ERROR_SUCCESS )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;	
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if ( t_PowerUsers_ACE )
	{
		delete [] ( ( BYTE * ) t_PowerUsers_ACE ) ;
	}

	if ( t_Everyone_ACE )
	{
		delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}
	
	if ( t_PowerUsers_Sid )
	{
		FreeSid ( t_PowerUsers_Sid ) ;
	}

	if ( t_Everyone_Sid )
	{
		FreeSid ( t_Everyone_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_User = L"User" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Locale = L"Locale" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Scope = L"Scope" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Provider = L"Provider" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;

LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_HomeServer = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Server" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: CServerObject_DecoupledClientRegistration_Element ()

	:	m_Provider ( NULL ) ,
		m_Clsid ( NULL ) ,
		m_CreationTime ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Scope ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 ) ,
		m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: ~CServerObject_DecoupledClientRegistration_Element ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledClientRegistration_Element :: Clear () 
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element &CServerObject_DecoupledClientRegistration_Element :: operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key )
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}

	if ( a_Key.m_Provider )
	{
		m_Provider = SysAllocString ( a_Key.m_Provider ) ;
	}

	if ( a_Key.m_CreationTime )
	{
		m_CreationTime = SysAllocString ( a_Key.m_CreationTime ) ;
	}

	if ( a_Key.m_User )
	{
		m_User = SysAllocString ( a_Key.m_User ) ;
	}

	if ( a_Key.m_Locale )
	{
		m_Locale = SysAllocString ( a_Key.m_Locale ) ;
	}

	if ( a_Key.m_Scope )
	{
		m_Scope = SysAllocString ( a_Key.m_Scope ) ;
	}

	if ( a_Key.m_Clsid ) 
	{
		m_Clsid = SysAllocString ( a_Key.m_Clsid ) ;
	}

	m_MarshaledProxyLength = a_Key.m_MarshaledProxyLength ;

	if ( a_Key.m_MarshaledProxy )
	{
		m_MarshaledProxy = new BYTE [ a_Key.m_MarshaledProxyLength ] ;
		if ( m_MarshaledProxy )
		{
			CopyMemory ( m_MarshaledProxy , a_Key.m_MarshaledProxy , a_Key.m_MarshaledProxyLength ) ;
		}
	}

	return *this ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProvider ( BSTR a_Provider )
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
	}

	m_Provider = SysAllocString ( a_Provider ) ;
	if ( m_Provider == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetLocale ( BSTR a_Locale )
{
	HRESULT t_Result = S_OK ;

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
	}

	m_Locale = SysAllocString ( a_Locale ) ;
	if ( m_Locale == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetUser ( BSTR a_User )
{
	HRESULT t_Result = S_OK ;

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
	}

	m_User = SysAllocString ( a_User ) ;
	if ( m_User == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetScope ( BSTR a_Scope )
{
	HRESULT t_Result = S_OK ;

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
	}

	m_Scope = SysAllocString ( a_Scope ) ;
	if ( m_Scope == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetClsid ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	m_Clsid = SysAllocString ( a_Clsid ) ;
	if ( m_Clsid == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = OS::GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Load ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			3, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			L"\\" ,
			a_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClientClsid_Key ;

			LONG t_RegResult = OS::RegOpenKeyEx (

				HKEY_LOCAL_MACHINE ,
				t_HomeClientClsid_String ,
				0 ,
				KEY_READ ,
				& t_HomeClientClsid_Key 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Validate () ;
				}

				RegCloseKey ( t_HomeClientClsid_Key ) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( FAILED ( t_Result ) )
	{
		Delete ( a_Clsid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Save ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			2, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			m_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClient_Key ;
			DWORD t_Disposition = 0 ;

			LONG t_RegResult = OS::RegCreateKeyEx (

				HKEY_LOCAL_MACHINE ,
				s_Strings_Reg_HomeClient ,
				0 ,
				NULL ,
				REG_OPTION_VOLATILE ,
				KEY_WRITE ,
				NULL ,
				& t_HomeClient_Key ,
				& t_Disposition                     
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				HKEY t_HomeClientClsid_Key ;

				LONG t_RegResult = OS::RegCreateKeyEx (

					t_HomeClient_Key ,
					m_Clsid ,
					0 ,
					NULL ,
					REG_OPTION_VOLATILE ,
					KEY_WRITE ,
					NULL ,
					& t_HomeClientClsid_Key ,
					& t_Disposition                     
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					t_Result = SetSecurity ( t_HomeClientClsid_Key , KEY_READ ) ;

					if ( t_Disposition == REG_CREATED_NEW_KEY )
					{
						t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_Locale )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_User )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
						}
					}
					else
					{
						t_Result = WBEM_E_ALREADY_EXISTS ;
					}

					RegCloseKey ( t_HomeClientClsid_Key ) ;
				}

				RegCloseKey ( t_HomeClient_Key ) ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Delete ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_HomeClientClsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		3, 
		& t_HomeClientClsid_String , 
		s_Strings_Reg_HomeClient ,
		L"\\" ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_HomeClientClsid_Key ;

		LONG t_RegResult = OS::RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String ,
			0 ,
			KEY_READ ,
			& t_HomeClientClsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			BYTE *t_MarshaledProxy = NULL ;
			ULONG t_MarshaledProxyLength = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

				t_HomeClientClsid_Key , 
				s_Strings_Reg_MarshaledProxy , 
				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

					t_MarshaledProxy , 
					t_MarshaledProxyLength
				) ;

				if ( t_MarshaledProxy )
				{
					delete [] t_MarshaledProxy ;
				}
			}

			RegCloseKey ( t_HomeClientClsid_Key ) ;
		}

		t_RegResult = OS::RegDeleteKey (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String
		) ;

		if ( t_RegResult != ERROR_SUCCESS )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		SysFreeString ( t_HomeClientClsid_String ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: CServerObject_DecoupledClientRegistration (

	WmiAllocator &a_Allocator 

) : m_Queue ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: ~CServerObject_DecoupledClientRegistration ()
{
	m_Queue.UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Count = 0 ;
		DWORD t_Size = 16 ;

		BSTR *t_Elements = ( BSTR * ) malloc ( sizeof ( BSTR ) * t_Size ) ;
		if ( t_Elements )
		{
			FILETIME t_FileTime ;
			DWORD t_Class ;
			BOOL t_Continue = TRUE ;

			while ( SUCCEEDED ( t_Result ) && t_Continue )
			{
				DWORD t_NameLength = 256 ;
				wchar_t t_Name [ 256 ] ;

				LONG t_RegResult = OS::RegEnumKeyEx (

					t_HomeClient_Key ,
					t_Count ,
					t_Name ,
					& t_NameLength ,            // size of subkey buffer
					NULL ,
					NULL ,
					NULL ,
					& t_FileTime
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					if ( t_Count >= t_Size )
					{
						BSTR *t_NewElements = ( BSTR * ) realloc ( t_Elements , sizeof ( BSTR ) * ( t_Size + 16 ) ) ;
						if ( t_NewElements )
						{
							t_Elements = t_NewElements ;
							t_Size = t_Size + 16 ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Elements [ t_Count ] = SysAllocString ( t_Name ) ;
						if ( t_Elements [ t_Count ]  )
						{
                                                        t_Count ++ ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
				else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
				{
					t_Continue = FALSE ;
				}
				else
				{
					t_Continue = FALSE ;
	// Generate message
				}
			}

			if ( t_Elements )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_Elements [ t_Index ] )
					{
						CServerObject_DecoupledClientRegistration_Element t_Element ;
						HRESULT t_TempResult = t_Element.Load ( t_Elements [ t_Index ] ) ;
						if ( SUCCEEDED ( t_TempResult ) )
						{
							m_Queue.EnQueue ( t_Element ) ;
						}
						else
						{
			// Generate message
						}

						SysFreeString ( t_Elements [ t_Index ] ) ;
					}
				}

				free ( t_Elements ) ;
			}
		}
		else
		{
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load (

	BSTR a_Provider ,
	BSTR a_User ,
	BSTR a_Locale ,
	BSTR a_Scope
)
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Index = 0 ;
		FILETIME t_FileTime ;
		DWORD t_Class ;
		BOOL t_Continue = TRUE ;

		while ( SUCCEEDED ( t_Result ) && t_Continue )
		{
			DWORD t_NameLength = 256 ;
			wchar_t t_Name [ 256 ] ;

			LONG t_RegResult = OS::RegEnumKeyEx (

				t_HomeClient_Key ,
				t_Index ,
				t_Name ,
				& t_NameLength ,            // size of subkey buffer
				NULL ,
				NULL ,
				NULL ,
				& t_FileTime
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				CServerObject_DecoupledClientRegistration_Element t_Element ;
				HRESULT t_TempResult = t_Element.Load ( t_Name ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					BOOL t_Compare = ( _wcsicmp ( a_Provider , t_Element.GetProvider () ) == 0 ) ;
					t_Compare = t_Compare && ( _wcsicmp ( a_Scope , t_Element.GetScope () ) == 0 ) ;

					if ( t_Compare )
					{
						if ( ( a_Locale == NULL ) && ( t_Element.GetLocale () == NULL ) )
						{
						}
						else
						{
							if ( ( a_Locale ) && ( t_Element.GetLocale () ) )
							{
								t_Compare = ( _wcsicmp ( a_Locale , t_Element.GetLocale () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						if ( ( a_User == NULL ) && ( t_Element.GetUser () == NULL ) )
						{
						}
						else
						{
							if ( ( a_User ) && ( t_Element.GetUser () ) )
							{
								t_Compare = ( _wcsicmp ( a_User , t_Element.GetUser () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						m_Queue.EnQueue ( t_Element ) ;
					}
				}
				else
				{
// Generate message
				}
			}
			else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
			{
				t_Continue = FALSE ;
			}
			else
			{
				t_Continue = FALSE ;
// Generate message
			}

			t_Index ++ ;
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator )

	:	m_CreationTime ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: ~CServerObject_DecoupledServerRegistration ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledServerRegistration :: Clear () 
{
	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = OS::GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
	}

 	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if (OS::secureOS_)
		{
		SECURITY_INFORMATION t_SecurityInformation = OWNER_SECURITY_INFORMATION ;
		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;
		DWORD t_Length = 0 ;

		t_RegResult = RegGetKeySecurity (

			t_HomeServerClsid_Key ,
			t_SecurityInformation ,
			t_SecurityDescriptor ,
			& t_Length 
		) ;

		if ( t_RegResult == ERROR_INSUFFICIENT_BUFFER )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_Length ] ;
			if ( t_SecurityDescriptor )
			{
				t_RegResult = RegGetKeySecurity (

					t_HomeServerClsid_Key ,
					t_SecurityInformation ,
					t_SecurityDescriptor ,
					& t_Length 
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					SID *t_Sid = NULL ;
					BOOL t_Defaulted = FALSE ;

					BOOL t_Status = GetSecurityDescriptorOwner (

					  t_SecurityDescriptor ,
					  ( PSID * ) & t_Sid ,
					  & t_Defaulted
					) ;

					if ( t_Status )
					{
						SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

						PSID t_Administrator_Sid = NULL ;

						BOOL t_BoolResult = AllocateAndInitializeSid (

							& t_NtAuthoritySid ,
							2 ,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_ADMINS,
							0,
							0,
							0,
							0,
							0,
							0,
							& t_Administrator_Sid
						);

						if ( t_BoolResult )
						{
							if ( EqualSid ( t_Administrator_Sid , t_Sid ) == FALSE )
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}

							if ( t_Administrator_Sid )
							{
								FreeSid ( t_Administrator_Sid ) ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				delete [] ( BYTE * ) t_SecurityDescriptor ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
		}
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeServerClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeServerClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeServerClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Validate () ;
		}

		RegCloseKey ( t_HomeServerClsid_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Save ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServer_Key ;
	DWORD t_Disposition = 0 ;

	LONG t_RegResult = OS::RegCreateKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		NULL ,
		REG_OPTION_VOLATILE ,
		KEY_WRITE ,
		NULL ,
		& t_HomeServer_Key ,
		& t_Disposition                     
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		HRESULT t_TempResult = SetSecurity ( t_HomeServer_Key , KEY_READ ) ;

		t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeServer_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeServer_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeServer_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		RegCloseKey ( t_HomeServer_Key ) ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Delete ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		BYTE *t_MarshaledProxy = NULL ;
		ULONG t_MarshaledProxyLength = 0 ;

		t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

			t_HomeServerClsid_Key , 
			s_Strings_Reg_MarshaledProxy , 
			t_MarshaledProxy , 
			t_MarshaledProxyLength
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( t_MarshaledProxy )
			{
				delete [] t_MarshaledProxy ;
			}
		}

		RegCloseKey ( t_HomeServerClsid_Key ) ;
	}

	t_RegResult = OS::RegDeleteKey (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer
	) ;

	if ( t_RegResult != ERROR_SUCCESS )
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\datetime.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  DATETIME.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemDateTime
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <sys/timeb.h>
#include <math.h>
#include <time.h> 
#include <float.h>
#include <wbemint.h>

#include "DateTime.h"

#define ISWILD(c)		(L'*' == c)
#define ISINTERVAL(c)	(L':' == c)
#define ISMINUS(c)		(L'-' == c)
#define ISPLUS(c)		(L'+' == c)
#define	ISDOT(c)		(L'.' == c)

#define	WILD2			L"**"
#define	WILD3			L"***"
#define	WILD4			L"****"
#define	WILD6			L"******"

#define ASSERT_BREAK 

//***************************************************************************
//
//  CWbemDateTime::CWbemDateTime
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemDateTime::CWbemDateTime() :
		m_bYearSpecified (VARIANT_TRUE),
		m_bMonthSpecified (VARIANT_TRUE),
		m_bDaySpecified (VARIANT_TRUE),
		m_bHoursSpecified (VARIANT_TRUE),
		m_bMinutesSpecified (VARIANT_TRUE),
		m_bSecondsSpecified (VARIANT_TRUE),
		m_bMicrosecondsSpecified (VARIANT_TRUE),
		m_bUTCSpecified (VARIANT_TRUE),
		m_bIsInterval (VARIANT_FALSE),
		m_iYear (0),
		m_iMonth (1),
		m_iDay (1),
		m_iHours (0),
		m_iMinutes (0),
		m_iSeconds (0),
		m_iMicroseconds (0),
		m_iUTC (0)
{
}

//***************************************************************************
//
//  CWbemDateTime::~CWbemDateTime
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemDateTime::~CWbemDateTime(void)
{
}

//***************************************************************************
//
//  SCODE CWbemDateTime::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		pbsValue		pointer to BSTR to hold value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime :: GetValue ( BSTR *pbsValue) 
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pbsValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		wchar_t	dmtfValue [WBEMDT_DMTF_LEN + 1];
		dmtfValue [WBEMDT_DMTF_LEN] = NULL;

		if (m_bIsInterval)
		{
			// Intervals are easy
			swprintf (dmtfValue, L"%08d%02d%02d%02d.%06d:000", m_iDay, 
						m_iHours, m_iMinutes, m_iSeconds, m_iMicroseconds);
		}
		else
		{
			if (m_bYearSpecified)
				swprintf (dmtfValue, L"%04d", m_iYear);
			else
				wcscpy (dmtfValue, WILD4);

			if (m_bMonthSpecified)
				swprintf (dmtfValue + 4, L"%02d", m_iMonth);
			else
				wcscat (dmtfValue + 4, WILD2);

			if (m_bDaySpecified)
				swprintf (dmtfValue + 6, L"%02d", m_iDay);
			else
				wcscat (dmtfValue + 6, WILD2);

			if (m_bHoursSpecified)
				swprintf (dmtfValue + 8, L"%02d", m_iHours);
			else
				wcscat (dmtfValue + 8, WILD2);

			if (m_bMinutesSpecified)
				swprintf (dmtfValue + 10, L"%02d", m_iMinutes);
			else
				wcscat (dmtfValue + 10, WILD2);

			if (m_bSecondsSpecified)
				swprintf (dmtfValue + 12, L"%02d.", m_iSeconds);
			else
			{
				wcscat (dmtfValue + 12, WILD2);
				wcscat (dmtfValue + 14, L".");
			}

			if (m_bMicrosecondsSpecified)
				swprintf (dmtfValue + 15, L"%06d", m_iMicroseconds);
			else
				wcscat (dmtfValue + 15, WILD6);

			if (m_bUTCSpecified)
				swprintf (dmtfValue + 21, L"%C%03d", (0 <= m_iUTC) ? L'+' : L'-', 
							(0 <= m_iUTC) ? m_iUTC : -m_iUTC);
			else
			{
				wcscat (dmtfValue + 21, L"+");
				wcscat (dmtfValue + 22, WILD3);
			}
		}

		*pbsValue = SysAllocString (dmtfValue);
		hr = WBEM_S_NO_ERROR;
	}
	
	return hr;

}


//***************************************************************************
//
//  SCODE CWbemDateTime::put_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		bsValue		new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDateTime::PutValue( BSTR bsValue) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	// First check that the value is the right length
	if (bsValue && (WBEMDT_DMTF_LEN == wcslen (bsValue)))
	{
		bool err = false;
		long iYear = 0, iMonth = 1, iDay = 1, iHours = 0, iMinutes = 0, 
		iSeconds = 0, iMicroseconds = 0, iUTC = 0;
		VARIANT_BOOL bYearSpecified = VARIANT_TRUE, 
		bMonthSpecified = VARIANT_TRUE, 
		bDaySpecified = VARIANT_TRUE, 
		bHoursSpecified = VARIANT_TRUE, 
		bMinutesSpecified = VARIANT_TRUE, 
		bSecondsSpecified = VARIANT_TRUE, 
		bMicrosecondsSpecified = VARIANT_TRUE, 
		bUTCSpecified = VARIANT_TRUE, 
		bIsInterval = VARIANT_TRUE;

		LPWSTR pValue = (LPWSTR) bsValue;
		
		// Check whether its an interval
		if (ISINTERVAL(pValue [WBEMDT_DMTF_UPOS]))
		{
			// Years and months are as nothing to us in interval land
			bYearSpecified = VARIANT_FALSE;
			bMonthSpecified = VARIANT_FALSE;

			// Check that everything is a digit apart from
			// the interval separator
			for (int i = 0; i < WBEMDT_DMTF_LEN; i++)
			{
				if ((WBEMDT_DMTF_UPOS != i) && 
					(WBEMDT_DMTF_SPOS != i) && !iswdigit (pValue [i]))
				{
					err = true;
					break;
				}
			}

			if (!err)
			{
				// Now check all is within bounds
				err = !(CheckField (pValue, 8, bDaySpecified, iDay, WBEMDT_MAX_DAYINT, WBEMDT_MIN_DAYINT) &&
					(VARIANT_TRUE == bDaySpecified) &&
					CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
					(VARIANT_TRUE == bHoursSpecified) &&
					CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
					(VARIANT_TRUE == bMinutesSpecified) &&
					CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
					(VARIANT_TRUE == bSecondsSpecified) &&
					(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
					CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
					(VARIANT_TRUE == bMicrosecondsSpecified) &&
					CheckUTC (pValue+21, bUTCSpecified, iUTC, false));
				
			}
		}
		else
		{
			// assume it's a datetime
			bIsInterval = VARIANT_FALSE;

			err = !(CheckField (pValue, 4, bYearSpecified, iYear, WBEMDT_MAX_YEAR, WBEMDT_MIN_YEAR) &&
				CheckField (pValue+4, 2, bMonthSpecified, iMonth, WBEMDT_MAX_MONTH, WBEMDT_MIN_MONTH) &&
				CheckField (pValue+6, 2, bDaySpecified, iDay, WBEMDT_MAX_DAY, WBEMDT_MIN_DAY) &&
				CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
				CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
				CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
				(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
				CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
				CheckUTC (pValue+21, bUTCSpecified, iUTC));
		}

		if (!err)
		{
			m_iYear = iYear;
			m_iMonth = iMonth;
			m_iDay = iDay;
			m_iHours = iHours;
			m_iMinutes = iMinutes;
			m_iSeconds = iSeconds;
			m_iMicroseconds = iMicroseconds;
			m_iUTC = iUTC;
			m_bYearSpecified = bYearSpecified;
			m_bMonthSpecified = bMonthSpecified;
			m_bDaySpecified = bDaySpecified;
			m_bHoursSpecified = bHoursSpecified;
			m_bMinutesSpecified = bMinutesSpecified;
			m_bSecondsSpecified = bSecondsSpecified;
			m_bMicrosecondsSpecified = bMicrosecondsSpecified;
			m_bUTCSpecified = bUTCSpecified;
			m_bIsInterval = bIsInterval;
			hr = S_OK;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckField
//
//  DESCRIPTION:
//
//  Check a string-based datetime field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		len				number of characters in the value
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		maxValue		maximum numeric value allowed for this field
//		minValue		minimum numeric value allowed for this field
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckField (
		LPWSTR			pValue,
		ULONG			len,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		long			maxValue,
		long			minValue
	)
{
	bool status = true;
	bIsSpecified = VARIANT_FALSE;

	for (ULONG i = 0; i < len; i++)
	{
		if (ISWILD(pValue [i]))
		{
			if (VARIANT_TRUE == bIsSpecified)
			{
				status = false;
				break;
			}
		}
		else if (!iswdigit (pValue [i]))
		{
			status = false;
			break;
		}
		else
			bIsSpecified = VARIANT_TRUE;
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [9];
			
			wcsncpy (temp, pValue, len);
			temp [len] = NULL;
			iValue = wcstol (temp, &dummy, 10);
		}
	}
	
	return status;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckUTC
//
//  DESCRIPTION:
//
//  Check a string-based UTC field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		bParseSign		whether first character should be a sign (+/-) or
//						a : (for intervals)
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckUTC (
		LPWSTR			pValue,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		bool			bParseSign
	)
{
	bool status = true;
	bool lessThanZero = false;
	bIsSpecified = VARIANT_FALSE;

	// Check if we have a signed offset
	if (bParseSign)
	{
		if (ISMINUS(pValue [0]))
			lessThanZero = true;
		else if (!ISPLUS(pValue [0]))
			status = false;
	}
	else
	{
		if (!ISINTERVAL(pValue[0]))
			status = false;
	}

	if (status)
	{
		// Check remaining are digits or wildcars
		for (int i = 1; i < 4; i++)
		{
			if (ISWILD(pValue [i]))
			{
				if (VARIANT_TRUE == bIsSpecified)
				{
					status = false;
					break;
				}
			}
			else if (!iswdigit (pValue [i]))
			{
				status = false;
				break;
			}
			else
				bIsSpecified = VARIANT_TRUE;
		}
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [4];
			
			wcsncpy (temp, pValue+1, 3);
			temp [3] = NULL;
			iValue = wcstol (temp, &dummy, 10);

			if (lessThanZero)
				iValue = -iValue;
		}
	}
	
	return status;
}


//***************************************************************************
//
//  SCODE CWbemDateTime::GetVarDate
//
//  DESCRIPTION:
//
//  Retrieve the value in Variant form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pVarDate		holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime::GetVarDate( 
        IN VARIANT_BOOL bIsLocal,
		OUT DATE *pVarDate) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	if (NULL == pVarDate)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = WBEM_E_FAILED;
		}
		else
		{	
			SYSTEMTIME sysTime;
			sysTime.wYear = ( WORD ) m_iYear;
			sysTime.wMonth = ( WORD ) m_iMonth;
			sysTime.wDay = ( WORD ) m_iDay;
			sysTime.wHour = ( WORD ) m_iHours;
			sysTime.wMinute = ( WORD ) m_iMinutes;
			sysTime.wSecond = ( WORD ) m_iSeconds;
			sysTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
				
			if (VARIANT_TRUE == bIsLocal)
			{
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.

				// Coerce the time to GMT first
				WBEMTime wbemTime (sysTime);
				
				if (!wbemTime.GetDMTF (sysTime))
					return WBEM_E_INVALID_SYNTAX;
			}

			double dVarDate;

			if (SystemTimeToVariantTime (&sysTime, &dVarDate))
			{
				*pVarDate = dVarDate;
				hr = S_OK;
			}
		}
	}

	return hr;
}
    
//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	if (TRUE == VariantTimeToSystemTime (dVarDate, &sysTime))
	{
		long offset = 0;

		if (VARIANT_TRUE == bIsLocal)
		{
			WBEMTime wbemTime (sysTime);
			if (!wbemTime.GetDMTF (sysTime, offset))
				return WBEM_E_INVALID_SYNTAX;
		}

		m_iYear = sysTime.wYear;
		m_iMonth = sysTime.wMonth;
		m_iDay = sysTime.wDay;
		m_iHours = sysTime.wHour;
		m_iMinutes = sysTime.wMinute;
		m_iSeconds = sysTime.wSecond;
		m_iMicroseconds = sysTime.wMilliseconds * 1000;
		m_iUTC = offset;

		m_bYearSpecified = VARIANT_TRUE,	
		m_bMonthSpecified = VARIANT_TRUE, 
		m_bDaySpecified = VARIANT_TRUE, 
		m_bHoursSpecified = VARIANT_TRUE, 
		m_bMinutesSpecified = VARIANT_TRUE, 
		m_bSecondsSpecified = VARIANT_TRUE, 
		m_bMicrosecondsSpecified = VARIANT_TRUE, 
		m_bUTCSpecified = VARIANT_TRUE, 
		m_bIsInterval = VARIANT_FALSE;			

		hr = S_OK;
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetFileTimeDate( 
        /*[in]*/ FILETIME fFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	long offset = 0;

	if (VARIANT_TRUE == bIsLocal)
	{
		WBEMTime wbemTime (fFileTime);
		if (!wbemTime.GetDMTF (sysTime, offset))
			return WBEM_E_INVALID_SYNTAX;
	}
	else
	{
		WBEMTime wbemTime (fFileTime);
		wbemTime.GetSYSTEMTIME(&sysTime);
	}

	m_iYear = sysTime.wYear;
	m_iMonth = sysTime.wMonth;
	m_iDay = sysTime.wDay;
	m_iHours = sysTime.wHour;
	m_iMinutes = sysTime.wMinute;
	m_iSeconds = sysTime.wSecond;
	m_iMicroseconds = sysTime.wMilliseconds * 1000;
	m_iUTC = offset;

	m_bYearSpecified = VARIANT_TRUE,	
	m_bMonthSpecified = VARIANT_TRUE, 
	m_bDaySpecified = VARIANT_TRUE, 
	m_bHoursSpecified = VARIANT_TRUE, 
	m_bMinutesSpecified = VARIANT_TRUE, 
	m_bSecondsSpecified = VARIANT_TRUE, 
	m_bMicrosecondsSpecified = VARIANT_TRUE, 
	m_bUTCSpecified = VARIANT_TRUE, 
	m_bIsInterval = VARIANT_FALSE;			

	hr = S_OK;

	return hr;
}


// These are here rather than wbemtime.h so we don't have to doc/support
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

CWbemDateTime::WBEMTime :: WBEMTime ( const FILETIME &ft )	
{
	FileTimeToui64(&ft, &m_uTime);
}

LONG CWbemDateTime::WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTimeSpan &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const	CWbemDateTime::WBEMTime & CWbemDateTime::WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
	FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
	{
		// now assign using a FILETIME.
		*this = t_ft;
	}
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const CWbemDateTime::WBEMTime & CWbemDateTime::WBEMTime::operator=(const FILETIME & ft)
{
	FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CWbemDateTime::WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
	if ((pst == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	FILETIME t_ft;

	if (GetFILETIME(&t_ft))
	{
		if (!FileTimeToSystemTime(&t_ft, pst))
		{
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CWbemDateTime::WBEMTime::GetFILETIME(FILETIME * pft) const
{
	if ((pft == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset)
//
//  Description:  Gets the time in DMTF string local datetime format as a 
//	SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this - WBEMTimeSpan(offset);
            else
               wt = *this + WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st)
//
//  Description:  Gets the time in as local SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            long offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this + WBEMTimeSpan(offset);
            else
               wt = *this - WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

BOOL CWbemDateTime::Preceeds ( CWbemDateTime &a_Time )
{
	BOOL t_Truth = TRUE ;

	SYSTEMTIME t_ThisTime ;
	t_ThisTime.wYear = ( WORD ) m_iYear;
	t_ThisTime.wMonth = ( WORD ) m_iMonth;
	t_ThisTime.wDay = ( WORD ) m_iDay;
	t_ThisTime.wHour = ( WORD ) m_iHours;
	t_ThisTime.wMinute = ( WORD ) m_iMinutes;
	t_ThisTime.wSecond = ( WORD ) m_iSeconds;
	t_ThisTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
		
	SYSTEMTIME t_ArgTime ;
	t_ArgTime.wYear = ( WORD ) a_Time.m_iYear;
	t_ArgTime.wMonth = ( WORD ) a_Time.m_iMonth;
	t_ArgTime.wDay = ( WORD ) a_Time.m_iDay;
	t_ArgTime.wHour = ( WORD ) a_Time.m_iHours;
	t_ArgTime.wMinute = ( WORD ) a_Time.m_iMinutes;
	t_ArgTime.wSecond = ( WORD ) a_Time.m_iSeconds;
	t_ArgTime.wMilliseconds = ( WORD ) ( a_Time.m_iMicroseconds/1000 ) ;

	t_Truth = CompareSYSTEMTIME ( & t_ThisTime , & t_ArgTime ) < 0 ;

	return t_Truth ;
}

HRESULT CWbemDateTime::GetSystemTimeDate (

	SYSTEMTIME &fSystemTime
)
{
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	return S_OK ;
}

HRESULT CWbemDateTime::GetFileTimeDate (

	FILETIME &fFileTime
)
{
	SYSTEMTIME fSystemTime ;
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	if ( FileTimeToSystemTime ( & fFileTime , & fSystemTime ) ) 
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_FAILED ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\os.cpp ===
#include "PreComp.h"
#undef POLARITY
#include "os.h"
#include <autoptr.h>

namespace OS
{

bool unicodeOS_ = unicodeOS();
bool secureOS_ = unicodeOS(); 

DWORD convert2ansi(const wchar_t* unicode,  wmilib::auto_buffer<char>& ansi)
{
  if (unicode)
  {
    size_t class_len = wcslen(unicode);
    ansi  = wmilib::auto_buffer<char>(new char[2*class_len+1],2*class_len+1);
    if (ansi.get() == 0)
      return ERROR_NOT_ENOUGH_MEMORY;
    if (wcstombs(ansi.get(),unicode, 2*class_len+1)==-1)
      return ERROR_NO_UNICODE_TRANSLATION;
  }
  return ERROR_SUCCESS;
};
 
bool unicodeOS()
{
    OSVERSIONINFOA OsVersionInfoA;
    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);
    return (OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT);
};

	HRESULT CoImpersonateClient()
	{
	if (secureOS_)
		return ::CoImpersonateClient();
	else
		return S_OK;
	}

LONG RegOpenKeyExW (HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
	if (unicodeOS_)
		return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
	size_t key_len = wcslen(lpSubKey);
	wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
	if (ansi_key.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
		return ERROR_NO_UNICODE_TRANSLATION;
	
	return ::RegOpenKeyExA(hKey, ansi_key.get(), ulOptions, samDesired, phkResult);
};

LONG RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
	if (unicodeOS_)
		return ::RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

	wmilib::auto_buffer<char> ansi_class;
	if (lpClass)
	{
	  size_t class_len = wcslen(lpClass);
	  ansi_class  = wmilib::auto_buffer<char>(new char[2*class_len+1]);
	  if (ansi_class.get() == 0)
	    return ERROR_NOT_ENOUGH_MEMORY;
	  if (wcstombs(ansi_class.get(),lpClass, 2*class_len+1)==-1)
	    return ERROR_NO_UNICODE_TRANSLATION;
	};

	size_t key_len = wcslen(lpSubKey);
	wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
	
	if (ansi_key.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
		return ERROR_NO_UNICODE_TRANSLATION;
	
	return ::RegCreateKeyExA(hKey, ansi_key.get(), Reserved, ansi_class.get(), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
};

LONG RegEnumKeyExW (HKEY hKey,DWORD dwIndex,LPWSTR lpName,LPDWORD lpcName,LPDWORD lpReserved,LPWSTR lpClass,LPDWORD lpcClass,PFILETIME lpftLastWriteTime)
{
if (unicodeOS_)
	return ::RegEnumKeyExW(hKey,dwIndex,lpName,lpcName,lpReserved,lpClass,lpcClass,lpftLastWriteTime);

DWORD nameLength = *lpcName ;
wmilib::auto_buffer<char> ansi_name(new char[(*lpcName)*2]);
if (ansi_name.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;

LONG return_code = ::RegEnumKeyExA(hKey,dwIndex,ansi_name.get(),&nameLength,0, 0, 0,lpftLastWriteTime);

if (return_code == ERROR_SUCCESS)
{
	mbstowcs(lpName, ansi_name.get(), *lpcName);
	*lpcName = nameLength;
}
return return_code;
};

LONG RegDeleteKeyW (HKEY hKey, LPCWSTR lpSubKey)
{
if (unicodeOS_)
	return ::RegDeleteKeyW(hKey, lpSubKey);

size_t key_len = wcslen(lpSubKey);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

return ::RegDeleteKeyA(hKey, ansi_key.get());
};



LONG RegQueryValueExW( HKEY hKey,  LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,  LPDWORD lpcbData )
{
if (unicodeOS_)
	::RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

size_t key_len = wcslen(lpValueName);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpValueName, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

LONG available_size = *lpcbData;
LONG return_code = ::RegQueryValueExA(hKey, ansi_key.get(), lpReserved, lpType, lpData, lpcbData);
if (lpData==0)
{
*lpcbData *= 2;
return return_code;
}

if (return_code == ERROR_SUCCESS && (*lpType == REG_EXPAND_SZ || *lpType == REG_SZ))
{
	wmilib::auto_buffer<BYTE> tempData(new BYTE[*lpcbData]);
	if (tempData.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	memcpy(tempData.get(), lpData, *lpcbData);
	const char * src = (char *)tempData.get();
	wchar_t * dst = (wchar_t*)lpData;

	if (*lpType==REG_SZ)
		*lpcbData = (mbstowcs(dst, src, available_size)+1)*sizeof(wchar_t);
	else
	{
		// Not Implemented
		return ERROR_NOT_ENOUGH_MEMORY;
	};
}
return return_code;
};

LONG RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
if (unicodeOS_)
	::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

size_t key_len = wcslen(lpValueName);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpValueName, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

if (dwType==REG_EXPAND_SZ || dwType==REG_SZ)
{
	const wchar_t * src = reinterpret_cast<const wchar_t*>(lpData);
	size_t value_len = cbData / sizeof(wchar_t) ;
	wmilib::auto_buffer<char> ansi_value (new char[2*value_len+1]);
	if (ansi_value.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	char * dest = ansi_value.get();
	
	if (dwType==REG_SZ)
	{
		if ((value_len = wcstombs(dest,src, value_len)+1)==-1)
			return ERROR_NO_UNICODE_TRANSLATION;
	} 
	else
	{
		// Not Implemented
		return ERROR_NOT_ENOUGH_MEMORY;
	};
	return ::RegSetValueExA(hKey, ansi_key.get(), Reserved, dwType, (const BYTE*)ansi_value.get(), value_len);
}
return ::RegSetValueExA(hKey, ansi_key.get(), Reserved, dwType, lpData, cbData);
}

BOOL GetProcessTimes(
  HANDLE hProcess,           // handle to process
  LPFILETIME lpCreationTime, // process creation time
  LPFILETIME lpExitTime,     // process exit time
  LPFILETIME lpKernelTime,   // process kernel-mode time
  LPFILETIME lpUserTime      // process user-mode time
)
{
	if (unicodeOS_)
		return ::GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
	FILETIME zero = {0, 0};
	*lpCreationTime = zero;
	*lpExitTime = zero;
	*lpKernelTime = zero;
	*lpUserTime = zero;
	return 1;
};

  HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName )
  {
  if (unicodeOS_)
    return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
  
  wmilib::auto_buffer<char> name;
  DWORD res = convert2ansi(lpName, name);
  if (res == ERROR_SUCCESS)
    return ::CreateEventA(lpEventAttributes, bManualReset, bInitialState, name.get());
  else
    ::SetLastError(res);
  return NULL;
  }

  HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bInitialOwner, LPCWSTR lpName )
  {
  if (unicodeOS_)
    return ::CreateMutexW(lpEventAttributes, bInitialOwner, lpName);
  
  wmilib::auto_buffer<char> name;
  DWORD res = convert2ansi(lpName, name);
  if (res == ERROR_SUCCESS)
    return ::CreateMutexA(lpEventAttributes, bInitialOwner, name.get());
  else
    ::SetLastError(res);
  return NULL;
  }



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provobjectsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include "CGlobals.h"
#include "ProvObjectSink.h"

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Begin_IWbemObjectSink (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_IWbemObjectSink , 
						IID_IWbemObjectSink , 
						m_InterceptedSink , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_Internal_IWbemObjectSink , 
						IID_Internal_IWbemObjectSink , 
						m_Internal_InterceptedSink , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_IWbemObjectSink , 
				IID_IWbemObjectSink , 
				m_InterceptedSink , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_InterceptedSink ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_Internal_IWbemObjectSink , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_IWbemObjectSink , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: End_IWbemObjectSink (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_Internal_IWbemObjectSink , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_IWbemObjectSink , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_IWbemSyncObjectSink :: CCommon_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
#ifdef INTERNAL_IDENTIFY
		m_Internal_InterceptedSink ( NULL ) ,
		m_ProxyContainer ( a_Allocator , ProxyIndex_ObjectSink_Size , MAX_PROXIES )
#endif
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_Dependant ( a_Dependant )
{
	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;

#ifdef INTERNAL_IDENTIFY
		HRESULT t_TempResult = m_InterceptedSink->QueryInterface ( IID_Internal_IWbemObjectSink , ( void ** ) & m_Internal_InterceptedSink ) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_IWbemSyncObjectSink :: ~CCommon_IWbemSyncObjectSink ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CCommon_IWbemSyncObjectSink :: CallBackInternalRelease ()
{
#ifdef INTERNAL_IDENTIFY
	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;
#endif
	
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

#ifdef INTERNAL_IDENTIFY

	if ( m_Internal_InterceptedSink )
	{
		m_Internal_InterceptedSink->Release () ;
	}
#endif

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CCommon_IWbemSyncObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: AddRef ( void )
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

#ifdef INTERNAL_IDENTIFY

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
#endif

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = Helper_Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;

#ifdef DBG
		if ( FAILED ( t_Result ) )
		{
			OutputDebugString ( L"\nCCommon_IWbemSyncObjectSink :: Indicate - Failure () " ) ;
		}
#endif
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	BOOL t_Impersonating ;
	IUnknown *t_OldContext ;
	IServerSecurity *t_OldSecurity ;
	BOOL t_IsProxy ;
	IUnknown *t_Interface ;
	BOOL t_Revert ;
	IUnknown *t_Proxy ;
	DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
	HANDLE t_IdentifyToken = NULL ;

	HRESULT t_Result = Begin_IWbemObjectSink (

		t_ProcessIdentifier ,
		t_IdentifyToken ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity ,
		t_IsProxy ,
		t_Interface ,
		t_Revert ,
		t_Proxy 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_IdentifyToken )
		{
			WmiInternalContext t_InternalContext ;
			t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
			t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

			t_Result = ( ( Internal_IWbemObjectSink * ) t_Interface )->Internal_Indicate (

				t_InternalContext ,
				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
		else
		{

			t_Result = ( ( IWbemObjectSink * ) t_Interface )->Indicate (

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}

		End_IWbemObjectSink (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	BOOL t_Impersonating ;
	IUnknown *t_OldContext ;
	IServerSecurity *t_OldSecurity ;
	BOOL t_IsProxy ;
	IUnknown *t_Interface ;
	BOOL t_Revert ;
	IUnknown *t_Proxy ;
	DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
	HANDLE t_IdentifyToken = NULL ;

	HRESULT t_Result = Begin_IWbemObjectSink (

		t_ProcessIdentifier ,
		t_IdentifyToken ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity ,
		t_IsProxy ,
		t_Interface ,
		t_Revert ,
		t_Proxy 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_StringParam = NULL ;
		if ( a_StringParam )
		{
			t_StringParam = SysAllocString ( a_StringParam ) ;
			if ( t_StringParam == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemObjectSink * ) t_Interface )->Internal_SetStatus (

					t_InternalContext ,
					a_Flags ,
					a_Result ,
					t_StringParam ,
					a_ObjectParam
				) ;
			}
			else
			{

				t_Result = ( ( IWbemObjectSink * ) t_Interface )->SetStatus (

					a_Flags ,
					a_Result ,
					t_StringParam ,
					a_ObjectParam
				) ;
			}
		}

		SysFreeString ( t_StringParam ) ;

		End_IWbemObjectSink (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;
	}

	return t_Result ;
}

#else

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = m_InterceptedSink->Indicate (

		a_ObjectCount ,
		a_ObjectArray
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_StringParam = NULL ;
	if ( a_StringParam )
	{
		t_StringParam = SysAllocString ( a_StringParam ) ;
		if ( t_StringParam == NULL )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_InterceptedSink->SetStatus (

			a_Flags ,
			a_Result ,
			t_StringParam ,
			a_ObjectParam
		) ;

		SysFreeString ( t_StringParam ) ;
	}

	return t_Result ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCCommon_IWbemSyncObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = Helper_SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = Helper_SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = Helper_SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_Batching_IWbemSyncObjectSink :: CCommon_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink ( 

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Queue ( a_Allocator ) ,
		m_Size ( 0 ),
		m_CriticalSection(NOTHROW_LOCK)
{
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_Batching_IWbemSyncObjectSink :: ~CCommon_Batching_IWbemSyncObjectSink ()
{
	IWbemClassObject *t_ClassObject ;
	WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_ClassObject->Release () ;

		t_StatusCode = m_Queue.DeQueue () ;
	}

	m_Queue.UnInitialize () ;

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SinkInitialize () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection );
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_Queue.Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	if ( m_GateClosed == 0 )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
			{
				if ( a_ObjectArray [ t_Index ] )
				{
					ULONG t_ObjectSize = 0 ;
					_IWmiObject *t_Object ;
					HRESULT t_TempResult = a_ObjectArray [ t_Index ]->QueryInterface ( IID__IWmiObject , ( void ** ) & t_Object ) ;
					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_TempResult = t_Object->GetObjectMemory (

							NULL ,
							0 ,
							& t_ObjectSize
						);

						if ( t_TempResult == WBEM_E_BUFFER_TOO_SMALL )
						{
							if ( ( t_ObjectSize + m_Size ) < ProviderSubSystem_Common_Globals :: GetTransmitSize () )
							{
								WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
									a_ObjectArray [ t_Index ]->AddRef () ;
									m_Size = m_Size + t_ObjectSize ;
								}			
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								ULONG t_Count = m_Queue.Size () + 1 ;
								IWbemClassObject **t_Array = new IWbemClassObject * [ t_Count ] ;
								if ( t_Array )
								{
									IWbemClassObject *t_ClassObject ;
									WmiStatusCode t_StatusCode ;

									t_Array [ t_Count - 1 ] = a_ObjectArray [ t_Index ] ;

									ULONG t_InnerIndex = 0 ;
									while ( ( t_StatusCode = m_Queue.Top ( t_ClassObject ) ) == e_StatusCode_Success )
									{
										t_Array [ t_InnerIndex ] = t_ClassObject ;

										t_InnerIndex ++ ;

										t_StatusCode = m_Queue.DeQueue() ;
									}

									m_Size = 0 ;

									WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

									t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

									for ( t_InnerIndex = 0 ; t_InnerIndex < t_Count - 1 ; t_InnerIndex ++ )
									{
										t_Array [ t_InnerIndex ]->Release () ;
									}

									delete [] t_Array ;

									t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
									if ( t_StatusCode == e_StatusCode_Success )
									{
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
						}

						t_Object->Release () ;
					}
				}
			}

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

			return t_Result ;
		}
		else
		{
			return WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		return WBEM_E_SHUTTING_DOWN ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_COMPLETE:
		{
			if ( m_GateClosed == 0 )
			{
				WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE );
				if ( t_StatusCode == e_StatusCode_Success )
				{
					LONG t_Count = m_Queue.Size () ;
					if ( t_Count )
					{
						IWbemClassObject **t_Array = new IWbemClassObject * [ m_Queue.Size () ] ;
						if ( t_Array )
						{
							for ( LONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								IWbemClassObject *t_ClassObject ;
								WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
									t_Array [ t_Index ] = t_ClassObject ;

									t_StatusCode = m_Queue.DeQueue () ;
								}
							}

							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

							for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								if ( t_Array [ t_Index ] )
								{
									t_Array [ t_Index ]->Release () ;
								}
							}

							delete [] t_Array ;
						}
						else
						{
							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				a_Result = t_Result ;
			}

			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;

		default:
		{
			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provreginfo.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#undef POLARITY

#include <typeinfo.h>
#include <stdio.h>
#include <sddl.h>

#include <wbemint.h>
#include <genlex.h>
#include <sql_1.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvDnf.h"
#include "ProvRegInfo.h"
#include "DateTime.h"
#include "ssdlhelper.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_SecureSvcHostProviders [] =
{
	L"{266c72d4-62e8-11d1-ad89-00c04fd8fdff}"	,	// "LogFileEventConsumer"
    L"{266c72e6-62e8-11d1-ad89-00c04fd8fdff}"   ,	// "NTEventLogEventConsumer"    
	L"{29F06F0C-FB7F-44A5-83CD-D41705D5C525}"	,	// "Non Com provider"
	L"{405595AA-1E14-11d3-B33D-00105A1F4AAF}"	,	// "Microsoft WMI Transient Provider"
	L"{405595AB-1E14-11d3-B33D-00105A1F4AAF}"	,	// "Microsoft WMI Transient Reboot Event Provider"
	L"{74E3B84C-C7BE-4e0a-9BD2-853CA72CD435}"	,	// "Microsoft WMI Updating Consumer Assoc Provider"
	L"{7879E40D-9FB5-450a-8A6D-00C89F349FCE}"	,	// "Microsoft WMI Forwarding Event Provider"
	L"{7F598975-37E0-4a67-A992-116680F0CEDA}"	,	// "Msft_ProviderSubSystem"	
	L"{9877D8A7-FDA1-43F9-AEEA-F90747EA66B0}"	,	// "WMI Kernel Trace Event Provider"
	L"{A3A16907-227B-11d3-865D-00C04F63049B}"	,	// "Microsoft WMI Updating Consumer Provider"
	L"{A83EF168-CA8D-11d2-B33D-00104BCC4B4A}"	,	// "WBEMCORE
	L"{AD1B46E8-0AAC-401b-A3B8-FCDCF8186F55}"	,	// "Microsoft WMI Forwarding Consumer Provider"
	L"{C486ABD2-27F6-11d3-865E-00C04F63049B}"	,	// "Microsoft WMI Template Provider"
	L"{D6C74FF3-3DCD-4c23-9F58-DD86F371EC73}"	,	// "Microsoft WMI Forwarding Ack Event Provider"
	L"{FD18A1B2-9E61-4e8e-8501-DB0B07846396}"		// "Microsoft WMI Template Association Provider"
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_SecureLocalSystemProviders [] =
{
	L"{0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}",		// "WmiEventProv"
	L"{72967901-68EC-11d0-B729-00AA0062CBB7}",		// "RegPropProv"
	L"{B3FF88A4-96EC-4cc1-983F-72BE0EBB368B}",		// "Rsop Logging Mode Provider"
    L"{BE0A9830-2B8B-11d1-A949-0060181EBBAD}",		// "MSIProv"
	L"{D2D588B5-D081-11d0-99E0-00C04FC2F8EC}",		// "WMIProv"
	L"{F0FF8EBB-F14D-4369-BD2E-D84FBF6122D6}",		// "Rsop Planning Mode Provider"
	L"{FA77A74E-E109-11D0-AD6E-00C04FD8FDFF}",		// "RegistryEventProvider"
	L"{FE9AF5C0-D3B6-11CE-A5B6-00AA00680C3F}"		// "RegProv"
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT QuickFind ( wchar_t *a_Clsid , ULONG a_Size , wchar_t **a_Container )
{
	ULONG t_Lower = 0 ;
	ULONG t_Upper = a_Size ;

	while ( t_Lower < t_Upper ) 
	{
		ULONG t_Index = ( t_Lower + t_Upper ) >> 1 ;

		LONG t_Compare = _wcsicmp ( a_Clsid , a_Container [ t_Index ] ) ;
		if ( t_Compare == 0 ) 
		{
			return S_OK ;
		}
		else
		{
			if ( t_Compare < 0 ) 
			{
				t_Upper = t_Index ;
			}
			else
			{
				t_Lower = t_Index + 1 ;
			}
		}
	}

	return WBEM_E_ACCESS_DENIED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid )
{
	return QuickFind ( a_Clsid , sizeof ( g_SecureLocalSystemProviders ) / sizeof ( wchar_t * ) , g_SecureLocalSystemProviders ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid )
{
	return QuickFind ( a_Clsid , sizeof ( g_SecureSvcHostProviders ) / sizeof ( wchar_t * ) , g_SecureSvcHostProviders ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

GENERIC_MAPPING g_ProviderBindingMapping = {

	0 ,
	0 ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_Class = L"__CLASS" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___ObjectProviderCacheControl = L"__ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___EventProviderCacheControl = L"__EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_ClearAfter = L"ClearAfter" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Object = L"Select * from __ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Object = L"__ObjectProviderCacheControl=@" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Event = L"Select * from __EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Event = L"__EventProviderCacheControl=@" ;

LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Query = L"Select * from __ProviderHostQuotaConfiguration" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Path = L"__ProviderHostQuotaConfiguration=@" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryPerHost = L"MemoryPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryAllHosts = L"MemoryAllHosts" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ThreadsPerHost = L"ThreadsPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HandlesPerHost = L"HandlesPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ProcessLimitAllHosts = L"ProcessLimitAllHosts" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ClsidKeyStr = L"CLSID\\" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Null = NULL ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ThreadingModel = L"ThreadingModel" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_InProcServer32 = L"InProcServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_LocalServer32 = L"LocalServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization = L"Synchronization" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_AppId = L"AppId" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Apartment = L"apartment" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Both = L"both";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Free = L"free";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Neutral = L"neutral";

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Ignored = L"ignored" ; 
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_None = L"none" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Supported = L"supported" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Required = L"required" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_RequiresNew = L"requiresnew" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Clsid = L"CLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ClientClsid = L"ClientLoadableCLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Name = L"Name" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultMachineName = L"DefaultMachineName" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_UnloadTimeout = L"UnloadTimeout" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ImpersonationLevel = L"ImpersonationLevel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationReentrancy = L"InitializationReentrancy" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializeAsAdminFirst = L"InitializeAsAdminFirst" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerUserInitialization = L"PerUserInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerLocaleInitialization = L"PerLocaleInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Pure = L"Pure" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Hosting = L"HostingModel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_HostingGroup = L"HostingGroup" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsThrottling = L"SupportsThrottling" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsShutdown = L"SupportsShutdown" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ConcurrentIndependantRequests = L"ConcurrentIndependantRequests";
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsSendStatus = L"SupportsSendStatus" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_OperationTimeoutInterval = L"OperationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationTimeoutInterval = L"InitializationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsQuotas = L"SupportsQuotas" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Enabled = L"Enabled" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Version = L"Version" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SecurityDescriptor = L"SecurityDescriptor" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCore [] = L"WmiCore" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCoreOrSelfHost [] = L"WmiCoreOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SelfHost [] = L"SelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ClientHost [] = L"ClientHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Decoupled [] = L"Decoupled:Com" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DecoupledColon [] = L"Decoupled:Com:" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHost [] = L"LocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] = L"LocalSystemHostOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedNetworkServiceHost [] = L"NetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalServiceHost [] = L"LocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedUserHost [] = L"UserHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_NonCom [] = L"Decoupled:NonCom" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost [] = L"DefaultNetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalServiceHost [] = L"DefaultLocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedUserHost [] = L"DefaultUserHost" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultHostingRegistryKey = L"Software\\Microsoft\\WBEM\\Providers\\Configuration\\" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_CacheRefreshInterval = L"CacheRefreshInterval" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_PerUserSchema = L"PerUserSchema" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReSynchroniseOnNamespaceOpen = L"ReSynchroniseOnNamespaceOpen" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Version = L"Version" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ResultSetQueries = L"ResultSetQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_UnSupportedQueries = L"UnSupportedQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReferencedSetQueries = L"ReferencedSetQueries" ;

LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;

LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;

LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;

LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: CServerObject_GlobalRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Object_UnloadTimeout ( NULL ) ,
	m_Event_UnloadTimeout ( NULL ) ,
	m_Object_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Event_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: ~CServerObject_GlobalRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Object_UnloadTimeout )
	{
		SysFreeString ( m_Object_UnloadTimeout ) ;
	}

	if ( m_Event_UnloadTimeout )
	{
		SysFreeString ( m_Event_UnloadTimeout ) ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPWSTR &a_UnloadTimeout ,
	ULONG &a_UnloadTimeoutMilliSeconds 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_ClearAfter )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_ClearAfter , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
				}

				a_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
				if ( a_UnloadTimeout )
				{
					CWbemDateTime t_Interval ;
					t_Result = t_Interval.PutValue ( a_UnloadTimeout ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT_BOOL t_Bool = VARIANT_FALSE ;
						t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
						if ( t_Bool == VARIANT_TRUE )
						{
							LONG t_MicroSeconds = 0 ;
							LONG t_Seconds = 0 ;
							LONG t_Minutes = 0 ;
							LONG t_Hours = 0 ;
							LONG t_Days = 0 ;

							t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
							t_Interval.GetSeconds ( & t_Seconds ) ;
							t_Interval.GetMinutes ( & t_Minutes ) ;
							t_Interval.GetHours ( & t_Hours ) ;
							t_Interval.GetDay ( & t_Days ) ;

							a_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
														  ( t_Hours * 60 * 60 * 1000 ) +
														  ( t_Minutes * 60 * 1000 ) +
														  ( t_Seconds * 1000 ) +
														  ( t_MicroSeconds / 1000 ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
					a_UnloadTimeout = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Object ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject ,
				m_Object_UnloadTimeout ,
				m_Object_UnloadTimeoutMilliSeconds
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Event ) ;
		if ( t_ObjectPath ) 
		{
			IWbemClassObject *t_ClassObject = NULL ;

			t_Result = m_Repository->GetObject ( 

				t_ObjectPath ,
				0 ,
				m_Context , 
				& t_ClassObject , 
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = QueryProperties ( 

					a_Mask ,
					t_ClassObject ,
					m_Event_UnloadTimeout ,
					m_Event_UnloadTimeoutMilliSeconds
				) ;

				t_ClassObject->Release () ;
			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: CServerObject_HostQuotaRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_MemoryPerHost ( 0 ) ,
	m_MemoryAllHosts ( 0 ) ,
	m_ThreadsPerHost ( 0 ) ,
	m_HandlesPerHost ( 0 ) ,
	m_ProcessLimitAllHosts ( 0 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: ~CServerObject_HostQuotaRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastObject = NULL ;

	t_Result = a_Object->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_MemoryAllHosts )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			HRESULT t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryAllHosts ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryAllHosts = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryAllHosts = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
		}

		if ( a_Mask & e_MemoryPerHost )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			HRESULT t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryPerHost ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryPerHost = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryPerHost = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
		}

		t_FastObject->Release () ;
	}

	if ( a_Mask & e_ThreadsPerHost )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_ThreadsPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ThreadsPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ThreadsPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_HandlesPerHost )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_HandlesPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_HandlesPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_HandlesPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_ProcessLimitAllHosts )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_ProcessLimitAllHosts , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ProcessLimitAllHosts = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ProcessLimitAllHosts = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_HostQuotas_Path ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject 
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: CServerObject_ComRegistration ()

	:	m_ThreadingModel ( e_ThreadingModel_Unknown ) ,
		m_Synchronization ( e_Ignored ) ,
		m_InProcServer32 ( e_Boolean_Unknown ) ,
		m_LocalServer32 ( e_Boolean_Unknown ) ,
		m_Service ( e_Boolean_Unknown ) ,
		m_Loaded ( e_False ) ,
		m_Clsid ( NULL ) ,
		m_AppId ( NULL ) ,
		m_ProviderName ( NULL ) ,
		m_Result ( S_OK )
{
	m_InProcServer32_Path [ 0 ] = 0 ;
	m_LocalServer32_Path [ 0 ] = 0 ;
	m_Server_Name [ 0 ] = 0 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: ~CServerObject_ComRegistration ()
{
	if ( m_AppId )
	{
		SysFreeString ( m_AppId ) ;
	}

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	if ( m_ProviderName )
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ThreadingModel ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_ThreadingModel ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Apartment ) == 0 ) 
		{
			m_ThreadingModel = e_Apartment ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Both ) == 0 ) 
		{
			m_ThreadingModel = e_Both ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Free ) == 0 ) 
		{
			m_ThreadingModel = e_Free ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Neutral ) == 0 )	
		{
			m_ThreadingModel = e_Neutral ;
		}
		else
		{
			m_ThreadingModel = e_ThreadingModel_Unknown ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_Synchronization ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_Synchronization ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Ignored ) == 0 ) 
		{
			m_Synchronization = e_Ignored ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_None ) == 0 ) 
		{
			m_Synchronization = e_None ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Supported ) == 0 )	
		{
			m_Synchronization = e_Supported ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Required ) == 0 )	
		{
			m_Synchronization = e_Required ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_RequiresNew ) == 0 )	
		{
			m_Synchronization = e_RequiresNew ;
		}
		else
		{
			m_Synchronization = e_Synchronization_Unknown ;
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_InProcServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_InProcServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_InProcServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_InProcServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_InProcServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_InProcServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_InProcServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_InProcServer32 = e_True ;

			t_Result = Load_ThreadingModel ( t_Clsid_Key_InProcServer32 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Load_Synchronization ( t_Clsid_Key_InProcServer32 ) ;
			}

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_InProcServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_InProcServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_InProcServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			RegCloseKey ( t_Clsid_Key_InProcServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_InProcServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_LocalServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_LocalServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_LocalServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_LocalServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_LocalServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_LocalServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_LocalServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_LocalServer32 = e_True ;
			m_ThreadingModel = e_Free ;
			m_Synchronization = e_Ignored ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_LocalServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_LocalServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_LocalServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			RegCloseKey ( t_Clsid_Key_LocalServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_LocalServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ServerTypes ( LPCWSTR a_ClsidString )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key , 
		a_ClsidString ,
		L"\\"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_InProcServer32 ( t_Clsid_String_Key ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Load_LocalServer32 ( t_Clsid_String_Key ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
		}

		SysFreeString ( t_Clsid_String_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_AppId ( HKEY a_Clsid_Key )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Clsid_Key ,
	  s_Strings_Reg_AppId ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( m_AppId )
		{
			SysFreeString ( m_AppId ) ;
		}

		m_AppId = SysAllocString ( t_Data ) ;
		if ( m_AppId )
		{
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
	}

	m_Clsid = SysAllocString ( a_Clsid ) ;

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
	}

	m_ProviderName = SysAllocString ( a_ProviderName ) ;

	LPWSTR t_Clsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String , 
		s_Strings_Reg_ClsidKeyStr ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_ServerTypes ( t_Clsid_String ) ;

		HKEY t_Clsid_Key ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_Server_Name ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_Server_Name ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			t_Result = Load_AppId ( t_Clsid_Key	) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_InProcServer32 != e_True && m_LocalServer32 != e_True )
				{
					m_Service = e_True ;
					m_ThreadingModel = e_Free ;
					m_Synchronization = e_Ignored ;
				}
			}

			RegCloseKey ( t_Clsid_Key ) ;
		}

		SysFreeString ( t_Clsid_String ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_Loaded = e_True ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: CServerObject_ComProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Identity ( NULL ) ,
	m_DefaultMachineName ( NULL ) ,
	m_UnloadTimeout ( NULL ) ,
	m_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_OperationTimeout ( NULL ) ,
	m_OperationTimeoutMilliSeconds ( INFINITE ) ,
	m_InitializationTimeout ( NULL ) ,
	m_InitializationTimeoutMilliSeconds ( DEFAULT_PROVIDER_LOAD_TIMEOUT ) ,
	m_Enabled ( TRUE ) ,
	m_SupportsQuotas ( FALSE ) ,
	m_SupportsThrottling ( FALSE ) ,
	m_SupportsSendStatus ( FALSE ) ,
	m_SupportsShutdown ( FALSE ) ,
	m_ConcurrentIndependantRequests ( 0 ) ,
	m_ImpersonationLevel ( e_ImpersonationLevel_Unknown ) ,
	m_InitializationReentrancy ( e_InitializationReentrancy_Namespace ) ,
	m_InitializeAsAdminFirst ( FALSE ) ,
	m_PerUserInitialization ( FALSE ) ,
	m_PerLocaleInitialization ( FALSE ) ,
	m_Pure ( FALSE ) ,
	m_Version ( 1 ) ,
	m_ProviderName ( NULL ) ,
	m_Hosting ( e_Hosting_Undefined ) , // e_Hosting_SharedLocalSystemHost e_Hosting_WmiCore
	m_HostingGroup ( NULL ) ,
	m_Result ( S_OK ) ,
	m_SecurityDescriptor ( NULL ) ,
	m_DecoupledImpersonationRestriction ( TRUE )
{
	ZeroMemory ( & m_CLSID , sizeof ( GUID ) ) ;
	ZeroMemory ( & m_ClientCLSID  , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: ~CServerObject_ComProviderRegistrationV1 ()
{
	if ( m_SecurityDescriptor )
	{
		LocalFree ( m_SecurityDescriptor ) ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Identity )
	{
		m_Identity->Release () ;
	}

	if ( m_DefaultMachineName ) 
	{
		SysFreeString ( m_DefaultMachineName ) ;
	}

	if ( m_UnloadTimeout )
	{
		SysFreeString ( m_UnloadTimeout ) ;
	}

	if ( m_HostingGroup )
	{
		SysFreeString ( m_HostingGroup ) ;
	}

	if ( m_InitializationTimeout )
	{
		SysFreeString ( m_InitializationTimeout ) ;
	}

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDefaultHostingGroup ( 

	Enum_Hosting a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_HostingValue )
	{
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHost ) ;

		}
		break ;

		case e_Hosting_SharedNetworkServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedNetworkServiceHost ) ;
		}
		break ;

		case e_Hosting_SharedLocalServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalServiceHost ) ;
		}
		break ;

		case e_Hosting_SharedUserHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedUserHost ) ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHostingGroup ( 

	LPCWSTR a_Hosting , 
	size_t a_Prefix ,
	Enum_Hosting a_ExpectedHostingValue ,
	Enum_Hosting & a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	size_t t_Length = wcslen ( a_Hosting ) ;

	if ( t_Length > a_Prefix )
	{
		if ( a_Hosting [ a_Prefix ] == L':' ) 
		{
			if ( t_Length > a_Prefix + 1 )
			{
				a_HostingGroup = SysAllocString ( & a_Hosting [ a_Prefix + 1 ] ) ;
				if ( a_HostingGroup )
				{
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				a_HostingValue = a_ExpectedHostingValue ;
			}
			else
			{
				t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}
	else
	{
		t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;

		a_HostingValue = a_ExpectedHostingValue ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define StateAction_Accept		1	// Add the char to the token
#define StateAction_Consume		2	// Consume the char without adding to token
#define StateAction_Pushback	4	// Place the char back in the source buffer for next token
#define StateAction_Not			8	// A match occurs if the char is NOT the one specified
#define StateAction_Linefeed	16	// Increase the source linecount
#define StateAction_Return		32	// Return the indicated token to caller
#define StateAction_Any			64	// wchar_t(0xFFFF) Any character
#define StateAction_Empty		128	// wchar_t(0xFFFE) When subrange is not specified

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry
{
	wchar_t m_LowerRange ;
	wchar_t m_UpperRange ;

	ULONG m_Token ;
	ULONG m_GotoState ;
	ULONG m_Action ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum LexicalStatus
{
	Success ,
	Syntax_Error ,
	Lexical_Error ,
	Failed ,
	Buffer_Too_Small ,
	ImpossibleState ,
	UnexpectedEof ,
	OutOfMemory 
} ;	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TOKEN_IDENTITY			1
#define TOKEN_LEFTPARENTHESIS	2
#define TOKEN_RIGHTPARENTHESIS	3
#define TOKEN_TRUE				4
#define TOKEN_FALSE				5
#define TOKEN_EOF				6
#define TOKEN_ERROR				7

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry g_StateTable [] = {

	' ',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 0
	'\t',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 1
	'a',			'z',				0 ,							8 ,			StateAction_Accept		,		// 2
	'A',			'Z',				0 ,							8 ,			StateAction_Accept		,		// 3
	'(',			65534 ,				TOKEN_LEFTPARENTHESIS ,		0 ,			StateAction_Return		,		// 4
	')',			65534 ,				TOKEN_RIGHTPARENTHESIS ,	0 ,			StateAction_Return		,		// 5
	0,				65534 ,				TOKEN_EOF ,					0 ,			StateAction_Return		,		// 6
	65535,			65534 ,				TOKEN_ERROR ,				0 ,			StateAction_Return		,		// 7

	'a',			'z',				0	,						8 ,			StateAction_Accept		,		// 8
	'A',			'Z',				0	,						8 ,			StateAction_Accept		,		// 9
	65535,			65534 ,				TOKEN_IDENTITY ,			0 ,			StateAction_Pushback | StateAction_Return	// 10
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LexicalStatus LexicalAnalyser_NextToken ( 

	StateTableEntry *a_Dfa , 
	ULONG a_DfaSize ,
	const wchar_t *a_Stream , 
	ULONG a_Position , 
	ULONG &a_Token , 
	ULONG &a_NextPosition , 
	wchar_t *&a_TokenText
)
{
	LexicalStatus t_Status = Success ;

	a_Token = 0 ;
	a_TokenText = NULL ;
	a_NextPosition = a_Position ;

	ULONG t_State = 0 ;
    BOOL t_Read = TRUE ;
	BOOL t_EndOfFile = FALSE ;
    wchar_t t_Current = 0 ;
	ULONG CurrentLine = 0 ;
	wchar_t *t_TokenText = NULL ;
	ULONG t_TokenTextActualSize = 0 ;
	ULONG t_TokenTextBufferSize = 0 ;

    while ( 1 )
	{
		wchar_t t_First = a_Dfa [ t_State ].m_LowerRange ;
		wchar_t t_Last = a_Dfa [ t_State ].m_UpperRange ;
		ULONG t_GotoState = a_Dfa [ t_State ].m_GotoState ;
		ULONG t_ReturnToken = a_Dfa [ t_State ].m_Token ;
		ULONG t_Action = a_Dfa [ t_State ].m_Action ;

        if ( t_Read )
		{
			if ( t_EndOfFile ) 
			{
				t_Status = UnexpectedEof ;

				delete [] t_TokenText ;

				return t_Status ;
			}

            if ( a_NextPosition > wcslen ( a_Stream ) )
			{
				t_Current = 0 ;

				t_EndOfFile = TRUE ;
			}
			else
			{
				t_Current = a_Stream [ a_NextPosition ] ;
			}
		}

        BOOL t_Match = FALSE ;

        if ( t_First == 65535 )
		{
            t_Match = TRUE ;
		}
		else
        {
			if ( t_Last == 65534 )
			{
				if ( t_Current == t_First ) 
				{
					t_Match = TRUE ;
				}
	            else 
				{
					if ( ( t_Action & StateAction_Not ) && ( t_Current != t_First ) )
					{
                		t_Match = TRUE ;
					}
				}
			}
			else
			{
				if ( ( t_Action & StateAction_Not ) && ( ! ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) ) ) )
				{
					t_Match = TRUE ;
				}
				else 
				{
					if ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) )
					{
						t_Match = TRUE ;
					}
				}
			}
        }

        t_Read = FALSE ;

        if ( t_Match )
		{
            if ( t_Action & StateAction_Accept )
			{
				if ( t_TokenText )
				{
					if ( t_TokenTextActualSize < t_TokenTextBufferSize - 1 )
					{
					}
					else
					{
						t_TokenTextBufferSize = t_TokenTextBufferSize + 32 ;
						wchar_t *t_TempTokenText = new wchar_t [ t_TokenTextBufferSize ] ;
						if ( t_TempTokenText )
						{
							CopyMemory ( t_TempTokenText , t_TokenText , ( t_TokenTextActualSize ) * sizeof ( wchar_t ) ) ;

							delete [] t_TokenText ;
							t_TokenText = t_TempTokenText ;
						}
						else
						{
							delete [] t_TokenText ;

							return OutOfMemory ;
						}
					}

					t_TokenText [ t_TokenTextActualSize ] = t_Current ;
					t_TokenText [ t_TokenTextActualSize + 1 ] = 0 ;

					t_TokenTextActualSize ++ ;
				}
				else
				{
					t_TokenTextActualSize = 1 ;
					t_TokenTextBufferSize = 32 ;

					t_TokenText = new wchar_t [ t_TokenTextBufferSize ] ;
					if ( t_TokenText )
					{
						t_TokenText [ 0 ] = t_Current ;
						t_TokenText [ 1 ] = 0 ;
					}
					else
					{
						return OutOfMemory ;
					}
				}

                t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Consume )
			{
               t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Pushback )
			{
                t_Read = TRUE ;

                a_NextPosition = a_NextPosition - 1 ;
            }

            if ( t_Action & StateAction_Linefeed )
			{
                CurrentLine = CurrentLine + 1 ;
			}

			a_NextPosition = a_NextPosition + 1 ;

            if ( t_Action & StateAction_Return )
			{
                a_Token = t_ReturnToken ;
				a_TokenText = t_TokenText ;

				return t_Status ;
			}

            t_State = t_GotoState ;
        }
		else
		{
            t_State = t_State + 1 ;
		}
	}

	delete [] t_TokenText ;

    return ImpossibleState ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDecoupledImpersonationRestriction ( 

	LPCWSTR a_Hosting , 
	BOOL &a_ImpersonationRestriction 
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_Decoupled ) != 0 )
	{
		if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_DecoupledColon , ( sizeof ( s_Strings_Wmi_DecoupledColon ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
		{
			const wchar_t *t_Scan = & a_Hosting [ ( sizeof ( s_Strings_Wmi_DecoupledColon ) - 1 ) / sizeof ( WCHAR ) ] ;

			ULONG t_Position = 0 ; 
			ULONG t_Token = 0 ;
			ULONG t_NextPosition = 0 ; 
			wchar_t *t_FoldText = NULL ;

			LexicalStatus t_Status = LexicalAnalyser_NextToken ( 

				g_StateTable ,
				sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
				t_Scan ,
				t_Position , 
				t_Token , 
				t_NextPosition , 
				t_FoldText
			) ;

			if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( _wcsicmp ( t_FoldText , L"FoldIdentity" ) == 0 ) )
			{
				wchar_t *t_IgnoreText = NULL ;

				t_Position = t_NextPosition ;

				t_Status = LexicalAnalyser_NextToken ( 

					g_StateTable ,
					sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
					t_Scan ,
					t_Position , 
					t_Token , 
					t_NextPosition , 
					t_IgnoreText
				) ;

				delete [] t_IgnoreText ;

				if ( ( t_Status == Success ) && ( t_Token == TOKEN_LEFTPARENTHESIS ) )
				{
					wchar_t *t_ValueText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_ValueText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( _wcsicmp ( t_ValueText , L"TRUE" ) == 0 ) )
					{
						a_ImpersonationRestriction = TRUE ;
					}
					else if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( _wcsicmp ( t_ValueText , L"FALSE" ) == 0 ) )
					{
						a_ImpersonationRestriction = FALSE ;
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_ValueText ;
				}
				else
				{
					t_Status = Syntax_Error ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_RIGHTPARENTHESIS ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_EOF ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}
			}
			else
			{
				t_Status = Syntax_Error ;
			}

			delete [] t_FoldText ;

			if ( t_Status != Success ) 
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHosting ( 

	LPCWSTR a_Hosting , 
	Enum_Hosting & a_HostingValue ,
	LPWSTR &a_HostingGroup ,
	BOOL & a_ImpersonationRestriction
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCore ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCore ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCoreOrSelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCoreOrSelfHost ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_SelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_SelfHost ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_ClientHost ) == 0 )
	{
		a_HostingValue = e_Hosting_ClientHost ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_Decoupled , ( sizeof ( s_Strings_Wmi_Decoupled ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		a_HostingValue = e_Hosting_Decoupled ;

		t_Result = GetDecoupledImpersonationRestriction ( 

			a_Hosting , 
			a_ImpersonationRestriction 
		) ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_NonCom ) == 0 )
	{
		a_HostingValue = e_Hosting_NonCom ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedLocalSystemHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHostOrSelfHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedLocalSystemHostOrSelfHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedNetworkServiceHost , ( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedNetworkServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalServiceHost , ( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedLocalServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedUserHost , ( sizeof ( s_Strings_Wmi_SharedUserHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedUserHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedUserHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPCWSTR a_ProviderName 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Name )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_ProviderName ) 
					{
						SysFreeString ( m_ProviderName ) ;
					}

					m_ProviderName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_ProviderName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Enabled )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Enabled , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Enabled = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Enabled = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Clsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Clsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_CLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = m_ClsidServer.Load ( (LPCWSTR) t_Variant.bstrVal , a_ProviderName ) ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_CLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ClientClsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ClientClsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_ClientCLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ClientCLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_DefaultMachineName )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_DefaultMachineName , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
					}

					m_DefaultMachineName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_DefaultMachineName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
						m_DefaultMachineName = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnloadTimeout )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_UnloadTimeout , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
					}

					m_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_UnloadTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_UnloadTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ImpersonationLevel )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ImpersonationLevel , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_ImpersonationLevel = e_Impersonate_None ;		
						}
						break ;

						case 1:
						{
							m_ImpersonationLevel = e_Impersonate ;
						}
						break ;

						default:
						{
							if ( m_Version > 1 )
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
							else
							{
								m_ImpersonationLevel = e_Impersonate_None ;	
							}
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ImpersonationLevel = e_Impersonate_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsSendStatus )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsSendStatus , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsSendStatus = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsSendStatus = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsShutdown )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsShutdown , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsShutdown = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsShutdown = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsQuotas )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsQuotas , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsQuotas = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsQuotas = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_OperationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_OperationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
					}

					m_OperationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_OperationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_OperationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_OperationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
					}

					m_InitializationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_InitializationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_InitializationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_InitializationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsThrottling )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsThrottling , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsThrottling = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsThrottling = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ConcurrentIndependantRequests )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ConcurrentIndependantRequests , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					m_ConcurrentIndependantRequests = t_Variant.lVal ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ConcurrentIndependantRequests = 0 ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationReentrancy )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationReentrancy , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Clsid ;		
						}
						break ;

						case 1:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Namespace ;
						}
						break ;

						case 2:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_None ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializationReentrancy = e_InitializationReentrancy_Namespace;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializeAsAdminFirst )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializeAsAdminFirst , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_InitializeAsAdminFirst = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializeAsAdminFirst = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerUserInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerLocaleInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerLocaleInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerLocaleInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerLocaleInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Pure )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Pure , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Pure = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Pure = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Hosting )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Hosting , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = GetHosting ( t_Variant.bstrVal , m_Hosting , m_HostingGroup , m_DecoupledImpersonationRestriction ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
#ifdef UNIQUE_HOST
						if ( m_HostingGroup )
						{
							SysFreeString ( m_HostingGroup ) ;
						}

						m_HostingGroup = SysAllocString ( GetProviderName () ) ;
						if ( m_HostingGroup == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
#else
#endif
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Hosting = e_Hosting_SharedLocalSystemHostOrSelfHost ;

#ifdef UNIQUE_HOST
					m_HostingGroup = SysAllocString ( GetProviderName () ) ;
#else
					m_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost ) ;
#endif
					if ( m_HostingGroup == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( GetHosting () )
		{
			case e_Hosting_NonCom:
			case e_Hosting_Decoupled:
			{
			}
			break ;

			default:
			{
				if ( GetClsidServer ().GetProviderClsid () == NULL )
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			break ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SecurityDescriptor )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SecurityDescriptor , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					BOOL t_Status = SSDL_wrapper::ConvertStringSecurityDescriptorToSecurityDescriptor (

						t_Variant.bstrVal ,
						SDDL_REVISION_1 ,
						( PSECURITY_DESCRIPTOR * ) & m_SecurityDescriptor,
						NULL 
					) ;

					if ( t_Status )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SecurityDescriptor = NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_ObjectPath = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_ObjectPath , 
		L"__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\""
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( m_Identity )
		{
			m_Identity->Release () ;
		}

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& m_Identity , 
			NULL 
		) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				m_Identity ,
				a_ProviderName 
			) ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Identity )
				{
					m_Identity->Release () ;
				}

				t_Result = m_Repository->GetObject ( 

					t_ObjectPath ,
					0 ,
					m_Context , 
					& m_Identity , 
					NULL 
				) ;
			
				if ( SUCCEEDED ( t_Result ) )
				{
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;
				
					LONG t_VarType = 0 ;
					LONG t_Flavour = 0 ;

					t_Result = m_Identity->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Variant.vt == VT_BSTR )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								m_Identity ,
								t_Variant.bstrVal
							) ;
						}

						VariantClear ( & t_Variant ) ;
					}
				}

			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
				}
			}
		}

		VariantClear ( & t_Variant ) ;

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1 :: CServerObject_InstanceProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1::~CServerObject_InstanceProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsGet )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsDelete )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsDelete = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsEnumeration )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsEnumeration = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsBatching )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsBatching = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsTransactions )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsTransactions = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_QuerySupportLevels  )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					if ( t_Count ) 
					{
						for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
						{
							BSTR t_Element ;
							if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
							{
								if ( _wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
								}
								else if ( _wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
								}
								else if ( _wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
								}
								else if ( _wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}

								SysFreeString ( t_Element ) ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_QuerySupportLevels = e_QuerySupportLevels_None ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_InteractionType )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				switch ( t_Variant.lVal )
				{
					case 0:
					{
						m_InteractionType = e_InteractionType_Pull ;
					}
					break ;

					case 1:
					{
						m_InteractionType = e_InteractionType_Push ;
					}
					break ;

					case 2:
					{
						m_InteractionType = e_InteractionType_PushVerify ;
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
					break ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_InteractionType = e_InteractionType_Pull ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery ( 

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1 :: CServerObject_ClassProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_ReSynchroniseOnNamespaceOpen ( FALSE ) ,
	m_PerUserSchema ( FALSE ) ,
	m_HasReferencedSet( FALSE ),
	m_CacheRefreshInterval ( NULL ) ,
	m_CacheRefreshIntervalMilliSeconds ( 0 ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_ResultSetQueryTreeCount ( 0 ) ,
	m_UnSupportedQueryTreeCount ( 0 ) ,
	m_ReferencedSetQueryTreeCount ( 0 ) ,
	m_ResultSetQueryTree ( NULL ) ,
	m_UnSupportedQueryTree ( NULL ) ,
	m_ReferencedSetQueryTree ( NULL ) ,
	m_ProviderName ( NULL ) ,
	m_Version ( 1 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1::~CServerObject_ClassProviderRegistrationV1 ()
{
	if ( m_ResultSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ResultSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ResultSetQueryTree [ t_Index ] )
			{
				delete m_ResultSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ResultSetQueryTree ;
	}

	if ( m_UnSupportedQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_UnSupportedQueryTreeCount ; t_Index ++ )
		{
			if ( m_UnSupportedQueryTree [ t_Index ] )
			{
				delete m_UnSupportedQueryTree [ t_Index ] ;
			}
		}

		delete [] m_UnSupportedQueryTree ;
	}

	if ( m_ReferencedSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ReferencedSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ReferencedSetQueryTree [ t_Index ] )
			{
				delete m_ReferencedSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ReferencedSetQueryTree ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_ProviderName ) 
	{
		delete [] m_ProviderName ;
	}

	if ( m_CacheRefreshInterval )
	{
		SysFreeString ( m_CacheRefreshInterval ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: ParseQuery ( 

	ULONG &a_Count ,
	WmiTreeNode **&a_Root , 
	SAFEARRAY *a_Array
)

{
	HRESULT t_Result = S_OK ;

	if ( SafeArrayGetDim ( a_Array ) == 1 )
	{
		LONG t_Dimension = 1 ; 

		LONG t_Lower ;
		SafeArrayGetLBound ( a_Array , t_Dimension , & t_Lower ) ;

		LONG t_Upper ;
		SafeArrayGetUBound ( a_Array , t_Dimension , & t_Upper ) ;

		LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

		a_Root = NULL ;
		a_Count = t_Count ;

		if ( t_Count )
		{
			a_Root = new WmiTreeNode * [ t_Count ] ;
			if ( a_Root ) 
			{
				ZeroMemory ( a_Root , sizeof ( WmiTreeNode * ) * t_Count ) ;

				for ( LONG t_ElementIndex = t_Lower ; SUCCEEDED ( t_Result ) && ( t_ElementIndex <= t_Upper ) ; t_ElementIndex ++ )
				{
					BSTR t_Element ;
					if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( a_Array , &t_ElementIndex , & t_Element ) ) )
					{
						QueryPreprocessor t_PreProcessor ;

						IWbemQuery *t_QueryAnalyser = NULL ;
						t_Result = CoCreateInstance (

							CLSID_WbemQuery ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemQuery ,
							( void ** ) & t_QueryAnalyser
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							switch ( t_PreProcessor.Query ( t_Element , t_QueryAnalyser ) )
							{
								case QueryPreprocessor :: State_True:
								{
									WmiTreeNode *t_Root = NULL ;

									switch ( t_PreProcessor.PreProcess ( m_Context , t_QueryAnalyser , t_Root ) )
									{
										case QueryPreprocessor :: State_True:
										{
											a_Root [ t_ElementIndex ] = t_Root ;
										}
										break ;

										case QueryPreprocessor :: State_Error:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break;

										default:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break ;
									}
								}
								break ;

								case QueryPreprocessor :: State_Error:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break;

								default:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break ;

							}

							t_QueryAnalyser->Release () ;
						}

						SysFreeString ( t_Element ) ;
					}
				}

				if ( FAILED ( t_Result ) ) 
				{
					for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
					{
						delete a_Root [ t_ElementIndex ] ;
					}

					delete [] a_Root ;
					a_Root = NULL ;
					a_Count = 0 ;

					if ( m_Version == 1 )
					{
						t_Result = S_OK ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsPut )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsPut = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsGet )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsGet = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsDelete )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsDelete = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsEnumeration )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsEnumeration = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsBatching )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsBatching = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsTransactions )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsTransactions = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserSchema )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_PerUserSchema , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserSchema = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserSchema = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReSynchroniseOnNamespaceOpen )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_ReSynchroniseOnNamespaceOpen , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_ReSynchroniseOnNamespaceOpen = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ReSynchroniseOnNamespaceOpen = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_QuerySupportLevels  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
				{
					if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
					{
						LONG t_Dimension = 1 ; 

						LONG t_Lower ;
						SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

						LONG t_Upper ;
						SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

						LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

						if ( t_Count )
						{
							for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
							{
								BSTR t_Element ;
								if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
								{
									if ( _wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
									}
									else if ( _wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
									}
									else if ( _wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
									}
									else if ( _wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
									}
									else
									{
										t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
									}

									SysFreeString ( t_Element ) ;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_QuerySupportLevels = e_QuerySupportLevels_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InteractionType )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InteractionType = e_InteractionType_Pull ;
						}
						break ;

						case 1:
						{
							m_InteractionType = e_InteractionType_Push ;
						}
						break ;

						case 2:
						{
							m_InteractionType = e_InteractionType_PushVerify ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InteractionType = e_InteractionType_Pull ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ResultSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ResultSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ResultSetQueryTreeCount , m_ResultSetQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnSupportedQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_UnSupportedQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_UnSupportedQueryTreeCount , m_UnSupportedQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReferencedSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ReferencedSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ReferencedSetQueryTreeCount , m_ReferencedSetQueryTree , t_Variant.parray ) ;

					// Backwards compatibility.
					// W2K code, Query is not really parsed, as long as there is a
					// value, m_HasReferencedSet is TRUE.
					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , 1 , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , 1 , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					m_HasReferencedSet = ( ( t_Upper - t_Lower ) + 1 ) > 0;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_CacheRefreshInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_CacheRefreshInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
					}

					m_CacheRefreshInterval = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_CacheRefreshInterval )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_CacheRefreshInterval ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_CacheRefreshIntervalMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
						m_CacheRefreshInterval = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( ( m_InteractionType == e_InteractionType_Pull ) && ( ( m_SupportsEnumeration == FALSE ) || ( m_SupportsGet == FALSE ) ) )
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			m_ProviderName = new wchar_t [ wcslen ( a_ProviderName ) + 1 ] ;
			if ( m_ProviderName ) 
			{
				wcscpy ( m_ProviderName , a_ProviderName ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemPathKeyList *t_Keys = NULL ;

						t_Result = a_Provider->GetKeyList (

							& t_Keys 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ULONG t_ProviderNameLength = 0 ;
							ULONG t_Type = 0 ;

							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								NULL ,
								NULL ,
								& t_ProviderNameLength ,
								m_ProviderName ,
								& t_Type
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								m_ProviderName = new wchar_t [ ( t_ProviderNameLength / sizeof ( wchar_t ) ) + 1 ] ;
								if ( m_ProviderName ) 
								{
									t_Result = t_Keys->GetKey (

										0 ,
										0 ,
										NULL ,
										NULL ,
										& t_ProviderNameLength ,
										m_ProviderName ,
										& t_Type
									) ;
								}
							}

							t_Keys->Release () ;
						}
					}
					
					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath * a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( FAILED ( t_Result ) )
	{
		m_Result = t_Result ;
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1 :: CServerObject_MethodProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsMethods ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1::~CServerObject_MethodProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_SupportsMethods = TRUE ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1 :: CServerObject_DynamicPropertyProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1::~CServerObject_DynamicPropertyProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsGet )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1 :: CServerObject_EventProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1::~CServerObject_EventProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1 :: CServerObject_EventConsumerProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1::~CServerObject_EventConsumerProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1 :: CServerObject_ProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Result ( S_OK ) ,
	m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1::~CServerObject_ProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	t_Result = m_ComRegistration.SetContext ( 

		a_Context ,
		a_Namespace ,
		a_Repository
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_InstanceProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_ClassProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_MethodProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_PropertyProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventConsumerProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = m_ComRegistration.QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepository ( 
	
						a_Mask ,
						a_Scope , 
						t_Variant.bstrVal
					) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: ObjectProvider ()
{
	BOOL t_Supported =	GetClassProviderRegistration ().Supported () ||
						GetInstanceProviderRegistration ().Supported () ||
						GetMethodProviderRegistration ().Supported () || 
						GetPropertyProviderRegistration ().Supported () ;

	return t_Supported ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: EventProvider ()
{
	BOOL t_Supported =	GetEventConsumerProviderRegistration ().Supported () ||
						GetEventProviderRegistration ().Supported () ;

	return t_Supported ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provtree.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <typeinfo.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvTree.h"

WmiTreeNode *WmiTreeNode :: Copy () 
{
	TypeId_TreeNode t_Type = m_Type ;
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_Type , t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\cglobals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _CommonGlobals_H
#define _CommonGlobals_H

#include <pssException.h>
#include <HelperFuncs.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <Queue.h>
#include <PQueue.h>
#include <ReaderWriter.h>
#include <Cache.h>
#include <locks.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYNCPROV_BATCH_TRANSMIT_SIZE 0x40000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MASK_PROVIDER_BINDING_BIND 1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern void DumpThreadTokenSecurityDescriptor () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_FACILITY_MASK (0x0FFF0000)
#define HRESULT_FACILITY_FUNC(X) ((X&HRESULT_FACILITY_MASK)>>16)
#define HRESULT_SEVERITY_MASK (0xC0000000)
#define HRESULT_SEVERITY_FUNC(X) ((X&HRESULT_SEVERITY_MASK)>>30)

#define HRESULT_ERROR_SERVER_UNAVAILABLE	1722L
#define HRESULT_ERROR_CALL_FAILED_DNE		1727L

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MAX_PROXIES 512

class ProxyContainer
{
private:

	WmiAllocator &m_Allocator ;
#if 1
	WmiStack <IUnknown *,8> **m_ContainerArray ;
#else
	WmiQueue <IUnknown *,8> **m_ContainerArray ;
#endif
	CriticalSection m_CriticalSection ;
	ULONG m_TopSize ;
	ULONG m_CurrentSize ;
	ULONG m_ProxyCount ;
	BOOL m_Initialized ;

public:

	ProxyContainer ( 

		WmiAllocator &a_Allocator ,
		ULONG a_ProxyCount ,
		ULONG a_TopSize 

	) : m_Allocator ( a_Allocator ) ,
		m_ContainerArray ( NULL ) ,
		m_TopSize ( a_TopSize ) ,
		m_CurrentSize ( 0 ) ,
		m_ProxyCount ( a_ProxyCount ) ,
		m_Initialized ( FALSE ) ,
		m_CriticalSection(NOTHROW_LOCK)
	{
	}

	~ProxyContainer ()
	{
		UnInitialize () ;
	}

	WmiStatusCode Initialize () 
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 1
		m_ContainerArray = new WmiStack <IUnknown *,8> * [ m_ProxyCount ] ;
#else
		m_ContainerArray = new WmiQueue <IUnknown *,8> * [ m_ProxyCount ] ;
#endif
		if ( m_ContainerArray )
		{
			t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				m_Initialized = TRUE ;

 				for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
					m_ContainerArray [ t_Index ] = NULL ;
				}

				for ( t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
#if 1
					WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiStack <IUnknown *,8> ( m_Allocator ) ;
#else
					WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiQueue <IUnknown *,8> ( m_Allocator ) ;
#endif

					if ( t_Container )
					{
						t_StatusCode = t_Container->Initialize () ;
						if ( t_StatusCode != e_StatusCode_Success )
						{
							break ;
						}
					}
					else
					{
						t_StatusCode = e_StatusCode_OutOfMemory ;

						break ;
					}
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode UnInitialize ()
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		if ( m_ContainerArray )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
			{
#if 1
				WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#else
				WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#endif
				if ( t_Container )
				{
					IUnknown *t_Top = NULL ;
					WmiStatusCode t_StatusCode ;
					while ( ( t_StatusCode = t_Container->Top ( t_Top ) ) == e_StatusCode_Success )
					{
						t_Top->Release () ;
#if 1
						t_StatusCode = t_Container->Pop () ;
#else
						t_StatusCode = t_Container->DeQueue () ;
#endif
					}

					t_StatusCode = t_Container->UnInitialize () ;

					delete t_Container ;
				}
			}

			delete [] m_ContainerArray ;

			m_ContainerArray = NULL ;
		}

		if ( m_Initialized )
		{
			WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
			m_Initialized = FALSE ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode Return ( 

		IUnknown *a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Push ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->EnQueue ( a_Element ) ;
#endif
	}

	WmiStatusCode Top ( 

		IUnknown *&a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#endif
	}

	WmiStatusCode Reserve ( ULONG a_Index )
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Pop () ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->DeQueue () ;
#endif
	}
	
	ULONG GetTopSize () { return m_TopSize ; } ;
	ULONG GetCurrentSize () { return m_CurrentSize ; } ;
	BOOL GetInitialized () { return m_Initialized ; }

	void SetCurrentSize ( ULONG a_CurrentSize ) { m_CurrentSize = a_CurrentSize ; }

	CriticalSection &GetCriticalSection () { return m_CriticalSection ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderSubSystem_Common_Globals
{
public:

	static LPCWSTR s_Wql ;
	static LPCWSTR s_Provider ;

	static WORD s_System_ACESize ;
	static WORD s_LocalService_ACESize ;
	static WORD s_NetworkService_ACESize ;
	static WORD s_LocalAdmins_ACESize ;

	static ACCESS_ALLOWED_ACE *s_Provider_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalAdmins_ACE ;

	static ACCESS_ALLOWED_ACE *s_Token_All_Access_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalAdmins_ACE ;

	static SECURITY_DESCRIPTOR *s_MethodSecurityDescriptor ;
	static SECURITY_DESCRIPTOR *s_DefaultDecoupledSD ;

	static ULONG s_TransmitBufferSize ;
	static ULONG s_DefaultStackSize ;

public:

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT CreateRemoteInstance ( 

		LPCWSTR a_Server ,
		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT GetNamespaceServerPath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_ServerNamespacePath
	) ;

	static HRESULT GetNamespacePath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_NamespacePath
	) ;

	static HRESULT GetPathText (

		IWbemPath *a_Path ,
		wchar_t *&a_ObjectPath
	) ;

	static HRESULT BeginCallbackImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT BeginImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating ,
		DWORD *a_AuthenticationLevel = NULL
	) ;

	static HRESULT EndImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT GetProxy (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT GetProxy (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown ,
		DWORD a_AuthenticationLevel ,
		DWORD a_ImpersonationLevel
	) ;

	static BOOL IsProxy ( IUnknown *a_Unknown ) ;

	static DWORD GetCurrentImpersonationLevel () ;

	static HRESULT EnableAllPrivileges () ;

	static HRESULT EnableAllPrivileges ( HANDLE a_Token ) ;

	static HRESULT SetAnonymous ( IUnknown *a_Proxy ) ;

	static HRESULT SetCallState (

		IUnknown *a_Interface ,
		BOOL &a_Revert
	) ;

	static HRESULT RevertCallState ( 

		BOOL a_Revert
	) ;

	static HRESULT SetProxyState (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT SetProxyState_SvcHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_SvcHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value ) ;
	static HRESULT Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value ) ;
	static HRESULT Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength ) ;

	static HRESULT Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value ) ;
	static HRESULT Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value ) ;
	static HRESULT Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength ) ;

	static HRESULT UnMarshalRegistration (

		IUnknown **a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	static HRESULT ReleaseRegistration (

		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT IsDependantCall ( IWbemContext *a_Parent , IWbemContext *a_ChildContext , BOOL &a_DependantCall ) ;

	static HRESULT Set_Uint64 (

		_IWmiObject *a_Instance ,
		wchar_t *a_Name ,
		const UINT64 &a_Uint64
	) ;

	static HRESULT Set_Uint32 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const DWORD &a_Uint32
	) ;

	static HRESULT Set_Uint16 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const WORD &a_Uint16
	) ;

	static HRESULT Set_Bool ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const BOOL &a_Bool
	) ;

	static HRESULT Set_String ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *a_String
	) ;

	static HRESULT Set_DateTime ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		FILETIME a_Time
	) ;

	static HRESULT Set_Byte_Array ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		BYTE *a_Bytes ,
		WORD a_BytesCount 
	) ;

	static HRESULT Get_Uint64 (

		_IWmiObject *a_Instance ,
		wchar_t *a_Name ,
		UINT64 &a_Uint64 ,
		BOOL &a_Null
	) ;

	static HRESULT Get_Uint32 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		DWORD &a_Uint32 ,
		BOOL &a_Null
	) ;

	static HRESULT Get_Uint16 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		WORD &a_Uint16 ,
		BOOL &a_Null 
	) ;

	static HRESULT Get_Bool ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		BOOL &a_Bool ,
		BOOL &a_Null
	) ;

	static HRESULT Get_String ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *&a_String ,
		BOOL &a_Null
	) ;

	static HRESULT Get_DateTime ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		FILETIME &a_Time ,
		BOOL &a_Null
	) ;

	static HRESULT Check_SecurityDescriptor_CallIdentity ( 

		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping,
		SECURITY_DESCRIPTOR *defaultSD = s_MethodSecurityDescriptor
	) ;

	static HRESULT AdjustSecurityDescriptorWithSid ( 

		SID *a_OwnerSid , 
		SID *a_GroupSid , 
		DWORD a_Access ,
		SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
		SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
	) ;

	static HRESULT CreateSystemAces () ;

	static HRESULT DeleteSystemAces () ;

	static HRESULT ConstructIdentifyToken_SvcHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT ConstructIdentifyToken_PrvHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT CheckAccess (
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) ;

	static HRESULT GetUserSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetGroupSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetAceWithProcessTokenUser ( 
					
		DWORD a_ProcessIdentifier ,
		WORD &a_AceSize ,
		ACCESS_ALLOWED_ACE *&a_Ace 
	) ;

	static HRESULT SinkAccessInitialize (

		SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
		SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
	) ;

	static HRESULT CreateMethodSecurityDescriptor () ;

	static HRESULT DeleteMethodSecurityDescriptor () ;

	static SECURITY_DESCRIPTOR *GetMethodSecurityDescriptor () 
	{
		return s_MethodSecurityDescriptor ;
	}

	static SECURITY_DESCRIPTOR * GetDefaultDecoupledSD() 
	{ 
		return s_DefaultDecoupledSD ;
	}
	static DWORD InitializeTransmitSize () ;
	static DWORD GetTransmitSize () { return s_TransmitBufferSize ; }

	static DWORD InitializeDefaultStackSize () ;
	static DWORD GetDefaultStackSize () { return s_DefaultStackSize ; }

} ;

#endif // _CommonGlobals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\datetime.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  datetime.h
//
//  alanbos  20-Jan-00   Created.
//
//  Datetime helper implementation.
//
//***************************************************************************

#ifndef _DATETIME_H_
#define _DATETIME_H_

#define WBEMDT_DMTF_LEN		25
#define WBEMDT_DMTF_SPOS	14
#define WBEMDT_DMTF_UPOS	21

#define	WBEMDT_MIN_YEAR		0
#define	WBEMDT_MAX_YEAR		9999
#define WBEMDT_MIN_MONTH	1
#define WBEMDT_MAX_MONTH	12
#define WBEMDT_MIN_DAY		1
#define WBEMDT_MAX_DAY		31
#define WBEMDT_MIN_DAYINT	0
#define WBEMDT_MAX_DAYINT	999999
#define	WBEMDT_MIN_HOURS	0
#define	WBEMDT_MAX_HOURS	23
#define	WBEMDT_MIN_MINUTES	0
#define	WBEMDT_MAX_MINUTES	59
#define	WBEMDT_MIN_SECONDS	0
#define	WBEMDT_MAX_SECONDS	59
#define	WBEMDT_MIN_MICROSEC	0
#define	WBEMDT_MAX_MICROSEC	999999
#define	WBEMDT_MIN_UTC		-720
#define	WBEMDT_MAX_UTC		720

#define INVALID_TIME 0xffffffffffffffff

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemDateTime
//
//  DESCRIPTION:
//
//  Implements the ISWbemDateTime interface.  
//
//***************************************************************************

class CWbemDateTime 
{
private:
	// Private helper class for all the messy business
	class WBEMTime 
	{
		private:
			class WBEMTimeSpan 
			{
				private:

					ULONGLONG m_Time;
					friend class WBEMTime;

				public:

					WBEMTimeSpan ( 
						int iMinutes 
					) 
					{
						m_Time = iMinutes * 60;
						m_Time *= 10000000;
				}
			};

		public:

			WBEMTime ()													{ m_uTime = INVALID_TIME ; }
			WBEMTime ( const SYSTEMTIME &st )							{ *this = st ; }
			WBEMTime ( const FILETIME &ft )	;

			const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
			const WBEMTime &operator= ( const FILETIME &ft ) ;

			WBEMTime    operator+ ( const WBEMTimeSpan &ts ) const;
			WBEMTime    operator- ( const WBEMTimeSpan &sub ) const;

			BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
			BOOL GetFILETIME ( FILETIME *pst ) const;

			BOOL GetDMTF ( SYSTEMTIME &st, long &offset ) const;
			BOOL GetDMTF ( SYSTEMTIME &st ) const;

			void Clear ( void )											{ m_uTime = INVALID_TIME ; }

			bool IsOk () const											{ return m_uTime != INVALID_TIME ? true : false; }
			
			static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);

		private:
			ULONGLONG m_uTime;
	};

	VARIANT_BOOL		m_bYearSpecified;
	VARIANT_BOOL		m_bMonthSpecified;
	VARIANT_BOOL		m_bDaySpecified;
	VARIANT_BOOL		m_bHoursSpecified;
	VARIANT_BOOL		m_bMinutesSpecified;
	VARIANT_BOOL		m_bSecondsSpecified;
	VARIANT_BOOL		m_bMicrosecondsSpecified;
	VARIANT_BOOL		m_bUTCSpecified;
	VARIANT_BOOL		m_bIsInterval;
	
	long				m_iYear;
	long				m_iMonth;
	long				m_iDay;
	long				m_iHours;
	long				m_iMinutes;
	long				m_iSeconds;
	long				m_iMicroseconds;
	long				m_iUTC;

	bool				CheckField (
								LPWSTR			pValue,
								ULONG			len,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								long			maxValue,
								long			minValue
						);

	bool				CheckUTC (
								LPWSTR			pValue,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								bool			bParseSign = true
						);

protected:
public:
    
    CWbemDateTime(void);
    virtual ~CWbemDateTime(void);

	// ISWbemDateTime methods

    HRESULT GetValue ( BSTR *value ) ;
    
    HRESULT PutValue ( BSTR value ) ;

    HRESULT GetYear ( long *value ) 
	{
		*value = m_iYear;

		return S_OK;
	}
    
    HRESULT PutYear ( long value ) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		if ((value > WBEMDT_MAX_YEAR) || (value < WBEMDT_MIN_YEAR))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iYear = value;

		return hr;
	}		

    HRESULT GetMonth ( long *value ) 
	{
		*value = m_iMonth;

		return S_OK;
	}
    
    HRESULT PutMonth ( long value ) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		if ((value > WBEMDT_MAX_MONTH) || (value < WBEMDT_MIN_MONTH))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMonth = value;

		return hr;
	}		

	HRESULT GetDay ( long *value ) 
	{
		*value = m_iDay;

		return S_OK;
	}
    
    HRESULT PutDay ( long value ) 
	{
		HRESULT hr = S_OK ;

		if (((VARIANT_TRUE == m_bIsInterval) && ((value > WBEMDT_MAX_DAYINT) || (value < WBEMDT_MIN_DAYINT))) ||
			((VARIANT_FALSE == m_bIsInterval) &&((value > WBEMDT_MAX_DAY) || (value < WBEMDT_MIN_DAY))))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iDay = value;

		return hr;
	}		

	HRESULT GetHours ( long *value ) 
	{
		*value = m_iHours;

		return S_OK;
	}
    
    HRESULT PutHours ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_HOURS) || (value < WBEMDT_MIN_HOURS))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iHours = value;

		return hr;
	}		

		
	HRESULT GetMinutes ( long *value ) 
	{
		*value = m_iMinutes;

		return S_OK;
	}
    
    HRESULT PutMinutes ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_MINUTES) || (value < WBEMDT_MIN_MINUTES))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMinutes = value;

		return hr;
	}		

	HRESULT GetSeconds ( long *value ) 
	{
		*value = m_iSeconds;

		return S_OK;
	}
        
    HRESULT PutSeconds ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_SECONDS) || (value < WBEMDT_MIN_SECONDS))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iSeconds = value;

		return hr;
	}		


	HRESULT GetMicroseconds ( long *value ) 
	{
		*value = m_iMicroseconds;

		return S_OK;
	}
    
    HRESULT PutMicroseconds ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_MICROSEC) || (value < WBEMDT_MIN_MICROSEC))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMicroseconds = value;

		return hr;
	}		

	HRESULT GetUTC ( long *value ) 
	{
		*value = m_iUTC;

		return S_OK;
	}
    
    HRESULT PutUTC( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_UTC) || (value < WBEMDT_MIN_UTC))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iUTC = value;

		return hr;
	}		

	HRESULT GetYearSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bYearSpecified; 

		return S_OK;
	}
    
    HRESULT PutYearSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED ;
		else
			m_bYearSpecified = value;

		return hr;
	}
    
    HRESULT GetMonthSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMonthSpecified; 

		return S_OK;
	}
    
    HRESULT PutMonthSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED;
		else
			m_bMonthSpecified = value;
		
		return hr;
	}

	HRESULT GetDaySpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bDaySpecified; 

		return S_OK;
	}
    
    HRESULT PutDaySpecified ( VARIANT_BOOL value ) 
	{ 
		m_bDaySpecified = value;

		return S_OK;
	}

	HRESULT GetHoursSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bHoursSpecified; 

		return S_OK;
	}
    
    HRESULT PutHoursSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bHoursSpecified = value;

		return S_OK;
	}
		
	HRESULT GetMinutesSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMinutesSpecified; 

		return S_OK;
	}
        
    HRESULT PutMinutesSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bMinutesSpecified = value;

		return S_OK;
	}

	HRESULT GetSecondsSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bSecondsSpecified; 

		return S_OK;
	}
    
    HRESULT PutSecondsSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bSecondsSpecified = value;

		return S_OK;
	}

	HRESULT GetMicrosecondsSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMicrosecondsSpecified; 

		return S_OK;
	}
    
    HRESULT PutMicrosecondsSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bMicrosecondsSpecified = value;

		return S_OK;
	}

	HRESULT GetUTCSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bUTCSpecified; 

		return S_OK;
	}
    
    HRESULT PutUTCSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED;
		else
			m_bUTCSpecified = value;
	
		return hr;
	}

	HRESULT GetIsInterval ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bIsInterval; 

		return S_OK;
	}
    
    HRESULT PutIsInterval( VARIANT_BOOL value ) 
	{ 
		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_FALSE == value))
		{
			if (0 == m_iDay)
				m_iDay = 1;
			else if (WBEMDT_MAX_DAY < m_iDay)
				m_iDay = WBEMDT_MAX_DAY;
		}
		else if ((VARIANT_TRUE == value) && (VARIANT_FALSE == m_bIsInterval))
		{
			m_bDaySpecified = VARIANT_TRUE; 
			m_bHoursSpecified = VARIANT_TRUE;
			m_bMinutesSpecified = VARIANT_TRUE;
			m_bSecondsSpecified = VARIANT_TRUE;
			m_bMicrosecondsSpecified = VARIANT_TRUE;
		}

		m_bIsInterval = value;

		return S_OK;
	}

	HRESULT GetVarDate (
 
        VARIANT_BOOL bIsLocal,
		DATE *dVarDate
	) ;
    
    HRESULT SetVarDate ( 

        DATE dVarDate,
		VARIANT_BOOL bIsLocal
	) ;

	HRESULT GetSystemTimeDate (

		SYSTEMTIME &fSystemTime
	) ;

	HRESULT GetFileTimeDate (

		FILETIME &fFileTime
	) ;

	HRESULT SetFileTimeDate ( 

		FILETIME fFileTime,
		VARIANT_BOOL bIsLocal
	) ;

	BOOL Preceeds ( CWbemDateTime &a_Time ) ;
};

#endif // _DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\os.h ===
#ifndef __OS_H__
#define __OS_H__

namespace OS
{
	bool unicodeOS();
	extern bool unicodeOS_;
	extern bool secureOS_;
	
	LONG RegOpenKeyExW (HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
	LONG RegCreateKeyExW (HKEY hKey, LPCTSTR lpSubKey,DWORD Reserved, LPTSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
	LONG RegEnumKeyExW (HKEY hKey,DWORD dwIndex,LPTSTR lpName,LPDWORD lpcName,LPDWORD lpReserved,LPTSTR lpClass,LPDWORD lpcClass,PFILETIME lpftLastWriteTime);
	LONG RegDeleteKeyW (HKEY hKey, LPCTSTR lpSubKey);
	LONG RegQueryValueExW(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
);

LONG RegSetValueExW(
  HKEY hKey,           // handle to key
  LPCTSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
);

	HRESULT CoImpersonateClient();

	BOOL GetProcessTimes(
  HANDLE hProcess,           // handle to process
  LPFILETIME lpCreationTime, // process creation time
  LPFILETIME lpExitTime,     // process exit time
  LPFILETIME lpKernelTime,   // process kernel-mode time
  LPFILETIME lpUserTime      // process user-mode time
);
  
  HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName );
  HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bInitialOwner, LPCWSTR lpName );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\ssdlhelper.cpp ===
#include "precomp.h"
#include <sddl.h>
#include "ssdlhelper.h"

SSDL_wrapper ssdl_wrapper;

SSDL_wrapper::function_type 
SSDL_wrapper::GetFunction(void)
    {
  function_type return_function = DummyConvertStringSecurityDescriptorToSecurityDescriptor;
  if (lock_.acquire())
  {
    return_function = current_function_;
    if (current_function_==0)
    {
      HMODULE advapi = LoadLibrary(L"advapi32.dll");
      if (advapi)
	{
	current_function_ = (function_type)GetProcAddress(advapi,"ConvertStringSecurityDescriptorToSecurityDescriptorW");
	FreeLibrary(advapi);
	}

      if (current_function_==0)
	current_function_ = DummyConvertStringSecurityDescriptorToSecurityDescriptor;
      
      return_function = current_function_;
    }
    lock_.release();
  };
  return return_function;
};

BOOL SSDL_wrapper::ConvertStringSecurityDescriptorToSecurityDescriptor(
  LPCTSTR StringSecurityDescriptor,          // security descriptor string
  DWORD StringSDRevision,                    // revision level
  PSECURITY_DESCRIPTOR *SecurityDescriptor,  // SD
  PULONG SecurityDescriptorSize              // SD size
)
{
  return (ssdl_wrapper.GetFunction())(StringSecurityDescriptor, StringSDRevision, SecurityDescriptor, SecurityDescriptorSize);
};


BOOL SSDL_wrapper::DummyConvertStringSecurityDescriptorToSecurityDescriptor(
  LPCTSTR StringSecurityDescriptor,          // security descriptor string
  DWORD StringSDRevision,                    // revision level
  PSECURITY_DESCRIPTOR *SecurityDescriptor,  // SD
  PULONG SecurityDescriptorSize              // SD size
)
{
if (SecurityDescriptor==0)
  return ERROR_INVALID_PARAMETER;
if (SecurityDescriptorSize)
  *SecurityDescriptorSize = 0;
*SecurityDescriptor = 0;
return TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provdnf.h ===
// (C) 1999-2001 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <stdio.h>
#include <wmiutils.h>

#include "ProvTree.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiTriState
{
	State_False		= 0 ,
	State_True		= 1 ,
	State_Error		= 0xFFFFFFFF
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TypeId_WmiOrNode						1
#define TypeId_WmiAndNode						2
#define TypeId_WmiNotNode						3
#define TypeId_WmiOperatorNode					4
#define TypeId_WmiOperatorEqualNode				5
#define TypeId_WmiOperatorNotEqualNode			6
#define TypeId_WmiOperatorEqualOrGreaterNode	7
#define TypeId_WmiOperatorEqualOrLessNode		8
#define TypeId_WmiOperatorGreaterNode			9
#define TypeId_WmiOperatorLessNode				10
#define TypeId_WmiOperatorLikeNode				11
#define TypeId_WmiOperatorNotLikeNode			12
#define TypeId_WmiOperatorIsANode				13
#define TypeId_WmiOperatorNotIsANode			14
#define TypeId_WmiValueNode						15
#define TypeId_WmiSignedIntegerNode				16	
#define TypeId_WmiUnsignedIntegerNode			17
#define TypeId_WmiStringNode					18
#define TypeId_WmiNullNode						19
#define TypeId_WmiRangeNode						20
#define TypeId_WmiUnsignedIntegerRangeNode		21
#define TypeId_WmiSignedIntegerRangeNode		22
#define TypeId_WmiStringRangeNode				23
#define TypeId_WmiNullRangeNode					24

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiOrNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiAndNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiNotNode , NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		TypeId_TreeNode a_Type , 
		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiRangeNode *GetRange () = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () { return NULL ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrLessNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLessNode , a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorIsANode , a_Node , a_Parent ) {}

	~WmiOperatorIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotIsANode , a_Node , a_Parent ) {}

	~WmiOperatorNotIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = 0 ,
		Function_Upper = 1 ,
		Function_Lower = 2
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiSignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiUnsignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiStringNode ,
			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = towlower ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = towupper ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else
			{
				m_String = SysAllocString ( a_String ) ;
			}
		}
		else
		{
			m_String = NULL ;
		}
	}

	~WmiStringNode ()
	{
		if ( m_String )
		{
			SysFreeString ( m_String ) ;
		}
	} ;

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( BSTR &a_String )
	{
		if ( wcscmp ( L"" , m_String ) == 0 )
		{
			return FALSE ;
		}
		else
		{
			ULONG t_StringLen = wcslen ( m_String ) ;
			wchar_t *t_String = NULL ;

			if ( m_String [ t_StringLen - 1 ] == 0x01 )
			{
				t_String = new wchar_t [ t_StringLen ] ;
				wcsncpy ( t_String , m_String , t_StringLen - 1 ) ;
				t_String [ t_StringLen ] = 0 ;
			}
			else
			{
				t_String = new wchar_t [ t_StringLen + 1 ] ;
				wcscpy ( t_String , m_String ) ;
				t_String [ t_StringLen - 1 ] = t_String [ t_StringLen - 1 ] - 1 ;
			}			
			
			a_String = SysAllocString ( t_String ) ;
			delete [] t_String ;

			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( BSTR &a_String )
	{
		ULONG t_StringLen = wcslen ( m_String ) ;
		wchar_t *t_String = new wchar_t [ t_StringLen + 2 ] ;
		wcscpy ( t_String , m_String ) ;
		t_String [ t_StringLen ] = 0x01 ;
		t_String [ t_StringLen ] = 0x00 ;

		a_String = SysAllocString ( t_String ) ;

		delete [] t_String ;

		return TRUE ;
	}

	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiNullNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

public:

	WmiRangeNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( a_Type , NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		}
		else
		{
			m_PropertyName = NULL ;
		}
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
		{
			SysFreeString ( m_PropertyName ) ;
		}
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;
	
	WmiTriState GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Before ,
		WmiUnsignedIntegerRangeNode *&a_Intersection ,
		WmiUnsignedIntegerRangeNode *&a_After 
	) ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiUnsignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Before ,
		WmiSignedIntegerRangeNode *&a_Intersection ,
		WmiSignedIntegerRangeNode *&a_After 
	) ;

public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiSignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Before ,
		WmiStringRangeNode *&a_Intersection ,
		WmiStringRangeNode *&a_After 
	) ;

public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiStringRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
		{
			m_LowerBound = SysAllocString ( a_LowerBound ) ;
		}
		else
		{
			m_LowerBound = NULL ;
		}

		if ( a_UpperBound )
		{
			m_UpperBound = SysAllocString ( a_UpperBound ) ;
		}
		else
		{
			m_UpperBound = NULL ;
		}
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
		{
			SysFreeString ( m_LowerBound ) ;
		}

		if ( m_UpperBound )
		{
			SysFreeString ( m_UpperBound ) ;
		}
	} ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiNullRangeNode ,
			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount ) ,
		m_RangeContainer ( NULL )
	{
	}

	~Conjunctions () 
	{
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				delete m_RangeContainer [ t_Index ] ;
			}

			delete [] m_RangeContainer ;
		}
	} ;	

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_RangeContainer = new WmiRangeNode * [ m_RangeContainerCount ] ;
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				m_RangeContainer [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ; 
		}

		return t_Status ;
	}

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
			{
				delete m_RangeContainer [ a_Index ] ;
			}

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount ) ,
		m_Disjunction ( NULL )
	{
	}

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				m_Disjunction [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = new Conjunctions ( m_ConjunctionCount ) ;
				if ( t_Disjunction )
				{
					t_Status = t_Disjunction->Initialize () ;
					if ( t_Status != State_True )
					{
						break ;
					}
				}
				else
				{
					t_Status = State_Error ;
					break ;
				}

				m_Disjunction [ t_Index ] = t_Disjunction ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}

	~Disjunctions () 
	{
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
				delete t_Disjunction ;
			}
			
			delete [] m_Disjunction ;
		}
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;

		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
			{
				delete m_NonOverlappingPartitions [ t_Index ] ;
			}

			delete [] m_NonOverlappingPartitions ;
		}
	}

public:

	WmiTriState Initialize ( ULONG a_Count ) 
	{
		WmiTriState t_Status = State_True ;

		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
			{
				m_NonOverlappingPartitions [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
		}
	}

public:

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }

	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			return m_NonOverlappingPartitions [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL RecursiveEvaluate ( 

		void *a_Context ,
		SWbemRpnQueryToken ** a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node ,
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;

	WmiTriState EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveRemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	WmiTriState InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	WmiTriState RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	WmiTriState SortConditionals ( WmiTreeNode *&a_Root ) ;
	WmiTriState RecursiveSort ( WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;

	WmiTriState CreateDisjunctions ( 

		void *a_Context ,
		WmiTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	WmiTriState RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) ;

	virtual QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 

	) { return NULL ; }

protected:

	BOOL Evaluate (

		void *a_Context ,
		SWbemRpnQueryToken **a_Expression , 
		int a_Count ,
		WmiTreeNode **a_Root
	) ;

	QuadState DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;

	void RecursiveQuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Lower , 
		ULONG a_Upper
	) ;

	void QuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Size
	) ;

	void SortRanges (

		ULONG a_DisjunctionCount ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	WmiTriState RemoveOverlaps (

		ULONG *a_DisjunctionSetToTest ,
		ULONG a_DisjunctionCount ,
		ULONG *a_OverlappingIndex ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	QuadState RemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState Sort ( WmiTreeNode *&a_Root ) ;

	WmiTriState ConvertToRanges ( WmiTreeNode *&a_Root ) ;

	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;

	WmiTriState CreateDisjunctionContainer (

		void *a_Context , 
		WmiTreeNode *a_Root , 
		ULONG a_Count , 
		BSTR *a_Container , 
		Disjunctions *&a_Disjunctions
	) ;

	WmiTriState CreatePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition
	) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QueryPreprocessor () ;
	virtual ~QueryPreprocessor () ;

	QuadState PreProcess (

		void *a_Context , 
		IWbemQuery *a_QueryAnalysis , 
		WmiTreeNode *&a_Root
	) ;

	QuadState PreProcess ( 

		void *a_Context ,
		IWbemQuery *a_QueryAnalysis ,
		WmiTreeNode *a_Root ,
		ULONG a_Count , 
		BSTR *a_Container , 
		PartitionSet *&a_Partition
	) ;

	QuadState Query ( 

		BSTR a_Query ,
		IWbemQuery *a_QueryAnalysis
	) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provobjectsink.h ===
#ifndef _Common_IWbemObjectSink_H
#define _Common_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include "Queue.h"
#include "CGlobals.h"

#define SYNCPROV_USEBATCH

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemObjectSink					0
#define ProxyIndex_Internal_IWbemObjectSink			1
#define ProxyIndex_ObjectSink_Size					2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_IWbemSyncObjectSink :			public IWbemObjectSink , 
											public IWbemShutdown ,
											public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	ULONG m_Dependant ;
	IWbemObjectSink *m_InterceptedSink ;

#ifdef INTERNAL_IDENTIFY
	Internal_IWbemObjectSink *m_Internal_InterceptedSink ;

	ProxyContainer m_ProxyContainer ;
#endif
	IUnknown *m_Unknown ;

protected:

	LONG m_GateClosed ;

protected:

#ifdef INTERNAL_IDENTIFY

	HRESULT Begin_IWbemObjectSink (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemObjectSink (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;
#endif

    HRESULT STDMETHODCALLTYPE Helper_Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE Helper_SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

public:

	CCommon_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_IWbemSyncObjectSink() ;

	void CallBackInternalRelease () ;

	virtual HRESULT SinkInitialize () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_Batching_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:

	DWORD m_Size ;
	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:
public:

	CCommon_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_Batching_IWbemSyncObjectSink () ;

	HRESULT SinkInitialize () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

#endif _Common_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\provdnf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>
#include <typeinfo.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorIsANode :: ~WmiOperatorIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotIsANode :: ~WmiOperatorNotIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOrNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiAndNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{	
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOrNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Or "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiAndNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" And "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNotNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Not"
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Not IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLessOrEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLessOrEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
  		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLessOrEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) <= 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLess ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessOrEqualRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLessOrEqual ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Before ,
	WmiSignedIntegerRangeNode *&a_Intersection ,
	WmiSignedIntegerRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Before ,
	WmiUnsignedIntegerRangeNode *&a_Intersection ,
	WmiUnsignedIntegerRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}

				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetNonIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Before ,
	WmiStringRangeNode *&a_Intersection ,
	WmiStringRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiStringRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )


				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == - 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

   				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE ,
					    X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					    Y_E_CLOSED ,
					    Y_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE , 
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node ,
	int &a_Index 
)
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = TRUE ;

	SWbemRpnQueryToken *t_Token = a_Expression [ a_Index ] ;
	a_Index -- ;

	switch ( t_Token->m_uTokenType )
	{
		case WMIQ_RPN_TOKEN_EXPRESSION:
		{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = OP_EXPESSION"
	) ;
)
			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RELOP )
			{
				switch ( t_Token->m_uOperator )
				{
					case WMIQ_RPN_OP_EQ:
					{
						t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_NE:
					{
						t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GE:
					{
						t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LE: 
					{
						t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LT:
					{
						t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GT:
					{
						t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LIKE:
					{
						t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_ISA:
					{
						t_OperatorNode = new WmiOperatorIsANode ( NULL , t_ParentNode ) ;
					}
					break ;

					default:
					{
						t_Status = FALSE ;
					}
					break ;
				}

				if ( t_OperatorNode == NULL )
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}

			if ( t_Status ) 
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;

				WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_FUNCTION )
				{
					if ( _wcsicmp ( t_Token->m_pszLeftFunc , L"Upper" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( _wcsicmp ( t_Token->m_pszLeftFunc , L"Lower" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_FUNCTION )
				{
					if ( _wcsicmp ( t_Token->m_pszRightFunc , L"Upper" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( _wcsicmp ( t_Token->m_pszRightFunc , L"Lower" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				if ( t_Status ) 
				{
					BOOL t_LeftProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_PROPERTY_NAME ;
					BOOL t_RightProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_PROPERTY_NAME ;
					BOOL t_Const = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST ;
					BOOL t_Const2 = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST2 ;

					BOOL t_Validity = ( t_LeftProperty != 0 ) ? TRUE : FALSE ;
					t_Validity = t_Validity && ( ( t_RightProperty != 0 ) ? FALSE : TRUE ) ;
					t_Validity = t_Validity && ( ( t_Const != 0 ) ? TRUE : FALSE ) ;
					t_Validity = t_Validity && ( ( t_Const2 != 0 ) ? FALSE : TRUE ) ;

					if ( t_Validity ) 
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						switch ( t_Token->m_uConstApparentType )
						{
							case VT_I8:
							{
								t_Variant.vt = VT_R8 ;
								t_Variant.dblVal = t_Token->m_Const.m_dblVal ;
							}
							break ;

							case VT_I4:
							{
								t_Variant.vt = VT_I4 ;
								t_Variant.lVal = t_Token->m_Const.m_lLongVal ;
							}
							break ;

							case VT_LPWSTR:
							{
								t_Variant.vt = VT_BSTR ;
								t_Variant.bstrVal = SysAllocString ( t_Token->m_Const.m_pszStrVal ) ;
							}
							break ;

							case CIM_EMPTY:
							{
								t_Variant.vt = VT_NULL ;
							}
							break ;
						}

						BSTR t_PropertyName = SysAllocString ( t_Token->m_pLeftIdent->m_ppszNameList [ 0 ] ) ;
						if ( t_PropertyName ) 
						{
							WmiTreeNode *t_ValueNode = AllocTypeNode ( 

								a_Context ,
								t_PropertyName , 
								t_Variant , 
								t_PropertyFunction ,
								t_ConstantFunction ,
								t_ParentNode 
							) ;

							if ( t_ValueNode )
							{
								*t_Node = t_ValueNode ;

								t_Status = TRUE ;
							}
							else
							{				
								t_Status = FALSE ;
							}

							SysFreeString ( t_PropertyName ) ;
						}
						else
						{
							t_Status = FALSE ;
						}

						VariantClear ( & t_Variant ) ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case WMIQ_RPN_TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node ) 
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  


		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;

				t_Status = RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: Evaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	int a_Count ,
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;

	if ( a_Count )
	{
		int t_Index = a_Count - 1 ; ;  
		t_Status = RecursiveEvaluate ( a_Context , a_Expression , NULL , a_Root , t_Index ) ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"PostEvaluation Status = (%lu)\n" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = "
	) ;

	if ( a_Root ) 
		a_Root->Print () ;

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"\n"
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
		if ( t_NewOrNodeLeft )
		{
			t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;
		if ( t_AndChildCopy )
		{
			WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;
			if ( t_NewOrNodeRight )
			{
				t_NewOrNode->SetRight ( t_NewOrNodeRight ) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_NewOrNode ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_NewOrNode ) ;
			}	
		}

		a_Node->SetLeft ( NULL ) ;
		a_Node->SetRight ( NULL ) ;
		a_Node->SetData ( NULL ) ;

		a_OrChild->SetLeft ( NULL ) ;
		a_OrChild->SetRight ( NULL ) ;
		a_OrChild->SetData ( NULL ) ;

		delete a_Node ; 
		a_Node = NULL ;

		delete a_OrChild ; 
		a_OrChild = NULL ;
	}

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
		a_Node = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	t_Leaf->SetParent ( t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	a_Node = t_Leaf ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
		if ( t_LeftNot )
		{
			t_NewOrNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;
		if ( t_RightNot )
		{
			t_NewOrNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewAndNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
		if ( t_LeftNot )
		{
			t_NewAndNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;
		if ( t_RightNot )
		{
			t_NewAndNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewAndNode ;
	}
	else
	{
		delete t_NewAndNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_Child , t_NewOrNode ) ;
		if ( t_LessNode )
		{
			t_NewOrNode->SetLeft ( t_LessNode ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_CopyGreaterChild = a_Child->Copy () ;
		if ( t_CopyGreaterChild )
		{
			WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( t_CopyGreaterChild , t_NewOrNode ) ;
			if ( t_GreatorNode )
			{
				t_NewOrNode->SetRight ( t_GreatorNode ) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiTreeNode *t_Range = t_OperatorNode->GetRange () ;
	if ( t_Range )
	{
		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_Range ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_Range ) ;
			}	
		}

		t_Range->SetParent ( t_Parent ) ;
	}

	delete a_Node ;

	a_Node = t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( t_Left->GetType () == TypeId_WmiAndNode ) 
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiNotNode ) 
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformNotOperatorIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformNotOperatorNotIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else
		{
			return WmiTriState :: State_False ; 
		}
	}

	return WmiTriState :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
	}

	if ( t_Right )
	{
		if ( t_Right->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
	}

	return WmiTriState :: State_False ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return WmiTriState :: State_False  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			if ( EvaluateAndExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			if ( EvaluateOrExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
			if ( EvaluateNotExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			if ( EvaluateNotEqualExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	QueryPreprocessor :: QuadState t_Status = RecursiveDisjunctiveNormalForm ( a_Root ) ;
	if ( t_Status == QuadState :: State_ReEvaluate )
	{
		t_Status = DisjunctiveNormalForm ( a_Root ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( 

	void *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context, a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants (

	void *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Context , a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Context , a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status != WmiTriState :: State_False )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status != WmiTriState :: State_False )
				{
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				if ( t_NewAndNode )
				{
					a_Node->SetParent ( t_NewAndNode ) ;
					a_Insertion->SetParent ( t_NewAndNode ) ;

					if ( t_Parent )
					{
						if ( t_Parent->GetLeft () == a_Node )
						{
							t_Parent->SetLeft ( t_NewAndNode ) ;
						}
						else
						{
							t_Parent->SetRight ( t_NewAndNode ) ;
						}
					}

					a_Node = t_NewAndNode ;

					t_Status = WmiTriState :: State_True ;
				}
				else
				{
					t_Status = WmiTriState :: State_Error ; 
				}
			}
			else
			{
				t_Status = WmiTriState :: State_False  ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;

		t_Status = WmiTriState :: State_True ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState  QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == WmiTriState :: State_False  )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		if ( t_NewAndNode )
		{
			a_NewRoot->SetParent ( t_NewAndNode ) ;
			a_Insertion->SetParent ( t_NewAndNode ) ;

			if ( t_Parent )
			{
				if ( t_Parent->GetLeft () == a_NewRoot )
				{
					t_Parent->SetLeft ( t_NewAndNode ) ;
				}
				else
				{
					t_Parent->SetRight ( t_NewAndNode ) ;
				}
			}

			a_NewRoot = t_NewAndNode ;
		}
		else
		{
			return WmiTriState :: State_Error ;
		}
	}

	return WmiTriState :: State_True ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;
		}		
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	WmiTriState t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

    if ( a_Root )
    {
	    WmiTreeNode *t_Parent = a_Root->GetParent () ;
	    if ( t_Parent ) 
	    {
		    if ( t_Parent->GetLeft () == a_Root )
		    {
			    t_Parent->SetLeft ( t_NewRoot ) ;
		    }
		    else
		    {
			    t_Parent->SetRight ( t_NewRoot ) ;
		    }
	    }

	    t_NewRoot->SetParent ( t_Parent ) ;

	    delete a_Root ;
    }

	a_Root = t_NewRoot ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				if ( t_Right  )
				{
					t_Status = RecursiveSort ( t_Right ) ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Single operand
			t_Status = WmiTriState :: State_True ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	WmiTriState t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	return RecursiveConvertToRanges ( a_Root ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}

		a_Intersection->SetParent ( t_CompareParent ) ;

		delete a_Compare ; 
		a_Compare = NULL ;
	}
	else
	{
// Should never happen
DebugBreak () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					a_Compare = NULL ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

                    a_Compare = NULL;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNullRangeNode ) 
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiNullRangeNode ) 
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiStringRangeNode ) 
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiStringRangeNode ) 
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break; 

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
// Should never happen, failure in DNF evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctions ( 

	void *a_Context , 
	WmiTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context , 
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

				for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
				{
					if ( t_Disjunction->GetRange ( t_Index ) == NULL )
					{
						WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

							a_Context ,
							a_PropertiesToPartition [ t_Index ] 
						) ;

						if ( t_RangeNode )
						{
							t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
						}
						else
						{
							t_Status = WmiTriState :: State_Error ;
							break ;
						}
					}
				}
			}

			a_DisjunctionIndex ++ ;

			if ( t_Status == WmiTriState :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context ,
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}

				if ( t_Status == WmiTriState :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

					for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								a_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ; 
							}
						}
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context ,
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context , 
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( _wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					WmiRangeNode *t_NodeCopy = ( WmiRangeNode * ) t_Node->Copy () ;
					if ( t_NodeCopy )
					{
						t_Disjunction->SetRange ( t_Index , t_NodeCopy ) ;
					}
					else
					{
						t_Status = WmiTriState :: State_Error ;
					}

					break ;
				}
			}			
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctionContainer ( 

	void *a_Context , 
	WmiTreeNode *a_Root , 
	ULONG a_Count , 
	BSTR *a_Container , 
	Disjunctions *&a_Disjunctions
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Count && a_Container )
	{
		ULONG t_PropertiesToPartitionCount = a_Count ;
		BSTR *t_PropertiesToPartition = a_Container ;

		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;
		if ( a_Disjunctions )
		{
			t_Status = a_Disjunctions->Initialize () ;
			if ( t_Status == WmiTriState :: State_True )
			{
				t_Count = 0 ; 
				t_Status = CreateDisjunctions ( 

					a_Context , 
					a_Root , 
					a_Disjunctions ,
					t_PropertiesToPartitionCount ,
					t_PropertiesToPartition ,
					t_Count
				) ;

				if ( t_Status == WmiTriState :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								t_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ;
								break ;
							}
						}
					}
				}
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintInit (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
   	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"    "
            ) ;
        )
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"%lu", a_DisjunctionSetToTest [ t_Index ] ? 1 : 0
            ) ;
        )
    }

    DebugMacro3( 

        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"\n"
        ) ;
    )

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
    	for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
        {
            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"    "
                ) ;
            )
        }

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
		if ( t_Disjunction )
		{
			t_Disjunction->GetRange ( a_KeyIndex )->Print () ;

			DebugMacro3( 

				WmiDebugLog :: s_WmiDebugLog->Write (  

					L"\n"
				) ;
			)
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintSortedRange (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
    ULONG *a_OriginToSorted ,
	ULONG a_KeyIndex ,
    WmiRangeNode **a_RangeTable
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
   		if ( a_RangeTable [ t_Index ] )
        {
    	    for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"%lu    ", t_Index
                    ) ;
                )
            }

            if ( a_DisjunctionSetToTest [ a_OriginToSorted [ t_Index ] ] )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"In "
                    ) ;
				)
            }
            else
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"Out "
                    ) ;
				)
            }

		    a_RangeTable [ t_Index ]->Print () ;

            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"\n"
                ) ;
            )
        }
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintOverlap (

	ULONG a_DisjunctionSetToTestCount ,
   	ULONG *a_DisjunctionSetToTest ,
	ULONG *a_SortedDisjunctionSetToTest ,
    ULONG *a_OverlappingIndex ,
  	ULONG a_KeyIndex 
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"    "
    ) ;
)
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
DebugMacro3( 

    if ( a_DisjunctionSetToTest [ t_Index ] )
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"%lu ",  a_OverlappingIndex [ t_Index ]
        ) ;
    }
    else
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"X "
        ) ;
    }
)
    }

DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"\n"
    ) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: RecursiveQuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Lower , 
	ULONG a_Upper
)
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;

				ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
				a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ t_RightIndex ];
				a_UnsortedOrder [ t_RightIndex ] = t_Val ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare )
		{
			WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;

			ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
			a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ a_Lower - 1 ];
			a_UnsortedOrder [ a_Lower - 1 ] = t_Val ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_UnsortedOrder ,
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			a_UnsortedOrder ,
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: QuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Size
)
{
	RecursiveQuickSort ( a_Array , a_UnsortedOrder , 1 , a_Size - 1 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: SortRanges (

	ULONG t_DisjunctionCount ,
    ULONG *t_OriginToSorted ,
	WmiRangeNode **t_RangeTable 
)
{
	QuickSort (	t_RangeTable , t_OriginToSorted , t_DisjunctionCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RemoveOverlaps (

	ULONG *a_DisjunctionSetToTest ,
	ULONG a_DisjunctionCount ,
	ULONG *a_OverlappingIndex ,
    ULONG *a_OriginToSorted ,
	WmiRangeNode **a_RangeTable 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

/*
 *  Remove Overlaps
 */

	ULONG t_InnerIndex = 0 ;
	ULONG t_OuterIndex = 1 ;

	while ( ( t_Status != WmiTriState :: State_Error ) && ( t_OuterIndex < a_DisjunctionCount ) )
	{
		WmiRangeNode *t_LeftRange = a_RangeTable [ t_OuterIndex ] ;
		WmiRangeNode *t_RightRange = a_RangeTable [ t_InnerIndex ] ;

		if ( a_OverlappingIndex [ t_OuterIndex ] != a_OverlappingIndex [ t_InnerIndex ] )
		{
			if ( t_LeftRange && t_RightRange )
			{
				if ( ( t_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
				{
					WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
					WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;
    				WmiStringRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftString->GetOverlappingRange ( *t_RightString , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)

						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;

						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
					}
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
				{
					WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
					WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;
    				WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
				{
					WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
					WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;
    				WmiSignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else
				{
// Failure
					t_Status = WmiTriState :: State_Error ;  
				}
			}
		}

		t_InnerIndex ++ ;
		t_OuterIndex ++ ;
	}

	for ( LONG t_Index = a_DisjunctionCount - 1 ; t_Index >= 0 ; t_Index -- )
	{
		if ( t_Index < a_OverlappingIndex [ t_Index ] )
		{
			a_OverlappingIndex [ t_Index ] = a_OverlappingIndex [ a_OverlappingIndex [ t_Index ] ] ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_KeyIndex < a_Disjunctions->GetConjunctionCount () )
	{
		ULONG *t_OverlappingIndex = new ULONG [ a_DisjunctionSetToTestCount ] ;
        ULONG *t_OriginToSorted = new ULONG [ a_DisjunctionSetToTestCount ] ;
		WmiRangeNode **t_RangeTable = new WmiRangeNode * [ a_DisjunctionSetToTestCount ] ;

		if ( t_OverlappingIndex && t_OriginToSorted && t_RangeTable )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionSetToTest [ t_Index ] ) ;
				t_RangeTable [ t_Index ] = ( WmiRangeNode * ) t_Disjunction->GetRange ( a_KeyIndex )->Copy () ;
				t_OverlappingIndex [ t_Index ] = t_Index ;
				t_OriginToSorted [ t_Index ] = t_Index ;
			}

// Sort Partitions

			SortRanges (

				a_DisjunctionSetToTestCount ,
				t_OriginToSorted ,
				t_RangeTable 
			) ;

			t_Status = RemoveOverlaps (

				a_DisjunctionSetToTest ,
				a_DisjunctionSetToTestCount ,
				t_OverlappingIndex ,
				t_OriginToSorted ,
				t_RangeTable 
			) ;

			if ( t_Status != WmiTriState :: State_Error )
			{
				ULONG t_PartitionCount = 0 ;
				for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						t_PartitionCount ++ ;
					}
				}

				t_Status = a_Partition->Initialize ( t_PartitionCount ) ;
				if ( t_Status == WmiTriState :: State_True )
				{
					ULONG t_PartitionIndex = 0 ;
					for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount; t_Index ++ )
					{
						WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
						if ( t_Range )
						{
							PartitionSet *t_Partition = new PartitionSet ;
							if ( t_Partition )
							{
								a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

								WmiRangeNode *t_Copy = ( WmiRangeNode * ) t_Range->Copy () ;
								if ( t_Copy )
								{
									t_Partition->SetRange ( t_Copy ) ;
									t_Partition->SetKeyIndex ( a_KeyIndex ) ;
									t_PartitionIndex ++ ;
								}
								else
								{
									t_Status = WmiTriState :: State_Error ; 
									break ;
								}
							}
							else
							{
								t_Status = WmiTriState :: State_Error ; 
								break ;
							}
						}
					}
				}

				if ( t_Status == WmiTriState :: State_True )
				{
/*
 *  Outer Index is the range order
 */
					ULONG t_PartitionIndex = 0 ;

/*
 *	Array allocation has max defined by function arg.
 */

					ULONG *t_DisjunctionSetToTest = new ULONG [ a_DisjunctionSetToTestCount ] ;
					if ( t_DisjunctionSetToTest )
					{
						ULONG t_OuterIndex = 0 ;
						while ( t_Status && ( t_OuterIndex < a_DisjunctionSetToTestCount ) )
						{
							BOOL t_Found = FALSE ;

							ULONG t_DisjunctionSetToTestCount = 0 ;

							if ( t_RangeTable [ t_OuterIndex ] )
							{
/*
 * Inner index matches the overlaps
 */

								LONG t_InnerIndex = t_OuterIndex ;
								while ( t_InnerIndex >= 0 )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] == t_OverlappingIndex [ t_InnerIndex ] )
									{
										t_DisjunctionSetToTest [ t_DisjunctionSetToTestCount ] = a_DisjunctionSetToTest [ t_OriginToSorted [ t_InnerIndex ] ] ;
										t_DisjunctionSetToTestCount ++ ;
										t_Found = TRUE ;
									}
									else
									{
										break ;
									}

									t_InnerIndex -- ;
								}
							}

    						if ( t_Found )
							{
								PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
								if ( t_Partition )
								{
									t_Status = RecursivePartitionSet (

										a_Disjunctions ,
										t_Partition ,
										t_DisjunctionSetToTestCount ,
										t_DisjunctionSetToTest ,
										a_KeyIndex + 1
									) ;

									t_PartitionIndex ++ ;
								}
							}

							t_OuterIndex ++ ;
						}

						delete [] t_DisjunctionSetToTest ;
					}
					else
					{
						t_Status = WmiTriState :: State_Error ; 
					}
				}
			}
			else
			{
				t_Status = WmiTriState :: State_Error ; 
			}

			for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				if ( t_RangeTable [ t_Index ] )
				{
					delete t_RangeTable [ t_Index ] ;
				}
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ; 
		}

		delete [] t_RangeTable ;
		delete [] t_OverlappingIndex ;
		delete [] t_OriginToSorted ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	if ( t_DisjunctionSetToTest )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_DisjunctionSetToTest [ t_Index ] = t_Index ;
		}

		a_Partition = new PartitionSet ;
		if ( a_Partition )
		{
			t_Status = RecursivePartitionSet (

				a_Disjunctions ,
				a_Partition ,
				t_DisjunctionCount ,
				t_DisjunctionSetToTest ,
				0
			) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		delete [] t_DisjunctionSetToTest ;
	}
	else
	{
		t_Status = WmiTriState :: State_Error ;
	}

	return t_Status;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess ( 

	void *a_Context , 
	IWbemQuery *a_QueryAnalysis , 
	WmiTreeNode *a_Root ,
	ULONG a_Count , 
	BSTR *a_Container , 
	PartitionSet *&a_Partition
)
{
	QuadState t_State = State_True ;

    if ( a_Root != NULL )
    {
        WmiTreeNode *t_Root = a_Root->Copy () ;
		if ( t_Root )
		{
			t_State = RemoveInvariants ( a_Context , t_Root ) ;

			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{		
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = TRUE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_False:
				{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = FALSE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_Undefined:
				{
					PrintTree ( t_Root ) ;
						
					WmiTriState t_Status = Sort ( t_Root ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
						PrintTree ( t_Root ) ;

						t_Status = ConvertToRanges ( t_Root ) ;
					}

					if ( t_Status == WmiTriState :: State_True )
					{
						PrintTree ( t_Root ) ;

						switch ( t_State = RemoveNonOverlappingRanges ( t_Root ) )
						{
							case QueryPreprocessor :: QuadState :: State_True :
							{		
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = TRUE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_False:
							{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = FALSE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_Undefined:
							{
								PrintTree ( t_Root ) ;

								t_State =  State_Error ;

								Disjunctions *t_Disjunctions = NULL ;

								t_Status = CreateDisjunctionContainer ( a_Context , t_Root , a_Count , a_Container , t_Disjunctions ) ;
								if ( t_Status == WmiTriState :: State_True )
								{
									PartitionSet *t_Partition = NULL ;
									t_Status = CreatePartitionSet ( t_Disjunctions , t_Partition ) ;
									if ( t_Status == WmiTriState :: State_True )
									{
										t_State =  State_Undefined ; 
										a_Partition = t_Partition ;
									}
									else
									{
										delete t_Partition ;
									}

									delete t_Disjunctions ;
								}
								else
								{
									t_State = QueryPreprocessor :: QuadState :: State_Error ;
								}
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_ReEvaluate:
							default:
							{
							}
							break ;
						}
					}
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_ReEvaluate:
				default:
				{
				}
				break ;
			}

			delete t_Root ;
		}
		else
		{
			t_State = State_Error ;
		}
    }

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess (

	void *a_Context ,																
	IWbemQuery *a_QueryAnalysis ,
	WmiTreeNode *&a_Root 
)
{
	QuadState t_State = State_Error ;

	SWbemRpnEncodedQuery *t_Expression = NULL ;

	HRESULT t_Result = a_QueryAnalysis->GetAnalysis (

		WMIQ_ANALYSIS_RPN_SEQUENCE ,
        0 ,
        ( void ** ) & t_Expression
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Status = Evaluate ( 
		
			a_Context , 
			( t_Expression->m_ppRpnWhereClause ) , 
			( t_Expression->m_uWhereClauseSize ) , 
			& a_Root
		) ;

		if ( t_Status )
		{
			t_State = State_True ;

			PrintTree ( a_Root ) ;
        
			t_State = DisjunctiveNormalForm ( a_Root ) ;

			PrintTree ( a_Root ) ;
		}

		a_QueryAnalysis->FreeMemory ( t_Expression ) ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: Query ( 

	BSTR a_Query ,
	IWbemQuery *a_QueryAnalysis
)
{
	QuadState t_State = State_Error ;

	ULONG t_Array [] = { 

		WMIQ_LF1_BASIC_SELECT ,
		WMIQ_LF2_CLASS_NAME_IN_QUERY ,
		WMIQ_LF3_STRING_CASE_FUNCTIONS ,
		WMIQ_LF4_PROP_TO_PROP_TESTS ,
		WMIQ_LF8_ISA ,
		WMIQ_LF9_THIS ,
		WMIQ_LF26_LIKE
	} ;
 
	ULONG t_ArraySize = sizeof ( t_Array ) / sizeof ( ULONG ) ;

    HRESULT t_Result = a_QueryAnalysis->SetLanguageFeatures (

        0 ,
        t_ArraySize ,
        t_Array
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_QueryAnalysis->Parse ( L"WQL" , a_Query , 0 ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_State = State_True ;
		}
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: ~QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_THIS				L"__THIS"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *QueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_THIS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
	}

	return t_Node ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provtree.h ===
// (C) 1999-2001 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef DWORD TypeId_TreeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiTreeNode 
{
protected:

	TypeId_TreeNode m_Type ;

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;
	
public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Type = a_Node->m_Type ;
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
	}

	WmiTreeNode ( 

		TypeId_TreeNode a_Type = 0 ,
		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) 
	{
		m_Type = a_Type ;
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Right->SetParent ( this ) ;
	}

	virtual ~WmiTreeNode () {}

	TypeId_TreeNode GetType ()
	{
		return m_Type ;
	}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void SetType ( TypeId_TreeNode a_Type )
	{
		m_Type = a_Type ;
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provregdecoupled.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationDecoupled_H
#define _Server_ProviderRegistrationDecoupled_H

#include "Queue.h"
#include "DateTime.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration_Element
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_Provider ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Scope ;
	BSTR m_CreationTime ;
	BSTR m_Clsid ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_User ;
	static LPCWSTR s_Strings_Reg_Locale ;
	static LPCWSTR s_Strings_Reg_Scope ;
	static LPCWSTR s_Strings_Reg_Provider;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration_Element () ;
    ~CServerObject_DecoupledClientRegistration_Element () ;

	CServerObject_DecoupledClientRegistration_Element &operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key ) ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( BSTR a_Clsid ) ;
	HRESULT Save ( BSTR a_Clsid ) ;
	HRESULT Delete ( BSTR a_Clsid ) ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetProvider () { return m_Provider ; }
	BSTR GetLocale () { return m_Locale ; }
	BSTR GetUser () { return m_User ; }
	BSTR GetScope () { return m_Scope ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BSTR GetClsid () { return m_Clsid ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetProvider ( BSTR a_Provider ) ;
	HRESULT SetLocale ( BSTR a_Locale ) ;
	HRESULT SetUser ( BSTR a_User ) ;
	HRESULT SetScope ( BSTR a_Scope ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetClsid ( const BSTR a_Clsid ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration
{
private:

	LONG m_ReferenceCount ;

private:

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > m_Queue ;

protected:

	HRESULT m_Result ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledClientRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;

	HRESULT Load (

		BSTR a_Provider ,
		BSTR a_User ,
		BSTR a_Locale ,
		BSTR a_Scope
	) ;

	static  LPCWSTR getClientKey(void) { return s_Strings_Reg_HomeClient;}

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &GetQueue () { return m_Queue ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledServerRegistration
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_CreationTime ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeServer ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledServerRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;
	HRESULT Save () ;
	HRESULT Delete () ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;

};


#endif // _Server_ProviderRegistrationDecoupled_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\ssdlhelper.h ===
#include "PreComp.h"
#include <locks.h>

struct SSDL_wrapper
{
  typedef BOOL (*function_type)( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  function_type current_function_; 
  CriticalSection lock_;

  SSDL_wrapper():lock_(false), current_function_(0){};
  
  static BOOL ConvertStringSecurityDescriptorToSecurityDescriptor( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  static BOOL DummyConvertStringSecurityDescriptorToSecurityDescriptor( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  function_type GetFunction(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\include\provreginfo.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationInfo_H
#define _Server_ProviderRegistrationInfo_H

#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid ) ;
HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern GENERIC_MAPPING g_ProviderBindingMapping ; 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define DEFAULT_PROVIDER_TIMEOUT 120000
#define DEFAULT_PROVIDER_LOAD_TIMEOUT 120000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ThreadingModel
{
	e_Apartment = 0 ,
	e_Both ,
	e_Free ,
	e_Neutral ,
	e_ThreadingModel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Synchronization
{
	e_Ignored = 0 ,
	e_None ,
	e_Supported ,
	e_Required ,
	e_RequiresNew ,
	e_Synchronization_Unknown 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Boolean
{
	e_False = 0 ,
	e_True ,
	e_Boolean_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ImpersonationLevel
{
	e_Impersonate_None = 0 ,
	e_Impersonate ,
	e_ImpersonationLevel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InitializationReentrancy
{
	e_InitializationReentrancy_Clsid = 0 ,
	e_InitializationReentrancy_Namespace ,
	e_InitializationReentrancy_None ,
	e_InitializationReentrancy_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InteractionType
{
	e_InteractionType_Pull = 0 ,
	e_InteractionType_Push ,
	e_InteractionType_PushVerify ,
	e_InteractionType_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Hosting
{
	e_Hosting_Undefined = 0 ,
	e_Hosting_WmiCore  ,
	e_Hosting_WmiCoreOrSelfHost ,
	e_Hosting_SelfHost ,
	e_Hosting_ClientHost ,
	e_Hosting_Decoupled ,
	e_Hosting_SharedLocalSystemHost ,
	e_Hosting_SharedLocalSystemHostOrSelfHost ,
	e_Hosting_SharedLocalServiceHost ,
	e_Hosting_SharedNetworkServiceHost ,
	e_Hosting_SharedUserHost ,
	e_Hosting_NonCom
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define e_QuerySupportLevels_UnarySelect ( 1 )
#define e_QuerySupportLevels_References ( e_QuerySupportLevels_UnarySelect << 1 )
#define e_QuerySupportLevels_Associators ( e_QuerySupportLevels_References << 1 )
#define e_QuerySupportLevels_V1ProviderDefined ( e_QuerySupportLevels_Associators << 1 )
#define e_QuerySupportLevels_None ( e_QuerySupportLevels_V1ProviderDefined << 1 )
#define e_QuerySupportLevels_Unknown ( 0 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef ULONGLONG Enum_PropertyMask ;

#define	e_ThreadingModel 0x1 
#define	e_Synchronization 0x2
#define	e_Clsid 0x4
#define	e_ClientClsid 0x8
#define	e_DefaultMachineName 0x10
#define	e_UnloadTimeout 0x20
#define	e_ImpersonationLevel 0x40
#define	e_InitializationReentrancy 0x80
#define	e_InitializeAsAdminFirst 0x100
#define	e_PerUserInitialization 0x200
#define	e_PerLocaleInitialization 0x400
#define	e_Pure 0x800
#define	e_Hosting 0x1000
#define	e_HostingGroup 0x2000
#define	e_SupportsPut 0x4000
#define	e_SupportsGet 0x8000
#define	e_SupportsDelete 0x10000
#define	e_SupportsEnumeration 0x20000
#define	e_QuerySupportLevels 0x40000
#define	e_InteractionType 0x80000
#define	e_ResultSetQueries 0x100000
#define	e_UnSupportedQueries 0x200000
#define	e_ReferencedSetQueries 0x400000
#define	e_ClearAfter 0x800000
#define	e_SupportsThrottling 0x1000000
#define	e_ConcurrentIndependantRequests 0x2000000
#define	e_SupportsSendStatus 0x4000000
#define	e_OperationTimeoutInterval 0x8000000
#define	e_InitializationTimeoutInterval 0x10000000
#define	e_SupportsQuotas 0x20000000
#define	e_Enabled 0x40000000
#define	e_SupportsShutdown 0x80000000
#define	e_SupportsBatching 0x100000000
#define	e_SupportsTransactions 0x200000000
#define	e_CacheRefreshInterval 0x400000000
#define	e_PerUserSchema 0x800000000
#define	e_ReSynchroniseOnNamespaceOpen 0x1000000000
#define	e_MemoryPerHost 0x2000000000
#define	e_MemoryAllHosts 0x4000000000
#define	e_ThreadsPerHost 0x8000000000
#define	e_HandlesPerHost 0x10000000000
#define	e_ProcessLimitAllHosts 0x20000000000
#define	e_Version 0x40000000000
#define	e_SecurityDescriptor 0x80000000000
#define	e_Name 0x100000000000

#define	e_All 0xFFFFFFFFFFFFFFFF

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_GlobalRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	LPWSTR m_Object_UnloadTimeout ;
	ULONG m_Object_UnloadTimeoutMilliSeconds ;

	LPWSTR m_Event_UnloadTimeout ;
	ULONG m_Event_UnloadTimeoutMilliSeconds ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_ClearAfter ;
	static LPCWSTR s_Strings_Wmi___ObjectProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi___EventProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi_Class ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Event ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Event ;

protected:
public:	/* Internal */

    CServerObject_GlobalRegistration () ;
    ~CServerObject_GlobalRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPWSTR &a_UnloadTimeout ,
		ULONG &a_UnloadTimeoutMilliSeconds 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	wchar_t *GetUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetObjectUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetObjectUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetEventUnloadTimeout () { return m_Event_UnloadTimeout ; }
	ULONG GetEventUnloadTimeoutMilliSeconds () { return m_Event_UnloadTimeoutMilliSeconds ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_HostQuotaRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	SIZE_T m_MemoryPerHost ;
	SIZE_T m_MemoryAllHosts ;
	ULONG m_ThreadsPerHost ;
	ULONG m_HandlesPerHost ;
	ULONG m_ProcessLimitAllHosts ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_HostQuotas_Query ;
	static LPCWSTR s_Strings_Wmi_HostQuotas_Path ;
	static LPCWSTR s_Strings_Wmi_MemoryPerHost ;
	static LPCWSTR s_Strings_Wmi_MemoryAllHosts ;
	static LPCWSTR s_Strings_Wmi_ThreadsPerHost ;
	static LPCWSTR s_Strings_Wmi_HandlesPerHost ;
	static LPCWSTR s_Strings_Wmi_ProcessLimitAllHosts ;

protected:
public:	/* Internal */

    CServerObject_HostQuotaRegistration () ;
    ~CServerObject_HostQuotaRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	SIZE_T GetMemoryPerHost () { return m_MemoryPerHost ; }
	SIZE_T GetMemoryAllHosts () { return m_MemoryAllHosts ; }
	ULONG GetThreadsPerHost () { return m_ThreadsPerHost; }
	ULONG GetHandlesPerHost () { return m_HandlesPerHost; }
	ULONG GetProcessLimitAllHosts () { return m_ProcessLimitAllHosts ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComRegistration 
{
private:

	LONG m_ReferenceCount ;

private:

	HRESULT Load_ThreadingModel ( HKEY a_Clsid ) ;
	HRESULT Load_Synchronization ( HKEY a_ClsidKey ) ;

	HRESULT Load_InProcServer32 ( LPCWSTR a_ClsidStringKey ) ;
	HRESULT Load_LocalServer32 ( LPCWSTR a_ClsidStringKey ) ;

	HRESULT Load_AppId ( HKEY a_Clsid_Key ) ;
	HRESULT Load_ServerTypes ( LPCWSTR a_ClsidString ) ;

protected:

	HRESULT m_Result ;

	Enum_ThreadingModel m_ThreadingModel ;
	Enum_Synchronization m_Synchronization ;

	Enum_Boolean m_InProcServer32 ;
	Enum_Boolean m_LocalServer32 ;
	Enum_Boolean m_Service ;
	Enum_Boolean m_Loaded ;
	BSTR m_Clsid ;
	BSTR m_AppId ;
	BSTR m_ProviderName ;
	wchar_t m_InProcServer32_Path [ MAX_PATH ] ;
	wchar_t m_LocalServer32_Path [ MAX_PATH ] ;
	wchar_t m_Server_Name [ MAX_PATH ] ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;

	static LPCWSTR s_Strings_Reg_ThreadingModel ;
	static LPCWSTR s_Strings_Reg_InProcServer32 ;
	static LPCWSTR s_Strings_Reg_LocalServer32 ;
	static LPCWSTR s_Strings_Reg_Synchronization ;
	static LPCWSTR s_Strings_Reg_AppId ;

	static LPCWSTR s_Strings_Reg_Apartment_Apartment ;
	static LPCWSTR s_Strings_Reg_Apartment_Both ;
	static LPCWSTR s_Strings_Reg_Apartment_Free ;
	static LPCWSTR s_Strings_Reg_Apartment_Neutral ;

	static LPCWSTR s_Strings_Reg_Apartment_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_Ignored ; 
	static LPCWSTR s_Strings_Reg_Synchronization_None ;
	static LPCWSTR s_Strings_Reg_Synchronization_Supported ;
	static LPCWSTR s_Strings_Reg_Synchronization_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_RequiresNew ;

	static LPCWSTR s_Strings_Reg_ClsidKeyStr ;

public:	/* Internal */

    CServerObject_ComRegistration () ;
    ~CServerObject_ComRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName ) ;

	Enum_ThreadingModel GetThreadingModel () { return m_ThreadingModel ; }
	Enum_Synchronization GetSynchronization () { return m_Synchronization ; }

	Enum_Boolean InProcServer32 () { return m_InProcServer32 ; }
	Enum_Boolean LocalServer32 () { return m_LocalServer32 ; }
	Enum_Boolean Loaded () { return m_Loaded ; }

	wchar_t *GetInProcServer32_Path () { return m_InProcServer32_Path ; }
	wchar_t *GetLocalServer32_Path () { return m_LocalServer32_Path ; }
	wchar_t *GetServer_Name () { return m_Server_Name ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }
	wchar_t *GetProviderClsid () { return m_Clsid ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	CServerObject_ComRegistration m_ClsidServer ;

	ULONG m_Version ;
	Enum_ImpersonationLevel m_ImpersonationLevel ;
	Enum_InitializationReentrancy m_InitializationReentrancy ;
	BOOL m_InitializeAsAdminFirst ;
	BOOL m_PerUserInitialization ;
	BOOL m_PerLocaleInitialization ;
	BOOL m_SupportsQuotas ;
	BOOL m_Enabled ;
	BOOL m_SupportsShutdown ;
	BOOL m_Pure ;
	Enum_Hosting m_Hosting ;
	LPWSTR m_HostingGroup ;
	LPWSTR m_DefaultMachineName ;
	BOOL m_DecoupledImpersonationRestriction ;

	LPWSTR m_InitializationTimeout ;
	ULONG m_InitializationTimeoutMilliSeconds ;

	LPWSTR m_UnloadTimeout ;
	ULONG m_UnloadTimeoutMilliSeconds ;

	BOOL m_SupportsSendStatus ;
	LPWSTR m_OperationTimeout ;
	ULONG m_OperationTimeoutMilliSeconds ;

	BOOL m_SupportsThrottling ;
	ULONG m_ConcurrentIndependantRequests ;

	BSTR m_ProviderName ;

	GUID m_CLSID ;
	GUID m_ClientCLSID ;

	IWbemClassObject *m_Identity ;
	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

public:

	static LPCWSTR s_Strings_Wmi_Clsid ;
	static LPCWSTR s_Strings_Wmi_ClientClsid ;
	static LPCWSTR s_Strings_Wmi_Name ;
	static LPCWSTR s_Strings_Wmi_Version ;
	static LPCWSTR s_Strings_Wmi_DefaultMachineName ;
	static LPCWSTR s_Strings_Wmi_UnloadTimeout ;
	static LPCWSTR s_Strings_Wmi_ImpersonationLevel ;
	static LPCWSTR s_Strings_Wmi_InitializationReentrancy ;
	static LPCWSTR s_Strings_Wmi_InitializeAsAdminFirst ;
	static LPCWSTR s_Strings_Wmi_PerUserInitialization ;
	static LPCWSTR s_Strings_Wmi_PerLocaleInitialization ;
	static LPCWSTR s_Strings_Wmi_Pure ;
	static LPCWSTR s_Strings_Wmi_Hosting ;
	static LPCWSTR s_Strings_Wmi_HostingGroup ;
	static LPCWSTR s_Strings_Wmi_SupportsThrottling ;
	static LPCWSTR s_Strings_Wmi_SupportsQuotas ;
	static LPCWSTR s_Strings_Wmi_SupportsShutdown ;
	static LPCWSTR s_Strings_Wmi_Enabled ;
	static LPCWSTR s_Strings_Wmi_ConcurrentIndependantRequests ;
	static LPCWSTR s_Strings_Wmi_SupportsSendStatus ;
	static LPCWSTR s_Strings_Wmi_OperationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_InitializationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_SecurityDescriptor ;

	static WCHAR s_Strings_Wmi_WmiCore [] ;
	static WCHAR s_Strings_Wmi_SelfHost [] ;
	static WCHAR s_Strings_Wmi_WmiCoreOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_ClientHost [] ;
	static WCHAR s_Strings_Wmi_Decoupled [] ;
	static WCHAR s_Strings_Wmi_DecoupledColon [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedUserHost [] ;
	static WCHAR s_Strings_Wmi_NonCom [] ;

	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedUserHost [] ;

	static LPCWSTR s_Strings_Wmi_DefaultHostingRegistryKey ;

protected:
public:	/* Internal */

    CServerObject_ComProviderRegistrationV1 () ;
    ~CServerObject_ComProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPCWSTR a_ProviderName
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_CLSID ; }
	const CLSID &GetClientClsid () { return m_ClientCLSID ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }

	ULONG GetVersion () { return m_Version ; }
	Enum_ImpersonationLevel GetImpersonationLevel () { return m_ImpersonationLevel ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_InitializationReentrancy ; }
	Enum_Hosting GetHosting () { return m_Hosting ; }
	LPCWSTR GetHostingGroup () { return m_HostingGroup ; }

	BOOL InitializeAsAdminFirst () { return m_InitializeAsAdminFirst ; }
	BOOL PerUserInitialization () { return m_PerUserInitialization ; }
	BOOL PerLocaleInitialization () { return m_PerLocaleInitialization ; }
	BOOL Pure () { return m_Pure ; }
	BOOL Enabled () { return m_Enabled ; }
	BOOL SupportsQuotas () { return m_SupportsQuotas ; }

	wchar_t *GetDefaultMachineName () { return m_DefaultMachineName ; }
	wchar_t *GetUnloadTimeout () { return m_UnloadTimeout ; }
	wchar_t *GetInitializationTimeout () { return m_InitializationTimeout ; }
	wchar_t *GetOperationTimeout () { return m_OperationTimeout ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_UnloadTimeoutMilliSeconds = a_UnloadTimeoutMilliSeconds ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_UnloadTimeoutMilliSeconds ; }
	ULONG GetInitializationTimeoutMilliSeconds () { return m_InitializationTimeoutMilliSeconds ; }
	ULONG GetOperationTimeoutMilliSeconds () { return m_OperationTimeoutMilliSeconds ; }

	ULONG GetConcurrentIndependantRequests () { return m_ConcurrentIndependantRequests ; }
	BOOL GetSupportsThrottling () { return m_SupportsThrottling ; }
	BOOL GetSupportsSendStatus () { return m_SupportsSendStatus ; }
	BOOL GetSupportsShutdown () { return m_SupportsShutdown ; }

	Enum_ThreadingModel GetThreadingModel () { return m_ClsidServer.GetThreadingModel () ; }	

	BOOL GetDecoupledImpersonationRestriction () { return m_DecoupledImpersonationRestriction ; }

	CServerObject_ComRegistration &GetClsidServer () { return m_ClsidServer ; }

	SECURITY_DESCRIPTOR *GetSecurityDescriptor () { return m_SecurityDescriptor ; }

	HRESULT GetResult () { return m_Result ; }

	IWbemClassObject *GetIdentity () { return m_Identity ; }

	static HRESULT GetHosting (
	
		LPCWSTR a_Hosting , 
		Enum_Hosting & a_HostingValue , 
		LPWSTR &a_HostingGroup ,
		BOOL & a_ImpersonationRestriction 
	) ;

	static HRESULT GetHostingGroup ( 

		LPCWSTR a_Hosting , 
		size_t a_Prefix ,
		Enum_Hosting a_ExpectedHostingValue ,
		Enum_Hosting & a_HostingValue ,
		BSTR & a_HostingGroup
	) ;

	static HRESULT GetDefaultHostingGroup ( 

		Enum_Hosting a_HostingValue ,
		BSTR & a_HostingGroup 
	) ;

	static HRESULT GetDecoupledImpersonationRestriction ( 

		LPCWSTR a_Hosting , 
		BOOL & a_ImpersonationRestriction 
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InstanceProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;

	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;

	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_InstanceProviderRegistrationV1 () ;
    ~CServerObject_InstanceProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }

	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ClassProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;
	BOOL m_PerUserSchema ;
	BOOL m_ReSynchroniseOnNamespaceOpen ;
	BOOL m_HasReferencedSet;
	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;
	ULONG m_Version ;
	LPWSTR m_CacheRefreshInterval ;
	ULONG m_CacheRefreshIntervalMilliSeconds ;

	LPWSTR m_ProviderName ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

	ULONG m_ResultSetQueryTreeCount ;
	WmiTreeNode **m_ResultSetQueryTree ;

	ULONG m_UnSupportedQueryTreeCount ;
	WmiTreeNode **m_UnSupportedQueryTree ;

	ULONG m_ReferencedSetQueryTreeCount ;
	WmiTreeNode **m_ReferencedSetQueryTree ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;

	static LPCWSTR s_Strings_Version ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;
	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;
	static LPCWSTR s_Strings_CacheRefreshInterval ;
	static LPCWSTR s_Strings_PerUserSchema ;
	static LPCWSTR s_Strings_ReSynchroniseOnNamespaceOpen ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

	static LPCWSTR s_Strings_ResultSetQueries ;
	static LPCWSTR s_Strings_UnSupportedQueries ;
	static LPCWSTR s_Strings_ReferencedSetQueries ;

private:

	HRESULT ParseQuery (

		ULONG &a_Count ,
		WmiTreeNode **&a_Root ,
		SAFEARRAY *a_Array
	) ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ClassProviderRegistrationV1 () ;
    ~CServerObject_ClassProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }
	BOOL GetPerUserSchema () { return m_PerUserSchema ; }
	BOOL GetReSynchroniseOnNamespaceOpen () { return m_ReSynchroniseOnNamespaceOpen ; }
	BOOL HasReferencedSet () { return m_HasReferencedSet ; }
	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	ULONG GetResultSetQueryCount () { return m_ResultSetQueryTreeCount ; }
	WmiTreeNode **GetResultSetQuery () { return m_ResultSetQueryTree ; }

	ULONG GetUnSupportedQueryCount () { return m_UnSupportedQueryTreeCount ; }
	WmiTreeNode **GetUnSupportedQuery () { return m_UnSupportedQueryTree ; }

	ULONG GetReferencedSetQueryCount () { return m_ReferencedSetQueryTreeCount ; }
	WmiTreeNode **GetReferencedSetQuery () { return m_ReferencedSetQueryTree ; }

	wchar_t *GetCacheRefreshInterval () { return m_CacheRefreshInterval ; }
	ULONG GetCacheRefreshIntervalMilliSeconds () { return m_CacheRefreshIntervalMilliSeconds ; }

	wchar_t *GetProviderName () { return m_ProviderName ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }

	BOOL GetVersion () { return m_Version ; } 
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_MethodProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsMethods ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_MethodProviderRegistrationV1 () ;
    ~CServerObject_MethodProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsMethods () { return m_SupportsMethods ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventProviderRegistrationV1 () ;
    ~CServerObject_EventProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventConsumerProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventConsumerProviderRegistrationV1 () ;
    ~CServerObject_EventConsumerProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DynamicPropertyProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;


private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_DynamicPropertyProviderRegistrationV1 () ;
    ~CServerObject_DynamicPropertyProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;
	static LPCWSTR s_Strings_EventProviderRegistration ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT m_Result ;

	CServerObject_ComProviderRegistrationV1 m_ComRegistration ;

	CServerObject_ClassProviderRegistrationV1 m_ClassProviderRegistration ;
	CServerObject_InstanceProviderRegistrationV1 m_InstanceProviderRegistration ;
	CServerObject_MethodProviderRegistrationV1 m_MethodProviderRegistration ;
	CServerObject_DynamicPropertyProviderRegistrationV1 m_PropertyProviderRegistration ;
	CServerObject_EventProviderRegistrationV1 m_EventProviderRegistration ;
	CServerObject_EventConsumerProviderRegistrationV1 m_EventConsumerProviderRegistration ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ProviderRegistrationV1 () ;
    ~CServerObject_ProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_ComRegistration.GetClsid () ; }

	BOOL PerUserInitialization () { return m_ComRegistration.PerUserInitialization () ; }
	BOOL PerLocaleInitialization () { return m_ComRegistration.PerLocaleInitialization () ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_ComRegistration.GetInitializationReentrancy () ; }
	Enum_ThreadingModel GetThreadingModel () { return m_ComRegistration.GetThreadingModel () ; }	
	Enum_Hosting GetHosting () { return m_ComRegistration.GetHosting () ; }
	LPCWSTR GetHostingGroup () { return m_ComRegistration.GetHostingGroup () ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_ComRegistration.GetUnloadTimeoutMilliSeconds () ; }
	wchar_t *GetProviderName () { return m_ComRegistration.GetProviderName () ; }
	CServerObject_ComProviderRegistrationV1 &GetComRegistration () { return m_ComRegistration ; }

	IWbemClassObject *GetIdentity () { return m_ComRegistration.GetIdentity () ; }

	CServerObject_ClassProviderRegistrationV1 &GetClassProviderRegistration () { return m_ClassProviderRegistration ; }
	CServerObject_InstanceProviderRegistrationV1 &GetInstanceProviderRegistration () { return m_InstanceProviderRegistration ; }
	CServerObject_MethodProviderRegistrationV1 &GetMethodProviderRegistration () { return m_MethodProviderRegistration ; }
	CServerObject_DynamicPropertyProviderRegistrationV1 &GetPropertyProviderRegistration () { return m_PropertyProviderRegistration ; }
	CServerObject_EventProviderRegistrationV1 &GetEventProviderRegistration () { return m_EventProviderRegistration ; }
	CServerObject_EventConsumerProviderRegistrationV1 &GetEventConsumerProviderRegistration () { return m_EventConsumerProviderRegistration ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_ComRegistration.SetUnloadTimeoutMilliSeconds ( a_UnloadTimeoutMilliSeconds ) ; }

	ULONG GetInitializationTimeoutMilliSeconds () { return m_ComRegistration.GetInitializationTimeoutMilliSeconds () ; }

	HRESULT GetResult () { return m_Result ; }

	BOOL ObjectProvider () ;
	BOOL EventProvider () ;
};

#endif // _Server_ProviderRegistrationInfo_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\test\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\common\test\main.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <wbemint.h>
#include <genlex.h>
#include <sql_1.h>

#include <HelperFuncs.h>
#include <Logging.h>
#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CImpQueryPreprocessor : public QueryPreprocessor
{
private:
protected:
public:

	WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 
	) ;

	QueryPreprocessor :: QuadState InvariantEvaluate (

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand
	) ;

	WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CImpQueryPreprocessor :: InvariantEvaluate (

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Undefined ;

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *CImpQueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( _wcsicmp ( a_PropertyName , L"Process" ) == 0 )
	{
		t_Node = new WmiUnsignedIntegerNode ( 

			a_PropertyName , 
			a_Variant.lVal , 
			0x1 ,
			a_Parent 
		) ;
	}
	else if ( _wcsicmp ( a_PropertyName , L"Name" ) == 0 )
	{
		t_Node = new WmiStringNode ( 

			a_PropertyName , 
			a_Variant.bstrVal , 
			a_PropertyFunction ,
			a_ConstantFunction ,
			0x2 ,
			a_Parent 
		) ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *CImpQueryPreprocessor :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName
)
{
	WmiRangeNode *t_RangeNode = NULL ;

	if ( _wcsicmp ( a_PropertyName , L"Process" ) == 0 )
	{
		t_RangeNode = new WmiUnsignedIntegerRangeNode (

			a_PropertyName ,
			0xFFFFFFFF ,
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			0 ,
			0 ,
			NULL ,
			NULL
		) ;
	}
	else if ( _wcsicmp ( a_PropertyName , L"Name" ) == 0 )
	{
		t_RangeNode = new WmiStringRangeNode (

			a_PropertyName ,
			0x0 ,
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			NULL ,
			NULL ,
			NULL ,
			NULL
		) ;
	}

/*
							t_RangeNode = new WmiSignedIntegerRangeNode (

								a_PropertyName ,
								0xFFFFFFFF ,
								TRUE ,
								TRUE ,
								FALSE ,
								FALSE ,
								0 ,
								0 ,
								NULL ,
								NULL
							) ;
*/

	return t_RangeNode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Internal_Analyse ( 

	IWbemQuery *a_QueryAnalyser ,
	wchar_t *a_Query 
)
{
	HRESULT t_Result = S_OK ;

	CImpQueryPreprocessor t_PreProcessor ;

	QueryPreprocessor :: QuadState t_State = t_PreProcessor.Query ( 
	
		a_Query ,
		a_QueryAnalyser
	) ;

	switch ( t_State )
	{
		case QueryPreprocessor :: State_True:
		{
			WmiTreeNode *t_Root = NULL ;

			t_State = t_PreProcessor.PreProcess ( NULL , a_QueryAnalyser , t_Root ) ;
			switch ( t_State )
			{
				case QueryPreprocessor :: State_True:
				{
					PartitionSet *t_Partition = NULL ;

					BSTR t_PropertyContainer [ 2 ] ;
					t_PropertyContainer [ 1 ] = SysAllocString ( L"Process" ) ;
					t_PropertyContainer [ 0 ] = SysAllocString ( L"Name" ) ;
					
					t_State = t_PreProcessor.PreProcess (

						NULL ,
						a_QueryAnalyser ,
						t_Root ,
						2 ,
						t_PropertyContainer ,
						t_Partition
					) ;

					SysFreeString ( t_PropertyContainer [ 0 ] ) ;
					SysFreeString ( t_PropertyContainer [ 1 ] ) ;

					switch ( t_State )
					{
						case QueryPreprocessor :: QuadState :: State_True :
						{
							
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_False :
						{
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_Undefined :
						{
							delete t_Partition ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
						break ;
					}

					delete t_Root ;
				}
				break ;

				case QueryPreprocessor :: State_Error:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
		break ;

		case QueryPreprocessor :: State_Error:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Analyse ( wchar_t *a_Query )
{
	IWbemQuery *t_QueryAnalyser = NULL ;
	HRESULT t_Result = CoCreateInstance (

		CLSID_WbemQuery ,
		NULL ,
		CLSCTX_INPROC_SERVER ,
		IID_IWbemQuery ,
		( void ** ) & t_QueryAnalyser
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Loop = 0 ; t_Loop < 1 ; t_Loop ++ )
		{
			t_Result = Internal_Analyse ( t_QueryAnalyser , a_Query ) ;
		}

		t_QueryAnalyser->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_Table [] =
{
//	L"Select * from Win32_Process Where Name ='Ian' Or ( ( ( Process > 3 And Process < 7 ) or ( Process > 2 And Process < 6 ) ) and Name = 'Steve' ) "
//	L"Select * from Win32_Process Where Name ='Ian' Or ( ( ( Process > 3 And Process < 7 ) or ( Process > 1 And Process < 9 ) or ( Process > 2 And Process < 6 ) ) and Name = 'Steve' ) "
//	L"Select * from Win32_Process Where ( ( Process > 3 And Process < 7 ) or ( Process > 1 And Process < 9 ) or ( Process > 2 And Process < 6 ) ) and Name = 'Steve' "
//	L"Select * from Win32_Process Where ( ( Process > 3 And Process <= 7 ) or ( Process >= 8 And Process < 9 ) ) and Name = 'Steve' "
//	L"Select * from Win32_Process Where ( ( Process > 3 And Process <= 6 ) or ( Process >= 8 And Process < 9 ) ) and Name = 'Steve' "
//	L"Select * from Win32_Process Where Name != 'Steve'"
	L"Select * from Win32_Process Where Name <= 'Steve' And Name >= 'Steve'"
//	L"Select * from Win32_Process Where ( ( Process = 3 or Process = 4 ) ) and Name = 'Steve' "
//	L"Select * from Win32_Process Where ( Process = 4 or Process = 5 ) and Name = 'Steve'" ,
//	L"Select * from Win32_Process Where ( Process = 4 or Process > 3 ) and Name = 'Steve'" 
} ;

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.New (

		( void ** ) & t_Allocator ,
		sizeof ( WmiAllocator ) 
	) ;

	t_StatusCode = WmiDebugLog :: Initialize ( t_Allocator ) ;

	for ( ULONG t_Index = 0 ; t_Index < ( sizeof ( g_Table ) / sizeof ( wchar_t * ) ) ; t_Index ++ )
	{
		HRESULT t_Result = Analyse ( 
		
			g_Table [ t_Index ] 
		) ;
	}

	t_StatusCode = WmiDebugLog :: UnInitialize ( t_Allocator ) ;

	CoUninitialize () ; 

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\assertbreak.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//  AssertBreak.cpp
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#include "precomp.h"

#if defined(_DEBUG) || defined(DEBUG)
#include <polarity.h>
#include <assertbreak.h>
#ifdef UTILLIB
#include <cregcls.h>
#endif
#include <chstring.h>
#include <malloc.h>

#include <cnvmacros.h>

////////////////////////////////////////////////////////////////////////
//
//  Function:   assert_break
//
//  Debug Helper function for displaying a message box
//
//  Inputs:     const char* pszReason - Reason for the  failure.
//              const char* pszFilename - Filename
//              int         nLine - Line Number
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
void WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFileName, int nLine )
{
    
    DWORD t_dwFlag = 0; //

#ifdef UTILLIB
    CRegistry   t_Reg;
    if(t_Reg.Open(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    KEY_READ) == ERROR_SUCCESS) 
    {

        // see if we can find the flag
        if((t_Reg.GetCurrentKeyValue(L"IgnoreAssert", t_dwFlag) != ERROR_SUCCESS))
        {
            t_dwFlag = 0;
        }
    }

#endif

    if (t_dwFlag == 0)
    {
        CHString    strAssert;

        strAssert.Format( L"Assert Failed\n\n[%s:%d]\n\n%s\n\nBreak into Debugger?", pszFileName, nLine, pszReason );

        // Set the MB flags correctly depending on which OS we are running on, since in NT we may
        // be running as a System Service, in which case we need to ensure we have the
        // MB_SERVICE_NOTIFICATION flag on, or the message box may not actually display.

        DWORD   dwFlags = MB_YESNO | MB_ICONSTOP;
        OSVERSIONINFOA OsVersionInfoA;

        OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
        GetVersionExA(&OsVersionInfoA);

        if ( OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Flag changed between OS's (sigh)
            if ( 4 <= OsVersionInfoA.dwMajorVersion )
            {
                dwFlags |= MB_SERVICE_NOTIFICATION;
            }
            else
            {
                dwFlags |= MB_SERVICE_NOTIFICATION_NT3X;
            }
        }

        // Now display the message box.

        int iRet;
        if (OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            iRet = MessageBoxW( NULL, strAssert, L"Assertion Failed!", dwFlags);
        }
        else
        {
            bool t_ConversionFailure = false ;
            char *szAssert = NULL ;

            WCSTOANSISTRING(strAssert, szAssert, t_ConversionFailure );
            if ( ! t_ConversionFailure ) 
            {
                if ( szAssert )
                {
                    iRet = MessageBoxA( NULL, szAssert, "Assertion Failed!", dwFlags);
                }
            }
        }

        if (iRet == IDYES)
        {
            DebugBreak();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\aggregator.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "precomp.h"
#include <wbemint.h>
#include <wmiutils.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"

#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include "ProvWsv.h"
#include "ProvInSk.h"
#include "ProvobSk.h"




/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxyAggr :: DCProxyAggr ( ) : 
	m_ReferenceCount ( 0 ) , 
	m_UnRegistered( 0 ),
	m_Allocator ( *DecoupledProviderSubSystem_Globals :: s_Allocator ),
	CWbemGlobal_IWmiObjectSinkController ( *DecoupledProviderSubSystem_Globals :: s_Allocator ),
	m_Sink(NULL),
	initialized_(false),
	m_Controller(0),
	m_CriticalSection(NOTHROW_LOCK)

{

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxyAggr :: ~DCProxyAggr ()
{
	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Controller )
	{
		CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
		m_Controller->GetContainer ( t_Container ) ;

		m_Controller->Lock () ;

		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;
		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			t_Container->Delete ( t_Element->GetKey () ) ;

			m_Controller->UnLock () ;

			t_Element->Release () ;

			m_Controller->Lock () ;

			t_Iterator = t_Container->Begin () ;
		}

		m_Controller->UnLock () ;

		m_Controller->UnInitialize () ;

		m_Controller->Release () ;

	}


}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxyAggr :: AddRef ( void )
{
	return InterlockedIncrement(&m_ReferenceCount) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxyAggr :: Release ( void )
{
	LONG t_Reference = InterlockedDecrement(&m_ReferenceCount);
	
	if (  0 == t_Reference )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

// IWbemServices

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface, const IID *TInterface_Id>
HRESULT GetProviders (

	IWbemContext *a_Context ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	TInterface **&a_Elements ,
	ULONG &a_ElementCount ,
	ULONG &a_ContainerCount 
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
	WmiStatusCode t_StatusCode = a_Controller->GetContainer ( t_Container ) ;

	a_Controller->Lock () ;

	a_ContainerCount = t_Container->Size () ;

	a_Elements = new TInterface * [ t_Container->Size () ] ;
	if ( a_Elements )
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

		a_ElementCount = 0 ;

		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			a_Elements [ a_ElementCount ] = NULL ;

			_IWmiProviderInitialize *t_Initializer = NULL ;

			t_Result = t_Element->QueryInterface (

				IID__IWmiProviderInitialize	,
				( void ** ) & t_Initializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Initializer->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					HRESULT t_Result = t_Element->QueryInterface ( *TInterface_Id , ( void ** ) & a_Elements [ a_ElementCount ] ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						a_ElementCount ++ ;
					}
				}

				t_Initializer->Release () ;
			}

			t_Iterator.Increment () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Controller->UnLock () ;

	return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface >
HRESULT GetProviders (

	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	TInterface **&a_Elements ,
	ULONG &a_ElementCount
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
	WmiStatusCode t_StatusCode = a_Controller->GetContainer ( t_Container ) ;

	a_Controller->Lock () ;

	a_Elements = new TInterface * [ t_Container->Size () ] ;
	if ( a_Elements )
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

		a_ElementCount = 0 ;

		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			a_Elements [ a_ElementCount ] = NULL ;

			HRESULT t_TempResult = t_Element->QueryInterface ( __uuidof(TInterface) , ( void ** ) & a_Elements [ a_ElementCount ] ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				a_ElementCount ++ ;
			}

			t_Iterator.Increment () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Controller->UnLock () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface>
HRESULT ClearProviders (

	TInterface **a_Elements ,
	ULONG a_ElementCount
) 
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; t_Index < a_ElementCount ; t_Index ++ )
	{
		a_Elements [ t_Index ]->Release () ;
	}

	delete [] a_Elements ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
      

HRESULT DCProxyAggr :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	LPWSTR a_ProviderName,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	if ( initialized() )
		return a_Sink->SetStatus ( WBEM_S_NO_ERROR , 0 ) ;
	

	if( !a_Sink)
		return WBEM_E_INVALID_PARAMETER;

	if(!a_CoreService )
		return a_Sink->SetStatus ( WBEM_E_INVALID_PARAMETER , 0 ) ;
	
	m_context = a_Context;
	
	if (m_context == 0)	// Create a default context or the test provider will fail !
		m_context.CreateInstance(CLSID_WbemContext);
	if (m_context == 0)
		return a_Sink->SetStatus ( WBEM_E_OUT_OF_MEMORY , 0 ) ;


//	m_CoreService = new CInterceptor_IWbemServices_Stub(m_Allocator,a_CoreService);

	m_CoreService = a_CoreService;
	m_Flags = a_Flags;
	


	try{
		m_User = a_User;
		m_Locale = a_Locale;
		m_Namespace = a_Namespace;
		m_ProviderName = a_ProviderName;
		}
	catch( _com_error& err){
		return a_Sink->SetStatus ( WBEM_E_OUT_OF_MEMORY , 0 ) ;

	}
	
	HRESULT t_Result = S_OK ;
	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}


	t_Result = m_NamespacePath.CreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
	}


	if ( SUCCEEDED ( t_Result ) )
	{
		m_Controller = new CWbemGlobal_IWbemSyncProviderController ( m_Allocator ) ;
		if ( m_Controller )
		{
			m_Controller->AddRef () ;

			t_StatusCode = m_Controller->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	LoadAll();

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: CreateSyncProvider ( 

	IUnknown *a_ServerSideProvider ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID a_Identity ,
	CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemDecoupledProvider *t_Interceptor = new CInterceptor_IWbemDecoupledProvider (

		m_Allocator , 
		a_ServerSideProvider ,
		a_Stub ,
		m_Controller , 
		a_Context ,
		a_Registration ,
		a_Identity
	) ;

	if ( t_Interceptor ) 
	{
/*
 *	One for the cache
 */
		t_Interceptor->AddRef () ;

		_IWmiProviderInitialize *t_InterceptorInit = NULL ;

		t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_InterceptorInit->Initialize (

							0 ,
							a_Context ,
							NULL ,
							a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
							a_NamespacePath ,
							NULL ,
							NULL ,
							t_Sink    
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_ProviderInitSink->Wait () ;
							t_Result = t_ProviderInitSink->GetResult () ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_InterceptorInit->Release () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Interceptor->AddRef () ;

			CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

			WmiStatusCode t_StatusCode = m_Controller->Insert ( 

				*t_Interceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			m_Controller->UnLock () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}

		t_Interceptor->SetInitialized ( t_Result ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_Interceptor = t_Interceptor ;
		}
		else
		{
			t_Interceptor->Release () ;
		}
	}
	else
	{
		m_Controller->UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: Register ( DC_reg& reg )
{
	DC_DBkey key( m_User, m_Locale, m_Namespace, m_ProviderName);

	if( !key.equal(reg) )
		return S_OK;

	HRESULT t_Result = S_OK ;
	
	// Check the client pointer
	IUnknown * pUnk = reg.service();
	if (pUnk == 0)
		return WBEM_E_PROVIDER_FAILURE;

	try
	{
		CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;

		if ( t_Registration )
		{
			t_Registration->AddRef () ;

			t_Result = t_Registration->SetContext ( 

				m_context ,
				m_NamespacePath , 
				m_CoreService
			) ;
			
			if ( SUCCEEDED ( t_Result ) )
			{
//				t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_CacheTimeout ) ;

				t_Result = t_Registration->Load ( 

					e_All ,
					m_NamespacePath , 
					reg.GetProvider()
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					m_Controller->Lock () ;

					CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

					WmiStatusCode t_StatusCode = m_Controller->Find ( reg.identity() , t_Iterator ) ;
					
					
					if ( t_StatusCode != e_StatusCode_Success )
					{
						CInterceptor_IWbemServices_Stub *t_Stub = new CInterceptor_IWbemServices_Stub ( m_Allocator , m_CoreService.GetInterfacePtr() ) ;
						
						CInterceptor_IWbemDecoupledProvider * t_Provider = NULL;
						if ( t_Stub )
						{
							t_Stub->AddRef () ;


							CInterceptor_IWbemDecoupledProvider *t_Interceptor = NULL ;


							t_Result = CreateSyncProvider ( 

								pUnk ,
								t_Stub ,
								reg.GetScope() ,
								0 ,
								m_context ,
								reg.GetUser() ,
								reg.GetLocale() ,
								NULL ,
								*t_Registration ,
								reg.identity(),
								t_Interceptor
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								IUnknown *t_Unknown = NULL ;
								t_Result = t_Interceptor->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
								if ( SUCCEEDED ( t_Result ) )
								{

								t_Result = InitializeProvider ( 

									t_Unknown ,
									t_Stub ,
									reg.GetScope() ,
									m_Flags ,
									m_context ,
									reg.GetUser() ,
									reg.GetLocale() ,
									NULL ,
									*t_Registration
								) ;


								if ( SUCCEEDED ( t_Result ) )
								{
									if ( m_Sink )
									{
										IWbemEventProvider *t_EvProvider = NULL ;

										t_Result = pUnk->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & t_EvProvider ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_EvProvider->ProvideEvents ( (IWbemObjectSink *)m_Sink , 0 ) ;

											t_EvProvider->Release () ;
										}

										m_Sink->SetStatus ( 

											WBEM_STATUS_REQUIREMENTS, 
											WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
											NULL, 
											NULL
										) ;
									}
								}

								t_Unknown->Release () ;
								}

								t_Interceptor->Release () ;
							}

							t_Stub->Release () ;
						}
						else
						{
							m_Controller->UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
		  				SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

						m_Controller->UnLock () ;

						t_Element->Release () ;
						t_Result = S_OK ;
					}
				}
			}
	
			t_Registration->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: UnRegister ( GUID a_Identity )
{
	HRESULT t_Result = S_OK ;

	try
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

		IWbemShutdown *t_Shutdown = NULL ;

		m_Controller->Lock () ;

		WmiStatusCode t_StatusCode = m_Controller->Find ( a_Identity , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;			

			t_Result = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;

			m_Controller->Delete ( a_Identity ) ;

			m_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) && t_Shutdown )
			{
				t_Result = t_Shutdown->Shutdown ( 
		
					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

/*
 *	One for the find.
 */

			t_Element->Release () ;

/*
 *	Removed reference due the cache.
 */

			t_Element->Release () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: UnRegister ( const CInterceptor_IWbemDecoupledProvider& provider  )
{
	CInterceptor_IWbemDecoupledProvider& prov = const_cast<CInterceptor_IWbemDecoupledProvider&>(provider);
	return UnRegister(prov.GetKey());
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxyAggr :: InitializeProvider ( 
	IUnknown *a_Unknown ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
  LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	IWbemProviderInit *t_ProviderInit = NULL ;
	t_Result = a_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
		
		if ( t_ProviderInitSink )
		{
			t_ProviderInitSink->AddRef () ;

			t_Result = t_ProviderInitSink->SinkInitialize (a_Registration.GetComRegistration ().GetSecurityDescriptor ()) ;

			CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				try
				{
					BOOL t_Impersonating = FALSE ;
					IUnknown *t_OldContext = NULL ;
					IServerSecurity *t_OldSecurity = NULL ;

					t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ProviderInit->Initialize (

							a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
							0 ,
							( const BSTR ) a_NamespacePath ,
							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
							a_Stub ,
							a_Context ,
							t_Sink    
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_ProviderInitSink->Wait () ;
							t_Result = t_ProviderInitSink->GetResult () ;
						}

						DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					}
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}
				
				t_Sink->Release();
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			t_ProviderInitSink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_ProviderInit->Release () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/



HRESULT DCProxyAggr :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_ObjectGot = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_GettingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_GettingSink )
			{
				t_GettingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_GettingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->GetObjectAsync ( 
							
						a_ObjectPath , 
						0 , 
						a_Context,
						t_GettingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_GettingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_GettingSink->GetResult () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_ObjectGot = TRUE ;
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_GettingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;
					}

					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_GettingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ObjectGot == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
/*	if ( InterlockedCompareExchange ( & m_Initialized , 1 , 1 ) == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

*/	BOOL t_ClassPut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_ClassPuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_ClassPuttingSink )
			{
				t_ClassPuttingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_ClassPuttingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->PutClassAsync ( 
							
						a_Object , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_ClassPuttingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ClassPuttingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_ClassPuttingSink->GetResult () ) )
							{
								t_ClassPut = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassPuttingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_ClassPuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassPut == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
/*	if ( InterlockedCompareExchange ( & m_Initialized , 1 , 1 ) == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

*/	BOOL t_ClassDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_ClassDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_ClassDeletingSink )
			{
				t_ClassDeletingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_ClassDeletingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->DeleteClassAsync ( 
							
						a_Class , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_ClassDeletingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ClassDeletingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_ClassDeletingSink->GetResult () ) )
							{
								t_ClassDeleted = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassDeletingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_ClassDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassDeleted == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE DCProxyAggr :: CreateClassEnumAsync (

	const BSTR a_Superclass , 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
  HRESULT t_Result = S_OK ;
  CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;

			t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

							t_Result = t_Provider->CreateClassEnumAsync ( 
									
								a_Superclass , 
								a_Flags, 
								a_Context,
								t_Sink
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
								else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
									UnRegister(*last_interceptor);
									t_Result = S_OK ;
								}

							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{

/*	if ( InterlockedCompareExchange ( & m_Initialized , 1 , 1 ) == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

*/	BOOL t_InstancePut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_InstancePuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_InstancePuttingSink )
			{
				t_InstancePuttingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_InstancePuttingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->PutInstanceAsync ( 
							
						a_Instance , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_InstancePuttingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_InstancePuttingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_InstancePuttingSink->GetResult () ) )
							{
								t_InstancePut = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstancePuttingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_InstancePuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstancePut == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT DCProxyAggr :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
/*	if ( InterlockedCompareExchange ( & m_Initialized , 1 , 1 ) == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

*/	
	BOOL t_InstanceDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_InstanceDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_InstanceDeletingSink )
			{
				t_InstanceDeletingSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_InstanceDeletingSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->DeleteInstanceAsync ( 
							
						a_ObjectPath , 
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						t_InstanceDeletingSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_InstanceDeletingSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_InstanceDeletingSink->GetResult () ) )
							{
								t_InstanceDeleted = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstanceDeletingSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_InstanceDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstanceDeleted == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
/*	if ( InterlockedCompareExchange ( & m_Initialized , 1 , 1 ) == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

*/	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;

			t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;


					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

							t_Result = t_Provider->CreateInstanceEnumAsync ( 
									
								a_Class, 
								a_Flags, 
								a_Context,
								t_Sink
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
								else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
									UnRegister(*last_interceptor);
									t_Result = S_OK ;
								}

							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
/*	if ( InterlockedCompareExchange ( & m_Initialized , 1 , 1 ) == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

*/	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;

			t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

							t_Result = t_Provider->ExecQueryAsync ( 
									
								a_QueryLanguage, 
								a_Query, 
								a_Flags, 
								a_Context,
								t_Sink
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
								else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
									UnRegister(*last_interceptor);
									t_Result = S_OK ;
								}

							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{

	BOOL t_MethodCalled = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			CInterceptor_IWbemWaitingObjectSink *t_MethodSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_MethodSink )
			{
				t_MethodSink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_MethodSink ,
					t_Iterator
				) ;

				UnLock () ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ;

					t_Result = t_Provider->ExecMethodAsync ( 
							
						a_ObjectPath,
						a_MethodName,
						a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
						a_Context,
						a_InParams,
						t_MethodSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_MethodSink->Wait ( INFINITE ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_MethodSink->GetResult () ) )
							{
								t_MethodCalled = TRUE ;
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
						{
							t_Result = S_OK ;
						}
						else if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
						{
							const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Provider);
							UnRegister(*last_interceptor);
							t_Result = S_OK ;
						}

					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				WmiQueue <IWbemClassObject *,8> &t_Queue = t_MethodSink->GetQueue () ;

				IWbemClassObject *t_Object = NULL ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
				{
					t_Object->Release () ;
					t_StatusCode = t_Queue.DeQueue () ;
				}

				t_MethodSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_MethodCalled == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

//	if ( InterlockedCompareExchangePointer ( ( void ** ) & m_Sink , a_Sink , NULL ) == NULL )
//	{
//		m_Sink->AddRef () ;
//	}

	m_Sink = a_Sink;

	IWbemEventProvider **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	t_Result = GetProviders <IWbemEventProvider> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->ProvideEvents (

 				a_Sink,
				a_Flags
			) ;
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
				const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
				UnRegister(*last_interceptor);
				t_Result = S_OK ;
				}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProvider> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

HRESULT DCProxyAggr ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_AggregatedResult = S_OK ;

	IWbemEventProviderSecurity **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemEventProviderSecurity,&IID_IWbemEventProviderSecurity> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->AccessCheck (

 				a_QueryLanguage,
				a_Query ,
				a_SidLength ,
				a_Sid
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Result != S_OK )
				{
					t_AggregatedResult = t_Result ;
				}
			}
			else
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
					UnRegister(*last_interceptor);
					t_Result = S_OK ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderSecurity> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{		
		if ( t_ContainerCount )
		{
			if ( t_ElementsCount != t_ContainerCount )
			{
				t_AggregatedResult = WBEM_S_SUBJECT_TO_SDS ;
			}
		}

		t_Result = t_AggregatedResult ;
	}

	return t_Result ;
}
	
HRESULT 
DCProxyAggr::LoadAll ( void )
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;
		HRESULT t_TempResult = t_Elements.Load () ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
			
			CServerObject_DecoupledClientRegistration_Element t_Top ;

			WmiStatusCode t_StatusCode ;
			while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
			{
				HRESULT t_TempResult = Register( DC_reg (t_Top ) );
				if (FAILED(t_TempResult) && t_TempResult == WBEM_E_PROVIDER_FAILURE)
					t_Top.Delete(t_Top.GetClsid());
				t_StatusCode = t_Queue.DeQueue () ;
			}
		}
		else
		{
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	initialized_ = true;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->NewQuery (

 				a_Id,
				a_QueryLanguage ,
				a_Query
			) ;
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
				UnRegister(*last_interceptor);
				t_Result = S_OK ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DCProxyAggr ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink> ( m_Controller , t_Elements , t_ElementsCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->CancelQuery ( a_Id ) ;
			
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				const CInterceptor_IWbemDecoupledProvider* last_interceptor = static_cast<CInterceptor_IWbemDecoupledProvider*>(t_Elements [ t_Index ]);
				UnRegister(*last_interceptor);
				t_Result = S_OK ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\callsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

History:

    raymcc      29-Jul-98        First draft.

--*/

#include "precomp.h"
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdio.h>
#include <wbemint.h>
#include "CallSec.h"

// {4551AB1A-C16F-40f3-A192-6A6264FE89D6}
DEFINE_GUID(IID_CWbemCallSecurity, 
0x4551ab1a, 0xc16f, 0x40f3, 0xa1, 0x92, 0x6a, 0x62, 0x64, 0xfe, 0x89, 0xd6);

// {60B9F5CA-036E-4795-BB7C-017B9807E9B3}
DEFINE_GUID(IID_CWbemThreadSecurityHandle, 
0x60b9f5ca, 0x36e, 0x4795, 0xbb, 0x7c, 0x1, 0x7b, 0x98, 0x7, 0xe9, 0xb3);


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT IsNetworkLogin (

	HANDLE a_Token ,
	BOOL &a_Truth 
)
{
	HRESULT t_Result = S_OK ;

	PSID t_NetworkSid = NULL ;

    SID_IDENTIFIER_AUTHORITY t_NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL t_Status = AllocateAndInitializeSid (

        &t_NtAuthority,
        1,
        SECURITY_NETWORK_RID,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_NetworkSid
    ) ;

    if ( t_Status )
    {
		t_Status = CheckTokenMembership ( a_Token, t_NetworkSid, & a_Truth ) ;
		if ( t_Status ) 
		{
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}

		FreeSid ( t_NetworkSid ) ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetImpersonationLevel (

	HANDLE a_Token ,
	SECURITY_IMPERSONATION_LEVEL &a_Level ,
	TOKEN_TYPE &a_TokenType
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_ReturnLength = 0 ;
	BOOL t_TokenStatus = GetTokenInformation (

		a_Token ,
		TokenType ,
		( void * ) & a_TokenType ,
		sizeof ( a_TokenType ) ,
		& t_ReturnLength
	) ;

	if ( t_TokenStatus )
	{
		if ( a_TokenType == TokenImpersonation )
		{
			BOOL t_TempTokenStatus = GetTokenInformation (

				a_Token ,
				TokenImpersonationLevel ,
				( void * ) & a_Level ,
				sizeof ( a_Level ) ,
				& t_ReturnLength
			) ;

			if ( t_TempTokenStatus )
			{
				t_Result = S_OK ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						if ( a_Sid )
						{
							if ( *a_Size >= t_ReturnLength )
							{
								t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
								if ( t_TokenUser )
								{
									t_TokenStatus = GetTokenInformation (

										a_Token ,
										t_TokenInformationClass ,
										t_TokenUser ,
										t_ReturnLength ,
										& t_ReturnLength
									) ;

									if ( t_TokenStatus )
									{
										DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
										*a_Size = t_SidLength ;

										CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

										t_Result = S_OK ;
									}

									delete [] t_TokenUser ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_BUFFER_TOO_SMALL ;
							}
						}
						else
						{
							*a_Size = t_ReturnLength ;

							t_Result = S_OK ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUser (

	HANDLE a_Token ,
    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

    if ( a_Token )
	{
		if ( a_Size && a_Buffer ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;

						t_TokenStatus = GetTokenInformation (

							a_Token ,
							t_TokenInformationClass ,
							t_TokenUser ,
							t_ReturnLength ,
							& t_ReturnLength
						) ;
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			if ( t_TokenStatus )
			{
				SID_NAME_USE t_SidNameUse ;
				wchar_t *t_Domain = NULL ;
				wchar_t *t_User = NULL ;
				ULONG t_DomainSize = 0 ;
				ULONG t_UserSize = 0 ;

				BOOL t_LookupStatus = LookupAccountSidW (

					NULL ,
					t_TokenUser->User.Sid ,
					t_User ,
					& t_UserSize ,
					t_Domain ,
					& t_DomainSize ,
					& t_SidNameUse
				) ;

				if ( ! t_LookupStatus )
				{
					DWORD t_LastError = GetLastError () ;

					switch ( t_LastError ) 
					{
						case ERROR_INSUFFICIENT_BUFFER:
						{
							t_User = new wchar_t [ t_UserSize ] ;
							if ( t_User )
							{
								t_Domain = new wchar_t [ t_DomainSize ] ;
								if ( t_Domain ) 
								{
									t_LookupStatus = LookupAccountSidW (

										NULL ,
										t_TokenUser->User.Sid ,
										t_User ,
										& t_UserSize ,
										t_Domain ,
										& t_DomainSize ,
										& t_SidNameUse
									) ;

									if ( t_LookupStatus )
									{
										ULONG t_Size = wcslen ( t_User ) + wcslen ( t_Domain ) + 2 ;

										if ( *a_Size >= t_Size )
										{
											swprintf ( a_Buffer , L"%s\\%s" , t_Domain , t_User ) ;
										}
										else
										{
											t_Result = WBEM_E_BUFFER_TOO_SMALL ;
										}

										*a_Size = t_Size ;
									}
									else
									{
										if ( GetLastError () == ERROR_NONE_MAPPED )
										{
											t_Result = WBEM_E_NOT_FOUND ;
										}
										else
										{
											t_Result = WBEM_E_FAILED ;
										}
									}

									delete [] t_Domain ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								delete [] t_User ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						break ;

						case ERROR_NONE_MAPPED:
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_FAILED ;
						}
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
				DWORD t_LastError = GetLastError () ;
			}

			if ( t_TokenUser )
			{
				delete [] ( ( BYTE * ) t_TokenUser ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetAuthenticationLuid ( 

	HANDLE a_Token ,
	LPVOID a_Luid
)
{
    if ( a_Token )
	{
		TOKEN_STATISTICS t_Statistics ;

		DWORD t_Returned = 0 ;
		BOOL t_Status = GetTokenInformation (

			a_Token, 
			TokenStatistics, 
			( void * ) & t_Statistics , 
			sizeof ( t_Statistics ) , 
			& t_Returned 
		) ;

		if ( t_Status )
		{
			* ( ( LUID * ) a_Luid ) = t_Statistics.AuthenticationId ;
		}
		else
		{
			return WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
        return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( CLifeControl *a_Control ) : 

	m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( a_Control ) 
{
    if ( m_Control )
    {
        m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( 

	const CWbemThreadSecurityHandle &a_Copy

) : m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( NULL ) 
{
	*this = a_Copy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: ~CWbemThreadSecurityHandle ()
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
	}

    if ( m_ServerPrincipalName )
	{
        CoTaskMemFree ( m_ServerPrincipalName ) ;
	}

    if ( m_Identity )
	{
        CoTaskMemFree ( m_Identity ) ;
	}

    if ( m_Control )
    {
        m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle &CWbemThreadSecurityHandle :: operator= ( const CWbemThreadSecurityHandle &a_Copy )
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
		m_ThreadToken = NULL ;
	}

	if ( a_Copy.m_ThreadToken )
	{
		BOOL t_Status = DuplicateHandle (

			GetCurrentProcess () ,
			a_Copy.m_ThreadToken ,
			GetCurrentProcess () ,
			& m_ThreadToken ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;
	}

	m_Origin = a_Copy.m_Origin ;
    m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

    m_AuthenticationService = a_Copy.m_AuthenticationService ;
    m_AuthorizationService = a_Copy.m_AuthorizationService ;
    m_AuthenticationLevel = a_Copy.m_AuthenticationLevel ;
 
    if ( m_ServerPrincipalName )
    {
        CoTaskMemFree ( m_ServerPrincipalName ) ;
        m_ServerPrincipalName = NULL ;
    }

    if ( a_Copy.m_ServerPrincipalName )
    {        
        m_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( a_Copy.m_ServerPrincipalName ) + 1 ) * 2	) ;
        if ( m_ServerPrincipalName )
		{
            wcscpy ( m_ServerPrincipalName , a_Copy.m_ServerPrincipalName ) ;
		}
    }

    if ( m_Identity )
    {
        CoTaskMemFree ( m_Identity ) ;
        m_Identity = NULL ;
    }

    if ( a_Copy.m_Identity )
    {
        m_Identity = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( a_Copy.m_Identity ) + 1 ) * 2 ) ;
        if ( m_Identity )
		{
            wcscpy ( m_Identity , a_Copy.m_Identity ) ;
		}
    }

	if ( a_Copy.m_Control )
	{
		m_Control = a_Copy.m_Control ;
        if ( m_Control )
        {
            m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
        }

	}

	return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiThreadSecHandle )
    {
        *a_Void = ( void ** ) ( _IWmiThreadSecHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemThreadSecurityHandle )
    {
        *a_Void = ( void ** ) ( CWbemThreadSecurityHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: GetToken ( HANDLE *a_ThreadToken )
{
	HRESULT t_Result = S_OK ;

	if ( a_ThreadToken )
	{
		if ( m_ThreadToken )
		{
			HANDLE t_ThreadToken = NULL ;

			BOOL t_Status = DuplicateHandle (

				GetCurrentProcess () ,
				m_ThreadToken ,
				GetCurrentProcess () ,
				& t_ThreadToken ,
				0 ,
				TRUE ,
				DUPLICATE_SAME_ACCESS
			) ;

			if ( t_Status )
			{
				*a_ThreadToken = t_ThreadToken ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUser ( m_ThreadToken , a_Size , a_Buffer ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUserSid ( m_ThreadToken , a_Size , a_Sid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetAuthenticationLuid ( m_ThreadToken , a_Luid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{		
		if ( a_Level )
		{
			SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
			TOKEN_TYPE t_TokenType = TokenImpersonation ;

			t_Result = :: GetImpersonationLevel ( 

				m_ThreadToken , 
				t_ImpersonationLevel ,
				t_TokenType 		
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				switch ( t_ImpersonationLevel )
				{
					case SecurityAnonymous:
					{
						*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
					}
					break ;
    
					case SecurityIdentification:
					{
						*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
					}
					break ;

					case SecurityImpersonation:
					{
						*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
					}
					break ;

					case SecurityDelegation:
					{
						*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
					}
					break ;

					default:
					{
						*a_Level = 0 ;
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		*a_Level = GetAuthenticationLevel () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: CloneRpcContext ( 

	IServerSecurity *a_Security 
)
{
	HRESULT t_Result = S_OK ;

	// If here, we are not impersonating and we want to gather info
	// about the client's call.
	// ============================================================

	RPC_AUTHZ_HANDLE t_Authorization = NULL ;

	// Ensures auto release of the mutex if we crash

//	CAutoSecurityMutex t_SecurityMutex ;

	DWORD t_ImpersonationLevel = 0 ;

	t_Result = a_Security->QueryBlanket (

		& m_AuthenticationService ,
		& m_AuthorizationService ,
		& m_ServerPrincipalName ,
		& m_AuthenticationLevel ,
		& t_ImpersonationLevel ,
		& t_Authorization ,
		NULL
	) ;

	if ( FAILED ( t_Result ) )
	{

		// In some cases, we cant get the name, but the rest is ok.  In particular
		// the temporary SMS accounts have that property.  Or nt 4 after IPCONFIG /RELEASE

		t_Result = a_Security->QueryBlanket (

			& m_AuthenticationService ,
			& m_AuthorizationService ,
			& m_ServerPrincipalName ,
			& m_AuthenticationLevel ,
			& t_ImpersonationLevel ,
			NULL ,
			NULL
		) ;

		t_Authorization = NULL ;
	}

	// We don't need this anymore.

//	t_SecurityMutex.Release () ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Authorization )
		{
			m_Identity = LPWSTR ( CoTaskMemAlloc ( ( wcslen ( LPWSTR ( t_Authorization ) ) + 1 ) * 2 ) ) ;
			if ( m_Identity )
			{
				wcscpy ( m_Identity , LPWSTR ( t_Authorization ) ) ;
			}
		}

		// Impersonate the client long enough to clone the thread token.
		// =============================================================

		BOOL t_Impersonating = a_Security->IsImpersonating () ;
		if ( ! t_Impersonating )
		{
			t_Result = a_Security->ImpersonateClient () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CloneThreadContext () ;

			if ( ! t_Impersonating )
			{
				a_Security->RevertToSelf () ;
			}
		}
	}
	else
	{        
		// THIS IS A WORKAROUND FOR COM BUG:
		// This failure is indicative of an anonymous-level client. 
		// ========================================================

		m_ImpersonationLevel = 0 ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneThreadContext ()
{
	HRESULT t_Result = S_OK ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

    if ( t_Status ) 
	{
		// Find out token info.
		// =====================

		DWORD t_ImpersonationLevel = 0 ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_ImpersonationLevel ,
			sizeof ( DWORD ) ,
			& t_Returned
		) ;

		if ( t_Status )
		{
			switch ( t_ImpersonationLevel )
			{
				case SecurityAnonymous:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
            
				case SecurityIdentification:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					m_ImpersonationLevel = 0 ;
				}
				break ;
			}

			// Duplicate the thread handle.
			// ============================

			PSECURITY_DESCRIPTOR t_SecurityDescriptor = NULL ;
			DWORD t_LengthRequested = 0 ;
			DWORD t_LengthReturned = 0 ;

			t_Status = GetKernelObjectSecurity (

				t_ThreadToken ,
				DACL_SECURITY_INFORMATION ,
				& t_SecurityDescriptor ,
				t_LengthRequested ,
				& t_LengthReturned
			) ;

			if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
			{
				t_SecurityDescriptor = ( PSECURITY_DESCRIPTOR ) new BYTE [ t_LengthReturned ] ;
				if ( t_SecurityDescriptor )
				{
					t_LengthRequested = t_LengthReturned ;

					t_Status = GetKernelObjectSecurity (

						t_ThreadToken ,
						DACL_SECURITY_INFORMATION ,
						t_SecurityDescriptor ,
						t_LengthRequested ,
						& t_LengthReturned
					) ;

					if ( t_LengthRequested != t_LengthReturned )
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				SECURITY_ATTRIBUTES t_SecurityAttributes ;
				t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( t_SecurityDescriptor ) ;
				t_SecurityAttributes.lpSecurityDescriptor = t_SecurityDescriptor ;
				t_SecurityAttributes.bInheritHandle = FALSE ;

				t_Status = DuplicateTokenEx ( 

					t_ThreadToken,
					MAXIMUM_ALLOWED ,
					& t_SecurityAttributes ,
					( SECURITY_IMPERSONATION_LEVEL ) t_ImpersonationLevel ,
					TokenImpersonation ,
					& m_ThreadToken
				) ;

				if ( t_Status == FALSE )
				{
					DWORD t_LastError = GetLastError () ;
				}
			}

			if ( t_SecurityDescriptor )
			{
				delete [] ( BYTE * ) t_SecurityDescriptor ; 
			}
		}
		else
		{
			t_Result = E_FAIL ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		if ( GetLastError () == ERROR_ACCESS_DENIED )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
		
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneProcessContext ()
{
	HRESULT t_Result = S_OK ;

	m_AuthenticationService = RPC_C_AUTHN_WINNT ;
	m_AuthorizationService = RPC_C_AUTHZ_NONE ;
	m_AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
	m_ServerPrincipalName = NULL ;
	m_Identity = NULL ;

	HANDLE t_ProcessToken = NULL ;
	BOOL t_Status = OpenProcessToken (

		GetCurrentProcess () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
		& t_ProcessToken
	) ;

	if ( t_Status ) 
	{
		t_Status = DuplicateTokenEx (

			t_ProcessToken,
			MAXIMUM_ALLOWED ,
			NULL ,
			( SECURITY_IMPERSONATION_LEVEL ) SecurityImpersonation ,
			TokenImpersonation ,
			& m_ThreadToken
		) ;

		if ( t_Status ) 
		{
			// This is the basic process thread. 
			// =================================

			m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

			t_Result = S_OK ;
		}
		else
		{
			// Unknown error
			// =============

			m_ImpersonationLevel = 0 ;

			t_Result = E_FAIL ;
		}

		CloseHandle ( t_ProcessToken ) ;
	}
	else
	{
		// Unknown error
		// =============

		m_ImpersonationLevel = 0 ;

		t_Result = E_FAIL ;
	}
		
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle  *CWbemThreadSecurityHandle :: New ()
{
	return new CWbemThreadSecurityHandle ( NULL ) ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: CWbemCallSecurity ( 

	CLifeControl *a_Control

) : m_ReferenceCount ( 0 ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_ThreadSecurityHandle ( NULL ) ,
	m_ThreadToken ( NULL ) ,
	m_Control ( a_Control ) 
{
	if ( m_Control ) 
	{
		m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: ~CWbemCallSecurity ()
{
 	if ( m_ThreadToken )
	{
		CloseHandle ( m_ThreadToken ) ;
	}

   if ( m_ThreadSecurityHandle )
	{
        m_ThreadSecurityHandle->Release () ;
	}

	if ( m_Control ) 
	{
		m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity &CWbemCallSecurity :: operator= ( const CWbemCallSecurity &a_Copy )
{
	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_Copy.m_Control )
	{
		m_Control = a_Copy.m_Control ;
        if ( m_Control )
           {
           m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
           }
	}

	if ( a_Copy.m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle = new CWbemThreadSecurityHandle ( * ( a_Copy.m_ThreadSecurityHandle ) ) ;
	}

	m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

	m_ReferenceCount = 1 ;

	return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_IServerSecurity )
    {
        *a_Void = ( void ** ) ( IServerSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemCallSecurity )
    {
        *a_Void = ( void ** ) ( CWbemCallSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiCallSec )
    {
        *a_Void = ( void ** ) ( _IWmiCallSec  *) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryBlanket ( 

	DWORD *a_AuthenticationService ,
	DWORD *a_AuthorizationService ,
	OLECHAR **a_ServerPrincipalName ,
	DWORD *a_AuthenticationLevel ,
	DWORD *a_ImpersonationLevel ,
	void **a_Privileges ,
	DWORD *a_Capabilities
)
{
	if ( m_ThreadSecurityHandle )
	{
		if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
		{
			return E_FAIL ;
		}

		if ( a_AuthenticationService )
		{
			*a_AuthenticationService = m_ThreadSecurityHandle->GetAuthenticationService () ;
		}

		if ( a_AuthorizationService )
		{
			*a_AuthorizationService = m_ThreadSecurityHandle->GetAuthorizationService () ;
		}

		if ( a_AuthenticationLevel )
		{
			*a_AuthenticationLevel = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}

		if ( a_ServerPrincipalName )
		{
			*a_ServerPrincipalName = 0 ;
        
			if ( m_ThreadSecurityHandle->GetServerPrincipalName () )
			{        
				*a_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( m_ThreadSecurityHandle->GetServerPrincipalName () ) + 1 ) * 2 ) ;
				if ( a_ServerPrincipalName )
				{
					wcscpy ( *a_ServerPrincipalName , m_ThreadSecurityHandle->GetServerPrincipalName () ) ;	
				}
				else
				{
					return E_OUTOFMEMORY ;
				}
			}
		}        

		if ( a_Privileges )
		{
			*a_Privileges = m_ThreadSecurityHandle->GetIdentity () ;  // Documented to point to an internal!!
		}
	}
	else
	{
		return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CWbemCallSecurity :: ImpersonateClient ()
{
	if ( m_ImpersonationLevel != 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
			{
				return ( ERROR_CANT_OPEN_ANONYMOUS | 0x80070000 ) ;
			}

			BOOL t_Status = OpenThreadToken (

				GetCurrentThread () ,
				TOKEN_IMPERSONATE ,
				TRUE ,
				& m_ThreadToken
			) ;

			if ( t_Status == FALSE ) 
			{
				DWORD t_LastError = GetLastError () ;
				if ( ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
				{
				}
				else
				{
					return ( ERROR_ACCESS_DENIED | 0x80070000 ) ;
				}
			}

			t_Status = SetThreadToken ( NULL , m_ThreadSecurityHandle->GetThreadToken () ) ;
			if ( t_Status )
			{
				m_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ; 

				return S_OK ;
			}
			else
			{
				CloseHandle ( m_ThreadToken ) ;

				m_ThreadToken = NULL ;	
			}
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return E_FAIL ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: RevertToSelf ()
{
	if ( m_ImpersonationLevel == 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			// If here,we are impersonating and can definitely revert.
			// =======================================================

			BOOL t_Status = SetThreadToken ( NULL , m_ThreadToken ) ;
			if ( t_Status == FALSE )
			{
				return ( GetLastError () |  0x80070000 ) ;
			}

			CloseHandle ( m_ThreadToken ) ;

			m_ThreadToken = NULL ;

			m_ImpersonationLevel = 0 ;
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
BOOL CWbemCallSecurity :: IsImpersonating ()
{
	if ( m_ImpersonationLevel != 0 )
	{
		return TRUE ;
	}

	return FALSE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetThreadSecurity ( 

	WMI_THREAD_SECURITY_ORIGIN a_Origin , 
	_IWmiThreadSecHandle **a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_ValidOrigin = ( ( a_Origin & WMI_ORIGIN_THREAD ) || ( a_Origin & WMI_ORIGIN_EXISTING ) || ( a_Origin & WMI_ORIGIN_RPC ) ) ;

	if ( a_ThreadSecurity && t_ValidOrigin )
	{
		if ( a_Origin & WMI_ORIGIN_THREAD )
		{
			*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
			if ( *a_ThreadSecurity )
			{
				( *a_ThreadSecurity )->AddRef () ;

				( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

				t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneThreadContext () ;
				if ( FAILED ( t_Result ) )
				{	
					( *a_ThreadSecurity )->Release () ;
					*a_ThreadSecurity = NULL;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( a_Origin & WMI_ORIGIN_RPC || a_Origin & WMI_ORIGIN_EXISTING )
			{
				// Figure out if the call context is ours or RPCs
				// ==============================================

				IServerSecurity *t_Security = NULL ;
				t_Result = CoGetCallContext ( IID_IServerSecurity , ( void ** ) & t_Security ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemCallSecurity *t_Internal = NULL ;
					if ( SUCCEEDED ( t_Security->QueryInterface ( IID_CWbemCallSecurity , ( void ** ) & t_Internal ) ) )
					{
						
						// This is our own call context --- this must be an in-proc object
						// calling us from our thread.  Behave depending on the flags
						// ===============================================================

						if ( a_Origin & WMI_ORIGIN_EXISTING ) 
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( *t_Internal->GetThreadSecurityHandle () ) ;
							if ( *a_ThreadSecurity )
							{
								(*a_ThreadSecurity)->AddRef () ;

								t_Result = S_OK ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}

						t_Internal->Release () ;
					}
					else
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}

					if ( t_Result == WBEM_E_NOT_FOUND ) 
					{
						if ( a_Origin & WMI_ORIGIN_RPC )
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
							if ( *a_ThreadSecurity )
							{
								( *a_ThreadSecurity )->AddRef () ;

								t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneRpcContext ( 

									t_Security 
								) ;

								if ( SUCCEEDED( t_Result ) )
								{
									( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity) ->SetOrigin ( WMI_ORIGIN_RPC ) ;
								}
								else
								{	
									( *a_ThreadSecurity )->Release ();
									*a_ThreadSecurity = NULL;
								}

							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}

					t_Security->Release();
				}
				else
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					if ( a_Origin & WMI_ORIGIN_THREAD )
					{
						*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
						if ( *a_ThreadSecurity )
						{
							( *a_ThreadSecurity )->AddRef () ;

							( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

							t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			else
			{
				if ( a_Origin & WMI_ORIGIN_THREAD )
				{
					*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
					if ( *a_ThreadSecurity )
					{
						( *a_ThreadSecurity )->AddRef () ;

						( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

						t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: SetThreadSecurity ( 

	_IWmiThreadSecHandle *a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_ThreadSecurity ) 
	{
		CWbemThreadSecurityHandle *t_ThreadHandle = NULL ; 
		t_Result = a_ThreadSecurity->QueryInterface ( IID_CWbemThreadSecurityHandle , ( void ** ) & t_ThreadHandle ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			m_ThreadSecurityHandle = t_ThreadHandle ;

			IUnknown *t_Unknown = NULL ;
			IUnknown *t_SwitchUnknown = NULL ;
			t_Result = this->QueryInterface ( IID_IUnknown , ( void **) & t_SwitchUnknown ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoSwitchCallContext ( t_SwitchUnknown, & t_Unknown ) ;
		
				t_SwitchUnknown->Release () ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess() ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUser ( t_Token , a_Size , a_Buffer ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUserSid ( t_Token , a_Size , a_Sid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetAuthenticationLuid ( t_Token , a_Luid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		HANDLE t_Token = NULL ;

		BOOL t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			& t_Token
		) ;

		DWORD t_LastError = GetLastError () ;
		if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
		{
			*a_Level = 0 ;
		}
		else
		{
			if ( t_Status ) 
			{
				SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
				TOKEN_TYPE t_TokenType = TokenImpersonation ;
 
				t_Result = :: GetImpersonationLevel ( 

					t_Token , 
					t_ImpersonationLevel ,
					t_TokenType 		
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					switch ( t_ImpersonationLevel )
					{
						case SecurityAnonymous:
						{
							*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
						}
						break ;
            
						case SecurityIdentification:
						{
							*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
						}
						break ;

						case SecurityImpersonation:
						{
							*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
						}
						break ;

						case SecurityDelegation:
						{
							*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
						}
						break ;

						default:
						{
							*a_Level = 0 ;
						}
						break ;
					}
				}

				CloseHandle ( t_Token ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		if ( m_ThreadSecurityHandle )
		{
			*a_Level = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity  *CWbemCallSecurity :: New ()
{
	return new CWbemCallSecurity ( NULL ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\cglobals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <sddl.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
//#include <winntsec.h>
//#include <wbemcomn.h>
#include <callsec.h>
#include <cominit.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>
#include <PSSException.h>
#include <Cache.h>

#include "DateTime.h"
#include "CGlobals.h"

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <ReaderWriter.cpp>
#include <Logging.cpp>

#include <Cache.cpp>

#include <CallSec.h>
#include <OS.h>
#include <ssdlhelper.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR ProviderSubSystem_Common_Globals :: s_Wql = L"Wql" ;
LPCWSTR ProviderSubSystem_Common_Globals :: s_Provider = L"Provider" ;

WORD ProviderSubSystem_Common_Globals :: s_System_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize = 0 ;
WORD ProviderSubSystem_Common_Globals :: s_LocalAdmins_ACESize = 0 ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Provider_LocalAdmins_ACE = NULL ;

ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE = NULL ;
ACCESS_ALLOWED_ACE *ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalAdmins_ACE = NULL ;

SECURITY_DESCRIPTOR *ProviderSubSystem_Common_Globals :: s_MethodSecurityDescriptor = NULL ;

ULONG ProviderSubSystem_Common_Globals :: s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;
ULONG ProviderSubSystem_Common_Globals :: s_DefaultStackSize = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateInstance ( 

	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateRemoteInstance ( 

	LPCWSTR a_Server ,
	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = ( LPWSTR ) a_Server ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespaceServerPath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_ServerNamespacePath
)
{
	a_ServerNamespacePath = NULL ;

	wchar_t *t_Server = NULL ;
	ULONG t_ServerLength = 0 ;

	HRESULT t_Result = a_Namespace->GetServer (

		& t_ServerLength , 
		t_Server
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Server = new wchar_t [ t_ServerLength + 1 ] ;

		t_Result = a_Namespace->GetServer (

			& t_ServerLength , 
			t_Server
		) ;

		if ( FAILED ( t_Result ) )
		{
			delete [] t_Server ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_ConcatString = NULL ;

		WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

			2 , 
			& t_ConcatString ,
			L"\\\\" ,
			t_Server
		) ;

		delete [] t_Server ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_ServerNamespacePath = t_ConcatString ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_NamespaceCount = 0 ;

        t_Result = a_Namespace->GetNamespaceCount (

            & t_NamespaceCount 
		) ;

		if ( t_NamespaceCount )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
			{
				wchar_t *t_Namespace = NULL ;
				ULONG t_NamespaceLength = 0 ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

    				t_Result = a_Namespace->GetNamespaceAt (

						t_Index ,
						& t_NamespaceLength ,
						t_Namespace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						wchar_t *t_ConcatString = NULL ;

						WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

							3 , 
							& t_ConcatString ,
							a_ServerNamespacePath ,
							L"\\" ,
							t_Namespace
						) ;

						delete [] t_Namespace ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							delete [] a_ServerNamespacePath ;
							a_ServerNamespacePath = t_ConcatString ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_NAMESPACE ;
		}
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_ServerNamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetNamespacePath (

	IWbemPath *a_Namespace ,
	wchar_t *&a_NamespacePath
)
{
	a_NamespacePath = NULL ;

	ULONG t_NamespaceCount = 0 ;

    HRESULT t_Result = a_Namespace->GetNamespaceCount (

        & t_NamespaceCount 
	) ;

	if ( t_NamespaceCount )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_NamespaceCount ; t_Index ++ )
		{
			wchar_t *t_Namespace = NULL ;
			ULONG t_NamespaceLength = 0 ;

    		t_Result = a_Namespace->GetNamespaceAt (

				t_Index ,
				& t_NamespaceLength ,
				t_Namespace 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Namespace = new wchar_t [ t_NamespaceLength + 1 ] ;

    			t_Result = a_Namespace->GetNamespaceAt (

					t_Index ,
					& t_NamespaceLength ,
					t_Namespace 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_ConcatString = NULL ;

					WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings_Wchar ( 

						3 , 
						& t_ConcatString ,
						a_NamespacePath ,
						t_Index ? L"\\" : NULL ,
						t_Namespace
					) ;

					delete [] t_Namespace ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						delete [] a_NamespacePath ;
						a_NamespacePath = t_ConcatString ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
				break ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_NAMESPACE ;
	}

	if ( FAILED ( t_Result ) ) 
	{
		delete [] a_NamespacePath ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetPathText (

	IWbemPath *a_Path ,
	wchar_t *&a_ObjectPath
)
{
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Path->GetText ( 

		0 ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		a_ObjectPath = new wchar_t [ t_ObjectPathLength + 1 ] ;
		if ( a_ObjectPath )
		{
			t_Result = a_Path->GetText ( 

				0 ,
				& t_ObjectPathLength ,
				a_ObjectPath
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: BeginImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating ,
	DWORD *a_AuthenticationLevel
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	_IWmiCallSec *t_CallSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

		CLSID__IWbemCallSec ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID__IWmiCallSec ,
		( void ** ) & t_CallSecurity 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD | WMI_ORIGIN_EXISTING | WMI_ORIGIN_RPC ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_AuthenticationLevel )
					{
						t_Result = t_ThreadSecurity->GetAuthentication ( a_AuthenticationLevel  ) ;
					}

					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EndImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_ClientSecurity->CopyProxy (

				a_Interface ,
				( IUnknown ** ) & a_Proxy
			) ;

			t_ClientSecurity->Release () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetProxy (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface ,
	IUnknown *&a_Proxy 
)
{
	IUnknown *t_Unknown = NULL ;

    HRESULT t_Result = a_Interface->QueryInterface (
	
		a_InterfaceId , 
		( void ** ) & t_Unknown
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
	    IClientSecurity *t_ClientSecurity = NULL ;

		t_Result = a_Interface->QueryInterface (
		
			IID_IClientSecurity , 
			( void ** ) & t_ClientSecurity
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

			WmiStatusCode t_StatusCode = a_Container.Top ( a_Proxy , a_ProxyIndex ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = a_Container.Reserve ( a_ProxyIndex ) ;
			}
			else
			{
				if ( a_Container.GetCurrentSize () < a_Container.GetTopSize () )
				{
					t_Result = t_ClientSecurity->CopyProxy (

						a_Interface ,
						( IUnknown ** ) & a_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						a_Container.SetCurrentSize ( a_Container.GetCurrentSize () + 1 ) ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

			t_ClientSecurity->Release () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		t_Unknown->Release () ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown ,
	DWORD a_AuthenticationLevel ,
	DWORD a_ImpersonationLevel
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			a_AuthenticationLevel ,
			a_ImpersonationLevel ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCloaking ( 

	IUnknown *a_Unknown
)
{
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			RPC_C_AUTHN_LEVEL_DEFAULT ,
			RPC_C_IMP_LEVEL_DEFAULT ,
			NULL ,
			EOAC_DYNAMIC_CLOAKING
		) ;

		t_ClientSecurity->Release () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ProviderSubSystem_Common_Globals :: IsProxy ( IUnknown *a_Unknown )
{
	BOOL t_IsProxy ;

    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_IsProxy = TRUE ;
		t_ClientSecurity->Release () ;
	}
	else
	{
		t_IsProxy = FALSE ;
	}

	return t_IsProxy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE ,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ( HANDLE a_Token )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ReturnedLength = 0 ;

	BOOL t_Status = GetTokenInformation (

		a_Token , 
		TokenPrivileges , 
		NULL , 
		0 , 
		& t_ReturnedLength
	) ;

	UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
	if ( t_Buffer )
	{
		t_Status = GetTokenInformation (

			a_Token , 
			TokenPrivileges , 
			t_Buffer , 
			t_ReturnedLength , 
			& t_ReturnedLength
		) ;

		if ( t_Status )
		{
			TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;

			for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
			{
				t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
			}

			t_Status = AdjustTokenPrivileges (

				a_Token, 
				FALSE, 
				t_Privileges , 
				0, 
				NULL, 
				NULL
			) ;

			if ( t_Status == FALSE )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Status = WBEM_E_ACCESS_DENIED ;
		}

		delete [] t_Buffer ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: EnableAllPrivileges ()
{
	HRESULT t_Result = S_OK ;

    HANDLE t_Token = NULL ;

    BOOL t_Status = TRUE ;

	t_Status = OpenThreadToken (

		GetCurrentThread (), 
		TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES ,
		FALSE, 
		&t_Token
	) ;

    if ( t_Status )
	{
		DWORD t_ReturnedLength = 0 ;

		t_Status = GetTokenInformation (

			t_Token , 
			TokenPrivileges , 
			NULL , 
			0 , 
			& t_ReturnedLength
		) ;
    
		UCHAR *t_Buffer = new UCHAR [ t_ReturnedLength ] ;
		if ( t_Buffer )
		{
			t_Status = GetTokenInformation (

				t_Token , 
				TokenPrivileges , 
				t_Buffer , 
				t_ReturnedLength , 
				& t_ReturnedLength
			) ;

			if ( t_Status )
			{
				TOKEN_PRIVILEGES *t_Privileges = ( TOKEN_PRIVILEGES * ) t_Buffer ;

				for ( ULONG t_Index = 0; t_Index < t_Privileges->PrivilegeCount ; t_Index ++ )
				{
					t_Privileges->Privileges [ t_Index ].Attributes |= SE_PRIVILEGE_ENABLED ;
				}

				t_Status = AdjustTokenPrivileges (

					t_Token, 
					FALSE, 
					t_Privileges , 
					0, 
					NULL, 
					NULL
				) ;

				if ( t_Status == FALSE )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			else
			{
				t_Status = WBEM_E_ACCESS_DENIED ;
			}

			delete [] t_Buffer ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		CloseHandle ( t_Token ) ;
	}
	else
	{
		DWORD t_LastError = GetLastError () ;
        t_Result = WBEM_E_ACCESS_DENIED;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetAnonymous ( IUnknown *a_Proxy )
{
	HRESULT t_Result = SetInterfaceSecurity (

		a_Proxy ,
		NULL ,
		NULL ,
		NULL ,
                DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
		RPC_C_IMP_LEVEL_ANONYMOUS
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_SvcHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize,
	SECURITY_IMPERSONATION_LEVEL impersonationLevel
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

	DWORD dummy = 0;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		HANDLE t_AdjustedThreadToken = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												//DUPLICATE_SAME_ACCESS ,
												MAXIMUM_ALLOWED ,//| TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
												& t_SecurityAttributes ,
												impersonationLevel ,
												TokenImpersonation ,
												& t_AdjustedThreadToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_ProcessHandle = OpenProcess (

				MAXIMUM_ALLOWED,
				FALSE ,
				a_ProcessIdentifier 
			) ;


			if ( t_ProcessHandle )
			{
				t_Status = DuplicateHandle (

					GetCurrentProcess() ,
					t_AdjustedThreadToken ,
					t_ProcessHandle ,
					& a_IdentifyToken ,
					0,//MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					DUPLICATE_SAME_ACCESS 
				) ;

				if ( t_Status )
				{

				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		if ( t_AdjustedThreadToken )
		{
			CloseHandle ( t_AdjustedThreadToken ) ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ConstructIdentifyToken_PrvHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												DUPLICATE_SAME_ACCESS ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) SecurityIdentification ,
												TokenImpersonation ,
												& a_IdentifyToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}


HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ConstructIdentifyToken_PrvHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					s_Token_All_Access_System_ACE ,
					s_System_ACESize
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}

			CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost (

	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	HRESULT t_Result = S_OK ;

	a_Proxy->Release () ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	CloseHandle ( a_IdentifyToken ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetCallState ( 

	IUnknown *a_Interface , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = S_OK ;
	
	if ( IsProxy ( a_Interface ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			t_Result = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				CoRevertToSelf () ;

				a_Revert = FALSE ;

				t_Result = WBEM_E_ACCESS_DENIED ;

#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }
	}
	else 
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT ProviderSubSystem_Common_Globals :: RevertCallState (

	BOOL a_Revert
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SetProxyState ( 

	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = GetProxy ( a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

			DWORD t_ImpersonationLevel = GetCurrentImpersonationLevel () ;

			if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
			{
			}
			else
			{
				t_Result = SetInterfaceSecurity (

					a_Proxy ,
					NULL ,
					NULL ,
					NULL ,
					DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
					RPC_C_IMP_LEVEL_IDENTIFY
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
        }
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: RevertProxyState ( IUnknown *a_Proxy , BOOL a_Revert )
{
	HRESULT t_Result = S_OK ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	a_Proxy->Release () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_Data = 0 ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_DWORD ) )
	{
		a_Value = t_Data ;
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_SZ ) )
	{
		t_Data = new wchar_t [ t_DataSize / sizeof ( wchar_t ) ] ;
		if ( t_Data )
		{
			t_RegResult = OS::RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = SysAllocString ( t_Data ) ;
				if ( a_Value == NULL )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] t_Data ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;
	BYTE *t_Data = NULL ;
	DWORD t_DataSize = 0 ;

	LONG t_RegResult = OS::RegQueryValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  & t_ValueType ,
	  NULL ,
	  & t_DataSize 
	) ;

	if ( ( t_RegResult == ERROR_SUCCESS ) && ( t_ValueType == REG_BINARY ) )
	{
		t_Data = new BYTE [ t_DataSize ] ;
		if ( t_Data )
		{
			t_RegResult = OS::RegQueryValueEx (

				a_Key ,
				a_Name ,
				0 ,
				& t_ValueType ,
				LPBYTE ( t_Data ) ,
				& t_DataSize 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				a_Value = t_Data ;
				a_ValueLength = t_DataSize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				DWORD t_LastError = GetLastError () ;
				DebugBreak () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = ERROR_FILE_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_DWORD ;
	DWORD t_DataSize = sizeof ( t_ValueType ) ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( & a_Value ) ,
	  t_DataSize 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	DWORD t_DataSize = wcslen ( a_Value ) + 1 ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  t_DataSize * sizeof ( wchar_t ) 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_BINARY ;

	LONG t_RegResult = OS::RegSetValueEx (

	  a_Key ,
	  a_Name ,
	  0 ,
	  t_ValueType ,
	  LPBYTE ( a_Value ) ,
	  a_ValueLength 
	) ;

	if ( t_RegResult != ERROR_SUCCESS ) 
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: UnMarshalRegistration (

	IUnknown **a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoUnmarshalInterface (

				t_Stream ,
				IID_IUnknown ,
				( void ** ) a_Unknown
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: ReleaseRegistration (

	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	IStream *t_Stream = NULL ;

	HGLOBAL t_Global = GlobalAlloc (

		GHND ,
		a_MarshaledProxyLength
	) ;

	if ( t_Global ) 
	{
		void *t_Memory = GlobalLock ( t_Global ) ;

		CopyMemory ( t_Memory , a_MarshaledProxy , a_MarshaledProxyLength ) ;

		GlobalUnlock ( t_Global ) ;

		t_Result = CreateStreamOnHGlobal (

			t_Global ,
			TRUE ,
			& t_Stream 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoReleaseMarshalData (

				t_Stream
			) ;

			t_Stream->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ; 
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: MarshalRegistration (

	IUnknown *a_Unknown ,
	BYTE *&a_MarshaledProxy ,
	DWORD &a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	t_Result = CoGetMarshalSizeMax (

		& a_MarshaledProxyLength ,
		IID_IUnknown ,
		a_Unknown ,
		MSHCTX_LOCAL ,
		NULL ,
		MSHLFLAGS_TABLEWEAK
	) ;
 
	if ( SUCCEEDED ( t_Result ) ) 
	{
		IStream *t_Stream = NULL ;

		HGLOBAL t_Global = GlobalAlloc (

			GHND ,
			a_MarshaledProxyLength
		) ;

		if ( t_Global ) 
		{
			t_Result = CreateStreamOnHGlobal (

			  t_Global ,
			  TRUE ,
			  & t_Stream 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoMarshalInterface (

					t_Stream ,
					IID_IUnknown ,
					a_Unknown ,
					MSHCTX_LOCAL ,
					NULL ,
					MSHLFLAGS_TABLESTRONG
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					a_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
					if ( a_MarshaledProxy )
					{
						void *t_Memory = GlobalLock ( t_Global ) ;

						CopyMemory ( a_MarshaledProxy , t_Memory , a_MarshaledProxyLength ) ;

						GlobalUnlock ( t_Global ) ;

					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ; 
					}
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ; 
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: IsDependantCall ( IWbemContext *a_ParentContext , IWbemContext *a_ChildContext , BOOL &a_DependantCall )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( a_ParentContext )
	{
		if ( a_ChildContext )
		{
			IWbemCausalityAccess *t_ParentCausality = NULL ;
			t_Result = a_ParentContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ParentCausality ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemCausalityAccess *t_ChildCausality = NULL ;
				t_Result = a_ChildContext->QueryInterface ( IID_IWbemCausalityAccess , ( void ** ) & t_ChildCausality ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					REQUESTID t_ParentId ;

					t_Result = t_ParentCausality->GetRequestId ( & t_ParentId ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_ChildCausality->IsChildOf ( t_ParentId ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							a_DependantCall = ( t_Result == S_FALSE ) ? FALSE : TRUE ;
						}
					}

					t_ChildCausality->Release () ;		
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}

				t_ParentCausality->Release () ;		
			}
		}
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	const UINT64 &a_Uint64
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		0 ,
		CIM_UINT64 ,
		( void * ) & a_Uint64
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Uint16 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const WORD &a_Uint16
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		0 ,
		CIM_UINT16 ,
		( void * ) & a_Uint16
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Bool ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const BOOL &a_Bool
)
{
	WORD t_Word = ( WORD ) a_Bool ;

	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		0 ,
		CIM_BOOLEAN ,
		( void * ) & t_Word
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME a_Time
)
{
	CWbemDateTime t_Time ;
	t_Time.SetFileTimeDate ( a_Time , VARIANT_FALSE ) ;

	BSTR t_String ;
	HRESULT t_Result = t_Time.GetValue ( & t_String ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_BSTR ;
		t_Variant.bstrVal = t_String ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , CIM_DATETIME ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Set_Byte_Array  ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	BYTE *a_Bytes ,
	WORD a_BytesCount 
)
{
	HRESULT t_Result = S_OK ;
 
	LONG t_Dimension = 1 ; 

	SAFEARRAYBOUND t_ArrayBounds ;
	t_ArrayBounds.cElements = a_BytesCount ; 
	t_ArrayBounds.lLbound = 0 ;

	SAFEARRAY *t_Array = SafeArrayCreate ( 

		VT_I1 , 
		t_Dimension ,
		& t_ArrayBounds
	) ;

	if ( t_Array )
	{
		for ( LONG t_Index = 0 ; t_Index <= a_BytesCount ; t_Index ++ )
		{
			if ( SUCCEEDED ( SafeArrayPutElement ( t_Array , & t_Index , & a_Bytes [ t_Index ] ) ) )
			{
			}
			else
			{
				SafeArrayDestroy ( t_Array ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;

				break ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_ARRAY | VT_I1  ;
		t_Variant.parray = t_Array ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	UINT64 &a_Uint64 ,
	BOOL &a_Null
)
{
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		& t_Type ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Uint64
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_UINT64 )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	DWORD &a_Uint32 ,
	BOOL &a_Null
)
{
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		& t_Type  ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Uint32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_UINT32 )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Uint16 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	WORD &a_Uint16 ,
	BOOL &a_Null 
)
{
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		& t_Type  ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Uint16
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_UINT16 )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_Bool ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	BOOL &a_Bool ,
	BOOL &a_Null
)
{
	WORD t_Word = 0 ;
	ULONG t_ReturnedSize = 0 ;
	LONG t_Flavour = 0 ;
	CIMTYPE t_Type = CIM_EMPTY ;

	HRESULT t_Result = a_Instance->ReadProp (

		a_Name , 
		0 , 
		sizeof ( WORD ) , 
		& t_Type ,
		& t_Flavour ,
		& a_Null ,
		& t_ReturnedSize ,
		( void * ) & a_Bool
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Type == CIM_BOOLEAN )
		{
			a_Bool = t_Word ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *&a_String ,
	BOOL &a_Null
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
					
	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Instance->Get ( a_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ( t_VarType == CIM_STRING ) && ( t_Variant.vt == VT_BSTR ) )
		{
			a_String = new wchar_t [ wcslen ( t_Variant.bstrVal ) + 1 ] ;
			if ( a_String )
			{
				wcscpy ( a_String , t_Variant.bstrVal ) ;

				a_Null = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( ( t_VarType == CIM_STRING ) && ( t_Variant.vt == VT_NULL ) )
		{
			a_Null = TRUE ;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Get_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME &a_Time ,
	BOOL &a_Null
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
					
	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Instance->Get ( a_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ( t_VarType == CIM_DATETIME ) && ( t_Variant.vt == VT_BSTR ) )
		{
			CWbemDateTime t_Time ;
			t_Result = t_Time.PutValue ( t_Variant.bstrVal ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Time.GetFileTimeDate ( a_Time ) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROPERTY ;
			}

			a_Null = FALSE ;
		}
		else if ( ( t_VarType == CIM_DATETIME ) && ( t_Variant.vt == VT_NULL ) )
		{
			a_Null = TRUE ;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping
)
{
	HRESULT t_Result = S_OK ;

	if ( a_SecurityDescriptor )
	{
		HANDLE t_Token = NULL ;

		BOOL t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY ,
			TRUE ,
			& t_Token 										
		) ;

		DWORD t_LastError = GetLastError () ;
		if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
		{
			HANDLE t_ProcessToken = NULL ;
			t_Status = OpenProcessToken (

				GetCurrentProcess () ,
				TOKEN_QUERY | TOKEN_DUPLICATE ,
				& t_ProcessToken
			) ;

			if ( t_Status )
			{
				t_Status = ImpersonateLoggedOnUser ( t_ProcessToken ) ;
				if ( t_Status )
				{
					BOOL t_Status = OpenThreadToken (

						GetCurrentThread () ,
						TOKEN_QUERY ,
						TRUE ,
						& t_Token 										
					) ;

					if ( ! t_Status )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					RevertToSelf () ;
				}
				else
				{
					DWORD t_LastError = GetLastError () ;

					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessToken ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			if ( ! t_Status ) 
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_Access = 0 ;
			BOOL t_AccessStatus = FALSE ;
			PRIVILEGE_SET *t_PrivilegeSet = NULL ;
			DWORD t_PrivilegeSetSize = 0 ;
		
			MapGenericMask (

				& a_Access ,
				a_Mapping
			) ;

			t_Status = AccessCheck (

				a_SecurityDescriptor ,
				t_Token,
				a_Access ,
				a_Mapping ,
				NULL ,
				& t_PrivilegeSetSize ,
				& t_Access ,
				& t_AccessStatus
			) ;

			if ( t_Status && t_AccessStatus )
			{
			}
			else
			{
				DWORD t_LastError = GetLastError () ;
				if ( t_LastError == ERROR_INSUFFICIENT_BUFFER )
				{
					t_PrivilegeSet = ( PRIVILEGE_SET * ) new BYTE [ t_PrivilegeSetSize ] ;
					if ( t_PrivilegeSet )
					{
						t_Status = AccessCheck (

							a_SecurityDescriptor ,
							t_Token,
							a_Access ,
							a_Mapping ,
							t_PrivilegeSet ,
							& t_PrivilegeSetSize ,
							& t_Access ,
							& t_AccessStatus
						) ;

						if ( t_Status && t_AccessStatus )
						{
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						delete [] ( BYTE * ) t_PrivilegeSet ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED;
				}
			}

			CloseHandle ( t_Token ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void DumpThreadTokenSecurityDescriptor ()
{
    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

    if ( t_Status ) 
	{
		PSECURITY_DESCRIPTOR t_SecurityDescriptor = NULL ;
		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( PSECURITY_DESCRIPTOR ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				delete [] t_SecurityDescriptor ;
			}
		}

		CloseHandle ( t_ThreadToken ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

	SID *a_OwnerSid , 
	SID *a_GroupSid , 
	DWORD a_Access ,
	SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
	SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	SECURITY_DESCRIPTOR t_CreatedSecurityDescriptor ;
	SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

	PACL t_Dacl = NULL ;
	PACL t_Sacl = NULL ;
	PSID t_Owner = NULL ;
	PSID t_PrimaryGroup = NULL ;
	SECURITY_DESCRIPTOR *t_AlteredSecurityDescriptor = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SecurityDescriptor )
		{
			DWORD t_AlteredSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;
			DWORD t_DaclSize = 0 ;
			DWORD t_SaclSize = 0 ;
			DWORD t_OwnerSize = 0 ;
			DWORD t_PrimaryGroupSize = 0 ;

			BOOL t_Status = MakeAbsoluteSD (

			  a_SecurityDescriptor ,
			  t_AlteredSecurityDescriptor ,
			  & t_AlteredSecurityDescriptorSize ,
			  t_Dacl,
			  & t_DaclSize,
			  t_Sacl,
			  & t_SaclSize,
			  t_Owner,
			  & t_OwnerSize,
			  t_PrimaryGroup,
			  & t_PrimaryGroupSize
			) ;

			if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
				DWORD t_ExtraSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

				t_Dacl = ( PACL ) new BYTE [ t_DaclSize + t_ExtraSize ] ;
				t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
				t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
				t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;

				t_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AlteredSecurityDescriptorSize ] ;

				if ( t_AlteredSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
				{
					BOOL t_Status = InitializeSecurityDescriptor ( t_AlteredSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
					if ( t_Status )
					{
						t_Status = MakeAbsoluteSD (

							a_SecurityDescriptor ,
							t_AlteredSecurityDescriptor ,
							& t_AlteredSecurityDescriptorSize ,
							t_Dacl,
							& t_DaclSize,
							t_Sacl,
							& t_SaclSize,
							t_Owner,
							& t_OwnerSize,
							t_PrimaryGroup,
							& t_PrimaryGroupSize
						) ;

						if ( t_Status )
						{
							t_SecurityDescriptor = t_AlteredSecurityDescriptor ;

							if ( t_OwnerSize == 0 )
							{
								t_Status = SetSecurityDescriptorOwner (

									t_SecurityDescriptor ,
									a_OwnerSid ,
									FALSE 
								) ;

								if ( ! t_Status )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_PrimaryGroupSize == 0 )
								{
									t_Status = SetSecurityDescriptorGroup (

										t_SecurityDescriptor ,
										a_GroupSid ,
										FALSE 
									) ;

									if ( ! t_Status )
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			BOOL t_Status = InitializeSecurityDescriptor ( & t_CreatedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_Status )
			{
				t_Status = SetSecurityDescriptorOwner (

					& t_CreatedSecurityDescriptor ,
					a_OwnerSid ,
					FALSE 
				) ;

				if ( ! t_Status )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Status = SetSecurityDescriptorGroup (

						& t_CreatedSecurityDescriptor ,
						a_GroupSid ,
						FALSE 
					) ;

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_SecurityDescriptor = & t_CreatedSecurityDescriptor ;
		}
	}


	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;
	DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;

	PACL t_ExtraDacl = NULL ;
	ACCESS_ALLOWED_ACE *t_Ace = NULL ;
	DWORD t_AceSize = 0 ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
		if ( t_Ace )
		{
			CopySid ( t_SidLength, (PSID) & t_Ace->SidStart, a_OwnerSid ) ;
			t_Ace->Mask = a_Access ;
			t_Ace->Header.AceType = 0 ;
			t_Ace->Header.AceFlags = 0 ;
			t_Ace->Header.AceSize = t_AceSize ;

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ACL_SIZE_INFORMATION t_Size ;

		if ( t_Dacl )
		{
			BOOL t_Status = GetAclInformation (

				t_Dacl ,
				& t_Size ,
				sizeof ( t_Size ) ,
				AclSizeInformation
			);

			if ( t_Status )
			{
				DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
				t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

				t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
				if ( t_ExtraDacl )
				{
					CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
					t_ExtraDacl->AclSize = t_ExtraSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			DWORD t_SidLength = GetLengthSid ( a_OwnerSid ) ;
			DWORD t_ExtraSize = sizeof ( ACL ) + ( sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ) ;
			t_ExtraSize = t_ExtraSize + s_LocalService_ACESize + s_NetworkService_ACESize + s_System_ACESize + s_LocalAdmins_ACESize ;

			t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
			if ( t_ExtraDacl )
			{
				BOOL t_Status = InitializeAcl (

					t_ExtraDacl ,
					t_ExtraSize ,
					ACL_REVISION 
				) ;

				if ( t_Status )
				{
					BOOL t_Status = GetAclInformation (

						t_ExtraDacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( ! t_Status )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		DWORD t_AceIndex = 0 ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , t_Ace , t_AceSize ) ;
			if ( t_Status )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_System_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_System_ACE , s_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalService_ACE , s_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_NetworkService_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_NetworkService_ACE , s_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( s_LocalAdmins_ACESize && :: AddAce ( t_ExtraDacl , ACL_REVISION , t_AceIndex , s_Provider_LocalAdmins_ACE , s_LocalAdmins_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}			


		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetSecurityDescriptorDacl (

				  t_SecurityDescriptor ,
				  TRUE ,
				  t_ExtraDacl ,
				  FALSE 
			) ;

			if ( t_Status )
			{
				DWORD t_FinalLength = 0 ;

				t_Status = MakeSelfRelativeSD (

					t_SecurityDescriptor ,
					a_AlteredSecurityDescriptor ,
					& t_FinalLength 
				) ;

				if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
				{
					a_AlteredSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
					if ( a_AlteredSecurityDescriptor )
					{
						t_Status = MakeSelfRelativeSD (

							t_SecurityDescriptor ,
							a_AlteredSecurityDescriptor ,
							& t_FinalLength 
						) ;

						if ( t_Status == FALSE )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;									
					}
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		delete [] t_Ace ;
		delete [] t_ExtraDacl ;
	}

	delete [] ( BYTE * ) t_Dacl ;
	delete [] ( BYTE * ) t_Sacl ;
	delete [] ( BYTE * ) t_Owner ;
	delete [] ( BYTE * ) t_PrimaryGroup ;
	delete [] ( BYTE * ) t_AlteredSecurityDescriptor ;

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateSystemAces ()
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_System_Sid = NULL ;
	PSID t_LocalService_Sid = NULL ;
	PSID t_NetworkService_Sid = NULL ;
	PSID t_LocalAdmins_Sid = NULL ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		s_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

		s_Provider_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
		if ( s_Provider_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & s_Provider_System_ACE->SidStart, t_System_Sid ) ;
			s_Provider_System_ACE->Mask =  MASK_PROVIDER_BINDING_BIND  ;
			s_Provider_System_ACE->Header.AceType = 0 ;
			s_Provider_System_ACE->Header.AceFlags = 3 ;
			s_Provider_System_ACE->Header.AceSize = s_System_ACESize ;

			s_Token_All_Access_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_System_ACESize ] ;
			if ( s_Token_All_Access_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Token_All_Access_System_ACE->SidStart, t_System_Sid ) ;
				s_Token_All_Access_System_ACE->Mask = TOKEN_ALL_ACCESS ;
				s_Token_All_Access_System_ACE->Header.AceType = 0 ;
				s_Token_All_Access_System_ACE->Header.AceFlags = 3 ;
				s_Token_All_Access_System_ACE->Header.AceSize = s_System_ACESize ;
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
			s_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
			if ( s_Provider_LocalService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
				s_Provider_LocalService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalService_ACE->Header.AceType = 0 ;
				s_Provider_LocalService_ACE->Header.AceFlags = 3 ;
				s_Provider_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;

				s_Token_All_Access_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalService_ACESize ] ;
				if ( s_Token_All_Access_LocalService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
					s_Token_All_Access_LocalService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalService_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_LocalService_ACE->Header.AceSize = s_LocalService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}
			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_NETWORK_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_NetworkService_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
			s_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
			if ( s_Provider_NetworkService_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
				s_Provider_NetworkService_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_NetworkService_ACE->Header.AceType = 0 ;
				s_Provider_NetworkService_ACE->Header.AceFlags = 3 ;
				s_Provider_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;

				s_Token_All_Access_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_NetworkService_ACESize ] ;
				if ( s_Token_All_Access_NetworkService_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
					s_Token_All_Access_NetworkService_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_NetworkService_ACE->Header.AceType = 0 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_NetworkService_ACE->Header.AceSize = s_NetworkService_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			2 ,
			SECURITY_BUILTIN_DOMAIN_RID ,
			DOMAIN_ALIAS_RID_ADMINS ,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_LocalAdmins_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_LocalAdmins_Sid );
			s_LocalAdmins_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;

			s_Provider_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
			if ( s_Provider_LocalAdmins_ACE )
			{
				CopySid ( t_SidLength, (PSID) & s_Provider_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
				s_Provider_LocalAdmins_ACE->Mask =  MASK_PROVIDER_BINDING_BIND ;
				s_Provider_LocalAdmins_ACE->Header.AceType = 0 ;
				s_Provider_LocalAdmins_ACE->Header.AceFlags = 3 ;
				s_Provider_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;

				s_Token_All_Access_LocalAdmins_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ s_LocalAdmins_ACESize ] ;
				if ( s_Token_All_Access_LocalAdmins_ACE )
				{
					CopySid ( t_SidLength, (PSID) & s_Token_All_Access_LocalAdmins_ACE->SidStart, t_LocalAdmins_Sid ) ;
					s_Token_All_Access_LocalAdmins_ACE->Mask =  TOKEN_ALL_ACCESS ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceType = 0 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceFlags = 3 ;
					s_Token_All_Access_LocalAdmins_ACE->Header.AceSize = s_LocalAdmins_ACESize ;
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}

			}
			else
			{
				t_Result = E_OUTOFMEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = E_OUTOFMEMORY ;
		}
	}

	if ( t_LocalAdmins_Sid )
	{
		FreeSid ( t_LocalAdmins_Sid ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_LocalService_Sid )
	{
		FreeSid ( t_LocalService_Sid ) ;
	}

	if ( t_NetworkService_Sid )
	{
		FreeSid ( t_NetworkService_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteSystemAces ()
{
	if ( s_Provider_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_System_ACE ) ;
	}

	if ( s_Provider_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalService_ACE ) ;
	}

	if ( s_Provider_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_NetworkService_ACE ) ;
	}

	if ( s_Provider_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Provider_LocalAdmins_ACE ) ;
	}

	if ( s_Token_All_Access_System_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_System_ACE ) ;
	}

	if ( s_Token_All_Access_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalService_ACE ) ;
	}

	if ( s_Token_All_Access_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_NetworkService_ACE ) ;
	}

	if ( s_Token_All_Access_LocalAdmins_ACE )
	{
		delete [] ( ( BYTE * ) s_Token_All_Access_LocalAdmins_ACE ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CheckAccess ( 

	SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
	DWORD a_Access , 
	GENERIC_MAPPING *a_Mapping
)
{
	HRESULT t_Result = S_OK ;

	if ( a_SecurityDescriptor )	
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) || t_Result == RPC_E_CALL_COMPLETE )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

				a_SecurityDescriptor , 
				a_Access ,
				a_Mapping
			) ;

			CoRevertToSelf () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenUser )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenUser ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenUser ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetGroupSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_PRIMARY_GROUP *t_TokenGroup = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenPrimaryGroup ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenGroup ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenGroup = ( TOKEN_PRIMARY_GROUP * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenGroup )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenGroup ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenGroup->PrimaryGroup ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenGroup->PrimaryGroup , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenGroup ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
					
	DWORD a_ProcessIdentifier ,
	WORD &a_AceSize ,
	ACCESS_ALLOWED_ACE *&a_Ace 
)
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

	HANDLE t_ProcessHandle = OpenProcess (

		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		HANDLE t_ProcessToken = NULL ;
		BOOL t_Status = OpenProcessToken (

			GetCurrentProcess () ,
			TOKEN_QUERY | TOKEN_DUPLICATE ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_ProcessToken ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) ) 
			{
				ACCESS_ALLOWED_ACE *t_Ace = NULL ;
				DWORD t_AceSize = 0 ;

				t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_OwnerSize - sizeof(DWORD) ) ;
				t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
				if ( t_Ace )
				{
					CopySid ( t_OwnerSize, (PSID) & t_Ace->SidStart, t_OwnerSid ) ;
					t_Ace->Mask = TOKEN_ALL_ACCESS ;
					t_Ace->Header.AceType = 0 ;
					t_Ace->Header.AceFlags = 0 ;
					t_Ace->Header.AceSize = t_AceSize ;

					a_Ace = t_Ace ;
					a_AceSize = t_AceSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}

		CloseHandle ( t_ProcessHandle ) ;
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: SinkAccessInitialize (

	SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
	SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
)
{
	HRESULT t_Result = CoImpersonateClient () ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		HANDLE t_Token = NULL ;
		BOOL t_Status = OpenThreadToken (

			GetCurrentThread () ,
			MAXIMUM_ALLOWED ,
			TRUE ,
			&t_Token
		) ;

		CoRevertToSelf () ;

		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_Token ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_GroupSize = 0 ; 
				PSID t_GroupSid = NULL ;
				BOOL t_GroupDefaulted = FALSE ;

				t_Result = GetGroupSid (

					t_Token ,
					& t_GroupSize , 
					t_GroupSid 
				) ; 

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 

						( SID * ) t_OwnerSid ,
						( SID * ) t_GroupSid ,
						MASK_PROVIDER_BINDING_BIND ,
						a_RegistrationSecurityDescriptor , 
						a_SinkSecurityDescriptor
					) ;

					delete [] ( BYTE * ) t_GroupSid ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			CloseHandle ( t_Token ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor ()
{
	HRESULT t_Result = S_OK ;

	BOOL t_Status = SSDL_wrapper::ConvertStringSecurityDescriptorToSecurityDescriptor (

		L"O:BAG:BAD:(A;;0x10000001;;;BA)(A;;0x10000001;;;SY)(A;;0x10000001;;;LA)(A;;0x10000001;;;SY)(A;;0x10000001;;;S-1-5-20)(A;;0x10000001;;;S-1-5-19)" ,
		SDDL_REVISION_1 ,
		( PSECURITY_DESCRIPTOR * ) & s_MethodSecurityDescriptor ,
		NULL 
	) ;

	if ( t_Status )
	{
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor ()
{
	if ( s_MethodSecurityDescriptor	)
	{
		LocalFree ( s_MethodSecurityDescriptor ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: InitializeTransmitSize ()
{	
	s_TransmitBufferSize = SYNCPROV_BATCH_TRANSMIT_SIZE ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		L"Software\\Microsoft\\WBEM\\CIMOM" ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_DataSize = sizeof ( s_TransmitBufferSize ) ;

		t_RegResult = OS::RegQueryValueEx (

		  t_ConfigRoot ,
		  L"Sink Transmit Buffer Size" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & s_TransmitBufferSize ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return s_TransmitBufferSize ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#ifdef IA64
#define RPC_STACK_COMMIT_SIZE 8192 * 8
#else
#define RPC_STACK_COMMIT_SIZE 4096 * 8
#endif

#define REGSTR_PATH_SVCHOST     TEXT("Software\\Microsoft\\Wbem\\Cimom")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ProviderSubSystem_Common_Globals :: InitializeDefaultStackSize ()
{	
	s_DefaultStackSize = RPC_STACK_COMMIT_SIZE ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		REGSTR_PATH_SVCHOST ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_Value = 0 ;
		DWORD t_DataSize = sizeof ( t_Value ) ;

		t_RegResult = RegQueryValueEx (

		  t_ConfigRoot ,
		  L"DefaultRpcStackSize" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & t_Value ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
			s_DefaultStackSize = t_Value * 1024 ;
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return s_DefaultStackSize ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "precomp.h"
#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <callsec.h>

#include <cominit.h>

#include <Guids.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>

#include "Globals.h"
#include "aggregator.h"
#include "os.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator *DecoupledProviderSubSystem_Globals :: s_Allocator = NULL ;


LONG DecoupledProviderSubSystem_Globals :: s_LocksInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_RegistrarUsers = 0 ;

LONG DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress=0;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress =0;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress = 0;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress=0;
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;
	
	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DecoupledProviderSubSystem_Globals::CreateSystemAces ();
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;
	
	WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_Allocator )
	{
		WmiAllocator t_Allocator ;
		t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;
	}
	
	t_Result = DecoupledProviderSubSystem_Globals::DeleteSystemAces () ;

	return t_Result ;
}


HRESULT 
DecoupledProviderSubSystem_Globals::CreateSystemAces()
{
  if (!OS::secureOS_) return S_OK;

  return ProviderSubSystem_Common_Globals::CreateSystemAces();
};

HRESULT 
DecoupledProviderSubSystem_Globals::DeleteSystemAces()
{
  if (!OS::secureOS_)
    return S_OK;
  return ProviderSubSystem_Common_Globals::DeleteSystemAces();
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
HRESULT 
DecoupledProviderSubSystem_Globals::SetCloaking ( 
		IUnknown *a_Unknown ,
		DWORD a_AuthenticationLevel ,
		DWORD a_ImpersonationLevel)
{
  if ( !OS::secureOS_) return S_OK;

    DWORD cloaking = (OS::osVer_ > OS::NT4) ? EOAC_DYNAMIC_CLOAKING : 0;
	DWORD impersonationLevel = (OS::osVer_ > OS::NT4) ? a_ImpersonationLevel : min(a_ImpersonationLevel,RPC_C_IMP_LEVEL_IDENTIFY) ;
    
    IClientSecurity *t_ClientSecurity = NULL ;

    HRESULT t_Result = a_Unknown->QueryInterface (
	
		IID_IClientSecurity , 
		( void ** ) & t_ClientSecurity
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		t_Result = t_ClientSecurity->SetBlanket (

			a_Unknown ,
			RPC_C_AUTHN_WINNT ,
			RPC_C_AUTHZ_NONE ,
			NULL ,
			a_AuthenticationLevel ,
			impersonationLevel ,
			NULL ,
			cloaking
		) ;

		t_ClientSecurity->Release () ;
	}
	return t_Result ;
};
		

HRESULT DecoupledProviderSubSystem_Globals :: BeginImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating,
	DWORD *a_AuthenticationLevel
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	

	CWbemCallSecurity * pSec = new CWbemCallSecurity(NULL);
	_IWmiCallSec *t_CallSecurity = NULL ;
	
	if (pSec == 0)
	  t_Result = WBEM_E_OUT_OF_MEMORY;
	else
	  t_Result = pSec->QueryInterface(IID__IWmiCallSec, ( void ** ) & t_CallSecurity);

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD | WMI_ORIGIN_EXISTING | WMI_ORIGIN_RPC ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_AuthenticationLevel )
					{
						t_Result = t_ThreadSecurity->GetAuthentication ( a_AuthenticationLevel  ) ;
					}

					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

HRESULT DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity * pSec = new CWbemCallSecurity(NULL);
	_IWmiCallSec *t_CallSecurity = NULL ;
	
	if (pSec == 0)
	  t_Result = WBEM_E_OUT_OF_MEMORY;
	else
	  t_Result = pSec->QueryInterface(IID__IWmiCallSec, ( void ** ) & t_CallSecurity);

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: BeginThreadImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity *t_CallSecurity = CWbemCallSecurity :: New () ;

	if ( t_CallSecurity )
	{
		t_CallSecurity->AddRef () ;

		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: EndThreadImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;

		BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
		if ( t_Status )
		{
			t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

			RevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		CloseHandle ( t_IdentifyToken ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	if (!OS::secureOS_)
		return S_OK;

	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = NULL ;

		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_CallerIdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
			DWORD t_ProcessIdentifier = a_InternalContext.m_ProcessIdentifier ;

			HANDLE t_ProcessHandle = OpenProcess (

				PROCESS_DUP_HANDLE ,
				FALSE ,
				t_ProcessIdentifier 
			) ;
			CoRevertToSelf () ;
			if ( t_ProcessHandle )
			{
				BOOL t_Status = DuplicateHandle (

					t_ProcessHandle ,
					t_CallerIdentifyToken ,
					GetCurrentProcess () ,
					& t_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
								
				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CoRevertToSelf () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

				CoRevertToSelf () ;

				RevertToSelf () ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	if (!OS::secureOS_)
		return S_OK;
	
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: SetProxyState_SvcHost ( 

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize,
	SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel
)
{
	if (!OS::secureOS_)
		return S_OK;

	a_Revert = FALSE ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals::GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = ProviderSubSystem_Common_Globals::EnableAllPrivileges () ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
			}
			else
			{
#if 0
				ERRORTRACE((LOG_WBEMCORE, "Unable to enable privileges in the "
					"client token: error code 0x%X (system error 0x%X)\n", hres,
					GetLastError()));
#endif
			}

			// Get the token's impersonation level
			// ===================================

//			DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals::GetCurrentImpersonationLevel () ;
			if ( (t_ImpersonationLevel == SecurityImpersonation  || t_ImpersonationLevel == SecurityDelegation ) && (OS::osVer_ > OS::NT4) )
			{
				a_IdentifyToken = 0 ;
			}
			else
			{
				t_Result = ProviderSubSystem_Common_Globals::ConstructIdentifyToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize,
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost (

	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	IUnknown *a_Proxy , 
	BOOL a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & a_Container.GetCriticalSection () ) ;

	WmiStatusCode t_StatusCode = a_Container.Return ( a_Proxy , a_ProxyIndex ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
	}
	else
	{
		a_Proxy->Release () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	WmiHelper :: LeaveCriticalSection ( & a_Container.GetCriticalSection () ) ;

	if ( a_Revert )
	{
		t_Result = CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: GetAceWithProcessTokenUser ( 
					
	DWORD a_ProcessIdentifier ,
	WORD &a_AceSize ,
	ACCESS_ALLOWED_ACE *&a_Ace 
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

	HANDLE t_ProcessHandle = OpenProcess (

		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		HANDLE t_ProcessToken = NULL ;
		BOOL t_Status = OpenProcessToken (

			t_ProcessHandle ,
			TOKEN_QUERY | TOKEN_DUPLICATE ,
			& t_ProcessToken
		) ;

		if ( t_Status )
		{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = GetUserSid (

				t_ProcessToken ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) ) 
			{
				ACCESS_ALLOWED_ACE *t_Ace = NULL ;
				DWORD t_AceSize = 0 ;

				t_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_OwnerSize - sizeof(DWORD) ) ;
				t_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ t_AceSize ] ;
				if ( t_Ace )
				{
					CopySid ( t_OwnerSize, (PSID) & t_Ace->SidStart, t_OwnerSid ) ;
					t_Ace->Mask = TOKEN_ALL_ACCESS ;
					t_Ace->Header.AceType = 0 ;
					t_Ace->Header.AceFlags = 0 ;
					t_Ace->Header.AceSize = t_AceSize ;

					a_Ace = t_Ace ;
					a_AceSize = t_AceSize ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}

			CloseHandle ( t_ProcessToken ) ;
		}

		CloseHandle ( t_ProcessHandle ) ;
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID &a_Sid
)
{
	if (!OS::secureOS_)
		return S_OK;

	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
						if ( t_TokenUser )
						{
							t_TokenStatus = GetTokenInformation (

								a_Token ,
								t_TokenInformationClass ,
								t_TokenUser ,
								t_ReturnLength ,
								& t_ReturnLength
							) ;

							if ( t_TokenStatus )
							{
								DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
								*a_Size = t_SidLength ;

								a_Sid = new BYTE [ t_SidLength ] ;
								if ( a_Sid )
								{
									CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

									t_Result = S_OK ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							delete [] t_TokenUser ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "classfac.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClassFactoryBase::ClassFactoryBase() : m_ReferenceCount ( 0 )
{
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals::s_CServerClassFactory_ObjectsInProgress);
	InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClassFactoryBase:: ~ClassFactoryBase()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	InterlockedDecrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT 
ClassFactoryBase::QueryInterface (REFIID iid, LPVOID FAR *iplpv) 
{
  if (iplpv==0)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    {
    *iplpv = static_cast<IUnknown*>(this) ;
    }
  else if (iid == IID_IClassFactory)
    {
    *iplpv = static_cast<IClassFactory *>(this);		
    }	
  else
    {
      *iplpv = NULL;
      return E_NOINTERFACE;
    }

  ClassFactoryBase::AddRef () ;
  return S_OK;
  }


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG ClassFactoryBase::AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


ULONG ClassFactoryBase :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		Object *lpunk = new Object ( );
		if ( lpunk == NULL)
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->Initialize () ;
			if (FAILED(status))
			{
				delete lpunk ;
				return status;
			};
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP ClassFactoryBase:: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
		InterlockedIncrement(&DecoupledProviderSubSystem_Globals :: s_LocksInProgress );
	else
		InterlockedDecrement(&DecoupledProviderSubSystem_Globals :: s_LocksInProgress );

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\datetime.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  DATETIME.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemDateTime
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <sys/timeb.h>
#include <math.h>
#include <time.h> 
#include <float.h>
#include <wbemint.h>

#include "DateTime.h"

#define ISWILD(c)		(L'*' == c)
#define ISINTERVAL(c)	(L':' == c)
#define ISMINUS(c)		(L'-' == c)
#define ISPLUS(c)		(L'+' == c)
#define	ISDOT(c)		(L'.' == c)

#define	WILD2			L"**"
#define	WILD3			L"***"
#define	WILD4			L"****"
#define	WILD6			L"******"

#define ASSERT_BREAK 

//***************************************************************************
//
//  CWbemDateTime::CWbemDateTime
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CWbemDateTime::CWbemDateTime() :
		m_bYearSpecified (VARIANT_TRUE),
		m_bMonthSpecified (VARIANT_TRUE),
		m_bDaySpecified (VARIANT_TRUE),
		m_bHoursSpecified (VARIANT_TRUE),
		m_bMinutesSpecified (VARIANT_TRUE),
		m_bSecondsSpecified (VARIANT_TRUE),
		m_bMicrosecondsSpecified (VARIANT_TRUE),
		m_bUTCSpecified (VARIANT_TRUE),
		m_bIsInterval (VARIANT_FALSE),
		m_iYear (0),
		m_iMonth (1),
		m_iDay (1),
		m_iHours (0),
		m_iMinutes (0),
		m_iSeconds (0),
		m_iMicroseconds (0),
		m_iUTC (0)
{
}

//***************************************************************************
//
//  CWbemDateTime::~CWbemDateTime
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWbemDateTime::~CWbemDateTime(void)
{
}

//***************************************************************************
//
//  SCODE CWbemDateTime::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		pbsValue		pointer to BSTR to hold value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime :: GetValue ( BSTR *pbsValue) 
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pbsValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		wchar_t	dmtfValue [WBEMDT_DMTF_LEN + 1];
		dmtfValue [WBEMDT_DMTF_LEN] = NULL;

		if (m_bIsInterval)
		{
			// Intervals are easy
			swprintf (dmtfValue, L"%08d%02d%02d%02d.%06d:000", m_iDay, 
						m_iHours, m_iMinutes, m_iSeconds, m_iMicroseconds);
		}
		else
		{
			if (m_bYearSpecified)
				swprintf (dmtfValue, L"%04d", m_iYear);
			else
				wcscpy (dmtfValue, WILD4);

			if (m_bMonthSpecified)
				swprintf (dmtfValue + 4, L"%02d", m_iMonth);
			else
				wcscat (dmtfValue + 4, WILD2);

			if (m_bDaySpecified)
				swprintf (dmtfValue + 6, L"%02d", m_iDay);
			else
				wcscat (dmtfValue + 6, WILD2);

			if (m_bHoursSpecified)
				swprintf (dmtfValue + 8, L"%02d", m_iHours);
			else
				wcscat (dmtfValue + 8, WILD2);

			if (m_bMinutesSpecified)
				swprintf (dmtfValue + 10, L"%02d", m_iMinutes);
			else
				wcscat (dmtfValue + 10, WILD2);

			if (m_bSecondsSpecified)
				swprintf (dmtfValue + 12, L"%02d.", m_iSeconds);
			else
			{
				wcscat (dmtfValue + 12, WILD2);
				wcscat (dmtfValue + 14, L".");
			}

			if (m_bMicrosecondsSpecified)
				swprintf (dmtfValue + 15, L"%06d", m_iMicroseconds);
			else
				wcscat (dmtfValue + 15, WILD6);

			if (m_bUTCSpecified)
				swprintf (dmtfValue + 21, L"%C%03d", (0 <= m_iUTC) ? L'+' : L'-', 
							(0 <= m_iUTC) ? m_iUTC : -m_iUTC);
			else
			{
				wcscat (dmtfValue + 21, L"+");
				wcscat (dmtfValue + 22, WILD3);
			}
		}

		*pbsValue = SysAllocString (dmtfValue);
		hr = WBEM_S_NO_ERROR;
	}
	
	return hr;

}


//***************************************************************************
//
//  SCODE CWbemDateTime::put_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		bsValue		new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDateTime::PutValue( BSTR bsValue) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	// First check that the value is the right length
	if (bsValue && (WBEMDT_DMTF_LEN == wcslen (bsValue)))
	{
		bool err = false;
		long iYear = 0, iMonth = 1, iDay = 1, iHours = 0, iMinutes = 0, 
		iSeconds = 0, iMicroseconds = 0, iUTC = 0;
		VARIANT_BOOL bYearSpecified = VARIANT_TRUE, 
		bMonthSpecified = VARIANT_TRUE, 
		bDaySpecified = VARIANT_TRUE, 
		bHoursSpecified = VARIANT_TRUE, 
		bMinutesSpecified = VARIANT_TRUE, 
		bSecondsSpecified = VARIANT_TRUE, 
		bMicrosecondsSpecified = VARIANT_TRUE, 
		bUTCSpecified = VARIANT_TRUE, 
		bIsInterval = VARIANT_TRUE;

		LPWSTR pValue = (LPWSTR) bsValue;
		
		// Check whether its an interval
		if (ISINTERVAL(pValue [WBEMDT_DMTF_UPOS]))
		{
			// Years and months are as nothing to us in interval land
			bYearSpecified = VARIANT_FALSE;
			bMonthSpecified = VARIANT_FALSE;

			// Check that everything is a digit apart from
			// the interval separator
			for (int i = 0; i < WBEMDT_DMTF_LEN; i++)
			{
				if ((WBEMDT_DMTF_UPOS != i) && 
					(WBEMDT_DMTF_SPOS != i) && !iswdigit (pValue [i]))
				{
					err = true;
					break;
				}
			}

			if (!err)
			{
				// Now check all is within bounds
				err = !(CheckField (pValue, 8, bDaySpecified, iDay, WBEMDT_MAX_DAYINT, WBEMDT_MIN_DAYINT) &&
					(VARIANT_TRUE == bDaySpecified) &&
					CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
					(VARIANT_TRUE == bHoursSpecified) &&
					CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
					(VARIANT_TRUE == bMinutesSpecified) &&
					CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
					(VARIANT_TRUE == bSecondsSpecified) &&
					(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
					CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
					(VARIANT_TRUE == bMicrosecondsSpecified) &&
					CheckUTC (pValue+21, bUTCSpecified, iUTC, false));
				
			}
		}
		else
		{
			// assume it's a datetime
			bIsInterval = VARIANT_FALSE;

			err = !(CheckField (pValue, 4, bYearSpecified, iYear, WBEMDT_MAX_YEAR, WBEMDT_MIN_YEAR) &&
				CheckField (pValue+4, 2, bMonthSpecified, iMonth, WBEMDT_MAX_MONTH, WBEMDT_MIN_MONTH) &&
				CheckField (pValue+6, 2, bDaySpecified, iDay, WBEMDT_MAX_DAY, WBEMDT_MIN_DAY) &&
				CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
				CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
				CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
				(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
				CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
				CheckUTC (pValue+21, bUTCSpecified, iUTC));
		}

		if (!err)
		{
			m_iYear = iYear;
			m_iMonth = iMonth;
			m_iDay = iDay;
			m_iHours = iHours;
			m_iMinutes = iMinutes;
			m_iSeconds = iSeconds;
			m_iMicroseconds = iMicroseconds;
			m_iUTC = iUTC;
			m_bYearSpecified = bYearSpecified;
			m_bMonthSpecified = bMonthSpecified;
			m_bDaySpecified = bDaySpecified;
			m_bHoursSpecified = bHoursSpecified;
			m_bMinutesSpecified = bMinutesSpecified;
			m_bSecondsSpecified = bSecondsSpecified;
			m_bMicrosecondsSpecified = bMicrosecondsSpecified;
			m_bUTCSpecified = bUTCSpecified;
			m_bIsInterval = bIsInterval;
			hr = S_OK;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckField
//
//  DESCRIPTION:
//
//  Check a string-based datetime field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		len				number of characters in the value
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		maxValue		maximum numeric value allowed for this field
//		minValue		minimum numeric value allowed for this field
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckField (
		LPWSTR			pValue,
		ULONG			len,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		long			maxValue,
		long			minValue
	)
{
	bool status = true;
	bIsSpecified = VARIANT_FALSE;

	for (ULONG i = 0; i < len; i++)
	{
		if (ISWILD(pValue [i]))
		{
			if (VARIANT_TRUE == bIsSpecified)
			{
				status = false;
				break;
			}
		}
		else if (!iswdigit (pValue [i]))
		{
			status = false;
			break;
		}
		else
			bIsSpecified = VARIANT_TRUE;
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [9];
			
			wcsncpy (temp, pValue, len);
			temp [len] = NULL;
			iValue = wcstol (temp, &dummy, 10);
		}
	}
	
	return status;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::CheckUTC
//
//  DESCRIPTION:
//
//  Check a string-based UTC field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		bParseSign		whether first character should be a sign (+/-) or
//						a : (for intervals)
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CWbemDateTime::CheckUTC (
		LPWSTR			pValue,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		bool			bParseSign
	)
{
	bool status = true;
	bool lessThanZero = false;
	bIsSpecified = VARIANT_FALSE;

	// Check if we have a signed offset
	if (bParseSign)
	{
		if (ISMINUS(pValue [0]))
			lessThanZero = true;
		else if (!ISPLUS(pValue [0]))
			status = false;
	}
	else
	{
		if (!ISINTERVAL(pValue[0]))
			status = false;
	}

	if (status)
	{
		// Check remaining are digits or wildcars
		for (int i = 1; i < 4; i++)
		{
			if (ISWILD(pValue [i]))
			{
				if (VARIANT_TRUE == bIsSpecified)
				{
					status = false;
					break;
				}
			}
			else if (!iswdigit (pValue [i]))
			{
				status = false;
				break;
			}
			else
				bIsSpecified = VARIANT_TRUE;
		}
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [4];
			
			wcsncpy (temp, pValue+1, 3);
			temp [3] = NULL;
			iValue = wcstol (temp, &dummy, 10);

			if (lessThanZero)
				iValue = -iValue;
		}
	}
	
	return status;
}


//***************************************************************************
//
//  SCODE CWbemDateTime::GetVarDate
//
//  DESCRIPTION:
//
//  Retrieve the value in Variant form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pVarDate		holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT CWbemDateTime::GetVarDate( 
        IN VARIANT_BOOL bIsLocal,
		OUT DATE *pVarDate) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	if (NULL == pVarDate)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = WBEM_E_FAILED;
		}
		else
		{	
			SYSTEMTIME sysTime;
			sysTime.wYear = ( WORD ) m_iYear;
			sysTime.wMonth = ( WORD ) m_iMonth;
			sysTime.wDay = ( WORD ) m_iDay;
			sysTime.wHour = ( WORD ) m_iHours;
			sysTime.wMinute = ( WORD ) m_iMinutes;
			sysTime.wSecond = ( WORD ) m_iSeconds;
			sysTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
				
			if (VARIANT_TRUE == bIsLocal)
			{
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.

				// Coerce the time to GMT first
				WBEMTime wbemTime (sysTime);
				
				if (!wbemTime.GetDMTF (sysTime))
					return WBEM_E_INVALID_SYNTAX;
			}

			double dVarDate;

			if (SystemTimeToVariantTime (&sysTime, &dVarDate))
			{
				*pVarDate = dVarDate;
				hr = S_OK;
			}
		}
	}

	return hr;
}
    
//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	if (TRUE == VariantTimeToSystemTime (dVarDate, &sysTime))
	{
		long offset = 0;

		if (VARIANT_TRUE == bIsLocal)
		{
			WBEMTime wbemTime (sysTime);
			if (!wbemTime.GetDMTF (sysTime, offset))
				return WBEM_E_INVALID_SYNTAX;
		}

		m_iYear = sysTime.wYear;
		m_iMonth = sysTime.wMonth;
		m_iDay = sysTime.wDay;
		m_iHours = sysTime.wHour;
		m_iMinutes = sysTime.wMinute;
		m_iSeconds = sysTime.wSecond;
		m_iMicroseconds = sysTime.wMilliseconds * 1000;
		m_iUTC = offset;

		m_bYearSpecified = VARIANT_TRUE,	
		m_bMonthSpecified = VARIANT_TRUE, 
		m_bDaySpecified = VARIANT_TRUE, 
		m_bHoursSpecified = VARIANT_TRUE, 
		m_bMinutesSpecified = VARIANT_TRUE, 
		m_bSecondsSpecified = VARIANT_TRUE, 
		m_bMicrosecondsSpecified = VARIANT_TRUE, 
		m_bUTCSpecified = VARIANT_TRUE, 
		m_bIsInterval = VARIANT_FALSE;			

		hr = S_OK;
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
HRESULT CWbemDateTime::SetFileTimeDate( 
        /*[in]*/ FILETIME fFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;

	SYSTEMTIME	sysTime;
	
	long offset = 0;

	if (VARIANT_TRUE == bIsLocal)
	{
		WBEMTime wbemTime (fFileTime);
		if (!wbemTime.GetDMTF (sysTime, offset))
			return WBEM_E_INVALID_SYNTAX;
	}
	else
	{
		WBEMTime wbemTime (fFileTime);
		wbemTime.GetSYSTEMTIME(&sysTime);
	}

	m_iYear = sysTime.wYear;
	m_iMonth = sysTime.wMonth;
	m_iDay = sysTime.wDay;
	m_iHours = sysTime.wHour;
	m_iMinutes = sysTime.wMinute;
	m_iSeconds = sysTime.wSecond;
	m_iMicroseconds = sysTime.wMilliseconds * 1000;
	m_iUTC = offset;

	m_bYearSpecified = VARIANT_TRUE,	
	m_bMonthSpecified = VARIANT_TRUE, 
	m_bDaySpecified = VARIANT_TRUE, 
	m_bHoursSpecified = VARIANT_TRUE, 
	m_bMinutesSpecified = VARIANT_TRUE, 
	m_bSecondsSpecified = VARIANT_TRUE, 
	m_bMicrosecondsSpecified = VARIANT_TRUE, 
	m_bUTCSpecified = VARIANT_TRUE, 
	m_bIsInterval = VARIANT_FALSE;			

	hr = S_OK;

	return hr;
}


// These are here rather than wbemtime.h so we don't have to doc/support
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

CWbemDateTime::WBEMTime :: WBEMTime ( const FILETIME &ft )	
{
	FileTimeToui64(&ft, &m_uTime);
}

LONG CWbemDateTime::WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTimeSpan &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const	CWbemDateTime::WBEMTime & CWbemDateTime::WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
	FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
	{
		// now assign using a FILETIME.
		*this = t_ft;
	}
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const CWbemDateTime::WBEMTime & CWbemDateTime::WBEMTime::operator=(const FILETIME & ft)
{
	FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

CWbemDateTime::WBEMTime CWbemDateTime::WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CWbemDateTime::WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
	if ((pst == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	FILETIME t_ft;

	if (GetFILETIME(&t_ft))
	{
		if (!FileTimeToSystemTime(&t_ft, pst))
		{
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CWbemDateTime::WBEMTime::GetFILETIME(FILETIME * pft) const
{
	if ((pft == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset)
//
//  Description:  Gets the time in DMTF string local datetime format as a 
//	SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this - WBEMTimeSpan(offset);
            else
               wt = *this + WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st)
//
//  Description:  Gets the time in as local SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            long offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this + WBEMTimeSpan(offset);
            else
               wt = *this - WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

BOOL CWbemDateTime::Preceeds ( CWbemDateTime &a_Time )
{
	BOOL t_Truth = TRUE ;

	SYSTEMTIME t_ThisTime ;
	t_ThisTime.wYear = ( WORD ) m_iYear;
	t_ThisTime.wMonth = ( WORD ) m_iMonth;
	t_ThisTime.wDay = ( WORD ) m_iDay;
	t_ThisTime.wHour = ( WORD ) m_iHours;
	t_ThisTime.wMinute = ( WORD ) m_iMinutes;
	t_ThisTime.wSecond = ( WORD ) m_iSeconds;
	t_ThisTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;
		
	SYSTEMTIME t_ArgTime ;
	t_ArgTime.wYear = ( WORD ) a_Time.m_iYear;
	t_ArgTime.wMonth = ( WORD ) a_Time.m_iMonth;
	t_ArgTime.wDay = ( WORD ) a_Time.m_iDay;
	t_ArgTime.wHour = ( WORD ) a_Time.m_iHours;
	t_ArgTime.wMinute = ( WORD ) a_Time.m_iMinutes;
	t_ArgTime.wSecond = ( WORD ) a_Time.m_iSeconds;
	t_ArgTime.wMilliseconds = ( WORD ) ( a_Time.m_iMicroseconds/1000 ) ;

	t_Truth = CompareSYSTEMTIME ( & t_ThisTime , & t_ArgTime ) < 0 ;

	return t_Truth ;
}

HRESULT CWbemDateTime::GetSystemTimeDate (

	SYSTEMTIME &fSystemTime
)
{
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	return S_OK ;
}

HRESULT CWbemDateTime::GetFileTimeDate (

	FILETIME &fFileTime
)
{
	SYSTEMTIME fSystemTime ;
	ZeroMemory ( & fSystemTime , sizeof ( fSystemTime ) ) ;

	fSystemTime.wYear = ( WORD ) m_iYear;
	fSystemTime.wMonth = ( WORD ) m_iMonth;
	fSystemTime.wDay = ( WORD ) m_iDay;
	fSystemTime.wHour = ( WORD ) m_iHours;
	fSystemTime.wMinute = ( WORD ) m_iMinutes;
	fSystemTime.wSecond = ( WORD ) m_iSeconds;
	fSystemTime.wMilliseconds = ( WORD ) ( m_iMicroseconds/1000 ) ;

	if ( FileTimeToSystemTime ( & fFileTime , & fSystemTime ) ) 
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_FAILED ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <comdef.h>
#include <stdio.h>

#include "Globals.h"
#include "ClassFac.h"
#include "Guids.h"
#include "aggregator.h"
#include "ProvRegistrar.h"
#include "ProvEvents.h"
#include "OS.h"
#include <tchar.h>


HINSTANCE g_hInst=NULL;
enum { RUN_AS_PROVIDER = 1, RUN_AS_CLIENT=2 };
int run_as = 0;

CriticalSection s_CriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		if (!s_CriticalSection.valid())
			return FALSE;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Startup () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	CS_GUARD_RETURN(monitor, s_CriticalSection,  E_OUTOFMEMORY) ;
	
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_WmiDCProxyProvider) 
	{
		run_as = RUN_AS_PROVIDER;
		CServerClassFactory <DCProxy,IWbemServices> *lpunk = new CServerClassFactory <DCProxy,IWbemServices> ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	} else if ( rclsid == CLSID_WbemDecoupledRegistrar) 
	{
		run_as = RUN_AS_CLIENT;
		CServerClassFactory <CServerObject_ProviderRegistrar,IWbemDecoupledRegistrar> *lpunk = new CServerClassFactory <CServerObject_ProviderRegistrar,IWbemDecoupledRegistrar> ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_WbemDecoupledBasicEventProvider) 
	{
		run_as = RUN_AS_CLIENT;
		CServerClassFactory <CServerObject_ProviderEvents,IWbemDecoupledBasicEventProvider> *lpunk = new CServerClassFactory <CServerObject_ProviderEvents,IWbemDecoupledBasicEventProvider> ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}

	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

	CS_GUARD_RETURN(monitor, s_CriticalSection,  E_OUTOFMEMORY) ;	bool unload = true;

	switch(run_as)
	{
	case 0:
					break;
	case RUN_AS_PROVIDER:
					{
					DC_registrar * dcReg = DC_registrar::instance_;
					if (dcReg && DecoupledProviderSubSystem_Globals::s_ObjectsInProgress == 0)
					{
								dcReg->Delete();
								dcReg->Release();
					}

					unload = DecoupledProviderSubSystem_Globals::s_LocksInProgress || DecoupledProviderSubSystem_Globals::s_ObjectsInProgress || 
									 DecoupledProviderSubSystem_Globals::s_RegistrarUsers;
					break;
					}
	case RUN_AS_CLIENT:
				unload = DecoupledProviderSubSystem_Globals::s_LocksInProgress || DecoupledProviderSubSystem_Globals::s_ObjectsInProgress;
				break;
	};


	unload = ! unload ;

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration


#define REG_FORMAT_STR			("%s\\%s")
#define NOT_INSERT_STR			("NotInsertable")
#define INPROC32_STR			("InprocServer32")
#define LOCALSERVER32_STR		("LocalServer32")
#define THREADING_MODULE_STR	("ThreadingModel")
#define APARTMENT_STR			("Both")
#define APPID_VALUE_STR			("APPID")
#define APPID_STR				("APPID\\")
#define CLSID_STR				("CLSID\\")

#define WMI_DECCUPLED_PROXY_PROVIDER				("Microsoft WMI Adaptor Provider for Decoupled  Provider")
#define WMI_PROVIDER_DECOUPLED_REGISTRAR				("Microsoft WMI Provider Subsystem Decoupled Registrar")
#define WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER		("Microsoft WMI Provider Subsystem Decoupled Basic Event Provider")

const char * WmiDCProxyProviderKey= ("{54D8502C-527D-43f7-A506-A9DA075E229C}");
const char * WbemDecoupledRegistrarKey=("{4cfc7932-0f9d-4bef-9c32-8ea2a6b56fcb}");
const char * WbemDecoupledBasicEventProviderKey = ("{f5f75737-2843-4f22-933d-c76a97cda62f}");

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( char *pszKey , char *pszSubkey , char *pszValueName , char *pszValue )
{
    HKEY hKey;
    char szKey[256];

	strcpy ( szKey , pszKey ) ;

    if ( NULL != pszSubkey )
    {
		strcat ( szKey , ("\\") ) ;
        strcat ( szKey , pszSubkey ) ;
    }

    if ( ERROR_SUCCESS != RegCreateKeyExA ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueExA (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlenA(pszValue)+1)*sizeof(char)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( const char *  szProviderClassID , char *a_ProviderName )
{
	char szModule[512];
	GetModuleFileNameA(g_hInst,(char *)szModule, sizeof(szModule)/sizeof(char));

	char szProviderCLSIDClassID[128];

	strcpy(szProviderCLSIDClassID,CLSID_STR);

	strcat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer( const char * szProviderClassID )
{
	
	char szTemp[128];

	char szProviderCLSIDClassID[128];

	strcpy(szProviderCLSIDClassID,CLSID_STR);
	strcat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintfA(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);

	wsprintfA(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKeyA(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( WmiDCProxyProviderKey			,	WMI_DECCUPLED_PROXY_PROVIDER ) ;
	t_Result = RegisterServer ( WbemDecoupledRegistrarKey			,	WMI_PROVIDER_DECOUPLED_REGISTRAR ) ;
	t_Result = RegisterServer ( WbemDecoupledBasicEventProviderKey	,	WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER ) ;
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( WmiDCProxyProviderKey ) ;
	t_Result = UnregisterServer ( WbemDecoupledRegistrarKey ) ;
	t_Result = UnregisterServer ( WbemDecoupledBasicEventProviderKey ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\os.cpp ===
#include "PreComp.h"
#undef POLARITY
#include <windows.h>
#include <objbase.h>
#include "os.h"
#include <autoptr.h>

namespace OS
{
int sysVersion();
bool unicodeOS_ = unicodeOS();
bool secureOS_ = unicodeOS(); 
int osVer_ = sysVersion();
	
DWORD convert2ansi(const wchar_t* unicode,  wmilib::auto_buffer<char>& ansi)
{
  if (unicode)
  {
    size_t class_len = wcslen(unicode);
    ansi  = wmilib::auto_buffer<char>(new char[2*class_len+1],2*class_len+1);
    if (ansi.get() == 0)
      return ERROR_NOT_ENOUGH_MEMORY;
    if (wcstombs(ansi.get(),unicode, 2*class_len+1)==-1)
      return ERROR_NO_UNICODE_TRANSLATION;
  }
  return ERROR_SUCCESS;
};
 
bool unicodeOS()
{
    OSVERSIONINFOA OsVersionInfoA;
    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);
    return (OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT);
};

int sysVersion()
{
    OSVERSIONINFOA OsVersionInfoA;
    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);
    //return (OsVersionInfoA.dwMajorVersion);
    return 4;
};

HRESULT 
CoImpersonateClient()
{
	if (secureOS_) return ::CoImpersonateClient();
	else return S_OK;
}

LONG RegOpenKeyExW (HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
	if (unicodeOS_)
		return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
	size_t key_len = wcslen(lpSubKey);
	wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
	if (ansi_key.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
		return ERROR_NO_UNICODE_TRANSLATION;
	
	return ::RegOpenKeyExA(hKey, ansi_key.get(), ulOptions, samDesired, phkResult);
};

LONG RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey,DWORD Reserved, LPWSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
	if (unicodeOS_)
		return ::RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

	wmilib::auto_buffer<char> ansi_class;
	if (lpClass)
	{
	  size_t class_len = wcslen(lpClass);
	  ansi_class  = wmilib::auto_buffer<char>(new char[2*class_len+1]);
	  if (ansi_class.get() == 0)
	    return ERROR_NOT_ENOUGH_MEMORY;
	  if (wcstombs(ansi_class.get(),lpClass, 2*class_len+1)==-1)
	    return ERROR_NO_UNICODE_TRANSLATION;
	};

	size_t key_len = wcslen(lpSubKey);
	wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
	
	if (ansi_key.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
		return ERROR_NO_UNICODE_TRANSLATION;
	
	return ::RegCreateKeyExA(hKey, ansi_key.get(), Reserved, ansi_class.get(), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
};

LONG RegEnumKeyExW (HKEY hKey,DWORD dwIndex,LPWSTR lpName,LPDWORD lpcName,LPDWORD lpReserved,LPWSTR lpClass,LPDWORD lpcClass,PFILETIME lpftLastWriteTime)
{
if (unicodeOS_)
	return ::RegEnumKeyExW(hKey,dwIndex,lpName,lpcName,lpReserved,lpClass,lpcClass,lpftLastWriteTime);

DWORD nameLength = *lpcName ;
wmilib::auto_buffer<char> ansi_name(new char[(*lpcName)*2]);
if (ansi_name.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;

LONG return_code = ::RegEnumKeyExA(hKey,dwIndex,ansi_name.get(),&nameLength,0, 0, 0,lpftLastWriteTime);

if (return_code == ERROR_SUCCESS)
{
	mbstowcs(lpName, ansi_name.get(), *lpcName);
	*lpcName = nameLength;
}
return return_code;
};

LONG RegDeleteKeyW (HKEY hKey, LPCWSTR lpSubKey)
{
if (unicodeOS_)
	return ::RegDeleteKeyW(hKey, lpSubKey);

size_t key_len = wcslen(lpSubKey);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpSubKey, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

return ::RegDeleteKeyA(hKey, ansi_key.get());
};



LONG RegQueryValueExW( HKEY hKey,  LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,  LPDWORD lpcbData )
{
if (unicodeOS_)
	return ::RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

size_t key_len = wcslen(lpValueName);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpValueName, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

LONG available_size = *lpcbData;
LONG return_code = ::RegQueryValueExA(hKey, ansi_key.get(), lpReserved, lpType, lpData, lpcbData);
if (lpData==0)
{
*lpcbData *= 2;
return return_code;
}

if (return_code == ERROR_SUCCESS && (*lpType == REG_EXPAND_SZ || *lpType == REG_SZ))
{
	wmilib::auto_buffer<BYTE> tempData(new BYTE[*lpcbData]);
	if (tempData.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	memcpy(tempData.get(), lpData, *lpcbData);
	const char * src = (char *)tempData.get();
	wchar_t * dst = (wchar_t*)lpData;

	if (*lpType==REG_SZ)
		*lpcbData = (mbstowcs(dst, src, available_size)+1)*sizeof(wchar_t);
	else
	{
		// Not Implemented
		return ERROR_NOT_ENOUGH_MEMORY;
	};
}
return return_code;
};

LONG RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
if (unicodeOS_)
	return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

size_t key_len = wcslen(lpValueName);
wmilib::auto_buffer<char> ansi_key (new char[2*key_len+1]);
if (ansi_key.get() == 0)
	return ERROR_NOT_ENOUGH_MEMORY;
if (wcstombs(ansi_key.get(),lpValueName, 2*key_len+1)==-1)
	return ERROR_NO_UNICODE_TRANSLATION;

if (dwType==REG_EXPAND_SZ || dwType==REG_SZ)
{
	const wchar_t * src = reinterpret_cast<const wchar_t*>(lpData);
	size_t value_len = cbData / sizeof(wchar_t) ;
	wmilib::auto_buffer<char> ansi_value (new char[2*value_len+1]);
	if (ansi_value.get() == 0)
		return ERROR_NOT_ENOUGH_MEMORY;
	char * dest = ansi_value.get();
	
	if (dwType==REG_SZ)
	{
		if ((value_len = wcstombs(dest,src, value_len)+1)==-1)
			return ERROR_NO_UNICODE_TRANSLATION;
	} 
	else
	{
		// Not Implemented
		return ERROR_NOT_ENOUGH_MEMORY;
	};
	return ::RegSetValueExA(hKey, ansi_key.get(), Reserved, dwType, (const BYTE*)ansi_value.get(), value_len);
}
return ::RegSetValueExA(hKey, ansi_key.get(), Reserved, dwType, lpData, cbData);
}

BOOL GetProcessTimes(
  HANDLE hProcess,           // handle to process
  LPFILETIME lpCreationTime, // process creation time
  LPFILETIME lpExitTime,     // process exit time
  LPFILETIME lpKernelTime,   // process kernel-mode time
  LPFILETIME lpUserTime      // process user-mode time
)
{
	if (unicodeOS_)
		return ::GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
	FILETIME zero = {0, 0};
	*lpCreationTime = zero;
	*lpExitTime = zero;
	*lpKernelTime = zero;
	*lpUserTime = zero;
	return 1;
};

  HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName )
  {
  if (unicodeOS_)
    return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
  
  wmilib::auto_buffer<char> name;
  DWORD res = convert2ansi(lpName, name);
  if (res == ERROR_SUCCESS)
    return ::CreateEventA(lpEventAttributes, bManualReset, bInitialState, name.get());
  else
    ::SetLastError(res);
  return NULL;
  }

  HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bInitialOwner, LPCWSTR lpName )
  {
  if (unicodeOS_)
    return ::CreateMutexW(lpEventAttributes, bInitialOwner, lpName);
  
  wmilib::auto_buffer<char> name;
  DWORD res = convert2ansi(lpName, name);
  if (res == ERROR_SUCCESS)
    return ::CreateMutexA(lpEventAttributes, bInitialOwner, name.get());
  else
    ::SetLastError(res);
  return NULL;
  }



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provdwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <wmiutils.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"

#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include "ProvWsv.h"
#include "ProvInSk.h"
#include "ProvobSk.h"

#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

SECURITY_IMPERSONATION_LEVEL RpcToNT(DWORD impersonation)
{
switch(impersonation)
{
case RPC_C_IMP_LEVEL_IMPERSONATE:
	return  SecurityImpersonation;
case RPC_C_IMP_LEVEL_ANONYMOUS:
	return SecurityAnonymous;
case RPC_C_IMP_LEVEL_IDENTIFY:
	return SecurityIdentification;
case RPC_C_IMP_LEVEL_DELEGATE:
	return   SecurityDelegation;
default:
	DebugBreak();
	return SECURITY_IMPERSONATION_LEVEL(0);
};
}

CDecoupled_IWbemUnboundObjectSink :: CDecoupled_IWbemUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Controller ( NULL ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBound_Size , MAX_PROXIES ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_InitializeResult ( S_OK ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals  :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
	
	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	m_InitializeResult = a_Controller->QueryInterface ( IID__IWmiProviderAbnormalShutdown , ( void ** ) & m_Controller ) ;
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		if ( a_ServerSideProvider ) 
		{
			m_Unknown = a_ServerSideProvider ;
			m_Unknown->AddRef () ;

			m_InitializeResult = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( SUCCEEDED ( m_InitializeResult ) )
			{
				m_InitializeResult  = a_ServerSideProvider->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			}
		}
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemUnboundObjectSink :: ~CDecoupled_IWbemUnboundObjectSink ()
{
	if ( m_Controller )
	{
		m_Controller->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals  :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	InterlockedDecrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Initialize ()
{
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			m_InitializeResult = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		m_InitializeResult = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( m_InitializeResult ) )
		{
			m_InitializeResult = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupled_IWbemUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupled_IWbemUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	if (!OS::secureOS_)
	{
	  a_Interface = a_ServerInterface ;
	  a_IsProxy = FALSE ;
	  return S_OK;
	}

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = OS::CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;
			
				if ( (t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE) && (OS::osVer_ > OS::NT4))
				{
					t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
					{
						t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
					}

					WORD t_AceSize = 0 ;
					ACCESS_ALLOWED_ACE *t_Ace = NULL ;

					t_Result = DecoupledProviderSubSystem_Globals :: GetAceWithProcessTokenUser ( 
					
						a_ProcessIdentifier ,
						t_AceSize ,
						t_Ace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState_SvcHost ( 
						
							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_InterfaceIdentifier , 
							a_InternalServerInterface , 
							a_Proxy , 
							a_Revert , 
							a_ProcessIdentifier , 
							a_IdentifyToken ,
							t_Ace ,
							t_AceSize,
							RpcToNT(t_ImpersonationLevel)
						) ;

						delete [] ( BYTE * ) t_Ace ;
					}
				}
			}
		}
		else
		{
			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  return S_OK;
	}

	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = m_ProcessIdentifier ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				if ( m_Controller )
				{
					m_Controller->AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledProvider :: CInterceptor_IWbemDecoupledProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_IWbemProviderInit ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_Internal_IWbemServices ( NULL ) ,
	m_Provider_Internal_IWbemPropertyProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWmiProviderConfiguration ( NULL ) ,
	m_Provider_Internal_IWbemProviderInit ( NULL ) ,
	m_Provider_Internal_IWbemProviderIdentity ( NULL ) ,
	m_ExtendedStatusObject ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals  :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);

	if ( a_InitializationContext )
	{
		a_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Provider_Internal_IWbemServices ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemPropertyProvider , ( void ** ) & m_Provider_Internal_IWbemPropertyProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProvider , ( void ** ) & m_Provider_Internal_IWbemEventProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_Internal_IWbemEventProviderQuerySink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderSecurity , ( void ** ) & m_Provider_Internal_IWbemEventProviderSecurity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProvider , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProviderEx ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & m_Provider_IWbemProviderInit ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderInit , ( void ** ) & m_Provider_Internal_IWbemProviderInit ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderIdentity , ( void ** ) & m_Provider_Internal_IWbemProviderIdentity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledProvider :: ~CInterceptor_IWbemDecoupledProvider ()
{

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemProviderInit )
	{
		m_Provider_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_Internal_IWbemServices )
	{
		m_Provider_Internal_IWbemServices->Release () ;
	}

	if ( m_Provider_Internal_IWbemPropertyProvider )
	{
		m_Provider_Internal_IWbemPropertyProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProvider )
	{
		m_Provider_Internal_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderQuerySink )
	{
		m_Provider_Internal_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderSecurity )
	{
		m_Provider_Internal_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProvider )
	{
		m_Provider_Internal_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProviderEx )
	{
		m_Provider_Internal_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWmiProviderConfiguration )
	{
		m_Provider_Internal_IWmiProviderConfiguration->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderInit )
	{
		m_Provider_Internal_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderIdentity )
	{
		m_Provider_Internal_IWbemProviderIdentity->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals  :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	InterlockedDecrement(&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		if ( m_Provider_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderAbnormalShutdown )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderAbnormalShutdown * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;		
	}	
	else if ( iid == IID_CacheElement )
	{
		*iplpv = ( LPVOID ) ( SyncProviderContainerElement * ) this ;		
	}
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
HRESULT CInterceptor_IWbemDecoupledProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	if (!OS::secureOS_)
	{
	  a_Interface = a_ServerInterface ;
	  a_IsProxy = FALSE ;
	  return S_OK;
	}


	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = OS::CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
				
				CoRevertToSelf () ;

				if ( (t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE) && (OS::osVer_ > OS::NT4) )
				{
					t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					WORD t_AceSize = 0 ;
					ACCESS_ALLOWED_ACE *t_Ace = NULL ;

					if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
					{
						t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
					}

					t_Result = DecoupledProviderSubSystem_Globals :: GetAceWithProcessTokenUser ( 
					
						a_ProcessIdentifier ,
						t_AceSize ,
						t_Ace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState_SvcHost ( 
						
							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_InterfaceIdentifier , 
							a_InternalServerInterface , 
							a_Proxy , 
							a_Revert , 
							a_ProcessIdentifier , 
							a_IdentifyToken ,
							t_Ace ,
							t_AceSize,
							RpcToNT(t_ImpersonationLevel)
						) ;

						delete [] ( BYTE * ) t_Ace ;
					}
				}
			}
		}
		else
		{
			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  return S_OK;
	}

	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	DecoupledProviderSubSystem_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{ 
				IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
				REFIID t_InterfaceIdentifier = IID_IWbemServices ;
				DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
				IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
				REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
				DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IUnknown *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;
				HANDLE t_IdentifyToken = NULL ;

				t_Result = Begin_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_IdentifyToken )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

							t_InternalContext ,
							t_ObjectSink
						) ;
					}
					else
					{
						t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

							t_ObjectSink
						) ;
					}

					End_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_DependantCall = FALSE ;

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

									t_InternalContext ,
									t_ObjectPath, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

								a_ObjectPath, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

								t_InternalContext ,
								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

									t_InternalContext ,
									t_Class , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

								a_Class , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemDecoupledProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
							if ( t_Superclass ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync  (

									t_InternalContext ,
									t_Superclass , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Superclass ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync  (

								a_Superclass , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

								t_InternalContext ,
								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									a_Flags ,
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync  (

								a_ObjectPath ,
								a_Flags ,
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class )
							{
								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

									t_InternalContext ,
 									t_Class ,
									a_Flags ,
									a_Context ,
									t_Sink 
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{

							t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								a_Context ,
								t_Sink 
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemFilteringObjectSink *t_Sink = new CInterceptor_IWbemFilteringObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			a_QueryLanguage ,
			a_Query 
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
							BSTR t_Query = SysAllocString ( a_Query ) ;

							if ( t_QueryLanguage && t_Query ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync  (

									t_InternalContext ,
									t_QueryLanguage , 
									t_Query, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_QueryLanguage ) ;
							SysFreeString ( t_Query ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync  (

								a_QueryLanguage , 
								a_Query, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			
			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy ,
						a_Context
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

							if ( t_ObjectPath && t_MethodName ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									a_Context ,
									a_InParams ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_ObjectPath ) ;
							SysFreeString ( t_MethodName ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync  (

								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								a_Context ,
								a_InParams ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_GetProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->GetProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}	
	else
	{
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_PutProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->PutProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProvider * ) t_Interface )->Internal_ProvideEvents (

					t_InternalContext ,
					a_Sink ,
					a_Flags 
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

					a_Sink ,
					a_Flags 
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_NewQuery (

						t_InternalContext ,
						a_Id ,
						t_QueryLanguage ,
						t_Query
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

					a_Id ,
					a_QueryLanguage ,
					a_Query
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_CancelQuery (

					t_InternalContext ,
					a_Id
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

					a_Id
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderSecurity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderSecurity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderSecurity;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderSecurity * ) t_Interface )->Internal_AccessCheck (

						t_InternalContext ,
						t_QueryLanguage ,
						t_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

					a_QueryLanguage ,
					a_Query ,
					a_SidLength ,
					a_Sid
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProvider * ) t_Interface )->Internal_FindConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CDecoupled_IWbemUnboundObjectSink *t_UnboundObjectSink = new CDecoupled_IWbemUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}
		else
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProviderEx ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProviderEx ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProviderEx ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProviderEx * ) t_Interface )->Internal_ValidateSubscription (

					t_InternalContext ,
					a_LogicalConsumer
				) ;
			}
			else
			{

				t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

					a_LogicalConsumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = DecoupledProviderSubSystem_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderIdentity ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderIdentity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderIdentity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderIdentity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderIdentity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderIdentity ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderIdentity * ) t_Interface )->Internal_SetRegistrationObject (

					t_InternalContext ,
					a_Flags ,
					a_ProviderRegistration
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderIdentity * ) t_Interface )->SetRegistrationObject (

					a_Flags ,
					a_ProviderRegistration
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	if ( m_Provider_IWbemProviderInit )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderInit ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderInit ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderInit ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderInit ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderInit ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderInit ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderInit * ) t_Interface )->Internal_Initialize (

					t_InternalContext ,
					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderInit * ) t_Interface )->Initialize (

					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: AbnormalShutdown ()
{
	HRESULT t_Result = S_OK ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_TransactionIdentifier )
		{
			wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

			if ( a_TransactionIdentifier )
			{
				StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
			}

			m_TransactionIdentifier = SysAllocString ( t_TransactionIdentifier ) ;
		}
	}

	if ( a_Repository )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = OS::CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		t_Result = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provevt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvEvents.h"
#include "ProvEvt.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: CEventProvider (

	WmiAllocator &a_Allocator ,
	CServerObject_ProviderEvents *a_EventRegistrar ,
	IUnknown *a_Unknown

) :	m_EventRegistrar ( a_EventRegistrar ) ,
	m_Unknown ( a_Unknown ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_InternalReferenceCount ( 0 ),
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->AddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;

		HRESULT t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: ~CEventProvider ()
{
	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->Release () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_CoreService )
	{
		m_CoreService->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize ()
{
	return m_CriticalSection.valid() ? S_OK : WBEM_E_OUT_OF_MEMORY ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CEventProvider :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		InternalAddRef () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CEventProvider :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		InternalRelease () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CEventProvider :: InternalAddRef ()
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CEventProvider :: InternalRelease ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}
	
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CEventProvider :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Unknown )
		{
			if ( m_Provider_IWbemEventProvider )
			{
				*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
			}
		}
		else
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*a_Void = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		HRESULT t_TempResult = m_EventRegistrar->SetSink ( a_Sink ) ;

		if ( SUCCEEDED ( t_TempResult ) ) 
		{
			if ( m_Provider_IWbemEventProvider )
			{

				BOOL t_Impersonating = FALSE ;
				IUnknown *t_OldContext = NULL ;
				IServerSecurity *t_OldSecurity = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					BOOL t_Revert = FALSE ;
					IUnknown *t_Proxy = NULL ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						try
						{
							t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

								a_Sink ,
								a_Flags 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}
					}
					else 
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_CONNECT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = OS::CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->ProvideEvents (

										a_Sink ,
										a_Flags 
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
						}
					}

					DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				}
			}
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try 
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

							a_Id ,
							a_QueryLanguage ,
							a_Query
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			return t_Result ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

							a_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = NULL ;
						t_Result = t_Proxy->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & t_Provider ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_CONNECT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = OS::CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->CancelQuery (

										a_Id
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							t_Provider->Release () ;
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

							a_QueryLanguage ,
							a_Query ,
							a_SidLength ,
							a_Sid
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

							a_Flags ,
							a_ProviderRegistration
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

							a_LogicalConsumer ,
							a_Consumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									a_Consumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

							a_LogicalConsumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: UnRegister ()
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Provider->Shutdown (

								a_Flags ,
								a_MaxMilliSeconds ,
								a_Context
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>
#include <polarity.h>
#define _WINNT_ // have what is needed from above

#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED
#ifndef POLARITY
#if 1
#define POLARITY __declspec( dllimport )
#else
#define POLARITY
#endif
#endif

#ifndef COREPROX_POLARITY
#if 1
#define COREPROX_POLARITY __declspec( dllimport )
#else
#define COREPROX_POLARITY
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provcache.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include "precomp.h"
#include <wbemint.h>

#include <HelperFuncs.h>

#include "Guids.h"
#include "Globals.h"
#include "CGlobals.h"
#include "ProvWsv.h"
#include "ProvObSk.h"

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const BindingFactoryCacheKey &a_Arg1 , const BindingFactoryCacheKey &a_Arg2 )
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) 
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const GUID &a_Guid1 , const GUID &a_Guid2 )
{
	return memcmp ( & a_Guid1, & a_Guid2 , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const LONG &a_Arg1 , const LONG &a_Arg2 )
{
	return a_Arg1 - a_Arg2 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provevents.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include "Globals.h"
#include "Guids.h"

#include "ProvRegistrar.h"
#include "ProvEvents.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink :: CDecoupled_IWbemObjectSink ()

	:	m_InterceptedSink ( NULL ) ,
		m_EventSink ( NULL ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptorLength ( 0 ) ,
		m_SecurityDescriptor ( NULL ),
		m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink::~CDecoupled_IWbemObjectSink ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
		if ( t_ObjectSink )
		{
			t_ObjectSink->AddRef () ;
		}

		WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		if ( t_ObjectSink )
		{
			t_ObjectSink->SetStatus ( 

				0 ,
				WBEM_E_UNEXPECTED ,
				NULL ,
				NULL
			) ;

			t_ObjectSink->Release () ;
		}


	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_EventSink )
	{
		m_EventSink->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemObjectSink::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemObjectSink )
	{
		*a_Void = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->Indicate ( 

						a_ObjectCount ,
						a_ObjectArray
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				switch ( a_Flags )
				{
					case WBEM_STATUS_PROGRESS:
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
						if ( t_ObjectSink )
						{
							t_ObjectSink->AddRef () ;
						}

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( t_ObjectSink )
						{
							t_Result = t_ObjectSink->SetStatus ( 

								a_Flags ,
								a_Result ,
								a_StringParam ,
								a_ObjectParam
							) ;

							t_ObjectSink->Release () ;
						}
					}
					break ;

					case WBEM_STATUS_COMPLETE:
					{
						if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
							if ( t_ObjectSink )
							{
								t_ObjectSink->AddRef () ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							if ( t_ObjectSink )
							{
								t_Result = t_ObjectSink->SetStatus ( 

									a_Flags ,
									a_Result ,
									a_StringParam ,
									a_ObjectParam
								) ;

								t_ObjectSink->Release () ;
							}
						}
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PARAMETER ;
					}
					break ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetSinkSecurity (

	long a_SecurityDescriptorLength ,
	BYTE *a_SecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetSinkSecurity ( 

							a_SecurityDescriptorLength ,
							a_SecurityDescriptor
					) ;

					t_ObjectSink->Release () ;
				}
				else
				{
					if ( a_SecurityDescriptor )
					{
						if ( a_SecurityDescriptorLength )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							m_SecurityDescriptor = new BYTE [ a_SecurityDescriptorLength ] ;
							if  ( m_SecurityDescriptor )
							{
								try
								{
									CopyMemory ( m_SecurityDescriptor , a_SecurityDescriptor , a_SecurityDescriptorLength ) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PARAMETER ;
						}
					}
					else
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( m_SecurityDescriptor )
						{
							delete m_SecurityDescriptor ;
							m_SecurityDescriptor = NULL ;
						}

						m_SecurityDescriptorLength = 0 ;

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
					}
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: IsActive ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->IsActive () ;

					t_ObjectSink->Release () ;
				}
				else
				{
					t_Result = WBEM_S_FALSE ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetBatchingParameters (

	LONG a_Flags,
	DWORD a_MaxBufferSize,
	DWORD a_MaxSendLatency
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetBatchingParameters ( 

						a_Flags ,
						a_MaxBufferSize ,
						a_MaxSendLatency
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
			if ( t_ObjectSink )
			{
				t_ObjectSink->AddRef () ;
			}

			WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			if ( t_ObjectSink )
			{
				t_Result = t_ObjectSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;

				t_ObjectSink->Release () ;
			}
		}

		m_GateClosed ++ ;

		try
		{
			bool t_Acquired = false ;
			while ( ! t_Acquired )
			{
				if ( m_InProgress == 0 )
				{
					t_Acquired = true ;

					break ;
				}

				if ( SwitchToThread () == FALSE ) 
				{
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_DecoupledIWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	Lock () ;

	CWbemGlobal_DecoupledIWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_DecoupledIWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		HRESULT t_Result = t_Iterator.GetKey ()->SetSink ( a_Sink ) ;

		t_Iterator.Increment () ;
	}

	UnLock () ;

	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	m_InterceptedSink = a_Sink ;
	m_InterceptedSink->AddRef () ;

	t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & m_EventSink ) ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	IWbemObjectSink *t_InterceptedObjectSink = NULL ;
	IWbemEventSink *t_RestrictedEventSinkObjectSink = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemEventSink *t_EventSink = NULL ;
		t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & t_EventSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_EventSink->GetRestrictedSink (

				m_QueryCount ,
				m_Queries ,
				m_Callback ,
				& t_RestrictedEventSinkObjectSink
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_RestrictedEventSinkObjectSink->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_InterceptedObjectSink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_SecurityDescriptor )
							{
								t_Result = t_RestrictedEventSinkObjectSink->SetSinkSecurity (

									m_SecurityDescriptorLength ,
									m_SecurityDescriptor
								) ;
							}
						}
					}
			}

			t_EventSink->Release () ;
		}
	}

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	IWbemObjectSink *t_TempInterceptedObjectSink = m_InterceptedSink ;
	IWbemEventSink *t_TempRestrictedEventSinkObjectSink = m_EventSink ;

	m_InterceptedSink = t_InterceptedObjectSink ;
	m_EventSink = t_RestrictedEventSinkObjectSink  ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( t_TempInterceptedObjectSink )
	{
		t_TempInterceptedObjectSink->Release () ;
	}

	if ( t_TempRestrictedEventSinkObjectSink )
	{
		t_TempRestrictedEventSinkObjectSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupledChild_IWbemObjectSink :: CDecoupledChild_IWbemObjectSink (

	CDecoupledRoot_IWbemObjectSink *a_RootSink
	
) : DecoupledObjectSinkContainerElement ( 

		a_RootSink ,
		this
	) ,
 	m_RootSink ( a_RootSink )
{
	m_RootSink->AddRef () ;
}

#pragma warning( default : 4355 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledChild_IWbemObjectSink :: ~CDecoupledChild_IWbemObjectSink ()
{
	m_RootSink->Release () ;

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: AddRef () 
{
	return DecoupledObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: Release ()
{
	return DecoupledObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SinkInitialize (

	long a_QueryCount ,
	const LPCWSTR *a_Queries ,
	IUnknown *a_Callback
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}

	m_Callback = a_Callback ;
	if ( m_Callback )
	{
		m_Callback->AddRef () ;
	}

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	m_QueryCount = a_QueryCount ;
	if ( a_Queries )
	{
		m_Queries = new wchar_t * [ m_QueryCount ] ;
		if ( m_Queries )
		{
			for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				m_Queries [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				try
				{
					m_Queries [ t_Index ] = SysAllocString ( a_Queries [ t_Index ] ) ;
					if ( m_Queries [ t_Index ] )
					{
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CDecoupledChild_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	return m_RootSink->GetRestrictedSink (

		a_QueryCount ,
		a_Queries ,
		a_Callback ,
		a_Sink
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledRoot_IWbemObjectSink :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledRoot_IWbemObjectSink :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;

		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Sink )
		{
			*a_Sink = NULL ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			InterlockedIncrement ( & m_InProgress ) ;

			try
			{
				if ( m_GateClosed == 1 )
				{
					t_Result = WBEM_E_SHUTTING_DOWN ;
				}
				else
				{
					WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					IWbemEventSink *t_ObjectSink = m_EventSink ;
					if ( t_ObjectSink )
					{
						t_ObjectSink->AddRef () ;
					}

					WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					if ( t_ObjectSink )
					{
						t_Result = t_ObjectSink->GetRestrictedSink ( 

								a_QueryCount ,
								a_Queries ,
								a_Callback ,
								a_Sink
						) ;

						t_ObjectSink->Release () ;
					}
					else
					{
						CDecoupledChild_IWbemObjectSink *t_RestrictedSink = new CDecoupledChild_IWbemObjectSink ( this ) ;
						if ( t_RestrictedSink )
						{
							t_RestrictedSink->AddRef () ;

							t_Result = t_RestrictedSink->SinkInitialize (

								a_QueryCount ,
								a_Queries ,
								a_Callback
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								Lock () ;

								CWbemGlobal_DecoupledIWmiObjectSinkController_Container_Iterator t_Iterator ;

								WmiStatusCode t_StatusCode = Insert (
								
									*t_RestrictedSink ,
									t_Iterator
								) ;

								if ( t_StatusCode == e_StatusCode_Success )
								{
									*a_Sink = t_RestrictedSink ;
								}
								else
								{
									t_RestrictedSink->Release () ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								UnLock () ;
							}
							else
							{
								t_RestrictedSink->Release () ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			InterlockedDecrement ( & m_InProgress ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents :: CServerObject_ProviderEvents (

	WmiAllocator &a_Allocator 

) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_ObjectSink ( NULL ) ,
	m_Service ( NULL ) ,
	m_Provider ( NULL ),
	m_SinkCriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_SinkCriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents::~CServerObject_ProviderEvents ()
{
	WmiHelper :: DeleteCriticalSection ( & m_SinkCriticalSection ) ;

	if ( m_Provider ) 
	{
		m_Provider->Release () ;
	}

	if ( m_Service ) 
	{
		m_Service->Release () ;
	}

	if ( m_ObjectSink )
	{
		m_ObjectSink->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderEvents::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) ( CServerObject_ProviderRegistrar_Base * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemDecoupledBasicEventProvider )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledBasicEventProvider * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IUnknown *a_Unknown 
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered == FALSE )
			{
				IWbemLocator *t_Locator = NULL ;

				t_Result = CoCreateInstance (

					CLSID_WbemLocator ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** )  & t_Locator
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = NULL ;

					BSTR t_Namespace = SysAllocString ( a_Scope ) ;
					if ( t_Namespace )
					{
						t_Result = t_Locator->ConnectServer (

							t_Namespace ,
							NULL ,
							NULL,
							NULL ,
							0 ,
							NULL,
							NULL,
							&t_Service
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							m_Service = t_Service ;
						}

						SysFreeString ( t_Namespace ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_Locator->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

					m_ObjectSink = new CDecoupledRoot_IWbemObjectSink ( m_Allocator ) ;
					if ( m_ObjectSink )
					{
						m_ObjectSink->AddRef () ;
						t_Result = m_ObjectSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
						}
						else
						{
							m_ObjectSink->Release ();
							m_ObjectSink = NULL ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					m_Provider = new CEventProvider (

						m_Allocator ,
						this ,
						a_Unknown 
					) ;

					if ( m_Provider )
					{
						m_Provider->AddRef () ;

						t_Result = m_Provider->Initialize () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							m_Provider->InternalAddRef () ;

							IUnknown *t_Unknown = NULL ;
							t_Result = m_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CServerObject_ProviderRegistrar_Base :: Register ( 

									a_Flags ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Registration ,
									t_Unknown
								) ;

								t_Unknown->Release () ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

					if ( m_ObjectSink )
					{
						m_ObjectSink->Release () ;
						m_ObjectSink = NULL ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

					if ( m_Provider )
					{
						m_Provider->Release () ;
						m_Provider = NULL ;
					}

					if ( m_Service ) 
					{
						m_Service->Release () ;
						m_Service = NULL ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: UnRegister ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered )
			{
				t_Result = CServerObject_ProviderRegistrar_Base :: UnRegister () ; 

				if ( m_Provider ) 
				{
					m_Provider->UnRegister () ;
					m_Provider->InternalRelease () ;
					m_Provider->Release () ;
					m_Provider = NULL ;
				}

				if ( m_Service )
				{
					m_Service->Release () ;
					m_Service = NULL ;
				}

				if ( m_ObjectSink )
				{
					m_ObjectSink->Release () ;
					m_ObjectSink = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetSink (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered )
			{
				if ( a_Sink )
				{	
					*a_Sink = m_ObjectSink ;
					m_ObjectSink->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetService (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_Service
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try
		{
			if ( m_Registered )
			{
				if ( a_Service )
				{	
					*a_Service = m_Service ;
					m_Service->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provinsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvInSk.h"
#include "guids.h"
#include <provreginfo.h>
enum { CALLED = 0, NOTCALLED = -1};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: CServerObject_ProviderInitSink (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor 

)	:   m_ReferenceCount ( 0 ) , 
		m_Event ( NULL ) , 
		m_StatusCalled ( FALSE ) , 
		m_Result ( S_OK ) ,
		m_SecurityDescriptor ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: ~CServerObject_ProviderInitSink () 
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] ( BYTE * ) m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SinkInitialize ( 
SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	HRESULT t_Result = S_OK ;

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_Event )
	{
		if ( a_SecurityDescriptor )
		{
			m_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ 
GetSecurityDescriptorLength ( a_SecurityDescriptor ) ] ;
			if ( m_SecurityDescriptor )
			{
				CopyMemory ( m_SecurityDescriptor , a_SecurityDescriptor , 
GetSecurityDescriptorLength ( a_SecurityDescriptor ) ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderInitSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderInitSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderInitSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SetStatus (

    LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;
	if ( m_SecurityDescriptor )
	{
		t_Result = OS::CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = DecoupledProviderSubSystem_Globals :: 
        Check_SecurityDescriptor_CallIdentity (

				m_SecurityDescriptor , 
				MASK_PROVIDER_BINDING_BIND ,
				& g_ProviderBindingMapping
			) ;

			CoRevertToSelf () ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Result = a_Status ;
	}
	else
	{
		m_Result = t_Result ;
	}

	SetEvent ( m_Event ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink :: CInterceptor_IWbemProviderInitSink (

	IWbemProviderInitSink *a_InterceptedSink

)	:	m_ReferenceCount ( 0 ) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( NOTCALLED ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink::~CInterceptor_IWbemProviderInitSink ()
{
	if ( m_StatusCalled == NOTCALLED ) 
	{
		m_InterceptedSink->SetStatus ( WBEM_E_UNEXPECTED , 0 ) ; 
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemProviderInitSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInitSink * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemProviderInitSink :: AddRef ()
{
	return InterlockedIncrement (&m_ReferenceCount) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProviderInitSink :: Release ()
{
	if ( ( InterlockedDecrement (&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return m_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: SetStatus (

	LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;

	m_StatusCalled = CALLED ;

	InterlockedIncrement (&m_InProgress) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			a_Status,
			a_Flags 
		) ;
	}

	InterlockedDecrement (&m_InProgress);

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: Shutdown ()
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement (&m_GateClosed) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provinterceptor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include "CGlobals.h"
#include "Globals.h"
#include "ProvInterceptor.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledUnboundObjectSink :: CInterceptor_IWbemDecoupledUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBoundSync_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledUnboundObjectSink :: ~CInterceptor_IWbemDecoupledUnboundObjectSink ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: SetContainer ( IUnknown *a_Container )
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_IWbemSyncObjectSink :: CDecoupled_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemSyncObjectSink :: ~CDecoupled_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_Batching_IWbemSyncObjectSink :: CDecoupled_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_Batching_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_Batching_IWbemSyncObjectSink :: ~CDecoupled_Batching_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledClient :: CInterceptor_DecoupledClient (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	m_ReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledClient :: ~CInterceptor_DecoupledClient ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledClient :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledClient :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledClient :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	if ( a_Riid == IID_Internal_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( Internal_IWbemProviderInit * ) this ;
	}
	else if ( a_Riid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( a_Riid == IID__IWmiProviderInitialize )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderSite )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderConfiguration )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( a_Riid == IID_Internal_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_Internal_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ProvideEvents (

	WmiInternalContext a_InternalContext ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProvideEvents (

			a_Sink ,
			a_Flags 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_NewQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NewQuery (

			a_Id ,
			a_QueryLanguage ,
			a_Query
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelQuery (

			a_Id
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_AccessCheck (

	WmiInternalContext a_InternalContext ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = AccessCheck (

			a_QueryLanguage ,
			a_Query ,
			a_SidLength ,
			a_Sid
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_FindConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindConsumer (

			a_LogicalConsumer ,
			a_Consumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ValidateSubscription (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ValidateSubscription (

			a_LogicalConsumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	return a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  a_Interface = m_Provider_IWbemServices ;
	  a_IsProxy = FALSE ;
	  return S_OK;
	}

	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedUserHost:
		{
			a_Interface = m_Provider_IWbemServices ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , a_Proxy , a_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = m_Provider_IWbemServices ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IWbemServices * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( 

								m_ProxyContainer , 
								ProxyIndex_IWbemServices , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) )
				{
					DecoupledProviderSubSystem_Globals  :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	if (!OS::secureOS_)
	{
	  return S_OK;
	}

	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedUserHost:
		{
		}
		break ;

		default:
		{
			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IWbemServices *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;

				t_Result = Begin_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Interface->CancelAsyncCall (

						t_ObjectSink
					) ;

					End_IWbemServices (

						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_GetObjectAsync () ;

						try	
						{
							t_Result = a_Service->GetObjectAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						Increment_ProviderOperation_GetObjectAsync () ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							try
							{
								t_Result = a_Service->GetObjectAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"GetObjectAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_GetObjectAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutClassAsync () ;

							try
							{
								t_Result = a_Service->PutClassAsync (

 									a_Object ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutClassAsync ( 

					t_IsProxy ,
					a_Object ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteClassAsync () ;

						try
						{
							t_Result = a_Service->DeleteClassAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteClassAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateClassEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateClassEnumAsync (

 								a_SuperClass ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									a_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"CreateClassEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateClassEnumAsync ( 

					t_IsProxy ,
					a_SuperClass ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutInstanceAsync () ;

							try
							{
								t_Result = a_Service->PutInstanceAsync (

 									a_Instance ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutInstanceAsync ( 

					t_IsProxy ,
					a_Instance ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteInstanceAsync () ;

						try
						{
							t_Result = a_Service->DeleteInstanceAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteInstanceAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;

			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateInstanceEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							Increment_ProviderOperation_CreateInstanceEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateInstanceEnumAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateInstanceEnumAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

				m_Allocator ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				FALSE
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ExecQueryAsync () ;

							try
							{
								t_Result = a_Service->ExecQueryAsync (

									a_QueryLanguage ,
									a_Query, 
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = OS::CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										a_QueryLanguage ,
										a_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"ExecQueryAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = DecoupledProviderSubSystem_Globals  :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

									m_Allocator ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									FALSE
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_Sink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_Sink ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											UnLock () ;

											if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
											{
												a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
											}

											if ( a_IsProxy )
											{
												t_Result = OS::CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}

											if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
											{
												a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

												if ( a_IsProxy )
												{
													t_Result = OS::CoImpersonateClient () ;
												}
												else
												{
													t_Result = S_OK ;
												}

												if ( SUCCEEDED ( t_Result ) ) 
												{
													Increment_ProviderOperation_CreateInstanceEnumAsync () ;

													try
													{
														t_Result = a_Service->CreateInstanceEnumAsync (

 															t_Class ,
															a_Flags ,
															t_ContextCopy ,
															t_Sink 
														) ;
													}
													catch ( ... )
													{
														t_Result = WBEM_E_PROVIDER_FAILURE ;
													}
					
													CoRevertToSelf () ;
												}
												else
												{
													t_Result = WBEM_E_ACCESS_DENIED ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									if ( FAILED ( t_Result ) )
									{
										HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecQueryAsync ( 

					t_IsProxy ,
					a_QueryLanguage ,
					a_Query, 
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_ExecMethodAsync () ;

						try
						{
							t_Result = a_Service->ExecMethodAsync (

 								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								t_ContextCopy ,
								a_InParams ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									a_ObjectPath ,
									a_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"ExecMethodAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecMethodAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_MethodName ,
					a_Flags ,
					a_Context ,
					a_InParams ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{
			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ProvideEvents () ;

				try
				{
					t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ProvideEvents () ;

							try
							{
								t_Result = t_Provider->ProvideEvents (

									a_Sink ,
									a_Flags 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_NewQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_NewQuery () ;

							try
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_CancelQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

						a_Id
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_CancelQuery () ;

							try
							{
								t_Result = t_Provider->CancelQuery (

									a_Id
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_AccessCheck () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_AccessCheck () ;

							try
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_SetRegistrationObject () ;

				try
				{
					t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

						a_Flags ,
						a_ProviderRegistration
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_SetRegistrationObject () ;

							try
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_FindConsumer () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_FindConsumer () ;

							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemDecoupledUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemDecoupledUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ValidateSubscription () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ValidateSubscription () ;

							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;
	
	if ( m_Unknown )
	{
		IWbemProviderInit *t_Provider = NULL ;

		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_Provider ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			try 
			{
				t_Result = t_Provider->Initialize (

					a_User,
					a_Flags,
					a_Namespace,
					a_Locale,
					a_CoreService,
					a_Context,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}

			t_Provider->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_Initialize (

	WmiInternalContext a_InternalContext ,
	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Initialize (

			a_User ,
			a_Flags ,
			a_Namespace ,
			a_Locale ,
			a_CoreService ,
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ProviderInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetContainer ( IUnknown *a_Container )
{	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals  :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals  :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals  :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals  :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals  :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals  :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provtree.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <typeinfo.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvTree.h"

WmiTreeNode *WmiTreeNode :: Copy () 
{
	TypeId_TreeNode t_Type = m_Type ;
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiTreeNode ( t_Type , t_DataCopy , t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiTreeNode :: CopyNode () 
{
	WmiTreeNode *t_Node = new WmiTreeNode ( this ) ;
	return t_Node ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provobsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvWsv.h"
#include "ProvObSk.h"
#include "Exclusion.h"
#include "Guids.h"

enum { CALLED = 0, NOTCALLED = -1};

inline int First(LONG& value)
  {
    return ( value<0 && InterlockedIncrement(&value)==0 );
  }

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemObjectSink :: CInterceptor_IWbemObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			this
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( NOTCALLED ),
		m_SecurityDescriptor ( NULL ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemObjectSink::~CInterceptor_IWbemObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

HRESULT CInterceptor_IWbemObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return DecoupledProviderSubSystem_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemObjectSink :: CallBackRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: CallBackRelease ()" )  ;
#endif

	if ( m_StatusCalled == NOTCALLED )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemObjectSink :: CInterceptor_DecoupledIWbemObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			this
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( NOTCALLED ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemObjectSink::~CInterceptor_DecoupledIWbemObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


void CInterceptor_DecoupledIWbemObjectSink :: CallBackRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: CallBackRelease ()" )  ;
#endif

	if ( m_StatusCalled == NOTCALLED )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: AddRef ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: AddRef ()" )  ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink :: CInterceptor_IWbemSyncObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			this
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( NOTCALLED ) ,
		m_Exclusion ( a_Exclusion ) ,
		m_Dependant ( a_Dependant ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	if ( m_Exclusion ) 
	{
		m_Exclusion->AddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink::~CInterceptor_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemSyncObjectSink :: CallBackRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink :: CallBackRelease ()" )  ;
#endif
	
	if (First(m_StatusCalled))
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_Exclusion ) 
	{
		m_Exclusion->Release () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncObjectSink :: AddRef ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink :: AddRef ()" )  ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}

				if ( m_Exclusion ) 
				{
					if ( m_Dependant ) 
					{
						m_Exclusion->GetExclusion ().LeaveWrite () ;
					}
					else
					{
						m_Exclusion->GetExclusion ().LeaveRead () ;
					}
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

	long a_Flags ,
	BSTR a_ObjectPath ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (
			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_GetObjectAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: ~CInterceptor_IWbemSyncObjectSink_GetObjectAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_GetObjectAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_GetObjectAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

	long a_Flags ,
	BSTR a_ObjectPath ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: ~CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteInstanceAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

	long a_Flags ,
	BSTR a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteClassAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: ~CInterceptor_IWbemSyncObjectSink_DeleteClassAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteClassAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_PutClassAsync :: CInterceptor_IWbemSyncObjectSink_PutClassAsync (

	long a_Flags ,
	IWbemClassObject *a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Class )
	{
		m_Class->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutClassAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_PutClassAsync :: ~CInterceptor_IWbemSyncObjectSink_PutClassAsync ()
{
	if ( m_Class )
	{
		m_Class->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_PutClassAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_PutClassAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutClassAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

	long a_Flags ,
	IWbemClassObject *a_Instance ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Instance ( a_Instance ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Instance )
	{
		m_Instance->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutInstanceAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Instance
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: ~CInterceptor_IWbemSyncObjectSink_PutInstanceAsync ()
{
	if ( m_Instance )
	{
		m_Instance->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutInstanceAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Instance ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

	long a_Flags ,
	BSTR a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;
#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: ~CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{

#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

	long a_Flags ,
	BSTR a_SuperClass ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_SuperClass ( a_SuperClass ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_SuperClass
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: ~CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync ()
{
	if ( m_SuperClass ) 
	{
		SysFreeString ( m_SuperClass ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateClassEnumAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_SuperClass ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

	long a_Flags ,
	BSTR a_QueryLanguage ,
	BSTR a_Query ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Query ( a_Query ) ,
		m_QueryLanguage ( a_QueryLanguage ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecQueryAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_QueryLanguage ,
			m_Query
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: ~CInterceptor_IWbemSyncObjectSink_ExecQueryAsync ()
{
	if ( m_Query ) 
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		SysFreeString ( m_QueryLanguage ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecQueryAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_QueryLanguage ,
				m_Query ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

	long a_Flags ,
	BSTR a_ObjectPath ,
	BSTR a_MethodName ,
	IWbemClassObject *a_InParameters ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	CInterceptor_IWbemSyncObjectSink (

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Exclusion ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_MethodName ( a_MethodName ) ,
		m_InParameters ( a_InParameters ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_InParameters ) 
	{
		m_InParameters->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

#if 0
		WmiSetAndCommitObject (

			DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecMethodAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath ,
			m_MethodName ,
			m_InParameters
		) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: ~CInterceptor_IWbemSyncObjectSink_ExecMethodAsync ()
{
	if ( m_MethodName ) 
	{
		SysFreeString ( m_MethodName ) ;
	}

	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_InParameters ) 
	{
		m_InParameters->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CInterceptor_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
#if 0
			WmiSetAndCommitObject (

				DecoupledProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecMethodAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				m_MethodName ,
				m_InParameters ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemFilteringObjectSink :: CInterceptor_IWbemFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query

)	:	CInterceptor_IWbemObjectSink ( 

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller 
		) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);


	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemFilteringObjectSink::~CInterceptor_IWbemFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

#if 0
	if ( m_Filtering )
	{
		for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ ) 
		{
			if ( SUCCEEDED ( m_QueryFilter->TestObject ( 0 , 0 , IID_IWbemClassObject , ( void * ) a_ObjectArray [ t_Index ] ) ) )
			{
				t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

					t_Index  ,
					& a_ObjectArray [ t_Index ]
				) ;
			}
		}
	}
	else
	{
		t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}
#else
	t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

		a_ObjectCount ,
		a_ObjectArray
	) ;
#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemFilteringObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_PROGRESS:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_COMPLETE:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_REQUIREMENTS:
		{
#if 0
			if ( ! InterlockedCompareExchange ( & m_Filtering , 1 , 0 ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

					CLSID_WbemQuery ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemQuery ,
					( void ** ) & m_QueryFilter
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_QueryFilter->Parse ( 

						m_QueryLanguage ,
						m_Query , 
						0 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
#else
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
		break;

		default:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncFilteringObjectSink :: CInterceptor_IWbemSyncFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	Exclusion *a_Exclusion ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			this
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( NOTCALLED ) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL ) ,
		m_Exclusion ( a_Exclusion ) ,
		m_Dependant ( a_Dependant ) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;

	if ( m_Exclusion ) 
	{
		m_Exclusion->AddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncFilteringObjectSink::~CInterceptor_IWbemSyncFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	if ( m_Exclusion ) 
	{
		m_Exclusion->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemSyncFilteringObjectSink :: CallBackRelease ()
{
	if ( m_StatusCalled == NOTCALLED )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncFilteringObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncFilteringObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemSyncFilteringObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncFilteringObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncFilteringObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
#if 0
		if ( m_Filtering )
		{
			for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ ) 
			{
				if ( SUCCEEDED ( m_QueryFilter->TestObject ( 0 , 0 , IID_IWbemClassObject , ( void * ) a_ObjectArray [ t_Index ] ) ) )
				{
					t_Result = m_InterceptedSink->Indicate ( 

						t_Index  ,
						& a_ObjectArray [ t_Index ]
					) ;
				}
			}
		}
		else
		{
			t_Result = m_InterceptedSink->Indicate ( 

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
#else
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
#endif
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncFilteringObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}

				if ( m_Exclusion ) 
				{
					if ( m_Dependant ) 
					{
						m_Exclusion->GetExclusion ().LeaveWrite () ;
					}
					else
					{
						m_Exclusion->GetExclusion ().LeaveRead () ;
					}
				}
			}
			break ;

			case WBEM_STATUS_REQUIREMENTS:
			{
#if 0
				if (First(m_Filtering))
				{
					t_Result = DecoupledProviderSubSystem_Globals :: CreateInstance	(

						CLSID_WbemQuery ,
						NULL ,
						CLSCTX_INPROC_SERVER ,
						IID_IWbemQuery ,
						( void ** ) & m_QueryFilter
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = m_QueryFilter->Parse ( 

							m_QueryLanguage ,
							m_Query , 
							0 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
#else
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
#endif

			}
			break;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


#pragma warning( disable : 4355 )

CInterceptor_IWbemCombiningObjectSink :: CInterceptor_IWbemCombiningObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			this
	) ,
#if 0
	m_Internal ( this ) ,
#endif
	m_InterceptedSink ( a_InterceptedSink ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( NOTCALLED ) ,
	m_SinkCount ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	DWORD lastError = GetLastError();
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemCombiningObjectSink::~CInterceptor_IWbemCombiningObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemCombiningObjectSink :: CallBackRelease ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemCombiningObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
#if 0
	else if ( iid == IID_CWbemCombiningObjectSink )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	
#endif
	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemCombiningObjectSink :: AddRef ()
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemCombiningObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemCombiningObjectSink :: Release ()" ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemCombiningObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemCombiningObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemCombiningObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( FAILED ( a_Result ) )
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if ( t_SinkCount == 0 )
			{
			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					a_Result ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}
			}
		}
		else
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if ( t_SinkCount == 0 )
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						0 ,
						S_OK ,
						NULL ,
						NULL 
					) ;

					SetEvent ( m_Event ) ;
				}
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemCombiningObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemCombiningObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemCombiningObjectSink :: EnQueue ( CInterceptor_IWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Insert ( 

		*a_Sink ,
		t_Iterator
	) ;

	UnLock () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		InterlockedIncrement ( & m_SinkCount ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemCombiningObjectSink :: Suspend ()
{
	InterlockedIncrement ( & m_SinkCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemCombiningObjectSink :: Resume ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_SinkCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
		}
		else
		{
			if (First(m_StatusCalled))
			{
				HRESULT t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					S_OK ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}			
		}

		InterlockedDecrement ( & m_InProgress ) ;

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemCombiningObjectSink :: CInterceptor_DecoupledIWbemCombiningObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			this
	) ,
#if 0
	m_Internal ( this ) ,
#endif
	m_InterceptedSink ( a_InterceptedSink ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( NOTCALLED ) ,
	m_SinkCount ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	DWORD lastError = GetLastError();
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemCombiningObjectSink::~CInterceptor_DecoupledIWbemCombiningObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: CallBackRelease ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemCombiningObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
#if 0
	else if ( iid == IID_CWbemCombiningObjectSink )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	
#endif
	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()" ) ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()" ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( FAILED ( a_Result ) )
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if (t_SinkCount == 0)
			{
			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					WBEM_STATUS_COMPLETE ,
					a_Result ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}
			}
		}
		else
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if ( t_SinkCount == 0 )
			{
				if (First(m_StatusCalled))
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						0 ,
						S_OK ,
						NULL ,
						NULL 
					) ;

					SetEvent ( m_Event ) ;
				}
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Insert ( 

		*a_Sink ,
		t_Iterator
	) ;

	UnLock () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		InterlockedIncrement ( & m_SinkCount ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Suspend ()
{
	InterlockedIncrement ( & m_SinkCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Resume ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_SinkCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
		}
		else
		{
			if (First(m_StatusCalled))
			{
				HRESULT t_Result = m_InterceptedSink->SetStatus ( 

					WBEM_STATUS_COMPLETE ,
					S_OK ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}			
		}

		InterlockedDecrement ( & m_InProgress ) ;

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemWaitingObjectSink :: CInterceptor_IWbemWaitingObjectSink (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			this
	) ,
	m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( NOTCALLED ) ,
	m_Result ( S_OK ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);

	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	DWORD lastError = GetLastError();

}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink::~CInterceptor_IWbemWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemWaitingObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemWaitingObjectSink :: AddRef ()
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemWaitingObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemWaitingObjectSink :: Release ()" ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		LockGuard<CriticalSection> monitor(  m_CriticalSection ) ;
		if (monitor.locked())
			{
			for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ )
			{
				WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					a_ObjectArray [ t_Index ]->AddRef () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
			}
		else
			t_Result = WBEM_E_OUT_OF_MEMORY ;

	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemWaitingObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if (First(m_StatusCalled))
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = a_Result ;
			}

			SetEvent ( m_Event ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled))
			{
				m_Result = WBEM_E_SHUTTING_DOWN ;

				SetEvent ( m_Event ) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWaitingObjectSink :: CWaitingObjectSink (

	WmiAllocator &a_Allocator

) : m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( NOTCALLED ) ,
	m_Result ( S_OK ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;

	m_Event = OS::CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	DWORD lastError = GetLastError();
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWaitingObjectSink::~CWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CWaitingObjectSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CWaitingObjectSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CWaitingObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCWaitingObjectSink :: Release ()" ) ;
#endif

	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		LockGuard<CriticalSection> monitor( m_CriticalSection ) ;
		if (monitor.locked())
			{

			for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ )
			{
				WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					a_ObjectArray [ t_Index ]->AddRef () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
			}
		else
			t_Result = WBEM_E_OUT_OF_MEMORY ;			
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCWaitingObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{

		if (First(m_StatusCalled) )
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = a_Result ;
			}

			SetEvent ( m_Event ) ;
		}
    

	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			if (First(m_StatusCalled) )
			{
				m_Result = WBEM_E_SHUTTING_DOWN ;

				SetEvent ( m_Event ) ;
			}

			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provobjectsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include "CGlobals.h"
#include "ProvObjectSink.h"

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Begin_IWbemObjectSink (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_IWbemObjectSink , 
						IID_IWbemObjectSink , 
						m_InterceptedSink , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_Internal_IWbemObjectSink , 
						IID_Internal_IWbemObjectSink , 
						m_Internal_InterceptedSink , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_IWbemObjectSink , 
				IID_IWbemObjectSink , 
				m_InterceptedSink , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_InterceptedSink ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_Internal_IWbemObjectSink , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_IWbemObjectSink , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: End_IWbemObjectSink (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_Internal_IWbemObjectSink , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_IWbemObjectSink , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_IWbemSyncObjectSink :: CCommon_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
#ifdef INTERNAL_IDENTIFY
		m_Internal_InterceptedSink ( NULL ) ,
		m_ProxyContainer ( a_Allocator , ProxyIndex_ObjectSink_Size , MAX_PROXIES )
#endif
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_Dependant ( a_Dependant )
{
	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;

#ifdef INTERNAL_IDENTIFY
		HRESULT t_TempResult = m_InterceptedSink->QueryInterface ( IID_Internal_IWbemObjectSink , ( void ** ) & m_Internal_InterceptedSink ) ;
#endif
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_IWbemSyncObjectSink :: ~CCommon_IWbemSyncObjectSink ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CCommon_IWbemSyncObjectSink :: CallBackInternalRelease ()
{
#ifdef INTERNAL_IDENTIFY
	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;
#endif
	
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

#ifdef INTERNAL_IDENTIFY

	if ( m_Internal_InterceptedSink )
	{
		m_Internal_InterceptedSink->Release () ;
	}
#endif

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CCommon_IWbemSyncObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: AddRef ( void )
{
	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CCommon_IWbemSyncObjectSink :: Release ( void )
{
	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

#ifdef INTERNAL_IDENTIFY

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
#endif

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = Helper_Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;

#ifdef DBG
		if ( FAILED ( t_Result ) )
		{
			OutputDebugString ( L"\nCCommon_IWbemSyncObjectSink :: Indicate - Failure () " ) ;
		}
#endif
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	BOOL t_Impersonating ;
	IUnknown *t_OldContext ;
	IServerSecurity *t_OldSecurity ;
	BOOL t_IsProxy ;
	IUnknown *t_Interface ;
	BOOL t_Revert ;
	IUnknown *t_Proxy ;
	DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
	HANDLE t_IdentifyToken = NULL ;

	HRESULT t_Result = Begin_IWbemObjectSink (

		t_ProcessIdentifier ,
		t_IdentifyToken ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity ,
		t_IsProxy ,
		t_Interface ,
		t_Revert ,
		t_Proxy 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_IdentifyToken )
		{
			WmiInternalContext t_InternalContext ;
			t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
			t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

			t_Result = ( ( Internal_IWbemObjectSink * ) t_Interface )->Internal_Indicate (

				t_InternalContext ,
				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
		else
		{

			t_Result = ( ( IWbemObjectSink * ) t_Interface )->Indicate (

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}

		End_IWbemObjectSink (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	BOOL t_Impersonating ;
	IUnknown *t_OldContext ;
	IServerSecurity *t_OldSecurity ;
	BOOL t_IsProxy ;
	IUnknown *t_Interface ;
	BOOL t_Revert ;
	IUnknown *t_Proxy ;
	DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
	HANDLE t_IdentifyToken = NULL ;

	HRESULT t_Result = Begin_IWbemObjectSink (

		t_ProcessIdentifier ,
		t_IdentifyToken ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity ,
		t_IsProxy ,
		t_Interface ,
		t_Revert ,
		t_Proxy 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_StringParam = NULL ;
		if ( a_StringParam )
		{
			t_StringParam = SysAllocString ( a_StringParam ) ;
			if ( t_StringParam == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemObjectSink * ) t_Interface )->Internal_SetStatus (

					t_InternalContext ,
					a_Flags ,
					a_Result ,
					t_StringParam ,
					a_ObjectParam
				) ;
			}
			else
			{

				t_Result = ( ( IWbemObjectSink * ) t_Interface )->SetStatus (

					a_Flags ,
					a_Result ,
					t_StringParam ,
					a_ObjectParam
				) ;
			}
		}

		SysFreeString ( t_StringParam ) ;

		End_IWbemObjectSink (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;
	}

	return t_Result ;
}

#else

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = m_InterceptedSink->Indicate (

		a_ObjectCount ,
		a_ObjectArray
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Helper_SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_StringParam = NULL ;
	if ( a_StringParam )
	{
		t_StringParam = SysAllocString ( a_StringParam ) ;
		if ( t_StringParam == NULL )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_InterceptedSink->SetStatus (

			a_Flags ,
			a_Result ,
			t_StringParam ,
			a_ObjectParam
		) ;

		SysFreeString ( t_StringParam ) ;
	}

	return t_Result ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCCommon_IWbemSyncObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = Helper_SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = Helper_SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_IWbemSyncObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = Helper_SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CCommon_Batching_IWbemSyncObjectSink :: CCommon_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink ( 

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Queue ( a_Allocator ) ,
		m_Size ( 0 ),
		m_CriticalSection(NOTHROW_LOCK)
{
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCommon_Batching_IWbemSyncObjectSink :: ~CCommon_Batching_IWbemSyncObjectSink ()
{
	IWbemClassObject *t_ClassObject ;
	WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_ClassObject->Release () ;

		t_StatusCode = m_Queue.DeQueue () ;
	}

	m_Queue.UnInitialize () ;

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SinkInitialize () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection );
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_Queue.Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	if ( m_GateClosed == 0 )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
			{
				if ( a_ObjectArray [ t_Index ] )
				{
					ULONG t_ObjectSize = 0 ;
					_IWmiObject *t_Object ;
					HRESULT t_TempResult = a_ObjectArray [ t_Index ]->QueryInterface ( IID__IWmiObject , ( void ** ) & t_Object ) ;
					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_TempResult = t_Object->GetObjectMemory (

							NULL ,
							0 ,
							& t_ObjectSize
						);

						if ( t_TempResult == WBEM_E_BUFFER_TOO_SMALL )
						{
							if ( ( t_ObjectSize + m_Size ) < ProviderSubSystem_Common_Globals :: GetTransmitSize () )
							{
								WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
									a_ObjectArray [ t_Index ]->AddRef () ;
									m_Size = m_Size + t_ObjectSize ;
								}			
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								ULONG t_Count = m_Queue.Size () + 1 ;
								IWbemClassObject **t_Array = new IWbemClassObject * [ t_Count ] ;
								if ( t_Array )
								{
									IWbemClassObject *t_ClassObject ;
									WmiStatusCode t_StatusCode ;

									t_Array [ t_Count - 1 ] = a_ObjectArray [ t_Index ] ;

									ULONG t_InnerIndex = 0 ;
									while ( ( t_StatusCode = m_Queue.Top ( t_ClassObject ) ) == e_StatusCode_Success )
									{
										t_Array [ t_InnerIndex ] = t_ClassObject ;

										t_InnerIndex ++ ;

										t_StatusCode = m_Queue.DeQueue() ;
									}

									m_Size = 0 ;

									WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

									t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

									for ( t_InnerIndex = 0 ; t_InnerIndex < t_Count - 1 ; t_InnerIndex ++ )
									{
										t_Array [ t_InnerIndex ]->Release () ;
									}

									delete [] t_Array ;

									t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
									if ( t_StatusCode == e_StatusCode_Success )
									{
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
						}

						t_Object->Release () ;
					}
				}
			}

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

			return t_Result ;
		}
		else
		{
			return WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		return WBEM_E_SHUTTING_DOWN ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_COMPLETE:
		{
			if ( m_GateClosed == 0 )
			{
				WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE );
				if ( t_StatusCode == e_StatusCode_Success )
				{
					LONG t_Count = m_Queue.Size () ;
					if ( t_Count )
					{
						IWbemClassObject **t_Array = new IWbemClassObject * [ m_Queue.Size () ] ;
						if ( t_Array )
						{
							for ( LONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								IWbemClassObject *t_ClassObject ;
								WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
								if ( t_StatusCode == e_StatusCode_Success )
								{
									t_Array [ t_Index ] = t_ClassObject ;

									t_StatusCode = m_Queue.DeQueue () ;
								}
							}

							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = CCommon_IWbemSyncObjectSink :: Indicate ( t_Count , t_Array ) ;

							for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								if ( t_Array [ t_Index ] )
								{
									t_Array [ t_Index ]->Release () ;
								}
							}

							delete [] t_Array ;
						}
						else
						{
							WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						WmiHelper :: LeaveCriticalSection ( & m_CriticalSection );
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				a_Result = t_Result ;
			}

			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;

		default:
		{
			t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

				a_Flags , 
				a_Result , 
				a_StringParam ,	
				a_ObjectParam
			) ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provreginfo.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#undef POLARITY

#include <typeinfo.h>
#include <stdio.h>
#include <sddl.h>

#include <wbemint.h>
#include <genlex.h>
#include <sql_1.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvDnf.h"
#include "ProvRegInfo.h"
#include "DateTime.h"
#include "ssdlhelper.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_SecureSvcHostProviders [] =
{
	L"{266c72d4-62e8-11d1-ad89-00c04fd8fdff}"	,	// "LogFileEventConsumer"
    L"{266c72e6-62e8-11d1-ad89-00c04fd8fdff}"   ,	// "NTEventLogEventConsumer"    
	L"{29F06F0C-FB7F-44A5-83CD-D41705D5C525}"	,	// "Non Com provider"
	L"{405595AA-1E14-11d3-B33D-00105A1F4AAF}"	,	// "Microsoft WMI Transient Provider"
	L"{405595AB-1E14-11d3-B33D-00105A1F4AAF}"	,	// "Microsoft WMI Transient Reboot Event Provider"
	L"{74E3B84C-C7BE-4e0a-9BD2-853CA72CD435}"	,	// "Microsoft WMI Updating Consumer Assoc Provider"
	L"{7879E40D-9FB5-450a-8A6D-00C89F349FCE}"	,	// "Microsoft WMI Forwarding Event Provider"
	L"{7F598975-37E0-4a67-A992-116680F0CEDA}"	,	// "Msft_ProviderSubSystem"	
	L"{9877D8A7-FDA1-43F9-AEEA-F90747EA66B0}"	,	// "WMI Kernel Trace Event Provider"
	L"{A3A16907-227B-11d3-865D-00C04F63049B}"	,	// "Microsoft WMI Updating Consumer Provider"
	L"{A83EF168-CA8D-11d2-B33D-00104BCC4B4A}"	,	// "WBEMCORE
	L"{AD1B46E8-0AAC-401b-A3B8-FCDCF8186F55}"	,	// "Microsoft WMI Forwarding Consumer Provider"
	L"{C486ABD2-27F6-11d3-865E-00C04F63049B}"	,	// "Microsoft WMI Template Provider"
	L"{D6C74FF3-3DCD-4c23-9F58-DD86F371EC73}"	,	// "Microsoft WMI Forwarding Ack Event Provider"
	L"{FD18A1B2-9E61-4e8e-8501-DB0B07846396}"		// "Microsoft WMI Template Association Provider"
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *g_SecureLocalSystemProviders [] =
{
	L"{72967901-68EC-11d0-B729-00AA0062CBB7}",		// "RegPropProv"
	L"{B3FF88A4-96EC-4cc1-983F-72BE0EBB368B}",		// "Rsop Logging Mode Provider"
    L"{BE0A9830-2B8B-11d1-A949-0060181EBBAD}",		// "MSIProv"
	L"{F0FF8EBB-F14D-4369-BD2E-D84FBF6122D6}",		// "Rsop Planning Mode Provider"
	L"{FA77A74E-E109-11D0-AD6E-00C04FD8FDFF}",		// "RegistryEventProvider"
	L"{FE9AF5C0-D3B6-11CE-A5B6-00AA00680C3F}"		// "RegProv"
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT QuickFind ( wchar_t *a_Clsid , ULONG a_Size , wchar_t **a_Container )
{
	ULONG t_Lower = 0 ;
	ULONG t_Upper = a_Size ;

	while ( t_Lower < t_Upper ) 
	{
		ULONG t_Index = ( t_Lower + t_Upper ) >> 1 ;

		LONG t_Compare = _wcsicmp ( a_Clsid , a_Container [ t_Index ] ) ;
		if ( t_Compare == 0 ) 
		{
			return S_OK ;
		}
		else
		{
			if ( t_Compare < 0 ) 
			{
				t_Upper = t_Index ;
			}
			else
			{
				t_Lower = t_Index + 1 ;
			}
		}
	}

	return WBEM_E_ACCESS_DENIED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid )
{
	return QuickFind ( a_Clsid , sizeof ( g_SecureLocalSystemProviders ) / sizeof ( wchar_t * ) , g_SecureLocalSystemProviders ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid )
{
	return QuickFind ( a_Clsid , sizeof ( g_SecureSvcHostProviders ) / sizeof ( wchar_t * ) , g_SecureSvcHostProviders ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

GENERIC_MAPPING g_ProviderBindingMapping = {

	0 ,
	0 ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND ,
	STANDARD_RIGHTS_REQUIRED | MASK_PROVIDER_BINDING_BIND 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_Class = L"__CLASS" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___ObjectProviderCacheControl = L"__ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi___EventProviderCacheControl = L"__EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_ClearAfter = L"ClearAfter" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Object = L"Select * from __ObjectProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Object = L"__ObjectProviderCacheControl=@" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Query_Event = L"Select * from __EventProviderCacheControl" ;
LPCWSTR CServerObject_GlobalRegistration :: s_Strings_Wmi_s_Strings_Path_Event = L"__EventProviderCacheControl=@" ;

LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Query = L"Select * from __ProviderHostQuotaConfiguration" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HostQuotas_Path = L"__ProviderHostQuotaConfiguration=@" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryPerHost = L"MemoryPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_MemoryAllHosts = L"MemoryAllHosts" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ThreadsPerHost = L"ThreadsPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_HandlesPerHost = L"HandlesPerHost" ;
LPCWSTR CServerObject_HostQuotaRegistration :: s_Strings_Wmi_ProcessLimitAllHosts = L"ProcessLimitAllHosts" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ClsidKeyStr = L"CLSID\\" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Null = NULL ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_ThreadingModel = L"ThreadingModel" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_InProcServer32 = L"InProcServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_LocalServer32 = L"LocalServer32" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization = L"Synchronization" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_AppId = L"AppId" ;

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Apartment = L"apartment" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Both = L"both";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Free = L"free";
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Apartment_Neutral = L"neutral";

LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Ignored = L"ignored" ; 
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_None = L"none" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Supported = L"supported" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_Required = L"required" ;
LPCWSTR CServerObject_ComRegistration :: s_Strings_Reg_Synchronization_RequiresNew = L"requiresnew" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Clsid = L"CLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ClientClsid = L"ClientLoadableCLSID" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Name = L"Name" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultMachineName = L"DefaultMachineName" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_UnloadTimeout = L"UnloadTimeout" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ImpersonationLevel = L"ImpersonationLevel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationReentrancy = L"InitializationReentrancy" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializeAsAdminFirst = L"InitializeAsAdminFirst" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerUserInitialization = L"PerUserInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_PerLocaleInitialization = L"PerLocaleInitialization" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Pure = L"Pure" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Hosting = L"HostingModel" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_HostingGroup = L"HostingGroup" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsThrottling = L"SupportsThrottling" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsShutdown = L"SupportsShutdown" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ConcurrentIndependantRequests = L"ConcurrentIndependantRequests";
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsSendStatus = L"SupportsSendStatus" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_OperationTimeoutInterval = L"OperationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_InitializationTimeoutInterval = L"InitializationTimeoutInterval" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SupportsQuotas = L"SupportsQuotas" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Enabled = L"Enabled" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Version = L"Version" ;
LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SecurityDescriptor = L"SecurityDescriptor" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCore [] = L"WmiCore" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_WmiCoreOrSelfHost [] = L"WmiCoreOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SelfHost [] = L"SelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_ClientHost [] = L"ClientHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_Decoupled [] = L"Decoupled:Com" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DecoupledColon [] = L"Decoupled:Com:" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHost [] = L"LocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] = L"LocalSystemHostOrSelfHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedNetworkServiceHost [] = L"NetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedLocalServiceHost [] = L"LocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_SharedUserHost [] = L"UserHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_NonCom [] = L"Decoupled:NonCom" ;

WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] = L"DefaultLocalSystemHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost [] = L"DefaultNetworkServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedLocalServiceHost [] = L"DefaultLocalServiceHost" ;
WCHAR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedUserHost [] = L"DefaultUserHost" ;

LPCWSTR CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultHostingRegistryKey = L"Software\\Microsoft\\WBEM\\Providers\\Configuration\\" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_InstanceProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsDelete = L"SupportsDelete" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsEnumeration = L"SupportsEnumeration" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels = L"QuerySupportLevels" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType = L"InteractionType" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsBatching = L"SupportsBatching" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_SupportsTransactions = L"SupportsTransactions" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_CacheRefreshInterval = L"CacheRefreshInterval" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_PerUserSchema = L"PerUserSchema" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReSynchroniseOnNamespaceOpen = L"ReSynchroniseOnNamespaceOpen" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_Version = L"Version" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_UnarySelect = L"WQL:UnarySelect" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_References = L"WQL:References" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_Associators = L"WQL:Associators" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_QuerySupportLevels_V1ProviderDefined = L"WQL:V1ProviderDefined" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Pull = L"Pull" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_Push = L"Push" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_InteractionType_PushVerify = L"PushVerify" ;

LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ResultSetQueries = L"ResultSetQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_UnSupportedQueries = L"UnSupportedQueries" ;
LPCWSTR CServerObject_ClassProviderRegistrationV1 :: s_Strings_ReferencedSetQueries = L"ReferencedSetQueries" ;

LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_MethodProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;

LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;

LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_EventConsumerProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsPut = L"SupportsPut" ;
LPCWSTR CServerObject_DynamicPropertyProviderRegistrationV1 :: s_Strings_SupportsGet = L"SupportsGet" ;

LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_Class  = L"__CLASS" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_ClassProviderRegistration = L"__ClassProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_InstanceProviderRegistration = L"__InstanceProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_MethodProviderRegistration = L"__MethodProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_PropertyProviderRegistration = L"__PropertyProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventProviderRegistration = L"__EventProviderRegistration" ;
LPCWSTR CServerObject_ProviderRegistrationV1 :: s_Strings_EventConsumerProviderRegistration = L"__EventConsumerProviderRegistration" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: CServerObject_GlobalRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Object_UnloadTimeout ( NULL ) ,
	m_Event_UnloadTimeout ( NULL ) ,
	m_Object_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Event_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_GlobalRegistration :: ~CServerObject_GlobalRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Object_UnloadTimeout )
	{
		SysFreeString ( m_Object_UnloadTimeout ) ;
	}

	if ( m_Event_UnloadTimeout )
	{
		SysFreeString ( m_Event_UnloadTimeout ) ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_GlobalRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPWSTR &a_UnloadTimeout ,
	ULONG &a_UnloadTimeoutMilliSeconds 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_ClearAfter )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_ClearAfter , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
				}

				a_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
				if ( a_UnloadTimeout )
				{
					CWbemDateTime t_Interval ;
					t_Result = t_Interval.PutValue ( a_UnloadTimeout ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT_BOOL t_Bool = VARIANT_FALSE ;
						t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
						if ( t_Bool == VARIANT_TRUE )
						{
							LONG t_MicroSeconds = 0 ;
							LONG t_Seconds = 0 ;
							LONG t_Minutes = 0 ;
							LONG t_Hours = 0 ;
							LONG t_Days = 0 ;

							t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
							t_Interval.GetSeconds ( & t_Seconds ) ;
							t_Interval.GetMinutes ( & t_Minutes ) ;
							t_Interval.GetHours ( & t_Hours ) ;
							t_Interval.GetDay ( & t_Days ) ;

							a_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
														  ( t_Hours * 60 * 60 * 1000 ) +
														  ( t_Minutes * 60 * 1000 ) +
														  ( t_Seconds * 1000 ) +
														  ( t_MicroSeconds / 1000 ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				if ( a_UnloadTimeout )
				{
					SysFreeString ( a_UnloadTimeout ) ;
					a_UnloadTimeout = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Object ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject ,
				m_Object_UnloadTimeout ,
				m_Object_UnloadTimeoutMilliSeconds
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_s_Strings_Path_Event ) ;
		if ( t_ObjectPath ) 
		{
			IWbemClassObject *t_ClassObject = NULL ;

			t_Result = m_Repository->GetObject ( 

				t_ObjectPath ,
				0 ,
				m_Context , 
				& t_ClassObject , 
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = QueryProperties ( 

					a_Mask ,
					t_ClassObject ,
					m_Event_UnloadTimeout ,
					m_Event_UnloadTimeoutMilliSeconds
				) ;

				t_ClassObject->Release () ;
			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_GlobalRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: CServerObject_HostQuotaRegistration () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_MemoryPerHost ( 0 ) ,
	m_MemoryAllHosts ( 0 ) ,
	m_ThreadsPerHost ( 0 ) ,
	m_HandlesPerHost ( 0 ) ,
	m_ProcessLimitAllHosts ( 0 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostQuotaRegistration :: ~CServerObject_HostQuotaRegistration ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_HostQuotaRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastObject = NULL ;

	t_Result = a_Object->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_MemoryAllHosts )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			HRESULT t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryAllHosts ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryAllHosts = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryAllHosts = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
		}

		if ( a_Mask & e_MemoryPerHost )
		{
			UINT64 t_Value = 0 ;

			BOOL t_IsNull = FALSE ;
			CIMTYPE t_VarType = CIM_EMPTY ;
			LONG t_Flavour = 0 ;
			ULONG t_Used = 0 ;

			HRESULT t_Result = t_FastObject->ReadProp ( 

				s_Strings_Wmi_MemoryPerHost ,
				0 ,
				sizeof ( UINT64 ) ,
				& t_VarType ,
				& t_Flavour ,
				& t_IsNull ,
				& t_Used ,
				& t_Value
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IsNull )
				{
					m_MemoryPerHost = 0 ;
				}
				else 
				{
					if ( t_VarType == CIM_UINT64 )
					{
						m_MemoryPerHost = t_Value ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
		}

		t_FastObject->Release () ;
	}

	if ( a_Mask & e_ThreadsPerHost )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_ThreadsPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ThreadsPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ThreadsPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_HandlesPerHost )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_HandlesPerHost , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_HandlesPerHost = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_HandlesPerHost = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_ProcessLimitAllHosts )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_Wmi_ProcessLimitAllHosts , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_ProcessLimitAllHosts = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_ProcessLimitAllHosts = 0 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: QueryRepository ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( s_Strings_Wmi_HostQuotas_Path ) ;
	if ( t_ObjectPath ) 
	{
		IWbemClassObject *t_ClassObject = NULL ;

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& t_ClassObject , 
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				t_ClassObject 
			) ;

			t_ClassObject->Release () ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostQuotaRegistration :: Load ( 

	Enum_PropertyMask a_Mask
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: CServerObject_ComRegistration ()

	:	m_ThreadingModel ( e_ThreadingModel_Unknown ) ,
		m_Synchronization ( e_Ignored ) ,
		m_InProcServer32 ( e_Boolean_Unknown ) ,
		m_LocalServer32 ( e_Boolean_Unknown ) ,
		m_Service ( e_Boolean_Unknown ) ,
		m_Loaded ( e_False ) ,
		m_Clsid ( NULL ) ,
		m_AppId ( NULL ) ,
		m_ProviderName ( NULL ) ,
		m_Result ( S_OK )
{
	m_InProcServer32_Path [ 0 ] = 0 ;
	m_LocalServer32_Path [ 0 ] = 0 ;
	m_Server_Name [ 0 ] = 0 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComRegistration :: ~CServerObject_ComRegistration ()
{
	if ( m_AppId )
	{
		SysFreeString ( m_AppId ) ;
	}

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	if ( m_ProviderName )
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ThreadingModel ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_ThreadingModel ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Apartment ) == 0 ) 
		{
			m_ThreadingModel = e_Apartment ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Both ) == 0 ) 
		{
			m_ThreadingModel = e_Both ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Free ) == 0 ) 
		{
			m_ThreadingModel = e_Free ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Apartment_Neutral ) == 0 )	
		{
			m_ThreadingModel = e_Neutral ;
		}
		else
		{
			m_ThreadingModel = e_ThreadingModel_Unknown ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_Synchronization ( HKEY a_ClsidKey )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_ClsidKey ,
	  s_Strings_Reg_Synchronization ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Ignored ) == 0 ) 
		{
			m_Synchronization = e_Ignored ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_None ) == 0 ) 
		{
			m_Synchronization = e_None ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Supported ) == 0 )	
		{
			m_Synchronization = e_Supported ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_Required ) == 0 )	
		{
			m_Synchronization = e_Required ;
		}
		else if ( _wcsicmp ( t_Data , s_Strings_Reg_Synchronization_RequiresNew ) == 0 )	
		{
			m_Synchronization = e_RequiresNew ;
		}
		else
		{
			m_Synchronization = e_Synchronization_Unknown ;
		}
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_InProcServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_InProcServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_InProcServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_InProcServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_InProcServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_InProcServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_InProcServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_InProcServer32 = e_True ;

			t_Result = Load_ThreadingModel ( t_Clsid_Key_InProcServer32 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Load_Synchronization ( t_Clsid_Key_InProcServer32 ) ;
			}

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_InProcServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_InProcServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_InProcServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			RegCloseKey ( t_Clsid_Key_InProcServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_InProcServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_LocalServer32 ( LPCWSTR a_ClsidStringKey )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key_LocalServer32 = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key_LocalServer32 , 
		a_ClsidStringKey ,
		s_Strings_Reg_LocalServer32
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_Clsid_Key_LocalServer32 ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String_Key_LocalServer32 ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key_LocalServer32 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			m_LocalServer32 = e_True ;
			m_ThreadingModel = e_Free ;
			m_Synchronization = e_Ignored ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_LocalServer32_Path ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key_LocalServer32 ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_LocalServer32_Path ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			RegCloseKey ( t_Clsid_Key_LocalServer32 ) ;
		}

		SysFreeString ( t_Clsid_String_Key_LocalServer32 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_ServerTypes ( LPCWSTR a_ClsidString )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_Clsid_String_Key = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String_Key , 
		a_ClsidString ,
		L"\\"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_InProcServer32 ( t_Clsid_String_Key ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Load_LocalServer32 ( t_Clsid_String_Key ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
		}

		SysFreeString ( t_Clsid_String_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load_AppId ( HKEY a_Clsid_Key )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ValueType = REG_SZ ;
	wchar_t t_Data [ MAX_PATH ] ;
	DWORD t_DataSize = sizeof ( t_Data ) ;

	LONG t_RegResult = RegQueryValueEx (

	  a_Clsid_Key ,
	  s_Strings_Reg_AppId ,
	  0 ,
	  & t_ValueType ,
	  LPBYTE ( & t_Data ) ,
	  & t_DataSize 
	);

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if ( m_AppId )
		{
			SysFreeString ( m_AppId ) ;
		}

		m_AppId = SysAllocString ( t_Data ) ;
		if ( m_AppId )
		{
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComRegistration :: Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
	}

	m_Clsid = SysAllocString ( a_Clsid ) ;

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
	}

	m_ProviderName = SysAllocString ( a_ProviderName ) ;

	LPWSTR t_Clsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		2, 
		& t_Clsid_String , 
		s_Strings_Reg_ClsidKeyStr ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Load_ServerTypes ( t_Clsid_String ) ;

		HKEY t_Clsid_Key ;

		LONG t_RegResult = RegOpenKeyEx (

			HKEY_CLASSES_ROOT ,
			t_Clsid_String ,
			0 ,
			KEY_READ ,
			& t_Clsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( m_Server_Name ) ;

			t_RegResult = RegQueryValueEx (

			  t_Clsid_Key ,
			  s_Strings_Reg_Null ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & m_Server_Name ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
			}

			t_Result = Load_AppId ( t_Clsid_Key	) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_InProcServer32 != e_True && m_LocalServer32 != e_True )
				{
					m_Service = e_True ;
					m_ThreadingModel = e_Free ;
					m_Synchronization = e_Ignored ;
				}
			}

			RegCloseKey ( t_Clsid_Key ) ;
		}

		SysFreeString ( t_Clsid_String ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_Loaded = e_True ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: CServerObject_ComProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Identity ( NULL ) ,
	m_DefaultMachineName ( NULL ) ,
	m_UnloadTimeout ( NULL ) ,
	m_UnloadTimeoutMilliSeconds ( DEFAULT_PROVIDER_TIMEOUT ) ,
	m_OperationTimeout ( NULL ) ,
	m_OperationTimeoutMilliSeconds ( INFINITE ) ,
	m_InitializationTimeout ( NULL ) ,
	m_InitializationTimeoutMilliSeconds ( DEFAULT_PROVIDER_LOAD_TIMEOUT ) ,
	m_Enabled ( TRUE ) ,
	m_SupportsQuotas ( FALSE ) ,
	m_SupportsThrottling ( FALSE ) ,
	m_SupportsSendStatus ( FALSE ) ,
	m_SupportsShutdown ( FALSE ) ,
	m_ConcurrentIndependantRequests ( 0 ) ,
	m_ImpersonationLevel ( e_ImpersonationLevel_Unknown ) ,
	m_InitializationReentrancy ( e_InitializationReentrancy_Namespace ) ,
	m_InitializeAsAdminFirst ( FALSE ) ,
	m_PerUserInitialization ( FALSE ) ,
	m_PerLocaleInitialization ( FALSE ) ,
	m_Pure ( FALSE ) ,
	m_Version ( 1 ) ,
	m_ProviderName ( NULL ) ,
	m_Hosting ( e_Hosting_Undefined ) , // e_Hosting_SharedLocalSystemHost e_Hosting_WmiCore
	m_HostingGroup ( NULL ) ,
	m_Result ( S_OK ) ,
	m_SecurityDescriptor ( NULL ) ,
	m_DecoupledImpersonationRestriction ( TRUE )
{
	ZeroMemory ( & m_CLSID , sizeof ( GUID ) ) ;
	ZeroMemory ( & m_ClientCLSID  , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ComProviderRegistrationV1 :: ~CServerObject_ComProviderRegistrationV1 ()
{
	if ( m_SecurityDescriptor )
	{
		LocalFree ( m_SecurityDescriptor ) ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Identity )
	{
		m_Identity->Release () ;
	}

	if ( m_DefaultMachineName ) 
	{
		SysFreeString ( m_DefaultMachineName ) ;
	}

	if ( m_UnloadTimeout )
	{
		SysFreeString ( m_UnloadTimeout ) ;
	}

	if ( m_HostingGroup )
	{
		SysFreeString ( m_HostingGroup ) ;
	}

	if ( m_InitializationTimeout )
	{
		SysFreeString ( m_InitializationTimeout ) ;
	}

	if ( m_ProviderName ) 
	{
		SysFreeString ( m_ProviderName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ComProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDefaultHostingGroup ( 

	Enum_Hosting a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_HostingValue )
	{
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHost ) ;

		}
		break ;

		case e_Hosting_SharedNetworkServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedNetworkServiceHost ) ;
		}
		break ;

		case e_Hosting_SharedLocalServiceHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalServiceHost ) ;
		}
		break ;

		case e_Hosting_SharedUserHost:
		{
			a_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedUserHost ) ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHostingGroup ( 

	LPCWSTR a_Hosting , 
	size_t a_Prefix ,
	Enum_Hosting a_ExpectedHostingValue ,
	Enum_Hosting & a_HostingValue ,
	BSTR & a_HostingGroup 
)
{
	HRESULT t_Result = S_OK ;

	size_t t_Length = wcslen ( a_Hosting ) ;

	if ( t_Length > a_Prefix )
	{
		if ( a_Hosting [ a_Prefix ] == L':' ) 
		{
			if ( t_Length > a_Prefix + 1 )
			{
				a_HostingGroup = SysAllocString ( & a_Hosting [ a_Prefix + 1 ] ) ;
				if ( a_HostingGroup )
				{
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				a_HostingValue = a_ExpectedHostingValue ;
			}
			else
			{
				t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}
	else
	{
		t_Result = GetDefaultHostingGroup ( a_ExpectedHostingValue , a_HostingGroup ) ;

		a_HostingValue = a_ExpectedHostingValue ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define StateAction_Accept		1	// Add the char to the token
#define StateAction_Consume		2	// Consume the char without adding to token
#define StateAction_Pushback	4	// Place the char back in the source buffer for next token
#define StateAction_Not			8	// A match occurs if the char is NOT the one specified
#define StateAction_Linefeed	16	// Increase the source linecount
#define StateAction_Return		32	// Return the indicated token to caller
#define StateAction_Any			64	// wchar_t(0xFFFF) Any character
#define StateAction_Empty		128	// wchar_t(0xFFFE) When subrange is not specified

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry
{
	wchar_t m_LowerRange ;
	wchar_t m_UpperRange ;

	ULONG m_Token ;
	ULONG m_GotoState ;
	ULONG m_Action ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum LexicalStatus
{
	Success ,
	Syntax_Error ,
	Lexical_Error ,
	Failed ,
	Buffer_Too_Small ,
	ImpossibleState ,
	UnexpectedEof ,
	OutOfMemory 
} ;	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TOKEN_IDENTITY			1
#define TOKEN_LEFTPARENTHESIS	2
#define TOKEN_RIGHTPARENTHESIS	3
#define TOKEN_TRUE				4
#define TOKEN_FALSE				5
#define TOKEN_EOF				6
#define TOKEN_ERROR				7

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct StateTableEntry g_StateTable [] = {

	' ',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 0
	'\t',			65534 ,				0 ,							0 ,			StateAction_Consume		,		// 1
	'a',			'z',				0 ,							8 ,			StateAction_Accept		,		// 2
	'A',			'Z',				0 ,							8 ,			StateAction_Accept		,		// 3
	'(',			65534 ,				TOKEN_LEFTPARENTHESIS ,		0 ,			StateAction_Return		,		// 4
	')',			65534 ,				TOKEN_RIGHTPARENTHESIS ,	0 ,			StateAction_Return		,		// 5
	0,				65534 ,				TOKEN_EOF ,					0 ,			StateAction_Return		,		// 6
	65535,			65534 ,				TOKEN_ERROR ,				0 ,			StateAction_Return		,		// 7

	'a',			'z',				0	,						8 ,			StateAction_Accept		,		// 8
	'A',			'Z',				0	,						8 ,			StateAction_Accept		,		// 9
	65535,			65534 ,				TOKEN_IDENTITY ,			0 ,			StateAction_Pushback | StateAction_Return	// 10
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LexicalStatus LexicalAnalyser_NextToken ( 

	StateTableEntry *a_Dfa , 
	ULONG a_DfaSize ,
	const wchar_t *a_Stream , 
	ULONG a_Position , 
	ULONG &a_Token , 
	ULONG &a_NextPosition , 
	wchar_t *&a_TokenText
)
{
	LexicalStatus t_Status = Success ;

	a_Token = 0 ;
	a_TokenText = NULL ;
	a_NextPosition = a_Position ;

	ULONG t_State = 0 ;
    BOOL t_Read = TRUE ;
	BOOL t_EndOfFile = FALSE ;
    wchar_t t_Current = 0 ;
	ULONG CurrentLine = 0 ;
	wchar_t *t_TokenText = NULL ;
	ULONG t_TokenTextActualSize = 0 ;
	ULONG t_TokenTextBufferSize = 0 ;

    while ( 1 )
	{
		wchar_t t_First = a_Dfa [ t_State ].m_LowerRange ;
		wchar_t t_Last = a_Dfa [ t_State ].m_UpperRange ;
		ULONG t_GotoState = a_Dfa [ t_State ].m_GotoState ;
		ULONG t_ReturnToken = a_Dfa [ t_State ].m_Token ;
		ULONG t_Action = a_Dfa [ t_State ].m_Action ;

        if ( t_Read )
		{
			if ( t_EndOfFile ) 
			{
				t_Status = UnexpectedEof ;

				delete [] t_TokenText ;

				return t_Status ;
			}

            if ( a_NextPosition > wcslen ( a_Stream ) )
			{
				t_Current = 0 ;

				t_EndOfFile = TRUE ;
			}
			else
			{
				t_Current = a_Stream [ a_NextPosition ] ;
			}
		}

        BOOL t_Match = FALSE ;

        if ( t_First == 65535 )
		{
            t_Match = TRUE ;
		}
		else
        {
			if ( t_Last == 65534 )
			{
				if ( t_Current == t_First ) 
				{
					t_Match = TRUE ;
				}
	            else 
				{
					if ( ( t_Action & StateAction_Not ) && ( t_Current != t_First ) )
					{
                		t_Match = TRUE ;
					}
				}
			}
			else
			{
				if ( ( t_Action & StateAction_Not ) && ( ! ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) ) ) )
				{
					t_Match = TRUE ;
				}
				else 
				{
					if ( ( t_Current >= t_First ) && ( t_Current <= t_Last ) )
					{
						t_Match = TRUE ;
					}
				}
			}
        }

        t_Read = FALSE ;

        if ( t_Match )
		{
            if ( t_Action & StateAction_Accept )
			{
				if ( t_TokenText )
				{
					if ( t_TokenTextActualSize < t_TokenTextBufferSize - 1 )
					{
					}
					else
					{
						t_TokenTextBufferSize = t_TokenTextBufferSize + 32 ;
						wchar_t *t_TempTokenText = new wchar_t [ t_TokenTextBufferSize ] ;
						if ( t_TempTokenText )
						{
							CopyMemory ( t_TempTokenText , t_TokenText , ( t_TokenTextActualSize ) * sizeof ( wchar_t ) ) ;

							delete [] t_TokenText ;
							t_TokenText = t_TempTokenText ;
						}
						else
						{
							delete [] t_TokenText ;

							return OutOfMemory ;
						}
					}

					t_TokenText [ t_TokenTextActualSize ] = t_Current ;
					t_TokenText [ t_TokenTextActualSize + 1 ] = 0 ;

					t_TokenTextActualSize ++ ;
				}
				else
				{
					t_TokenTextActualSize = 1 ;
					t_TokenTextBufferSize = 32 ;

					t_TokenText = new wchar_t [ t_TokenTextBufferSize ] ;
					if ( t_TokenText )
					{
						t_TokenText [ 0 ] = t_Current ;
						t_TokenText [ 1 ] = 0 ;
					}
					else
					{
						return OutOfMemory ;
					}
				}

                t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Consume )
			{
               t_Read = TRUE ;
			}

            if ( t_Action & StateAction_Pushback )
			{
                t_Read = TRUE ;

                a_NextPosition = a_NextPosition - 1 ;
            }

            if ( t_Action & StateAction_Linefeed )
			{
                CurrentLine = CurrentLine + 1 ;
			}

			a_NextPosition = a_NextPosition + 1 ;

            if ( t_Action & StateAction_Return )
			{
                a_Token = t_ReturnToken ;
				a_TokenText = t_TokenText ;

				return t_Status ;
			}

            t_State = t_GotoState ;
        }
		else
		{
            t_State = t_State + 1 ;
		}
	}

	delete [] t_TokenText ;

    return ImpossibleState ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetDecoupledImpersonationRestriction ( 

	LPCWSTR a_Hosting , 
	BOOL &a_ImpersonationRestriction 
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_Decoupled ) != 0 )
	{
		if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_DecoupledColon , ( sizeof ( s_Strings_Wmi_DecoupledColon ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
		{
			const wchar_t *t_Scan = & a_Hosting [ ( sizeof ( s_Strings_Wmi_DecoupledColon ) - 1 ) / sizeof ( WCHAR ) ] ;

			ULONG t_Position = 0 ; 
			ULONG t_Token = 0 ;
			ULONG t_NextPosition = 0 ; 
			wchar_t *t_FoldText = NULL ;

			LexicalStatus t_Status = LexicalAnalyser_NextToken ( 

				g_StateTable ,
				sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
				t_Scan ,
				t_Position , 
				t_Token , 
				t_NextPosition , 
				t_FoldText
			) ;

			if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( _wcsicmp ( t_FoldText , L"FoldIdentity" ) == 0 ) )
			{
				wchar_t *t_IgnoreText = NULL ;

				t_Position = t_NextPosition ;

				t_Status = LexicalAnalyser_NextToken ( 

					g_StateTable ,
					sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
					t_Scan ,
					t_Position , 
					t_Token , 
					t_NextPosition , 
					t_IgnoreText
				) ;

				delete [] t_IgnoreText ;

				if ( ( t_Status == Success ) && ( t_Token == TOKEN_LEFTPARENTHESIS ) )
				{
					wchar_t *t_ValueText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_ValueText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( _wcsicmp ( t_ValueText , L"TRUE" ) == 0 ) )
					{
						a_ImpersonationRestriction = TRUE ;
					}
					else if ( ( t_Status == Success ) && ( t_Token == TOKEN_IDENTITY ) && ( _wcsicmp ( t_ValueText , L"FALSE" ) == 0 ) )
					{
						a_ImpersonationRestriction = FALSE ;
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_ValueText ;
				}
				else
				{
					t_Status = Syntax_Error ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_RIGHTPARENTHESIS ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}

				if ( t_Status == Success ) 
				{
					wchar_t *t_IgnoreText = NULL ;

					t_Position = t_NextPosition ;

					t_Status = LexicalAnalyser_NextToken ( 

						g_StateTable ,
						sizeof ( g_StateTable ) / sizeof ( StateTableEntry ) ,
						t_Scan ,
						t_Position , 
						t_Token , 
						t_NextPosition , 
						t_IgnoreText
					) ;

					if ( ( t_Status == Success ) && ( t_Token == TOKEN_EOF ) )
					{
					}
					else
					{
						t_Status = Syntax_Error ;
					}

					delete [] t_IgnoreText ;
				}
			}
			else
			{
				t_Status = Syntax_Error ;
			}

			delete [] t_FoldText ;

			if ( t_Status != Success ) 
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: GetHosting ( 

	LPCWSTR a_Hosting , 
	Enum_Hosting & a_HostingValue ,
	LPWSTR &a_HostingGroup ,
	BOOL & a_ImpersonationRestriction
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCore ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCore ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_WmiCoreOrSelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_WmiCoreOrSelfHost ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_SelfHost ) == 0 )
	{
		a_HostingValue = e_Hosting_SelfHost ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_ClientHost ) == 0 )
	{
		a_HostingValue = e_Hosting_ClientHost ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_Decoupled , ( sizeof ( s_Strings_Wmi_Decoupled ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		a_HostingValue = e_Hosting_Decoupled ;

		t_Result = GetDecoupledImpersonationRestriction ( 

			a_Hosting , 
			a_ImpersonationRestriction 
		) ;
	}
	else if ( _wcsicmp ( a_Hosting , s_Strings_Wmi_NonCom ) == 0 )
	{
		a_HostingValue = e_Hosting_NonCom ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedLocalSystemHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalSystemHostOrSelfHost , ( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalSystemHostOrSelfHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedLocalSystemHostOrSelfHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedNetworkServiceHost , ( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedNetworkServiceHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedNetworkServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedLocalServiceHost , ( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedLocalServiceHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedLocalServiceHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else if ( _wcsnicmp ( a_Hosting , s_Strings_Wmi_SharedUserHost , ( sizeof ( s_Strings_Wmi_SharedUserHost ) - 1 ) / sizeof ( WCHAR ) ) == 0 )
	{
		t_Result = GetHostingGroup ( 

			a_Hosting , 
			( sizeof ( s_Strings_Wmi_SharedUserHost ) - 1 ) / sizeof ( WCHAR ) ,
			e_Hosting_SharedUserHost ,
			a_HostingValue ,
			a_HostingGroup
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object ,
	LPCWSTR a_ProviderName 
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Name )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Name , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_ProviderName ) 
					{
						SysFreeString ( m_ProviderName ) ;
					}

					m_ProviderName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_ProviderName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Enabled )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Enabled , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Enabled = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Enabled = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Clsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Clsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_CLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = m_ClsidServer.Load ( (LPCWSTR) t_Variant.bstrVal , a_ProviderName ) ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_CLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ClientClsid  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ClientClsid , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & m_ClientCLSID ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ClientCLSID = CLSID_NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_DefaultMachineName )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_DefaultMachineName , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
					}

					m_DefaultMachineName = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_DefaultMachineName == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_DefaultMachineName )
					{
						SysFreeString ( m_DefaultMachineName ) ;
						m_DefaultMachineName = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnloadTimeout )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_UnloadTimeout , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
					}

					m_UnloadTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_UnloadTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_UnloadTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_UnloadTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_UnloadTimeout )
					{
						SysFreeString ( m_UnloadTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ImpersonationLevel )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ImpersonationLevel , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_ImpersonationLevel = e_Impersonate_None ;		
						}
						break ;

						case 1:
						{
							m_ImpersonationLevel = e_Impersonate ;
						}
						break ;

						default:
						{
							if ( m_Version > 1 )
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
							else
							{
								m_ImpersonationLevel = e_Impersonate_None ;	
							}
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ImpersonationLevel = e_Impersonate_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsSendStatus )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsSendStatus , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsSendStatus = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsSendStatus = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsShutdown )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsShutdown , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsShutdown = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsShutdown = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsQuotas )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsQuotas , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsQuotas = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsQuotas = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_OperationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_OperationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
					}

					m_OperationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_OperationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_OperationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_OperationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_OperationTimeout )
					{
						SysFreeString ( m_OperationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationTimeoutInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationTimeoutInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
					}

					m_InitializationTimeout = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_InitializationTimeout )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_InitializationTimeout ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_InitializationTimeoutMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_InitializationTimeout )
					{
						SysFreeString ( m_InitializationTimeout ) ;
						m_UnloadTimeout = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsThrottling )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SupportsThrottling , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsThrottling = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsThrottling = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ConcurrentIndependantRequests )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_ConcurrentIndependantRequests , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					m_ConcurrentIndependantRequests = t_Variant.lVal ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ConcurrentIndependantRequests = 0 ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializationReentrancy )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializationReentrancy , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Clsid ;		
						}
						break ;

						case 1:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_Namespace ;
						}
						break ;

						case 2:
						{
							m_InitializationReentrancy = e_InitializationReentrancy_None ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializationReentrancy = e_InitializationReentrancy_Namespace;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InitializeAsAdminFirst )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_InitializeAsAdminFirst , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_InitializeAsAdminFirst = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InitializeAsAdminFirst = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerUserInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerLocaleInitialization )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_PerLocaleInitialization , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerLocaleInitialization = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerLocaleInitialization = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Pure )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Pure , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_Pure = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Pure = TRUE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_Hosting )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_Hosting , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = GetHosting ( t_Variant.bstrVal , m_Hosting , m_HostingGroup , m_DecoupledImpersonationRestriction ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
#ifdef UNIQUE_HOST
						if ( m_HostingGroup )
						{
							SysFreeString ( m_HostingGroup ) ;
						}

						m_HostingGroup = SysAllocString ( GetProviderName () ) ;
						if ( m_HostingGroup == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
#else
#endif
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_Hosting = e_Hosting_SharedLocalSystemHostOrSelfHost ;

#ifdef UNIQUE_HOST
					m_HostingGroup = SysAllocString ( GetProviderName () ) ;
#else
					m_HostingGroup = SysAllocString ( s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost ) ;
#endif
					if ( m_HostingGroup == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( GetHosting () )
		{
			case e_Hosting_NonCom:
			case e_Hosting_Decoupled:
			{
			}
			break ;

			default:
			{
				if ( GetClsidServer ().GetProviderClsid () == NULL )
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}
			break ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SecurityDescriptor )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_Wmi_SecurityDescriptor , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					BOOL t_Status = SSDL_wrapper::ConvertStringSecurityDescriptorToSecurityDescriptor (

						t_Variant.bstrVal ,
						SDDL_REVISION_1 ,
						( PSECURITY_DESCRIPTOR * ) & m_SecurityDescriptor,
						NULL 
					) ;

					if ( t_Status )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SecurityDescriptor = NULL ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_ObjectPath = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_ObjectPath , 
		L"__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\""
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( m_Identity )
		{
			m_Identity->Release () ;
		}

		t_Result = m_Repository->GetObject ( 

			t_ObjectPath ,
			0 ,
			m_Context , 
			& m_Identity , 
			NULL 
		) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = QueryProperties ( 

				a_Mask ,
				m_Identity ,
				a_ProviderName 
			) ;
		}

		SysFreeString ( t_ObjectPath ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_Identity )
				{
					m_Identity->Release () ;
				}

				t_Result = m_Repository->GetObject ( 

					t_ObjectPath ,
					0 ,
					m_Context , 
					& m_Identity , 
					NULL 
				) ;
			
				if ( SUCCEEDED ( t_Result ) )
				{
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;
				
					LONG t_VarType = 0 ;
					LONG t_Flavour = 0 ;

					t_Result = m_Identity->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Variant.vt == VT_BSTR )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								m_Identity ,
								t_Variant.bstrVal
							) ;
						}

						VariantClear ( & t_Variant ) ;
					}
				}

			}

			SysFreeString ( t_ObjectPath ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
				}
			}
		}

		VariantClear ( & t_Variant ) ;

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ComProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1 :: CServerObject_InstanceProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InstanceProviderRegistrationV1::~CServerObject_InstanceProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_InstanceProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsGet )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsDelete )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsDelete = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsEnumeration )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsEnumeration = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsBatching )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsBatching = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsTransactions )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsTransactions = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_QuerySupportLevels  )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					if ( t_Count ) 
					{
						for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
						{
							BSTR t_Element ;
							if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
							{
								if ( _wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
								}
								else if ( _wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
								}
								else if ( _wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
								}
								else if ( _wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
								{
									m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}

								SysFreeString ( t_Element ) ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_QuerySupportLevels = e_QuerySupportLevels_None ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_InteractionType )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				switch ( t_Variant.lVal )
				{
					case 0:
					{
						m_InteractionType = e_InteractionType_Pull ;
					}
					break ;

					case 1:
					{
						m_InteractionType = e_InteractionType_Push ;
					}
					break ;

					case 2:
					{
						m_InteractionType = e_InteractionType_PushVerify ;
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
					break ;
				}
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_InteractionType = e_InteractionType_Pull ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery ( 

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InstanceProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1 :: CServerObject_ClassProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_SupportsDelete ( FALSE ) ,
	m_SupportsEnumeration ( FALSE ) ,
	m_SupportsBatching ( FALSE ) ,
	m_SupportsTransactions ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_ReSynchroniseOnNamespaceOpen ( FALSE ) ,
	m_PerUserSchema ( FALSE ) ,
	m_HasReferencedSet( FALSE ),
	m_CacheRefreshInterval ( NULL ) ,
	m_CacheRefreshIntervalMilliSeconds ( 0 ) ,
	m_QuerySupportLevels ( e_QuerySupportLevels_Unknown ) ,
	m_InteractionType ( e_InteractionType_Unknown ) ,
	m_ResultSetQueryTreeCount ( 0 ) ,
	m_UnSupportedQueryTreeCount ( 0 ) ,
	m_ReferencedSetQueryTreeCount ( 0 ) ,
	m_ResultSetQueryTree ( NULL ) ,
	m_UnSupportedQueryTree ( NULL ) ,
	m_ReferencedSetQueryTree ( NULL ) ,
	m_ProviderName ( NULL ) ,
	m_Version ( 1 ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ClassProviderRegistrationV1::~CServerObject_ClassProviderRegistrationV1 ()
{
	if ( m_ResultSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ResultSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ResultSetQueryTree [ t_Index ] )
			{
				delete m_ResultSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ResultSetQueryTree ;
	}

	if ( m_UnSupportedQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_UnSupportedQueryTreeCount ; t_Index ++ )
		{
			if ( m_UnSupportedQueryTree [ t_Index ] )
			{
				delete m_UnSupportedQueryTree [ t_Index ] ;
			}
		}

		delete [] m_UnSupportedQueryTree ;
	}

	if ( m_ReferencedSetQueryTree )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ReferencedSetQueryTreeCount ; t_Index ++ )
		{
			if ( m_ReferencedSetQueryTree [ t_Index ] )
			{
				delete m_ReferencedSetQueryTree [ t_Index ] ;
			}
		}

		delete [] m_ReferencedSetQueryTree ;
	}

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_ProviderName ) 
	{
		delete [] m_ProviderName ;
	}

	if ( m_CacheRefreshInterval )
	{
		SysFreeString ( m_CacheRefreshInterval ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ClassProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: ParseQuery ( 

	ULONG &a_Count ,
	WmiTreeNode **&a_Root , 
	SAFEARRAY *a_Array
)

{
	HRESULT t_Result = S_OK ;

	if ( SafeArrayGetDim ( a_Array ) == 1 )
	{
		LONG t_Dimension = 1 ; 

		LONG t_Lower ;
		SafeArrayGetLBound ( a_Array , t_Dimension , & t_Lower ) ;

		LONG t_Upper ;
		SafeArrayGetUBound ( a_Array , t_Dimension , & t_Upper ) ;

		LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

		a_Root = NULL ;
		a_Count = t_Count ;

		if ( t_Count )
		{
			a_Root = new WmiTreeNode * [ t_Count ] ;
			if ( a_Root ) 
			{
				ZeroMemory ( a_Root , sizeof ( WmiTreeNode * ) * t_Count ) ;

				for ( LONG t_ElementIndex = t_Lower ; SUCCEEDED ( t_Result ) && ( t_ElementIndex <= t_Upper ) ; t_ElementIndex ++ )
				{
					BSTR t_Element ;
					if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( a_Array , &t_ElementIndex , & t_Element ) ) )
					{
						QueryPreprocessor t_PreProcessor ;

						IWbemQuery *t_QueryAnalyser = NULL ;
						t_Result = CoCreateInstance (

							CLSID_WbemQuery ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemQuery ,
							( void ** ) & t_QueryAnalyser
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							switch ( t_PreProcessor.Query ( t_Element , t_QueryAnalyser ) )
							{
								case QueryPreprocessor :: State_True:
								{
									WmiTreeNode *t_Root = NULL ;

									switch ( t_PreProcessor.PreProcess ( m_Context , t_QueryAnalyser , t_Root ) )
									{
										case QueryPreprocessor :: State_True:
										{
											a_Root [ t_ElementIndex ] = t_Root ;
										}
										break ;

										case QueryPreprocessor :: State_Error:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break;

										default:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break ;
									}
								}
								break ;

								case QueryPreprocessor :: State_Error:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break;

								default:
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}
								break ;

							}

							t_QueryAnalyser->Release () ;
						}

						SysFreeString ( t_Element ) ;
					}
				}

				if ( FAILED ( t_Result ) ) 
				{
					for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
					{
						delete a_Root [ t_ElementIndex ] ;
					}

					delete [] a_Root ;
					a_Root = NULL ;
					a_Count = 0 ;

					if ( m_Version == 1 )
					{
						t_Result = S_OK ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_Version )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_TempResult = a_Object->Get ( s_Strings_Version , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				m_Version = t_Variant.lVal ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_Version = 1 ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsPut )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsPut = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsGet )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsGet = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsDelete )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsDelete , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsDelete = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsDelete = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsEnumeration )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_SupportsEnumeration , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsEnumeration = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsEnumeration = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsBatching )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_SupportsBatching , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsBatching = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsBatching = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_SupportsTransactions )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_SupportsTransactions , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_SupportsTransactions = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_SupportsTransactions = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_PerUserSchema )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_PerUserSchema , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_PerUserSchema = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_PerUserSchema = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReSynchroniseOnNamespaceOpen )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_ReSynchroniseOnNamespaceOpen , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BOOL )
				{
					m_ReSynchroniseOnNamespaceOpen = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_ReSynchroniseOnNamespaceOpen = FALSE ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_QuerySupportLevels  )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_QuerySupportLevels , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_BSTR | VT_ARRAY ) )
				{
					if ( SafeArrayGetDim ( t_Variant.parray ) == 1 )
					{
						LONG t_Dimension = 1 ; 

						LONG t_Lower ;
						SafeArrayGetLBound ( t_Variant.parray , t_Dimension , & t_Lower ) ;

						LONG t_Upper ;
						SafeArrayGetUBound ( t_Variant.parray , t_Dimension , & t_Upper ) ;

						LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

						if ( t_Count )
						{
							for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
							{
								BSTR t_Element ;
								if ( SUCCEEDED ( SafeArrayGetElement ( t_Variant.parray , &t_ElementIndex , & t_Element ) ) )
								{
									if ( _wcsicmp ( s_Strings_QuerySupportLevels_UnarySelect , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_UnarySelect ;
									}
									else if ( _wcsicmp ( s_Strings_QuerySupportLevels_References , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_References ;
									}
									else if ( _wcsicmp ( s_Strings_QuerySupportLevels_Associators , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_Associators ;
									}
									else if ( _wcsicmp ( s_Strings_QuerySupportLevels_V1ProviderDefined , t_Element ) == 0 )
									{
										m_QuerySupportLevels = m_QuerySupportLevels | e_QuerySupportLevels_V1ProviderDefined ;
									}
									else
									{
										t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
									}

									SysFreeString ( t_Element ) ;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_QuerySupportLevels = e_QuerySupportLevels_None ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_InteractionType )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_InteractionType , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == VT_I4 )
				{
					switch ( t_Variant.lVal )
					{
						case 0:
						{
							m_InteractionType = e_InteractionType_Pull ;
						}
						break ;

						case 1:
						{
							m_InteractionType = e_InteractionType_Push ;
						}
						break ;

						case 2:
						{
							m_InteractionType = e_InteractionType_PushVerify ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
						break ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					m_InteractionType = e_InteractionType_Pull ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ResultSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ResultSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ResultSetQueryTreeCount , m_ResultSetQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_UnSupportedQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_UnSupportedQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_UnSupportedQueryTreeCount , m_UnSupportedQueryTree , t_Variant.parray ) ;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_ReferencedSetQueries )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_TempResult = a_Object->Get ( s_Strings_ReferencedSetQueries , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				if ( t_Variant.vt == ( VT_ARRAY | VT_BSTR ) )
				{
					t_Result = ParseQuery ( m_ReferencedSetQueryTreeCount , m_ReferencedSetQueryTree , t_Variant.parray ) ;

					// Backwards compatibility.
					// W2K code, Query is not really parsed, as long as there is a
					// value, m_HasReferencedSet is TRUE.
					LONG t_Lower ;
					SafeArrayGetLBound ( t_Variant.parray , 1 , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_Variant.parray , 1 , & t_Upper ) ;

					LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

					m_HasReferencedSet = ( ( t_Upper - t_Lower ) + 1 ) > 0;
				}
				else if ( t_Variant.vt == VT_NULL )
				{
				}
				else
				{
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Mask & e_CacheRefreshInterval )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = a_Object->Get ( s_Strings_CacheRefreshInterval , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
					}

					m_CacheRefreshInterval = SysAllocString ( t_Variant.bstrVal ) ;
					if ( m_CacheRefreshInterval )
					{
						CWbemDateTime t_Interval ;
						t_Result = t_Interval.PutValue ( m_CacheRefreshInterval ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT_BOOL t_Bool = VARIANT_FALSE ;
							t_Result = t_Interval.GetIsInterval ( & t_Bool ) ;
							if ( t_Bool == VARIANT_TRUE )
							{
								LONG t_MicroSeconds = 0 ;
								LONG t_Seconds = 0 ;
								LONG t_Minutes = 0 ;
								LONG t_Hours = 0 ;
								LONG t_Days = 0 ;

								t_Interval.GetMicroseconds ( & t_MicroSeconds ) ;
								t_Interval.GetSeconds ( & t_Seconds ) ;
								t_Interval.GetMinutes ( & t_Minutes ) ;
								t_Interval.GetHours ( & t_Hours ) ;
								t_Interval.GetDay ( & t_Days ) ;

								m_CacheRefreshIntervalMilliSeconds = ( t_Days * 24 * 60 * 60 * 1000 ) +
															  ( t_Hours * 60 * 60 * 1000 ) +
															  ( t_Minutes * 60 * 1000 ) +
															  ( t_Seconds * 1000 ) +
															  ( t_MicroSeconds / 1000 ) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else if ( t_Variant.vt == VT_NULL )
				{
					if ( m_CacheRefreshInterval )
					{
						SysFreeString ( m_CacheRefreshInterval ) ;
						m_CacheRefreshInterval = NULL ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( ( m_InteractionType == e_InteractionType_Pull ) && ( ( m_SupportsEnumeration == FALSE ) || ( m_SupportsGet == FALSE ) ) )
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			m_ProviderName = new wchar_t [ wcslen ( a_ProviderName ) + 1 ] ;
			if ( m_ProviderName ) 
			{
				wcscpy ( m_ProviderName , a_ProviderName ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemPathKeyList *t_Keys = NULL ;

						t_Result = a_Provider->GetKeyList (

							& t_Keys 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ULONG t_ProviderNameLength = 0 ;
							ULONG t_Type = 0 ;

							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								NULL ,
								NULL ,
								& t_ProviderNameLength ,
								m_ProviderName ,
								& t_Type
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								m_ProviderName = new wchar_t [ ( t_ProviderNameLength / sizeof ( wchar_t ) ) + 1 ] ;
								if ( m_ProviderName ) 
								{
									t_Result = t_Keys->GetKey (

										0 ,
										0 ,
										NULL ,
										NULL ,
										& t_ProviderNameLength ,
										m_ProviderName ,
										& t_Type
									) ;
								}
							}

							t_Keys->Release () ;
						}
					}
					
					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ClassProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath * a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( FAILED ( t_Result ) )
	{
		m_Result = t_Result ;
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1 :: CServerObject_MethodProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsMethods ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_MethodProviderRegistrationV1::~CServerObject_MethodProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_MethodProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_SupportsMethods = TRUE ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_MethodProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1 :: CServerObject_DynamicPropertyProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SupportsPut ( FALSE ) ,
	m_SupportsGet ( FALSE ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderRegistrationV1::~CServerObject_DynamicPropertyProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DynamicPropertyProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	if ( a_Mask & e_SupportsPut )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsPut , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsPut = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsPut = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( a_Mask & e_SupportsGet )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		HRESULT t_Result = a_Object->Get ( s_Strings_SupportsGet , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL )
			{
				m_SupportsGet = ( t_Variant.boolVal == VARIANT_TRUE ) ? TRUE : FALSE ;
			}
			else if ( t_Variant.vt == VT_NULL )
			{
				m_SupportsGet = FALSE ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1 :: CServerObject_EventProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventProviderRegistrationV1::~CServerObject_EventProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1 :: CServerObject_EventConsumerProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Supported ( FALSE ) ,
	m_Result ( S_OK )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_EventConsumerProviderRegistrationV1::~CServerObject_EventConsumerProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_EventConsumerProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryProperties ( 

	Enum_PropertyMask a_Mask ,
	IWbemClassObject *a_Object 
)
{
	HRESULT t_Result = S_OK ;

	m_Supported = TRUE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query  
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_EventConsumerProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1 :: CServerObject_ProviderRegistrationV1 () : 

	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Result ( S_OK ) ,
	m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrationV1::~CServerObject_ProviderRegistrationV1 ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_ProviderRegistrationV1 :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: SetContext (

	IWbemContext *a_Context ,
	IWbemPath *a_Namespace ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

	m_Context = a_Context ;
	m_Namespace = a_Namespace ;
	m_Repository = a_Repository ;

	if ( m_Context ) 
	{
		m_Context->AddRef () ;
	}

	if ( m_Namespace ) 
	{
		m_Namespace->AddRef () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->AddRef () ;
	}

	t_Result = m_ComRegistration.SetContext ( 

		a_Context ,
		a_Namespace ,
		a_Repository
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepositoryUsingQuery ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	BSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

	BSTR t_Language = SysAllocString ( ProviderSubSystem_Common_Globals :: s_Wql ) ;
	if ( t_Language ) 
	{
		t_Result = m_Repository->ExecQuery ( 
			
			t_Language ,
			a_Query ,
			WBEM_FLAG_FORWARD_ONLY ,
			m_Context , 
			& t_ClassObjectEnum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_ClassObject = NULL ;
			ULONG t_ObjectCount = 0 ;

			t_ClassObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_ClassObject->Get ( s_Strings_Class , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Variant.vt == VT_BSTR )
					{
						if ( _wcsicmp ( s_Strings_InstanceProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_InstanceProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_ClassProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_ClassProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_MethodProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_MethodProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_PropertyProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_PropertyProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_EventProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
						else if ( _wcsicmp ( s_Strings_EventConsumerProviderRegistration , t_Variant.bstrVal ) == 0 )
						{
							t_Result = m_EventConsumerProviderRegistration.QueryProperties ( 

								a_Mask ,
								t_ClassObject 
							) ;
						}
					}
				}

				VariantClear ( & t_Variant ) ;

				t_ClassObject->Release () ;
			}

			t_ClassObjectEnum->Release () ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}

		SysFreeString ( t_Language ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_ProviderName  
)
{
	BSTR t_Query = NULL ;

	HRESULT t_Result = WmiHelper :: ConcatenateStrings ( 

		3 , 
		& t_Query , 
		L"references of {__Win32Provider.Name=\"" ,
		a_ProviderName ,
		L"\"}"
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepositoryUsingQuery (

			a_Mask ,
			a_Scope,
			t_Query
		) ;

		SysFreeString ( t_Query ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: QueryRepository ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	BSTR t_ObjectPath = NULL ;
	ULONG t_ObjectPathLength = 0 ;

	HRESULT t_Result = a_Provider->GetText ( 

		WBEMPATH_GET_RELATIVE_ONLY ,
		& t_ObjectPathLength ,
		NULL
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_ObjectPath = SysAllocStringLen ( NULL , t_ObjectPathLength ) ;
		if ( t_ObjectPath )
		{
			t_Result = a_Provider->GetText ( 

				WBEMPATH_GET_RELATIVE_ONLY ,
				& t_ObjectPathLength ,
				t_ObjectPath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{		
				BSTR t_Query = NULL ;

				t_Result = WmiHelper :: ConcatenateStrings ( 

					3 , 
					& t_Query , 
					L"references of {" ,
					t_ObjectPath ,
					L"}"
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepositoryUsingQuery (

						a_Mask ,
						a_Scope,
						t_Query
					) ;

					SysFreeString ( t_Query ) ;
				}
			}

			SysFreeString ( t_ObjectPath ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemClassObject *a_Class
)
{
	HRESULT t_Result = S_OK ;

	IWbemQualifierSet *t_QualifierObject = NULL ;
	t_Result = a_Class->GetQualifierSet ( & t_QualifierObject ) ;
	
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;

		t_Result = t_QualifierObject->Get (
			
			ProviderSubSystem_Common_Globals :: s_Provider ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Result = m_ComRegistration.QueryRepository ( 

					a_Mask ,
					a_Scope , 
					t_Variant.bstrVal
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = QueryRepository ( 
	
						a_Mask ,
						a_Scope , 
						t_Variant.bstrVal
					) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		t_QualifierObject->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrationV1 :: Load ( 

	Enum_PropertyMask a_Mask ,
	IWbemPath *a_Scope,
	IWbemPath *a_Provider
)
{
	HRESULT t_Result = S_OK ;

	t_Result = m_ComRegistration.QueryRepository ( 

		a_Mask ,
		a_Scope , 
		a_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryRepository ( 

			a_Mask ,
			a_Scope , 
			a_Provider
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: ObjectProvider ()
{
	BOOL t_Supported =	GetClassProviderRegistration ().Supported () ||
						GetInstanceProviderRegistration ().Supported () ||
						GetMethodProviderRegistration ().Supported () || 
						GetPropertyProviderRegistration ().Supported () ;

	return t_Supported ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CServerObject_ProviderRegistrationV1 :: EventProvider ()
{
	BOOL t_Supported =	GetEventConsumerProviderRegistration ().Supported () ||
						GetEventProviderRegistration ().Supported () ;

	return t_Supported ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provregdecoupled.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#undef POLARITY

#include <typeinfo.h>
#include <stdio.h>
#include <Aclapi.h>

#include <wbemint.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include <HelperFuncs.h>
#include "CGlobals.h"
#include "ProvRegDeCoupled.h"
#include "DateTime.h"
#include "OS.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetSecurity ( HKEY a_Key , DWORD a_Access ) 
{
	if (!OS::secureOS_)
		return ERROR_SUCCESS;

	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	DWORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = 0x1F01FF;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	DWORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = 0x1F01FF;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	PSID t_PowerUsers_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_PowerUsers_ACE = NULL ;
	DWORD t_PowerUsers_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_POWER_USERS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_PowerUsers_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_PowerUsers_Sid );
		t_PowerUsers_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_PowerUsers_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_PowerUsers_ACESize ] ;
		if ( t_PowerUsers_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_PowerUsers_ACE->SidStart, t_PowerUsers_Sid ) ;
			t_PowerUsers_ACE->Mask = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE ;
			t_PowerUsers_ACE->Header.AceType = 0 ;
			t_PowerUsers_ACE->Header.AceFlags = 3 ;
			t_PowerUsers_ACE->Header.AceSize = t_PowerUsers_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

	PSID t_Everyone_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
	DWORD t_Everyone_ACESize = 0 ;
	
	t_BoolResult = AllocateAndInitializeSid (

		& t_WorldAuthoritySid ,
		1 ,
		SECURITY_WORLD_RID ,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Everyone_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
		t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
		if ( t_Everyone_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
			t_Everyone_ACE->Mask = a_Access ;
			t_Everyone_ACE->Header.AceType = 0 ;
			t_Everyone_ACE->Header.AceFlags = 3 ;
			t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_System_ACESize + t_Everyone_ACESize ;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					LONG t_SetStatus = RegSetKeySecurity (

					  a_Key ,
					  t_SecurityInfo ,
					  & t_SecurityDescriptor
					) ;

					if ( t_SetStatus != ERROR_SUCCESS )
					{
						DWORD t_LastError = GetLastError () ;

						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;	
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if ( t_PowerUsers_ACE )
	{
		delete [] ( ( BYTE * ) t_PowerUsers_ACE ) ;
	}

	if ( t_Everyone_ACE )
	{
		delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}
	
	if ( t_PowerUsers_Sid )
	{
		FreeSid ( t_PowerUsers_Sid ) ;
	}

	if ( t_Everyone_Sid )
	{
		FreeSid ( t_Everyone_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_User = L"User" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Locale = L"Locale" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Scope = L"Scope" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_Provider = L"Provider" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;
LPCWSTR CServerObject_DecoupledClientRegistration_Element :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;

LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledClientRegistration :: s_Strings_Reg_HomeClient = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Null = NULL ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_Home = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_HomeServer = L"Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Server" ;

LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_CreationTime = L"CreationTime" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_ProcessIdentifier = L"ProcessIdentifier" ;
LPCWSTR CServerObject_DecoupledServerRegistration :: s_Strings_Reg_MarshaledProxy = L"MarshaledProxy" ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: CServerObject_DecoupledClientRegistration_Element ()

	:	m_Provider ( NULL ) ,
		m_Clsid ( NULL ) ,
		m_CreationTime ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Scope ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 ) ,
		m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element :: ~CServerObject_DecoupledClientRegistration_Element ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledClientRegistration_Element :: Clear () 
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration_Element &CServerObject_DecoupledClientRegistration_Element :: operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key )
{
	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
		m_Provider = NULL ;
	}

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
		m_User = NULL ;
	}

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
		m_Locale = NULL ;
	}

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
		m_Scope = NULL ;
	}

	if ( m_Clsid ) 
	{
		SysFreeString ( m_Clsid ) ;
		m_Clsid = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}

	if ( a_Key.m_Provider )
	{
		m_Provider = SysAllocString ( a_Key.m_Provider ) ;
	}

	if ( a_Key.m_CreationTime )
	{
		m_CreationTime = SysAllocString ( a_Key.m_CreationTime ) ;
	}

	if ( a_Key.m_User )
	{
		m_User = SysAllocString ( a_Key.m_User ) ;
	}

	if ( a_Key.m_Locale )
	{
		m_Locale = SysAllocString ( a_Key.m_Locale ) ;
	}

	if ( a_Key.m_Scope )
	{
		m_Scope = SysAllocString ( a_Key.m_Scope ) ;
	}

	if ( a_Key.m_Clsid ) 
	{
		m_Clsid = SysAllocString ( a_Key.m_Clsid ) ;
	}

	m_MarshaledProxyLength = a_Key.m_MarshaledProxyLength ;

	if ( a_Key.m_MarshaledProxy )
	{
		m_MarshaledProxy = new BYTE [ a_Key.m_MarshaledProxyLength ] ;
		if ( m_MarshaledProxy )
		{
			CopyMemory ( m_MarshaledProxy , a_Key.m_MarshaledProxy , a_Key.m_MarshaledProxyLength ) ;
		}
	}

	return *this ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetProvider ( BSTR a_Provider )
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		SysFreeString ( m_Provider ) ;
	}

	m_Provider = SysAllocString ( a_Provider ) ;
	if ( m_Provider == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetLocale ( BSTR a_Locale )
{
	HRESULT t_Result = S_OK ;

	if ( m_Locale )
	{
		SysFreeString ( m_Locale ) ;
	}

	m_Locale = SysAllocString ( a_Locale ) ;
	if ( m_Locale == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetUser ( BSTR a_User )
{
	HRESULT t_Result = S_OK ;

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
	}

	m_User = SysAllocString ( a_User ) ;
	if ( m_User == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetScope ( BSTR a_Scope )
{
	HRESULT t_Result = S_OK ;

	if ( m_Scope )
	{
		SysFreeString ( m_Scope ) ;
	}

	m_Scope = SysAllocString ( a_Scope ) ;
	if ( m_Scope == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetClsid ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	m_Clsid = SysAllocString ( a_Clsid ) ;
	if ( m_Clsid == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration_Element :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = OS::GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Load ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			3, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			L"\\" ,
			a_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClientClsid_Key ;

			LONG t_RegResult = OS::RegOpenKeyEx (

				HKEY_LOCAL_MACHINE ,
				t_HomeClientClsid_String ,
				0 ,
				KEY_READ ,
				& t_HomeClientClsid_Key 
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
					if ( t_Result == ERROR_FILE_NOT_FOUND )
					{	
						t_Result = S_OK ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Validate () ;
				}

				RegCloseKey ( t_HomeClientClsid_Key ) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( FAILED ( t_Result ) )
	{
		Delete ( a_Clsid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Save ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	t_Result = SetClsid ( a_Clsid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LPWSTR t_HomeClientClsid_String = NULL ;
		t_Result = WmiHelper :: ConcatenateStrings ( 

			2, 
			& t_HomeClientClsid_String , 
			s_Strings_Reg_HomeClient ,
			m_Clsid
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HKEY t_HomeClient_Key ;
			DWORD t_Disposition = 0 ;

			LONG t_RegResult = OS::RegCreateKeyEx (

				HKEY_LOCAL_MACHINE ,
				s_Strings_Reg_HomeClient ,
				0 ,
				NULL ,
				REG_OPTION_VOLATILE ,
				KEY_WRITE ,
				NULL ,
				& t_HomeClient_Key ,
				& t_Disposition                     
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				HKEY t_HomeClientClsid_Key ;

				LONG t_RegResult = OS::RegCreateKeyEx (

					t_HomeClient_Key ,
					m_Clsid ,
					0 ,
					NULL ,
					REG_OPTION_VOLATILE ,
					KEY_WRITE ,
					NULL ,
					& t_HomeClientClsid_Key ,
					& t_Disposition                     
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					t_Result = SetSecurity ( t_HomeClientClsid_Key , KEY_READ ) ;

					if ( t_Disposition == REG_CREATED_NEW_KEY )
					{
						t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Provider , m_Provider ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Scope , m_Scope ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_Locale )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_Locale , m_Locale ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_User )
							{
								t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeClientClsid_Key , s_Strings_Reg_User , m_User ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeClientClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeClientClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
						}
					}
					else
					{
						t_Result = WBEM_E_ALREADY_EXISTS ;
					}

					RegCloseKey ( t_HomeClientClsid_Key ) ;
				}

				RegCloseKey ( t_HomeClient_Key ) ;
			}

			SysFreeString ( t_HomeClientClsid_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration_Element :: Delete ( BSTR a_Clsid )
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_HomeClientClsid_String = NULL ;
	t_Result = WmiHelper :: ConcatenateStrings ( 

		3, 
		& t_HomeClientClsid_String , 
		s_Strings_Reg_HomeClient ,
		L"\\" ,
		a_Clsid
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		HKEY t_HomeClientClsid_Key ;

		LONG t_RegResult = OS::RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String ,
			0 ,
			KEY_READ ,
			& t_HomeClientClsid_Key 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			BYTE *t_MarshaledProxy = NULL ;
			ULONG t_MarshaledProxyLength = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

				t_HomeClientClsid_Key , 
				s_Strings_Reg_MarshaledProxy , 
				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

					t_MarshaledProxy , 
					t_MarshaledProxyLength
				) ;

				if ( t_MarshaledProxy )
				{
					delete [] t_MarshaledProxy ;
				}
			}

			RegCloseKey ( t_HomeClientClsid_Key ) ;
		}

		t_RegResult = OS::RegDeleteKey (

			HKEY_LOCAL_MACHINE ,
			t_HomeClientClsid_String
		) ;

		if ( t_RegResult != ERROR_SUCCESS )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		SysFreeString ( t_HomeClientClsid_String ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: CServerObject_DecoupledClientRegistration (

	WmiAllocator &a_Allocator 

) : m_Queue ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledClientRegistration :: ~CServerObject_DecoupledClientRegistration ()
{
	m_Queue.UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledClientRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Count = 0 ;
		DWORD t_Size = 16 ;

		BSTR *t_Elements = ( BSTR * ) malloc ( sizeof ( BSTR ) * t_Size ) ;
		if ( t_Elements )
		{
			FILETIME t_FileTime ;
			DWORD t_Class ;
			BOOL t_Continue = TRUE ;

			while ( SUCCEEDED ( t_Result ) && t_Continue )
			{
				DWORD t_NameLength = 256 ;
				wchar_t t_Name [ 256 ] ;

				LONG t_RegResult = OS::RegEnumKeyEx (

					t_HomeClient_Key ,
					t_Count ,
					t_Name ,
					& t_NameLength ,            // size of subkey buffer
					NULL ,
					NULL ,
					NULL ,
					& t_FileTime
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					if ( t_Count >= t_Size )
					{
						BSTR *t_NewElements = ( BSTR * ) realloc ( t_Elements , sizeof ( BSTR ) * ( t_Size + 16 ) ) ;
						if ( t_NewElements )
						{
							t_Elements = t_NewElements ;
							t_Size = t_Size + 16 ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Elements [ t_Count ] = SysAllocString ( t_Name ) ;
						if ( t_Elements [ t_Count ]  )
						{
                                                        t_Count ++ ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
				else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
				{
					t_Continue = FALSE ;
				}
				else
				{
					t_Continue = FALSE ;
	// Generate message
				}
			}

			if ( t_Elements )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_Elements [ t_Index ] )
					{
						CServerObject_DecoupledClientRegistration_Element t_Element ;
						HRESULT t_TempResult = t_Element.Load ( t_Elements [ t_Index ] ) ;
						if ( SUCCEEDED ( t_TempResult ) )
						{
							m_Queue.EnQueue ( t_Element ) ;
						}
						else
						{
			// Generate message
						}

						SysFreeString ( t_Elements [ t_Index ] ) ;
					}
				}

				free ( t_Elements ) ;
			}
		}
		else
		{
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledClientRegistration :: Load (

	BSTR a_Provider ,
	BSTR a_User ,
	BSTR a_Locale ,
	BSTR a_Scope
)
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeClient_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeClient ,
		0 ,
		KEY_READ ,
		& t_HomeClient_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_Index = 0 ;
		FILETIME t_FileTime ;
		DWORD t_Class ;
		BOOL t_Continue = TRUE ;

		while ( SUCCEEDED ( t_Result ) && t_Continue )
		{
			DWORD t_NameLength = 256 ;
			wchar_t t_Name [ 256 ] ;

			LONG t_RegResult = OS::RegEnumKeyEx (

				t_HomeClient_Key ,
				t_Index ,
				t_Name ,
				& t_NameLength ,            // size of subkey buffer
				NULL ,
				NULL ,
				NULL ,
				& t_FileTime
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				CServerObject_DecoupledClientRegistration_Element t_Element ;
				HRESULT t_TempResult = t_Element.Load ( t_Name ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					BOOL t_Compare = ( _wcsicmp ( a_Provider , t_Element.GetProvider () ) == 0 ) ;
					t_Compare = t_Compare && ( _wcsicmp ( a_Scope , t_Element.GetScope () ) == 0 ) ;

					if ( t_Compare )
					{
						if ( ( a_Locale == NULL ) && ( t_Element.GetLocale () == NULL ) )
						{
						}
						else
						{
							if ( ( a_Locale ) && ( t_Element.GetLocale () ) )
							{
								t_Compare = ( _wcsicmp ( a_Locale , t_Element.GetLocale () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						if ( ( a_User == NULL ) && ( t_Element.GetUser () == NULL ) )
						{
						}
						else
						{
							if ( ( a_User ) && ( t_Element.GetUser () ) )
							{
								t_Compare = ( _wcsicmp ( a_User , t_Element.GetUser () ) == 0 ) ;
							}
							else
							{
								t_Compare = FALSE ;
							}
						}
					}

					if ( t_Compare )
					{
						m_Queue.EnQueue ( t_Element ) ;
					}
				}
				else
				{
// Generate message
				}
			}
			else if ( t_RegResult == ERROR_NO_MORE_ITEMS )
			{
				t_Continue = FALSE ;
			}
			else
			{
				t_Continue = FALSE ;
// Generate message
			}

			t_Index ++ ;
		}

		RegCloseKey ( t_HomeClient_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator )

	:	m_CreationTime ( NULL ) ,
		m_MarshaledProxy ( NULL ) ,
		m_MarshaledProxyLength ( 0 ) ,
		m_Result ( S_OK ) ,
		m_ProcessIdentifier ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DecoupledServerRegistration :: ~CServerObject_DecoupledServerRegistration ()
{
	Clear () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_DecoupledServerRegistration :: Clear () 
{
	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
		m_CreationTime = NULL ;
	}

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CServerObject_DecoupledServerRegistration :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Validate ()
{
	CWbemDateTime t_CreationTime ;

	HRESULT t_Result = t_CreationTime.PutValue ( m_CreationTime ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		HANDLE t_Handle = OpenProcess (

			PROCESS_QUERY_INFORMATION ,
			FALSE ,
			m_ProcessIdentifier
		) ;

		if ( t_Handle ) 
		{
			FILETIME t_CreationFileTime ;
			FILETIME t_ExitFileTime ;
			FILETIME t_KernelFileTime ;
			FILETIME t_UserFileTime ;

			BOOL t_Status = OS::GetProcessTimes (

			  t_Handle ,
			  & t_CreationFileTime,
			  & t_ExitFileTime,
			  & t_KernelFileTime,
			  & t_UserFileTime
			) ;

			if ( t_Status ) 
			{
				CWbemDateTime t_Time ;
				t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

				if ( t_CreationTime.Preceeds ( t_Time ) )
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			CloseHandle ( t_Handle ) ;
		}
	}

 	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Load ()
{
	HRESULT t_Result = S_OK ;

	Clear () ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		if (OS::secureOS_)
		{
		SECURITY_INFORMATION t_SecurityInformation = OWNER_SECURITY_INFORMATION ;
		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;
		DWORD t_Length = 0 ;

		t_RegResult = RegGetKeySecurity (

			t_HomeServerClsid_Key ,
			t_SecurityInformation ,
			t_SecurityDescriptor ,
			& t_Length 
		) ;

		if ( t_RegResult == ERROR_INSUFFICIENT_BUFFER )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_Length ] ;
			if ( t_SecurityDescriptor )
			{
				t_RegResult = RegGetKeySecurity (

					t_HomeServerClsid_Key ,
					t_SecurityInformation ,
					t_SecurityDescriptor ,
					& t_Length 
				) ;

				if ( t_RegResult == ERROR_SUCCESS )
				{
					SID *t_Sid = NULL ;
					BOOL t_Defaulted = FALSE ;

					BOOL t_Status = GetSecurityDescriptorOwner (

					  t_SecurityDescriptor ,
					  ( PSID * ) & t_Sid ,
					  & t_Defaulted
					) ;

					if ( t_Status )
					{
						SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

						PSID t_Administrator_Sid = NULL ;

						BOOL t_BoolResult = AllocateAndInitializeSid (

							& t_NtAuthoritySid ,
							2 ,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_ADMINS,
							0,
							0,
							0,
							0,
							0,
							0,
							& t_Administrator_Sid
						);

						if ( t_BoolResult )
						{
							if ( EqualSid ( t_Administrator_Sid , t_Sid ) == FALSE )
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}

							if ( t_Administrator_Sid )
							{
								FreeSid ( t_Administrator_Sid ) ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				delete [] ( BYTE * ) t_SecurityDescriptor ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
		}
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_String ( t_HomeServerClsid_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray ( t_HomeServerClsid_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Load_DWORD ( t_HomeServerClsid_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Validate () ;
		}

		RegCloseKey ( t_HomeServerClsid_Key ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetCreationTime ( BSTR a_CreationTime )
{
	HRESULT t_Result = S_OK ;

	if ( m_CreationTime )
	{
		SysFreeString ( m_CreationTime ) ;
	}

	m_CreationTime = SysAllocString ( a_CreationTime ) ;
	if ( m_CreationTime == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetProcessIdentifier ( DWORD a_ProcessIdentifier )
{
	m_ProcessIdentifier = a_ProcessIdentifier ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: SetMarshaledProxy ( BYTE *a_MarshaledProxy , ULONG a_MarshaledProxyLength )
{
	HRESULT t_Result = S_OK ;

	if ( m_MarshaledProxy )
	{
		delete [] m_MarshaledProxy ;
	}

	m_MarshaledProxyLength = a_MarshaledProxyLength ;
	m_MarshaledProxy = new BYTE [ a_MarshaledProxyLength ] ;
	if ( m_MarshaledProxy )
	{
		CopyMemory ( m_MarshaledProxy , a_MarshaledProxy , a_MarshaledProxyLength ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Save ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServer_Key ;
	DWORD t_Disposition = 0 ;

	LONG t_RegResult = OS::RegCreateKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		NULL ,
		REG_OPTION_VOLATILE ,
		KEY_WRITE ,
		NULL ,
		& t_HomeServer_Key ,
		& t_Disposition                     
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		HRESULT t_TempResult = SetSecurity ( t_HomeServer_Key , KEY_READ ) ;

		t_Result = ProviderSubSystem_Common_Globals :: Save_String ( t_HomeServer_Key , s_Strings_Reg_CreationTime , m_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_ByteArray ( t_HomeServer_Key , s_Strings_Reg_MarshaledProxy , m_MarshaledProxy , m_MarshaledProxyLength ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Save_DWORD ( t_HomeServer_Key , s_Strings_Reg_ProcessIdentifier , m_ProcessIdentifier ) ;
		}

		RegCloseKey ( t_HomeServer_Key ) ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DecoupledServerRegistration :: Delete ()
{
	HRESULT t_Result = S_OK ;

	HKEY t_HomeServerClsid_Key ;

	LONG t_RegResult = OS::RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer ,
		0 ,
		KEY_READ ,
		& t_HomeServerClsid_Key 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		BYTE *t_MarshaledProxy = NULL ;
		ULONG t_MarshaledProxyLength = 0 ;

		t_Result = ProviderSubSystem_Common_Globals :: Load_ByteArray (

			t_HomeServerClsid_Key , 
			s_Strings_Reg_MarshaledProxy , 
			t_MarshaledProxy , 
			t_MarshaledProxyLength
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: ReleaseRegistration ( 

				t_MarshaledProxy , 
				t_MarshaledProxyLength
			) ;

			if ( t_MarshaledProxy )
			{
				delete [] t_MarshaledProxy ;
			}
		}

		RegCloseKey ( t_HomeServerClsid_Key ) ;
	}

	t_RegResult = OS::RegDeleteKey (

		HKEY_LOCAL_MACHINE ,
		s_Strings_Reg_HomeServer
	) ;

	if ( t_RegResult != ERROR_SUCCESS )
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provregistrar.cpp ===
/*++
    
    Copyright (C) 1996-2001 Microsoft Corporation
    
    Module Name:
    
    	ProvFact.cpp
    
    Abstract:
    
    
    History:
    
    --*/
    
    #include <PreComp.h>
    #include <wbemint.h>
    #include "Globals.h"
#include "CGlobals.h"
    #include "Guids.h"
    
 #include "DateTime.h"
 #include "ProvRegDecoupled.h"
 #include "ProvInterceptor.h"
 #include "ProvRegistrar.h"
    
  #include <os.h>
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar_Base :: CServerObject_ProviderRegistrar_Base (
    
    	WmiAllocator &a_Allocator 
    
    ) : 
    	m_Allocator ( a_Allocator ) ,
    	m_Clsid ( NULL ) ,
    	m_Provider ( NULL ) ,
    	m_User ( NULL ) ,
    	m_Locale ( NULL ) ,
    	m_Scope ( NULL ) ,
    	m_Registration ( NULL ) ,
    	m_Registered ( FALSE ),
    	m_CriticalSection(NOTHROW_LOCK)
    {
    	ZeroMemory ( & m_Identity , sizeof ( m_Identity ) ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar_Base::~CServerObject_ProviderRegistrar_Base ()
    {
    	if ( m_Clsid )
    	{
    		SysFreeString ( m_Clsid ) ;
    	}
    
    	if ( m_User )
    	{
    		SysFreeString ( m_User ) ;
    	}
    
    	if ( m_Locale ) 
    	{
    		SysFreeString ( m_Locale ) ;
    	}
    
    	if ( m_Scope ) 
    	{
    		SysFreeString ( m_Scope ) ;
    	}
    
    	if ( m_Registration )
    	{
    		SysFreeString ( m_Registration ) ;
    	}
    
    	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: Initialize ()
    {
    	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
    	if ( t_StatusCode == e_StatusCode_Success )
    	{
    		return S_OK ;
    	}
    	else
    	{
    		return WBEM_E_OUT_OF_MEMORY ;
    	}
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: SaveToRegistry (
    
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Registration ,
    	LPCWSTR a_Scope ,
    	IUnknown *a_Unknown ,
    	BYTE *a_MarshaledProxy ,
    	DWORD a_MarshaledProxyLength
    )
    {
    	HRESULT t_Result = S_OK ;
    
    	CServerObject_DecoupledClientRegistration_Element t_Element ;
    
    	BSTR t_CreationTime = NULL ;
    
    	FILETIME t_CreationFileTime ;
    	FILETIME t_ExitFileTime ;
    	FILETIME t_KernelFileTime ;
    	FILETIME t_UserFileTime ;
    
  	BOOL t_Status = OS::GetProcessTimes (
 
    
    		  GetCurrentProcess (),
    		  & t_CreationFileTime,
    		  & t_ExitFileTime,
    		  & t_KernelFileTime,
    		  & t_UserFileTime
    	);
    
    	if ( t_Status ) 
    	{
    		CWbemDateTime t_Time ;
    		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
    
    		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
    		if ( SUCCEEDED ( t_Result ) ) 
    		{
    			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				if ( a_Locale ) 
    				{
    					t_Result = t_Element.SetLocale ( ( BSTR ) a_Locale ) ;
    				}
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				if ( a_User ) 
    				{
    					t_Result = t_Element.SetUser ( ( BSTR ) a_User ) ;
    				}
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetProvider ( ( BSTR ) a_Registration ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetScope ( ( BSTR ) a_Scope ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) ) 
    			{
    				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
    			}
    
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				t_Result = t_Element.Save ( m_Clsid ) ;
    			}
    
    			SysFreeString ( t_CreationTime ) ;
    		}
    		else
    		{
    			t_Result = WBEM_E_UNEXPECTED ;
    		}
    	}
    	else
    	{
    		t_Result = WBEM_E_UNEXPECTED ;
    	}
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: DirectRegister (
    
    	GUID &a_Identity ,
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Registration ,
    	LPCWSTR a_Scope ,
    	IUnknown *a_Unknown ,
    	BYTE *a_MarshaledProxy ,
    	DWORD a_MarshaledProxyLength
    )
    {
    	HRESULT t_Result = S_OK ;
    
    	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;
    
    	BSTR t_CreationTime = NULL ;
    
    	FILETIME t_CreationFileTime ;
    	FILETIME t_ExitFileTime ;
    	FILETIME t_KernelFileTime ;
    	FILETIME t_UserFileTime ;
    
  	BOOL t_Status = OS::GetProcessTimes (
 
    
    		  GetCurrentProcess (),
    		  & t_CreationFileTime,
    		  & t_ExitFileTime,
    		  & t_KernelFileTime,
    		  & t_UserFileTime
    	);
    
    	if ( t_Status ) 
    	{
    		CWbemDateTime t_Time ;
    		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
    
    		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
    		if ( SUCCEEDED ( t_Result ) ) 
    		{
    			t_Result = t_Element.Load () ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				BSTR t_ServerCreationTime = t_Element.GetCreationTime () ;
    				DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
    				BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
    				DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;
    
    				IUnknown *t_Unknown = NULL ;
 				HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
 
    				if ( SUCCEEDED ( t_TempResult ) )
    				{
    					_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
    						
    					t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
    					if ( SUCCEEDED ( t_Result ) )
    					{
    						BOOL t_Impersonating = FALSE ;
    						IUnknown *t_OldContext = NULL ;
    						IServerSecurity *t_OldSecurity = NULL ;
    
 						t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
 
    						if ( SUCCEEDED ( t_Result ) )
    						{
    							BOOL t_Revert = FALSE ;
    							IUnknown *t_Proxy = NULL ;
    
 							t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
 
    							if ( t_Result == WBEM_E_NOT_FOUND )
    							{
    								try
    								{
    									t_Result = t_Registrar->Register ( 
    
    										0 ,
    										a_Context ,
    										a_User ,
    										a_Locale ,
    										a_Scope ,
    										a_Registration ,
    										GetCurrentProcessId () ,
    										a_Unknown ,
    										a_Identity 
    									) ;
    								}
    								catch ( ... )
    								{
    									t_Result = WBEM_E_PROVIDER_FAILURE ;
    								}
    							}
    							else
    							{
    								if ( SUCCEEDED ( t_Result ) )
    								{
    									_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;
    
    									// Set cloaking on the proxy
    									// =========================
    
  									DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
    
  									t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (
    
    										t_RegistrarProxy ,
    										RPC_C_AUTHN_LEVEL_DEFAULT , 
    										t_ImpersonationLevel
    									) ;
    
    									if ( SUCCEEDED ( t_Result ) )
    									{
  										t_Result = OS::CoImpersonateClient () ;
    										if ( SUCCEEDED ( t_Result ) )
    										{
    											try
    											{
    												t_Result = t_RegistrarProxy->Register ( 
    
    													0 ,
    													a_Context ,
    													a_User ,
    													a_Locale ,
    													a_Scope ,
    													a_Registration ,
    													GetCurrentProcessId () ,
    													a_Unknown ,
    													a_Identity 
    												) ;
    											}
    											catch ( ... )
    											{
    												t_Result = WBEM_E_PROVIDER_FAILURE ;
    											}
    
    											CoRevertToSelf () ;
    										}
    										else
    										{
    											t_Result = WBEM_E_ACCESS_DENIED ;
    										}
    									}	
    
  									DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
    								}
    							}
    
  							DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
    						}
    
    						t_Registrar->Release () ;
    					}
    
    					t_Unknown->Release () ;
    				}
    			}
    			else
    			{
    				t_Result = S_OK ;
    			}
    
    			SysFreeString ( t_CreationTime ) ;
    		}
    		else
    		{
    			t_Result = WBEM_E_UNEXPECTED ;
    		}
    	}
    	else
    	{
    		t_Result = WBEM_E_UNEXPECTED ;
    	}
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: DirectUnRegister (
    
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Registration ,
    	LPCWSTR a_Scope ,
    	GUID &a_Identity  
    )
    {
    	HRESULT t_Result = S_OK ;
    
    	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;
    
    	FILETIME t_CreationFileTime ;
    	FILETIME t_ExitFileTime ;
    	FILETIME t_KernelFileTime ;
    	FILETIME t_UserFileTime ;
    
  	BOOL t_Status = OS::GetProcessTimes (
    
    		  GetCurrentProcess (),
    		  & t_CreationFileTime,
    		  & t_ExitFileTime,
    		  & t_KernelFileTime,
    		  & t_UserFileTime
    	);
    
    	if ( t_Status ) 
    	{
    		t_Result = t_Element.Load () ;
    		if ( SUCCEEDED ( t_Result ) )
    		{
  			BSTR t_ServerCreationTime = t_Element.GetCreationTime () ;
    			DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
    			BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
    			DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;
    
    			IUnknown *t_Unknown = NULL ;
  			t_Result = DecoupledProviderSubSystem_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
    					
    				t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
    				if ( SUCCEEDED ( t_Result ) )
    				{
    					BOOL t_Impersonating = FALSE ;
    					IUnknown *t_OldContext = NULL ;
    					IServerSecurity *t_OldSecurity = NULL ;
    
  					t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
    					if ( SUCCEEDED ( t_Result ) )
    					{
    						BOOL t_Revert = FALSE ;
    						IUnknown *t_Proxy = NULL ;
    
  						t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
    						if ( t_Result == WBEM_E_NOT_FOUND )
    						{
    							try
    							{
    								t_Result = t_Registrar->UnRegister ( 
    
    									0 ,
    									a_Context ,
    									a_User ,
    									a_Locale ,
    									a_Scope ,
    									a_Registration ,
    									a_Identity 
    								) ;
    							}
    							catch ( ... )
    							{
    								t_Result = WBEM_E_PROVIDER_FAILURE ;
    							}
    						}
    						else
    						{
    							if ( SUCCEEDED ( t_Result ) )
    							{
    								_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;
    
    								// Set cloaking on the proxy
    								// =========================
    
  								DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;
    
  								t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (
    
    									t_RegistrarProxy ,
    									RPC_C_AUTHN_LEVEL_CONNECT , 
    									t_ImpersonationLevel
    								) ;
    
    								if ( SUCCEEDED ( t_Result ) )
    								{
  									t_Result = OS::CoImpersonateClient () ;
    									if ( SUCCEEDED ( t_Result ) )
    									{
    										try
    										{
    											t_Result = t_RegistrarProxy->UnRegister ( 
    
    												0 ,
    												a_Context ,
    												a_User ,
    												a_Locale ,
    												a_Scope ,
    												a_Registration ,
    												a_Identity 
    											) ;
    										}
    										catch ( ... )
    										{
    											t_Result = WBEM_E_PROVIDER_FAILURE ;
    										}
    
    										CoRevertToSelf () ;
    									}
    									else
    									{
    										t_Result = WBEM_E_ACCESS_DENIED ;
    									}
    								}	
    
  								HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
    							}
    						}
    
  						DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
    					}
    
    					t_Registrar->Release () ;
    				}
    
    				t_Unknown->Release () ;
    			}
    		}
    	}
    	else
    	{
    		t_Result = WBEM_E_UNEXPECTED ;
  	}
  
  	return t_Result ;
  }
  
  /******************************************************************************
   *
   *	Name:
   *
   *	
   *  Description:
   *
   *	
   *****************************************************************************/
  
  HRESULT CServerObject_ProviderRegistrar_Base :: CreateInterceptor (
  
  	IWbemContext *a_Context ,
  	IUnknown *a_Unknown ,
  	BYTE *&a_MarshaledProxy ,
  	DWORD& a_MarshaledProxyLength ,
  	IUnknown *&a_MarshaledUnknown
  )
  {
  	IWbemLocator *t_Locator = NULL ;
  	IWbemServices *t_Service = NULL ;
  	CServerObject_ProviderRegistrationV1 *t_Registration = NULL ;
  
  	HRESULT t_Result = CoCreateInstance (
  
  		CLSID_WbemLocator ,
  		NULL ,
  		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
  		IID_IUnknown ,
  		( void ** )  & t_Locator
  	);
  
  	if ( SUCCEEDED ( t_Result ) )
  	{
  		t_Result = t_Locator->ConnectServer (
  
  			m_Scope ,
  			NULL ,
  			NULL,
  			NULL ,
  			0 ,
  			NULL,
  			NULL,
  			& t_Service
  		) ;
  
  		t_Locator->Release () ;
  	}
 
 	if ( SUCCEEDED ( t_Result ) )
 	{
  		t_Registration = new CServerObject_ProviderRegistrationV1 ;
  		if ( t_Registration )
  		{
  			t_Registration->AddRef () ;
  
  			IWbemPath *t_NamespacePath = NULL ;
  
  			t_Result = CoCreateInstance (
  
  				CLSID_WbemDefPath ,
  				NULL ,
  				CLSCTX_INPROC_SERVER ,
  				IID_IWbemPath ,
  				( void ** )  & t_NamespacePath
  			) ;
  
  			if ( SUCCEEDED ( t_Result ) )
  			{
  				t_Result = t_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , m_Scope ) ;
  			}
  
  			if ( SUCCEEDED( t_Result ) ) 
  			{
  				t_Result = t_Registration->SetContext ( 
  
  					a_Context ,
  					t_NamespacePath , 
  					t_Service
  				) ;
  				
  				if ( SUCCEEDED ( t_Result ) )
  				{
  					t_Result = t_Registration->Load ( 
  
  						e_All ,
  						NULL , 
  						m_Registration
  					) ;
  
  					if ( t_Result == WBEM_E_NOT_FOUND )
  					{
  						t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
  					}
  				}
  			}
  		}
  		else
  		{
  			t_Result = WBEM_E_OUT_OF_MEMORY ;
  		}
  	}
  
  	if ( SUCCEEDED ( t_Result ) )
  	{
  		CInterceptor_DecoupledClient *t_Provider = new CInterceptor_DecoupledClient ( 
  
  			m_Allocator ,
 			a_Unknown , 
  			t_Service ,
  			*t_Registration
  		) ;
  		
  		if ( t_Provider )
  		{
  			t_Provider->AddRef () ;
  
  			t_Result = t_Provider->ProviderInitialize () ;
  			if ( SUCCEEDED ( t_Result ) ) 
  			{
  				t_Result = t_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & a_MarshaledUnknown ) ;
  				if ( SUCCEEDED ( t_Result ) )
  				{
  					t_Result = DecoupledProviderSubSystem_Globals :: MarshalRegistration ( 
  
  						a_MarshaledUnknown ,
  						a_MarshaledProxy ,
  						a_MarshaledProxyLength
  					) ;
  
  					if ( FAILED ( t_Result ) )
  					{
  						a_MarshaledUnknown->Release () ;
  						a_MarshaledUnknown = NULL ;
  					}
  				}
  			}
  
  			if ( SUCCEEDED ( t_Result ) )
  			{
  				m_Provider = t_Provider ;
  			}
  			else
  			{
  				t_Provider->Release () ;
  			}
  		}
  	}
  
  	if ( t_Registration )
  	{
  		t_Registration->Release () ;
  	}
  
  	if ( t_Service )
  	{
  		t_Service->Release () ;
    	}
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: Register (
    
    	long a_Flags ,
    	IWbemContext *a_Context ,
    	LPCWSTR a_User ,
    	LPCWSTR a_Locale ,
    	LPCWSTR a_Scope ,
    	LPCWSTR a_Registration ,
    	IUnknown *a_Unknown
    )
    {
    	HRESULT t_Result = S_OK ;
    
 	if ( a_Scope == NULL || a_Registration == NULL || a_Unknown == NULL )
    	{
    		return WBEM_E_INVALID_PARAMETER ;
    	}
    		
    	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;
    
    	try
    	{
    		if ( m_Registered == FALSE )
    		{
    			t_Result = CoCreateGuid ( & m_Identity ) ;
    			if ( SUCCEEDED ( t_Result ) )
    			{
    				BSTR t_Clsid = NULL ;
    
    				t_Result = StringFromCLSID (
    
    				  m_Identity ,
    				  & t_Clsid
    				) ;
    
    				if ( SUCCEEDED ( t_Result ) )
    				{
    					if ( m_Clsid ) 
    					{
    						SysFreeString ( m_Clsid ) ;
    						m_Clsid = NULL ;
    					}
    
    					if ( m_User )
    					{
    						SysFreeString ( m_User ) ;
    						m_User = NULL ;
    					}
    
    					if ( m_Locale ) 
    					{
    						SysFreeString ( m_Locale ) ;
    						m_Locale = NULL ;
    					}
    
    					if ( m_Scope ) 
    					{
    						SysFreeString ( m_Scope ) ;
    						m_Scope = NULL ;
    					}
    
    					if ( m_Registration )
    					{
    						SysFreeString ( m_Registration ) ;
    						m_Registration = NULL ;
    					}
    
    					m_Clsid = SysAllocString ( t_Clsid ) ;
    					if ( m_Clsid == NULL )
    					{
    						t_Result = WBEM_E_OUT_OF_MEMORY ;
    					}
    
    					if ( a_User )
    					{
    						m_User = SysAllocString ( a_User ) ;
    						if ( m_User == NULL )
    						{
    							t_Result = WBEM_E_OUT_OF_MEMORY ;
    						}
    					}
    
    					if ( m_Locale )
    					{
    						m_Locale = SysAllocString ( a_Locale ) ;
    						if ( m_Locale == NULL )
    						{
    							t_Result = WBEM_E_OUT_OF_MEMORY ;
    						}
    					}
    
    					m_Scope = SysAllocString ( a_Scope ) ;
    					if ( m_Scope == NULL )
    					{
    						t_Result = WBEM_E_OUT_OF_MEMORY ;
    					}
    
    					m_Registration = SysAllocString ( a_Registration ) ;
    					if ( m_Registration == NULL )
    					{
    						t_Result = WBEM_E_OUT_OF_MEMORY ;
    					}
    
    					if ( SUCCEEDED ( t_Result ) )
    					{
    						BYTE *t_MarshaledProxy = NULL ;
    						DWORD t_MarshaledProxyLength = 0 ;
  						IUnknown *t_MarshaledUnknown = NULL ;
  
  						t_Result = CreateInterceptor (
  
  							a_Context ,
    							a_Unknown ,
    							t_MarshaledProxy ,
  							t_MarshaledProxyLength ,
  							t_MarshaledUnknown
    						) ;
    
    						if ( SUCCEEDED ( t_Result ) ) 
    						{
    							t_Result = DirectRegister (
    
    								m_Identity ,
    								a_Flags ,
    								a_Context ,
    								a_User ,
    								a_Locale ,
    								a_Registration ,
    								a_Scope ,
  								t_MarshaledUnknown ,
    								t_MarshaledProxy ,
    								t_MarshaledProxyLength
    							) ;
    						}
    
 
 							t_Result = SaveToRegistry ( 
    
    								a_Flags ,
    								a_Context ,
    								a_User ,
    								a_Locale ,
    								a_Registration ,
    								a_Scope ,
	  								a_Unknown ,
    								t_MarshaledProxy ,
    								t_MarshaledProxyLength
    							) ;
    
    							delete [] t_MarshaledProxy ;
  
/*  						if ( SUCCEEDED ( t_Result ) )
  						{
  							m_Provider = a_Unknown ;
  							if ( m_Provider )
  							{
  								m_Provider->AddRef () ;
  							}
*/  						if ( t_MarshaledUnknown )
  						{
  							t_MarshaledUnknown->Release () ;
    						}
    					}
    
    					CoTaskMemFree ( t_Clsid ) ;
    				}
    				else
    				{
    					t_Result = WBEM_E_OUT_OF_MEMORY ;
    				}
    			}
    			else
    			{
    				t_Result = WBEM_E_UNEXPECTED ;
    			}
    		}
    		else
    		{
    			t_Result = WBEM_E_PROVIDER_ALREADY_REGISTERED ;
    		}
    	}
    	catch ( ... )
    	{
    		t_Result = WBEM_E_PROVIDER_FAILURE ;
    	}
    
    	if ( SUCCEEDED ( t_Result ) )
    	{
    		m_Registered = TRUE ;
    	}
    
    	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    HRESULT CServerObject_ProviderRegistrar_Base :: UnRegister ()
    {
    	HRESULT t_Result = S_OK ;
    
    	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;
    
    	try
    	{
    		if ( m_Registered ) 
    		{
    			CServerObject_DecoupledClientRegistration_Element t_Element ;
  			t_Result = t_Element.Delete ( m_Clsid ) ;
    
    			HRESULT t_TempResult = DirectUnRegister ( 
    
    				0 ,
    				NULL ,
    				m_User ,
    				m_Locale ,
    				m_Registration ,
    				m_Scope ,
    				m_Identity
    			) ;
    
    			if ( m_Provider )
    			{
    				m_Provider->Release () ;
    				m_Provider = NULL ;
    			}
    
    			m_Registered = FALSE ;
    		}
    		else
    		{
    			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
    		}
    	}
    	catch ( ... )
    	{
    		t_Result = WBEM_E_PROVIDER_FAILURE ;
    	}
    
    	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
    
    	return t_Result ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar :: CServerObject_ProviderRegistrar (
    
    	WmiAllocator &a_Allocator 
    
    ) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
    	m_ReferenceCount ( 0 )
    {
    	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
    	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    CServerObject_ProviderRegistrar::~CServerObject_ProviderRegistrar ()
    {
    	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
    	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    STDMETHODIMP CServerObject_ProviderRegistrar::QueryInterface (
    
    	REFIID a_Riid , 
    	LPVOID FAR *a_Void 
    ) 
    {
    	*a_Void = NULL ;
    
    	if ( a_Riid == IID_IUnknown )
    	{
    		*a_Void = ( LPVOID ) this ;
    	}
    	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
    	{
    		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) this ;		
    	}	
    
    	if ( *a_Void )
    	{
    		( ( LPUNKNOWN ) *a_Void )->AddRef () ;
    
    		return ResultFromScode ( S_OK ) ;
    	}
    	else
    	{
    		return ResultFromScode ( E_NOINTERFACE ) ;
    	}
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    STDMETHODIMP_( ULONG ) CServerObject_ProviderRegistrar :: AddRef ()
    {
    	return InterlockedIncrement ( & m_ReferenceCount ) ;
    }
    
    /******************************************************************************
     *
     *	Name:
     *
     *	
     *  Description:
     *
     *	
     *****************************************************************************/
    
    STDMETHODIMP_(ULONG) CServerObject_ProviderRegistrar :: Release ()
    {
    	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
    	if ( t_ReferenceCount == 0 )
    	{
    		delete this ;
    	}
    
    	return t_ReferenceCount ;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\ssdlhelper.cpp ===
#include "precomp.h"
#include <sddl.h>
#include "ssdlhelper.h"

SSDL_wrapper ssdl_wrapper;

SSDL_wrapper::function_type 
SSDL_wrapper::GetFunction(void)
    {
  function_type return_function = DummyConvertStringSecurityDescriptorToSecurityDescriptor;
  if (lock_.acquire())
  {
    return_function = current_function_;
    if (current_function_==0)
    {
      HMODULE advapi = LoadLibrary(L"advapi32.dll");
      if (advapi)
	{
	current_function_ = (function_type)GetProcAddress(advapi,"ConvertStringSecurityDescriptorToSecurityDescriptorW");
	FreeLibrary(advapi);
	}

      if (current_function_==0)
	current_function_ = DummyConvertStringSecurityDescriptorToSecurityDescriptor;
      
      return_function = current_function_;
    }
    lock_.release();
  };
  return return_function;
};

BOOL SSDL_wrapper::ConvertStringSecurityDescriptorToSecurityDescriptor(
  LPCTSTR StringSecurityDescriptor,          // security descriptor string
  DWORD StringSDRevision,                    // revision level
  PSECURITY_DESCRIPTOR *SecurityDescriptor,  // SD
  PULONG SecurityDescriptorSize              // SD size
)
{
  return (ssdl_wrapper.GetFunction())(StringSecurityDescriptor, StringSDRevision, SecurityDescriptor, SecurityDescriptorSize);
};


BOOL SSDL_wrapper::DummyConvertStringSecurityDescriptorToSecurityDescriptor(
  LPCTSTR StringSecurityDescriptor,          // security descriptor string
  DWORD StringSDRevision,                    // revision level
  PSECURITY_DESCRIPTOR *SecurityDescriptor,  // SD
  PULONG SecurityDescriptorSize              // SD size
)
{
if (SecurityDescriptor==0)
  return ERROR_INVALID_PARAMETER;
if (SecurityDescriptorSize)
  *SecurityDescriptorSize = 0;
*SecurityDescriptor = 0;
return TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvObSk.h"
#include "ProvWsv.h"
#include "Exclusion.h"
#include "ProvCache.h"

#include "arrtempl.h"
#include "os.h"

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_FACILITY_MASK (0x0FFF0000)
#define HRESULT_FACILITY_FUNC(X) ((X&HRESULT_FACILITY_MASK)>>16)
#define HRESULT_SEVERITY_MASK (0xC0000000)
#define HRESULT_SEVERITY_FUNC(X) ((X&HRESULT_SEVERITY_MASK)>>30)

CInterceptor_IWbemSyncProvider :: CInterceptor_IWbemSyncProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ClientSideProvider , 
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Exclusion *a_Exclusion ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemHiPerfProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Exclusion ( a_Exclusion ) ,
	m_ProxyContainer ( a_Allocator , 11 , MAX_PROXIES ) ,
	m_ReferenceCount ( 0 ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_Begin ( 0 ) ,
	m_ProviderOperation_Rollback ( 0 ) ,
	m_ProviderOperation_Commit ( 0 ) ,
	m_ProviderOperation_QueryState ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_ProviderOperation_OpenAsync ( 0 ) ,
	m_ProviderOperation_AddAsync ( 0 ) ,
	m_ProviderOperation_RemoveAsync ( 0 ) ,
	m_ProviderOperation_RefreshObjectAsync ( 0 ) ,
	m_ProviderOperation_RenameObjectAsync ( 0 ) ,
	m_ProviderOperation_DeleteObjectAsync ( 0 ) ,
	m_ProviderOperation_PutObjectAsync ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	    t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemHiPerfProvider , ( void ** ) & m_Provider_IWbemHiPerfProvider ) ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}

	if ( m_Exclusion )
	{
		m_Exclusion->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncProvider :: ~CInterceptor_IWbemSyncProvider ()
{

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemHiPerfProvider )
	{
		m_Provider_IWbemHiPerfProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	if ( m_Exclusion )
	{
		m_Exclusion->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemSyncProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP 
CInterceptor_IWbemSyncProvider::QueryInterface (REFIID iid , LPVOID FAR *iplpv) 
{
  if (iplpv == NULL)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    {
    *iplpv = static_cast<IWbemServices*>(this);
    }
  else if (iid == IID_IWbemServices && (m_Provider_IWbemServices || m_Provider_IWbemHiPerfProvider) )
    {
    *iplpv = static_cast<IWbemServices *>(this);
    }
  else if (iid == IID_IWbemPropertyProvider && m_Provider_IWbemPropertyProvider)
    {
      *iplpv = static_cast<IWbemPropertyProvider *>(this);
    }
  else if (iid == IID_IWbemHiPerfProvider && m_Provider_IWbemHiPerfProvider)
    {
      *iplpv = static_cast<IWbemHiPerfProvider *>(this);
    }
  else if (iid == IID_IWbemEventProvider && m_Provider_IWbemEventProvider)
    {
      *iplpv = static_cast<IWbemEventProvider *>(this);
    }
  else if (iid == IID_IWbemEventProviderQuerySink && m_Provider_IWbemEventProviderQuerySink)
    {
      *iplpv = static_cast<IWbemEventProviderQuerySink *>(this);
    }
  else if (iid == IID_IWbemEventProviderSecurity && m_Provider_IWbemEventProviderSecurity)
    {
      *iplpv = static_cast<IWbemEventProviderSecurity *>(this);
    }
  else if (iid == IID_IWbemProviderIdentity && m_Provider_IWbemProviderIdentity)
    {
      *iplpv = static_cast<IWbemProviderIdentity *>(this);
    }
  else
    {
    *iplpv = 0;
    return E_NOINTERFACE;
    };

  reinterpret_cast<IUnknown*>(*iplpv)->AddRef();
  return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CInterceptor_IWbemSyncProvider :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

 HRESULT CInterceptor_IWbemSyncProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		if ( t_ObjectPath ) 
		{
			CInterceptor_IWbemSyncObjectSink_GetObjectAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

				a_Flags ,
				t_ObjectPath ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				m_Exclusion ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_GetObjectAsync () ;

						try	
						{
							t_Result = a_Service->GetObjectAsync (

 								t_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

						Increment_ProviderOperation_GetObjectAsync () ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							try
							{
								t_Result = a_Service->GetObjectAsync (

 									t_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_HiPerfGetObjectAsync (

	IWbemHiPerfProvider *a_HighPerformanceProvider ,
 	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
  HRESULT t_Result = WBEM_E_PROVIDER_FAILURE;

#if 0 //Dan
    IWbemClassObject *t_Instance = NULL ;

#if 0
    t_Result = m_CoreStub->CreateRefreshableObjectTemplate (a_ObjectPath, a_Flags, &t_Instance);
#else
	// Parse the path
	// ==============

	IWbemPath*	pPathParser = NULL;
	WCHAR*	pwszClassName = NULL;
	HRESULT t_Result = CoCreateInstance( CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, IID_IWbemPath, (void**) &pPathParser );

	if ( SUCCEEDED( t_Result ) )
	{
		t_Result = pPathParser->SetText( WBEMPATH_CREATE_ACCEPT_ALL, a_ObjectPath );

		if ( SUCCEEDED( t_Result ) )
		{
			ULONG	uLength = 0;

			// Get the length of the name
			t_Result = pPathParser->GetClassName( &uLength, NULL );

			if ( SUCCEEDED( t_Result ) )
			{
				// Allocate memory and get it for real
				uLength++;
				pwszClassName = new WCHAR[uLength];

				if ( NULL != pwszClassName )
				{
					t_Result = pPathParser->GetClassName( &uLength, pwszClassName );
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY;
				}

			}	// IF Buffer too small

		}	// IF SetText

	}	// IF CoCreateInstance
	
	// Cleanup the parser and any allocated memory
	CReleaseMe	rmPP( pPathParser );
	CVectorDeleteMe<WCHAR>	vdm( pwszClassName );

	if ( FAILED( t_Result ) )
	{
		return t_Result;
	}

	// Get the class
	// =============

	IWbemClassObject* pClass = NULL;

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( pwszClassName );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

	// Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag
	t_Result = m_CoreStub->GetObject( bstrClass, 0L, NULL, &pClass, NULL);
	CReleaseMe	rmClass( pClass );

	if(FAILED(t_Result))
	{
		return WBEM_E_INVALID_CLASS;
	}

	_IWmiObject*	pWmiClass = NULL;
	t_Result = pClass->QueryInterface( IID__IWmiObject, (void**) &pWmiClass );
	CReleaseMe		rmObj( pWmiClass );

	// Get a Keyed instance and continue
	if ( SUCCEEDED( t_Result ) )
	{
		_IWmiObject*	pTempInst = NULL;

		t_Result = pWmiClass->SpawnKeyedInstance( 0L, a_ObjectPath, &pTempInst );
		CReleaseMe	rmTempInst( pTempInst );

		if ( SUCCEEDED( t_Result ) )
		{
			t_Result = pTempInst->QueryInterface( IID_IWbemClassObject, (void**) &t_Instance );
		}
	}
	
	CReleaseMe	rmInst( t_Instance );

#endif

    if ( SUCCEEDED ( t_Result ) )
    {
		try
		{
			t_Result = a_HighPerformanceProvider->GetObjects (

				m_CoreStub , 
				1 ,
				( IWbemObjectAccess ** ) & t_Instance , 
				0 ,
				a_Context
			) ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;
		}

		CoRevertToSelf () ;

        if ( SUCCEEDED ( t_Result ) && t_Instance )
        {
            a_Sink->Indicate ( 1 , & t_Instance ) ;
        }
        else
		{
			if ( 
				SUCCEEDED ( t_Result ) ||
				t_Result == WBEM_E_PROVIDER_NOT_CAPABLE ||
				t_Result == WBEM_E_METHOD_NOT_IMPLEMENTED ||
				t_Result == E_NOTIMPL ||
				t_Result == WBEM_E_NOT_SUPPORTED
			)
			{

				IWbemRefresher *t_Refresher = NULL ;

				try
				{
					t_Result = a_HighPerformanceProvider->CreateRefresher (
		
						m_CoreStub , 
						0 , 
						& t_Refresher
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemObjectAccess *t_Object = NULL ;
	                long t_Id = 0 ;

					try
					{
						t_Result = a_HighPerformanceProvider->CreateRefreshableObject (

							m_CoreStub , 
							( IWbemObjectAccess * ) t_Instance ,
							t_Refresher , 
							0, 
							a_Context , 
							& t_Object, 
							& t_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;

					if ( SUCCEEDED ( t_Result ) )
					{
						try
						{
							t_Result = t_Refresher->Refresh ( 0 ) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;

						if ( SUCCEEDED( t_Result ) )
						{
							a_Sink->Indicate ( 1, ( IWbemClassObject ** ) & t_Object );
						}

						t_Object->Release () ;
					}

					t_Refresher->Release () ;
				}
			}
		}
	}
#endif
    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_GetObjectAsync ( 

						FALSE ,
						a_ObjectPath ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_GetObjectAsync ( 

								TRUE ,
								a_ObjectPath ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_HiPerfGetObjectAsync (

				m_Provider_IWbemHiPerfProvider ,
 				a_ObjectPath ,
				a_Flags ,
				a_Context ,
				a_Sink
			) ;

			// Send back the final status
			a_Sink->SetStatus( WBEM_STATUS_COMPLETE, t_Result, NULL, NULL );
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CInterceptor_IWbemSyncObjectSink_PutClassAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_PutClassAsync (

			a_Flags ,
			a_Object ,
			this ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			m_Exclusion ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Sink ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				UnLock () ;

				if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
				{
					a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
				}

				if ( m_Exclusion ) 
				{
					if ( t_Dependant ) 
					{
						m_Exclusion->GetExclusion ().EnterWrite () ;
					}
					else
					{
						m_Exclusion->GetExclusion ().EnterRead () ;
					}
				}

				if ( a_IsProxy )
				{
					t_Result = OS::CoImpersonateClient () ;
				}
				else
				{
					t_Result = S_OK ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					Increment_ProviderOperation_PutClassAsync () ;

					try
					{
						t_Result = a_Service->PutClassAsync (

 							a_Object ,
							a_Flags ,
							t_ContextCopy ,
							t_Sink 
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
				{
					a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_PutClassAsync ( 

						FALSE ,
						a_Object ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_PutClassAsync ( 

								TRUE ,
								a_Object ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			CInterceptor_IWbemSyncObjectSink_DeleteClassAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

				a_Flags ,
				t_Class ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				m_Exclusion ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteClassAsync () ;

						try
						{
							t_Result = a_Service->DeleteClassAsync (

 								t_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									t_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_Class ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_DeleteClassAsync ( 

						FALSE ,
						a_Class ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_DeleteClassAsync ( 

								TRUE ,
								a_Class ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
		if ( t_SuperClass ) 
		{
			CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

				a_Flags ,
				t_SuperClass ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				m_Exclusion ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						
						Increment_ProviderOperation_CreateClassEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateClassEnumAsync (

 								t_SuperClass ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{

							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									t_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_SuperClass ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_CreateClassEnumAsync ( 

						FALSE ,
						a_SuperClass ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_CreateClassEnumAsync ( 

								TRUE ,
								a_SuperClass ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CInterceptor_IWbemSyncObjectSink_PutInstanceAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

			a_Flags ,
			a_Instance ,
			this ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			m_Exclusion ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Sink ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				UnLock () ;

				if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
				{
					a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
				}

				if ( m_Exclusion ) 
				{
					if ( t_Dependant ) 
					{
						m_Exclusion->GetExclusion ().EnterWrite () ;
					}
					else
					{
						m_Exclusion->GetExclusion ().EnterRead () ;
					}
				}

				if ( a_IsProxy )
				{
					t_Result = OS::CoImpersonateClient () ;
				}
				else
				{
					t_Result = S_OK ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{

					Increment_ProviderOperation_PutInstanceAsync () ;

					try
					{
						t_Result = a_Service->PutInstanceAsync (

 							a_Instance ,
							a_Flags ,
							t_ContextCopy ,
							t_Sink 
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
				{
					a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{

						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}
				}
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_PutInstanceAsync ( 

						FALSE ,
						a_Instance ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_PutInstanceAsync ( 

								TRUE ,
								a_Instance ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		if ( t_ObjectPath ) 
		{
			CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

				a_Flags ,
				t_ObjectPath ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				m_Exclusion ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{

						Increment_ProviderOperation_DeleteInstanceAsync () ;

						try
						{
							t_Result = a_Service->DeleteInstanceAsync (

 								t_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{

							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									t_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_DeleteInstanceAsync ( 

						FALSE ,
						a_ObjectPath ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_DeleteInstanceAsync ( 

								TRUE ,
								a_ObjectPath ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;

			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

				a_Flags ,
				t_Class ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				m_Exclusion ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}

					t_Result = OS::CoImpersonateClient () ;
					if ( SUCCEEDED ( t_Result ) )
					{

						Increment_ProviderOperation_CreateInstanceEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateInstanceEnumAsync (

 								t_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;


						Increment_ProviderOperation_CreateInstanceEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateInstanceEnumAsync (

 								t_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_Class ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_QueryInstancesAsync (

	IWbemHiPerfProvider *a_PerformanceProvider ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;

			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CInterceptor_IWbemSyncObjectSink *t_Sink = new CInterceptor_IWbemSyncObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			m_Exclusion ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Sink ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				UnLock () ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class ) 
				{
					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}


					Increment_ProviderOperation_QueryInstances () ;

					try
					{
						a_PerformanceProvider->QueryInstances (

							m_CoreStub ,
							a_Class, 
							a_Flags, 
							a_Context, 
							t_Sink
						) ;
					}
					catch ( ... ) 
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;


						Increment_ProviderOperation_QueryInstances () ;

						try
						{
							a_PerformanceProvider->QueryInstances (

								m_CoreStub,
								a_Class, 
								a_Flags, 
								a_Context, 
								t_Sink
							) ;
						}
						catch ( ... ) 
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_CreateInstanceEnumAsync ( 

						FALSE ,
						a_Class ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_CreateInstanceEnumAsync ( 

								TRUE ,
								a_Class ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_QueryInstancesAsync ( 

				m_Provider_IWbemHiPerfProvider ,
				a_Class ,
				a_Flags , 
				a_Context ,
				a_Sink
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
			BSTR t_Query = SysAllocString ( a_Query ) ;

			if ( t_QueryLanguage && t_Query ) 
			{
				CInterceptor_IWbemSyncObjectSink_ExecQueryAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

					a_Flags ,
					t_QueryLanguage ,
					t_Query ,
					this ,
					a_Sink , 
					( IWbemServices * ) this , 
					( CWbemGlobal_IWmiObjectSinkController * ) this ,
					m_Exclusion ,
					t_Dependant
				) ;


				if ( t_Sink )
				{
					t_Sink->AddRef () ;

					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( m_Exclusion ) 
						{
							if ( t_Dependant ) 
							{
								m_Exclusion->GetExclusion ().EnterWrite () ;
							}
							else
							{
								m_Exclusion->GetExclusion ().EnterRead () ;
							}
						}

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{

							Increment_ProviderOperation_ExecQueryAsync () ;

							try
							{
								t_Result = a_Service->ExecQueryAsync (

									t_QueryLanguage ,
									t_Query, 
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

							if ( a_IsProxy )
							{
								t_Result = OS::CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{

								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										t_QueryLanguage ,
										t_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
					}

					t_Sink->Release () ;
				}
				else
				{
					SysFreeString ( t_Query ) ;
					SysFreeString ( t_QueryLanguage ) ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = DecoupledProviderSubSystem_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

									a_Flags ,
									t_Class ,
									this ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									m_Exclusion ,
									t_Dependant
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

									CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

									Lock () ;

									WmiStatusCode t_StatusCode = Insert ( 

										*t_Sink ,
										t_Iterator
									) ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										UnLock () ;

										if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
										{
											a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
										}

										if ( m_Exclusion ) 
										{
											if ( t_Dependant ) 
											{
												m_Exclusion->GetExclusion ().EnterWrite () ;
											}
											else
											{
												m_Exclusion->GetExclusion ().EnterRead () ;
											}
										}

										if ( a_IsProxy )
										{
											t_Result = OS::CoImpersonateClient () ;
										}
										else
										{
											t_Result = S_OK ;
										}

										if ( SUCCEEDED ( t_Result ) )
										{
											a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;


											Increment_ProviderOperation_CreateInstanceEnumAsync () ;

											try
											{
												t_Result = a_Service->CreateInstanceEnumAsync (

 													t_Class ,
													a_Flags ,
													t_ContextCopy ,
													t_Sink 
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}
			
											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}

										if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
										{
											a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

											if ( a_IsProxy )
											{
												t_Result = OS::CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) ) 
											{

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}

									if ( FAILED ( t_Result ) )
									{
										t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_ExecQueryAsync ( 

						FALSE ,
						a_QueryLanguage ,
						a_Query, 
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_ExecQueryAsync ( 

								TRUE ,
								a_QueryLanguage ,
								a_Query, 
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = DecoupledProviderSubSystem_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					HRESULT t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

								t_Result = Helper_QueryInstancesAsync ( 

									m_Provider_IWbemHiPerfProvider ,
									t_Class ,
									a_Flags , 
									a_Context ,
									a_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemSyncProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
		if ( t_ObjectPath && t_MethodName ) 
		{
			CInterceptor_IWbemSyncObjectSink_ExecMethodAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

				a_Flags ,
				t_ObjectPath ,
				t_MethodName ,
				a_InParams ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				m_Exclusion ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( m_Exclusion ) 
					{
						if ( t_Dependant ) 
						{
							m_Exclusion->GetExclusion ().EnterWrite () ;
						}
						else
						{
							m_Exclusion->GetExclusion ().EnterRead () ;
						}
					}

					if ( a_IsProxy )
					{
						t_Result = OS::CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{

						Increment_ProviderOperation_ExecMethodAsync () ;

						try
						{
							t_Result = a_Service->ExecMethodAsync (

 								t_ObjectPath ,
								t_MethodName ,
								a_Flags ,
								t_ContextCopy ,
								a_InParams ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) & ( ~WBEM_FLAG_DIRECT_READ ) ;

						if ( a_IsProxy )
						{
							t_Result = OS::CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{

							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_ExecMethodAsync ( 

						FALSE ,
						a_ObjectPath ,
						a_MethodName ,
						a_Flags ,
						a_Context ,
						a_InParams ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_ExecMethodAsync ( 

								TRUE ,
								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								a_Context ,
								a_InParams ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}

	return t_Result ;
}






/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{

			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CInterceptor_IWbemSyncProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ProvideEvents () ;

				try
				{
					t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ProvideEvents () ;

							try
							{
								t_Result = t_Provider->ProvideEvents (

									a_Sink ,
									a_Flags 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{

				Increment_ProviderOperation_NewQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{

							Increment_ProviderOperation_NewQuery () ;

							try
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
CInterceptor_IWbemSyncProvider::CancelQuery (unsigned long a_Id)
{
  HRESULT t_Result = WBEM_E_PROVIDER_FAILURE ;  
  if (m_Provider_IWbemEventProviderQuerySink != 0)
    {
    BOOL t_Impersonating = FALSE ;  
    IUnknown *t_OldContext = NULL ; 
    IServerSecurity *t_OldSecurity = NULL ; 
    t_Result = DecoupledProviderSubSystem_Globals::BeginImpersonation (t_OldContext, t_OldSecurity, t_Impersonating); 
    if (SUCCEEDED (t_Result))   
      { 
      BOOL t_Revert = FALSE ; 
      IUnknown *t_Proxy = NULL ;	
      t_Result = DecoupledProviderSubSystem_Globals::SetProxyState (m_ProxyContainer, ProxyIndex_IWbemEventProviderQuerySink, IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy, t_Revert); 
      if (t_Result == WBEM_E_NOT_FOUND) 
	{	
	try 
	  {
	  t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (a_Id); 
	  } 
	catch (...) 
	  { 
	  t_Result = WBEM_E_PROVIDER_FAILURE ;  
	  } 
	CoRevertToSelf (); 
	}	
      else 
	{	
	if (SUCCEEDED (t_Result))	
	  { 
	  IWbemEventProviderQuerySink *t_Provider = 0;  
	  t_Result = t_Proxy->QueryInterface (__uuidof(IWbemEventProviderQuerySink), (void**)&t_Provider);  
	  if (SUCCEEDED (t_Result)){ 
  	    DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals::GetCurrentImpersonationLevel (); 
	    t_Result = DecoupledProviderSubSystem_Globals::SetCloaking (t_Provider, RPC_C_AUTHN_LEVEL_CONNECT, t_ImpersonationLevel); 
	    if (SUCCEEDED (t_Result)) 
	      { 
	      t_Result = OS::CoImpersonateClient ();  
	      if (SUCCEEDED (t_Result)) 
		{ 
		try	
		  {	
		  t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (a_Id);	
		  }	
		catch (...)	
		  {	
		  t_Result = WBEM_E_PROVIDER_FAILURE ;  
		  }	
		CoRevertToSelf () ;	
	    } 
	  else  
	    { 
	    t_Result = WBEM_E_ACCESS_DENIED ; 
	    } 
	  } 
	  HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;  
	  t_Proxy->Release(); 
	  } 
	} 
	}	
      DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;	
      } 
      else  
	return t_Result ; 
    } 

    if (SUCCEEDED (t_Result))
      {
      Increment_ProviderOperation_CancelQuery ();
      }
  return t_Result;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{

				Increment_ProviderOperation_AccessCheck () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{

							Increment_ProviderOperation_AccessCheck () ;

							try
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{

				Increment_ProviderOperation_SetRegistrationObject () ;

				try
				{
					t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

						a_Flags ,
						a_ProviderRegistration
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_SetRegistrationObject () ;

							try
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{

				Increment_ProviderOperation_FindConsumer () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						a_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = OS::CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{

							Increment_ProviderOperation_FindConsumer () ;

							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									a_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::QueryInstances (

	IWbemServices *a_Namespace ,
	WCHAR *a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{

			Increment_ProviderOperation_QueryInstances () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->QueryInstances (

					a_Namespace ,
					a_Class ,
					a_Flags ,
					a_Context ,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefresher (

	IWbemServices *a_Namespace ,
	long a_Flags ,
	IWbemRefresher **a_Refresher
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			
			Increment_ProviderOperation_CreateRefresher () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefresher (

					a_Namespace ,
					a_Flags ,
					a_Refresher
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
} 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefreshableObject (

	IWbemServices *a_Namespace ,
	IWbemObjectAccess *a_Template ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectAccess **a_Refreshable ,
	long *a_Id
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{

			Increment_ProviderOperation_CreateRefreshableObject () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefreshableObject (

					a_Namespace ,
					a_Template ,
					a_Refresher ,
					a_Flags ,
					a_Context ,
					a_Refreshable ,
					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::StopRefreshing (

	IWbemRefresher *a_Refresher ,
	long a_Id ,
	long a_Flags
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			
			Increment_ProviderOperation_StopRefreshing () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->StopRefreshing (

					a_Refresher ,
					a_Id ,
					a_Flags
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefreshableEnum (

	IWbemServices *a_Namespace ,
	LPCWSTR a_Class ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemHiPerfEnum *a_HiPerfEnum ,
	long *a_Id
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			
			Increment_ProviderOperation_CreateRefreshableEnum () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefreshableEnum (

					a_Namespace ,
					a_Class ,
					a_Refresher ,
					a_Flags ,
					a_Context ,
					a_HiPerfEnum ,
					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::GetObjects (

	IWbemServices *a_Namespace ,
	long a_ObjectCount ,
	IWbemObjectAccess **a_Objects ,
	long a_Flags ,
	IWbemContext *a_Context
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			
			Increment_ProviderOperation_GetObjects () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->GetObjects (

					a_Namespace ,
					a_ObjectCount ,
					a_Objects ,
					a_Flags ,
					a_Context
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_Service ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Provider_IWbemServices )
	{
		t_Result = m_Provider_IWbemServices->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = OS::CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		IWbemShutdown *t_TempShutdown = NULL ;
		t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_TempShutdown ) ;

		t_Iterator.Increment () ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_TempShutdown->Shutdown ( 

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_TempShutdown->Release () ;
		}
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	UnLock () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provwsvs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsvS.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Stub :: CInterceptor_IWbemServices_Stub (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service 

) : m_ReferenceCount ( 0 ) , 
	m_CoreService ( a_Service ) ,
	m_RefreshingService ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_ProxyContainer ( a_Allocator , 3 , MAX_PROXIES ),
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;

	HRESULT t_Result = m_CoreService->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_RefreshingService ) ;

	m_CoreService->AddRef () ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Stub :: ~CInterceptor_IWbemServices_Stub ()
{

	if ( m_CoreService )
	{
		m_CoreService->Release () ; 
	}

	if ( m_RefreshingService )
	{
		m_RefreshingService->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress)  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: AddRef ( void )
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: Release ( void )
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Stub :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = static_cast<IWbemServices *>(this) ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = static_cast<IWbemServices *>(this) ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = static_cast<IWbemRefreshingServices *>(this) ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = static_cast<IWbemShutdown *>(this) ;		
	}	

	if ( *iplpv )
	{
		reinterpret_cast<IUnknown*>(*iplpv)->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->OpenNamespace (

					a_ObjectPath, 
					a_Flags, 
					a_Context ,
					a_NamespaceService, 
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->OpenNamespace (

							a_ObjectPath, 
							a_Flags, 
							a_Context ,
							a_NamespaceService, 
							a_CallResult
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CancelAsyncCall (

					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->CancelAsyncCall (

							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->QueryObjectSink (

					a_Flags,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->QueryObjectSink (

							a_Flags,
							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->GetObject (

					a_ObjectPath,
					a_Flags,
					a_Context ,
					a_Object,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( a_ObjectPath )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_Service->GetObject (

									t_ObjectPath,
									a_Flags,
									a_Context ,
									a_Object,
									a_CallResult
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = t_Service->GetObject (

								a_ObjectPath,
								a_Flags,
								a_Context ,
								a_Object,
								a_CallResult
							) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->GetObjectAsync (

					a_ObjectPath, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						if ( t_ObjectPath )
						{
							t_Result = t_Service->GetObjectAsync (

								t_ObjectPath, 
								a_Flags, 
								a_Context ,
								a_Sink
							) ;

							SysFreeString ( t_ObjectPath ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutClass (

					a_Object, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutClass (

							a_Object, 
							a_Flags, 
							a_Context,
							a_CallResult
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutClassAsync (

					a_Object, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutClassAsync (

							a_Object, 
							a_Flags, 
							a_Context ,
							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteClass (

					a_Class, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->DeleteClass (

								t_Class, 
								a_Flags, 
								a_Context,
								a_CallResult
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteClassAsync (

					a_Class , 
					a_Flags , 
					a_Context ,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->DeleteClassAsync (

								t_Class , 
								a_Flags , 
								a_Context ,
								a_Sink
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateClassEnum (

					a_Superclass, 
					a_Flags, 
					a_Context,
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
						if ( t_Superclass )
						{
							t_Result = t_Service->CreateClassEnum (

								t_Superclass, 
								a_Flags, 
								a_Context,
								a_Enum
							) ;

							SysFreeString ( t_Superclass ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_Stub :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateClassEnumAsync (

					a_Superclass, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
						if ( t_Superclass )
						{
							t_Result = t_Service->CreateClassEnumAsync (

								t_Superclass, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;

							SysFreeString ( t_Superclass ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutInstance (

					a_Instance,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutInstance (

							a_Instance,
							a_Flags,
							a_Context,
							a_CallResult
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->PutInstanceAsync (

					a_Instance, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Service->PutInstanceAsync (

							a_Instance, 
							a_Flags, 
							a_Context,
							a_Sink
						) ;
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteInstance (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						if ( t_ObjectPath )
						{
							t_Result = t_Service->DeleteInstance (

								t_ObjectPath,
								a_Flags,
								a_Context,
								a_CallResult
							) ;

							SysFreeString ( t_ObjectPath ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->DeleteInstanceAsync (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						if ( t_ObjectPath )
						{
							t_Result = t_Service->DeleteInstanceAsync (

								t_ObjectPath,
								a_Flags,
								a_Context,
								a_Sink
							) ;

							SysFreeString ( t_ObjectPath ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateInstanceEnum (

					a_Class, 
					a_Flags, 
					a_Context, 
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->CreateInstanceEnum (

								t_Class, 
								a_Flags, 
								a_Context, 
								a_Enum
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->CreateInstanceEnumAsync (

 					a_Class, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( a_Class ) ;
						if ( t_Class )
						{
							t_Result = t_Service->CreateInstanceEnumAsync (

 								a_Class, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;

							SysFreeString ( t_Class ) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecQuery (

					a_QueryLanguage, 
					a_Query, 
					a_Flags, 
					a_Context,
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecQuery (

								t_QueryLanguage, 
								t_Query, 
								a_Flags, 
								a_Context,
								a_Enum
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecQueryAsync (

					a_QueryLanguage, 
					a_Query, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecQueryAsync (

								t_QueryLanguage, 
								t_Query, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecNotificationQuery (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Enum
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecNotificationQuery (

								t_QueryLanguage,
								t_Query,
								a_Flags,
								a_Context,
								a_Enum
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecNotificationQueryAsync (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
						BSTR t_Query = SysAllocString ( a_Query ) ;
						if ( t_QueryLanguage && t_Query )
						{
							t_Result = t_Service->ExecNotificationQueryAsync (

								t_QueryLanguage,
								t_Query,
								a_Flags,
								a_Context,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_QueryLanguage )
						{
							SysFreeString ( t_QueryLanguage ) ;
						}

						if ( t_Query )
						{
							SysFreeString ( t_Query ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Stub :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecMethod (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_OutParams,
					a_CallResult
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
						if ( t_ObjectPath && t_MethodName )
						{
							t_Result = t_Service->ExecMethod (

								t_ObjectPath,
								t_MethodName,
								a_Flags,
								a_Context,
								a_InParams,
								a_OutParams,
								a_CallResult
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_ObjectPath )
						{
							SysFreeString ( t_ObjectPath ) ;
						}

						if ( t_MethodName )
						{
							SysFreeString ( t_MethodName ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Stub :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServices , m_CoreService , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_CoreService->ExecMethodAsync (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Co